{
    "username": "pyjuan91",
    "submission": "class Solution {\nprivate:\n  pair<int, int> bfs(int start, const vector<vector<int>>& adj) {\n    int n = adj.size();\n    vector<int> dist(n, -1);\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n\n    int farthest_node = start, max_dist = 0;\n\n    while (!q.empty()) {\n      int node = q.front();\n      q.pop();\n      for (int neighbor : adj[node]) {\n        if (dist[neighbor] == -1) {\n          dist[neighbor] = dist[node] + 1;\n          q.push(neighbor);\n          if (dist[neighbor] > max_dist) {\n            max_dist = dist[neighbor];\n            farthest_node = neighbor;\n          }\n        }\n      }\n    }\n\n    return { farthest_node, max_dist };\n  }\n\n  int treeDiameter(const vector<vector<int>>& adj) {\n    auto [farthest_node, _] = bfs(0, adj);\n    auto [__, diameter] = bfs(farthest_node, adj);\n    return diameter;\n  }\n\n  int findMinDiameter(int n, const vector<vector<int>>& adj1, int m, const vector<vector<int>>& adj2) {\n    int d1 = treeDiameter(adj1);\n    int d2 = treeDiameter(adj2);\n\n    return max({ d1, d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1 });\n  }\n\npublic:\n  int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n    int n = edges1.size() + 1, m = edges2.size() + 1;\n    vector<vector<int>> tree1(n), tree2(m);\n    for (auto& edge : edges1) {\n      tree1[edge[0]].push_back(edge[1]);\n      tree1[edge[1]].push_back(edge[0]);\n    }\n    for (auto& edge : edges2) {\n      tree2[edge[0]].push_back(edge[1]);\n      tree2[edge[1]].push_back(edge[0]);\n    }\n\n\n    return findMinDiameter(n, tree1, m, tree2);\n  }\n};",
    "submit_ts": 1719718908.0
}