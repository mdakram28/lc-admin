{
    "username": "user0747oJ",
    "submission": "class Solution {\n    fun minimumDiameterAfterMerge(edges1: Array<IntArray>, edges2: Array<IntArray>): Int {\n        val g1 = build(edges1)\n        val g2 = build(edges2)\n\n        val d1 = diameter(g1)\n        val d2 = diameter(g2)\n\n        return max((d1 + 1) / 2 + (d2 + 1) / 2 + 1, max(d1, d2))\n    }\n\n    private fun build(edges: Array<IntArray>): List<List<Int>> {\n        val g = List(edges.size + 1) { mutableListOf<Int>() }\n\n        for ((u, v) in edges) {\n            g[u] += v\n            g[v] += u\n        }\n\n        return g\n    }\n\n    private fun diameter(g: List<List<Int>>): Int {\n        val d0 = bfs(g, 0)\n        val u = g.indices.maxBy { d0[it] }\n        val du = bfs(g, u)\n\n        return du.max()\n    }\n\n    private fun bfs(g: List<List<Int>>, u: Int): IntArray {\n        val d = IntArray(g.size) { -1 }\n        val q = ArrayDeque<Int>()\n        var level = 0\n\n        q += u\n        while (q.isNotEmpty()) {\n            repeat(q.size) {\n                val v = q.removeFirst()\n                if (d[v] < 0) {\n                    d[v] = level\n                    for (next in g[v]) {\n                        if (d[next] >= 0) continue\n\n                        q += next\n                    }\n                }\n            }\n\n            level++\n        }\n\n        return d\n    }\n}",
    "submit_ts": "1719718393",
    "subm_id": "1304416109"
}