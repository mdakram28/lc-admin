{
    "username": "non_deterministic",
    "submission": "#define lld long long\n#define rep(i,a,n) for(lld i = (a); i <= (n); ++i)\n#define repI(i,a,n) for(int i = (a); i <= (n); ++i)\n#define repD(i,a,n) for(lld i = (a); i >= (n); --i)\n#define repDI(i,a,n) for(int i = (a); i >= (n); --i)\n#define all(c) (c).begin(), (c).end()\n#define sz(a) ((int)a.size())\n\n#define Error(x...) { cout << \"(\" << #x << \")\" << \" = ( \"; printIt(x); }\ntemplate <typename T1> void printIt(T1 t1) { cout << t1 << \" )\" << endl; }\ntemplate <typename T1, typename... T2>\nvoid printIt(T1 t1, T2... t2) { cout << t1 << \" , \"; printIt(t2...); }\n#define errorpair(a) cout<<#a<<\" = ( \"<<((a).first)<<\" , \"<<((a).second)<<\" )\\n\";\n\nstruct UF {\n    UF(int n) {\n        A.resize(n + 1);\n        Sz.resize(n + 1);\n        for(int i = 1; i <= n; i++) A[i] = i, Sz[i] = 1;\n    }\n \n    int root(int a) {\n        while(a != A[a]) {\n            A[a] = A[A[a]];\n            a = A[a];\n        }\n        return a;\n    }\n \n    lld merge(int a, int b) {\n        int par_a = root(a);\n        int par_b = root(b);\n        if(par_a != par_b) {\n            A[par_b] = par_a;\n            Sz[par_a] += Sz[par_b];\n            return 1;\n        }\n        return 0;\n    }\n    vector<int> A, Sz;\n};\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n        UF uf(n + 4);\n        repI(i, 0, n - 1) {\n            auto cx = circles[i][0];\n            auto cy = circles[i][1];\n            auto r = circles[i][2];\n            if(cx - r <= 0) uf.merge(i + 1, n + 1);\n            if(cx + r >= X) uf.merge(i + 1, n + 2);\n            if(cy - r <= 0) uf.merge(i + 1, n + 3);\n            if(cy + r >= Y) uf.merge(i + 1, n + 4);\n            repI(j, i + 1, n - 1) {\n                lld cx2 = circles[j][0];\n                lld cy2 = circles[j][1];\n                lld r2 = circles[j][2];\n                if((cx - cx2) * (cx - cx2) + (cy - cy2) * (cy - cy2) <= (r + r2) * (r + r2)) {\n                    uf.merge(i + 1, j + 1);\n                }\n            }\n        }\n        // repI(i, 1, 4) {\n        //     Error(i, uf.root(n + i));\n        // }\n        bool pathExists = true;\n        if(uf.root(n + 1) == uf.root(n + 2) || uf.root(n + 3) == uf.root(n + 4)) pathExists = false;\n        if(uf.root(n + 1) == uf.root(n + 3) || uf.root(n + 2) == uf.root(n + 4)) pathExists = false;\n        return pathExists;\n    }\n};",
    "submit_ts": "1722136427",
    "subm_id": "1335734143"
}