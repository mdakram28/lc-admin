{
    "username": "boolbool",
    "submission": "\n\nstruct SegTree {\n    int n;\n    vector<int> arr, tree, lazy;\n    SegTree(int n_) {\n        n = n_;\n        arr.resize(n, 0);\n        for(int i = 0; i < arr.size(); i++) {\n            arr[i] = i;\n        }\n        tree.resize(4 * n + 5, 0);\n        lazy.resize(4 * n + 5, 0);\n    }\n \n    void build_tree(int node, int a, int b) {\n        if(a > b) return; // Out of range\n        \n        if(a == b) { // Leaf node\n                tree[node] = arr[a]; // Init value\n            return;\n        }\n        \n        build_tree(node*2, a, (a+b)/2); // Init left child\n        build_tree(node*2+1, 1+(a+b)/2, b); // Init right child\n        \n        tree[node] = max(tree[node*2], tree[node*2+1]); // Init root value\n    }\n\n    void update_tree(int node, int a, int b, int i, int j, int value) {\n  \n        if(lazy[node] != 0) { // This node needs to be updated\n            tree[node] += lazy[node]; // Update it\n\n            if(a != b) {\n                lazy[node*2] += lazy[node]; // Mark child as lazy\n                    lazy[node*2+1] += lazy[node]; // Mark child as lazy\n            }\n\n            lazy[node] = 0; // Reset it\n        }\n      \n        if(a > b || a > j || b < i) // Current segment is not within range [i, j]\n            return;\n        \n        if(a >= i && b <= j) { // Segment is fully within range\n                tree[node] += value;\n\n            if(a != b) { // Not leaf node\n                lazy[node*2] += value;\n                lazy[node*2+1] += value;\n            }\n\n                return;\n        }\n\n        update_tree(node*2, a, (a+b)/2, i, j, value); // Updating left child\n        update_tree(1+node*2, 1+(a+b)/2, b, i, j, value); // Updating right child\n\n        tree[node] = max(tree[node*2], tree[node*2+1]); // Updating root with max value\n    }\n\n    int query_tree(int node, int a, int b, int i, int j) {\n    \n        if(a > b || a > j || b < i) return -1e5; // Out of range\n\n        if(lazy[node] != 0) { // This node needs to be updated\n            tree[node] += lazy[node]; // Update it\n\n            if(a != b) {\n                lazy[node*2] += lazy[node]; // Mark child as lazy\n                lazy[node*2+1] += lazy[node]; // Mark child as lazy\n            }\n\n            lazy[node] = 0; // Reset it\n        }\n\n        if(a >= i && b <= j) // Current segment is totally within range [i, j]\n            return tree[node];\n\n        int q1 = query_tree(node*2, a, (a+b)/2, i, j); // Query left child\n        int q2 = query_tree(1+node*2, 1+(a+b)/2, b, i, j); // Query right child\n\n        int res = max(q1, q2); // Return final result\n        \n        return res;\n    }\n\n};\n\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n\n        int N = 1e5;\n        SegTree st(N);\n        st.build_tree(1, 0, N-1);\n\n        multiset<int> s;\n        s.insert(0);\n        s.insert(N - 5);\n\n        vector<bool> a;\n        for(auto i : queries) {\n            if(i.size() == 2) {\n                int x = i[1];\n                auto it = s.upper_bound(x);\n                int L, R;\n                R = *it;\n                it--;\n                L = *it;\n                s.insert(x);\n                st.update_tree(1, 0, N-1, x + 1, R, -(x - L));\n            } else {\n                int x = st.query_tree(1, 0, N-1, 0, i[1]);\n                if(x >= i[2]) {\n                    a.push_back(true);\n                } else {\n                    a.push_back(false);\n                }\n            }\n        }\n        return a;\n    }\n};\n",
    "submit_ts": "1716652346",
    "subm_id": "1267661537"
}