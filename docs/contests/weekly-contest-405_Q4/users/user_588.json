{
    "username": "profchi",
    "submission": "class Solution {\n    \n    Random rand = new Random();\n    \n    public int minimumCost(String target, String[] words, int[] costs) {\n        int mod = 1_000_000_017;\n        int mul = 30 + rand.nextInt(10);\n        \n        RollingHash hashes = RollingHash.getHashFromString(target, mul, mod);\n        \n        Map<Integer, Integer> [] costMap = new Map[target.length() + 1];\n        \n        Map<Integer, Map<Integer, Integer> > [] hashCost = new Map[3];\n        Map<Integer, Integer> map;\n        int hash, length;\n        \n        Set<Integer> keys = new HashSet<>();\n        \n        for (int j = 0; j < words.length; ++j) {\n            RollingHash temp = RollingHash.getHashFromString(words[j], mul, mod);\n            hash = (int)temp.getHash(0, words[j].length() - 1);\n            length = words[j].length();\n            keys.add(length);\n\n            if (costMap[length] == null)\n                costMap[length] = new HashMap<>();\n\n            \n            costMap[length].put(hash, Math.min(costMap[length].getOrDefault(hash, 1_000_000), costs[j]));\n        }\n        \n        \n        List<Integer> distinct = new ArrayList<>(keys);\n        Collections.sort(distinct);\n        \n        int [] dp = new int [target.length() + 1];\n        \n        Arrays.fill(dp, -1);\n        dp[0] = 0;\n        \n        Map<Integer, Integer> cMap;\n        \n        for (int i = 0; i < target.length(); ++i) {\n            \n            for (int l : distinct) {\n                if (i + l > target.length())\n                    break;\n                else if (dp[i] < 0)\n                    continue;\n                \n                \n                hash = (int)hashes.getHash(i, i + l - 1);\n                \n                if (costMap[l].containsKey(hash)) {\n                    int newVal = costMap[l].get(hash) + dp[i];\n                    dp[i + l] = dp[i + l] < 0 ? newVal : Math.min(newVal, dp[i + l]);\n                }\n            }\n        }\n        \n        \n        return dp[target.length()];\n    }\n}\n\nclass RollingHash {\n\t\n\tlong [] mArr;\n\tlong [] forwardArr;\n\tlong [] backArr;\n\t\n\tint [] requestArr;\n\tint reqMul;\n\t\n\tlong mod;\n\t\n\t// lower case alpha\n\tpublic static RollingHash getHashFromString(String s, int mul, int mod) {\n\t\tint [] arr = new int[s.length()];\n\t\t\n\t\tfor (int i = 0; i < s.length(); ++i) {\n\t\t\tarr[i] = s.charAt(i) - 'a';\n\t\t}\n\t\t\n\t\treturn new RollingHash(arr, mul, mod);\n\t}\n\t\n\t// zero indexex\n\tpublic RollingHash(int [] arr, int mul, int mod) {\n\t\t\n\t\tlong cHash = 0;\n\t\tlong mHash = 1;\n\t\t\n\t\tmArr = new long [arr.length + 1];\n\t\tforwardArr = new long [arr.length];\n\t\tbackArr = new long [arr.length];\n\t\t\n\t\tthis.mod = mod;\n\t\tthis.requestArr = arr;\n\t\tthis.reqMul = mul;\n\t\t\n\t\tmArr[0] = 1;\n\t\t\n\t\tfor (int i = 0; i < arr.length; ++i) {\n\t\t\tcHash *= mul;\n\t\t\tcHash += arr[i];\n\t\t\tcHash %= mod;\n\t\t\t\n\t\t\tforwardArr[i] = cHash;\n\t\t\t\n\t\t\tmHash *= mul;\n\t\t\tmHash %= mod;\n\t\t\t\n\t\t\tmArr[i + 1] = mHash;\n\t\t}\n\t\t\n\t\tcHash = 0;\n\t\t\n\t\tfor (int i = arr.length - 1; i >= 0; --i) {\n\t\t\tcHash *= mul;\n\t\t\tcHash += arr[i];\n\t\t\tcHash %= mod;\n\t\t\t\n\t\t\tbackArr[i] = cHash;\n\t\t}\n\t}\n\t\n\t// abcdefg\n\t// def - abcdef - abc * 3\n\t\n\tpublic long getHash(int from, int to) {\n\t\tlong result;\n\t\tint prev;\n\t\t\n\t\tif (to >= from) {\n\t\t\tresult = forwardArr[to];\n\t\t\tprev = from - 1;\n\t\t\t\n\t\t\tlong sub = prev == -1 ? 0 : forwardArr[prev];\n\t\t\tsub *= mArr[to - prev];\n\t\t\tsub %= mod;\n\t\t\t\n\t\t\tresult += mod;\n\t\t\tresult -= sub;\n\t\t\tresult %= mod;\n\t\t}else {\n\t\t\tresult = backArr[to];\n\t\t\tprev = from + 1;\n\t\t\t\n\t\t\tlong sub = prev == backArr.length ? 0 : backArr[prev];\n\t\t\tsub *= mArr[prev - to];\n\t\t\tsub %= mod;\n\t\t\t\n\t\t\tresult += mod;\n\t\t\tresult -= sub;\n\t\t\tresult %= mod;\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\tpublic long getHashBruteForce(int from, int to) {\n\t\tlong result = 0;\n\t\t\n\t\tint diff = from >= to ? -1 : 1;\n\t\t\n\t\tresult = requestArr[from];\n\t\tint idx = from;\n\t\t\n\t\twhile (idx != to) {\n\t\t\tidx += diff;\n\t\t\tresult *= reqMul;\n\t\t\tresult += requestArr[idx];\n\t\t\tresult %= mod;\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n}\n",
    "submit_ts": "1720322511",
    "subm_id": "1312351869"
}