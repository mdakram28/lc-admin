{
    "username": "Manan04",
    "submission": "from bisect import bisect_left as lower_bound\nfrom bisect import bisect_right as upper_bound\n\n\nclass FenwickTree:\n    def __init__(self, x):\n        bit = self.bit = list(x)\n        size = self.size = len(bit)\n        for i in range(size):\n            j = i | (i + 1)\n            if j < size:\n                bit[j] += bit[i]\n\n    def update(self, idx, x):\n        \"\"\"updates bit[idx] += x\"\"\"\n        while idx < self.size:\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def __call__(self, end):\n        \"\"\"calc sum(bit[:end])\"\"\"\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\n    def find_kth(self, k):\n        \"\"\"Find largest idx such that sum(bit[:idx]) <= k\"\"\"\n        idx = -1\n        for d in reversed(range(self.size.bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < self.size and self.bit[right_idx] <= k:\n                idx = right_idx\n                k -= self.bit[idx]\n        return idx + 1, k\n\n\nclass SortedList:\n    block_size = 700\n\n    def __init__(self, iterable=()):\n        self.macro = []\n        self.micros = [[]]\n        self.micro_size = [0]\n        self.fenwick = FenwickTree([0])\n        self.size = 0\n        for item in iterable:\n            self.insert(item)\n\n    def insert(self, x):\n        i = lower_bound(self.macro, x)\n        j = upper_bound(self.micros[i], x)\n        self.micros[i].insert(j, x)\n        self.size += 1\n        self.micro_size[i] += 1\n        self.fenwick.update(i, 1)\n        if len(self.micros[i]) >= self.block_size:\n            self.micros[i:i + 1] = self.micros[i][:self.block_size >> 1], self.micros[i][self.block_size >> 1:]\n            self.micro_size[i:i + 1] = self.block_size >> 1, self.block_size >> 1\n            self.fenwick = FenwickTree(self.micro_size)\n            self.macro.insert(i, self.micros[i + 1][0])\n\n    def pop(self, k=-1):\n        i, j = self._find_kth(k)\n        self.size -= 1\n        self.micro_size[i] -= 1\n        self.fenwick.update(i, -1)\n        return self.micros[i].pop(j)\n\n    def __getitem__(self, k):\n        i, j = self._find_kth(k)\n        return self.micros[i][j]\n\n    def count(self, x):\n        return self.upper_bound(x) - self.lower_bound(x)\n\n    def __contains__(self, x):\n        return self.count(x) > 0\n\n    def lower_bound(self, x):\n        i = lower_bound(self.macro, x)\n        return self.fenwick(i) + lower_bound(self.micros[i], x)\n\n    def upper_bound(self, x):\n        i = upper_bound(self.macro, x)\n        return self.fenwick(i) + upper_bound(self.micros[i], x)\n\n    def _find_kth(self, k):\n        return self.fenwick.find_kth(k + self.size if k < 0 else k)\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return (x for micro in self.micros for x in micro)\n\n    def __repr__(self):\n        return str(list(self))\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, q: List[List[int]]) -> List[int]:\n        l = SortedList()\n        for i in range(n):\n            l.insert(i)\n        ans = []\n        for u, v in q:\n            helper = []\n            idx = l.lower_bound(u + 1)\n            while idx < len(l) and l[idx] < v:\n                val = l[idx]\n                helper.append(val)\n                idx += 1\n            while helper:\n                val = helper.pop()\n                idx = l.lower_bound(val)\n                l.pop(idx)\n            ans.append(len(l) - 1)\n        return ans",
    "submit_ts": "1722739649",
    "subm_id": "1343699692"
}