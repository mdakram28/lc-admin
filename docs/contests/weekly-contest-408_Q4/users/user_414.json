{
    "username": "unknown_ajay",
    "submission": "\n/*\n \n File   : Leetcode.cpp\n -------------------\n |   Hello         |\n |   DSA !         |\n -------------------\n \n */\n\n#define mii map<int,int>\n#define vi vector<int>\n#define vs vector<string>\n#define vb vector<bool>\n#define pii pair<int,int>\n#define endl \"\\n\"\n#define intmax INT_MAX\n#define intmin INT_MIN\n#define need_for_speed ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define ff(i,a,b) for(int i=a;i<b;i++)\n#define rfor(i,a,b) for(int i=a;i>=b;i--)\n#define all(x) x.begin(),x.end()\n#define pt(x) { cout<<x<<\"\\n\"; }\n#define fs first.second\n#define ss second.second\n#define countofSet(x) __builtin_popcount(x)\n#define pb push_back\n#define fir first\n#define sec second\n#define sqrt(x) sqrtl(x)\n\nstruct node\n{\n    int x;\n    int y;\n    int r;\n};\n\nbool canReach(vector<vector<int>> &adj, int st, int T1, int T2, int N)\n{\n    vector<int> vis(N + 4, 0);\n    queue<int> q;\n    vis[st] = 1;\n    q.push(st);\n    \n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) \n        {\n            if (vis[v]) continue;\n            q.push(v);\n            vis[v] = 1;\n        }\n    }\n    \n    bool ok = vis[T1] || vis[T2];\n    return ok;\n}\n\nclass Solution {\npublic:\n    \n    bool canReachCorner(int X, int Y, vector<vector<int>>& C)\n    {\n        int M = (int)C.size();\n        vector<vector<int>> adj(M+5);\n        \n        ff(i,0,M)\n        {\n            if (C[i][0] <= C[i][2])\n            {\n                adj[M].push_back(i);\n                adj[i].push_back(M);\n            }\n            \n            if (C[i][1] <= C[i][2])\n            {\n                adj[M + 1].push_back(i);\n                adj[i].push_back(M + 1);\n            }\n            \n            if (X - C[i][0] <= C[i][2])\n            {\n                adj[M + 2].push_back(i);\n                adj[i].push_back(M + 2);\n            }\n            \n            if (Y - C[i][1] <= C[i][2])\n            {\n                adj[M + 3].push_back(i);\n                adj[i].push_back(M + 3);\n            }\n            \n            ff(j,i+1,M)\n            {\n                double dis = sqrt(pow(C[i][0] - C[j][0],2) + pow(C[i][1] - C[j][1], 2));\n                if (C[i][2] + C[j][2] >= dis) \n                {\n                    adj[i].push_back(j);\n                    adj[j].push_back(i);\n                }\n            }\n        }\n        \n        bool ok = 0;\n        ok |= canReach(adj, M, M + 1, M + 2, M);\n        ok |= canReach(adj, M + 3, M + 1, M + 2, M);\n        return !ok;\n    }\n};",
    "submit_ts": "1722137649",
    "subm_id": "1335769806"
}