{
    "username": "Prajjawal_Agrahari",
    "submission": "class Solution {\npublic:\n     int findMinHeightTrees(int n, vector<vector<int>>& edges) \n     {\n        if(n==1)\n            return 0;\n        vector<int>res;\n        vector<int>degrees(n,0);\n        vector<vector<int>>adj(n);\n        for(int i=0;i<edges.size();i++)\n        {\n            adj[edges[i][0]].push_back(edges[i][1]);\n            adj[edges[i][1]].push_back(edges[i][0]);\n            degrees[edges[i][1]]++;\n            degrees[edges[i][0]]++;\n        }\n        queue<int>queue;\n        for(int i=0;i<n;i++)\n        {\n            if(degrees[i]==1)\n                queue.push(i);\n        }\n        while(!queue.empty())\n        {\n            res.clear();\n            int size=queue.size();\n            for(int i=0;i<size;i++)\n            {\n                int cur=queue.front();\n                queue.pop();\n                res.push_back(cur);\n                for(auto &neighbor:adj[cur])\n                {\n                    degrees[neighbor]--;\n                    if(degrees[neighbor]==1)\n                        queue.push(neighbor);\n                }\n            }\n        }\n         \n        function<int(int, int)> calc = [&](int u, int p) -> int\n        {\n            int height = 0;\n            for(auto &v : adj[u])\n            {\n                if(v == p)\n                {\n                    continue;\n                }\n                int h1 = calc(v, u);\n                height = max(height, h1+1);\n            }\n            return height;\n        };\n        return calc(res[0], -1);\n        \n    }\n    \n    void dfsA(int u, int p, vector<int> &d1, vector<vector<int>> &adj)\n    {\n        if (p != (-1))\n        {\n            d1[u] = 1 + d1[p];\n        }\n        for (auto &v : adj[u])\n        {\n            if (v != p)\n            {\n                dfsA(v, u, d1, adj);\n            }\n        }\n    }\n    \n    int findDiameter(int n, vector<vector<int>> &edges)\n    {\n        vector<vector<int>>adj(n);\n        for(int i=0;i<edges.size();i++)\n        {\n            adj[edges[i][0]].push_back(edges[i][1]);\n            adj[edges[i][1]].push_back(edges[i][0]);\n        }\n\n        vector<int> d1(n);\n\n        int mx1 = 0;\n        dfsA(mx1, -1, d1, adj);\n        for(int i = 0; i < n; ++i)\n        {\n            if (d1[i] > d1[mx1])\n            {\n                mx1 = i;\n            }\n        }\n\n        vector<int> d2(n);\n        dfsA(mx1, -1, d2, adj);\n        int mx2 = mx1;\n        for(int i = 0; i < n; ++i)\n        {\n            if (d2[i] > d2[mx2])\n            {\n                mx2 = i;\n            }\n        }\n\n        // dfs(1, -1, 1);\n        return d2[mx2];\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) \n    {\n        int n = edges1.size();\n        n += 1;\n        int m = edges2.size();\n        m += 1;\n        int add1 = findMinHeightTrees(n, edges1);\n        int add2 = findMinHeightTrees(m, edges2);\n        int ans = (add1 + add2 + 1);\n        int v1 = findDiameter(n, edges1);\n        int v2 = findDiameter(m, edges2);\n        ans = max(ans, v1);\n        ans = max(ans, v2);\n        return ans;\n    }\n};",
    "submit_ts": "1719719832",
    "subm_id": "1304451689"
}