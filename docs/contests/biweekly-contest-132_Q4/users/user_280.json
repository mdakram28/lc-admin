{
    "username": "EUqr2c2cjD8nuX5K",
    "submission": "class Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {\n        const int n = nums.size();\n        \n        set<int> s(nums.begin(), nums.end());\n        map<int, int> m;\n        int next = 0;\n        for (auto& x : s) m[x] = next++;\n        \n        auto update = [&](vector<int>& t, int index, int val) {\n            index += n;\n            t[index] = max(t[index], val);\n            index >>= 1;\n            while (index) {\n                t[index] = max(t[index * 2], t[index * 2 + 1]);\n                index >>= 1;\n            }\n        };\n        auto query = [&](vector<int>& t, int a, int b) {\n            int max_val = INT_MIN;\n            a += n, b += n;\n            while (a <= b) {\n                if (a & 1) {\n                    max_val = max(max_val, t[a]);\n                    ++a;\n                }\n                if (!(b & 1)) {\n                    max_val = max(max_val, t[b]);\n                    --b;\n                }\n                a >>= 1, b >>= 1;\n            }\n            return max_val;\n        };\n\n    \n\n        vector dp(n, vector(k + 1, 0));\n        // dp[i][c]: The longest for ending at nums[i] and containing == c qualifying indices (must be true: c <= i)\n        \n        for (int c = 0; c <= k; ++c) {\n            vector<int> PREV(n * 2, INT_MIN);\n            vector<int> CUR(n * 2, INT_MIN);\n            \n            for (int i = 0; i < n; ++i) {\n                dp[i][c] = c == 0 ? 1 : 0;\n                \n                /*\n                for (int prev = 0; prev < i; ++prev) {\n                    if (nums[i] == nums[prev])\n                        dp[i][c] = max(dp[i][c], dp[prev][c] + 1);\n                    else if (c > 0)\n                        dp[i][c] = max(dp[i][c], dp[prev][c - 1] + 1);\n                }\n                */\n                \n                {\n                    int tmp = query(CUR, m[nums[i]], m[nums[i]]);\n                    if (tmp + 1 > dp[i][c])\n                        dp[i][c] = tmp + 1;\n                }\n                if (0 <= m[nums[i]] - 1) {\n                    int tmp = query(PREV, 0, m[nums[i]] - 1);\n                    if (tmp + 1 > dp[i][c])\n                        dp[i][c] = tmp + 1;\n                }\n                if (m[nums[i]] + 1 <= next - 1) {\n                    int tmp = query(PREV, m[nums[i]] + 1, next - 1);\n                    if (tmp + 1 > dp[i][c])\n                        dp[i][c] = tmp + 1;\n                }\n                \n                if (c > 0)\n                    update(PREV, m[nums[i]], dp[i][c - 1]);\n                update(CUR, m[nums[i]], dp[i][c]);\n            }\n        }\n        \n        int res = 0;\n        for (int i = 0; i < n; ++i)\n            for (int c = 0; c <= k; ++c)\n                res = max(res, dp[i][c]);\n        return res;\n        \n    }\n};",
    "submit_ts": "1717860875",
    "subm_id": "1281772300"
}