{
    "username": "apometta",
    "submission": "class Solution {\nprivate:\n    static inline double dist(int x1, int y1, int x2, int y2) {\n        long long xdiff = x2 - x1, ydiff = y2 - y1;\n        return sqrt(xdiff * xdiff + ydiff * ydiff);\n    }\n\n    static inline bool intersecting(int x1, int y1, int r1, int x2, int y2, int r2) {\n        return dist(x1, y1, x2, y2) <= r1 + (long long) r2;\n    }\n\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        vector<vector<int>> relevants;\n        for (int i = 0; i < circles.size(); i++) {\n            int cx = circles[i][0], cy = circles[i][1], cr = circles[i][2];\n            if (dist(cx, cy, 0, 0) <= cr || dist(cx, cy, X, Y) <= cr) return false;\n\n            if (cx < 0) {\n                if (cy < 0 || (cy > Y && dist(cx, cy, 0, Y) > cr)) continue;\n            } else if (cx > X) {\n                if (cy > Y || (cy < 0 && dist(cx, cy, X, 0) > cr)) continue;\n            }\n            relevants.push_back(circles[i]);\n        }\n\n        const int n = relevants.size();\n        vector<int> roots(n, -1), sizes(n, 1);\n        vector<long long> lefts(n), rights(n), tops(n), bots(n);\n        for (int i = 0; i < n; i++) {\n            roots[i] = i;\n            lefts[i] = relevants[i][0] - (long long) relevants[i][2];\n            rights[i] = relevants[i][0] + (long long) relevants[i][2];\n            bots[i] = relevants[i][1] - (long long) relevants[i][2];\n            tops[i] = relevants[i][1] + (long long) relevants[i][2];\n        }\n\n        function<int(int)> get_root;\n        get_root = [&get_root, &roots] (int i) -> int {\n            if (roots[i] != i) roots[i] = get_root(roots[i]);\n            return roots[i];\n        };\n        auto merge = [&roots, &sizes, &get_root, &lefts, &rights, &tops, &bots] (int a, int b) -> void {\n            a = get_root(a); b = get_root(b);\n            if (a == b) return;\n            if (sizes[b] > sizes[a]) swap(a, b);\n\n            roots[b] = a;\n            sizes[a] += sizes[b];\n            lefts[a] = min(lefts[a], lefts[b]);\n            rights[a] = max(rights[a], rights[b]);\n            tops[a] = max(tops[a], tops[b]);\n            bots[a] = min(bots[a], bots[b]);\n        };\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (get_root(i) != get_root(j) && intersecting(relevants[i][0], relevants[i][1], relevants[i][2], relevants[j][0], relevants[j][1], relevants[j][2])) merge(i, j);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (get_root(i) != i) continue;\n            cout << i << ' ' << lefts[i] << ' ' << rights[i] << ' ' << tops[i] << ' ' << bots[i] << endl;\n            if (tops[i] >= Y && bots[i] <= 0) return false;\n            if (lefts[i] <= 0 && rights[i] >= X) return false;\n            if (tops[i] >= Y && rights[i] >= X) return false;\n            if (bots[i] <= 0 && lefts[i] <= 0) return false;\n        }\n\n        return true;\n    }\n};",
    "submit_ts": "1722139119",
    "subm_id": "1335808362"
}