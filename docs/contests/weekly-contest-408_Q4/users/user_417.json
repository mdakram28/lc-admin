{
    "username": "youngbryanyu",
    "submission": "import java.util.*;\n\nclass Solution {\n    // Union-Find data structure with path compression and union by rank\n    class UnionFind {\n        private int[] parent; // Parent array to keep track of the parent of each node\n        private int[] rank; // Rank array to keep track of the depth of each tree\n        private boolean[][] touches; // To track if a component touches any edge: [right, top, left, bottom]\n\n        public UnionFind(int size) {\n            parent = new int[size];\n            rank = new int[size];\n            touches = new boolean[size][4]; // Initialize touches array\n            for (int i = 0; i < size; i++) {\n                parent[i] = i; // Initially, each node is its own parent\n                rank[i] = 1; // Initially, the rank (depth) of each node is 1\n            }\n        }\n\n        // Find with path compression\n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]); // Path compression: make the parent of x the root\n            }\n            return parent[x];\n        }\n\n        // Union by rank\n        public void union(int x, int y) {\n            int rootX = find(x); // Find the root of x\n            int rootY = find(y); // Find the root of y\n\n            if (rootX != rootY) { // If they are in different sets, we need to union them\n                if (rank[rootX] > rank[rootY]) {\n                    parent[rootY] = rootX; // Make rootX the parent of rootY\n                    // Merge the edge touches information\n                    for (int i = 0; i < 4; i++) {\n                        touches[rootX][i] = touches[rootX][i] || touches[rootY][i];\n                    }\n                } else if (rank[rootX] < rank[rootY]) {\n                    parent[rootX] = rootY; // Make rootY the parent of rootX\n                    // Merge the edge touches information\n                    for (int i = 0; i < 4; i++) {\n                        touches[rootY][i] = touches[rootX][i] || touches[rootY][i];\n                    }\n                } else {\n                    parent[rootY] = rootX; // Arbitrarily make rootX the parent of rootY\n                    rank[rootX]++; // Increment the rank of rootX\n                    // Merge the edge touches information\n                    for (int i = 0; i < 4; i++) {\n                        touches[rootX][i] = touches[rootX][i] || touches[rootY][i];\n                    }\n                }\n            }\n        }\n\n        // Get the edge touches information for a component\n        public boolean[] getTouches(int x) {\n            return touches[find(x)];\n        }\n\n        // Set the edge touches information for a specific circle\n        public void setTouches(int x, boolean[] edgeTouches) {\n            int root = find(x); // Find the root of x\n            for (int i = 0; i < 4; i++) {\n                touches[root][i] = edgeTouches[i]; // Set the touches information\n            }\n        }\n    }\n\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        int n = circles.length;\n        UnionFind uf = new UnionFind(n);\n\n        // Check initial circles touching borders\n        for (int i = 0; i < n; i++) {\n            int cx = circles[i][0];\n            int cy = circles[i][1];\n            int r = circles[i][2];\n            boolean[] touches = new boolean[4];\n            if (cx - r <= 0) touches[2] = true; // Left\n            if (cx + r >= X) touches[0] = true; // Right\n            if (cy - r <= 0) touches[3] = true; // Bottom\n            if (cy + r >= Y) touches[1] = true; // Top\n\n            // System.out.println(Arrays.toString())\n            uf.setTouches(i, touches);\n        }\n\n        // Check intersections between circles\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int cx1 = circles[i][0];\n                int cy1 = circles[i][1];\n                int r1 = circles[i][2];\n                int cx2 = circles[j][0];\n                int cy2 = circles[j][1];\n                int r2 = circles[j][2];\n                int distSq = (cx1 - cx2) * (cx1 - cx2) + (cy1 - cy2) * (cy1 - cy2);\n                int radiusSumSq = (r1 + r2) * (r1 + r2);\n                if (distSq <= radiusSumSq) {\n                    uf.union(i, j); // If the circles intersect, union their components\n                }\n            }\n        }\n\n        // Check if any component touches both sides\n        for (int i = 0; i < n; i++) {\n            boolean[] touches = uf.getTouches(i);\n            if ((touches[0] && touches[2]) || (touches[1] && touches[3]) || (touches[2] && touches[3]) || (touches[0] && touches[1])) {\n                return false; // If any component touches opposite sides, return false\n            }\n        }\n\n        return true; // If no component touches opposite sides, return true\n    }\n\n    // public static void main(String[] args) {\n    //     Solution solution = new Solution();\n    //     int X = 5;\n    //     int Y = 5;\n    //     int[][] circles = {{1, 1, 1}, {3, 3, 1}, {4, 4, 1}};\n    //     System.out.println(solution.canReachCorner(X, Y, circles));  // Expected output: false\n    // }\n}\n",
    "submit_ts": "1722137063",
    "subm_id": "1335753086"
}