{
    "username": "Ayush-1234",
    "submission": "class Solution {\npublic:\n    int n, m, inf = 1e9;\n    vector<vector<int>> g[2], mxChildren[2];\n    vector<int> indp[2], outdp[2];\n    \n    void dfs1(int nn, int par, vector<vector<int>> &g, vector<int> &indp, vector<vector<int>> &mxChildren){\n        indp[nn] = 0;\n        mxChildren[nn] = {-inf, -inf};\n        \n        for(auto v: g[nn])\n            if(v != par){\n                dfs1(v, nn, g, indp, mxChildren);\n                indp[nn] = max(indp[nn], 1 + indp[v]);\n                \n                if(indp[v] >= mxChildren[nn][1]){\n                    mxChildren[nn][0] = mxChildren[nn][1];\n                    mxChildren[nn][1] = indp[v];\n                }else if(indp[v] >= mxChildren[nn][0]){\n                    mxChildren[nn][0] = indp[v];\n                }\n            }\n    }\n    \n    void dfs2(int nn, int par, vector<vector<int>> &g, vector<int> &indp, vector<int> &outdp, vector<vector<int>> &mxChildren){\n        outdp[nn] = 0;\n        if(par != -1){\n            if(indp[nn] == mxChildren[par][1]){\n                outdp[nn] = max(outdp[nn], 2 + mxChildren[par][0]);\n            }else{\n                outdp[nn] = max(outdp[nn], 2 + mxChildren[par][1]);\n            }\n            outdp[nn] = max(outdp[nn], 1 + outdp[par]);\n        }\n        for(auto v: g[nn])\n            if(v != par)\n                dfs2(v, nn, g, indp, outdp, mxChildren);\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        n = (int)(edges1.size()) + 1;\n        m = (int)(edges2.size()) + 1;\n        g[0] = vector<vector<int>>(n);\n        g[1] = vector<vector<int>>(m);\n        mxChildren[0] = vector<vector<int>>(n);\n        mxChildren[1] = vector<vector<int>>(m);\n        indp[0] = outdp[0] = vector<int>(n);\n        indp[1] = outdp[1] = vector<int>(m);\n        \n        for(auto v: edges1){\n            g[0][v[0]].push_back(v[1]);\n            g[0][v[1]].push_back(v[0]);\n        }\n        for(auto v: edges2){\n            g[1][v[0]].push_back(v[1]);\n            g[1][v[1]].push_back(v[0]);\n        }\n        \n        \n        auto dfs = [](int nn, int par, int depth, vector<vector<int>> &g, vector<int> &dp, auto &&dfs) -> void{\n            dp[nn] = depth;\n            for(auto v: g[nn])\n                if(v != par)\n                    dfs(v, nn, depth + 1, g, dp, dfs);\n        };\n        \n        vector<int> dp;\n        int ans = 0, temp1 = 1e9, temp2 = 1e9, ix;\n        \n        dp = vector<int>(n);\n        dfs(0, -1, 0, g[0], dp, dfs);\n        ix = max_element(dp.begin(), dp.end()) - dp.begin();\n        dfs(ix, -1, 0, g[0], dp, dfs);\n        ans = max(ans, *max_element(dp.begin(), dp.end()));\n        \n        dp = vector<int>(m);\n        dfs(0, -1, 0, g[1], dp, dfs);\n        ix = max_element(dp.begin(), dp.end()) - dp.begin();\n        dfs(ix, -1, 0, g[1], dp, dfs);\n        ans = max(ans, *max_element(dp.begin(), dp.end()));\n        \n        dfs1(0, -1, g[0], indp[0], mxChildren[0]);\n        dfs2(0, -1, g[0], indp[0], outdp[0], mxChildren[0]);\n        \n        dfs1(0, -1, g[1], indp[1], mxChildren[1]);\n        dfs2(0, -1, g[1], indp[1], outdp[1], mxChildren[1]);\n        \n        for(int i = 0; i < n; ++i) temp1 = min(temp1, max(indp[0][i], outdp[0][i]));\n        for(int i = 0; i < m; ++i) temp2 = min(temp2, max(indp[1][i], outdp[1][i]));\n        \n        // cout << temp1 << ' ' << temp2 << endl;\n        // cout << \"tree1:\\n\";\n        // for(int i = 0; i < n; ++i) cout << i << \": \" << indp[0][i] << ' ' << outdp[0][i] << endl;\n        // cout << \"tree2:\\n\";\n        // for(int i = 0; i < m; ++i) cout << i << \": \" << indp[1][i] << ' ' << outdp[1][i] << endl;\n        \n        int temp = temp1 + temp2 + 1;\n        ans = max(ans, temp);\n        \n        return ans;\n    }\n};",
    "submit_ts": 1719718677.0
}