{
    "username": "lddlinan",
    "submission": "class Edge(object):\n    def __init__(self, a, b, w=1):\n        self.a, self.b, self.w = a, b, w\n    def weight(self):\n        return self.w\n    def nei(self, a):\n        if a==self.a: return self.b\n        return self.a\nclass T2Value(object):\n    def __init__(self):\n        self.v1, self.i1 = 0, -1\n        self.v2, self.i2 = -1, -1\n    def update(self, v, i):\n        if v>self.v1:\n            self.v1, self.i1, self.v2, self.i2 = v, i, self.v1, self.i1\n        elif v>self.v2:\n            self.v2, self.i2 = v, i\n    def __str__(self):\n        return \"%d(%d) %d(%d)\"%(self.v1, self.i1, self.v2, self.i2)\nclass Tree(object):\n    def __init__(self, n, edges):\n        nei = [[] for _ in range(n)]\n        for e in edges:\n            en = Edge(*e)\n            a, b = e[0], e[1]\n            nei[a].append(en)\n            nei[b].append(en)\n        self.nei, self.n = nei, n\n        self.dd, self.hs, self.cs = [-1]*n, [-1]*n, [-1]*n\n        self.h2s = [T2Value() for _ in range(n)]\n        self.rs = [0]*n\n    def add_edge(self, a, b, w=1):\n        e = Edge(a, b, w)\n        nei[a].append(e)\n        nei[b].append(e)\n        \n    def bfs(self, r):\n        n, nei, dd = self.n, self.nei, self.dd\n        for i in range(n): dd[i]=-1\n        q = deque()\n        q.append(r)\n        dd[r] = 0\n        while q:\n            a = q.popleft()\n            for e in nei[a]:\n                b = e.nei(a)\n                if dd[b]!=-1: continue\n                dd[b]=dd[a]+1\n                q.append(b)\n        return dd\n    def diameter(self):\n        dd = self.bfs(0)\n        n = self.n\n        md, mi = 0, 0\n        for i in range(1, n):\n            if md<dd[i]:\n                md, mi = dd[i], i\n        dd = self.bfs(mi)\n        return max(dd)\n    def _build_h(self, r, p):\n        h = 0\n        c = 1\n        for e in self.nei[r]:\n            b = e.nei(r)\n            if b==p: continue\n            ch = 1+self._build_h(b, r)\n            if (b&1)==0: ch+=1\n            self.h2s[r].update(ch, b)\n            h = max(h, ch)\n            c += self.cs[b]\n        self.hs[r] = h\n        self.cs[r] = c\n        return h\n    def build_height(self, r):\n        self._build_h(r, -1)\n        return self.hs\n    def _dfs_radius(self, r, p, eh):\n        self.rs[r] = max(self.hs[r], eh)\n        for e in self.nei[r]:\n            b = e.nei(r)\n            if b==p: continue\n            if b==self.h2s[r].i1:\n                nh = max(eh, self.h2s[r].v2)\n            else:\n                nh = max(eh, self.h2s[r].v1)\n            d = 1\n            if (r&1)==0: d=2\n            self._dfs_radius(b, r, nh+d)\n    def build_radius(self):\n        self.build_height(0)\n        self._dfs_radius(0, -1, 0)\n        return self.rs\n\n    def _dfs(self, r, p):\n        self.enters[r] = self.gk\n        self.gk +=1\n        self.pps[0][r]=p\n        for e in self.nei[r]:\n            b = e.nei(r)\n            if b==p: continue\n            self._dfs(b, r)\n        self.leaves[r] = self.gk-1\n    def build_lcm(self, r):\n        n = self.n\n        self.enters = [-1]*n\n        self.leaves = [-1]*n\n        self.gk = 0\n        K = 30\n        self.pps = [[-1]*n for _ in range(K)]\n        self._dfs(r, r)\n        for k in range(1, K):\n            for i in range(n):\n                ni = self.pps[k-1][i]\n                self.pps[k][i]=self.pps[k-1][ni]\n        self.K = K\n    def lcm_is_ancestor(self, a, b):\n        return self.enters[b]>=self.enters[a] and self.enters[b]<=self.leaves[a]\n    def lcm(self, a, b):\n        if self.lcm_is_ancestor(a, b): return a\n        if self.lcm_is_ancestor(b, a): return b\n        K = self.K\n        for k in range(K-1, -1, -1):\n            na = self.pps[k][a]\n            if self.lcm_is_ancestor(na, b): continue\n            a = na\n        return self.pps[0][a]\nclass Solution(object):\n    def timeTaken(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        t = Tree(len(edges)+1, edges)\n        rs = t.build_radius()\n        return rs",
    "submit_ts": "1722696656",
    "subm_id": "552262116"
}