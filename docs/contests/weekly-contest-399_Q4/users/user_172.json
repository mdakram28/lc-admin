{
    "username": "mhasan01",
    "submission": "template<class Info, class Merge = plus<Info>>\nstruct SegmentTree {\n    const int n;\n    const Merge merge;\n    vector<Info> t;\n    SegmentTree(int len) : n(len), merge(Merge()), t(4 << __lg(len)) {}\n    SegmentTree(vector<Info> init) : SegmentTree(init.size()) {\n        function<void(int, int, int)> build = [&](int v, int s, int e) {\n            if (s == e) {\n                t[v] = init[s];\n                return;\n            }\n            int mid = (s + e) >> 1;\n            build(v << 1, s, mid);\n            build(v << 1 | 1, mid + 1, e);\n            pull(v);\n        };\n        build(1, 0, n - 1);\n    }\n\n    void pull(int v) {\n        t[v] = merge(t[v << 1], t[v << 1 | 1]);\n    }\n\n    void modify(int v, int s, int e, int pos, const Info &val) {\n        if (s == e && s == pos) {\n            t[v] = val;\n            return;\n        }\n        int mid = (s + e) >> 1;\n        if (pos <= mid) {\n            modify(v << 1, s, mid, pos, val);\n        } else {\n            modify(v << 1 | 1, mid + 1, e, pos, val);\n        }\n        pull(v);\n    }\n\n    void modify(int p, const Info &v) {\n        modify(1, 0, n - 1, p, v);\n    }\n\n    Info rangeQuery(int v, int s, int e, int l, int r) {\n        if (e < l || s > r || l > r) {\n            return Info();\n        }\n        if (l <= s && e <= r) {\n            return t[v];\n        }\n        int mid = (s + e) >> 1;\n        return merge(rangeQuery(v << 1, s, mid, l, r), rangeQuery(v << 1 | 1, mid + 1, e, l, r));\n    }\n\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n - 1, l, r);\n    }\n};\n\nstruct Info {\n    int l, r;\n    long long val[4];\n    Info() {\n        l = -1, r = -1;\n        for (int i = 0; i < 4; i++) {\n            val[i] = 0LL;\n        }\n    }\n    \n    Info(int pos, long long x) {\n        l = pos, r = pos;\n        val[0] = max(0LL, x);\n        for (int i = 1; i < 4; i++) {\n            val[i] = 0LL;\n        }\n    }\n};\n\nconst int DL[] = {0, 1, 0, 1};\nconst int DR[] = {0, 0, -1, -1};\n\nInfo operator+(const Info& lhs, const Info& rhs) {\n    if (lhs.l == -1) {\n        return rhs;\n    }\n    if (rhs.l == -1) {\n        return lhs;\n    }\n    Info ret = Info();\n    ret.l = lhs.l;\n    ret.r = rhs.r;\n    if (ret.r - ret.l == 1) {\n        ret.val[0] = 0LL;\n        ret.val[1] = rhs.val[0];\n        ret.val[2] = lhs.val[0];\n        ret.val[3] = 0LL;\n        // return ret;\n    }\n    if (ret.r - ret.l == 2) {\n        if (lhs.l == lhs.r) {\n            ret.val[0] = lhs.val[0] + rhs.val[1];\n            ret.val[3] = rhs.val[2];\n        } else {\n            ret.val[0] = lhs.val[2] + rhs.val[0];\n            ret.val[3] = lhs.val[1];      \n        }\n        // return ret;\n    }\n    for (int i = 0; i < 4; i++) {\n        int fl = lhs.l + DL[i];\n        int fr = lhs.r + DR[i];\n        for (int j = 0; j < 4; j++) {\n            int sl = rhs.l + DL[j];\n            int sr = rhs.r + DR[j];\n            if (fr + 1 == sl) {\n                continue;\n            }\n            int idx = -1;\n            if (fl == lhs.l && sr == rhs.r) {\n                idx = 0;\n            } else if (fl == lhs.l + 1 && sr == rhs.r) {\n                idx = 1;\n            } else if (fl == lhs.l && sr == rhs.r - 1) {\n                idx = 2;\n            } else if (fl == lhs.l + 1 && sr == rhs.r - 1) {\n                idx = 3;\n            } else {\n                continue;\n            }\n            ret.val[idx] = max(ret.val[idx], lhs.val[i] + rhs.val[j]);\n        }\n    }\n    // cout << \"MERGING \" << lhs.l << \" - \" << lhs.r << \" with \" << rhs.l << \" - \" << rhs.r << '\\n';\n    // cout << ret.l << \" - \" << ret.r << \" and \" << '\\n';\n    // for (int i = 0; i < 4; i++) {\n    //     cout << i << \" => \" << ret.val[i] << '\\n';\n    // }\n    return ret;\n}\n\nconst int MOD = 1e9 + 7;\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& a, vector<vector<int>>& q) {\n        int n = (int) a.size();\n        vector<Info> init(n);\n        for (int i = 0; i < n; i++) {\n            init[i] = Info(i, a[i]);\n        }\n        SegmentTree sgt(init);\n        long long ans = 0;\n        for (auto& qq : q) {\n            int pos = qq[0];\n            long long x = qq[1];\n            Info cur = Info(pos, x);\n            sgt.modify(pos, cur);\n            Info info = sgt.rangeQuery(0, n - 1);\n            long long res = 0;\n            for (int i = 0; i < 4; i++) {\n                res = max(res, info.val[i]);\n            }\n            ans = (ans + res) % MOD;\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716695184.0
}