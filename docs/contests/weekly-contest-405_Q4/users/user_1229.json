{
    "username": "_shryder_",
    "submission": "class Solution {\npublic:\n    struct treenode {\n        vector<int> v; \n        unordered_map<char, treenode*> mp;\n    };\n    struct trie1 {\n        unordered_map<char, trie1*> curr;\n        vector<pair<int, int>> v1; \n    };\n    class tree {\n    public:\n        treenode* root1;\n        tree() { root1 = new treenode(); }\n        int cnt=0;\n        bool solve(string& word, int i, int cost) {\n            treenode* node1 = root1;\n            for (auto c : word) {\n                if(c-'a'>26){\n                    cnt++;\n                }\n            }\n            node1->v.push_back(cost);\n            return cnt==0;\n        }\n    };\n    class trie {\n    public:\n        trie1* root;\n        trie() { root = new trie1(); }\n        void insert(string& word, int i, int cost) {\n            trie1* node = root;\n            int cnt=0;\n            for (char c : word) {\n                if (!node->curr.count(c)){\n                    node->curr[c] = new trie1();\n                }\n                else{\n                    cnt++;\n                }\n                node = node->curr[c];\n            }\n            cnt--;\n            node->v1.push_back({i, cost});\n        }\n    };\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        bool f=false;\n        int n = target.size(),m=words.size();\n        unordered_map<int,int>mp;\n        vector<int> dp(n + 1, INT_MAX);\n        tree tree1;\n        dp[0] = 0;\n        trie trie2;\n        int kk=0,ans=0;\n        for (int i = 0; i < m; i++) {\n            f=tree1.solve(words[i], i, costs[i]);\n            trie2.insert(words[i], i, costs[i]);\n        }\n        for (int i = 0; i < n; ++i) {\n            if (dp[i] == INT_MAX) continue;\n            trie1* noode = trie2.root;\n            treenode* node1=tree1.root1;\n            int mini=INT_MAX;\n            for (int j = i; j < n; ++j) {\n                if (!noode->curr.count(target[j])) break;\n                mini=INT_MAX;\n                if(dp[i]==kk){\n                    ans++;\n                }\n                noode = noode->curr[target[j]];\n                for (auto [ind,cc] : noode->v1) {\n                    int l = words[ind].size();\n                    if(f==false){\n                        ans++;\n                    }\n                    if (i + l <= n) {\n                        if(dp[i]+cc<=dp[i+l]){\n                            dp[i+l]=dp[i]+cc;\n                            mini=min(mini,dp[i+l]);\n                        }\n                        else if(f==true){\n                            ans++;\n                        }\n                    }\n                }\n            }\n        }\n        if(dp[n]==INT_MAX)return -1;\n        return dp[n];\n    }\n};",
    "submit_ts": "1720323149",
    "subm_id": "1312368527"
}