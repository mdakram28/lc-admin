{
    "username": "Gaurang22",
    "submission": "class Solution {\n    int x;\n    void dfsUtil(int node, int count, bool visited[], int& maxCount, vector<int> adj[]){\n        visited[node] = true;\n        count++;\n        for (auto i = adj[node].begin(); i != adj[node].end(); ++i) {\n            if (!visited[*i]) {\n                if (count >= maxCount) {\n                    maxCount = count;\n                    x = *i;\n                }\n                dfsUtil(*i, count, visited, maxCount, adj);\n            }\n        }\n    }\n\n    void dfs(int node, int n, vector<int> adj[], int& maxCount)    {\n        bool visited[n+1];\n        int count = 0;\n        for (int i = 0; i <= n; ++i)\n            visited[i] = false;\n        dfsUtil(node, count, visited, maxCount, adj);\n    }\n\n    int diameter(vector<int> adj[], int n){\n        int maxCount = INT_MIN;\n        dfs(0, n-1, adj, maxCount);\n        dfs(x, n-1, adj, maxCount);\n        return maxCount;\n    }\n    \n    vector<int> rootForMinimumHeight(vector<int> adj[], int V, vector<int> &degree){\n        if(V == 1)  return {};\n        queue<int> q;\n        for (int i = 0; i < V; i++)\n            if (degree[i] == 1)\n                q.push(i);\n\n        while (V > 2){\n            int popEle = q.size();\n            V -= popEle;\n\n            for (int i = 0; i < popEle; i++){\n                int t = q.front();\n                q.pop();\n                for (auto j = adj[t].begin(); j != adj[t].end(); j++){\n                    degree[*j]--;\n                    if (degree[*j] == 1)\n                        q.push(*j);\n                }\n            }\n        }\n        vector<int> res;\n        while (!q.empty())\n        {\n            res.push_back(q.front());\n            q.pop();\n        }\n        return res;\n    }\n    \n    int getHeight(vector<int> adj[], int n, int node) {\n        if(n == 1)  return 0;\n        queue<int> q;\n        vector<int> vis(n);\n        q.push(node);\n        vis[node] = true;\n        int h = 0;\n        \n        while(!q.empty()) {\n            int siz = q.size();\n            while(siz--){\n                node = q.front();\n                q.pop();\n                for(auto i: adj[node]){\n                    if(!vis[i]){\n                        vis[i] = true;\n                        q.push(i);\n                    }\n                }\n            }\n            h++;\n        }\n        return h-1;\n    }\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size()+1, m = edges2.size()+1;\n        vector<int> adj1[n], adj2[m], indeg1(n, 0), indeg2(m, 0);\n        \n        for(auto i: edges1) {\n            adj1[i[0]].push_back(i[1]);\n            adj1[i[1]].push_back(i[0]);\n            indeg1[i[0]]++;\n            indeg1[i[1]]++;\n        }\n        for(auto i: edges2) {\n            adj2[i[0]].push_back(i[1]);\n            adj2[i[1]].push_back(i[0]);\n            indeg2[i[0]]++;\n            indeg2[i[1]]++;\n        }\n        vector<int> r1 = rootForMinimumHeight(adj1, n, indeg1);\n        vector<int> r2 = rootForMinimumHeight(adj2, m, indeg2);\n        int rr1 = (r1.size() > 0)? r1[0]: -1;\n        int rr2 = (r2.size() > 0)? r2[0]: -1;\n        int h1 = getHeight(adj1, n, rr1);\n        int h2 = getHeight(adj2, m, rr2);\n        // cout << r1[0] << '\\t' << h1 << '\\n' << r2[0] << '\\t' << h2;\n        return max({h1 + h2 + 1, diameter(adj1, n), diameter(adj2, m)});\n    }\n};",
    "submit_ts": 1719718297.0
}