{
    "username": "mhwg",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n/*\nThere exist two undirected trees with n and m nodes, numbered from 0 to n - 1 and from 0 to m - 1, respectively. You are given two 2D integer arrays edges1 and edges2 of lengths n - 1 and m - 1, respectively, where edges1[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the first tree and edges2[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the second tree.\n\nYou must connect one node from the first tree with another node from the second tree with an edge.\n\nReturn the minimum possible diameter of the resulting tree.\n\nThe diameter of a tree is the length of the longest path between any two nodes in the tree.\n*/\n\n// finds the diameter of a tree\nstruct diam {\n    vector<vector<int>> adj;\n    int n;\n    int farthest;\n    int max_dist;\n    diam(vector<vector<int>> &adj) {\n        n = adj.size();\n        this->adj = adj;\n        max_dist = 0;\n        dfs(0, -1, 0);\n        max_dist = 0;\n        dfs(farthest, -1, 0);\n    }\n    void dfs(int u, int p, int d) {\n        if (d > max_dist) {\n            max_dist = d;\n            farthest = u;\n        }\n        for (int v : adj[u]) {\n            if (v != p) {\n                dfs(v, u, d + 1);\n            }\n        }\n    }\n};\n\n// finds the furthest node from each node using dp\nstruct furth {\n    vector<vector<int>> adj;\n    int n;\n    vector<int> dp1, dp2;\n    furth(vector<vector<int>> &adj) {\n        this->adj = adj;\n        n = adj.size();\n        dp1 = vector<int>(n);\n        dp2 = vector<int>(n);\n        dfs1(0);\n        dfs2(0);\n    }\n    void dfs1(int at, int p = -1) {\n        dp1[at] = 0;\n        for (int to : adj[at]) {\n            if (to != p) {\n                dfs1(to, at);\n                dp1[at] = max(dp1[at], dp1[to] + 1);\n            }\n        }\n    }\n    void dfs2(int at, int pd = 0, int p = -1) {\n        // cout << \"at: \" << at << \" pd: \" << pd << \" p: \" << p << endl;\n        dp2[at] = pd;\n        multiset<int> s;\n        for (int to : adj[at]) {\n            if (to != p) {\n                s.insert(dp1[to] + 1);\n                dp2[at] = max(dp2[at], dp1[to] + 1);\n            }\n        }\n        for (int to : adj[at]) {\n            if (to != p) {\n                s.erase(s.find(dp1[to] + 1));\n                if (!s.empty()) {\n                    dfs2(to, max(pd + 1, *s.rbegin() + 1), at);\n                } else {\n                    dfs2(to, pd + 1, at);\n                }\n                s.insert(dp1[to] + 1);\n            }\n        }\n    }\n};\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        vector<vector<int>> adj1(edges1.size() + 1), adj2(edges2.size() + 1);\n        for (auto &e : edges1) {\n            adj1[e[0]].push_back(e[1]);\n            adj1[e[1]].push_back(e[0]);\n        }\n        for (auto &e : edges2) {\n            adj2[e[0]].push_back(e[1]);\n            adj2[e[1]].push_back(e[0]);\n        }\n        diam d1(adj1), d2(adj2);\n        furth f1(adj1), f2(adj2);\n        int n = adj1.size(), m = adj2.size();\n        int ans = 1e9;\n        int min1 = 1e9, min2 = 1e9;\n        // cout << \"diam1: \" << d1.max_dist << endl;\n        // cout << \"diam2: \" << d2.max_dist << endl;\n        for (int i = 0; i < n; i++) {\n            // cout << \"furth for 1: \" << i << \" = \" << f1.dp2[i] << endl;\n            min1 = min(min1, f1.dp2[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            // cout << \"furth for 2: \" << i << \" = \" << f2.dp2[i] << endl;\n            min2 = min(min2, f2.dp2[i]);\n        }\n        return max({d1.max_dist, d2.max_dist, min1 + min2 + 1});\n    }\n};\n",
    "submit_ts": 1719717029.0
}