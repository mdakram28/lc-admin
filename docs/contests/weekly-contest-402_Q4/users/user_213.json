{
    "username": "fplk0",
    "submission": "class Solution {\npublic:\n    struct SegmTree {\n        SegmTree(size_t size) {\n            size_t npot = 1;\n            while(npot < size) {\n                npot *= 2;\n            }\n            stSize = npot;\n            st.resize(stSize * 2);\n            sums.resize(stSize * 2);\n        }\n        void push(size_t root) {\n            auto& cur = st[root];\n            if (cur != -1) {\n                auto lInd = root * 2 + 1, rInd = root * 2 + 2;\n                sums[root] = cur;\n                if (rInd < st.size()) {\n                    st[lInd] = cur;\n                    st[rInd] = cur;\n                }\n                cur = -1;\n            }\n        }\n\n        void set(size_t l, size_t r, size_t toSet, size_t l0 = 0, size_t r0 = -1, size_t root = 0) {\n            if (r0 == -1) {\n                r0 = stSize - 1;\n            }\n            auto lInd = root * 2 + 1, rInd = root * 2 + 2;\n            push(root);\n            if (l == l0 && r == r0) {\n                sums[root] = toSet * (r - l + 1);\n                st[root] = toSet;\n            } else {\n                size_t mid = (l0 + r0) / 2;\n                if (r <= mid) {\n                    set(l, r, toSet, l0, mid, lInd);\n                } else if (l > mid) {\n                    set(l, r, toSet, mid + 1, r0, rInd);\n                } else {\n                    set(l, mid, toSet, l0, mid, lInd);\n                    set(mid + 1, r, toSet, mid + 1, r0, rInd);\n                }\n                sums[root] = sums[lInd] + sums[rInd];\n            }\n        }\n        int getSum(size_t l, size_t r, size_t l0 = 0, size_t r0 = -1, size_t root = 0) {\n            if (r0 == -1) {\n                r0 = stSize - 1;\n            }\n            auto lInd = root * 2 + 1, rInd = root * 2 + 2;\n            push(root);\n            auto mx = sums[root];\n            if (l == l0 && r == r0) {\n\n            } else {\n                size_t mid = (l0 + r0) / 2;\n                int maxL = 0, maxR = 0;\n                if (r <= mid) {\n                    maxL = getSum(l, r, l0, mid, lInd);\n                } else if (l > mid) {\n                    maxR = getSum(l, r, mid + 1, r0, rInd);\n                } else {\n                    maxL = getSum(l, mid, l0, mid, lInd);\n                    maxR = getSum(mid + 1, r, mid + 1, r0, rInd);\n                }\n                mx = maxL + maxR;\n            }\n            return mx;\n        }\n\n        std::vector<int> st;\n        std::vector<int> sums;\n        size_t stSize = 0;\n    };\n\n    vector<int> countOfPeaks(vector<int>& nums, const vector<vector<int>>& queries) {\n        size_t n = nums.size();\n        SegmTree st(n);\n        std::vector<int> peaks(n, 0);\n        for (int i = 1; i < n-1; i++) {\n            if (nums[i] > nums[i-1] && nums[i] > nums[i+1]) {\n                peaks[i] = 1;\n                st.set(i, i, 1);\n            }\n        }\n\n        std::vector<int> result;\n        for (const auto& q : queries) {\n            if (q[0] == 1) {\n                int lb = q[1] + 1;\n                int rb = q[2] - 1;\n                if (lb > rb) {\n                    result.push_back(0);\n                } else {\n                    int cv = st.getSum(lb, rb);\n                    result.push_back(cv);\n                }\n            } else {\n                int idx = q[1];\n                int to = q[2];\n                nums[idx] = to;\n                for (int i = std::max(1, idx - 1), iEnd = std::min((int)n-2, idx + 1); i <= iEnd; i++) {\n                    if (nums[i] > nums[i-1] && nums[i] > nums[i+1]) {\n                        peaks[i] = 1;\n                    } else {\n                        peaks[i] = 0;\n                    }\n                    st.set(i, i, peaks[i]);\n                }\n            }\n        }\n        return result;\n    }\n};",
    "submit_ts": 1718507101.0
}