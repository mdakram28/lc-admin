{
    "username": "i3rave-darwinbl8",
    "submission": "class Solution {\npublic:\n    int minimumSum(vector<vector<int>>& grid) {\n        const int m = grid.size();\n        const int n = grid[0].size();\n        int t0{n-1}, b0{0}, l0{m-1}, r0{0};\n        int cnt = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j]) {\n                    t0 = min(t0, i);\n                    b0 = max(b0, i);\n                    l0 = min(l0, j);\n                    r0 = max(r0, j);\n                    cnt += 1;\n                }\n            }\n        }\n        \n        int min_area = (b0 - t0 + 1) * (r0 - l0 + 1);\n        \n        struct Rect { int t; int b; int l; int r; };\n        \n        auto col_cut = [&](Rect rect, int k) -> pair<Rect, Rect> {\n            int t = rect.t;\n            int b = rect.b;\n            int l = rect.l;\n            int r = rect.r;\n            Rect left_rect{b, t, k, l};\n            for (int i = t; i <= b; ++i) {\n                for (int j = l; j <= k; ++j) {\n                    if (grid[i][j]) {\n                        left_rect.t = min(left_rect.t, i);\n                        left_rect.b = max(left_rect.b, i);\n                        left_rect.l = min(left_rect.l, j);\n                        left_rect.r = max(left_rect.r, j);\n                    }\n                }\n            }\n            Rect right_rect{b, t, r, k+1};\n            for (int i = t; i <= b; ++i) {\n                for (int j = k+1; j <= r; ++j) {\n                    if (grid[i][j]) {\n                        right_rect.t = min(right_rect.t, i);\n                        right_rect.b = max(right_rect.b, i);\n                        right_rect.l = min(right_rect.l, j);\n                        right_rect.r = max(right_rect.r, j);\n                    }\n                }\n            }\n            return pair{left_rect, right_rect};\n        };\n        \n        auto row_cut = [&](Rect rect, int k) -> pair<Rect, Rect> {\n            int t = rect.t;\n            int b = rect.b;\n            int l = rect.l;\n            int r = rect.r;\n            Rect left_rect{k, t, r, l};\n            for (int i = t; i <= k; ++i) {\n                for (int j = l; j <= r; ++j) {\n                    if (grid[i][j]) {\n                        left_rect.t = min(left_rect.t, i);\n                        left_rect.b = max(left_rect.b, i);\n                        left_rect.l = min(left_rect.l, j);\n                        left_rect.r = max(left_rect.r, j);\n                    }\n                }\n            }\n            Rect right_rect{b, k+1, r, l};\n            for (int i = k+1; i <= b; ++i) {\n                for (int j = l; j <= r; ++j) {\n                    if (grid[i][j]) {\n                        right_rect.t = min(right_rect.t, i);\n                        right_rect.b = max(right_rect.b, i);\n                        right_rect.l = min(right_rect.l, j);\n                        right_rect.r = max(right_rect.r, j);\n                    }\n                }\n            }\n            return pair{left_rect, right_rect};\n        };\n        \n        auto area = [](Rect& rect) -> int {\n            return (rect.b - rect.t + 1) * (rect.r - rect.l + 1);\n        };\n        \n        Rect o_rect{t0, b0, l0, r0};\n        for (int k1 = t0; k1 < b0; ++k1) {\n            auto [to_rect, bo_rect] = row_cut(o_rect, k1);\n            auto to_area = area(to_rect);\n            auto bo_area = area(bo_rect);\n            \n            for (int k2 = to_rect.t; k2 < to_rect.b; ++k2) {\n                auto [tto, bto] = row_cut(to_rect, k2);\n                min_area = min(min_area, bo_area + area(tto) + area(bto));\n            }\n            \n            for (int k2 = bo_rect.t; k2 < bo_rect.b; ++k2) {\n                auto [tbo, bbo] = row_cut(bo_rect, k2);\n                min_area = min(min_area, to_area + area(tbo) + area(bbo));\n            }\n            \n            for (int k2 = to_rect.l; k2 < to_rect.r; ++k2) {\n                auto [lto, rto] = col_cut(to_rect, k2);\n                min_area = min(min_area, bo_area + area(lto) + area(rto));\n            }\n            \n            for (int k2 = bo_rect.l; k2 < bo_rect.r; ++k2) {\n                auto [lbo, rbo] = col_cut(bo_rect, k2);\n                min_area = min(min_area, to_area + area(lbo) + area(rbo));\n            }\n        }\n        \n        for (int k1 = l0; k1 < r0; ++k1) {\n            auto [to_rect, bo_rect] = col_cut(o_rect, k1);\n            auto to_area = area(to_rect);\n            auto bo_area = area(bo_rect);\n            \n            for (int k2 = to_rect.t; k2 < to_rect.b; ++k2) {\n                auto [tto, bto] = row_cut(to_rect, k2);\n                min_area = min(min_area, bo_area + area(tto) + area(bto));\n            }\n            \n            for (int k2 = bo_rect.t; k2 < bo_rect.b; ++k2) {\n                auto [tbo, bbo] = row_cut(bo_rect, k2);\n                min_area = min(min_area, to_area + area(tbo) + area(bbo));\n            }\n            \n            for (int k2 = to_rect.l; k2 < to_rect.r; ++k2) {\n                auto [lto, rto] = col_cut(to_rect, k2);\n                min_area = min(min_area, bo_area + area(lto) + area(rto));\n            }\n            \n            for (int k2 = bo_rect.l; k2 < bo_rect.r; ++k2) {\n                auto [lbo, rbo] = col_cut(bo_rect, k2);\n                min_area = min(min_area, to_area + area(lbo) + area(rbo));\n            }\n        }\n        \n        return max(cnt, min_area);\n    }\n};",
    "submit_ts": 1719114769.0
}