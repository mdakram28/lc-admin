{
    "username": "hazzler",
    "submission": "class Solution {\npublic:\n    #define fi first\n    #define se second\n    #define all(m) (m).begin(), (m).end()\n    #define rall(m) (m).rbegin(), (m).rend()\n    #define vec vector\n    #define mp make_pair\n\n    typedef long long ll;\n    typedef long double ld;\n    typedef unsigned long long ull;\n    typedef pair <int, int> pii;\n    typedef tuple <int, int, int> tui;\n\n    template <typename T> bool chmin(T &a, T b) { if (a > b) { a = b; return 1; } return 0; }\n    template <typename T> bool chmax(T &a, T b) { if (a < b) { a = b; return 1; } return 0; }\n\nstruct ariseg{\n\n        int n;\n        vector <ll> t, lf, dt;\n\n        ariseg(int z): n(z), t(4 * z, 0), lf(4 * z, 0), dt(4 * z, 0) {}\n\n        ll foo(ll st, ll d, ll len){\n              return (2 * st + d * (len - 1)) * len >> 1;\n        }\n\n        void push(int v, int tl, int tr){\n              if (v * 2 + 2 < 4 * n){\n                  int tm = tl + tr >> 1;\n                  t[v * 2 + 1] -= foo(lf[v * 2 + 1], dt[v * 2 + 1], tm - tl);\n                  t[v * 2 + 2] -= foo(lf[v * 2 + 2], dt[v * 2 + 2], tr - tm);\n                  lf[v * 2 + 1] += lf[v];\n                  lf[v * 2 + 2] += lf[v] + dt[v] * (tm - tl);\n                  dt[v * 2 + 1] += dt[v]; dt[v * 2 + 2] += dt[v];\n                  t[v * 2 + 1] += foo(lf[v * 2 + 1], dt[v * 2 + 1], tm - tl);\n                  t[v * 2 + 2] += foo(lf[v * 2 + 2], dt[v * 2 + 2], tr - tm);\n                  lf[v] = 0; dt[v] = 0;\n              }\n        }\n\n        void upd(int l, int r, int rem, int tl, int tr, int v){\n              if (l >= r) return;\n              if (tl == l && tr == r) {\n                    lf[v] += rem - tl;\n                    --dt[v];\n                    t[v] += foo(rem - tl, -1, tr - tl);\n                    return;\n              }\n              push(v, tl, tr);\n              int tm = tl + tr >> 1;\n              upd(l, min(tm, r), rem, tl, tm, v * 2 + 1);\n              upd(max(l, tm), r, rem, tm, tr, v * 2 + 2);\n              t[v] = t[v * 2 + 1] + t[v * 2 + 2];\n        }\n\n        void upd2(int l, int r, int rem, int tl, int tr, int v){\n              if (l >= r) return;\n              if (tl == l && tr == r) {\n                    lf[v] -= rem - tl;\n                    ++dt[v];\n                    t[v] += foo(tl - rem, +1, tr - tl);\n                    return;\n              }\n              push(v, tl, tr);\n              int tm = tl + tr >> 1;\n              upd2(l, min(tm, r), rem, tl, tm, v * 2 + 1);\n              upd2(max(l, tm), r, rem, tm, tr, v * 2 + 2);\n              t[v] = t[v * 2 + 1] + t[v * 2 + 2];\n        }\n\n        ll get(int l, int r, int tl, int tr, int v){\n              if (l >= r) return 0;\n              if (tl == l && tr == r) return t[v];\n              push(v, tl, tr);\n              int tm = tl + tr >> 1;\n              return get(l, min(tm, r), tl, tm, v * 2 + 1) +\n                     get(max(l, tm), r, tm, tr, v * 2 + 2);\n        }\n\n        void add(int k){\n            upd(0, k, k, 0, n, 0);\n        }\n\n        void del(int k){\n            upd2(0, k, k, 0, n, 0);\n        }\n\n        ll get(int k){\n            return get(k - 1, k, 0, n, 0);\n        }\n    };\n\n    \n\n    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {\n        int n = colors.size();\n        ariseg t(n + 3);\n        set <pii> s;\n        for (int i = 0; i < n; ++i){\n            s.insert({i + 1, i});\n            t.add(1);\n        }\n        auto get_seg = [&](int j){\n            return *s.upper_bound({j, n});\n        };\n        auto del_seg = [&](pii x){\n            t.del(x.fi - x.se);\n            s.erase(x);\n        };\n        auto add_seg = [&](pii x){\n            t.add(x.fi - x.se);\n            s.insert(x);\n        };\n        for (int i = 0; i + 1 < n; ++i){\n            if (colors[i] != colors[i + 1]){\n                auto [r, l] = get_seg(i);\n                auto [r2, l2] = get_seg(i + 1);\n                del_seg({r, l});\n                del_seg({r2, l2});\n                add_seg({r2, l});\n            }\n        }\n        vector <int> ans;\n        for (int i = 0; i < queries.size(); ++i){\n            if (queries[i][0] == 1){\n                int k = queries[i][1];\n                auto [r1, l1] = get_seg(n - 1);\n                auto [r2, l2] = get_seg(0);\n                if (colors[0] != colors[n - 1]){\n                    if (r2 == r1){\n                        ans.push_back(n);\n                        continue;\n                    }\n                    else{\n                        t.del(r1 - l1);\n                        t.del(r2 - l2);\n                        t.add(r1 - l1 + r2 - l2);\n                    }\n                }\n                ans.push_back(t.get(k));\n                if (colors[0] != colors[n - 1]){\n                    t.add(r1 - l1);\n                    t.add(r2 - l2);\n                    t.del(r1 - l1 + r2 - l2);\n                }\n            }\n            else{\n                int j = queries[i][1];\n                int c = queries[i][2];\n                auto [r, l] = get_seg(j);\n                del_seg({r, l});\n                if (l != j){\n                    add_seg({j, l});\n                }\n                if (j + 1 < r){\n                    add_seg({r, j + 1});\n                }\n                add_seg({j + 1, j});\n                colors[j] = c;\n                for (int x = j - 1; x <= j; ++x){\n                    if (x >= 0 && x + 1 < n && colors[x] != colors[x + 1]){\n                        auto [r, l] = get_seg(x);\n                        auto [r2, l2] = get_seg(x + 1);\n                        if (r != r2){\n                            del_seg({r, l});\n                            del_seg({r2, l2});\n                            add_seg({r2, l});\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722742862",
    "subm_id": "1343778822"
}