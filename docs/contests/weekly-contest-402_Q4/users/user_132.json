{
    "username": "Homie_Lander7",
    "submission": "template <class T>\nclass BIT\n{\n    static_assert(is_integral<T>::value, \"Integer required\");\n\nprivate:\n    const size_t N;\n    vector<T> data;\n\npublic:\n    // Binary indexed tree or fenwick tree\n    // O (log n) all operations except order\n    // order complexity - O (log n)\n    // 1 based indexing\n    BIT() : N(0) {}\n    BIT(const size_t _N) : N(_N), data(_N + 1) {}\n\n    size_t size()\n    {\n        return N;\n    }\n    // sum of [1, idx]\n    // range sum query\n    T sum(size_t idx)\n    {\n        assert(idx > 0);\n        T ans = 0;\n        for (; idx > 0; idx -= (idx & -idx))\n        {\n            ans += data[idx];\n        }\n        return ans;\n    }\n    T sum(size_t l, size_t r)\n    {\n        assert(l <= r);\n        if (l == 1 or l == 0)\n            return sum(r);\n        return sum(r) - sum(l - 1);\n    }\n\n    // Point update\n    void add(size_t idx, T val)\n    {\n        assert(idx > 0);\n        for (; idx <= N; idx += (idx & -idx))\n        {\n            data[idx] += val;\n        }\n    }\n\n    // Range update\n    void range_add(size_t l, size_t r, T val)\n    {\n        assert(l <= r);\n        assert(l > 0);\n        add(l, val);\n        add(r + 1, -val);\n    }\n};\nclass Solution\n{\npublic:\n    vector<int> countOfPeaks(vector<int> &nums, vector<vector<int>> &queries)\n    {\n        nums.insert(nums.begin(), INT_MAX);\n        nums.push_back(INT_MAX);\n        int n = nums.size();\n        int q = queries.size();\n        vector<int> ans;\n        BIT<int> bit(n);\n        for (int i = 1; i < n - 1; i++)\n        {\n            if (nums[i] > nums[i - 1] and nums[i] > nums[i + 1])\n            {\n                bit.add(i, 1);\n            }\n        }\n        for (int i = 0; i < q; i++)\n        {\n            int type = queries[i][0], l = queries[i][1], r = queries[i][2];\n            l++;\n            if (type == 1)\n            {\n                r++;\n                if (r - l + 1 <= 2)\n                {\n                    ans.push_back(0);\n                }\n                else\n                {\n                    ans.push_back(bit.sum(l + 1, r - 1));\n                }\n            }\n            else\n            {\n                if (nums[l] > nums[l - 1] and nums[l] > nums[l + 1])\n                {\n                    bit.add(l, -1);\n                }\n                if (l - 2 > 0 and nums[l - 1] > nums[l - 2] and nums[l - 1] > nums[l])\n                {\n                    bit.add(l - 1, -1);\n                }\n                if (l + 2 < n and nums[l + 1] > nums[l] and nums[l + 1] > nums[l + 2])\n                {\n                    bit.add(l + 1, -1);\n                }\n                nums[l] = r;\n                if (nums[l] > nums[l - 1] and nums[l] > nums[l + 1])\n                {\n                    bit.add(l, 1);\n                }\n                if (l - 2 > 0 and nums[l - 1] > nums[l - 2] and nums[l - 1] > nums[l])\n                {\n                    bit.add(l - 1, 1);\n                }\n                if (l + 2 < n and nums[l + 1] > nums[l] and nums[l + 1] > nums[l + 2])\n                {\n                    bit.add(l + 1, 1);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718506476.0
}