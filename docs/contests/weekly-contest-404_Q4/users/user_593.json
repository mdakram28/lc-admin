{
    "username": "iyerke",
    "submission": "from collections import deque, defaultdict\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def find_diameter(edges):\n            n = len(edges) + 1\n            if n == 1:\n                return 0 \n            \n            graph = defaultdict(list)\n            for u, v in edges:\n                graph[u].append(v)\n                graph[v].append(u)\n            \n            def bfs(start):\n                visited = [-1] * n\n                queue = deque([start])\n                visited[start] = 0\n                farthest_node = start\n                max_distance = 0\n                \n                while queue:\n                    node = queue.popleft()\n                    for neighbor in graph[node]:\n                        if visited[neighbor] == -1:\n                            visited[neighbor] = visited[node] + 1\n                            queue.append(neighbor)\n                            if visited[neighbor] > max_distance:\n                                max_distance = visited[neighbor]\n                                farthest_node = neighbor\n                return farthest_node, max_distance\n\n            farthest_node_from_start, _ = bfs(0)\n            _, diameter = bfs(farthest_node_from_start)\n            return diameter\n\n        dia1 = find_diameter(edges1)\n        dia2 = find_diameter(edges2)\n        # crossing\n        res = ((dia1 + 1) // 2) + ((dia2 + 1) // 2) + 1\n        # not crossing\n        res = max(res, dia1, dia2)\n\n        return res",
    "submit_ts": 1719717631.0
}