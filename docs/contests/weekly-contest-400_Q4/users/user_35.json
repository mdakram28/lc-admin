{
    "username": "qdd1999",
    "submission": "template <class S>\nstruct segtree {\n  using OP = S (*)(S, S);\n  using E = S (*)();\n\n  int _n, size;\n  vector<S> d;\n\n  const OP op;\n  const E e;\n\n  void pull(int p) { d[p] = op(d[p * 2], d[p * 2 + 1]); }\n\n  segtree(int n, OP op, E e) : _n(n), op(op), e(e) {\n    size = 1;\n    while (size < n) size <<= 1;\n    d.assign(2 * size, e());\n  }\n\n  template <class I>\n  segtree(I first, I last, OP op, E e) : segtree(last - first, op, e) {\n    copy(first, last, d.begin() + size);\n    for (int i = size - 1; i >= 1; i--) pull(i);\n  }\n\n  S ask(int ql, int qr, int p, int l, int r) {\n    if (ql > r || qr < l) return e();\n    if (ql <= l && qr >= r) return d[p];\n    S vl = ask(ql, qr, p * 2, l, (l + r) >> 1);\n    S vr = ask(ql, qr, p * 2 + 1, ((l + r) >> 1) + 1, r);\n    return op(vl, vr);\n  }\n\n  void set(int p, S x) {\n    p += size;\n    d[p] = x;\n    for (p >>= 1; p > 0; p >>= 1) pull(p);\n  }\n\n  S operator[](int i) { return d[i + size]; }\n  S query(int l, int r) { return ask(l, r, 1, 0, size - 1); }\n\n  // f(e()) = false\n  // find the smallest r such that f(sum([l...r])) = true\n  template <class F>\n  int find_right(int l, F f) {\n    l += size;\n    S s = e();\n    do {\n      while (l % 2 == 0) l >>= 1;\n      if (f(op(s, d[l]))) {\n        while (l < size) {\n          l *= 2;\n          if (!f(op(s, d[l]))) {\n            s = op(s, d[l]);\n            l++;\n          }\n        }\n        return l - size;\n      }\n      s = op(s, d[l]);\n      l++;\n    } while ((l & -l) != l);\n    return _n;\n  }\n\n  // find the largest l such that f(sum([l...r])) = true\n  template <class F>\n  int find_left(int r, F f) {\n    r += size + 1;\n    S s = e();\n    do {\n      r--;\n      while (r > 1 && (r % 2)) r >>= 1;\n      if (f(op(d[r], s))) {\n        while (r < size) {\n          r = 2 * r + 1;\n          if (!f(op(d[r], s))) {\n            s = op(d[r], s);\n            r--;\n          }\n        }\n        return r - size;\n      }\n      s = op(d[r], s);\n    } while ((r & -r) != r);\n    return -1;\n  }\n};\n\nclass Solution {\npublic:\n  int minimumDifference(vector<int>& nums, int k) {\n    int n = nums.size();\n    segtree<int> st(nums.begin(), nums.end(), [](int a, int b) { return a & b; }, []() { return (1 << 30) - 1; });\n    int ans = INT_MAX;\n    for (int l = 0; l < n; l++) {\n      int r = st.find_right(l, [&](int x) { return x < k; });\n      if (r < n) ans = min(ans, abs(k - st.query(l, r)));\n      if (r > l) ans = min(ans, abs(k - st.query(l, r - 1)));\n    }\n    return ans;\n  }\n};",
    "submit_ts": "1717296099",
    "subm_id": "1274690122"
}