{
    "username": "tfunk116",
    "submission": "class Solution {\n    private long solve(int[][] b, int rCut, int cCut) {\n        int m = b.length, n = b[0].length;\n        int rMax = -1, cMax = -1;\n        for (int r = 0; r < m; r++) {\n            if (r == rCut) continue;\n            for (int c = 0; c < n; c++) {\n                if (c == cCut) continue;\n                if (rMax == -1 || b[r][c] > b[rMax][cMax]) {\n                    rMax = r;\n                    cMax = c;\n                }\n            }\n        }\n        int rMaxDiffCol = -1, cMaxDiffCol = -1;\n        int rMaxDiffRow = -1, cMaxDiffRow = -1;\n        int rMaxDiffBoth = -1, cMaxDiffBoth = -1;\n        for (int r = 0; r < m; r++) {\n            if (r == rCut) continue;\n            for (int c = 0; c < n; c++) {\n                if (c == cCut) continue;\n                if (r != rMax) {\n                    if (rMaxDiffRow == -1 || b[r][c] > b[rMaxDiffRow][cMaxDiffRow]) {\n                        rMaxDiffRow = r;\n                        cMaxDiffRow = c;\n                    }\n                }\n                if (c != cMax) {\n                    if (rMaxDiffCol == -1 || b[r][c] > b[rMaxDiffCol][cMaxDiffCol]) {\n                        rMaxDiffCol = r;\n                        cMaxDiffCol = c;\n                    }\n                }\n                if (r != rMax && c != cMax) {\n                    if (rMaxDiffBoth == -1 || b[r][c] > b[rMaxDiffBoth][cMaxDiffBoth]) {\n                        rMaxDiffBoth = r;\n                        cMaxDiffBoth = c;\n                    }\n                }\n            }\n        }\n        // System.out.printf(\"cut=%d,%d -> max =%d,%d\\n\", rCut, cCut, rMax, cMax);\n        // System.out.printf(\"cut=%d,%d -> diff col =%d,%d\\n\", rCut, cCut, rMaxDiffCol, cMaxDiffCol);\n\n        long res = Long.MIN_VALUE;\n        for (int r = 0; r < m; r++) {\n            if (r == rCut) continue;\n            for (int c = 0; c < n; c++) {\n                if (c == cCut) continue;\n\n                long score = (long) b[rCut][cCut] + (long) b[r][c];\n                if (r == rMax && c == cMax) {\n                    score += (long) b[rMaxDiffBoth][cMaxDiffBoth];\n                } else if (r == rMax) {\n                    score += (long) b[rMaxDiffRow][cMaxDiffRow];\n                } else if (c == cMax) {\n                    score += (long) b[rMaxDiffCol][cMaxDiffCol];\n                } else {\n                    score += (long) b[rMax][cMax];\n                }\n                res = Math.max(res, score);\n            }\n        }\n        return res;\n    }\n    public long maximumValueSum(int[][] board) {\n        // brute force?\n        // dp\n        // let dp[r][c][k] = best score putting one rook?\n        // row-wise: either place rook or don't\n        // col-wise: either place rook or don't\n        // track top 3 indices for each row/col, and then dp?\n\n        // how many rooks can place before guarantee three in sep row/col?\n        // up to 2*max(row,col)\n        // take 2*max(row,col)+1 largest values from board, then test all 3-tuples?\n        // best solution must use one of top 3? 2*max(row,col)?\n        long res = Long.MIN_VALUE;\n        int m = board.length, n = board[0].length;\n        // min heap\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(board[a[0]][a[1]], board[b[0]][b[1]]));\n        for (int r = 0; r < m; r++) {\n            for (int c = 0; c < n; c++) {\n                pq.offer(new int[] {r, c});\n                if (pq.size() > 6) pq.poll();\n            }\n        }\n        for (int[] p : pq) {\n            int rCut = p[0], cCut = p[1];\n            res = Math.max(res, solve(board, rCut, cCut));\n            // System.out.printf(\"%d,%d -> %d\\n\", rCut, cCut, solve(board, rCut, cCut));\n        }\n        return res;\n    }\n}",
    "submit_ts": "1723908790",
    "subm_id": "1359167207"
}