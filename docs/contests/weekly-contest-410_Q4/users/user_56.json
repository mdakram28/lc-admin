{
    "username": "RoadTo2K4",
    "submission": "using i64 = long long;\ntemplate <typename T>\nT power(T a, i64 b) {\n    T res = T(1);\n    for (; b; b /= 2, a *= a) {\n        if (b & 1) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\ni64 mul(i64 a, i64 b, i64 mod) {\n    i64 res = a * b - (i64) (a * b / mod) * mod;\n    res %= mod;\n    if (res < 0) {\n        res += mod;\n    }\n    return res;\n}\n\ntemplate <i64 P>\nstruct ModNum {\n    i64 x;\n    ModNum() : x(0) {}\n    ModNum(i64 _x) : x(norm(_x % getMod())) {}\n    static i64 Mod;\n    static i64 getMod() {\n        if (P > 0) {\n            return P;\n        }\n        return Mod;\n    }\n    static void setMod(i64 _Mod) {\n        Mod = _Mod;\n    }\n    i64 norm(i64 x) const {\n        if (x < 0) {\n            return x += getMod();\n        } else if (x >= getMod()) {\n            return x -= getMod();\n        }\n        return x;\n    }\n    i64 val() const {\n        return x;\n    }\n    ModNum operator-() const {\n        ModNum res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    ModNum inv() const {\n        return power(*this, getMod() - 2);\n    }\n    ModNum &operator*=(const ModNum &lhs) {\n        if (getMod() < ((i64) 1 << 31)) {\n            x = x * lhs.x % getMod();\n        } else {\n            x = mul(x, lhs.x, getMod());\n        }\n        return *this;\n    }\n    ModNum &operator+=(const ModNum &lhs) {\n        x = norm(x + lhs.x);\n        return *this;\n    }\n    ModNum &operator-=(const ModNum &lhs) {\n        x = norm(x - lhs.x);\n        return *this;\n    }\n    ModNum &operator/=(const ModNum &lhs) {\n        return *this *= lhs.inv();\n    }\n    friend ModNum operator+(const ModNum &lhs, const ModNum &rhs) {\n        ModNum res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend ModNum operator-(const ModNum &lhs, const ModNum &rhs) {\n        ModNum res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend ModNum operator*(const ModNum &lhs, const ModNum &rhs) {\n        ModNum res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend ModNum operator/(const ModNum &lhs, const ModNum &rhs) {\n        ModNum res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend ModNum operator==(const ModNum &lhs, const ModNum &rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend ModNum operator!=(const ModNum &lhs, const ModNum &rhs) {\n        return lhs.val() != rhs.val();\n    }\n    friend std::istream &operator>>(std::istream &is, ModNum &lhs) {\n        i64 v;\n        is >> v;\n        lhs = ModNum(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const ModNum &lhs) {\n        os << lhs.val();\n        return os;\n    }\n};\n\ntemplate <>\ni64 ModNum<0>::Mod = 1E9 + 7;\n\nconstexpr int P = 1E9 + 7;\nusing Z = ModNum<P>;\nclass Solution {\npublic:\n    int countOfPairs(vector<int>& nums) {\n        int n = (int) nums.size();\n        std::vector<std::vector<Z>> dp(n, std::vector<Z> (1005, 0));\n        for (int i = 0; i <= nums[0]; ++i) {\n            dp[0][i] = 1;\n        }\n        for (int i = 1; i < n; ++i) {\n            for (int j = 1; j <= 1000; ++j) {\n                dp[i - 1][j] += dp[i - 1][j - 1];\n            }\n            for (int j = 0; j <= nums[i]; ++j) {\n                // j_pre <= j\n                // j2_pre >= j2\n                // nums[i - 1] - j_pre >= nums[i] - j\n                // nums[i - 1] - nums[i] + j >= j_pre\n                // j_pre <= nums[i - 1] - nums[i] + j\n                int j_pre = std::min(j, nums[i - 1] - nums[i] + j);\n                dp[i][j] += (j_pre >= 0 ? dp[i - 1][j_pre] : Z(0));\n            }\n        }\n        Z ans = std::accumulate(dp[n - 1].begin(), dp[n - 1].end(), Z(0));\n        return ans.val();\n    }\n};",
    "submit_ts": "1723344871",
    "subm_id": "1351543834"
}