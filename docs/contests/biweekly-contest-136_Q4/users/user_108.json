{
    "username": "iamc7054",
    "submission": "class Solution {\npublic:\n    using LL = long long;\n    typedef pair<LL, LL> PII;\n\n    vector<LL> dijkstra(LL n, vector<vector<LL>>& adj, LL s) {\n        // Initialize distances with infinity\n        vector<LL> dist(n, numeric_limits<LL>::max());\n        dist[s] = 0;\n        \n        // Priority queue to process vertices by shortest distance\n        priority_queue<PII, vector<PII>, greater<PII>> pq;\n        pq.push({0, s});\n        \n        while (!pq.empty()) {\n            LL d = pq.top().first;\n            LL u = pq.top().second;\n            pq.pop();\n            \n            // If the distance to u is already greater, we skip processing\n            if (d > dist[u]) continue;\n            \n            // Process each neighbor v of u\n            for (auto& edge : adj[u]) {\n                LL v = edge;\n                LL weight = 1;\n                if (u % 2 == 0) weight++;\n                \n                // Relax the edge (u, v)\n                if (dist[u] + weight < dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    pq.push({dist[v], v});\n                }\n            }\n        }\n        \n        return dist;\n    }\n    pair<LL, LL> treeMaxDist(LL c, LL l, vector<vector<LL>> &adj) {\n        pair<LL, LL> maxDist = { c, 0ll };\n        for(const auto &e : adj[c]) {\n            if (e != l) {\n                pair<LL, LL> dist = treeMaxDist(e, c, adj);\n                dist.second += 1 + int(e % 2 == 0);\n                if (dist.second > maxDist.second) {\n                    maxDist = dist;\n                }\n            }\n        }\n        return maxDist;\n    }\n    pair<LL, LL> getTreeDiameter(vector<vector<LL>> &adj) {\n        pair<LL, LL> inds;\n        pair<LL, LL> res = treeMaxDist(0, -1, adj);\n        inds.first = res.first;\n        inds.second = treeMaxDist(res.first, -1, adj).first;\n        return inds;\n    }\n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        const int n = edges.size() + 1;\n        vector<vector<LL>> adj(n);\n        for(auto e : edges) {\n            adj[e[0]].push_back(e[1]);\n            adj[e[1]].push_back(e[0]);\n        }\n        pair<LL, LL> r = getTreeDiameter(adj);\n        vector<LL> a = dijkstra(n, adj, r.first);\n        vector<LL> b = dijkstra(n, adj, r.second);\n        // cout << r.first << ' ' << r.second << endl;\n        // for(auto e : a) cout << e << ' ';\n        // cout << endl;\n        // for(auto e : b) cout << e << ' ';\n        // cout << endl;\n        vector<int> ans(n);\n        for(int i = 0; i < n; i++) {\n            ans[i] = max(a[i], b[i]);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722697892",
    "subm_id": "1343162710"
}