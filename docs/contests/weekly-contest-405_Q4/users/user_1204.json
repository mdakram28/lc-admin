{
    "username": "nikhil_120",
    "submission": "struct Node {\n    unordered_map<char, Node*> children;\n    vector<pair<int, int>> pairs;\n};\n\nclass PrefixTree {\npublic:\n    Node* root;\n    \n    PrefixTree() {\n        root = new Node();\n    }\n    \n    void addWord(string& word, int idx, int cost) {\n        auto binarySearch = [](vector<int>& arr, int target) {\n            int left = 0;\n            int right = arr.size() - 1;\n            while (left <= right) {\n                int mid = left + (right - left) / 2;\n                if (arr[mid] == target) return mid;\n                else if (arr[mid] < target) left = mid + 1;\n                else right = mid - 1;\n            }\n            return -1;\n        };\n        \n        Node* node = root;\n        int i = 0;\n        while (i < word.size()) {\n            char ch = word[i];\n            if (node->children.find(ch) == node->children.end()) {\n                node->children[ch] = new Node();\n            }\n            node = node->children[ch];\n            ++i;\n        }\n        node->pairs.push_back({idx, cost});\n    }\n};\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& wordList, vector<int>& costList) {\n        int x, y;\n        int targetLen = target.size();\n        PrefixTree trie;\n        \n        int i = 0;\n        while (i < wordList.size()) {\n            trie.addWord(wordList[i], i, costList[i]);\n            ++i;\n        }\n        \n        vector<int> dp(targetLen + 1, INT_MAX);\n        dp[0] = 0;\n        \n        i = 0;\n        while (i < targetLen) {\n            if (dp[i] == INT_MAX) {\n                ++i;\n                continue;\n            }\n            \n            Node* node = trie.root;\n            int j = i;\n            while (j < targetLen) {\n                if (node->children.find(target[j]) == node->children.end()) break;\n                node = node->children[target[j]];\n                \n                int k = 0;\n                while (k < node->pairs.size()) {\n                    int idx = node->pairs[k].first;\n                    int cost = node->pairs[k].second;\n                    x = y;\n                    if (j + 1 <= targetLen) {\n                        dp[j + 1] = min(dp[j + 1], dp[i] + cost);\n                    }\n                    ++k;\n                }\n                ++j;\n            }\n            ++i;\n        }\n        \n        return dp[targetLen] == INT_MAX ? -1 : dp[targetLen];\n    }\n};\n",
    "submit_ts": "1720322774",
    "subm_id": "1312358750"
}