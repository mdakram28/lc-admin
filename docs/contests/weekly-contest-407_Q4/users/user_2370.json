{
    "username": "saketw",
    "submission": "#include <bits/stdc++.h>\n#define ll long long int\n#define FASTIO std::ios::sync_with_stdio(false);\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define inf 1e18\n#define g(x) cout<<x<<endl\n#define all(x) x.begin(),x.end()\n#define input_from_file  freopen(\"input.txt\", \"r\", stdin);\n#define mod 1000000007ll\n#define sz 400005\n#define bitcnt(x) __builtin_popcountll(x)\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\nusing namespace std;\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n    cout << name << \" : \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n    const char* comma = strchr(names + 1, ',');cout.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n\nstruct SegmentTree {\n    std::vector<int> tree;\n    std::vector<int> lazy;\n\n    SegmentTree() {\n        tree.resize(2 * sz);\n        lazy.resize(2 * sz, 0);\n    }\n\n    // Function to update the segment tree lazily\n    void updateRange(int qlow, int qhigh, int delta, int node, int start, int end) {\n        if (lazy[node] != 0) {\n            // Apply the lazy update to the current node\n            tree[node] += lazy[node];\n\n            // Propagate the lazy update to the children if it's not a leaf node\n            if (start != end) {\n                lazy[2 * node + 1] += lazy[node];\n                lazy[2 * node + 2] += lazy[node];\n            }\n\n            // Reset the lazy value for the current node\n            lazy[node] = 0;\n        }\n\n        // If the query range is completely outside the current segment\n        if (qlow > end || qhigh < start)\n            return;\n\n        // If the query range is completely inside the current segment\n        if (qlow <= start && qhigh >= end) {\n            // Apply the update to the current node\n            tree[node] += delta;\n\n            // Propagate the update to the children if it's not a leaf node\n            if (start != end) {\n                lazy[2 * node + 1] += delta;\n                lazy[2 * node + 2] += delta;\n            }\n            return;\n        }\n\n        int mid = (start + end) / 2;\n\n        // Update the left and right subtrees recursively\n        updateRange(qlow, qhigh, delta, 2 * node + 1, start, mid);\n        updateRange(qlow, qhigh, delta, 2 * node + 2, mid + 1, end);\n\n        // Update the current node with the minimum value from the children\n        tree[node] = std::min(tree[2 * node + 1], tree[2 * node + 2]);\n    }\n\n    // Function to update a single element in the segment tree\n    void updatePoint(int index, int newValue, int node, int start, int end) {\n        if (start == end) {\n            // Leaf node, update the value\n            tree[node] = newValue;\n            return;\n        }\n\n        int mid = (start + end) / 2;\n\n        if (index <= mid) {\n            // Update in the left subtree\n            updatePoint(index, newValue, 2 * node + 1, start, mid);\n        } else {\n            // Update in the right subtree\n            updatePoint(index, newValue, 2 * node + 2, mid + 1, end);\n        }\n\n        // Update the current node with the minimum value from the children\n        tree[node] = std::min(tree[2 * node + 1], tree[2 * node + 2]);\n    }\n\n\n    // Function to query the segment tree for a given range\n    int queryRange(int qlow, int qhigh, int node, int start, int end) {\n        if (lazy[node] != 0) {\n            // Apply the lazy update to the current node\n            tree[node] += lazy[node];\n\n            // Propagate the lazy update to the children if it's not a leaf node\n            if (start != end) {\n                lazy[2 * node + 1] += lazy[node];\n                lazy[2 * node + 2] += lazy[node];\n            }\n\n            // Reset the lazy value for the current node\n            lazy[node] = 0;\n        }\n\n        // If the query range is completely outside the current segment\n        if (qlow > end || qhigh < start)\n            return INT_MAX;\n\n        // If the query range is completely inside the current segment\n        if (qlow <= start && qhigh >= end)\n            return tree[node];\n\n        int mid = (start + end) / 2;\n\n        // Query the left and right subtrees recursively\n        int left = queryRange(qlow, qhigh, 2 * node + 1, start, mid);\n        int right = queryRange(qlow, qhigh, 2 * node + 2, mid + 1, end);\n\n        // Return the minimum value from the left and right subtrees\n        return std::min(left, right);\n    }\n};\n\nclass Solution {\npublic:\n    SegmentTree st;\n    map <ll,vector <ll> > ma;\n    ll go(ll l, ll r, ll n,ll extra){\n        // trace(l,r,extra);\n        if(l>r)return 0;\n        ll min = st.queryRange(l,r,1,0,n-1);\n        \n        auto it = lower_bound(ma[min].begin(), ma[min].end(),l);\n        ll curr = min-extra;\n        extra += min-extra;\n        ll prev = l-1;\n        while(it != ma[min].end() && *it <= r){\n            curr += go(prev+1,*it-1,n,extra);\n            \n            prev = *it;\n            it++;\n        }\n        curr += go(prev+1,r,n,extra);\n        return curr;\n    }\n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n        ll n= nums.size();\n        ll idx = 0;\n        for(ll i=0;i<n;i++){\n            nums[i]-=target[i];\n            st.updatePoint(i,abs(nums[i]),1,0,n-1);\n            ma[abs(nums[i])].pb(i);\n        }\n        \n        ll ans = 0;\n        \n        while(idx < n){\n            \n            if(nums[idx]> 0){\n            int l = idx;\n            while(idx < n && nums[idx] > 0){\n                idx++;\n            }\n                \n            ans += go(l,idx-1,n,0);\n                // trace(l,idx-1);\n                continue;\n            }\n            else if(nums[idx] == 0){\n                idx+=1;\n                continue;\n            }else{\n                \n                int l = idx;\n                while(idx < n && nums[idx] < 0){\n                    // trace(idx);\n                    nums[idx]=abs(nums[idx]);\n                    idx+=1;\n                }\n                // trace(l,idx-1);\n                ans += go(l,idx-1,n,0);\n            }\n            \n\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1721533991",
    "subm_id": "1328021151"
}