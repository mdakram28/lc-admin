{
    "username": "cursed_archer",
    "submission": "#define ll long long\n\nclass Solution {\npublic:\n    pair<ll, ll> bfs(ll S, vector<vector<ll>>& adj, ll n) {\n        if (n == 0) return make_pair(0, 0);\n        queue<pair<ll, ll>> q;\n        q.push({S, 0});\n        vector<ll> vis(n + 1, 0);\n        vis[S] = 1;\n        ll dist = 0, farthestNode = S;\n        while (!q.empty()) {\n            auto [u, t] = q.front();\n            q.pop();\n            if (t > dist) {\n                dist = t;\n                farthestNode = u;\n            }\n            for (auto it : adj[u]) {\n                if (!vis[it]) {\n                    q.push({it, t + 1});\n                    vis[it] = 1;\n                }\n            }\n        }\n        return make_pair(farthestNode, dist);\n    }\n\n    ll treeDiameter(vector<vector<ll>>& adj) {\n        if (adj.size() == 1) return 0; \n        auto [f, _1] = bfs(0, adj, adj.size() - 1);\n        auto [_2, d] = bfs(f, adj, adj.size() - 1);\n        return d;\n    }\n\n    ll minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        ll n1 = edges1.size() + 1, n2 = edges2.size() + 1;\n        vector<vector<ll>> adj1(n1), adj2(n2);\n        \n        for (auto &it : edges1) {\n            ll u = it[0], v = it[1];\n            adj1[u].push_back(v);\n            adj1[v].push_back(u);\n        }\n        \n        for (auto &it : edges2) {\n            ll u = it[0], v = it[1];\n            adj2[u].push_back(v);\n            adj2[v].push_back(u);\n        }\n        \n        ll d1 = treeDiameter(adj1);\n        ll d2 = treeDiameter(adj2);\n        \n        return max({d1, d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1});\n    }\n};\n",
    "submit_ts": 1719718531.0
}