{
    "username": "dhuamaniluLujanCarrion",
    "submission": "// building blocks\nusing ll  = long long;\nusing db  = long double; // or double, if TL is tight\nusing str = string;      // yay python!\n\n//? priority_queue for minimum\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n//? using ull  = unsigned long long;\n//? using i64  = long long;\n//? using u64  = uint64_t;\n//? using i128 = __int128;\n//? using u128 = __uint128_t;\n//? using f128 = __float128;\n\n\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n\n#define mp make_pair\n#define f  first\n#define s  second\n\n\n\n#define tcT template <class T\n#define tcTU tcT, class U\n//! ^ lol this makes everything look weird but I'll try it\n\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n#define ts to_string\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\n\n\nconst int MOD = 1e9 + 7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  //? not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  //? for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\n\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\n\n\n#define tcTUU tcT, class ...U\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for read\");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? \",\" : \"\"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? '\\n'\n\t\t                                                             : ' ';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << '{';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << '}';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << '(';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << \" \", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << ')';\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for print\");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << \"\\033[0;31m\";\n\t\tImpl(t);\n\t\tif (debug) os << \"\\033[0m\";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << '\\n'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep(\" \", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\n\n#ifdef LOCAL\n#include \"helpers/debug.h\"\n\n#define chk(...) if (!(__VA_ARGS__)) cerr << \"\\033[41m\" << \"Line(\" << __LINE__ << \") -> function(\" \\\n\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\033[0m\" << \"\\n\", exit(0);\n\n#define MACRO(code) do {code} while (false)\n#define RAYA MACRO(cerr << \"\\033[101m\" << \"================================\" << \"\\033[0m\" << endl;)\n#else\n#define dbg(...)\n\n#define chk(...)\n#define RAYA\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\n\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), \"r\", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), \"w\", stdout); }\nvoid setIO(str s = \"\") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\t//? cout << fixed << setprecision(12);\n    //? cerr << fixed << setprecision(12);\n\tcin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + \".in\"), setOut(s + \".out\");  // for old USACO\n}\n}  // namespace FileIO\n\n\n\n//? Custom Helpers\ntemplate <typename T>\ninline T gcd(T a, T b) { while (b != 0) swap(b, a %= b); return a; }\n\nlong long binpow(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a;\n        a = a * a;\n        b >>= 1;\n    }\n    return res;\n}\n\nconst int dddx[8]{1, 0, -1,  0, 1,  1, -1, -1};\nconst int dddy[8]{0, 1,  0, -1, 1, -1,  1, -1};\n\n//? /Custom Helpers\n\n\n\n//* Template\nstruct AngelBeats {\n    using i64 = long long;\n    static constexpr i64 INF = numeric_limits<i64>::max() / 2.1;\n\n    struct alignas(32) Node {\n        i64 sum = 0, g1 = 0, l1 = 0;\n        i64 g2 = -INF, gc = 1, l2 = INF, lc = 1, add = 0;\n    };\n\n    vector<Node> v;\n    i64 n, log;\n\n    AngelBeats() {}\n    AngelBeats(int _n) : AngelBeats(vector<i64>(_n)) {}\n    AngelBeats(const vector<i64> &vc) {\n        n = 1, log = 0;\n        while(n < (int)vc.size()) n <<= 1, log++;\n        v.resize(2 * n);\n        for(i64 i = 0; i < (int)vc.size(); ++i) { v[i + n].sum = v[i + n].g1 = v[i + n].l1 = vc[i]; }\n        for(i64 i = n - 1; i; --i) update(i);\n    }\n\n    void range_chmin(int l, int r, i64 x) { inner_apply<1>(l, r, x); }\n    void range_chmax(int l, int r, i64 x) { inner_apply<2>(l, r, x); }\n    void range_add(int l, int r, i64 x) { inner_apply<3>(l, r, x); }\n    void range_update(int l, int r, i64 x) { inner_apply<4>(l, r, x); }\n    i64 range_min(int l, int r) { return inner_fold<1>(l, r); }\n    i64 range_max(int l, int r) { return inner_fold<2>(l, r); }\n    i64 range_sum(int l, int r) { return inner_fold<3>(l, r); }\n\n  private:\n    void update(int k) {\n        Node &p = v[k];\n        Node &l = v[k * 2 + 0];\n        Node &r = v[k * 2 + 1];\n\n        p.sum = l.sum + r.sum;\n\n        if(l.g1 == r.g1) {\n            p.g1 = l.g1;\n            p.g2 = max(l.g2, r.g2);\n            p.gc = l.gc + r.gc;\n        } else {\n            bool f = l.g1 > r.g1;\n            p.g1 = f ? l.g1 : r.g1;\n            p.gc = f ? l.gc : r.gc;\n            p.g2 = max(f ? r.g1 : l.g1, f ? l.g2 : r.g2);\n        }\n\n        if(l.l1 == r.l1) {\n            p.l1 = l.l1;\n            p.l2 = min(l.l2, r.l2);\n            p.lc = l.lc + r.lc;\n        } else {\n            bool f = l.l1 < r.l1;\n            p.l1 = f ? l.l1 : r.l1;\n            p.lc = f ? l.lc : r.lc;\n            p.l2 = min(f ? r.l1 : l.l1, f ? l.l2 : r.l2);\n        }\n    }\n\n    void push_add(int k, i64 x) {\n        Node &p = v[k];\n        p.sum += x << (log + __builtin_clz(k) - 31);\n        p.g1 += x;\n        p.l1 += x;\n        if(p.g2 != -INF) p.g2 += x;\n        if(p.l2 != INF) p.l2 += x;\n        p.add += x;\n    }\n    void push_min(int k, i64 x) {\n        Node &p = v[k];\n        p.sum += (x - p.g1) * p.gc;\n        if(p.l1 == p.g1) p.l1 = x;\n        if(p.l2 == p.g1) p.l2 = x;\n        p.g1 = x;\n    }\n    void push_max(int k, i64 x) {\n        Node &p = v[k];\n        p.sum += (x - p.l1) * p.lc;\n        if(p.g1 == p.l1) p.g1 = x;\n        if(p.g2 == p.l1) p.g2 = x;\n        p.l1 = x;\n    }\n    void push(int k) {\n        Node &p = v[k];\n        if(p.add != 0) {\n            push_add(k * 2 + 0, p.add);\n            push_add(k * 2 + 1, p.add);\n            p.add = 0;\n        }\n        if(p.g1 < v[k * 2 + 0].g1) push_min(k * 2 + 0, p.g1);\n        if(p.l1 > v[k * 2 + 0].l1) push_max(k * 2 + 0, p.l1);\n\n        if(p.g1 < v[k * 2 + 1].g1) push_min(k * 2 + 1, p.g1);\n        if(p.l1 > v[k * 2 + 1].l1) push_max(k * 2 + 1, p.l1);\n    }\n\n    void subtree_chmin(int k, i64 x) {\n        if(v[k].g1 <= x) return;\n        if(v[k].g2 < x) {\n            push_min(k, x);\n            return;\n        }\n        push(k);\n        subtree_chmin(k * 2 + 0, x);\n        subtree_chmin(k * 2 + 1, x);\n        update(k);\n    }\n\n    void subtree_chmax(int k, i64 x) {\n        if(x <= v[k].l1) return;\n        if(x < v[k].l2) {\n            push_max(k, x);\n            return;\n        }\n        push(k);\n        subtree_chmax(k * 2 + 0, x);\n        subtree_chmax(k * 2 + 1, x);\n        update(k);\n    }\n\n    template <int cmd> inline void _apply(int k, i64 x) {\n        if constexpr(cmd == 1) subtree_chmin(k, x);\n        if constexpr(cmd == 2) subtree_chmax(k, x);\n        if constexpr(cmd == 3) push_add(k, x);\n        if constexpr(cmd == 4) subtree_chmin(k, x), subtree_chmax(k, x);\n    }\n\n    template <int cmd> void inner_apply(int l, int r, i64 x) {\n        if(l == r) return;\n        l += n, r += n;\n        for(int i = log; i >= 1; i--) {\n            if(((l >> i) << i) != l) push(l >> i);\n            if(((r >> i) << i) != r) push((r - 1) >> i);\n        }\n        {\n            int l2 = l, r2 = r;\n            while(l < r) {\n                if(l & 1) _apply<cmd>(l++, x);\n                if(r & 1) _apply<cmd>(--r, x);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n        for(int i = 1; i <= log; i++) {\n            if(((l >> i) << i) != l) update(l >> i);\n            if(((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <int cmd> inline i64 e() {\n        if constexpr(cmd == 1) return INF;\n        if constexpr(cmd == 2) return -INF;\n        return 0;\n    }\n\n    template <int cmd> inline void op(i64 &a, const Node &b) {\n        if constexpr(cmd == 1) a = min(a, b.l1);\n        if constexpr(cmd == 2) a = max(a, b.g1);\n        if constexpr(cmd == 3) a += b.sum;\n    }\n\n    template <int cmd> i64 inner_fold(int l, int r) {\n        if(l == r) return e<cmd>();\n        l += n, r += n;\n        for(int i = log; i >= 1; i--) {\n            if(((l >> i) << i) != l) push(l >> i);\n            if(((r >> i) << i) != r) push((r - 1) >> i);\n        }\n        i64 lx = e<cmd>(), rx = e<cmd>();\n        while(l < r) {\n            if(l & 1) op<cmd>(lx, v[l++]);\n            if(r & 1) op<cmd>(rx, v[--r]);\n            l >>= 1;\n            r >>= 1;\n        }\n        if constexpr(cmd == 1) lx = min(lx, rx);\n        if constexpr(cmd == 2) lx = max(lx, rx);\n        if constexpr(cmd == 3) lx += rx;\n        return lx;\n    }\n};\n\n/**\n * @brief Range Chmin Chmax Add Update Range Min Max Sum Segment Tree Beats!\n * @docs docs/segment-tree/segment-tree-beats.md\n */\n\n//* /Template\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        AngelBeats st(vector<long long>(n + 5));\n        vi ans;\n        int current_ans = n - 1;\n        each(que, queries) { // TODO [l, r[\n            int u = que[0];\n            int v = que[1];\n            if(st.range_sum(u + 1, v) == 0) {\n                current_ans -= (v - u) - 1;\n                ans.eb(current_ans);\n                st.range_update(u + 1, v, 1);\n            } else if(st.range_sum(u + 1, v) == (v - u)) {\n                ans.eb(current_ans);\n            } else {\n                int sum = st.range_sum(u + 1, v);\n                current_ans += sum;\n                st.range_update(u + 1, v, 1);\n                current_ans -= (v - u) - 1;\n                ans.eb(current_ans);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722740764",
    "subm_id": "1343728165"
}