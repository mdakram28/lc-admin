{
    "username": "LayCurse",
    "submission": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"inline\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define MD (1000000007U)\ntemplate<class T> struct cLtraits_identity{\n  using type = T;\n}\n;\ntemplate<class T> using cLtraits_try_make_signed =\n  typename conditional<\n    is_integral<T>::value,\n    make_signed<T>,\n    cLtraits_identity<T>\n    >::type;\ntemplate <class S, class T> struct cLtraits_common_type{\n  using tS = typename cLtraits_try_make_signed<S>::type;\n  using tT = typename cLtraits_try_make_signed<T>::type;\n  using type = typename common_type<tS,tT>::type;\n}\n;\ntemplate<class S, class T> inline auto min_L(S a, T b)\n-> typename cLtraits_common_type<S,T>::type{\n  return (typename cLtraits_common_type<S,T>::type) a <= (typename cLtraits_common_type<S,T>::type) b ? a : b;\n}\nstruct Modint{\n  unsigned val;\n  Modint(){\n    val=0;\n  }\n  Modint(int a){\n    val = ord(a);\n  }\n  Modint(unsigned a){\n    val = ord(a);\n  }\n  Modint(long long a){\n    val = ord(a);\n  }\n  Modint(unsigned long long a){\n    val = ord(a);\n  }\n  inline unsigned ord(unsigned a){\n    return a%MD;\n  }\n  inline unsigned ord(int a){\n    a %= (int)MD;\n    if(a < 0){\n      a += MD;\n    }\n    return a;\n  }\n  inline unsigned ord(unsigned long long a){\n    return a%MD;\n  }\n  inline unsigned ord(long long a){\n    a %= (int)MD;\n    if(a < 0){\n      a += MD;\n    }\n    return a;\n  }\n  inline unsigned get(){\n    return val;\n  }\n  inline Modint &operator++(){\n    val++;\n    if(val >= MD){\n      val -= MD;\n    }\n    return *this;\n  }\n  inline Modint &operator--(){\n    if(val == 0){\n      val = MD - 1;\n    }\n    else{\n      --val;\n    }\n    return *this;\n  }\n  inline Modint operator++(int a){\n    Modint res(*this);\n    val++;\n    if(val >= MD){\n      val -= MD;\n    }\n    return res;\n  }\n  inline Modint operator--(int a){\n    Modint res(*this);\n    if(val == 0){\n      val = MD - 1;\n    }\n    else{\n      --val;\n    }\n    return res;\n  }\n  inline Modint &operator+=(Modint a){\n    val += a.val;\n    if(val >= MD){\n      val -= MD;\n    }\n    return *this;\n  }\n  inline Modint &operator-=(Modint a){\n    if(val < a.val){\n      val = val + MD - a.val;\n    }\n    else{\n      val -= a.val;\n    }\n    return *this;\n  }\n  inline Modint &operator*=(Modint a){\n    val = ((unsigned long long)val*a.val)%MD;\n    return *this;\n  }\n  inline Modint &operator/=(Modint a){\n    return *this *= a.inverse();\n  }\n  inline Modint operator+(Modint a){\n    return Modint(*this)+=a;\n  }\n  inline Modint operator-(Modint a){\n    return Modint(*this)-=a;\n  }\n  inline Modint operator*(Modint a){\n    return Modint(*this)*=a;\n  }\n  inline Modint operator/(Modint a){\n    return Modint(*this)/=a;\n  }\n  inline Modint operator+(int a){\n    return Modint(*this)+=Modint(a);\n  }\n  inline Modint operator-(int a){\n    return Modint(*this)-=Modint(a);\n  }\n  inline Modint operator*(int a){\n    return Modint(*this)*=Modint(a);\n  }\n  inline Modint operator/(int a){\n    return Modint(*this)/=Modint(a);\n  }\n  inline Modint operator+(long long a){\n    return Modint(*this)+=Modint(a);\n  }\n  inline Modint operator-(long long a){\n    return Modint(*this)-=Modint(a);\n  }\n  inline Modint operator*(long long a){\n    return Modint(*this)*=Modint(a);\n  }\n  inline Modint operator/(long long a){\n    return Modint(*this)/=Modint(a);\n  }\n  inline Modint operator-(void){\n    Modint res;\n    if(val){\n      res.val=MD-val;\n    }\n    else{\n      res.val=0;\n    }\n    return res;\n  }\n  inline operator bool(void){\n    return val!=0;\n  }\n  inline operator int(void){\n    return get();\n  }\n  inline operator long long(void){\n    return get();\n  }\n  inline Modint inverse(){\n    int a = val;\n    int b = MD;\n    int u = 1;\n    int v = 0;\n    int t;\n    Modint res;\n    while(b){\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    if(u < 0){\n      u += MD;\n    }\n    res.val = u;\n    return res;\n  }\n  inline Modint pw(unsigned long long b){\n    Modint a(*this);\n    Modint res;\n    res.val = 1;\n    while(b){\n      if(b&1){\n        res *= a;\n      }\n      b >>= 1;\n      a *= a;\n    }\n    return res;\n  }\n  inline bool operator==(int a){\n    return ord(a)==val;\n  }\n  inline bool operator!=(int a){\n    return ord(a)!=val;\n  }\n}\n;\ninline Modint operator+(int a, Modint b){\n  return Modint(a)+=b;\n}\ninline Modint operator-(int a, Modint b){\n  return Modint(a)-=b;\n}\ninline Modint operator*(int a, Modint b){\n  return Modint(a)*=b;\n}\ninline Modint operator/(int a, Modint b){\n  return Modint(a)/=b;\n}\ninline Modint operator+(long long a, Modint b){\n  return Modint(a)+=b;\n}\ninline Modint operator-(long long a, Modint b){\n  return Modint(a)-=b;\n}\ninline Modint operator*(long long a, Modint b){\n  return Modint(a)*=b;\n}\ninline Modint operator/(long long a, Modint b){\n  return Modint(a)/=b;\n}\n#define main dummy_main\nint main(){\n  return 0;\n}\n#undef main\nclass Solution{\n  public:\n  int countOfPairs(vector<int>& A){\n    int i, k;\n    int N = A.size();\n    int x;\n    int y;\n    int mn;\n    int mx;\n    Modint dp[1010];\n    Modint nx[1010];\n    Modint s[1010];\n    Modint res;\n    for(i=(0);i<(1010);i++){\n      dp[i] = 0;\n    }\n    for(i=(0);i<(A[0]+1);i++){\n      dp[i] = 1;\n    }\n    for(k=(1);k<(N);k++){\n      for(i=(0);i<(1010);i++){\n        nx[i] = 0;\n      }\n      s[0] = 0;\n      for(i=(0);i<(1008);i++){\n        s[i+1] = s[i] + dp[i];\n      }\n      for(i=(0);i<(A[k]+1);i++){\n        x = i;\n        y = A[k] - i;\n        mn = 0;\n        mx =min_L(min_L(1000, x), A[k-1] - y);\n        if(mn <= mx){\n          nx[i] += s[mx+1] - s[mn];\n        }\n      }\n      for(i=(0);i<(1010);i++){\n        dp[i] = nx[i];\n      }\n    }\n    res = 0;\n    for(i=(0);i<(1010);i++){\n      res += dp[i];\n    }\n    return res;\n  }\n}\n;\n// cLay version 20240810-1 [beta]\n\n// --- original code ---\n// #define main dummy_main\n// {}\n// #undef main\n// \n// class Solution {\n// public:\n//   int countOfPairs(vector<int>& A) {\n//     int N = A.size();\n//     int x, y, mn, mx;\n//     Modint dp[1010], nx[1010], s[1010], res;\n// \n//     rep(i,1010) dp[i] = 0;\n//     rep(i,A[0]+1) dp[i] = 1;\n// \n//     rep(k,1,N){\n//       rep(i,1010) nx[i] = 0;\n//       s[0] = 0;\n//       rep(i,1008) s[i+1] = s[i] + dp[i];\n// \n//       rep(i,A[k]+1){\n//         x = i;\n//         y = A[k] - i;\n// \n//         mn = 0;\n//         mx = min(1000, x, A[k-1] - y);\n//         if(mn <= mx) nx[i] += s[mx+1] - s[mn];\n//       }\n// \n//       rep(i,1010) dp[i] = nx[i];\n//     }\n// \n//     res = 0;\n//     rep(i,1010) res += dp[i];\n//     return res;\n//   }\n// };\n",
    "submit_ts": "1723344447",
    "subm_id": "1351534629"
}