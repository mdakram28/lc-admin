{
    "username": "qdd1999",
    "submission": "using i64 = int64_t;\n\nconst i64 INF = 1e15;\n\nstruct MCMF {\n  struct Edge {\n    int from, to;\n    i64 cap, cost;\n    Edge(int from, int to, i64 cap, i64 cost) : from(from), to(to), cap(cap), cost(cost) {}\n  };\n\n  int n, s, t;\n  i64 flow, cost;\n  vector<Edge> es;\n  vector<vector<int>> g;\n  vector<i64> d, a;  // dis, add, prev\n  vector<int> p, in;\n\n  MCMF(int n, int s, int t) : n(n), s(s), t(t), flow(0), cost(0), g(n + 1), p(n + 1), a(n + 1) {}\n\n  void add_edge(int u, int v, i64 cap, i64 cost) {\n    g[u].push_back(es.size());\n    es.emplace_back(u, v, cap, cost);\n    g[v].push_back(es.size());\n    es.emplace_back(v, u, 0, -cost);\n  }\n\n  bool spfa() {\n    d.assign(n + 1, INF);\n    in.assign(n + 1, 0);\n    d[s] = 0;\n    in[s] = 1;\n    a[s] = INF;\n    queue<int> q;\n    q.push(s);\n    while (!q.empty()) {\n      int u = q.front();\n      q.pop();\n      in[u] = 0;\n      for (int& i : g[u]) {\n        Edge& e = es[i];\n        if (e.cap && d[e.to] > d[u] + e.cost) {\n          d[e.to] = d[u] + e.cost;\n          p[e.to] = i;\n          a[e.to] = min(a[u], e.cap);\n          if (!in[e.to]) {\n            q.push(e.to);\n            in[e.to] = 1;\n          }\n        }\n      }\n    }\n    return d[t] != INF;\n  }\n\n  void solve() {\n    while (spfa()) {\n      flow += a[t];\n      cost += a[t] * d[t];\n      int u = t;\n      while (u != s) {\n        es[p[u]].cap -= a[t];\n        es[p[u] ^ 1].cap += a[t];\n        u = es[p[u]].from;\n      }\n    }\n  }\n};\n\nclass Solution {\npublic:\n  long long maximumValueSum(vector<vector<int>>& board) {\n    int n = board.size();\n    int m = board[0].size();\n    MCMF flow(n + m + 4, 0, n + m + 3);\n    flow.add_edge(0, 1, 3, 0);\n    for (int i = 0; i < n; i++) {\n      flow.add_edge(1, i + 2, 1, 0);\n    }\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        flow.add_edge(i + 2, n + j + 2, 1, -board[i][j]);\n      }\n    }\n    for (int i = 0; i < m; i++) {\n      flow.add_edge(n + i + 2, n + m + 2, 1, 0);\n    }\n    flow.add_edge(n + m + 2, n + m + 3, 3, 0);\n    flow.solve();\n    return -flow.cost;\n  }\n};",
    "submit_ts": "1723906136",
    "subm_id": "1359037160"
}