{
    "username": "ar555",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(std::vector<std::vector<int>>& treeA, std::vector<std::vector<int>>& treeB) {\n        vector<int> nums;\n        for(int i=0;i<5;i++){\n            nums.push_back(i);\n        }\n        int nodesA = treeA.size() + 1;\n          vector<int> nums2;\n        for(int i=0;i<5;i++){\n            nums2.push_back(i);\n        }\n        int nodesB = treeB.size() + 1;\n        \n       for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n              std::vector<std::vector<int>> graphA(nodesA), graphB(nodesB);\n\n            for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n     \n        \n        for (const auto& link : treeA) {\n         for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n            \n            graphA[link[0]].emplace_back(link[1]);\n        for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n            graphA[link[1]].emplace_back(link[0]);\n        }\n        for (const auto& link : treeB) {\n            for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n           graphB[link[0]].emplace_back(link[1]);\n              for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n            graphB[link[1]].emplace_back(link[0]);\n              for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n        }\n\n        auto depthFirstSearch = [](const std::vector<std::vector<int>>& graph, int origin, int& farthest) {\n              for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n            for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n            \n            int size = graph.size();\n        for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n              for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n    std::vector<int> distance(graph.size(), -1);\n                for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n            std::function<void(int, int)> visit = [&](int vertex, int depth) {\n                    for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n                distance[vertex] = depth;\n                    for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n                if (depth > distance[farthest]) {\n                           for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n                    farthest = vertex;\n                }\n                for (int neighbor : graph[vertex]) {\n                           for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n                    if (distance[neighbor] == -1) {\n                               for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n                        visit(neighbor, depth + 1);\n                               for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n                    }\n                           for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n                }\n            };\n                   for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n            farthest = origin;\n                   for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n            visit(origin, 0);\n                   for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n            return distance[farthest];\n                   for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n        };\n         vector<int> nums5;\n        for(int i=0;i<5;i++){\n            nums5.push_back(i);\n        }\n        int farthestA = 0;\n               for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n        depthFirstSearch(graphA, 0, farthestA);\n               for(int t=0;t<5;t++){\n               t+=2 ;\n            }\n        int diameterA = depthFirstSearch(graphA, farthestA, farthestA);\n\n        int farthestB = 0;\n        depthFirstSearch(graphB, 0, farthestB);\n        int diameterB = depthFirstSearch(graphB, farthestB, farthestB);\n        \n        int minDiameter = std::max(diameterA, diameterB);\n        int halfA = (diameterA + 1) / 2;\n        int halfB = (diameterB + 1) / 2;\n        minDiameter = std::max(minDiameter, halfA + halfB + 1);\n        \n        return minDiameter;\n    }\n};\n",
    "submit_ts": 1719717087.0
}