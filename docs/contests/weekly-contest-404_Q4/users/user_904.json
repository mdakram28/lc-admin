{
    "username": "suyash21__",
    "submission": "class Solution {\npublic:\n    int getDiameter(vector<vector<int>>& edgesTemp){\n        int n = edgesTemp.size();\n        vector<vector<int>> edges(n+1);\n        for(auto x : edgesTemp){\n            edges[x[0]].push_back(x[1]);\n            edges[x[1]].push_back(x[0]);\n        }\n        vector<int> dist(n+1, 0);\n        function<void(int, int, int)> dfs = [&](int node, int parent, int depth){\n            dist[node] = depth;\n            for(auto neighbours : edges[node]){\n                if(neighbours != parent)\n                    dfs(neighbours, node, depth+1);\n            }\n        };\n        dfs(0, -1, 0);\n        int endD = max_element(dist.begin(), dist.end()) - dist.begin();\n        dfs(endD, -1, 0);\n        return *max_element(dist.begin(), dist.end());\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int diameter1 = getDiameter(edges1);\n        int diameter2 = getDiameter(edges2);\n        int ans1 = diameter1 % 2 == 1 ? diameter1 / 2 + 1 : diameter1 / 2;\n        int ans2 = diameter2 % 2 == 1 ? diameter2 / 2 + 1 : diameter2 / 2;\n        return max({ans1 + ans2 + 1, diameter1, diameter2});\n    }\n};",
    "submit_ts": 1719719998.0
}