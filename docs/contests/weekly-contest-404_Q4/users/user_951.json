{
    "username": "vedapaulchowdhury",
    "submission": "from collections import deque\nfrom typing import List\n\nclass Solution:\n    def bfs(self, graph: List[List[int]], start: int) -> (int, int):\n        n = len(graph)\n        distance = [-1] * n\n        distance[start] = 0\n        furthest_node = start\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if distance[neighbor] == -1:\n                    distance[neighbor] = distance[node] + 1\n                    queue.append(neighbor)\n                    if distance[neighbor] > distance[furthest_node]:\n                        furthest_node = neighbor\n                        \n        return furthest_node, distance[furthest_node]\n\n    def find_diameter(self, graph: List[List[int]]) -> int:\n        start_node, _ = self.bfs(graph, 0)\n        furthest_node, distance = self.bfs(graph, start_node)\n        return distance\n\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        size1 = len(edges1) + 1\n        size2 = len(edges2) + 1\n\n        graph1 = [[] for _ in range(size1)]\n        graph2 = [[] for _ in range(size2)]\n\n        for edge in edges1:\n            graph1[edge[0]].append(edge[1])\n            graph1[edge[1]].append(edge[0])\n\n        for edge in edges2:\n            graph2[edge[0]].append(edge[1])\n            graph2[edge[1]].append(edge[0])\n\n        diameter1 = self.find_diameter(graph1)\n        diameter2 = self.find_diameter(graph2)\n\n        half1 = (diameter1 + 1) // 2\n        half2 = (diameter2 + 1) // 2\n\n        min_diameter = max(diameter1, diameter2, half1 + half2 + 1)\n        return min_diameter\n\n\n\n\n\n\n\n\n        ",
    "submit_ts": "1719719306",
    "subm_id": "1304438719"
}