{
    "username": "habersaat",
    "submission": "class Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n\n        # Find min cost associated with each word\n        d = {}\n        for cost, word in list(zip(costs, words)):\n            if word not in d:\n                d[word] = cost\n            d[word] = min(d[word], cost)\n        \n        wordCost = []\n        for word, cost in d.items():\n            wordCost.append((cost, word))\n\n\n        n = len(target)\n        dp = [float('inf')] * (n+1)\n        dp[0] = 0\n\n        for i in range(1, n+1):\n            for j, (cost, word) in enumerate(wordCost):\n                if i >= len(word) and target[i-len(word):i] == word:\n                    dp[i] = min(dp[i], dp[i-len(word)] + cost)\n\n        return dp[-1] if dp[-1] != float('inf') else -1\n\n\n\n\n\n\n\n        res = float('inf')\n        minHeap = [(0, 0, \"\")] # (currCost, i, word)\n        visit = set()\n\n        while minHeap:\n            cost, i, word = heapq.heappop(minHeap)\n            \n            j = 0\n            while j < len(word) and i < len(target) and word[j] == target[i]:\n                i += 1\n                j += 1\n\n            # Either went past len(target) or didn't match on a letter\n            if j < len(word):\n                continue\n\n            # Finished word and target\n            elif i == len(target):\n                return cost\n\n            # Added word but need to add more\n            if i in visit: continue\n            for c, w in wordCost:\n                if w[0] == target[i]:\n                    heapq.heappush(minHeap, (cost+c, i, w))\n            visit.add(i)\n\n        return -1",
    "submit_ts": "1720323327",
    "subm_id": "1312372886"
}