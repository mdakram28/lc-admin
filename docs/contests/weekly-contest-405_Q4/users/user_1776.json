{
    "username": "samarthgattu",
    "submission": "struct TrieNode {\n    unordered_map<char, TrieNode*> ma;\n    TrieNode* fail;\n    int last;\n    TrieNode() : fail(nullptr), last(-1) {}\n};\n\nclass charTrie {\npublic:\n    TrieNode* tt;\n    vector<string> words;\n    vector<int> costs;\n\n    charTrie(const vector<string>& words, const vector<int>& costs) : words(words), costs(costs) {\n        tt = new TrieNode();\n        cons();\n        fun();\n    }\n\n    void cons() {\n        for (int i = 0; i < words.size(); ++i) {\n            TrieNode* node = tt;\n            for (char c : words[i]) {\n                if (!node->ma.count(c)) {\n                    node->ma[c] = new TrieNode();\n                }\n                node = node->ma[c];\n            }\n            node->last = i;\n        }\n    }\n\n    void fun() {\n        queue<TrieNode*> q;\n        for (auto& p : tt->ma) {\n            p.second->fail = tt;\n            q.push(p.second);\n        }\n\n        while (!q.empty()) {\n            TrieNode* current = q.front();\n            q.pop();\n\n            for (auto& p : current->ma) {\n                char c = p.first;\n                TrieNode* child = p.second;\n                TrieNode* fail = current->fail;\n\n                while (fail && !fail->ma.count(c)) {\n                    fail = fail->fail;\n                }\n\n                if (fail) {\n                    child->fail = fail->ma[c];\n                } else {\n                    child->fail = tt;\n                }\n\n                q.push(child);\n            }\n        }\n    }\n\n    int check(const string& target) {\n        int n = target.size();\n        vector<int> dp(n + 1, INT_MAX);\n        dp[0] = 0;  \n\n        TrieNode* node = tt;\n        for (int i = 0; i < n; ++i) {\n            while (node && !node->ma.count(target[i])) {\n                node = node->fail;\n            }\n\n            if (node) {\n                node = node->ma[target[i]];\n            } else {\n                node = tt;\n            }\n\n            TrieNode* temp = node;\n            while (temp) {\n                if (temp->last != -1) {\n                    int wordIndex = temp->last;\n                    int wordLen = words[wordIndex].size();\n                    if (i + 1 >= wordLen && dp[i + 1 - wordLen] != INT_MAX) {\n                        dp[i + 1] = min(dp[i + 1], dp[i + 1 - wordLen] + costs[wordIndex]);\n                    }\n                }\n                temp = temp->fail;\n            }\n        }\n\n        return dp[n] == INT_MAX ? -1 : dp[n];\n    }\n};\n\nint solve(string tt, vector<string>& ww, vector<int>& cc) {\n    charTrie ac(ww, cc);\n    int haha=ac.check(tt);\n    return haha;\n}\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        vector<string> ww;\n        vector<int> cc;\n        map<string, int> ma;\n        for(int i=0;i<words.size();i++){\n            if(ma.find(words[i])!=ma.end()){\n                ma[words[i]]=min(ma[words[i]],costs[i]);\n            }else{\n                ma[words[i]]=costs[i];\n            }\n        }\n        for(auto &i: ma){\n            ww.push_back(i.first);\n            cc.push_back(i.second);\n        }\n         int sol = solve(target, ww, cc);\n         return sol;\n    }\n};",
    "submit_ts": "1720324751",
    "subm_id": "1312407207"
}