{
    "username": "LalitRathor",
    "submission": "class Solution {\npublic:\n    pair<int, vector<int>> bfs(int start, const vector<vector<int>>& graph, int n) {\n    vector<int> dist(n, -1); // Changed to n instead of n+1 to avoid out of bounds\n    dist[start] = 0;\n    queue<int> q;\n    q.push(start);\n    \n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        \n        for (int neighbor : graph[node]) {\n            if (dist[neighbor] == -1) {  // not visited\n                dist[neighbor] = dist[node] + 1;\n                q.push(neighbor);\n            }\n        }\n    }\n    \n    int farthest_node = max_element(dist.begin(), dist.end()) - dist.begin();\n    return {farthest_node, dist};\n}\n\nint minimumDiameterAfterMerge(vector<vector<int>>& e1, vector<vector<int>>& e2) {\n    int n = e1.size() + 1, m = e2.size() + 1;\n    vector<vector<int>> v1(n), v2(m);\n\n    for (const auto& edge : e1) {\n        v1[edge[0]].push_back(edge[1]);\n        v1[edge[1]].push_back(edge[0]);\n    }\n    for (const auto& edge : e2) {\n        v2[edge[0]].push_back(edge[1]);\n        v2[edge[1]].push_back(edge[0]);\n    }\n\n    auto [f1, da] = bfs(0, v1, n);\n    auto [f2, dist_from_v] = bfs(f1, v1, n);\n    auto [_, dist_from_w] = bfs(f2, v1, n);\n\n    auto [f3, da1] = bfs(0, v2, m);\n    auto [f4, dist_from_v1] = bfs(f3, v2, m);\n    auto [trf, dist_from_w1] = bfs(f4, v2, m);\n\n    int ans = 0;\n    vector<int> ma(n, 0);\n    for (int i = 0; i < n; ++i) ma[i] = max(ma[i], dist_from_v[i]);\n    for (int i = 0; i < n; ++i) ma[i] = max(ma[i], dist_from_w[i]), ans = max(ans, ma[i]);\n\n    vector<int> ma2(m, 0);\n    for (int i = 0; i < m; ++i) ma2[i] = max(ma2[i], dist_from_v1[i]);\n    for (int i = 0; i < m; ++i) ma2[i] = max(ma2[i], dist_from_w1[i]), ans = max(ans, ma2[i]);\n\n    sort(ma.begin(), ma.end());\n    sort(ma2.begin(), ma2.end());\n    ans = max(ans, ma[0] + ma2[0] + 1);\n\n    return ans;\n}\n};",
    "submit_ts": "1719717844",
    "subm_id": "1304402183"
}