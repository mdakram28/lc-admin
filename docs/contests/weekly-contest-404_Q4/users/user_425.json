{
    "username": "40547011S",
    "submission": "class Solution {\npublic:\n    \n    void find_longest(int ind, vector<vector<int>>& graph, int prev, int dist, int& target, int& max_dist) {\n        if (dist > max_dist) {\n            max_dist = dist;\n            target = ind;\n        }\n        for (int i = 0; i < graph[ind].size(); i += 1) {\n            if (graph[ind][i] != prev) {\n                find_longest(graph[ind][i], graph, ind, dist + 1, target, max_dist);\n            }\n        }\n    }\n    \n    bool find_path(vector<vector<int>>& graph, int start, int end, int ind, int prev, vector<int>& path) {\n        if (end == ind) {\n            path.push_back(ind);\n            return true;\n        }    \n        \n        for (int i = 0; i < graph[ind].size(); i += 1) {\n            if (graph[ind][i] != prev) {\n                if (find_path(graph, start, end, graph[ind][i], ind, path)) {\n                    path.push_back(ind);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    pair<int, int> find_diameter_mid(vector<vector<int>>& graph) {\n        int end1 = -1, max_dist = -1;\n\n        find_longest(0, graph, -1, 0, end1, max_dist);\n\n        int end2 = -1;\n        max_dist = -1;\n        find_longest(end1, graph, -1, 0, end2, max_dist);\n        vector<int> path;\n\n        find_path(graph, end1, end2, end1, -1, path);\n        int n = path.size();\n        \n        if (n > 1 && n % 2 == 0) {\n            return {path[n / 2 - 1], path[n / 2]};\n        }\n        return {path[n / 2], -1};\n        \n    }\n    \n    int find_diameter(vector<vector<int>>& graph) {\n        int end1 = -1, max_dist = 0;\n        find_longest(0, graph, -1, 0, end1, max_dist);\n        \n        int end2 = -1;\n        max_dist = 0;\n        find_longest(end1, graph, -1, 0, end2, max_dist);\n        \n        return max_dist;\n        \n    }\n    \n    int shift = 1e5 + 1;\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        if (edges1.size() == 0 && edges2.size() == 0) {\n            return 1;\n        }\n        \n        vector<vector<int>> graph1(edges1.size() + 1), graph2(edges2.size() + 1);\n        vector<vector<int>> merge(shift + edges2.size() + 1 + 1);\n        \n        for (int i = 0; i < edges1.size(); i += 1) {\n            graph1[edges1[i][0]].push_back(edges1[i][1]);\n            graph1[edges1[i][1]].push_back(edges1[i][0]);\n        }\n        \n        for (int i = 0; i < edges2.size(); i += 1) {\n            graph2[edges2[i][0]].push_back(edges2[i][1]);\n            graph2[edges2[i][1]].push_back(edges2[i][0]);\n        }\n        \n        auto [t11, t12] = find_diameter_mid(graph1);\n        auto [t21, t22] = find_diameter_mid(graph2);\n        \n        // cout << t11 << \" \" << t12 << \" \" << t21 << \" \" << t22 << endl;\n        \n        for (int i = 0; i < edges1.size(); i += 1) {\n\n            merge[edges1[i][0]].push_back(edges1[i][1]);\n            merge[edges1[i][1]].push_back(edges1[i][0]);\n        }\n        \n        for (int i = 0; i < edges2.size(); i += 1) {\n            merge[edges2[i][0] + shift].push_back(edges2[i][1] + shift);\n            merge[edges2[i][1] + shift].push_back(edges2[i][0] + shift);\n        }\n        // cout << t11 << \" \" << t12 << \" \" << t21 << \" \" << t22 << endl;\n        t21 += shift;\n        merge[t11].push_back(t21);\n        merge[t21].push_back(t11);\n        \n        \n        int ans = find_diameter(merge);\n        merge[t11].pop_back();\n        merge[t21].pop_back();\n        // cout << t11 << \" \" << t12 << \" \" << t21 << \" \" << t22 << endl;\n        if (t12 != -1 && t22 != -1) {\n            int tmp = t22 + shift;\n            merge[t12].push_back(tmp);\n            merge[tmp].push_back(t12);\n            ans = max(ans, find_diameter(merge));\n            merge[t12].pop_back();\n            merge[tmp].pop_back();\n        }\n        \n        if (t12 != -1) {\n\n            merge[t12].push_back(t21);\n            merge[t21].push_back(t12);\n            ans = max(ans, find_diameter(merge));\n            merge[t12].pop_back();\n            merge[t21].pop_back();\n        }\n        \n        if (t21 != -1) {\n\n            merge[t11].push_back(t21);\n            merge[t21].push_back(t11);\n            ans = max(ans, find_diameter(merge));\n            merge[t11].pop_back();\n            merge[t21].pop_back();\n        }\n        return ans;\n        \n    }\n};",
    "submit_ts": "1719718593",
    "subm_id": "1304421185"
}