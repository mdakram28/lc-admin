{
    "username": "farmerboy",
    "submission": "#include <bits/stdc++.h>\n#define FI first\n#define SE second\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) int((a).size())\n#define MS(s, n) memset(s, n, sizeof(s))\n#define FOR(i,a,b) for (int i = (a); i <= (b); i++)\n#define FORE(i,a,b) for (int i = (a); i >= (b); i--)\n#define FORALL(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define TRAV(x, a) for (auto &x : a)\n\nusing namespace std;\nusing ll = long long; using ld = double; \nusing pi = pair<int, int>; using pl = pair<ll, ll>; using pd = pair<ld, ld>;\nusing cd = complex<ld>; using vcd = vector<cd>;\n\nusing vi = vector<int>; using vl = vector<ll>;\nusing vd = vector<ld>; using vs = vector<string>;\nusing vpi = vector<pi>; using vpl = vector<pl>; using vpd = vector<pd>; // vector<pair>\n\ntemplate<class T> using min_pq = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T> inline int ckmin(T& a, const T& val) { return val < a ? a = val, 1 : 0; }\ntemplate<class T> inline int ckmax(T& a, const T& val) { return a < val ? a = val, 1 : 0; }\ntemplate<class T> void remDup(vector<T>& v) { sort(ALL(v)); v.erase(unique(ALL(v)), end(v)); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { return x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll ceilDiv(ll a, ll b) { return a / b + ((a ^ b) > 0 && a % b); } // divide a by b rounded up\nll floorDiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); } // divide a by b rounded down\nvoid setPrec(int x) { cout << fixed << setprecision(x); }\n\n// TO_STRING\n#define ts to_string\nstring ts(char c) { return string(1, c); }\nstring ts(const char* s) { return (string) s; }\nstring ts(string s) { return s; }\nstring ts(bool b) { return (b ? \"true\" : \"false\"); }\n\ntemplate<class T> using V = vector<T>;\ntemplate<class T> string ts(complex<T> c);\nstring ts(V<bool> v);\ntemplate<size_t sz> string ts(bitset<sz> b);\ntemplate<class T> string ts(T v);\ntemplate<class T, class U> string ts(pair<T,U> p);\ntemplate<class ...U> string ts(tuple<U...> u);\n\ntemplate<class T> string ts(complex<T> c) { stringstream ss; ss << c; return ss.str(); }\nstring ts(V<bool> v) {string res = \"{\"; FOR(i,0,SZ(v)-1) res += char('0'+v[i]); res += \"}\"; return res; }\ntemplate<size_t sz> string ts(bitset<sz> b) { string res = \"\"; FOR(i,0,SZ(b)-1) res += char('0'+b[i]); return res; }\ntemplate<class T> string ts(T v) { // containers with begin(), end()\n    bool fst = 1; string res = \"\";\n    for (const auto& x: v) { if (!fst) res += \" \"; fst = 0; res += ts(x); }\n    return res;\n}\ntemplate<class T, class U> string ts(pair<T,U> p) { return \"(\" + ts(p.FI) + \", \" + ts(p.SE) + \")\"; }\ntemplate<size_t i, class T> string print_tuple_utils(const T& tup) { if constexpr(i == tuple_size<T>::value) return \")\"; else return (i ? \", \" : \"(\") + ts(get<i>(tup)) + print_tuple_utils<i + 1, T>(tup); }\ntemplate<class ...U> string ts(tuple<U...> u) { return print_tuple_utils<0, tuple<U...>>(u); }\n\n// OUTPUT\ntemplate<class T> void pr(T x) { cout << ts(x); }\ntemplate<class T, class ...U> void pr(const T& t, const U&... u) { pr(t); pr(u...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class T, class ...U> void ps(const T& t, const U&... u) { pr(t); if (sizeof...(u)) pr(\" \"); ps(u...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class T, class ...U> void DBG(const T& t, const U&... u) { cerr << ts(t); if (sizeof...(u)) cerr << \", \"; DBG(u...); }\n\n#ifdef LOCAL_DEBUG\n#define CONCAT(x, y) x##y\n#define with_level setw(__db_level * 2) << setfill(' ') << \"\" << setw(0)\n#define dbg(...) cerr << with_level << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#define chk(...) if (!(__VA_ARGS__)) cerr << setw(__db_level * 2) << setfill(' ') << \"\" << setw(0) << \"Line(\" << __LINE__ << \") -> function(\" << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#define db_block() debug_block CONCAT(dbbl, __LINE__)\nint __db_level = 0;\nstruct debug_block {\n    debug_block() { cerr << with_level << \"{\" << endl; ++__db_level; }\n    ~debug_block() { --__db_level; cerr << with_level << \"}\" << endl; }\n};\n#else\n#define dbg(...) 0\n#define chk(...) 0\n#define db_block() 0\n#endif\n\nconst ld PI = acos(-1.0);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\nconst ld EPS = 1e-9;\nconst ll MODBASE = 1000000007LL;\nconst int INF = 0x3f3f3f3f;\n\nconst int MAXN = 101;\nconst int MAXM = 1000;\nconst int MAXK = 16;\nconst int MAXQ = 200010;\n\nll dp[MAXN][MAXN][MAXN];\nll sum[MAXN][MAXN];\n\nclass Solution {\npublic:\n    long long maximumScore(vector<vector<int>>& grid) {\n        int n = SZ(grid);\n        if (n == 1) return 0;\n\n        FOR(i,1,n) FOR(j,1,n) {\n            sum[i][j] = sum[i-1][j] + grid[i-1][j-1];\n        }\n\n        FOR(i,0,n) FOR(j,0,n) FOR(k,0,n) dp[i][j][k] = -1;\n        FOR(i,0,n) dp[1][0][i] = 0;\n\n        FOR(col,1,n-1) {\n            FOR(x,0,n) {\n                FOR(y,0,n) {\n                    // prev = y\n                    // second prev = x\n                    if (dp[col][x][y] == -1) continue;\n                    int threshold = max(x, y);\n                    FOR(k,threshold+1,n) {\n                        dp[col+1][y][k] = max(dp[col+1][y][k], dp[col][x][y] + sum[k][col] - sum[threshold][col]);\n                    }\n                    FOR(k,0,y-1) {\n                        dp[col+1][y][k] = max(dp[col+1][y][k], dp[col][x][y] + sum[y][col+1] - sum[k][col+1]);\n                    }\n                    FOR(k,y,threshold) {\n                        dp[col+1][y][k] = max(dp[col+1][y][k], dp[col][x][y]);\n                    }\n                }\n            }\n        }\n\n        ll res = 0;\n        FOR(i,0,n) FOR(j,0,n) ckmax(res, dp[n][i][j]);\n        return res;\n    }\n};",
    "submit_ts": "1721490353",
    "subm_id": "1327480242"
}