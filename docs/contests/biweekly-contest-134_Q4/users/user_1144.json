{
    "username": "asmitpapney",
    "submission": "class Solution {\npublic:\n    \n    vector<long long> tree ;\n\n\n    void buildSegmentTree(int nodeIndex, int nodeRangeLeft, int nodeRangeRight, vector<int>&A){\n       if(nodeRangeLeft == nodeRangeRight){\n           // leaf node\n           tree[nodeIndex] = A[nodeRangeLeft];\n           return ;\n       }\n\n       int mid = nodeRangeLeft + (nodeRangeRight-nodeRangeLeft)/2;\n\n       buildSegmentTree(2*nodeIndex, nodeRangeLeft, mid, A);\n       buildSegmentTree(2*nodeIndex+1, mid+1, nodeRangeRight, A);\n\n       // backtracking, once children are filled, we will update the current node\n       tree[nodeIndex] = tree[2*nodeIndex] & tree[2*nodeIndex+1];\n    }\n\n\n    long long querySegmentTree(int nodeIndex, int nodeRangeLeft, int nodeRangeRight, int queryRangeLeft, int queryRangeRight){\n       if(queryRangeLeft <= nodeRangeLeft && queryRangeRight >= nodeRangeRight){  // complete overlap\n           return tree[nodeIndex] ;\n       }\n\n       if( (queryRangeLeft > nodeRangeRight) || (queryRangeRight < nodeRangeLeft) ){ // no overlap at all\n           return 18446744073709551615;\n       }\n\n       int mid = nodeRangeLeft + (nodeRangeRight-nodeRangeLeft)/2;\n\n       long long leftNodeAns = querySegmentTree(2*nodeIndex, nodeRangeLeft, mid, queryRangeLeft, queryRangeRight);\n       long long rightNodeAns = querySegmentTree(2*nodeIndex + 1, mid+1, nodeRangeRight, queryRangeLeft, queryRangeRight);\n\n       return leftNodeAns & rightNodeAns;\n    }\n    \n    \n    int binarySearch(int i, int N, int k){\n        int start=i, end = N-1;\n        // find first index, at which AND is <= k\n        while(start < end){\n            if(end-start==1) break;\n            \n            int mid = start + (end-start)/2;\n            \n            long long val = querySegmentTree(1, 0, N-1, i, mid);\n            if(val > k){\n                start = mid;\n            }\n            else end = mid;\n        }\n        \n        // cout<<\" i = \"<<i<<\" start = \"<<start<<\" and end = \"<<end<<endl; \n        long long val = querySegmentTree(1, 0, N-1, i, start);\n        // cout<<\" k  = \"<<k<<\" valStart = \"<<val<<endl; \n        if(val <= k) return N-start;\n        \n        val = querySegmentTree(1, 0, N-1, i, end);\n        // cout<<\" k  = \"<<k<<\" valEnd = \"<<val<<endl; \n        if(val <= k) return N-end;\n        \n        return 0;\n    }\n    \n    long long countSubarrays(vector<int>& nums, int k) {\n        tree.resize(4*nums.size());\n        buildSegmentTree(1, 0, nums.size()-1, nums);\n        \n        long long Ans = 0;\n        \n        for(int i=0; i<nums.size(); i++){\n            // cout<<querySegmentTree(1, 0, nums.size()-1, i, i)<<endl;\n            // cout<<\" <=k :\"<<binarySearch(i, nums.size(), k)<<endl;\n            // cout<<endl<<endl;\n            // cout<<\" <=k+1 :\"<<binarySearch(i, nums.size(), k-1)<<endl;\n            Ans += binarySearch(i, nums.size(), k) - binarySearch(i, nums.size(), k-1) ;\n            // cout<<endl;\n        }\n        \n        return Ans;\n    }\n};",
    "submit_ts": "1720280409",
    "subm_id": "1311788332"
}