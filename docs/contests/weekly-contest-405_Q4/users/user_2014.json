{
    "username": "amank13",
    "submission": "class TrieNode {\n        public:\n            bool is_word;\n            int min_len;\n            int cost;\n            unordered_map<char, TrieNode*> children;\n            TrieNode() {\n                is_word = false;\n                min_len = 1000000;\n                cost = 1000000;\n                children.clear();\n            }\n    };\n    class Trie {\n        public:\n            TrieNode* root;\n            Trie() {\n                root = new TrieNode();\n            }\n            void add_word(string word, int cost) {\n                TrieNode* curr = root;\n                int n = word.size();\n                for(int i=0;i<n;i++) {\n                    auto it = curr->children.find(word[i]);\n                    if(it == curr->children.end()) {\n                        curr->children.emplace(word[i], new TrieNode());\n                    }\n                    curr->min_len = min(curr->min_len, n);\n                    curr = curr->children[word[i]];\n                }\n                curr->is_word = true;\n                curr->cost = min(curr->cost, cost);\n            }\n        \n            TrieNode* advance(TrieNode* curr, char c) {\n                auto it = curr->children.find(c);\n                if(it == curr->children.end())return nullptr;\n                else return it->second;\n            }\n\n    };\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        pq.push(make_pair(0, 0));\n        unordered_set<int> visited;\n        int n = target.length();\n        vector<int> cost_vec(n+1, 1000000000);\n        cost_vec[0]=0;\n        //unordered_map<string, int> cost_map;\n        Trie* trie = new Trie();\n        for(int i=0;i<words.size();i++) {\n            trie->add_word(words[i], costs[i]);\n        }\n        // for(int i=0;i<words.size();i++) {\n        //     auto it = cost_map.find(words[i]);\n        //     if( it != cost_map.end()) {\n        //         it->second = min(it->second, costs[i]);\n        //     } else {\n        //         cost_map.emplace(words[i], costs[i]);\n        //     }\n        // }\n        int ans = -1;\n        while(!pq.empty()) {\n            auto top = pq.top();\n            pq.pop();\n            int idx = top.second;\n            if(visited.contains(idx))continue;\n            visited.insert(idx);\n            if(idx == target.size()) {\n                ans = top.first;\n                break;\n            }\n            //string s = \"\";\n            TrieNode* curr = trie->root;\n            //cout<<idx<<\" \"<<top.first<<endl;\n            for(int i = idx;i<target.length();i++) {\n                //cout<<i<<endl;\n                //s.push_back(target[i]);\n                curr = trie->advance(curr, target[i]);\n                if(curr == nullptr)break;\n                if(curr->is_word) {\n                    if(top.first + curr->cost < cost_vec[i+1]) {\n                        cost_vec[i+1] =  top.first + curr->cost;\n                        pq.push(make_pair(top.first + curr->cost, i+1));\n                    }\n                    // if(auto it = cost_map.find(s); it != cost_map.end()) {\n                    //     pq.push(make_pair(top.first + it->second, i+1));\n                    // }\n                }\n                if(curr->min_len + idx > target.length()) {\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720324769",
    "subm_id": "1312407758"
}