{
    "username": "sergey_chebotarev",
    "submission": "class Solution {\n    // 1.15:\n    public int minFlips(int[][] grid) {\n        int minFlips = 0;\n        minFlips += minNonMidFlips(grid);\n        minFlips += minMidFlips(grid);\n        return minFlips;\n    }\n\n    // Modified \"Q2. Minimum Number of Flips to Make Binary Grid Palindromic I\"\n    private int minNonMidFlips(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n\n        int flips = 0;\n        for (int firstRow = 0, lastRow = n-1; firstRow < lastRow; firstRow++, lastRow--) {\n            for (int firstCol = 0, lastCol = m-1; firstCol < lastCol; firstCol++, lastCol--) {\n                // all 4 values should match for non mid row/col\n                int ones = grid[firstRow][firstCol] + grid[firstRow][lastCol]\n                         + grid[lastRow][firstCol] + grid[lastRow][lastCol];\n                flips += Math.min(ones, 4 - ones);\n                // these flips always produce number of 1s divisible by 4\n                // as all 4 values are either 0 or 1 at once\n            }\n        }\n        return flips;\n    }\n\n    // flips neede to keep the total number of 1s divisible by 4\n    private int minMidFlips(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n\n        int onesInPairs = 0;\n        boolean hasMidRow = n % 2 == 1;\n        boolean hasMidCol = m % 2 == 1;\n        int midRow = n/2;\n        int midCol = m/2;\n\n        int flips = 0;\n        for (int first = 0, last = m-1; hasMidRow && first < last; first++, last--) {\n            if (grid[midRow][first] != grid[midRow][last]) {\n                flips++;\n            } else {\n                onesInPairs += grid[midRow][first] == 1 ? 2 : 0; \n            }\n        }\n        for (int first = 0, last = n-1; hasMidCol && first < last; first++, last--) {\n            if (grid[first][midCol] != grid[last][midCol]) {\n                flips++;\n            } else {\n                onesInPairs += grid[first][midCol] == 1 ? 2 : 0; \n            }\n        }\n\n        // need to patch flips to make a 4-div amount of 1-s\n        if (flips > 1) {\n            // everything is ok, we can simply choose which pairs to change to 0-0 or 1-1\n            // with 2 flips we have at least 4 numbers to control,\n            // all the numbers on mid lines come in pairs\n        } else if (flips > 0) {\n            // actually, it's fine too, there is either 2+ 1s or all 0s,\n            // so a flip is enough to make the ottal number of 1s div-ble by 4\n        } else {\n            int mistamch = onesInPairs % 4;\n            flips += Math.min(mistamch, 4 - mistamch); // actually, it's always 0 or 2\n            // we're removeing the redundant 1s in pairs / or add, doesn't matter\n        }\n\n        if (hasMidRow && hasMidCol && grid[midRow][midCol] == 1) {\n            flips++; // the center should always be 0 as it matches nothing\n        }\n\n        return flips;\n    }\n}",
    "submit_ts": "1722698239",
    "subm_id": "1343174225"
}