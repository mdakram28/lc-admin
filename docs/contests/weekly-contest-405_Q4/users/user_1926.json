{
    "username": "ArunPanwar",
    "submission": "struct TrieNode {\n    std::unordered_map<char, TrieNode*> children;\n    int cost;\n    bool isEndOfWord;\n\n    TrieNode() : cost(INT_MAX), isEndOfWord(false) {}\n};\n\nclass Trie {\npublic:\n    Trie() {\n        root = new TrieNode();\n    }\n\n    // Function to insert a word and its cost\n    void insert(const std::string& word, int cost) {\n        TrieNode* node = root;\n        for (char ch : word) {\n            if (node->children.find(ch) == node->children.end()) {\n                node->children[ch] = new TrieNode();\n            }\n            node = node->children[ch];\n        }\n        node->cost = std::min(node->cost, cost);\n        node->isEndOfWord = true;\n    }\n\n    // Function to get the cost of a prefix starting from a given node\n    TrieNode* getPrefixNode(const std::string& prefix, TrieNode* startNode) {\n        TrieNode* node = startNode;\n        for (char ch : prefix) {\n            if (node->children.find(ch) == node->children.end()) {\n                return nullptr; // Prefix not found\n            }\n            node = node->children[ch];\n        }\n        return node;\n    }\n\n    // Function to get the root node\n    TrieNode* getRoot() {\n        return root;\n    }\n\nprivate:\n    TrieNode* root;\n};\n\nclass Solution {\npublic:\n    Trie dp;\n    std::vector<long long> mem;\n\n    int minimumCost(std::string target, std::vector<std::string>& words, std::vector<int>& costs) {\n        int n = target.length();\n        mem.resize(n + 1, LLONG_MAX);\n        mem[n] = 0; // Base case: cost to transform an empty suffix is 0\n\n        for (int i = 0; i < words.size(); ++i) {\n            if (words[i].length() > target.length()) continue;\n            dp.insert(words[i], costs[i]);\n        }\n\n        for (int i = n - 1; i >= 0; --i) {\n            TrieNode* node = dp.getRoot();\n            for (int j = i; j < n; ++j) {\n                node = dp.getPrefixNode(std::string(1, target[j]), node);\n                if (!node) break;\n                if (node->isEndOfWord) {\n                    if (mem[j + 1] != LLONG_MAX) {\n                        mem[i] = std::min(mem[i], node->cost + mem[j + 1]);\n                    }\n                }\n            }\n        }\n\n        return mem[0] == LLONG_MAX ? -1 : mem[0];\n    }\n};",
    "submit_ts": "1720323662",
    "subm_id": "1312381031"
}