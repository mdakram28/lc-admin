{
    "username": "JustJie",
    "submission": "/********************************************\n * author : Jie Chen (4th Year CS)\n * school : Rochester Institute of Technology\n * created: 08.10.2024 21:54:38\n*********************************************/\n\nusing i64 = long long;\n\n// Credit: Jiangly\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n \ntemplate<>\nint MInt<0>::Mod = 998'244'353;\n \ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n \nconstexpr int P = 1'000'000'007; // 998'244'353;\nusing Z = MInt<P>;\n\n\ntemplate <class Info>\nstruct SegmentTree {\n    int n;\n    vector<Info> info;\n    SegmentTree() : n(0) {}\n    SegmentTree(int n_, Info v_ = Info()) {\n        init(n_, v_);\n    }\n    template<class T>\n    SegmentTree(vector<T> init_) {\n        init(init_);\n    }\n    void init(int n_, Info v_ = Info()) {\n        init(vector(n_, v_));\n    }\n    template<class T>\n    void init(vector<T> init_) {\n        n = init_.size();\n        info.assign(4 << __lg(n), Info());\n        function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init_[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = info[2 * p] + info[2 * p + 1];\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info range_query(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        return range_query(2 * p, l, m, x, y) + range_query(2 * p + 1, m, r, x, y);\n    }\n    Info range_query(int l, int r) {\n        return range_query(1, 0, n, l, r);\n    }\n    template<class F>\n    int find_first(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        int res = find_first(2 * p, l, m, x, y, pred);\n        if (res == -1) {\n            res = find_first(2 * p + 1, m, r, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int find_first(int l, int r, F pred) {\n        return find_first(1, 0, n, l, r, pred);\n    }\n    template<class F>\n    int find_last(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        int res = find_last(2 * p + 1, m, r, x, y, pred);\n        if (res == -1) {\n            res = find_last(2 * p, l, m, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int find_last(int l, int r, F pred) {\n        return find_last(1, 0, n, l, r, pred);\n    }\n};\n \nstruct Info {\n    Z x = 0;\n};\n \nInfo operator+(const Info& a, const Info& b) {\n    return {a.x + b.x};\n}\n\nconstexpr int LIM = 1001;\n\nclass Solution {\npublic:\n    int countOfPairs(vector<int>& a) {\n        int n = a.size();\n\n        vector<SegmentTree<Info>> dp(n);\n        vector<Info> init(a[0] + 1, {Z(1)});\n        dp[0] = SegmentTree<Info>(init);\n        for (int i = 1; i < n; i++) {\n            dp[i] = SegmentTree<Info>(a[i] + 1);\n            for (int x = 0; x <= a[i]; x++) {\n                int y = a[i] - x;\n                // x >= x_(i - 1)\n                // -a[i] + a[i - 1] + x >= x_(i - 1)\n                int d = min(x, x + a[i - 1] - a[i]);\n                d = min(d, a[i - 1]);\n                // x_(i - 1) <= d\n                Info res = dp[i - 1].range_query(0, d + 1);\n                dp[i].modify(x, res);\n            }\n        }\n\n        return dp[n - 1].range_query(0, a[n - 1] + 1).x.val();\n    }\n};\n\n// ~ JustJie",
    "submit_ts": "1723344213",
    "subm_id": "1351529117"
}