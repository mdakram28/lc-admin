{
    "username": "pku_erutan",
    "submission": "import collections\n\nclass SegmentTree:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build(0, 0, self.n - 1, nums)\n\n    def build(self, node, start, end, nums):\n        if start == end:\n            self.tree[node] = nums[start]\n        else:\n            mid = (start + end) // 2\n            left_child = 2 * node + 1\n            right_child = 2 * node + 2\n            self.build(left_child, start, mid, nums)\n            self.build(right_child, mid + 1, end, nums)\n            self.tree[node] = self.tree[left_child] + self.tree[right_child]\n\n    def update_range(self, node, start, end, l, r, val):\n        if self.lazy[node] != 0:\n            self.tree[node] += (end - start + 1) * self.lazy[node]\n            if start != end:\n                left_child = 2 * node + 1\n                right_child = 2 * node + 2\n                self.lazy[left_child] += self.lazy[node]\n                self.lazy[right_child] += self.lazy[node]\n            self.lazy[node] = 0\n        \n        if start > end or start > r or end < l:\n            return\n        \n        if start >= l and end <= r:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                left_child = 2 * node + 1\n                right_child = 2 * node + 2\n                self.lazy[left_child] += val\n                self.lazy[right_child] += val\n            return\n        \n        mid = (start + end) // 2\n        left_child = 2 * node + 1\n        right_child = 2 * node + 2\n        self.update_range(left_child, start, mid, l, r, val)\n        self.update_range(right_child, mid + 1, end, l, r, val)\n        self.tree[node] = self.tree[left_child] + self.tree[right_child]\n\n    def query_range(self, node, start, end, l, r):\n        if self.lazy[node] != 0:\n            self.tree[node] += (end - start + 1) * self.lazy[node]\n            if start != end:\n                left_child = 2 * node + 1\n                right_child = 2 * node + 2\n                self.lazy[left_child] += self.lazy[node]\n                self.lazy[right_child] += self.lazy[node]\n            self.lazy[node] = 0\n        \n        if start > end or start > r or end < l:\n            return 0\n        \n        if start >= l and end <= r:\n            return self.tree[node]\n        \n        mid = (start + end) // 2\n        left_child = 2 * node + 1\n        right_child = 2 * node + 2\n        left_sum = self.query_range(left_child, start, mid, l, r)\n        right_sum = self.query_range(right_child, mid + 1, end, l, r)\n        return left_sum + right_sum\n\n    def add(self, p1, p2):\n        self.update_range(0, 0, self.n - 1, p1, p2, 1)\n\n    def range_sum(self, p1, p2):\n        return self.query_range(0, 0, self.n - 1, p1, p2)\n\n    def to_array(self):\n        # \u8f85\u52a9\u51fd\u6570\uff0c\u7528\u6765\u9012\u5f52\u5904\u7406\u6bcf\u4e2a\u8282\u70b9\n        def retrieve_values(node, start, end, arr):\n            if start == end:\n                # \u53f6\u8282\u70b9\uff0c\u5bf9\u5e94\u5177\u4f53\u7684\u6570\u7ec4\u5143\u7d20\n                arr[start] = self.query_range(0, 0, self.n - 1, start, start)\n            else:\n                mid = (start + end) // 2\n                left_child = 2 * node + 1\n                right_child = 2 * node + 2\n                # \u9012\u5f52\u5904\u7406\u5de6\u53f3\u5b50\u6811\n                retrieve_values(left_child, start, mid, arr)\n                retrieve_values(right_child, mid + 1, end, arr)\n        \n        # \u521b\u5efa\u4e00\u4e2a\u7a7a\u6570\u7ec4\uff0c\u5927\u5c0f\u4e0e\u521d\u59cb\u6570\u7ec4\u76f8\u540c\n        arr = [0] * self.n\n        # \u4ece\u6839\u8282\u70b9\u5f00\u59cb\u904d\u5386\u6811\uff0c\u83b7\u53d6\u6bcf\u4e2a\u4f4d\u7f6e\u7684\u503c\n        retrieve_values(0, 0, self.n - 1, arr)\n        return arr\n\n\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries):\n        n = len(s)\n        s = [int(c) for c in s]\n        \n        iqs = [[l, r, i] for i, (l, r) in enumerate(queries)]\n        iqs = sorted(iqs, key=lambda x : (x[1], x[0]))\n        to_ret = [-1] *len(queries)\n        sgt = SegmentTree([0]*n)\n        \n        piqs = 0\n        cts = 0\n        ct = [0, 0]\n        for i, vt in enumerate(s) :\n            ct[vt] += 1\n            # while ct[vt] > k :\n            #     ct[s[cts]] -= 1\n            #     cts += 1\n            while ct[0] > k and ct[1] > k:\n                ct[s[cts]] -= 1\n                cts += 1\n            \n            sgt.add(cts, i) # \u95ed\u533a\u95f4\n            # print(sgt.to_array())\n            \n            while piqs < len(iqs) and iqs[piqs][1] == i :\n                # print(iqs[piqs][0], i)\n                to_ret[iqs[piqs][2]] = sgt.range_sum(iqs[piqs][0], i) # \u95ed\u533a\u95f4\n                piqs += 1\n                \n        return to_ret",
    "submit_ts": "1723951504",
    "subm_id": "556405848"
}