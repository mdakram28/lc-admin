{
    "username": "tang-donghai",
    "submission": "class Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> peaks(n, 0);\n\n        // Helper function to determine if an element is a peak\n        auto isPeak = [&](int i) -> bool {\n            if (i <= 0 || i >= n - 1) return false;\n            return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n        };\n\n        // Initialize the peaks array\n        for (int i = 1; i < n - 1; ++i) {\n            if (isPeak(i)) peaks[i] = 1;\n        }\n\n        // Segment tree to store the count of peaks in each segment\n        vector<int> segTree(4 * n, 0);\n\n        // Build the segment tree\n        function<void(int, int, int)> build = [&](int node, int start, int end) {\n            if (start == end) {\n                segTree[node] = peaks[start];\n            } else {\n                int mid = (start + end) / 2;\n                int leftChild = 2 * node + 1;\n                int rightChild = 2 * node + 2;\n                build(leftChild, start, mid);\n                build(rightChild, mid + 1, end);\n                segTree[node] = segTree[leftChild] + segTree[rightChild];\n            }\n        };\n\n        // Update the segment tree\n        function<void(int, int, int, int, int)> update = [&](int node, int start, int end, int idx, int value) {\n            if (start == end) {\n                segTree[node] = value;\n            } else {\n                int mid = (start + end) / 2;\n                int leftChild = 2 * node + 1;\n                int rightChild = 2 * node + 2;\n                if (idx <= mid) {\n                    update(leftChild, start, mid, idx, value);\n                } else {\n                    update(rightChild, mid + 1, end, idx, value);\n                }\n                segTree[node] = segTree[leftChild] + segTree[rightChild];\n            }\n        };\n\n        // Query the segment tree\n        function<int(int, int, int, int, int)> query = [&](int node, int start, int end, int l, int r) -> int {\n            if (r < start || l > end) return 0;\n            if (l <= start && r >= end) return segTree[node];\n            int mid = (start + end) / 2;\n            int leftChild = 2 * node + 1;\n            int rightChild = 2 * node + 2;\n            int leftResult = query(leftChild, start, mid, l, r);\n            int rightResult = query(rightChild, mid + 1, end, l, r);\n            return leftResult + rightResult;\n        };\n\n        build(0, 0, n - 1);\n\n        vector<int> answer;\n\n        for (const auto& queryInfo : queries) {\n            if (queryInfo[0] == 1) {\n                int l = queryInfo[1];\n                int r = queryInfo[2];\n                int peakCount = query(0, 0, n - 1, l, r);\n\n                // Check boundary conditions\n                if (l > 0 && isPeak(l)) peakCount--;\n                if (r < n - 1 && isPeak(r)) peakCount--;\n\n                answer.push_back(max(0,peakCount));\n            } else if (queryInfo[0] == 2) {\n                int index = queryInfo[1];\n                int value = queryInfo[2];\n                nums[index] = value;\n\n                // Update peaks around the changed index\n                for (int i = max(1, index - 1); i <= min(n - 2, index + 1); ++i) {\n                    int isPeakBefore = peaks[i];\n                    peaks[i] = isPeak(i);\n                    if (peaks[i] != isPeakBefore) {\n                        update(0, 0, n - 1, i, peaks[i]);\n                    }\n                }\n            }\n        }\n\n        return answer;\n    }\n};\n",
    "submit_ts": 1718508471.0
}