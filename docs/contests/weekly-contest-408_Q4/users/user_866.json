{
    "username": "Spartan333",
    "submission": "class Solution {\n\npublic:\n    int dfs(vector<vector<int>> &graph, int S, int curr, int prev, int n) {\n        \n        queue<int> pq;\n\n        int size = n+4;\n        vector<int> vis(size, 0);\n        pq.push(S);\n        vis[S] = 1;\n\n        while (!pq.empty()) {\n            int u = pq.front();\n            pq.pop();\n            for (int node : graph[u]) {\n                if (!vis[node]) {\n                    pq.push(node);\n                    vis[node] = 1;\n                }\n            }\n        }\n        return vis[curr] || vis[prev];\n    }\n\n  bool canReachCorner(int X, int Y, vector<vector<int>>& c2) {\n      \n             vector<pair<pair<int, int>, int>> circles(c2.size());\n            int size = c2.size()+4;\n             vector<vector<int>> graph(size);\n            int n=c2.size();\n\n            for (int i = 0; i < n; ++i) {\n                circles[i].first.first=c2[i][0];\n                circles[i].first.second=c2[i][1];\n                circles[i].second=c2[i][2];\n            }\n\n\n\n             for (int i = 0; i < n; ++i) {\n\n                if (circles[i].first.first <= circles[i].second) {\n                    graph[n].push_back(i);\n                    graph[i].push_back(n);\n                }\n                if (X - circles[i].first.first <= circles[i].second) {\n                    graph[n + 2].push_back(i);\n                    graph[i].push_back(n + 2);\n                }\n                if (circles[i].first.second <= circles[i].second) {\n                    graph[n + 1].push_back(i);\n                    graph[i].push_back(n + 1);\n                }\n                if (Y - circles[i].first.second <= circles[i].second) {\n                    graph[n + 3].push_back(i);\n                    graph[i].push_back(n + 3);\n                }\n                for (int j = i + 1; j < n; ++j) {\n                    double dis = sqrt(pow(circles[i].first.first - circles[j].first.first, 2) +\n                                           pow(circles[i].first.second - circles[j].first.second, 2));\n                    int sum = circles[i].second + circles[j].second;\n                    if (sum >= dis) {\n                        graph[i].push_back(j);\n                        graph[j].push_back(i);\n                    }\n                }\n            }\n\n            int ans = 0;\n    ans = max(ans, dfs(graph, n, n+ 1, n+ 2, n+ 4)); \n        ans = max(ans, dfs(graph, n+ 3, n+ 2, n + 1, n + 4)); \n            if (ans)\n                return false;\n      \n            return true;\n       \n        \n       \n    }\n};",
    "submit_ts": "1722138926",
    "subm_id": "1335803296"
}