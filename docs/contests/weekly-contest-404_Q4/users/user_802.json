{
    "username": "satyam21092",
    "submission": "class Solution {\npublic:\n    int dfs(int node, vector<vector<int>>& adj, vector<bool>& visited) {\n        visited[node] = true;\n        int maxDepth1 = 0, maxDepth2 = 0;\n        for (int neighbor : adj[node]) {\n            if (!visited[neighbor]) {\n                int depth = dfs(neighbor, adj, visited);\n                if (depth > maxDepth1) {\n                    maxDepth2 = maxDepth1;\n                    maxDepth1 = depth;\n                } else if (depth > maxDepth2) {\n                    maxDepth2 = depth;\n                }\n            }\n        }\n        diameter = max(diameter, maxDepth1 + maxDepth2);\n        return maxDepth1 + 1; \n    }\n\n    int treeDiameter(vector<vector<int>>& edges, int n) {\n        vector<vector<int>> adj(n);\n        for (auto& edge : edges) {\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n        vector<bool> visited(n, false);\n        diameter = 0;\n        dfs(0, adj, visited); \n        return diameter;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int diameter1 = treeDiameter(edges1, edges1.size() + 1);\n        int diameter2 = treeDiameter(edges2, edges2.size() + 1);\n        \n        // Calculate the maximum possible diameter after merging\n        int maxDiameter = max(diameter1, diameter2);\n        \n        // The minimum diameter is achieved by connecting a longest path's endpoint\n        // from one tree to an endpoint of a longest path in the other tree.\n        int minDiameter = (diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1;\n        \n        return max(maxDiameter, minDiameter);\n    }\n\nprivate:\n    int diameter; \n};",
    "submit_ts": 1719716743.0
}