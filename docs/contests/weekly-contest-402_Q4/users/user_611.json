{
    "username": "ajingo",
    "submission": "template <typename R, typename T>\nconcept Foldable = requires(R op, const T& l, const T& r) { { op.fold(l, r) } -> same_as<T>; };\ntemplate <typename R>\nconcept T = requires(R op) {\n  typename R::T;\n  requires Foldable<R, typename R::T>;\n  { op.e() } -> same_as<typename R::T>;\n};\n\ntemplate<T R>\nstruct SegmentTree {\n  R op = R{};\n  using T = typename R::T;\n  vector<T> data;\n  int n = 1;\n  int bit = 0;\n  int size = 0;\n\n  void init(int sz) {\n    size = sz;\n    while (n < sz) {\n      n <<= 1;\n      bit++;\n    }\n    data.assign(n << 1, op.e());\n  }\n\n  SegmentTree(int n) { init(n); }\n\n  SegmentTree(const vector<T>& a) {\n    int sz = a.size();\n    init(sz);\n    for (int i = 0; i < sz; i++) data[i + n] = a[i];\n    for (int i = n - 1; i > 0; i--) data[i] = op.fold(data[i << 1 | 0], data[i << 1 | 1]);\n  }\n\n  void update(int x, const T& v) {\n    data[x += n] = v;\n    for (x >>= 1; x > 0; x >>= 1) {\n      data[x] = op.fold(data[x << 1 | 0], data[x << 1 | 1]);\n    }\n  }\n\n  T find(int l, int r) {\n    if (l == r) return op.e();\n    T x = op.e(), y = op.e();\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) x = op.fold(x, data[l++]);\n      if (r & 1) y = op.fold(data[--r], y);\n    }\n    return op.fold(x, y);\n  }\n\n  int minLeft(int r, const function<bool(const T&)>& f) {\n    assert(r <= size);\n    assert(f(op.e()));\n    if (r == 0) {\n      return 0;\n    }\n    r += n;\n    auto s = op.e();\n    while(true) {\n      r -= 1;\n      while (r > 1 && r % 2 == 1) {\n        r >>= 1;\n      }\n      auto v = op.fold(data[r], s);\n      if (!f(v)) {\n        while (r < n) {\n          r = r << 1 | 1;\n          v = op.fold(data[r], s);\n          if (f(v)) {\n            s = v;\n            r -= 1;\n          }\n        }\n        return r + 1 - n;\n      }\n      s = v;\n      if ((r & -r) == r) {\n        break;\n      }\n    }\n    return 0;\n  }\n  \n  int maxRight(int l, const function<bool(const T&)>& f) {\n    assert(l <= size);\n    assert(f(op.e()));\n    if (l == size) {\n      return size;\n    }\n    l += n;\n    auto s = op.e();\n    while(true) {\n      while (l % 2 == 0) {\n        l >>= 1;\n      }\n      auto v = op.fold(s, data[l]);\n      if (!f(v)) {\n        while (l < n) {\n          l <<= 1;\n          v = op.fold(s, data[l]);\n          if (f(v)) {\n            s = v;\n            l += 1;\n          }\n        }\n        return l - n;\n      }\n      s = v;\n      l += 1;\n      if ((l & -l) == l) {\n        break;\n      }\n    }\n    return size;\n  }\n};\n\nstruct R {\n  using T = int;\n  T fold(const T& l, const T& r) {\n    return l + r;\n  }\n  T e() { return 0; }\n};\n\nclass Solution {\npublic:\n  vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n    int n = nums.size();\n    SegmentTree<R> seg(n);\n    for (int i = 1; i + 1 < n; i++) {\n      if (nums[i] > nums[i + 1] && nums[i] > nums[i - 1]) {\n        seg.update(i, 1);\n        // cout << i << endl;\n      }\n    }\n    vector<int> ans;\n    for (auto& q : queries) {\n      int op = q[0];\n      if (op == 1) {\n        int l = q[1], r = q[2];\n        int got = seg.find(l + 1, r);\n        ans.push_back(got);\n      } else {\n        int index = q[1], val = q[2];\n        nums[index] = val;\n        for (auto at : {index, index + 1, index - 1}) {\n          if (at < 0 || at >= n) {\n            continue;\n          }\n          if (at - 1 >= 0 && at + 1 < n) {\n            int got = (nums[at] > nums[at + 1]) && (nums[at] > nums[at - 1]);\n            // for (auto x : nums) cout << x << \" \"; cout << endl;\n            // cout << at << \" \" << nums[at - 1] << \" \" << nums[at] << \" \" << nums[at + 1] << endl;\n            // cout << at << \" \" << got << endl;\n            seg.update(at, got);\n          }\n        }\n      }\n    }\n    return ans;\n  }\n};",
    "submit_ts": "1718506690",
    "subm_id": "539776623"
}