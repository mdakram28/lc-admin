{
    "username": "MKLOL",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double, double> pdd;\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define FOR(i, to) for (int i = 0; i < (to); ++i)\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<pair<int, int> > vpi;\ntypedef pair<ll,ll> pll;\ntypedef vector<string> vs;\nconst char en = '\\n';\nclass UnionFind {\npublic:\n  vector<int> par;\n  vector<int> h;\n  int size;\n\n  // Constructor\n  UnionFind(int size) : size(size) {\n    par.resize(size);\n    h.resize(size, 1);\n    for (int i = 0; i < size; ++i) {\n      par[i] = i;\n    }\n  }\n\n  // Find operation with path compression\n  int find(int x) {\n    int R = x, y;\n    while (par[R] != R) {\n      R = par[R];\n    }\n    while (par[x] != x) {\n      y = par[x];\n      par[x] = R;\n      x = y;\n    }\n    return R;\n  }\n\n  // Union operation by rank\n  int unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return 0;\n\n    if (h[x] > h[y]) {\n      par[y] = x;\n      h[x] += h[y];\n    } else {\n      par[x] = y;\n      h[y] += h[x];\n    }\n    return 1;\n  }\n\n  // Clear operation - reset to initial values\n  void clear() {\n    for (int i = 0; i < size; ++i) {\n      par[i] = i;\n      h[i] = 1;\n    }\n  }\n};\n\nbool inter(const std::vector<int>& circle1, const std::vector<int>& circle2) {\n    ll x1 = circle1[0], y1 = circle1[1], r1 = circle1[2];\n    ll x2 = circle2[0], y2 = circle2[1], r2 = circle2[2];\n    \n    ll dx = x2 - x1;\n    ll dy = y2 - y1;\n    ll distanceSquared = dx * dx + dy * dy;\n    \n    ll radiiSum = r1 + r2;\n    ll radiiSumSquared = radiiSum * radiiSum;\n    \n    return distanceSquared <= radiiSumSquared;\n}\n\nbool circleLine(const std::vector<int>& circle, const std::vector<int>& line) {\n    ll cx = circle[0], cy = circle[1], r = circle[2];\n    ll x1 = line[0], y1 = line[1], x2 = line[2], y2 = line[3];\n\n    ll dx = x2 - x1;\n    ll dy = y2 - y1;\n\n    ll A = dx * dx + dy * dy;\n    ll B = 2 * (dx * (x1 - cx) + dy * (y1 - cy));\n    ll C = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;\n\n    __int128 Bx = B;\n    __int128 Ax = A;\n    __int128 Cx = C;\n    return Bx*Bx >= 4 * Ax * Cx;\n}\n\nbool circlePoint(const std::vector<int>& circle, const std::vector<int>& point) {\n    ll cx = circle[0], cy = circle[1], r = circle[2];\n    ll px = point[0], py = point[1];\n\n    ll dx = px - cx;\n    ll dy = py - cy;\n    ll distanceSquared = dx * dx + dy * dy;\n\n    return distanceSquared <= r * r;\n}\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& vc) {\n        UnionFind uf(sz(vc) + 4);\n        int UP = sz(vc);\n        int DOWN = sz(vc)+1;\n        int LEFT = sz(vc)+2;\n        int RIGHT = sz(vc)+3;\n        //cout << \"WTF\" << endl;\n        FOR(i, sz(vc)) {\n            for (int j=i+1;j<sz(vc);++j) {\n                if (inter(vc[i], vc[j])) {\n                    uf.unite(i,j);\n                }\n            }\n        }\n        vi downv = {0,0,X,0};\n        vi upv = {0,Y,X,Y};\n        vi leftv = {0,0,0,Y};\n        vi rightv = {X,0,X,Y};\n        int ok = 1;\n        vi ev = {X,Y};\n        FOR(i, sz(vc)) {\n            if (circlePoint(vc[i], ev)) ok = 0;\n            if (circleLine(vc[i], downv)) {\n                uf.unite(DOWN, i);\n            }\n            if (circleLine(vc[i], upv)) {\n                uf.unite(UP, i);\n            }\n            if (circleLine(vc[i], rightv)) {\n                uf.unite(RIGHT, i);\n            }\n            if (circleLine(vc[i], leftv)) {\n                uf.unite(LEFT, i);\n            }\n        }\n        ok &= uf.find(UP) != uf.find(RIGHT);\n        ok &= uf.find(UP) != uf.find(DOWN);\n        ok &= uf.find(DOWN) != uf.find(LEFT);\n        ok &= uf.find(LEFT) != uf.find(RIGHT);\n        return ok;\n    }\n};",
    "submit_ts": "1722134864",
    "subm_id": "1335681130"
}