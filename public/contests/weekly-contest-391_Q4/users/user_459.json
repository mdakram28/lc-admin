{
    "username": "Sundae2608",
    "submission": "def max_distance_brute(points: List[List[int]]) -> int:\n    n = len(points)\n    max_dist = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            _, x1, y1 = points[i]\n            _, x2, y2 = points[j]\n            max_dist = max(max_dist, abs(x2 - x1) + abs(y2 - y1))\n    return max_dist\n\nclass Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        # Find the center\n        avg_x = sum([p[0] for p in points]) / len(points)\n        avg_y = sum([p[1] for p in points]) / len(points)\n        \n        # Quadrant maxima\n        h1 = []\n        h2 = []\n        h3 = []\n        h4 = []\n        \n        #\n        for x, y in points:\n            dist = abs(avg_x - x) + abs(avg_y - y)\n            if x >= avg_x and y >= avg_y:\n                heapq.heappush(h1, (dist, x, y))\n                if len(h1) > 2:\n                    heapq.heappop(h1)\n            elif x >= avg_x and y < avg_y:\n                heapq.heappush(h2, (dist, x, y))\n                if len(h2) > 2:\n                    heapq.heappop(h2)\n            elif x < avg_x and y >= avg_y:\n                heapq.heappush(h3, (dist, x, y))\n                if len(h3) > 2:\n                    heapq.heappop(h3)\n            else:\n                heapq.heappush(h4, (dist, x, y))\n                if len(h4) > 2:\n                    heapq.heappop(h4)\n                    \n        # Get the candidates\n        pts = h1 + h2 + h3 + h4\n        \n        # Find the points to drop\n        n = len(pts)\n        ret = None\n        for i in range(n):\n            new_pts = pts[:i] + pts[i + 1:]\n            max_dist = max_distance_brute(new_pts)\n            if ret is None:\n                ret = max_dist\n            else:\n                ret = min(ret, max_dist)\n        return ret\n            \n        \n                "
}