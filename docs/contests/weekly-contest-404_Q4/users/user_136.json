{
    "username": "dirigibility",
    "submission": "def f(edges):\n    n = len(edges)+1\n    adj = defaultdict(list)\n    for a,b in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    hts = [None]*n\n    def get_hts(node,parent):\n        a = b = 0\n        ac = None\n        for child in adj[node]:\n            if child != parent:\n                get_hts(child,node)\n                if (x := 1+hts[child][0]) > a:\n                    b = a\n                    a = x\n                    ac = child\n                elif x > b:\n                    b = x\n        hts[node] = (a,b,ac)\n    get_hts(0,-1)\n    result = [None]*n\n    def solve(node,parent,above):\n        if hts[node][0] > above:\n            a,b,ac = hts[node]\n            b = max(above,b)\n        else:\n            a = above\n            ac = None\n        result[node] = max(hts[node][0],above)\n        for child in adj[node]:\n            if child != parent:\n                solve(child,node,(a if child != ac else b)+1)\n    solve(0,-1,0)\n    return result\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        f1 = f(edges1)\n        d1 = max(f1)\n        h1 = min(f1)\n        f2 = f(edges2)\n        d2 = max(f2)\n        h2 = min(f2)\n        return max(d1,d2,h1+h2+1)",
    "submit_ts": 1719717655.0
}