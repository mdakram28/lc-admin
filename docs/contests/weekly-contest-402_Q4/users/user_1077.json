{
    "username": "auracodehandle",
    "submission": "class Solution {\npublic:\n    void build(int i, int l, int r, vector <int> &val, vector <int> &segment_tree){\n        if(l == r){\n            segment_tree[i] = val[l];\n            return ;\n        }\n        \n        int mid = (l + r) / 2;\n        build(i * 2, l, mid, val, segment_tree);\n        build(i * 2 + 1, mid + 1, r, val, segment_tree);\n        \n        segment_tree[i] = segment_tree[i * 2] + segment_tree[i * 2 + 1];\n    }\n    \n    void update(int i, int l, int r, int pos, int value, vector <int> &segment_tree){\n        if(pos < l or pos > r){\n            return ;\n        }\n        \n        if(l == r){\n            segment_tree[i] = value;\n            return ;\n        }\n        \n        int mid = (l + r) / 2;\n        update(i * 2, l, mid, pos, value, segment_tree);\n        update(i * 2 + 1, mid + 1, r, pos, value, segment_tree);\n        \n        segment_tree[i] = segment_tree[i * 2] + segment_tree[i * 2 + 1];\n    }\n    \n    int query(int i, int l, int r, int left, int right, vector <int> &segment_tree){\n        if(r < left or l > right){\n            return 0;\n        }\n        \n        if(l >= left and r <= right){\n            return segment_tree[i];\n        }\n        \n        int mid = (l + r) / 2;\n        int left_val = query(i * 2, l, mid, left, right, segment_tree);\n        int right_val = query(i * 2 + 1, mid + 1, r, left, right, segment_tree);\n        \n        return left_val + right_val;\n    }\n    \n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector <int> vec(n, 0);\n        for(int i = 1; i < n-1; i ++){\n            if(nums[i] > nums[i-1] and nums[i] > nums[i+1]) vec[i] = 1;\n        }\n\n        \n        vector <int> segment_tree(4*n + 10, 0);\n        build(1, 0, n-1, vec, segment_tree);\n        \n        vector <int> ans;\n        \n        for(auto a: queries){\n            if(a[0] == 1){\n                int check = query(1, 0, n-1, a[1] + 1, a[2] - 1, segment_tree);\n                ans.push_back(check);\n            }\n            else{\n                nums[a[1]] = a[2];\n                \n                if (a[1] > 0 && a[1] < n - 1) {\n                    if (nums[a[1]] > nums[a[1] - 1] && nums[a[1]] > nums[a[1] + 1]) {\n                        vec[a[1]] = 1;\n                        update(1, 0, n - 1, a[1], 1, segment_tree);\n                    } else {\n                        vec[a[1]] = 0;\n                        update(1, 0, n - 1, a[1], 0, segment_tree);\n                    }\n                }\n\n                // Update the peak status for the previous and next indices\n                if (a[1] > 1) {\n                    if (nums[a[1] - 1] > nums[a[1] - 2] && nums[a[1] - 1] > nums[a[1]]) {\n                        vec[a[1] - 1] = 1;\n                        update(1, 0, n - 1, a[1] - 1, 1, segment_tree);\n                    } else {\n                        vec[a[1] - 1] = 0;\n                        update(1, 0, n - 1, a[1] - 1, 0, segment_tree);\n                    }\n                }\n\n                if (a[1] < n - 2) {\n                    if (nums[a[1] + 1] > nums[a[1]] && nums[a[1] + 1] > nums[a[1] + 2]) {\n                        vec[a[1] + 1] = 1;\n                        update(1, 0, n - 1, a[1] + 1, 1, segment_tree);\n                    } else {\n                        vec[a[1] + 1] = 0;\n                        update(1, 0, n - 1, a[1] + 1, 0, segment_tree);\n                    }\n                }\n            }\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": 1718508574.0
}