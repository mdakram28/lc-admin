{
    "username": "inversionpeter",
    "submission": "static const auto Initialize = [] {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    return nullptr;\n}();\n\nint maximums[5001];\nint segmentTrees[20000][5001];\n\nvoid BuildSegmentTree(int left, int right, int index, int k) {\n    for (int i = 0; i <= k; ++i) {\n        segmentTrees[index][i] = 0;\n    }\n    if (left == right) {        \n        return;\n    }\n    int middle = (left + right) >> 1;\n    BuildSegmentTree(left, middle, index << 1, k);\n    BuildSegmentTree(middle + 1, right, (index << 1) + 1, k);\n}\n\nvoid Update(int intervalLeft, int intervalRight, int left, int right, int index, int k) {\n    if (intervalLeft <= left && right <= intervalRight) {\n        for (int i = 0; i <= k; ++i) {\n            segmentTrees[index][i] = maximums[i];\n        }\n        return;\n    }\n    int middle = (left + right) >> 1;\n    if (intervalLeft <= middle) {\n        Update(intervalLeft, intervalRight, left, middle, index << 1, k);\n    }\n    if (middle < intervalRight) {\n        Update(intervalLeft, intervalRight, middle + 1, right, (index << 1) + 1, k);\n    }\n    for (int i = 0; i <= k; ++i) {\n        segmentTrees[index][i] = max(segmentTrees[index << 1][i], segmentTrees[(index << 1) + 1][i]);\n    }\n}\n\nvoid Query(int intervalLeft, int intervalRight, int left, int right, int index, int k, bool mode) {\n    if (intervalLeft <= left && right <= intervalRight) {\n        if (mode) {\n            if (segmentTrees[index][0]) {\n                for (int i = 0; i < k; ++i) {\n                    maximums[i + 1] = max(maximums[i + 1], segmentTrees[index][i] + 1);\n                }\n            }\n        }\n        else {\n            if (segmentTrees[index][0]) {\n                for (int i = 0; i <= k; ++i) {\n                    maximums[i] = segmentTrees[index][i] + 1;\n                }\n            }\n        }\n        return;\n    }\n    int middle = (left + right) >> 1;\n    if (intervalLeft <= middle) {\n        Query(intervalLeft, intervalRight, left, middle, index << 1, k, mode);\n    }\n    if (middle < intervalRight) {\n        Query(intervalLeft, intervalRight, middle + 1, right, (index << 1) + 1, k, mode);\n    }\n}\n\nclass Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {\n        int maximum = 1;\n        vector <int> sorted = nums;\n        sort(sorted.begin(), sorted.end());\n        sorted.resize(unique(sorted.begin(), sorted.end()) - sorted.begin());\n        unordered_map <int, int> indices;\n        for (int i = 0; i != sorted.size(); ++i) {\n            indices[sorted[i]] = i;\n        }\n        BuildSegmentTree(0, sorted.size() - 1, 1, k);\n        for (int i : nums) {\n            fill(maximums, maximums + k + 1, 0);\n            maximums[0] = 1;\n            Query(indices[i], indices[i], 0, sorted.size() - 1, 1, k, false);\n            if (indices[i]) {\n                Query(0, indices[i] - 1, 0, sorted.size() - 1, 1, k, true);\n            }\n            if (indices[i] != sorted.size() - 1) {\n                Query(indices[i] + 1, sorted.size() - 1, 0, sorted.size() - 1, 1, k, true);\n            }\n            for (int j = 0; j <= k; ++j) {\n                maximum = max(maximum, maximums[j]);\n                //cout << maximums[j] << ' ';\n            }\n            //cout << '\\n';\n            Update(indices[i], indices[i], 0, sorted.size() - 1, 1, k);\n        }\n        return maximum;\n    }\n};",
    "submit_ts": "1717861492",
    "subm_id": "1281792842"
}