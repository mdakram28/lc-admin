{
    "username": "a0920732333",
    "submission": "class Solution \n{\npublic:\n    int minChanges(vector<int>& nums, int k) \n    {\n        int n = nums.size();\n        unordered_map<int, int> um;\n        // auto cmp = [](const pair<int, int>& p1, const pair<int, int>& p2)\n        // {\n        //     return abs(p1.first - p1.second) > abs(p2.first - p2.second);\n        // };\n        // priority_queue<pair<int,int>, vector<pair<int,int>>, decltype(cmp)> pq1(cmp);\n        priority_queue<int> pq1;\n        for(int i = 0; i < n / 2; i++)\n        {\n            um[abs(nums[i] - nums[n - 1 - i])]++;\n            int lmax = max(nums[i], k - nums[i]);\n            int rmax = max(nums[n - i - 1], k - nums[n - i - 1]);\n            pq1.push(max(lmax, rmax));\n        }\n        priority_queue<pair<int,int>> pq2;\n        for(auto& it : um)\n        {\n            pq2.push({it.second, it.first});\n        }\n        int ans = n / 2;\n        while(!pq2.empty())\n        {\n            auto [cnt, diff] = pq2.top();\n            pq2.pop();\n            while(!pq1.empty() && pq1.top() >= diff)\n            {\n                pq1.pop();\n            }\n            ans = min(ans, (int)(n / 2 - cnt + pq1.size()));\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1721487805",
    "subm_id": "1327401728"
}