{
    "username": "sheepforever",
    "submission": "struct FenwickTree {\n\tvector<int> a;\n \n\tFenwickTree(int n) : a(n + 10, 0) {}\n \n\tvoid add(int x, int y) {\n\t\t++x;\n\t\twhile (x < a.size()) {\n\t\t\ta[x] += y;\n\t\t\tx += x & -x;\n\t\t}\n\t}\n \n\tint get(int x) {\n\t\t++x;\n\t\tint ret = 0;\n\t\twhile (x) {\n\t\t\tret += a[x];\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn ret;\n\t}\n \n\tint getSum(int l, int r) {\n\t\tassert(l <= r);\n\t\treturn get(r) - get(l - 1);\n\t}\n};\n \n \ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>* a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : *a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const multiset<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n\nclass Solution {\npublic:\n    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {\n        set<pair<int, int>> s;\n        int n = colors.size();\n        \n        auto get = [&](int at) {\n          return colors[at] ^ (at & 1);  \n        };\n        FenwickTree treeSum(n + 1), treeCount(n + 1);\n        \n        auto insertSeg = [&](int i, int j) {\n            s.insert(make_pair(i, j));\n            treeSum.add(j - i + 1, j - i + 1);\n            treeCount.add(j - i + 1, 1);\n        };\n        \n        auto deleteSeg = [&](int i, int j) {\n            auto it = s.find(make_pair(i, j));\n            assert(it != s.end());\n            s.erase(it);\n            treeSum.add(j - i + 1, -(j - i + 1));\n            treeCount.add(j - i + 1, -1);\n        };\n        \n        auto getSeg = [&](int at) {\n            auto it = s.lower_bound(make_pair(at + 1, 0));\n            assert(it != s.begin());\n            --it;\n            return *it;\n        };\n        \n        // vector<vector<int>> nq;\n        // for (int i = 0; i < n; ++i) {\n        //     if (colors[i] != 0) {\n        //         nq.push_back({2, i, 1});\n        //         colors[i] = 0;\n        //     }\n        // }\n        // for (auto& q : queries) {\n        //     nq.push_back(q);\n        // }\n        // queries = nq;\n        for (int i = 0; i < n; ) {\n            int j = i;\n            while (j < n && (get(i) == get(j))) ++j;\n            insertSeg(i, j - 1);\n            i = j;\n        }\n\n        vector<int> ans;\n        vector<int> newSegs;\n        for (auto& q : queries) {\n            if (q[0] == 1) {\n                int len = q[1];\n                int totalSum = treeSum.getSum(len, n);\n                int totalCount = treeCount.getSum(len, n);\n                \n                int cur = totalSum - totalCount * (len - 1);\n                if (s.size() > 1) {\n                    if (colors[0] != colors[n - 1]) {\n                        int len1 = s.begin()->second - s.begin()->first + 1;\n                        int len2 = s.rbegin()->second - s.rbegin()->first + 1;\n                        len1 = min(len1, len - 1);\n                        len2 = min(len2, len - 1);\n                        cur += max(0, len1 + len2 - len + 1);\n                    }\n                } else if (colors[0] != colors[n - 1]) {\n                    cur = n;\n                }\n                ans.push_back(cur);\n            } else {\n                int at = q[1];\n                int newColor = q[2];\n                if (colors[at] != newColor) {\n                    newSegs.clear();\n                    if (at - 1 >= 0 && at + 1 < n) {\n                        int from, to;\n                        from = getSeg(at - 1).first;\n                        to = getSeg(at + 1).second;\n                        if (get(at - 1) == get(at + 1)) {\n                            if (get(at) == get(at - 1)) {\n                                deleteSeg(from, to);\n                                insertSeg(from, at - 1);\n                                insertSeg(at, at);\n                                insertSeg(at + 1, to);\n                            } else {\n                                deleteSeg(from, at - 1);\n                                deleteSeg(at, at);\n                                deleteSeg(at + 1, to);\n                                insertSeg(from, to);\n                            }\n                        } else {\n                            if (get(at) == get(at - 1)) {\n                                deleteSeg(from, at);\n                                deleteSeg(at + 1, to);\n                                insertSeg(from, at - 1);\n                                insertSeg(at, to);\n                            } else {\n                                deleteSeg(from, at - 1);\n                                deleteSeg(at, to);\n                                insertSeg(from, at);\n                                insertSeg(at + 1, to);\n                            }\n                        }\n                    } else {\n                        if (at - 1 >= 0) {\n                            int from = getSeg(at - 1).first;\n                            if (get(at) == get(at - 1)) {\n                                deleteSeg(from, at);\n                                insertSeg(from, at - 1);\n                                insertSeg(at, at);\n                            } else {\n                                deleteSeg(from, at - 1);\n                                deleteSeg(at, at);\n                                insertSeg(from, at);\n                            }\n                        } else if (at + 1 < n) {\n                            int to = getSeg(at + 1).second;\n                            if (get(at) == get(at + 1)) {\n                                deleteSeg(at, to);\n                                insertSeg(at + 1, to);\n                                insertSeg(at, at);\n                            } else {\n                                deleteSeg(at + 1, to);\n                                deleteSeg(at, at);\n                                insertSeg(at, to);\n                            }\n                        }\n                    }\n                }\n                colors[at] = newColor;\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722742121",
    "subm_id": "1343761482"
}