{
    "username": "cychiu77",
    "submission": "class Solution {\n    int bfs(int n, vector<vector<int>>& tree1, vector<int>& d1) {\n        // tree1\n        queue<int> q1;\n        vector<bool> seen1(n);\n        for (int i = 0; i < n; i++) {\n            if (d1[i] <= 1) {\n                q1.emplace(i);\n                seen1[i] = 1;\n            }\n        }\n        \n        int res = 0;\n        int len1 = 0, last;\n        while (q1.size()) {\n            int sz = q1.size();\n            last = sz;\n            while (sz--) {\n                auto cur = q1.front();\n                q1.pop();\n                \n                for (auto &nei : tree1[cur]) {\n                    if (seen1[nei] == 0 and --d1[nei] <= 1) {\n                        q1.emplace(nei);\n                        seen1[nei] = 1;\n                    }\n                }\n            }\n            len1++;\n        }\n        len1--;\n        len1 += last > 1;\n        // cout << len1 << endl;\n        return len1;\n    }  \n    \n    \n    int diameter(int n, vector<vector<int>>& tree1, vector<int>& d1) {\n        queue<int> q1;\n        vector<bool> seen1(n);\n        for (int i = 0; i < n; i++) {\n            if (d1[i] <= 1) {\n                q1.emplace(i);\n                seen1[i] = 1;\n                break;\n            }\n        }\n        \n        int last = -1;\n        while (q1.size()) {\n            int sz = q1.size();\n            while (sz--) {\n                auto cur = q1.front();\n                q1.pop();\n                \n                last = cur;\n                \n                for (auto &nei : tree1[cur]) {\n                    if (seen1[nei] == 0) {\n                        q1.emplace(nei);\n                        seen1[nei] = 1;\n                    }\n                }\n            }\n        }\n        \n        \n        // bfs again\n        q1.emplace(last);\n        fill(begin(seen1), end(seen1), 0);\n        seen1[last] = 1;\n        \n        int len = 0;\n        while (q1.size()) {\n            int sz = q1.size();\n            while (sz--) {\n                auto cur = q1.front();\n                q1.pop();\n                                \n                for (auto &nei : tree1[cur]) {\n                    if (seen1[nei] == 0) {\n                        q1.emplace(nei);\n                        seen1[nei] = 1;\n                    }\n                }\n            }\n            len++;\n        }\n        return len - 1;\n    }\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        // if (n == 1 and m == 1) return 1;\n        \n        vector tree1(n, vector<int>());\n        vector tree2(m, vector<int>());\n        \n        vector<int> d1(n), d2(m);\n        \n        for (auto &e : edges1) {\n            int u = e[0], v = e[1];\n            tree1[u].emplace_back(v);\n            tree1[v].emplace_back(u);\n            d1[u]++, d1[v]++;\n        }\n        \n        for (auto &e : edges2) {\n            int u = e[0], v = e[1];\n            tree2[u].emplace_back(v);\n            tree2[v].emplace_back(u);\n            d2[u]++, d2[v]++;\n        }\n        \n        int dia1 = diameter(n, tree1, d1);\n        int dia2 = diameter(m, tree2, d2);\n        // cout << dia1 << endl << dia2 << endl;\n        return max({dia1, dia2, bfs(n, tree1, d1) + bfs(m, tree2, d2) + 1});        \n    }\n};",
    "submit_ts": 1719719118.0
}