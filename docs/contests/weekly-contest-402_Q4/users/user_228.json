{
    "username": "zanj0",
    "submission": "/*\n\tJAI JAGANNATH!\n*/\n//@Author : zanj0\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ff              first\n#define ss              second\n#define pb              push_back\n#define MOD             1000000007\n#define inf             1e18\n\ntypedef long long int lli;\ntemplate<class T>\nstruct Segtree {\n\tvector<T>st;\n\tint n;\n\tT identity_element;\n\tSegtree(int n, T identity_element)\n\t{\n\t\tthis->n = n;\n\t\tthis->identity_element = identity_element;\n\t\tst.assign(4 * n, identity_element);\n\t}\n\tT combine(T l, T r)\n\t{\n\t\t// change this function as required.\n\t\tT ans = l + r;\n\t\treturn ans;\n\t}\n\tvoid buildUtil(int v, int tl, int tr, vector<T>&a)\n\t{\n\t\tif (tl == tr)\n\t\t{\n\t\t\tst[v] = a[tl];\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr) >> 1;\n\t\tbuildUtil(2 * v + 1, tl, tm, a);\n\t\tbuildUtil(2 * v + 2, tm + 1, tr, a);\n\t\tst[v] = combine(st[2 * v + 1], st[2 * v + 2]);\n\t}\n\tT queryUtil(int v, int tl, int tr, int l, int r)\n\t{\n\t\tif (l > r)return identity_element;\n\t\tif (r < tl or l > tr)\n\t\t{\n\t\t\treturn identity_element;\n\t\t}\n\t\tif (tl >= l and tr <= r)\n\t\t{\n\t\t\treturn st[v];\n\t\t}\n\t\tint tm = (tl + tr) >> 1;\n\t\treturn combine(queryUtil(2 * v + 1, tl, tm, l, r), queryUtil(2 * v + 2, tm + 1, tr, l, r));\n\t}\n\tT apply(T curr, T val)\n\t{\n\t\t// change this function if update is of some other kind.\n\n\t\treturn val;\n\t}\n\tvoid updateUtil(int v, int tl, int tr, int ind, T val)\n\t{\n\t\tif (tl == tr)\n\t\t{\n\t\t\tst[v] = apply(st[v], val);\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr) >> 1;\n\t\tif (ind <= tm)\n\t\t{\n\t\t\tupdateUtil(2 * v + 1, tl, tm, ind, val);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdateUtil(2 * v + 2, tm + 1, tr, ind, val);\n\t\t}\n\t\tst[v] = combine(st[2 * v + 1], st[2 * v + 2]);\n\t}\n\n\n\tvoid build(vector<T>a)\n\t{\n\t\tassert(a.size() == n);\n\t\tbuildUtil(0, 0, n - 1, a);\n\t}\n\tT query(int l, int r)\n\t{\n\t\treturn queryUtil(0, 0, n - 1, l, r);\n\t}\n\tvoid update(int ind, T val)\n\t{\n\t\tupdateUtil(0, 0, n - 1, ind, val);\n\t}\n};\nclass Solution {\npublic:\n\tbool IsPeak(lli idx, vector<int>& nums) {\n\t\tint n = nums.size();\n\t\treturn idx - 1 >= 0 && idx + 1 < n && nums[idx] > nums[idx - 1] && nums[idx] > nums[idx + 1];\n\t}\n\tvector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n\t\tint n = nums.size();\n\t\tvector<lli> pre(n);\n\t\tfor (int i = 1; i  + 1 < n; i++)   {\n\t\t\tpre[i] = nums[i - 1] < nums[i] && nums[i] > nums[i + 1];\n\t\t}\n\t\tSegtree<lli> segment_tree = Segtree(n, (lli)0);\n\t\tsegment_tree.build(pre);\n\t\tvector<int> ret;\n\t\tfor (auto& it : queries) {\n\t\t\tif (it[0] == 1) {\n\t\t\t\tlli l = it[1], r = it[2];\n\t\t\t\tl++, r--;\n\t\t\t\tlli now = 0;\n\t\t\t\tif (l <= r) {\n\t\t\t\t\tnow = segment_tree.query(l, r);\n\t\t\t\t}\n\t\t\t\tret.pb(now);\n\t\t\t} else {\n\t\t\t\tlli idx = it[1], val = it[2];\n\n\n\t\t\t\tsegment_tree.update(idx, -1 * IsPeak(idx, nums));\n\n\t\t\t\tif (idx - 1 >= 0) segment_tree.update(idx - 1, -1 * IsPeak(idx - 1, nums));\n\t\t\t\tif (idx + 1 < n) segment_tree.update(idx + 1, -1 * IsPeak(idx + 1, nums));\n                \n                nums[idx] = val;\n\t\t\t\t\n                segment_tree.update(idx,  IsPeak(idx, nums));\n\n\t\t\t\tif (idx - 1 >= 0) segment_tree.update(idx - 1, IsPeak(idx - 1, nums));\n\t\t\t\tif (idx + 1 < n) segment_tree.update(idx + 1, IsPeak(idx + 1, nums));\n\n    \n\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n};\n#ifdef LOCAL\nint main() {\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tcout << \"Compiled!\" << endl;\n}\n#endif\n",
    "submit_ts": 1718506262.0
}