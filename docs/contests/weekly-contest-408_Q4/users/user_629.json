{
    "username": "10Ari",
    "submission": "#include <vector>\n#include <queue>\n#include <cmath>\n\nclass Solution {\npublic:\n    bool canReachCorner(int width, int height, const std::vector<std::vector<int>>& obstacles) {\n        int numObstacles = obstacles.size();\n        std::vector<std::pair<std::pair<int, int>, int>> obstacleDetails(numObstacles);\n        std::vector<std::vector<int>> adjList(numObstacles + 4);\n\n        for (int i = 0; i < numObstacles; ++i) {\n            obstacleDetails[i] = {{obstacles[i][0], obstacles[i][1]}, obstacles[i][2]};\n        }\n\n        // Connect obstacles to the boundaries\n        for (int i = 0; i < numObstacles; ++i) {\n            int x = obstacleDetails[i].first.first;\n            int y = obstacleDetails[i].first.second;\n            int radius = obstacleDetails[i].second;\n\n            if (x <= radius) {\n                adjList[numObstacles].push_back(i);\n                adjList[i].push_back(numObstacles);\n            }\n            if (width - x <= radius) {\n                adjList[numObstacles + 2].push_back(i);\n                adjList[i].push_back(numObstacles + 2);\n            }\n            if (y <= radius) {\n                adjList[numObstacles + 1].push_back(i);\n                adjList[i].push_back(numObstacles + 1);\n            }\n            if (height - y <= radius) {\n                adjList[numObstacles + 3].push_back(i);\n                adjList[i].push_back(numObstacles + 3);\n            }\n            // Connect obstacles to each other if they overlap\n            for (int j = i + 1; j < numObstacles; ++j) {\n                if (circlesOverlap(obstacleDetails[i], obstacleDetails[j])) {\n                    adjList[i].push_back(j);\n                    adjList[j].push_back(i);\n                }\n            }\n        }\n\n        auto bfs = [&](int src, int dest1, int dest2) {\n            std::queue<int> q;\n            std::vector<bool> visited(adjList.size(), false);\n            q.push(src);\n            visited[src] = true;\n\n            while (!q.empty()) {\n                int node = q.front();\n                q.pop();\n                for (int neighbor : adjList[node]) {\n                    if (!visited[neighbor]) {\n                        q.push(neighbor);\n                        visited[neighbor] = true;\n                    }\n                }\n            }\n            return visited[dest1] || visited[dest2];\n        };\n\n        return !(bfs(numObstacles, numObstacles + 1, numObstacles + 2) || \n                     bfs(numObstacles + 3, numObstacles + 2, numObstacles + 1));\n    }\n\nprivate:\n    bool circlesOverlap(const std::pair<std::pair<int, int>, int>& circle1, const std::pair<std::pair<int, int>, int>& circle2) {\n        int x1 = circle1.first.first;\n        int y1 = circle1.first.second;\n        int r1 = circle1.second;\n\n        int x2 = circle2.first.first;\n        int y2 = circle2.first.second;\n        int r2 = circle2.second;\n\n        double dist = std::sqrt(std::pow(x1 - x2, 2) + std::pow(y1 - y2, 2));\n        return r1 + r2 >= dist;\n    }\n};\n",
    "submit_ts": "1722137798",
    "subm_id": "1335774044"
}