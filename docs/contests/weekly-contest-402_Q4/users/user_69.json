{
    "username": "Harshkriplani",
    "submission": "class Solution {\npublic:\n    struct my_node\n{\n\tint su = 0;\n\t\n\t// use more variables if you want more information\n\t// these default values should be identity_element\n\tmy_node() {}\n\tmy_node(int val) {\n\t\tsu=val;\n\t}\n\tvoid merge(const my_node &l, const my_node &r) { // store the thing you wanna query\n\n\t\tsu = (l.su+ r.su);/////combining nodes\n\t\t\n\n\t\t// if we wanted the maximum, then we would do\n\t\t// like v = max(l.v,r.v)\n\t}\n};\n\n// example: add on a range: identity transformation = 0\n// old += new\n\n// if old is identity which is 0, then 0 + new which new\n\nstruct my_update\n{\n\tint v = 0; // 4\n\t// use more variables if you want more information\n\t// these default values should be identity_transformation\n\tmy_update() {}\n\tmy_update(int val) {\n\t\tv = val; // 5/////jo milegi update karne ke liye .......\n\t}\n\t// combine the current my_update with the other my_update (see keynotes)\n\tvoid combine(my_update &other, const int32_t &tl, const int32_t &tr) {\n\t\tv = other.v; // 6//combining nodes......\n\t\t//v=other.v\n\n\t\t// you can be sure that the \"other\" is newer than current\n\n\t}\n\t// store the correct information in the my_node x\n\tvoid apply(my_node &x, const int32_t &tl, const int32_t &tr) {\n\n\t\t// no change in freq\n\t\t//x.mn=v\n\t\t//if(v%2)\n\t\tx.su = v;/////cobining nodes\n\t\t// x.v+=(tr-tl+1)*v;\n\n\t}\n};\n\ntemplate<typename node, typename update>\nstruct segtree\n{\n\tint len;\n\tvector<node> t;\n\tvector<update> u;\n\tvector<bool> lazy;\n\tnode identity_element;\n\tupdate identity_transformation;\n\tsegtree(int l) {\n\t\tlen = l;\n\t\tt.resize(4 * len);\n\t\tu.resize(4 * len);\n\t\tlazy.resize(4 * len);\n\t\tidentity_element = node();\n\t\tidentity_transformation = update();\n\t}\n\tsegtree()\n\t{\n\t\t;\n\t}\n\n\tvoid pushdown(const int32_t &v, const int32_t &tl, const int32_t &tr) {\n\t\tif (!lazy[v]) return;\n\t\tint32_t tm = (tl + tr) >> 1;\n\t\tapply(v << 1, tl, tm, u[v]);\n\t\tapply(v << 1 | 1, tm + 1, tr, u[v]);\n\t\tu[v] = identity_transformation;\n\t\tlazy[v] = 0;\n\t}\n\n\tvoid apply(const int32_t &v, const int32_t &tl, const int32_t &tr, update upd) {\n\t\tif (tl != tr) {\n\t\t\tlazy[v] = 1;\n\t\t\tu[v].combine(upd, tl, tr);\n\t\t}\n\t\tupd.apply(t[v], tl, tr);\n\t}\n\n\ttemplate<typename T>\n\tvoid build(const T &arr, const int32_t &v, const int32_t &tl, const int32_t &tr) {\n\t\tif (tl == tr) {\n\t\t\tt[v] = arr[tl];\n\t\t\treturn;\n\t\t}\n\t\tint32_t tm = (tl + tr) >> 1;\n\t\tbuild(arr, v << 1, tl, tm);\n\t\tbuild(arr, v << 1 | 1, tm + 1, tr);\n\t\tt[v].merge(t[v << 1], t[v << 1 | 1]);\n\t}\n\n\tnode query(const int32_t &v, const int32_t &tl, const int32_t &tr, const int32_t &l, const int32_t &r) {\n\t\tif (l > tr || r < tl) {\n\t\t\treturn identity_element;\n\t\t}\n\t\tif (tl >= l && tr <= r) {\n\t\t\treturn t[v];\n\t\t}\n\t\tpushdown(v, tl, tr);\n\t\tint32_t tm = (tl + tr) >> 1;\n\t\tnode a = query(v << 1, tl, tm, l, r), b = query(v << 1 | 1, tm + 1, tr, l, r), ans;\n\t\tans.merge(a, b);\n\t\treturn ans;\n\t}\n\n\t// rupd = range update\n\tvoid rupd(const int32_t &v, const int32_t &tl, const int32_t &tr, const int32_t &l, const int32_t &r, const update &upd) {\n\t\tif (l > tr || r < tl) {\n\t\t\treturn;\n\t\t}\n\t\tif (tl >= l && tr <= r) {\n\t\t\tapply(v, tl, tr, upd);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(v, tl, tr);\n\t\tint32_t tm = (tl + tr) >> 1;\n\t\trupd(v << 1, tl, tm, l, r, upd);\n\t\trupd(v << 1 | 1, tm + 1, tr, l, r, upd);\n\t\tt[v].merge(t[v << 1], t[v << 1 | 1]);\n\t}\n\npublic:\n\ttemplate<typename T>\n\tvoid build(const T &arr) {\n\t\tif (len == 0)\n\t\t\treturn ;\n\t\tbuild(arr, 1, 0, len - 1);\n\t}\n\tnode query(const int32_t &l, const int32_t &r) {\n\t\treturn query(1, 0, len - 1, l, r);\n\t}\n\tvoid rupd(const int32_t &l, const int32_t &r, const update &upd) {\n\t\tif (len == 0)\n\t\t\treturn ;\n\t\trupd(1, 0, len - 1, l, r, upd);\n\t}\n};\n\n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& q) {\n        int n=a.size();\n        vector<int>b(n,0);\n        for(int i=1;i<a.size()-1;i++)\n        {\n            if(a[i]>a[i-1]&&a[i]>a[i+1])\n            {\n                b[i]=1;\n            }\n            \n        }\n        segtree<my_node, my_update>s(n);\n        s.build(b);\n        vector<int>ans;\n        for(int i=0;i<q.size();i++)\n        {\n            if(q[i][0]==1)\n            {\n                int l=q[i][1]+1;\n                int r=q[i][2]-1;\n                if(l<=r)\n                ans.push_back(s.query(l,r).su);\n                else\n                    ans.push_back(0);\n                \n            }\n            else\n            {\n                int in=q[i][1];\n                int val=q[i][2];\n                a[in]=val;\n                if(in-1>=0)\n                s.rupd(in-1,in-1,0);\n                if(in+1<n)\n                    s.rupd(in+1,in+1,0);\n                s.rupd(in,in,0);\n                for(int j=in-1;j<=in+1;j++)\n                {\n                    if(j>=0&&j+1<n&&j-1>=0)\n                    {\n                        if(a[j]>a[j-1]&&a[j]>a[j+1])\n                        {\n                            s.rupd(j,j,1);\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n        \n        \n    }\n};",
    "submit_ts": 1718506419.0
}