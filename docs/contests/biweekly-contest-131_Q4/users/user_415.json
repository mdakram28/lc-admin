{
    "username": "liu-chen-22",
    "submission": "using i64 = long long;\n\ntemplate<class Info, class Tag>\nstruct LazySegmentTree {\n\tconst int n;\n\tvector<Info> info;\n\tvector<Tag> tag;\n\tLazySegmentTree(int n) : n(n), info(4 << __lg(n)), tag(4 << __lg(n)) {}\n\tLazySegmentTree(vector<Info> init) : LazySegmentTree(init.size()) {\n\t\tfunction<void(int, int, int)> build = [&](int p, int l, int r) {\n\t\t\tif (l == r) {\n\t\t\t\tinfo[p] = init[r - 1];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint m = (l + r) / 2;\n\t\t\tbuild(2 * p, l, m);\n\t\t\tbuild(2 * p + 1, m + 1, r);\n\t\t\tpull(p);\n\t\t};\n\t\tbuild(1, 1, n);\n\t}\n\tvoid pull(int p) {\n\t\tinfo[p] = info[2 * p] + info[2 * p + 1];\n\t}\n\tvoid apply(int p, const Tag &v) {\n\t\tinfo[p].apply(v);\n\t\ttag[p].apply(v);\n\t}\n\tvoid push(int p) {\n\t\tapply(2 * p, tag[p]);\n\t\tapply(2 * p + 1, tag[p]);\n\t\ttag[p] = Tag();\n\t}\n\tvoid modify(int p, int l, int r, int x, const Info &v) {\n\t\tif (l == r) {\n\t\t\tinfo[p] = v;\n\t\t\treturn;\n\t\t}\n\t\tint m = (l + r) / 2;\n\t\tpush(p);\n\t\tif (x <= m) {\n\t\t\tmodify(2 * p, l, m, x, v);\n\t\t} else {\n\t\t\tmodify(2 * p + 1, m + 1, r, x, v);\n\t\t}\n\t\tpull(p);\n\t}\n\tvoid modify(int p, const Info &v) {\n\t\tmodify(1, 1, n, p, v);\n\t}\n\tvoid rangeApply(int p, int l, int r, int x, int y, const Tag &v) {\n\t\tif (l > y || r < x) {\n\t\t\treturn;\n\t\t}\n\t\tif (l >= x && r <= y) {\n\t\t\tapply(p, v);\n\t\t\treturn;\n\t\t}\n\t\tint m = (l + r) / 2;\n\t\tpush(p);\n\t\trangeApply(2 * p, l, m, x, y, v);\n\t\trangeApply(2 * p + 1, m + 1, r, x, y, v);\n\t\tpull(p);\n\t}\n\tvoid rangeApply(int l, int r, const Tag &v) {\n\t\trangeApply(1, 1, n, l, r, v);\n\t}\n\tInfo rangeQuery(int p, int l, int r, int x, int y) {\n\t\tif (l > y || r < x) {\n\t\t\treturn Info();\n\t\t}\n\t\tif (l >= x && r <= y) {\n\t\t\treturn info[p];\n\t\t}\n\t\tint m = (l + r) / 2;\n\t\tpush(p);\n\t\treturn rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m + 1, r, x, y);\n\t}\n\tInfo rangeQuery(int l, int r) {\n\t\treturn rangeQuery(1, 1, n, l, r);\n\t}\n};\n\nstruct Tag {\n\tint add = 0;\n\n\tvoid apply(Tag t) {\n\t\tadd += t.add;\n\t}\n};\n\nstruct Info {\n\tint mx = 0;\n\n\tvoid apply(Tag t) {\n\t\tmx += t.add;\n\t}\n};\n\nInfo operator+(Info a, Info b) {\n\tInfo c;\n\tc.mx = a.mx > b.mx ? a.mx : b.mx;\n\treturn c;\n}\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n    \tint n = 0;\n        for (auto &v : queries) {\n            n = max(n, v[1]);\n        }\n    \tvector<Info> init(n);\n    \tfor (int i = 1; i <= n; i++) {\n    \t\tinit[i - 1] = {i};\n    \t}\n        LazySegmentTree<Info, Tag> seg(init);\n        set<int> s;\n        s.insert(0);\n        s.insert(n);\n\n        vector<bool> res;\n        for (auto &v : queries) {\n        \tint t = v[0];\n        \tif (t == 1) {\n        \t\tint x = v[1];\n                if (x == n) continue;\n        \t\ts.insert(x);\n        \t\tauto it = s.find(x);\n        \t\tseg.rangeApply(x + 1, *next(it), {-x});\n                if (*prev(it)) seg.rangeApply(x + 1, *next(it), {*prev(it)});\n        \t} else {\n        \t\tint x = v[1], sz = v[2];\n        \t\tint mx = seg.rangeQuery(1, x).mx;\n        \t\tif (mx >= sz) res.push_back(true);\n                else res.push_back(false);\n        \t}\n        }\n        return res;\n    }\n};",
    "submit_ts": "1716651626",
    "subm_id": "534775796"
}