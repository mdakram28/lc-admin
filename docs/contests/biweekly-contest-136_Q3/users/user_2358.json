{
    "username": "jachetheboss",
    "submission": "class Solution {\npublic:\n    int helper(int flips1, int ones, vector<vector<int>>& grid){\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        \n        int mod = ones % 4;\n        \n        int ans1 = -1;\n        \n        if(mod == 0){\n            int total_ones = flips1 * 2 + ones;\n            if(total_ones % 4 == 0) ans1 = flips1;\n            else ans1 = flips1; // % 4 == 2\n        }else if(mod == 1){ // some odd center\n            if(flips1 % 2 == 0){\n                ans1 = flips1 + 1;\n            }else{ // % 2 == 1\n                ans1 = flips1 + 1; // can we do less than this?\n            }\n        }else if(mod == 2){\n            if(flips1 == 0){\n                ans1 = 2;\n            }else ans1 = flips1;\n        }else if(mod == 3){\n            if(flips1 == 0){ // everything palindromic already\n                // check if there is a odd center 0\n                bool ok = false;\n                for(int i = 0; i < m; ++i){\n                    if(grid[i][n / 2] == 0){\n                        ok = true;\n                        break;\n                    }\n                }\n                if(ok) ans1 = 1;\n                else{\n                    ans1 = 3; // can \n                }\n            }else{\n                ans1 = flips1 + 1;\n            }\n        }\n        \n        cout << \"ones: \" << ones << endl;\n        cout << \"flips: \" << flips1 << endl;\n        cout << endl;\n        \n        return ans1;\n    }\n    int minFlips(vector<vector<int>>& grid) {\n         // try all rows\n//         int ones = 0; // palindromic ones\n//         int flips1 = 0;\n//         int n = grid[0].size();\n//         int m = grid.size();\n        \n//         int bound = n / 2;\n        \n//         for(int i = 0; i < m; ++i){\n//             for(int j = 0; j < bound; ++j){\n//                 if(grid[i][j] != grid[i][n - 1 - j]) flips1++;\n//                 else if(grid[i][j] == 1){\n//                     cout << \"i: \" << i << \" j: \" << j << endl;\n//                     ones += 2;\n//                 }\n//             }\n//             if(n % 2 == 1 and grid[i][n / 2] == 1) ones++;\n//         }\n//         // int mod = ones % 4;\n//         cout << \"ONES: \" << ones << endl;\n//         // check edge case of when flips1 == 0?\n//         int ans1 = helper(flips1, ones, grid);\n        \n        \n//         ones = 0;\n//         int flips2 = 0;\n//         bound = m / 2;\n//         for(int j = 0; j < n; ++j){\n//             for(int i = 0; i < bound; ++i){\n//                 if(grid[i][j] != grid[m - 1 - i][j]) flips2++;\n//                 else if(grid[i][j] == 1) ones += 2;\n//             }\n//             if(m % 2 == 1 and grid[m / 2][j] == 1) ones++;\n//         }\n//         // mod = ones % 4;\n//         int ans2 = helper(flips2, ones, grid);\n        \n//         int ans = min(ans1, ans2);\n        \n//         return ans;\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        int i_bound = m / 2;\n        int j_bound = n / 2;\n        int ans = 0;\n        for(int i = 0; i < i_bound; ++i){\n            for(int j = 0; j < j_bound; ++j){\n                int ones = 0;\n                if(grid[i][j] == 1) ones++;\n                if(grid[i][n - 1 - j] == 1) ones++;\n                if(grid[m - 1 - i][j] == 1) ones++;\n                if(grid[m - 1 - i][n - 1 - j] == 1) ones++;\n                if(ones == 0 or ones == 4) ans += 0;\n                else if(ones == 1 or ones == 3) ans++;\n                else if(ones == 2) ans += 2;\n            }\n        }\n        if(m % 2 == 1 and n % 2 == 1 and grid[m / 2][n / 2] == 1) ans++;\n        \n        if(m % 2 == 1 or n % 2 == 1){\n            int pal_ones = 0;\n            int flips = 0;\n            if(m % 2 == 1){\n                for(int j = 0; j < j_bound; ++j){\n                    if(grid[m / 2][j] != grid[m / 2][n - 1 - j]) flips++;\n                    else if(grid[m / 2][j] == 1) pal_ones += 2;\n                }\n            }\n            if(n % 2 == 1){\n                for(int i = 0; i < i_bound; ++i){\n                    if(grid[i][n / 2] != grid[m - 1 - i][n / 2]) flips++;\n                    else if(grid[i][n / 2] == 1) pal_ones += 2;\n                }\n            }\n            if(pal_ones % 4 == 0){\n                ans += flips;\n            }else{ // pal_ones % 4 == 2\n                if(flips == 0) ans += 2;\n                else ans += flips;\n            }\n        }\n        return ans;        \n    }\n};",
    "submit_ts": "1722700172",
    "subm_id": "1343233793"
}