{
    "username": "12113078",
    "submission": "class Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n        vector<vector<int>> graph(n);\n        \n        // Function to check if two circles touch or overlap\n        auto circlesTouch = [&](int i, int j) {\n            long long x1 = circles[i][0], y1 = circles[i][1], r1 = circles[i][2];\n            long long x2 = circles[j][0], y2 = circles[j][1], r2 = circles[j][2];\n            long long dx = x1 - x2, dy = y1 - y2;\n            long long distSq = dx * dx + dy * dy;\n            long long radSumSq = (r1 + r2) * (r1 + r2);\n            return distSq <= radSumSq;\n        };\n        \n        // Build the graph: add edges between touching circles\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (circlesTouch(i, j)) {\n                    graph[i].push_back(j);\n                    graph[j].push_back(i);\n                }\n            }\n        }\n        \n        // Function to check if a circle touches the bottom or right border\n        auto touchesBottomOrRightBorder = [&](int i) {\n            int x = circles[i][0], y = circles[i][1], r = circles[i][2];\n            return (y - r <= 0 || x + r >= X);\n        };\n\n        // Function to check if a circle touches the left or top border\n        auto touchesLeftOrTopBorder = [&](int i) {\n            int x = circles[i][0], y = circles[i][1], r = circles[i][2];\n            return (x - r <= 0 || y + r >= Y);\n        };\n        \n        unordered_set<int> bottomOrRightBorderTouch, leftOrTopBorderTouch;\n        \n        // Identify circles touching the bottom or right border and left or top border\n        for (int i = 0; i < n; ++i) {\n            if (touchesBottomOrRightBorder(i)) {\n                bottomOrRightBorderTouch.insert(i);\n            }\n            if (touchesLeftOrTopBorder(i)) {\n                leftOrTopBorderTouch.insert(i);\n            }\n        }\n        \n        // Use DFS or BFS to check connectivity between circles touching the borders\n        vector<bool> visited(n, false);\n        \n        auto isConnected = [&](unordered_set<int>& startSet, unordered_set<int>& endSet) {\n            queue<int> q;\n            for (int s : startSet) {\n                q.push(s);\n                visited[s] = true;\n            }\n            \n            while (!q.empty()) {\n                int node = q.front();\n                q.pop();\n                \n                if (endSet.count(node)) return true;\n                \n                for (int neighbor : graph[node]) {\n                    if (!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        q.push(neighbor);\n                    }\n                }\n            }\n            return false;\n        };\n        \n        // Check connectivity\n        if (!bottomOrRightBorderTouch.empty() && !leftOrTopBorderTouch.empty() && isConnected(bottomOrRightBorderTouch, leftOrTopBorderTouch)) {\n            return false;\n        }\n        \n        return true;\n    }\n};",
    "submit_ts": "1722136386",
    "subm_id": "1335732824"
}