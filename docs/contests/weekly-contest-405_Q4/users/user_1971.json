{
    "username": "mble6125",
    "submission": "struct node {\n    bool isEnd=false;\n    int cost=0;\n    node* next[26] = {nullptr};\n};\n\nclass Solution {\n    node root;\n    int res=INT_MAX;\n    unordered_map<int,int> M;\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        for (int i=0; i<words.size(); ++i) {\n            string& s = words[i];\n            node* temp=&root;\n            for (char c : s) {\n                if (temp->next[c-'a']==nullptr) {\n                    temp->next[c-'a'] = new node;\n                }\n                temp=temp->next[c-'a'];\n            }\n            if (temp->isEnd) {\n                temp->cost=min(temp->cost, costs[i]);\n            } else {\n                temp->isEnd=true;\n                temp->cost = costs[i];\n            }\n        }\n        \n        vector<int> dp(target.size()+1, INT_MAX);\n        dp[0]=0;\n        \n        for (int i=0; i<target.size(); ++i) {\n            if (dp[i]==INT_MAX) continue;\n            node* temp = &root;\n            \n            for (int j=i; j<target.size(); ++j) {\n                if (temp->next[target[j]-'a']==nullptr) break;\n                temp=temp->next[target[j]-'a'];\n                if (temp->isEnd) {\n                    dp[j+1]=min(dp[j+1], dp[i]+temp->cost);\n                }\n            }\n            \n        }\n        \n        if (dp.back()==INT_MAX) return -1;\n        return dp.back();\n    }\n    \n    bool success(string& s, int cur, int index) {\n        if (cur>=res) return false;\n        auto iter=M.find(index);\n        if (iter!=M.end() && iter->second<=cur) {\n            return false;\n        }\n\n        M[index]=cur;\n        \n        if (index==s.size()) {\n            res=min(res, cur);\n            return true;\n        }\n        // cout<<cur<<\" \"<<index<<\" \"<<maximum<<endl;\n        \n        node* temp=&root;\n\n        vector<array<int,2>> S;\n        \n        for (int i=index; i<s.size(); ++i) {\n            if (temp->next[s[i]-'a'] == nullptr) break;\n            temp=temp->next[s[i]-'a'];           \n            if (temp->isEnd){\n                S.push_back({cur+temp->cost, i+1});\n            }\n        }\n        \n        sort(S.begin(), S.end(), [=](array<int,2>& a, array<int,2>& b) {\n            return a[0]/(a[1]-index+1) > b[0]/(b[1]-index+1);\n        });\n        \n        for (auto& a : S) {\n            success(s, a[0], a[1]);\n        }\n        \n        return false;\n    }\n};",
    "submit_ts": "1720324598",
    "subm_id": "1312403459"
}