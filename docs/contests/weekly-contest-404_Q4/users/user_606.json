{
    "username": "sandbag",
    "submission": "class TreeDiameter {\npublic:\n    TreeDiameter(const vector<vector<int>>& adjacencyList)\n        : adj(adjacencyList), n(adjacencyList.size()), maxDist(0) {\n        visited.resize(n, false);\n    }\n\n    int find() {\n        // Start DFS from any node (we start from node 0)\n        dfs(0, 0);\n\n        // Start another DFS from the farthest node found in the previous DFS\n        fill(visited.begin(), visited.end(), false);\n        maxDist = 0;\n        dfs(farthestNode, 0);\n\n        return maxDist;\n    }\n\nprivate:\n    const vector<vector<int>>& adj;\n    int n;\n    vector<bool> visited;\n    int maxDist;\n    int farthestNode;\n\n    void dfs(int node, int dist) {\n        visited[node] = true;\n        if (dist > maxDist) {\n            maxDist = dist;\n            farthestNode = node;\n        }\n\n        for (int neighbor : adj[node]) {\n            if (!visited[neighbor]) {\n                dfs(neighbor, dist + 1);\n            }\n        }\n    }\n};\nclass TreeCenter {\npublic:\n    TreeCenter(const vector<vector<int>>& adjacencyList)\n        : adj(adjacencyList), n(adjacencyList.size()) {}\n\n    vector<int> findTreeCenters() {\n        if (n == 0) return {};\n\n        // Initialize degrees of all nodes\n        vector<int> degree(n, 0);\n        for (int i = 0; i < n; ++i) {\n            degree[i] = adj[i].size();\n        }\n\n        // Queue to store leaf nodes\n        queue<int> leaves;\n        for (int i = 0; i < n; ++i) {\n            if (degree[i] == 1 || degree[i] == 0) {\n                leaves.push(i);\n            }\n        }\n\n        // Remove leaves layer-by-layer\n        int remainingNodes = n;\n        while (remainingNodes > 2) {\n            int leavesCount = leaves.size();\n            remainingNodes -= leavesCount;\n            for (int i = 0; i < leavesCount; ++i) {\n                int leaf = leaves.front();\n                leaves.pop();\n                for (int neighbor : adj[leaf]) {\n                    if (--degree[neighbor] == 1) {\n                        leaves.push(neighbor);\n                    }\n                }\n            }\n        }\n\n        // The remaining nodes are the centers\n        vector<int> centers;\n        while (!leaves.empty()) {\n            centers.push_back(leaves.front());\n            leaves.pop();\n        }\n        return centers;\n    }\n\n    int find() {\n        vector<int> centers = findTreeCenters();\n        if (centers.empty()) return 0;\n\n        int maxDistance = 0;\n        for (int center : centers) {\n            maxDistance = max(maxDistance, dfs(center));\n        }\n\n        return maxDistance;\n    }\n\nprivate:\n    const vector<vector<int>>& adj;\n    int n;\n\n    int dfs(int node) {\n        vector<bool> visited(n, false);\n        return dfsHelper(node, visited);\n    }\n\n    int dfsHelper(int node, vector<bool>& visited) {\n        visited[node] = true;\n        int maxDist = 0;\n        for (int neighbor : adj[node]) {\n            if (!visited[neighbor]) {\n                maxDist = max(maxDist, 1 + dfsHelper(neighbor, visited));\n            }\n        }\n        return maxDist;\n    }\n};\n// boilerplate tree template code generated by gpt 3, \nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& e1, vector<vector<int>>& e2) {\n        vector<vector<int>> adj1(e1.size()+1, vector<int>());\n        vector<vector<int>> adj2(e2.size()+1, vector<int>());\n        for (auto i : e1) {\n            adj1[i[1]].push_back(i[0]);\n            adj1[i[0]].push_back(i[1]);\n        }\n        for (auto i : e2) {\n            adj2[i[1]].push_back(i[0]);\n            adj2[i[0]].push_back(i[1]);\n        }\n        // adj2[0].push_back(3);\n        TreeDiameter d1(adj1);\n        TreeDiameter d2(adj2);\n        TreeCenter t1(adj1);\n        TreeCenter t2(adj2);\n        // return t1.find();\n        int dm1 = d1.find(), dm2 = d2.find();\n        int ans1 = t1.find()+1+t2.find(), ans2 = max(dm1, dm2);\n        return max(ans1,ans2);\n        return t1.find() + 1 + t2.find();\n        return 0;\n        \n    }\n};",
    "submit_ts": 1719718967.0
}