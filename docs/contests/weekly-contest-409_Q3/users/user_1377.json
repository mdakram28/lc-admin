{
    "username": "jacobj2",
    "submission": "class MaxSegmentTree:\n    def __init__(self, data):\n        \"\"\"\n        Initialize the segment tree with the given data.\n        :param data: List[int], the initial array of data.\n        \"\"\"\n        self.n = len(data)\n        # Initialize the tree with 0s. The size of the tree array is 2 * n - 1\n        self.tree = [0] * (2 * self.n - 1)\n        \n        # Build the tree\n        self.build(data)\n    \n    def build(self, data):\n        \"\"\"\n        Build the segment tree from the given data.\n        :param data: List[int], the initial array of data.\n        \"\"\"\n        # Initialize leaves in the segment tree\n        for i in range(self.n):\n            self.tree[self.n - 1 + i] = data[i]\n        \n        # Build the tree by calculating parents\n        for i in range(self.n - 2, -1, -1):\n            self.tree[i] = max(self.tree[2 * i + 1], self.tree[2 * i + 2])\n    \n    def update(self, pos, value):\n        \"\"\"\n        Update the element at the given position.\n        :param pos: int, the index of the element to update (0-based).\n        :param value: int, the new value to update.\n        \"\"\"\n        # Set value at the position\n        pos += self.n - 1\n        self.tree[pos] = value\n        \n        # Update parents\n        while pos > 0:\n            pos = (pos - 1) // 2\n            self.tree[pos] = max(self.tree[2 * pos + 1], self.tree[2 * pos + 2])\n    \n    def query(self, left, right):\n        \"\"\"\n        Query the maximum value in the range [left, right).\n        :param left: int, the left boundary of the range (inclusive, 0-based).\n        :param right: int, the right boundary of the range (exclusive, 0-based).\n        :return: int, the maximum value in the specified range.\n        \"\"\"\n        # Convert to 0-based indexing in the segment tree\n        left += self.n - 1\n        right += self.n - 1\n        max_value = float('-inf')\n        \n        while left < right:\n            if left % 2 == 0:\n                max_value = max(max_value, self.tree[left])\n                left += 1\n            if right % 2 == 0:\n                right -= 1\n                max_value = max(max_value, self.tree[right])\n            left = (left - 1) // 2\n            right = (right - 1) // 2\n        \n        return max_value\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        mx = [i+1 for i in range(n)]\n        m = MaxSegmentTree(mx)\n        mb = [i-1 for i in range(n)]\n        l = n - 1\n        res = []\n        for u,v in queries:\n            if mx[u]>=v:\n                res.append(l)\n                continue\n            if mb[v]<=u:\n                res.append(l)\n                continue\n            if m.query(0,u+1)>=v:\n                res.append(l)\n                continue\n            d = 0\n            curr = u\n            while curr!=v:\n                d+=1\n                curr=mx[curr]\n            l-=(d-1)\n            mx[u]=v\n            m.update(u,v)\n            mb[v]=u\n            res.append(l)\n        return res\n            ",
    "submit_ts": "1722743977",
    "subm_id": "1343804165"
}