{
    "username": "turneja",
    "submission": "struct Node {\n    long long val;\n    int ct;\n    int left;\n    int right;\n    Node() : val(0), left(-1), right(-1), ct(0) {}\n};\n\nNode nodes[10000005];\n\nclass Solution {\npublic:\n    int pref[100005];\n    int rt[100005];\n    long long sumi[100005];\n    \n    int idx = 0;\n    int root[100005];\n    \n    void build(int node, int l, int r) {\n        if (l == r) {\n            return;\n        }\n        int mid = (l + r) / 2;\n        nodes[node].left = idx;\n        nodes[idx++] = Node();\n        nodes[node].right = idx;\n        nodes[idx++] = Node();\n        build(nodes[node].left, l, mid);\n        build(nodes[node].right, mid + 1, r);\n        return;\n    }\n\n    void update(int node_prev, int node, int l, int r, int ind) {\n        if (l == r) {\n            nodes[node].ct = nodes[node_prev].ct + 1;\n            nodes[node].val = nodes[node_prev].val + ind;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (ind <= mid) {\n            nodes[node].left = idx;\n            nodes[idx++] = Node();\n            nodes[node].right = nodes[node_prev].right;\n            update(nodes[node_prev].left, nodes[node].left, l, mid, ind);\n        } else {\n            nodes[node].right = idx;\n            nodes[idx++] = Node();\n            nodes[node].left = nodes[node_prev].left;\n            update(nodes[node_prev].right, nodes[node].right, mid + 1, r, ind);\n        }\n        nodes[node].val = nodes[nodes[node].left].val + nodes[nodes[node].right].val;\n        nodes[node].ct = nodes[nodes[node].left].ct + nodes[nodes[node].right].ct;\n        return;\n    }\n\n    long long queryVal(int node_l, int node_r, int l, int r, int lq, int rq) {\n        if (lq > r || rq < l) {\n            return 0;\n        }\n        if (lq <= l && rq >= r) {\n            return nodes[node_r].val - nodes[node_l].val;\n        }\n        int mid = (l + r) / 2;\n        return queryVal(nodes[node_l].left, nodes[node_r].left, l, mid, lq, rq) + queryVal(nodes[node_l].right, nodes[node_r].right, mid + 1, r, lq, rq);\n    }\n\n    int queryCt(int node_l, int node_r, int l, int r, int lq, int rq) {\n        if (lq > r || rq < l) {\n            return 0;\n        }\n        if (lq <= l && rq >= r) {\n            return nodes[node_r].ct - nodes[node_l].ct;\n        }\n        int mid = (l + r) / 2;\n        return queryCt(nodes[node_l].left, nodes[node_r].left, l, mid, lq, rq) + queryCt(nodes[node_l].right, nodes[node_r].right, mid + 1, r, lq, rq);\n    }\n    \n    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n        int n = s.size();\n        for (int i = 0; i < n; i++) {\n            int add = s[i] - '0';\n            pref[i] = ((i == 0) ? add : pref[i - 1] + add);\n            sumi[i] = ((i == 0) ? i : sumi[i - 1] + i);\n        }\n        for (int i = 0; i < n; i++) {\n            int l = i, r = n - 1, spl = l;\n            while (l <= r) {\n                int mid = (l + r) / 2;\n                int ct = pref[mid] - ((i == 0) ? 0 : pref[i - 1]);\n                if (ct > k && mid - i + 1 - ct > k) {\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                    spl = mid;\n                }\n            }\n            rt[i] = spl;\n        }\n       /* for (int i = 0; i < n; i++) {\n            cout << rt[i] << \" \";\n        }\n        cout << endl;*/\n        root[0] = idx;\n        nodes[idx++] = Node();\n        build(root[0], 0, n - 1);\n        for (int i = 0; i < n; i++) {\n            root[i + 1] = idx;\n            nodes[idx++] = Node();\n            update(root[i], root[i + 1], 0, n - 1, rt[i]);\n        }\n        vector<long long> ans;\n        for (int i = 0; i < queries.size(); i++) {\n            int l = queries[i][0], r = queries[i][1];\n            long long tot = queryVal(root[l], root[r + 1], 0, n - 1, 0, n - 1);\n            if (r < n - 1) {\n                long long sum = queryVal(root[l], root[r + 1], 0, n - 1, r + 1, n - 1);\n                long long ct = queryCt(root[l], root[r + 1], 0, n - 1, r + 1, n - 1);\n                tot += ct * r - sum;\n            }\n            tot -= sumi[r] - ((l == 0) ? 0 : sumi[l - 1]) - (r - l + 1);\n            ans.push_back(tot);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1723950461",
    "subm_id": "1359746554"
}