{
    "username": "simpcoder02",
    "submission": "using ll = long long int;\n\nclass Node{\npublic:\n\tint v = (1LL<<31)-1;\n\tNode(){}\n\tNode(int val){\n\t\tv = val;\n\t}\n\t\n\tvoid merge(const Node& l, const Node& r){ \n\t\tv = (l.v & r.v);\n\t}\n};\n\nclass Update{\npublic:\n\tint v = 0;\n\tUpdate(){};\n\tUpdate(int val){\n\t\tv = val; \n\t}\n\t\n\tvoid combine(const Update& otherUpdate, const int& tl, const int& tr){ \n\t\tv += otherUpdate.v; \n\t}\n\t\n\tvoid apply(Node& node, const int& tl, const int& tr) const{\n\t\tnode.v += (tr - tl + 1) * v;\n\t}\t\n};\n\ntemplate <typename node, typename update>\nclass SegTree{\npublic:\n\tint len;\n\tvector<node> t;\n\tnode identityElement;\n\tupdate identityTransformation; \n\t\n\tSegTree(){}\n\tSegTree(int l){\n\t\tlen = l;\n\t\tt.resize(4 * len);\n\t\tidentityElement = node();\n\t\tidentityTransformation = update();\n\t}\n\t\n\ttemplate<typename T>\n\tvoid build(const T& a, int v, int tl, int tr){\n\t\tif(tl == tr){\n\t\t\tt[v] = a[tl];\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr)/2;\n\t\tbuild(a, 2*v, tl, tm);\n\t\tbuild(a, 2*v+1, tm+1, tr);\n\t\tt[v].merge(t[2*v], t[2*v+1]);\n\t}\n\t\n\tnode query(int v, int tl, int tr, int l, int r){\n\t\tif(tl > r || tr < l) return identityElement;\n\t\tif(l <= tl && tr <= r) return t[v];\n\t\tint tm = (tl + tr)/2;\n\t\tnode leftAns = query(2*v, tl, tm, l, r);\n\t\tnode rightAns = query(2*v+1, tm+1, tr, l, r);\n\t\tnode ans;\n\t\tans.merge(leftAns, rightAns);\n\t\treturn ans;\n\t}\n\t\n\ttemplate<typename T>\n\tvoid build(const T& a){\n\t\tbuild(a, 1, 0, len-1);\n\t}\n\t\n\tnode query(int l, int r){\n\t\treturn query(1, 0, len-1, l, r);\n\t}\n};\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        int n = nums.size();\n        ll ans = 0;\n        SegTree<Node, Update> segTree(n);\n        segTree.build(nums);\n        for(int i = 0; i < n; i ++) {\n            int low = i, high = n - 1, idx1 = -1;\n            while(low <= high) {\n                int mid = low + (high - low)/2;\n                int curr = segTree.query(i, mid).v;\n                if(curr < k) high = mid - 1;\n                else {\n                    idx1 = mid;\n                    low = mid + 1;\n                }\n            }\n            low = i, high = n - 1;\n            int idx2 = -1;\n            while(low <= high) {\n                int mid = low + (high - low)/2;\n                int curr = segTree.query(i, mid).v;\n                if(curr < (k + 1)) high = mid - 1;\n                else {\n                    idx2 = mid;\n                    low = mid + 1;\n                }\n            }\n            if(idx1 == -1) continue;\n            int curr1 = segTree.query(i, idx1).v;\n            if(curr1 > k) continue;\n            if(idx2 == -1) idx2 = i - 1;\n            // cout << idx2 << \" \" << idx1 << endl;\n            ans += (idx1 - idx2);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720280143",
    "subm_id": "1311778480"
}