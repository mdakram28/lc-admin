{
    "username": "jalagara",
    "submission": "class Solution {\n    fun bfs(graph: List<List<Int>>, start: Int, target1: Int, target2: Int, totalNodes: Int): Int {\n        val queue: Queue<Int> = LinkedList()\n        val visited = BooleanArray(totalNodes + 4)\n        queue.add(start)\n        visited[start] = true\n\n        while (queue.isNotEmpty()) {\n            val current = queue.poll()\n            for (neighbor in graph[current]) {\n                if (!visited[neighbor]) {\n                    queue.add(neighbor)\n                    visited[neighbor] = true\n                }\n            }\n        }\n        return if (visited[target1] || visited[target2]) 1 else 0\n    }\n\n    fun canReachCorner(X: Int, Y: Int, circles: Array<IntArray>): Boolean {\n        val circleList = circles.map { intArrayOf(it[0], it[1], it[2]) }\n        val graph = MutableList(circles.size + 4) { mutableListOf<Int>() }\n\n        val numCircles = circles.size\n\n        for (i in 0 until numCircles) {\n            if (circleList[i][0] <= circleList[i][2]) {\n                graph[numCircles].add(i)\n                graph[i].add(numCircles)\n            }\n            if (X - circleList[i][0] <= circleList[i][2]) {\n                graph[numCircles + 2].add(i)\n                graph[i].add(numCircles + 2)\n            }\n            if (circleList[i][1] <= circleList[i][2]) {\n                graph[numCircles + 1].add(i)\n                graph[i].add(numCircles + 1)\n            }\n            if (Y - circleList[i][1] <= circleList[i][2]) {\n                graph[numCircles + 3].add(i)\n                graph[i].add(numCircles + 3)\n            }\n            for (j in i + 1 until numCircles) {\n                val distance = Math.sqrt(Math.pow(circleList[i][0] - circleList[j][0].toDouble(), 2.0) +\n                        Math.pow(circleList[i][1] - circleList[j][1].toDouble(), 2.0))\n                val radiusSum = circleList[i][2] + circleList[j][2]\n                if (radiusSum >= distance) {\n                    graph[i].add(j)\n                    graph[j].add(i)\n                }\n            }\n        }\n\n        var isBlocked = 0\n        isBlocked = maxOf(isBlocked, bfs(graph, numCircles, numCircles + 1, numCircles + 2, numCircles + 4))\n        isBlocked = maxOf(isBlocked, bfs(graph, numCircles + 3, numCircles + 2, numCircles + 1, numCircles + 4))\n\n        return isBlocked == 0\n    }\n}\n",
    "submit_ts": "1722138260",
    "subm_id": "1335786209"
}