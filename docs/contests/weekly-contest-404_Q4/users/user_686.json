{
    "username": "June24",
    "submission": "from collections import defaultdict\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        \n        def bfs(graph, start):\n            \"\"\" Perform BFS and return the farthest node and its distance from the start node \"\"\"\n            visited = {start}\n            queue = deque([(start, 0)])\n            farthest_node, max_dist = start, 0\n\n            while queue:\n                node, dist = queue.popleft()\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, dist + 1))\n                        if dist + 1 > max_dist:\n                            farthest_node, max_dist = neighbor, dist + 1\n\n            return farthest_node, max_dist\n\n        def find_tree_diameter(graph):\n            \"\"\" Find the diameter of the tree using two BFS \"\"\"\n            if not graph:\n                return 0\n\n            start = list(graph.keys())[0]\n            farthest_node, _ = bfs(graph, start)\n            opposite_node, diameter = bfs(graph, farthest_node)\n\n            return diameter\n\n        def build_graph(edge_list):\n            graph = defaultdict(list)\n            for u, v in edge_list:\n                graph[u].append(v)\n                graph[v].append(u)\n            return graph\n\n        graph1 = build_graph(edges1)\n        graph2 = build_graph(edges2)\n\n        diameter1 = find_tree_diameter(graph1)\n        diameter2 = find_tree_diameter(graph2)\n\n        radius1 = math.ceil(diameter1 / 2)\n        radius2 = math.ceil(diameter2 / 2)\n\n        new_diameter = max(diameter1, diameter2, radius1 + radius2 + 1)\n\n        return new_diameter\n#         import math\n\n#         def bfs(graph, start):\n#             \"\"\" Perform BFS and return the farthest node and its distance from the start node \"\"\"\n#             visited = {start}\n#             queue = deque([(start, 0)])\n#             farthest_node, max_dist = start, 0\n\n#             while queue:\n#                 node, dist = queue.popleft()\n#                 for neighbor in graph[node]:\n#                     if neighbor not in visited:\n#                         visited.add(neighbor)\n#                         queue.append((neighbor, dist + 1))\n#                         if dist + 1 > max_dist:\n#                             farthest_node, max_dist = neighbor, dist + 1\n\n#             return farthest_node, max_dist\n\n#         def find_tree_diameter_and_center(graph):\n#             # Step 1: Find the longest path in the tree\n#             start = list(graph.keys())[0]\n#             farthest_node, _ = bfs(graph, start)\n#             opposite_node, diameter = bfs(graph, farthest_node)\n\n#             # Step 2: Find the center(s) of the tree\n#             path = []\n#             visited = set()\n#             queue = deque([(farthest_node, [farthest_node])])\n\n#             while queue:\n#                 node, path_so_far = queue.popleft()\n#                 if node == opposite_node:\n#                     path = path_so_far\n#                     break\n#                 for neighbor in graph[node]:\n#                     if neighbor not in visited:\n#                         visited.add(neighbor)\n#                         queue.append((neighbor, path_so_far + [neighbor]))\n\n#             n = len(path)\n#             if n % 2 == 1:\n#                 # If the path length is odd, return the middle node\n#                 center = [path[n // 2]]\n#             else:\n#                 # If the path length is even, return the two middle nodes\n#                 center = [path[n // 2 - 1], path[n // 2]]\n\n#             return diameter, center\n#         graph = defaultdict(list)\n#         if not edges1:\n#             minimized_length1 = 0\n#         else:\n#             for u, v in edges1:\n#                 graph[u].append(v)\n#                 graph[v].append(u)\n\n#             # Find the diameter and center(s) of the tree\n#             diameter, center = find_tree_diameter_and_center(graph)\n\n#             # The minimized length is the ceiling of half the diameter\n#             minimized_length1 = math.ceil(diameter / 2)\n        \n#         if not edges2:\n#             minimized_length2 = 0\n#         else:\n#             for u, v in edges2:\n#                 graph[u].append(v)\n#                 graph[v].append(u)\n\n#             # Find the diameter and center(s) of the tree\n#             diameter, center = find_tree_diameter_and_center(graph)\n\n#             # The minimized length is the ceiling of half the diameter\n#             minimized_length2 = math.ceil(diameter / 2)\n        \n        \n#         return minimized_length1 + minimized_length2 + 1\n        ",
    "submit_ts": "1719718343",
    "subm_id": "1304414862"
}