{
    "username": "Edwards310",
    "submission": "// Start Of Anuj Bhati aka Edwards310's Template...\n#pragma GCC optimize(\"O2\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef pair<LL, LL> pll;\ntypedef pair<int, int> pii;\ntypedef pair<int, bool> pib;\ntypedef pair<char, bool> pcb;\ntypedef pair<string, int> psi;\ntypedef pair<char, int> pci;\ntypedef pair<int, char> pic;\ntypedef pair<string, string> pss;\ntypedef pair<char, char> pcc;\ntypedef pair<int, vi> pivi;\ntypedef vector<vi> vvi;\ntypedef vector<vb> vvb;\ntypedef vector<vc> vvc;\ntypedef vector<vd> vvd;\ntypedef vector<vs> vvs;\ntypedef vector<pii> vpii;\ntypedef vector<pib> vpib;\ntypedef vector<pcb> vpcb;\ntypedef vector<psi> vpsi;\ntypedef vector<pci> vpci;\ntypedef vector<pss> vpss;\ntypedef vector<LL> vll;\ntypedef vector<vll> vvll;\ndouble EPS = 1e-9;\nint INF = 1000000005;\nlong long INFF = 1000000000000000005LL;\ndouble PI = acos(-1);\n\n#define FOR(a, b, c) for (int a = b; a < c; a++)\n#define FOR1(a, b, c) for (int a = b; a <= c; ++a)\n#define Rep(i, n) FOR(i, 0, n)\n#define Rep1(i, n) FOR1(i, 1, n)\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ALL(v) v.begin(), v.end()\n#define SORT(v) sort(ALL(v))\n#define REVERSE(v) reverse(ALL(v))\n#define mxe(v) max_element(ALL(v))\n#define mie(v) min_element(ALL(v))\n#define bitsDedo(n) __builtin_popcount(n)\n#define umii unordered_map<int, int>\n#define umci unordered_map<char, int>\n#define umcc unordered_map<char, char>\n#define umsi unordered_map<string, int>\n#define umipii unordered_map<int, pii>\n#define umpiii unordered_map<pii, int>\n#define umivi unordered_map<int, vi>\n#define umili unordered_map<int, list<int>>\n#define umss unordered)map<string, string>\n#define usi unordered_set<int>\n#define usc unordered_set<char>\n#define sti stack<int>\n#define stc stack<char>\n#define sts stack<string>\n#define mii map<int, int>\n#define mpiii map<pii, int>\n#define mipii map<int, pii>\n#define mivi map<int, vi>\n#define mllll map<LL, LL>\n#define mci map<char, int>\n#define mcc map<char, char>\n#define mis map<int, string>\n#define msi map<string, int>\n#define mss map<string, string>\n#define qi queue<int>\ntemplate <class Y> void swap(Y& x, Y& y) {\n    x = x + y;\n    y = x - y;\n    x = x - y;\n}\ntemplate <typename X, typename Y> void add(X& x, Y& y) { return x + y; }\ntemplate <class T> class Stack {\npublic:\n    int top = -1;\n    Stack() {}\n};\n// end of Anuj Bhati's aka Edwards310's Template\nclass Solution {\npublic:\n    auto function(vvi &graph, int start, int target1, int target2, int list) {\n    qi q;\n    vi dekhliya(list + 4, 0);\n    q.push(start);\n    dekhliya[start] = 1;\n    \n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : graph[u]) {\n            if (!dekhliya[v]) {\n                q.push(v);\n                dekhliya[v] = 1;\n            }\n        }\n    }\n    return dekhliya[target1] or dekhliya[target2];\n}\n    \n    bool canReachCorner(int X, int Y, vvi& circles2) {\n        int n = circles2.size();\n         vector<pair<pair<int, int>, int>> circles(n);\n         vvi chart(n + 4);\n        int aaja = n;\n        //num_circles --> aaja\n        Rep(i, aaja) {\n            circles[i].fi.fi = circles2[i][0];\n            circles[i].fi.se = circles2[i][1];\n            circles[i].se = circles2[i][2];\n        }\n        \n         Rep(i, aaja) {\n            if (circles[i].fi.fi <= circles[i].se) {\n                chart[aaja].pb(i);\n                chart[i].pb(aaja);\n            }\n            if (X - circles[i].fi.fi <= circles[i].se) {\n                chart[aaja + 2].pb(i);\n                chart[i].pb(aaja + 2);\n            }\n            if (circles[i].fi.se <= circles[i].se) {\n                chart[aaja + 1].pb(i);\n                chart[i].pb(aaja + 1);\n            }\n            if (Y - circles[i].fi.se <= circles[i].se) {\n                chart[aaja + 3].pb(i);\n                chart[i].pb(aaja + 3);\n            }\n            for (int j = i + 1; j < aaja; ++j) {\n                double distance = sqrt(pow(circles[i].fi.fi - circles[j].fi.fi , 2) + pow(circles[i].fi.se - circles[j].fi.se , 2));\n                int radius = circles[i].se + circles[j].se;\n                if (radius >= distance) {\n                    chart[i].pb(j);\n                    chart[j].pb(i);\n                }\n            }\n        }\n        \n        int is_blocked = 0;\n        is_blocked = fmax(is_blocked, function(chart, aaja, aaja + 1, aaja + 2, aaja + 4)); \n        is_blocked = fmax(is_blocked, function(chart, aaja + 3, aaja + 2, aaja + 1, aaja + 4));\n        return (is_blocked) ? false: true;\n       \n        \n    }\n};",
    "submit_ts": "1722137120",
    "subm_id": "1335754759"
}