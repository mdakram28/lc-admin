{
    "username": "u77",
    "submission": "class Solution:\n    def minFlips(self, grid: List[List[int]]) -> int:\n        \n        R = len(grid)\n        C = len(grid[0]) if R else 0\n        \n        cc = collections.defaultdict(collections.Counter)\n        seen = set()\n        G = copy.deepcopy(grid)\n        for r in range(R):\n            for c in range(C):\n                if (r,c) in seen:\n                    continue\n                key = []\n                for nr,nc in ((r,c), (R-r-1,C-c-1), (R-r-1,c), (r,C-c-1)):\n                    if (nr,nc) in seen:\n                        continue\n                    key.append((nr,nc))\n                    seen.add((nr, nc))\n                K = tuple(sorted(key))\n                for nr,nc in K:\n                    cc[K][G[nr][nc]]+=1\n        \n        A = list(cc.values())\n        \n        @cache\n        def recurse(idx, score):\n            if idx == len(A):\n                return 0 if score==0 else math.inf\n            \n            curr = A[idx]\n            ones = curr[1]\n            zeros = curr[0]\n            \n            # costs to make everything zero\n            res = ones + recurse(idx+1, score)\n            # costs to make everything one\n            return min(res, zeros + recurse(idx+1, (score+zeros+ones)%4))\n        \n        return recurse(0,0)\n        ",
    "submit_ts": "1722697954",
    "subm_id": "1343164775"
}