{
    "username": "louisfghbvc",
    "submission": "class Solution {\npublic:\n    int numberOfPermutations(int n, vector<vector<int>>& requirements) {\n        // goal: find the number of permutation to satisfied the requirements\n        // idea:\n        // sort the requirements\n        // from left to right index, try to build the array (permutation)\n        \n        // constraints, cnt[i] <= 400\n        \n        // say dfs(len), should satisfied the require[len]\n        // if last position is n -> can reduce the length\n        // dfs(len, cnt) = dfs(len-1, cnt)\n        // if not largest in last\n        // [2,x,...0]\n        //         1\n        //  2 1    0 -> 2+1\n        //  2 0    1 -> 2\n        \n        // put other, will decrease by k\n        // dfs(len, cnt) = dfs(len-1, cnt-k)\n        \n        // dfs(3,2) -> dfs(2,2) +               2*dfs(2,1), 1\n        //             /     \\                  /      \\\n        //          dfs(1,2) dfs(1,1)       dfs(1,1)  dfs(1,0)\n        \n        vector<int> cnt(n+1, -1);\n        for (auto &r: requirements)\n            cnt[r[0]+1] = r[1];\n        \n        vector dp(n+2, vector<long>(405, -1));\n        int mod = 1e9+7;\n        \n        auto dfs = [&](auto &self, int len, int inv) -> long {\n            if (inv < 0) return 0;\n            if (len == 1) return (cnt[len] == 0 || cnt[len] == -1) && inv == 0; \n            \n            long &res = dp[len][inv];\n            if (res != -1) return res;\n            \n            res = 0;\n            if (inv == cnt[len] || cnt[len] == -1) {\n                // put largest\n                res = (res + self(self, len-1, inv)) % mod;\n                // put other\n                for (int i = len-2, j = 1; i >= 0; --i, j++) {\n                    res = (res + self(self, len-1, inv-j)) % mod;\n                }\n            }\n            \n            return res;\n        };\n        \n        return dfs(dfs, n, cnt[n]);\n    }\n};",
    "submit_ts": 1719069365.0
}