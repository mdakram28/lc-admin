{
    "username": "intelliCode",
    "submission": "class Solution:\n    def minimumDistance(self, P: List[List[int]]) -> int:\n        lP = len(P)\n        xSum,ySum = sum(x for x,_ in P),sum(y for _,y in P)\n        cen = (xSum/lP,ySum/lP)\n        \n        def dist(p1,p2):\n            (x,y),(X,Y) = p1,p2\n            return abs(x-X) + abs(y-Y)\n        \n        cntr = Counter([tuple(p) for p in P])\n        if min(cntr.values())>1:\n            return max(dist(p1,p2) for p1,p2 in combinations(cntr, 2)) if len(cntr)>1 else 0\n        \n        sortedP = sorted(cntr, key=lambda p: dist(p, cen))\n        \n        dictMax = defaultdict(set)\n        # listK = sorted(cntr)\n        for p1,p2 in combinations(sortedP[-20:], 2):\n            dictMax[dist(p1,p2)].add((p1,p2))\n        \n        sortedK = sorted(dictMax)\n        retV = sortedK.pop()\n        setPairs = dictMax[retV]\n        setP = reduce(lambda a,b: a&b, [set(p) for p in setPairs])\n        if not setP:        return retV\n        if all(cntr[p]>1 for p in setP):      return retV\n        setPRemove = set(p for p in setP if cntr[p]==1)\n        \n        while setPRemove and sortedK:\n            retV = sortedK.pop()\n            setPairs = dictMax[retV]\n            setP = reduce(lambda a,b: a&b, [set(p) for p in setPairs])\n            setPRemove &= setP\n\n        return retV\n            "
}