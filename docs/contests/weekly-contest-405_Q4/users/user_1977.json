{
    "username": "Jatin026",
    "submission": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <climits>\n\nusing namespace std;\nconst int ALPHABET_SIZE = 26;\n\nclass TrieNode {\npublic:\n    int children[ALPHABET_SIZE];\n    int index;\n    TrieNode() : index(-1) {\n        for (int i = 0; i < ALPHABET_SIZE; ++i) {\n            children[i] = -1;\n        }\n    }\n};\n\nclass Trie {\npublic:\n    vector<TrieNode> nodes;\n    Trie() {\n        nodes.emplace_back();\n    }\n    \n    void insert(const string& word, int index) {\n        int nodeIndex = 0; // Start from the root\n        for (char c : word) {\n            int childIndex = c - 'a';\n            if (nodes[nodeIndex].children[childIndex] == -1) {\n                nodes[nodeIndex].children[childIndex] = nodes.size();\n                nodes.emplace_back();\n            }\n            nodeIndex = nodes[nodeIndex].children[childIndex];\n        }\n        nodes[nodeIndex].index = index;\n    }\n\n    vector<int> search(const string& target, int start) {\n        vector<int> indices;\n        int nodeIndex = 0; // Start from the root\n        for (int i = start; i < target.size(); ++i) {\n            int childIndex = target[i] - 'a';\n            if (nodes[nodeIndex].children[childIndex] == -1) break;\n            nodeIndex = nodes[nodeIndex].children[childIndex];\n            if (nodes[nodeIndex].index != -1) {\n                indices.push_back(nodes[nodeIndex].index);\n            }\n        }\n        return indices;\n    }\n};\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int n = target.size();\n        vector<int> dp(n + 1, INT_MAX);\n        dp[0] = 0; // No cost to construct an empty string\n        vector<string> new_words;\n        vector<int> new_costs;\n        map<string , int> mp;\n        for(int i = 0; i < words.size(); i++){\n            if(mp.count(words[i])) mp[words[i]] = min(mp[words[i]] , costs[i]); \n            else mp[words[i]] = costs[i];\n        }\n        for(auto [a , b] : mp){\n            new_words.push_back(a);\n            new_costs.push_back(b);\n        }\n        swap(new_words , words);\n        swap(new_costs , costs);\n        Trie trie;\n        for (int i = 0; i < words.size(); ++i) {\n            if(words[i].size() > n) continue;\n            trie.insert(words[i], i);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            if (dp[i] == INT_MAX) continue; // Skip if this position is not reachable\n\n            vector<int> indices = trie.search(target, i);\n            for (int index : indices) {\n                const string& word = words[index];\n                int cost = costs[index];\n                int wordLen = word.size();\n\n                if (i + wordLen <= n) {\n                    dp[i + wordLen] = min(dp[i + wordLen], dp[i] + cost);\n                }\n            }\n        }\n\n        return dp[n] == INT_MAX ? -1 : dp[n];\n    }\n};\n\n",
    "submit_ts": "1720323837",
    "subm_id": "1312385222"
}