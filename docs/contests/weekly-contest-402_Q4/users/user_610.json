{
    "username": "skynet_007",
    "submission": "#include <vector>\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n    /*SIEVE -->*/ vector<int> primes;void sieve(int n) { bool prime[n + 1]; memset(prime, true, sizeof(prime)); for (int p = 2; p * p <= n; p++) { if (prime[p] == true) { for (int i = p * p; i <= n; i += p) prime[i] = false; } } for (int p = 2; p <= n; p++) if (prime[p]) primes.push_back(p); }\n/*Palindrome -->*/bool isPalindrome(string s) {int i,j; for(i=0,j=s.length()-1;i<=j;i++,j--){ if(s[i]!=s[j]) { return 0; } } return 1; }\n/*IsSubsequence-->*/bool isSubSeq(string str1, string str2, int m, int n) { if (m == 0) return true; if (n == 0) return false; if (str1[m-1] == str2[n-1]) return isSubSeq(str1, str2, m-1, n-1); return isSubSeq(str1, str2, m, n-1); }\n/*Binary Search -->*/ int binarySearch(vector<int>& arr,int x) { int l = 0; int r= arr.size()-1; while (l <= r) { int m = l + (r - l) / 2; if (arr[m] == x) return m; if (arr[m] < x) l = m + 1; else r = m - 1; } return -1; }\n/*Custom Hash -->*/struct chash { static uint64_t splitmix64(uint64_t x) {x += 0x9e3779b97f4a7c15; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x >> 27)) * 0x94d049bb133111eb; return x ^ (x >> 31); } size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM); } };\n/*Check Prime -->*/ bool isPrime(int n) { if (n <= 1) return false; for (int i = 2; i * i <= n; i++) { if (n % i == 0) return false; } return true; }\n/*Check Square -->*/bool isPerfectSquare(int n) { int root = sqrt(n); return root * root == n; }\n/*Number of Divisors -->*/int countdivisors(int N){ int ans = 1; for (int p : primes) { if (p * p * p > N) break; int count = 1; while (N % p == 0) { N = N / p; count++; } ans = ans * count; } if (isPrime(N)) { ans = ans * 2; } else if (isPerfectSquare(N) && isPrime(sqrt(N))) { ans = ans * 3; } else if (N != 1) { ans = ans * 4; } return ans; }\n/*Binary Exponentiation -->*/ int power(int x, int y, int p) { int res = 1; while (y > 0) { if (y % 2 == 1) res = (res * x); y = y >> 1; x = (x * x); } return res % p; }\n\n/*Inverse Modulo of N numbers :-\nint n = 10, p = 1000000007;\nint inv[n + 1];\ninv[1] = 1;\nfor (int i = 2; i <= n; i ++) inv[i] = 1LL * (p - p / i) * inv[p % i] % p;*/\n\n/*Factorial of N Numbers :-\nvector<int> fact(n+1,1);\nfor(int i=2;i<=n;i++)fact[i] = (fact[i-1]*1LL*(i))%mod;\n*/int nxt() {int x;cin >> x;return x;}\n\nint mod = 998244353;\nint shipsSunk(int n, long long k, const vector<int>& durability) {\n    vector<long long> prefixSum(n + 1), suffixSum(n + 1);\n    \n    // Calculate prefix and suffix sums\n    for (int i = 1; i <= n; ++i) {\n        prefixSum[i] = prefixSum[i - 1] + durability[i - 1];\n        suffixSum[n - i] = suffixSum[n - i + 1] + durability[n - i];\n    }\n\n    int left = 0, right = 0;\n    int sunkShips = 0;\n\n    while (k > 0 && left < n && right < n) {\n        // Calculate how many times the Kraken will attack ships in the current range\n        long long attacksLeft = min(k, prefixSum[left]);\n        long long attacksRight = min(k - attacksLeft, suffixSum[right]);\n\n        // Update the prefix and suffix sums\n        prefixSum[left] -= attacksLeft;\n        suffixSum[right] -= attacksRight;\n\n        // Update the number of sunk ships\n        sunkShips += (attacksLeft + attacksRight);\n\n        // Update pointers\n        if (prefixSum[left] == 0) left++;\n        if (suffixSum[right] == 0) right++;\n        \n        // Update remaining attacks\n        k -= (attacksLeft + attacksRight);\n    }\n\n    return sunkShips;\n}\nint countGoodSubsegments(vector<int>& a, vector<int>& b, int k) {\n    int n = a.size();\n    int m = b.size();\n    int count = 0;\n\n    for (int len = k; len <= n; ++len) {\n        vector<int> subarray(a.begin(), a.begin() + len);\n        sort(subarray.begin(), subarray.end());\n\n        int matches = 0;\n        for (int i = 0; i < m; ++i) {\n            if (binary_search(subarray.begin(), subarray.end(), b[i]))\n                matches++;\n        }\n\n        if (matches >= k)\n            count += n - len + 1;\n    }\n\n    return count;\n}\nbool hasOddParity(int num) {\n    int count = 0;\n    while (num) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count % 2 == 1;\n}\n    vector<int> tree;\n    vector<int> data;\n    int size;\n\n    int build(int start, int end, int node) {\n        if (start == end) {\n            tree[node] = isPeak(start) ? 1 : 0;\n            return tree[node];\n        }\n\n        int mid = (start + end) / 2;\n        tree[node] = build(start, mid, 2 * node + 1) + build(mid + 1, end, 2 * node + 2);\n        return tree[node];\n    }\n\n    int isPeak(int idx) {\n        if (idx <= 0 || idx >= size - 1) return 0;\n        return data[idx] > data[idx - 1] && data[idx] > data[idx + 1];\n    }\n\n    int queryRange(int start, int end, int l, int r, int node) {\n        if (r < start || end < l) return 0;\n        if (l <= start && end <= r) return tree[node];\n\n        int mid = (start + end) / 2;\n        return queryRange(start, mid, l, r, 2 * node + 1) + queryRange(mid + 1, end, l, r, 2 * node + 2);\n    }\n\n    void update(int start, int end, int idx, int node) {\n        if (start == end) {\n            tree[node] = isPeak(start) ? 1 : 0;\n            return;\n        }\n\n        int mid = (start + end) / 2;\n        if (idx <= mid) {\n            update(start, mid, idx, 2 * node + 1);\n        } else {\n            update(mid + 1, end, idx, 2 * node + 2);\n        }\n\n        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n    }\n\npublic:\n    SegmentTree(vector<int>& nums) : data(nums), size(nums.size()) {\n        tree.resize(4 * size, 0);\n        build(0, size - 1, 0);\n    }\n\n    int rangeQuery(int l, int r) {\n        return queryRange(0, size - 1, l, r, 0);\n    }\n\n    void updateIndex(int idx, int value) {\n        data[idx] = value;\n        if (idx > 0) update(0, size - 1, idx - 1, 0);\n        update(0, size - 1, idx, 0);\n        if (idx < size - 1) update(0, size - 1, idx + 1, 0);\n    }\n};\n\nclass Solution {\npublic:\n    /*SIEVE -->*/ vector<int> primes;void sieve(int n) { bool prime[n + 1]; memset(prime, true, sizeof(prime)); for (int p = 2; p * p <= n; p++) { if (prime[p] == true) { for (int i = p * p; i <= n; i += p) prime[i] = false; } } for (int p = 2; p <= n; p++) if (prime[p]) primes.push_back(p); }\n/*Palindrome -->*/bool isPalindrome(string s) {int i,j; for(i=0,j=s.length()-1;i<=j;i++,j--){ if(s[i]!=s[j]) { return 0; } } return 1; }\n/*IsSubsequence-->*/bool isSubSeq(string str1, string str2, int m, int n) { if (m == 0) return true; if (n == 0) return false; if (str1[m-1] == str2[n-1]) return isSubSeq(str1, str2, m-1, n-1); return isSubSeq(str1, str2, m, n-1); }\n/*Binary Search -->*/ int binarySearch(vector<int>& arr,int x) { int l = 0; int r= arr.size()-1; while (l <= r) { int m = l + (r - l) / 2; if (arr[m] == x) return m; if (arr[m] < x) l = m + 1; else r = m - 1; } return -1; }\n/*Custom Hash -->*/struct chash { static uint64_t splitmix64(uint64_t x) {x += 0x9e3779b97f4a7c15; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x >> 27)) * 0x94d049bb133111eb; return x ^ (x >> 31); } size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM); } };\n/*Check Prime -->*/ bool isPrime(int n) { if (n <= 1) return false; for (int i = 2; i * i <= n; i++) { if (n % i == 0) return false; } return true; }\n/*Check Square -->*/bool isPerfectSquare(int n) { int root = sqrt(n); return root * root == n; }\n/*Number of Divisors -->*/int countdivisors(int N){ int ans = 1; for (int p : primes) { if (p * p * p > N) break; int count = 1; while (N % p == 0) { N = N / p; count++; } ans = ans * count; } if (isPrime(N)) { ans = ans * 2; } else if (isPerfectSquare(N) && isPrime(sqrt(N))) { ans = ans * 3; } else if (N != 1) { ans = ans * 4; } return ans; }\n/*Binary Exponentiation -->*/ int power(int x, int y, int p) { int res = 1; while (y > 0) { if (y % 2 == 1) res = (res * x); y = y >> 1; x = (x * x); } return res % p; }\n\n/*Inverse Modulo of N numbers :-\nint n = 10, p = 1000000007;\nint inv[n + 1];\ninv[1] = 1;\nfor (int i = 2; i <= n; i ++) inv[i] = 1LL * (p - p / i) * inv[p % i] % p;*/\n\n/*Factorial of N Numbers :-\nvector<int> fact(n+1,1);\nfor(int i=2;i<=n;i++)fact[i] = (fact[i-1]*1LL*(i))%mod;\n*/int nxt() {int x;cin >> x;return x;}\n\nint mod = 998244353;\nint shipsSunk(int n, long long k, const vector<int>& durability) {\n    vector<long long> prefixSum(n + 1), suffixSum(n + 1);\n    \n    // Calculate prefix and suffix sums\n    for (int i = 1; i <= n; ++i) {\n        prefixSum[i] = prefixSum[i - 1] + durability[i - 1];\n        suffixSum[n - i] = suffixSum[n - i + 1] + durability[n - i];\n    }\n\n    int left = 0, right = 0;\n    int sunkShips = 0;\n\n    while (k > 0 && left < n && right < n) {\n        // Calculate how many times the Kraken will attack ships in the current range\n        long long attacksLeft = min(k, prefixSum[left]);\n        long long attacksRight = min(k - attacksLeft, suffixSum[right]);\n\n        // Update the prefix and suffix sums\n        prefixSum[left] -= attacksLeft;\n        suffixSum[right] -= attacksRight;\n\n        // Update the number of sunk ships\n        sunkShips += (attacksLeft + attacksRight);\n\n        // Update pointers\n        if (prefixSum[left] == 0) left++;\n        if (suffixSum[right] == 0) right++;\n        \n        // Update remaining attacks\n        k -= (attacksLeft + attacksRight);\n    }\n\n    return sunkShips;\n}\nint countGoodSubsegments(vector<int>& a, vector<int>& b, int k) {\n    int n = a.size();\n    int m = b.size();\n    int count = 0;\n\n    for (int len = k; len <= n; ++len) {\n        vector<int> subarray(a.begin(), a.begin() + len);\n        sort(subarray.begin(), subarray.end());\n\n        int matches = 0;\n        for (int i = 0; i < m; ++i) {\n            if (binary_search(subarray.begin(), subarray.end(), b[i]))\n                matches++;\n        }\n\n        if (matches >= k)\n            count += n - len + 1;\n    }\n\n    return count;\n}\nbool hasOddParity(int num) {\n    int count = 0;\n    while (num) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count % 2 == 1;\n}\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        SegmentTree segTree(nums);\n        vector<int> results;\n\n        for (const auto& query : queries) {\n            if (query[0] == 1) {\n                int left = query[1];\n                int right = query[2];\n                results.push_back(segTree.rangeQuery(left + 1, right - 1));\n            } else if (query[0] == 2) {\n                int index = query[1];\n                int value = query[2];\n                segTree.updateIndex(index, value);\n            }\n        }\n\n        return results;\n    }\n};\n",
    "submit_ts": 1718506934.0
}