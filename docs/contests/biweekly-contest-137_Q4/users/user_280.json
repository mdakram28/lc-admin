{
    "username": "Spryzen",
    "submission": "// want to do this in O(n^2 or n^3 time with backtraciking pruning)\n        // want to prune a couple of values, such as the \n        // if we find the 3 most maximum in each row\n        // and the maximum in each column\n        // then the value that has to be chosen has to always be one of these ones\n        // this is true since we can just simulate that one\n        // so sort \n        \n#define s second\n#define f first\n#define eb emplace\nclass Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& board) {\n        // solve this one and other one will work\n        // so at each row, we have one option to place it or not \n        // so go through each row and then \n        // on the first part, 100C3\n        // then find the 3 largest values for each one\n        // for this one want to do it in O(n^3) time\n        // with pruning\n        // so can use backtracking?\n        const int m=board.size();\n        const int n=board[0].size();\n\n\n        // same for equal ones then it's fine\n                set<pair<long long,pair<int,int>>> values;\n \n\n        for(int j=0;j<m;j++){\n            vector<pair<long long,pair<int,int>>> grid(n);\n            for(int k=0;k<board[j].size();k++){\n                grid[k]=make_pair(-board[j][k],make_pair(j,k));\n            }\n            sort(grid.begin(),grid.end());\n            for(int m=0;m<3;m++){\n                values.emplace(grid[m]);\n            }\n        }\n\n        // now we want to go through each thing\n        // 3000 values and then go through in n^2 time\n        // now keep going in the thing\n        // that fails though\n        // since it takes n^3 time\n\n\n        // same for equal ones then it's fine \n\n\n        for(int k=0;k<n;k++){\n            vector<pair<long long,pair<int,int>>> grid(m);\n\n            for(int j=0;j<m;j++){\n                grid[j]=make_pair(-board[j][k],make_pair(j,k));\n            }\n            sort(grid.begin(),grid.end());\n            for(int m=0;m<3;m++){\n                values.emplace(grid[m]);\n            }\n        }\n\n        // so has the maximum for both\n        // so add them to the set\n\n        // now have all of the values with no duplicates\n        // and sorted based on values\n        // can do n^3 time, but that fails \n        // so now what\n        // we can do n^2 time\n        // by g\n\n        vector<pair<long long,pair<int,int>>> vals;\n\n        for(auto a:values){\n            a.first*=-1;\n            vals.emplace_back(a);\n        }\n\n        const int N=vals.size();\n\n        // now want to go through the thing\n        long long ans=-1e15;\n\n\n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                // now want to go through the thing\n                if (vals[i].s.s==vals[j].s.s ||  vals[j].s.f==vals[i].s.f)\n                    continue;\n\n                for(int k=j+1;k<N;k++){ // should run only 9 times\n                    if (vals[j].s.f ^ vals[k].s.f && vals[j].s.s ^ vals[k].s.s && vals[i].s.f ^ vals[k].s.f && vals[i].s.s ^ vals[k].s.s){\n                        ans=max(ans,vals[i].f+vals[j].f+vals[k].f);\n                        break;\n                    }\n                }\n            }\n        }\n        return ans;\n\n\n\n\n\n    }\n};",
    "submit_ts": "1723908718",
    "subm_id": "1359164340"
}