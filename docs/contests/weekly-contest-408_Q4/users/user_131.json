{
    "username": "Roumak2008",
    "submission": "class Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        class UnionFind:\n            def __init__(self, n):\n                self.parent = list(range(n))\n                self.rank = [1] * n\n\n            def find(self, x):\n                if self.parent[x] != x:\n                    self.parent[x] = self.find(self.parent[x])\n                return self.parent[x]\n\n            def union(self, x, y):\n                rootX = self.find(x)\n                rootY = self.find(y)\n                if rootX != rootY:\n                    if self.rank[rootX] > self.rank[rootY]:\n                        self.parent[rootY] = rootX\n                    elif self.rank[rootX] < self.rank[rootY]:\n                        self.parent[rootX] = rootY\n                    else:\n                        self.parent[rootY] = rootX\n                        self.rank[rootX] += 1\n        import math\n\n        def circles_intersect(c1, c2):\n            (x1, y1, r1) = c1\n            (x2, y2, r2) = c2\n            dist_sq = (x1 - x2) ** 2 + (y1 - y2) ** 2\n            radius_sum_sq = (r1 + r2) ** 2\n            return dist_sq <= radius_sum_sq\n        def group_circles(circles):\n            n = len(circles)\n            uf = UnionFind(n)\n\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if circles_intersect(circles[i], circles[j]):\n                        uf.union(i, j)\n\n            groups = {}\n            for i in range(n):\n                root = uf.find(i)\n                if root not in groups:\n                    groups[root] = []\n                groups[root].append(circles[i])\n\n            return groups\n\n        def is_path_possible(X, Y, circles):\n            groups = group_circles(circles)\n            for group in groups.values():\n                min_x = group[0][0] - group[0][2]\n                max_x = group[0][0] + group[0][2]\n\n                min_y = group[0][1] - group[0][2]\n                max_y = group[0][1] + group[0][2]\n\n                for circle in group:\n                    min_x = min(min_x, circle[0] - circle[2])\n                    max_x = max(max_x, circle[0] + circle[2])\n\n                    min_y = min(min_y, circle[1] - circle[2])\n                    max_y = max(max_y, circle[1] + circle[2])\n                    \n                if min_y <= 0 and max_y >= Y:\n                    return False\n                elif max_x >= X and min_x <= 0:\n                    return False\n                elif max_y >= Y and max_x >= X and min_y <= Y and min_x <= X:\n                    return False\n                elif max_y >= 0 and max_x >= 0 and min_y <= 0 and min_x <= 0:\n                    return False\n            return True\n        return (is_path_possible(X, Y, circles))\n\n\n",
    "submit_ts": "1722138059",
    "subm_id": "1335781064"
}