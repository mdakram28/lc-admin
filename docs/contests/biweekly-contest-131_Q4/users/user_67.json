{
    "username": "981377660LMT",
    "submission": "\n// \u6709\u4e00\u6761\u65e0\u9650\u957f\u7684\u6570\u8f74\uff0c\u539f\u70b9\u5728 0 \u5904\uff0c\u6cbf\u7740 x \u8f74 \u6b63 \u65b9\u5411\u65e0\u9650\u5ef6\u4f38\u3002\n\n// \u7ed9\u4f60\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 queries \uff0c\u5b83\u5305\u542b\u4e24\u79cd\u64cd\u4f5c\uff1a\n\n// \u64cd\u4f5c\u7c7b\u578b 1 \uff1aqueries[i] = [1, x] \u3002\u5728\u8ddd\u79bb\u539f\u70b9 x \u5904\u5efa\u4e00\u4e2a\u969c\u788d\u7269\u3002\u6570\u636e\u4fdd\u8bc1\u5f53\u64cd\u4f5c\u6267\u884c\u7684\u65f6\u5019\uff0c\u4f4d\u7f6e x \u5904 \u6ca1\u6709 \u4efb\u4f55\u969c\u788d\u7269\u3002\n// \u64cd\u4f5c\u7c7b\u578b 2 \uff1aqueries[i] = [2, x, sz] \u3002\u5224\u65ad\u5728\u6570\u8f74\u8303\u56f4 [0, x] \u5185\u662f\u5426\u53ef\u4ee5\u653e\u7f6e\u4e00\u4e2a\u957f\u5ea6\u4e3a sz \u7684\u7269\u5757\uff0c\u8fd9\u4e2a\u7269\u5757\u9700\u8981 \u5b8c\u5168 \u653e\u7f6e\u5728\u8303\u56f4 [0, x] \u5185\u3002\u5982\u679c\u7269\u5757\u4e0e\u4efb\u4f55\u969c\u788d\u7269\u6709\u91cd\u5408\uff0c\u90a3\u4e48\u8fd9\u4e2a\u7269\u5757 \u4e0d\u80fd \u88ab\u653e\u7f6e\uff0c\u4f46\u7269\u5757\u53ef\u4ee5\u4e0e\u969c\u788d\u7269\u521a\u597d\u63a5\u89e6\u3002\u6ce8\u610f\uff0c\u4f60\u53ea\u662f\u8fdb\u884c\u67e5\u8be2\uff0c\u5e76 \u4e0d\u662f \u771f\u7684\u653e\u7f6e\u8fd9\u4e2a\u7269\u5757\u3002\u6bcf\u4e2a\u67e5\u8be2\u90fd\u662f\u76f8\u4e92\u72ec\u7acb\u7684\u3002\n// \u8bf7\u4f60\u8fd4\u56de\u4e00\u4e2a boolean \u6570\u7ec4results \uff0c\u5982\u679c\u7b2c i \u4e2a\u64cd\u4f5c\u7c7b\u578b 2 \u7684\u64cd\u4f5c\u4f60\u53ef\u4ee5\u653e\u7f6e\u7269\u5757\uff0c\u90a3\u4e48 results[i] \u4e3a true \uff0c\u5426\u5219\u4e3a false \u3002\nfunc getResults(queries [][]int) []bool {\n\tq := len(queries)\n\tres := make([]bool, 0, q)\n\n\tleaves := make([]E, 3*q+10)\n\tfor i := range leaves {\n\t\tleaves[i] = FromElement(1)\n\t}\n\n\tseg := NewSegmentTreeLongestOne(leaves)\n\tfor _, query := range queries {\n\t\tif query[0] == 1 {\n\t\t\tseg.Set(query[1], FromElement(0))\n\t\t} else {\n\t\t\tif query[1] < query[2] {\n\t\t\t\tres = append(res, false)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tres = append(res, seg.Query(1, query[1]).longestOne+1 >= query[2])\n\t\t}\n\t}\n\treturn res\n}\n\ntype V = int\n\ntype E = struct {\n\tsize                       int\n\tpreOne, sufOne, longestOne int // \u524d\u7f001\u7684\u4e2a\u6570, \u540e\u7f001\u7684\u4e2a\u6570, \u6700\u957f1\u7684\u4e2a\u6570\n\tleftV, rightV              V   // \u5de6\u7aef\u70b9\u503c, \u53f3\u7aef\u70b9\u503c\n\n\t// !TODO\n\tpairCount int // \u533a\u95f4\u5185\u6240\u6709\u6781\u957f\u8fde\u7eed1\u6bb5\u7684\u8d21\u732e\u548c sum(len_i*(len_i+1)/2)\n}\n\nfunc FromElement(v V) E {\n\tif v == 1 {\n\t\treturn E{\n\t\t\tsize: 1, preOne: 1, sufOne: 1, longestOne: 1, leftV: 1, rightV: 1,\n\t\t\t// !TODO\n\t\t\tpairCount: 1,\n\t\t}\n\t}\n\n\treturn E{\n\t\tsize: 1, leftV: v, rightV: v,\n\t\t// !TODO\n\t\tpairCount: 0,\n\t}\n}\n\nfunc (*SegmentTreeLongestOne) e() E { return E{} }\nfunc (*SegmentTreeLongestOne) op(a, b E) E {\n\tres := E{leftV: a.leftV, rightV: b.rightV, size: a.size + b.size}\n\tif a.rightV == b.leftV {\n\t\tres.preOne = a.preOne\n\t\tif a.preOne == a.size {\n\t\t\tres.preOne += b.preOne\n\t\t}\n\t\tres.sufOne = b.sufOne\n\t\tif b.sufOne == b.size {\n\t\t\tres.sufOne += a.sufOne\n\t\t}\n\t\tres.longestOne = max(max(a.longestOne, b.longestOne), a.sufOne+b.preOne)\n\n\t\t// !TODO\n\t\tn1, n2 := a.sufOne, b.preOne\n\t\tn3 := n1 + n2\n\t\tres.pairCount = a.pairCount + b.pairCount + n3*(n3+1)/2 - n1*(n1+1)/2 - n2*(n2+1)/2\n\t} else {\n\t\tres.preOne = a.preOne\n\t\tres.sufOne = b.sufOne\n\t\tres.longestOne = max(a.longestOne, b.longestOne)\n\n\t\t// !TODO\n\t\tres.pairCount = a.pairCount + b.pairCount\n\t}\n\treturn res\n}\n\n// \u7ef4\u62a4\u533a\u95f4\u6700\u957f1\u7684\u4e2a\u6570, \u533a\u95f4\u524d\u7f001\u7684\u4e2a\u6570\uff0c\u533a\u95f4\u540e\u7f001\u7684\u4e2a\u6570.\ntype SegmentTreeLongestOne struct {\n\tn, size int\n\tseg     []E\n}\n\nfunc NewSegmentTreeLongestOne(leaves []E) *SegmentTreeLongestOne {\n\tres := &SegmentTreeLongestOne{}\n\tn := len(leaves)\n\tsize := 1\n\tfor size < n {\n\t\tsize <<= 1\n\t}\n\tseg := make([]E, size<<1)\n\tfor i := range seg {\n\t\tseg[i] = res.e()\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tseg[i+size] = leaves[i]\n\t}\n\tfor i := size - 1; i > 0; i-- {\n\t\tseg[i] = res.op(seg[i<<1], seg[i<<1|1])\n\t}\n\tres.n = n\n\tres.size = size\n\tres.seg = seg\n\treturn res\n}\nfunc (st *SegmentTreeLongestOne) Get(index int) E {\n\tif index < 0 || index >= st.n {\n\t\treturn st.e()\n\t}\n\treturn st.seg[index+st.size]\n}\nfunc (st *SegmentTreeLongestOne) Set(index int, value E) {\n\tif index < 0 || index >= st.n {\n\t\treturn\n\t}\n\tindex += st.size\n\tst.seg[index] = value\n\tfor index >>= 1; index > 0; index >>= 1 {\n\t\tst.seg[index] = st.op(st.seg[index<<1], st.seg[index<<1|1])\n\t}\n}\nfunc (st *SegmentTreeLongestOne) Update(index int, value E) {\n\tif index < 0 || index >= st.n {\n\t\treturn\n\t}\n\tindex += st.size\n\tst.seg[index] = st.op(st.seg[index], value)\n\tfor index >>= 1; index > 0; index >>= 1 {\n\t\tst.seg[index] = st.op(st.seg[index<<1], st.seg[index<<1|1])\n\t}\n}\n\n// [start, end)\nfunc (st *SegmentTreeLongestOne) Query(start, end int) E {\n\tif start < 0 {\n\t\tstart = 0\n\t}\n\tif end > st.n {\n\t\tend = st.n\n\t}\n\tif start >= end {\n\t\treturn st.e()\n\t}\n\tleftRes, rightRes := st.e(), st.e()\n\tstart += st.size\n\tend += st.size\n\tfor start < end {\n\t\tif start&1 == 1 {\n\t\t\tleftRes = st.op(leftRes, st.seg[start])\n\t\t\tstart++\n\t\t}\n\t\tif end&1 == 1 {\n\t\t\tend--\n\t\t\trightRes = st.op(st.seg[end], rightRes)\n\t\t}\n\t\tstart >>= 1\n\t\tend >>= 1\n\t}\n\treturn st.op(leftRes, rightRes)\n}\nfunc (st *SegmentTreeLongestOne) QueryAll() E { return st.seg[1] }\n\n// \u4e8c\u5206\u67e5\u8be2\u6700\u5927\u7684 right \u4f7f\u5f97\u5207\u7247 [left:right] \u5185\u7684\u503c\u6ee1\u8db3 predicate\nfunc (st *SegmentTreeLongestOne) MaxRight(left int, predicate func(E) bool) int {\n\tif left == st.n {\n\t\treturn st.n\n\t}\n\tleft += st.size\n\tres := st.e()\n\tfor {\n\t\tfor left&1 == 0 {\n\t\t\tleft >>= 1\n\t\t}\n\t\tif !predicate(st.op(res, st.seg[left])) {\n\t\t\tfor left < st.size {\n\t\t\t\tleft <<= 1\n\t\t\t\tif tmp := st.op(res, st.seg[left]); predicate(tmp) {\n\t\t\t\t\tres = tmp\n\t\t\t\t\tleft++\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn left - st.size\n\t\t}\n\t\tres = st.op(res, st.seg[left])\n\t\tleft++\n\t\tif (left & -left) == left {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn st.n\n}\n\n// \u4e8c\u5206\u67e5\u8be2\u6700\u5c0f\u7684 left \u4f7f\u5f97\u5207\u7247 [left:right] \u5185\u7684\u503c\u6ee1\u8db3 predicate\nfunc (st *SegmentTreeLongestOne) MinLeft(right int, predicate func(E) bool) int {\n\tif right == 0 {\n\t\treturn 0\n\t}\n\tright += st.size\n\tres := st.e()\n\tfor {\n\t\tright--\n\t\tfor right > 1 && right&1 == 1 {\n\t\t\tright >>= 1\n\t\t}\n\t\tif !predicate(st.op(st.seg[right], res)) {\n\t\t\tfor right < st.size {\n\t\t\t\tright = right<<1 | 1\n\t\t\t\tif tmp := st.op(st.seg[right], res); predicate(tmp) {\n\t\t\t\t\tres = tmp\n\t\t\t\t\tright--\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn right + 1 - st.size\n\t\t}\n\t\tres = st.op(st.seg[right], res)\n\t\tif right&-right == right {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc (tree *SegmentTreeLongestOne) String() string {\n\tvar sb []string\n\tsb = append(sb, \"[\")\n\tfor i := 0; i < tree.n; i++ {\n\t\tif i != 0 {\n\t\t\tsb = append(sb, \", \")\n\t\t}\n\t\tsb = append(sb, fmt.Sprintf(\"%v\", tree.Get(i)))\n\t}\n\tsb = append(sb, \"]\")\n\treturn strings.Join(sb, \"\")\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n",
    "submit_ts": "1716649254",
    "subm_id": "534765689"
}