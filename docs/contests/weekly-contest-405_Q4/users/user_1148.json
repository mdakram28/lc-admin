{
    "username": "stupidRR",
    "submission": "class Solution {\nlong long binpow(long long base,long long ex,long long mod)\n{\n    long long ans=1ll;\n    while(ex>0)\n    {\n        if(ex%2==1)\n            ans=(ans*base)%mod;\n        base=(base*base)%mod;\n        ex=ex/2;\n    }\n    return ans;\n}\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int n=target.size();\n        vector<long long> hash1(n+1);\n        const int mod1=(1e9+7);\n        \n        vector<long long> power1(n+1);\n        power1[0]=1;\n        for(int i=1;i<=n;i++)\n            power1[i]=(power1[i-1]*31ll)%mod1;\n        \n        long long mul1=binpow(31ll,mod1-2,mod1);\n        vector<long long> inv1(n+1,1);\n        for(int i=1;i<=n;i++)\n            inv1[i]=(inv1[i-1]*mul1)%mod1;\n        \n        for(int i=1;i<=n;i++)\n        {\n            long long rep=target[i-1]-'a'+1;\n            hash1[i]=(rep*power1[i]+hash1[i-1])%mod1;\n        }\n        \n        unordered_map<long long,int> mp;\n        vector<int> distinct;\n        for(int j=0;j<words.size();j++)\n        {\n            auto ele=words[j];\n            int m=ele.size();\n            long long h1=0ll;\n            for(int i=1;i<=m;i++)\n            {\n                long long rep=ele[i-1]-'a'+1;\n                h1=(rep*power1[i]+h1)%mod1;\n            }\n            \n            distinct.push_back(m);\n            if(mp.find(h1)==mp.end())\n                mp[h1]=costs[j];\n            else\n                mp[h1]=std::min(mp[h1],costs[j]);\n        }\n        \n        sort(distinct.begin(),distinct.end());\n        distinct.erase(unique(distinct.begin(),distinct.end()),distinct.end());\n        \n        vector<long long> dp(n+1,1e12);\n        dp[0]=0ll;\n        for(int i=1;i<=n;i++)\n        {\n            for(auto sz : distinct)\n            {\n                if(sz>i)\n                    break;\n                \n                long long h1=(hash1[i]-hash1[i-sz]+mod1)%mod1;\n                h1=(h1*inv1[i-sz])%mod1;\n\n                if(mp.find(h1)!=mp.end())\n                    dp[i]=std::min(dp[i],dp[i-sz]+mp[h1]);\n            }\n        }\n        if(dp[n]>=1e9)\n            dp[n]=-1;\n        return dp[n];\n    }\n};",
    "submit_ts": "1720322354",
    "subm_id": "1312347651"
}