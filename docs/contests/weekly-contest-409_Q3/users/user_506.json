{
    "username": "harshbardolia",
    "submission": "class SGTree {\npublic:\n    int n;\n    vector<int> seg, lazy;\n\n    SGTree(vector<int>& a) {\n        n = (int) a.size();\n        seg.resize(4 * n + 1);\n        lazy.resize(4 * n + 1, -1);\n        Build(a);\n    }\n\n    int merge(int left, int right) {\n        return (left + right);\n    }\n\n    void build(int ind, int low, int high, vector<int>& a) {\n        if (low == high) {\n            seg[ind] = a[low];\n            return;\n        }\n\n        int mid = low + (high - low) / 2;\n        build(2 * ind + 1, low, mid, a);\n        build(2 * ind + 2, mid + 1, high, a);\n        seg[ind] = merge(seg[2 * ind + 1], seg[2 * ind + 2]);\n    }\n\n    void update(int ind, int low, int high, int l, int r, int val) {\n        if (lazy[ind] != -1) {\n            seg[ind] = (high - low + 1) * lazy[ind];\n            if (low != high) {\n                lazy[2 * ind + 1] = lazy[ind];\n                lazy[2 * ind + 2] = lazy[ind];\n            }\n            lazy[ind] = 0;\n        }\n\n        if (r < low || high < l)\n            return;\n\n        if (l <= low && high <= r) {\n            seg[ind] = (high - low + 1) * val;\n            if (low != high) {\n                lazy[2 * ind + 1] = val;\n                lazy[2 * ind + 2] = val;\n            }\n            return;\n        }\n\n        int mid = low + (high - low) / 2;\n        update(2 * ind + 1, low, mid, l, r, val);\n        update(2 * ind + 2, mid + 1, high, l, r, val);\n        seg[ind] = merge(seg[2 * ind + 1], seg[2 * ind + 2]);\n    }\n\n    int query(int ind, int low, int high, int l, int r) {\n        if (lazy[ind] != -1) {\n            seg[ind] = (high - low + 1) * lazy[ind];\n            if (low != high) {\n                lazy[2 * ind + 1] = lazy[ind];\n                lazy[2 * ind + 2] = lazy[ind];\n            }\n            lazy[ind] = 0;\n        }\n\n        if (r < low || high < l)\n            return 0;\n\n        if (l <= low && high <= r)\n            return seg[ind];\n\n        int mid = low + (high - low) / 2;\n        int left = query(2 * ind + 1, low, mid, l, r);\n        int right = query(2 * ind + 2, mid + 1, high, l, r);\n        return left + right;\n    }\n\n    int Query(int l, int r) {\n        return query(0, 0, n - 1, l, r);\n    }\n\n    void Update(int l, int r, int val) {\n        if (l > r) return;\n        update(0, 0, n - 1, l, r, val);\n    }\n\n    void Build(vector<int>& a) {\n        build(0, 0, n - 1, a);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int> a(n, 1);\n        a[n - 1] = 0;\n        SGTree tree(a);\n        vector<int> res;\n\n        for (auto q : queries) {\n            int u = q[0];\n            int v = q[1];\n\n            int l = u;\n            int r = v - 1;\n            int curSum = tree.Query(l, r);\n            \n            if (curSum == 0) {\n                res.push_back(res.back());\n                continue;\n            }\n\n            tree.Update(l + 1, r, 0);\n\n            int ans = tree.Query(0, n);\n            res.push_back(ans);\n        }\n\n        return res;\n    }\n    // 0 1 2 3 4 5 6 7\n};",
    "submit_ts": "1722741469",
    "subm_id": "1343745759"
}