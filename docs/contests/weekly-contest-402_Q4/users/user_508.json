{
    "username": "isheoran",
    "submission": "\nstruct BIT {\n    vector<int>tree;\n    int n;\n\n    BIT () {}\n\n    BIT(int n) {\n        this->n = n;\n        tree.resize(n);\n    }\n\n    int query(int r) {\n        int res = 0;\n        while(r>=0) {\n            res += tree[r];\n            r = (r&(r+1))-1;\n        }\n        return res;\n    }\n\n    void update(int i,int val) {\n        while(i<n) {\n            tree[i] += val;\n            i = (i|(i+1));\n        }\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        \n        BIT tr(n);\n        \n        auto f = [&](int i) {\n            if(i < 1 or i > n-2) return false;\n            else if(nums[i-1] < nums[i] and nums[i] > nums[i+1]) return true;\n            else return false;\n        };\n        \n        for(int i=1;i<n-1;i++) {\n            if(f(i)) tr.update(i,1);\n        }\n        \n        vector<int>ans;\n        \n        for(auto u:queries) {\n            if(u[0] == 1) {\n                if(u[2]-u[1] < 2) ans.push_back(0);\n                else ans.push_back(tr.query(u[2]-1)-tr.query(u[1]));\n            }\n            else {\n                if(f(u[1])) tr.update(u[1],-1);\n                if(f(u[1]-1)) tr.update(u[1]-1,-1);\n                if(f(u[1]+1)) tr.update(u[1]+1,-1);\n                \n                nums[u[1]] = u[2];\n                \n                if(f(u[1])) tr.update(u[1],1);\n                if(f(u[1]-1)) tr.update(u[1]-1,1);\n                if(f(u[1]+1)) tr.update(u[1]+1,1);\n            }\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": 1718507429.0
}