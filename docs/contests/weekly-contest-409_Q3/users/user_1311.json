{
    "username": "Sandeep_P",
    "submission": "class LazySegmentTree:\n    def __init__(self, data, default=0, func=max):\n        \"\"\"initialize the lazy segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n        self._lazy = [0] * (2 * _size)\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __len__(self):\n        return self._len\n\n    def _push(self, idx):\n        \"\"\"push query on idx to its children\"\"\"\n        # Let the children know of the queries\n        q, self._lazy[idx] = self._lazy[idx], 0\n\n        self._lazy[2 * idx] += q\n        self._lazy[2 * idx + 1] += q\n        self.data[2 * idx] += q\n        self.data[2 * idx + 1] += q\n\n    def _update(self, idx):\n        \"\"\"updates the node idx to know of all queries applied to it via its ancestors\"\"\"\n        for i in reversed(range(1, idx.bit_length())):\n            self._push(idx >> i)\n\n    def _build(self, idx):\n        \"\"\"make the changes to idx be known to its ancestors\"\"\"\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1]) + self._lazy[idx]\n            idx >>= 1\n\n    def add(self, start, stop, value):\n        \"\"\"lazily add value to [start, stop)\"\"\"\n        start = start_copy = start + self._size\n        stop = stop_copy = stop + self._size\n        while start < stop:\n            if start & 1:\n                self._lazy[start] += value\n                self.data[start] += value\n                start += 1\n            if stop & 1:\n                stop -= 1\n                self._lazy[stop] += value\n                self.data[stop] += value\n            start >>= 1\n            stop >>= 1\n\n        # Tell all nodes above of the updated area of the updates\n        self._build(start_copy)\n        self._build(stop_copy - 1)\n\n    def query(self, start, stop, default=0):\n        \"\"\"func of data[start, stop)\"\"\"\n        start += self._size\n        stop += self._size\n\n        # Apply all the lazily stored queries\n        self._update(start)\n        self._update(stop - 1)\n\n        res = default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        cur=[self[x] for x in range(len(self))]\n        return str(cur)\n    \n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        if isinstance(idx, slice):\n            start=idx.start\n            stop=idx.stop\n        else:\n            start=idx\n            stop=idx+1\n        return self.query(start,stop)\n\n    def __setitem__(self, idx, value):\n        if isinstance(idx, slice):\n            start=idx.start\n            stop=idx.stop\n        else:\n            start=idx\n            stop=idx+1\n        self.add(start,stop,value)\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        backwards = list(range(n))\n        forwards = backwards[::-1]\n        forwards = LazySegmentTree(forwards)\n        backwards = LazySegmentTree(backwards)\n        ans = []\n        c = n - 1\n        for u, v in queries:\n            cur = forwards.query(v, v + 1) + 1 + backwards.query(u, u + 1)\n            if cur < c:\n                forwards.add(0, u + 1, cur - c)\n                backwards.add(v, n, cur - c)\n                c = cur\n            ans.append(c)\n        return ans",
    "submit_ts": "1722743228",
    "subm_id": "1343787267"
}