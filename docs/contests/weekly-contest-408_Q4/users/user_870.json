{
    "username": "ManasSingh7",
    "submission": "class Solution {\npublic:\n    bool solve(int Cena, int Orton, vector<vector<int>>& Rings) {\n        int NumberOfCircles = Rings.size();\n        vector<vector<int>> WWEGraph(NumberOfCircles + 4);\n\n        for (int StoneCold = 0; StoneCold < NumberOfCircles; StoneCold++) {\n            if (Rings[StoneCold][0] <= Rings[StoneCold][2]) {\n                WWEGraph[NumberOfCircles].push_back(StoneCold);\n                      WWEGraph[StoneCold].push_back(NumberOfCircles);\n            }\n            if (Cena -         Rings[StoneCold][0] <= Rings[StoneCold][2]) {\n                WWEGraph    [NumberOfCircles + 2].push_back(StoneCold);\n                WWEGraph[StoneCold].push_back(NumberOfCircles + 2);\n            }\n            if (Rings[StoneCold][1] <= Rings[StoneCold][2]) {\n                WWEGraph[NumberOfCircles + 1].push_back(StoneCold);\n                WWEGraph[StoneCold].push_back(NumberOfCircles + 1);\n            }\n            if (Orton - Rings[StoneCold][1] <= Rings[StoneCold][2]) {\n                WWEGraph[NumberOfCircles + 3].push_back(StoneCold);\n                WWEGraph[StoneCold].push_back(NumberOfCircles + 3);\n            }\n            for (int TheRock = StoneCold + 1; TheRock < NumberOfCircles; ++TheRock) {\n                double HoganDist = sqrt(pow(Rings[StoneCold][0] - Rings[TheRock][0], 2) +\n                                        pow(Rings[StoneCold][1] - Rings[TheRock][1], 2));\n                int UndertakerRadSum = Rings[StoneCold][2] + Rings[TheRock][2];\n                if (    UndertakerRadSum >= HoganDist) {\n                    WWEGraph[StoneCold].push_back      (TheRock);\n                    WWEGraph[TheRock].push_back(StoneCold);\n                }\n            }\n        }\n\n        int EdgeBlocked = 0;\n\n        EdgeBlocked = max(EdgeBlocked, manas(WWEGraph, NumberOfCircles, NumberOfCircles + 1, NumberOfCircles + 2, NumberOfCircles + 4));\n        EdgeBlocked = max(EdgeBlocked, manas(WWEGraph, NumberOfCircles + 3, NumberOfCircles + 2, NumberOfCircles + 1, NumberOfCircles + 4)); \n\n        return EdgeBlocked == 0;\n    }\n\n    int manas(vector<vector<int>>& WWEGraph, int Starting, int TargetNode1, int TargetNode2, int TotalNodes) {\n        queue<int> dhoni;\n        vector<bool> Visited(TotalNodes + 4, false);\n\n        dhoni.push(Starting);\n        Visited[Starting] = true;\n\n        while (!dhoni.empty()) {\n            int CurrentNode = dhoni.front();\n            dhoni.pop();\n\n            for (int an : WWEGraph[CurrentNode]) {\n                if (!Visited[an]) {\n                    dhoni.push(an);\n                    Visited[an] = true;\n                }\n            }\n        }\n\n        return (Visited[TargetNode1] || Visited[TargetNode2]) ? 1 : 0;\n    }\n\n    bool canReachCorner(int Cena, int Orton, vector<vector<int>>& bingo) {\n        bool sachin=solve(Cena, Orton, bingo);\n        int counter=0;\n        int aman=1;\n        int d=1;\n        return sachin;\n    }\n};\n",
    "submit_ts": "1722139156",
    "subm_id": "1335809444"
}