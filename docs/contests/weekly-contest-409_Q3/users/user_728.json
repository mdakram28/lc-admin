{
    "username": "wadhwaaman1013",
    "submission": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass SegmentTree {\npublic:\n  int left_most, right_most;\n  SegmentTree *left_child, *right_child;\n  int res;\n\n  SegmentTree(int left, int right, vector<int> &v) {\n    left_most = left;\n    right_most = right;\n    if (left_most == right_most) {\n      res = v[left];\n      left_child = nullptr;\n      right_child = nullptr;\n    } else {\n      int mid = (left + right) / 2;\n      left_child = new SegmentTree(left_most, mid, v);\n      right_child = new SegmentTree(mid + 1, right_most, v);\n      recalc();\n    }\n  }\n\n  void recalc() {\n    if (left_most == right_most)\n      return;\n    res = left_child->res + right_child->res;\n  }\n\n  void point_update(int index, int new_val) {\n    if (left_most == right_most) {\n      res = new_val;\n      return;\n    }\n\n    if (index <= left_child->right_most)\n      left_child->point_update(index, new_val);\n    else\n      right_child->point_update(index, new_val);\n    recalc();\n  }\n\n  int range(int l, int r) {\n    if (l > right_most || r < left_most)\n      return 0;\n    if (l <= left_most && r >= right_most)\n      return res;\n    return left_child->range(l, r) +  right_child->range(l, r);\n  }\n\n  ~SegmentTree() {\n    if (left_child != nullptr)\n      delete left_child;\n    if (right_child != nullptr)\n      delete right_child;\n  }\n};\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int> dists(n - 1, 0);\n        SegmentTree* s = new SegmentTree(0, n - 2, dists);\n        int cur_dist = n - 1;\n        unordered_map<int, int> skip;\n        vector<int> res;\n\n        for (auto &query : queries) {\n            if (cur_dist == 1) {\n                res.push_back(cur_dist);\n                continue;\n            }\n                \n\n            int curskip = 0;\n            int p = query[0] + 1;\n            \n            if (query[0] + 1 <= query[1] - 1)\n                curskip = s->range(query[0] + 1, query[1] - 1);\n\n            if(skip.find(query[0]) != skip.end())\n                p = skip[query[0]];\n            \n            \n            skip[query[0]] = std::max(skip[query[0]], query[1]);\n            if (curskip < (query[1] - query[0] - 1)) {\n                cur_dist -= ((query[1] - query[0] - 1) - curskip);\n            }\n            res.push_back(cur_dist);\n\n            while (p < query[1]) {\n                s->point_update(p, 1);\n                if (skip.find(p) != skip.end())\n                    p = skip[p];\n                else\n                    p++;\n            }\n        }\n\n        return res;\n    }\n};\n\n\n// #include <bits/stdc++.h>\n\n// using namespace std;\n\n// class SegmentTree {\n// public:\n//   int left_most, right_most;\n//   SegmentTree *left_child, *right_child;\n//   int res;\n\n//   SegmentTree(int left, int right, vector<int> &v) {\n//     left_most = left;\n//     right_most = right;\n//     if (left_most == right_most) {\n//       res = v[left];\n//       left_child = nullptr;\n//       right_child = nullptr;\n//     } else {\n//       int mid = (left + right) / 2;\n//       left_child = new SegmentTree(left_most, mid, v);\n//       right_child = new SegmentTree(mid + 1, right_most, v);\n//       recalc();\n//     }\n//   }\n\n//   void recalc() {\n//     if (left_most == right_most)\n//       return;\n//     res = min(left_child->res, right_child->res);\n//   }\n\n//   void point_update(int index, int new_val) {\n//     if (left_most == right_most) {\n//       res = new_val;\n//       return;\n//     }\n\n//     if (index <= left_child->right_most)\n//       left_child->point_update(index, new_val);\n//     else\n//       right_child->point_update(index, new_val);\n//     recalc();\n//   }\n\n//   int range(int l, int r) {\n//     if (l > right_most || r < left_most)\n//       return INT_MAX;\n//     if (l <= left_most && r >= right_most)\n//       return res;\n//     return min(left_child->range(l, r), right_child->range(l, r));\n//   }\n\n//   ~SegmentTree() {\n//     if (left_child != nullptr)\n//       delete left_child;\n//     if (right_child != nullptr)\n//       delete right_child;\n//   }\n// };\n\n// class Solution {\n// public:\n//     vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n//         vector<int> dists (n - 1, 0);\n//         SegmentTree s = SegmentTree(0, n - 1, dists);\n//         int cur_dist = n - 1;\n//         unordered_map<int, int> skip;\n//         vector<int> res;\n\n//         for (auto &query : queries) {\n//             int curskip = s.range(query[0] + 1, query[1] - 1);\n\n//             if (skip.find(query[0]) != skip.end()) {\n//                 skip[query[0]] = std::max(skip[query[0]], query[1]);\n//             }\n//             else {\n//                 skip[query[0]] = query[1];\n//             }\n\n//             if (curskip < (query[1] - query[0] + 1)) {\n//                 cur_dist -= ((query[1] - query[0] - 1) - curskip);\n//             }\n//             res.push_back(cur_dist);\n\n//             int p = query[0] + 1;\n\n//             while (p < query[1]) {\n//                 s.point_update(p, 1);\n//                 if (skip.find(p) != skip.end())\n//                     p = skip[p];\n//                 else\n//                     p++;\n//             }\n//         }\n//         return res;\n//     }\n// };",
    "submit_ts": "1722742853",
    "subm_id": "1343778603"
}