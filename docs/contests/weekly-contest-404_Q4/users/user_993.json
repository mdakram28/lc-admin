{
    "username": "mnm373",
    "submission": "// calculating tree diameter with topological sort (complex)\nnamespace my {\nclass TreeDiameterTopo {\n   public:\n    TreeDiameterTopo(int n, vector<vector<int>> edges) {\n        degrees.resize(n);\n        ad_list.resize(n);\n\n        for (auto item : edges) {\n            int x = item[0], y = item[1];\n            ad_list[x].insert(y);\n            ad_list[y].insert(x);\n\n            degrees[x]++;\n            degrees[y]++;\n        }\n    }\n\n    int run(bool root) {\n        if (degrees.size() == 1) {\n            if (root) {\n                return 0;\n            } else {\n                return 0;\n            }\n        }\n\n        vector<int> zeros;\n        zeros.reserve(degrees.size());\n\n        for (int i = 0; i < degrees.size(); ++i) {\n            if (degrees[i] == 1) {\n                zeros.push_back(i);\n            }\n        }\n\n        int cnt = 0;\n\n        for (; !zeros.empty();) {\n            vector<int> tmp;\n            tmp.reserve(zeros.size());\n\n            for (int cur : zeros) {\n                for (int item : ad_list[cur]) {\n                    degrees[item]--;\n                    ad_list[item].erase(cur);\n                    if (degrees[item] == 1) {\n                        tmp.push_back(item);\n                    }\n                }\n            }\n\n            if (tmp.empty() && zeros.size() == 2) {\n                cnt++;\n                zeros = tmp;\n                break;\n            } else if (tmp.empty() && zeros.size() == 1) {\n                zeros = tmp;\n                break;\n            }\n\n            zeros = tmp;\n            cnt += 2;\n        }\n\n        if (root) {\n            return zeros[0];\n        }\n\n        return cnt;\n    }\n\n   private:\n    vector<int> degrees;\n    vector<set<int>> ad_list;\n};\n}  // namespace my\n\nclass Solution {\n   public:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1,\n                                  vector<vector<int>>& edges2) {\n        int n1 = edges1.size() + 1, n2 = edges2.size() + 1;\n\n        my::TreeDiameterTopo t1(n1, edges1), t2(n2, edges2);\n\n        int root1 = t1.run(true), root2 = t2.run(true);\n\n        vector<vector<int>> nedges;\n        nedges.reserve(edges1.size() + edges2.size() + 1);\n\n        for (auto item : edges1) {\n            nedges.push_back(item);\n        }\n        for (auto item : edges2) {\n            nedges.push_back(vector<int>{item[0] + n1, item[1] + n1});\n        }\n        nedges.push_back(vector<int>{root1, root2 + n1});\n\n        my::TreeDiameterTopo tn(n1 + n2, nedges);\n\n        return tn.run(false);\n    }\n};\n\n",
    "submit_ts": 1719717526.0
}