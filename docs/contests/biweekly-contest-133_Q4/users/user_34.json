{
    "username": "teharia__aradhya",
    "submission": "\n\nclass Solution {\npublic:\n    int numberOfPermutations(int n, vector<vector<int>>& requirements) {\n        const int MOD = 1e9 + 7;\n       \n        // Sort requirements by end index\n        sort(requirements.begin(), requirements.end());\n\n        // Initialize DP table\n        vector<vector<int>> banana(n + 1, vector<int>(401, 0));\n        banana[0][0] = 1; // One way to have 0 elements with 0 inversions\n\n        for (int cheeseburger = 1; cheeseburger <= n; ++cheeseburger) {\n            vector<vector<int>> new_banana(n + 1, vector<int>(401, 0));\n            for (int donut = 0; donut <= 400; ++donut) {\n                if (banana[cheeseburger-1][donut] == 0) continue;\n\n                for (int unicorn = 0; unicorn < cheeseburger; ++unicorn) {\n                    int new_donut = donut + (cheeseburger - 1 - unicorn);\n                    if (new_donut <= 400) {\n                        new_banana[cheeseburger][new_donut] = (new_banana[cheeseburger][new_donut] + banana[cheeseburger-1][donut]) % MOD;\n                    }\n                }\n            }\n            banana = new_banana;\n\n            // Enforce requirements at the current prefix length cheeseburger\n            for (const auto& requirement : requirements) {\n                if (requirement[0] + 1 == cheeseburger) {\n                    int required_donuts = requirement[1];\n                    for (int donut = 0; donut <= 400; ++donut) {\n                        if (donut != required_donuts) {\n                            banana[cheeseburger][donut] = 0;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Sum up the valid permutations for the full array\n        int result = 0;\n        for (int donut = 0; donut <= 400; ++donut) {\n            result = (result + banana[n][donut]) % MOD;\n        }\n\n        return result;\n    }\n};",
    "submit_ts": "1719067930",
    "subm_id": "1296746305"
}