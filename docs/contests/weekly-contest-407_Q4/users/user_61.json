{
    "username": "watashi",
    "submission": "class Solution {\n  template<typename T>\n  struct RMQ {\n    int n;\n    vector<T> e;\n    vector<vector<int> > rmq;\n\n    static const int INT_BIT = sizeof(4) * CHAR_BIT;\n    static inline int LG2(int i) { return INT_BIT - 1 - __builtin_clz(i); }\n    static inline int BIN(int i) { return 1 << i; }\n\n    int cmp(int l, int r) const {\n      return e[l] <= e[r] ? l : r;\n    }\n\n    void init(int n, const T e[]) {\n      this->n = n;\n      vector<T>(e, e + n).swap(this->e);\n\n      int m = 1;\n      while (BIN(m) <= n) {\n        ++m;\n      }\n      vector<vector<int> >(m, vector<int>(n)).swap(rmq);\n\n      for (int i = 0; i < n; ++i) {\n        rmq[0][i] = i;\n      }\n      for (int i = 0; BIN(i + 1) <= n; ++i) {\n        for (int j = 0; j + BIN(i + 1) <= n; ++j) {\n          rmq[i + 1][j] = cmp(rmq[i][j], rmq[i][j + BIN(i)]);\n        }\n      }\n    }\n\n    int index(int l, int r) const {\n      int b = LG2(r - l);\n      return cmp(rmq[b][l], rmq[b][r - (1 << b)]);\n    }\n\n    T value(int l, int r) const {\n      return e[index(l, r)];\n    }\n  };\n\npublic:\n  long long minimumOperations(vector<int>& nums, vector<int>& target) {\n    const int N = nums.size();\n    vector<int> d;\n    for (int i = 0; i < N; ++i) {\n      d.push_back(target[i] - nums[i]);\n    }\n\n    queue<tuple<int, int, int>> q;\n    for (int i = 0; i < N; ) {\n      if (d[i] == 0) {\n        ++i;\n        continue;\n      }\n      int start = i;\n      if (d[i] > 0) {\n        while (i < N && d[i] > 0) {\n          ++i;\n        }\n      }\n      else {\n        while (i < N && d[i] < 0) {\n          d[i] = -d[i];\n          ++i;\n        }\n      }\n      q.emplace(start, i, 0);\n    }\n    \n    RMQ<int> rmq;\n    rmq.init(N, d.data());\n\n    long long ret = 0;\n    while (!q.empty()) {\n      int start, end, from;\n      tie(start, end, from) = q.front();\n      q.pop();\n      if (start == end) {\n        continue;\n      }\n      int mid = rmq.index(start, end);\n      int to = d[mid];\n      ret += to - from;\n      if (start < mid) {\n        q.emplace(start, mid, to);\n      }\n      if (mid + 1 < end) {\n        q.emplace(mid + 1, end, to);\n      }\n    }\n    return ret;\n  }\n};",
    "submit_ts": "1721530161",
    "subm_id": "1327924787"
}