{
    "username": "TfVQQDhSj6",
    "submission": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 50000;\n\nstruct Node {\n    int mx;\n    int mxLeft;\n    int mxRight;\n    int left;\n    int right;\n\n    Node() {\n        mx = mxLeft = mxRight = left = right = 0;\n    }\n} node[N * 4 + 20];\n\nvoid pull_up(Node &rt, Node &left, Node &right) {\n    rt.mxLeft = left.mxLeft;\n    if (left.mxLeft == left.right - left.left + 1) {\n        rt.mxLeft = left.right - left.left + 1 + right.mxLeft;\n    }\n\n    rt.mxRight = right.mxRight;\n    if (right.mxRight == right.right - right.left + 1) {\n        rt.mxRight = right.right - right.left + 1 + left.mxRight;\n    }\n\n    rt.mx = max(left.mx, right.mx);\n    rt.mx = max(rt.mx, left.mxRight + right.mxLeft);\n    rt.mx = max(rt.mx, rt.mxLeft);\n    rt.mx = max(rt.mx, rt.mxRight);\n}\n\nvoid build(int rt, int left, int right) {\n    node[rt].left = left;\n    node[rt].right = right;\n    if (left == right) {\n        node[rt].mx = node[rt].mxLeft = node[rt].mxRight = 1;\n        return;\n    }\n    int mid = (left + right) / 2;\n    build(rt * 2, left, mid);\n    build(rt * 2 + 1, mid + 1, right);\n    pull_up(node[rt], node[rt * 2], node[rt * 2 + 1]);\n}\n\nNode query(int rt, int left, int right, int qLeft, int qRight) {\n    if (qLeft <= left && right <= qRight) {\n        return node[rt];\n    }\n    int mid = (left + right) / 2;\n    if (qRight <= mid) {\n        return query(rt * 2, left, mid, qLeft, qRight);\n    } else if (mid < qLeft) {\n        return query(rt * 2 + 1, mid + 1, right, qLeft, qRight);\n    } else {\n        Node a = query(rt * 2, left, mid, qLeft, mid);\n        Node b = query(rt * 2 + 1, mid + 1, right, mid + 1, qRight);\n        Node c;\n        c.left = qLeft;\n        c.right = qRight;\n        pull_up(c, a, b);\n        // printf(\"%d->%d : .mx = %d, .mxLeft=  %d, .mxRight = %d\\n\", c.left, c.right, c.mx, c.mxLeft, c.mxRight);\n        return c;\n    }\n}\n\nvoid update(int rt, int left, int right, int pos, int tp) {\n    if (left == right && left == pos) {\n        if (tp == 0) {\n            node[rt].mxLeft = 0;\n        } else {\n            node[rt].mxRight = 0;\n        }\n        return;\n    }\n    int mid = (left + right) / 2;\n    if (pos <= mid) update(rt * 2, left, mid, pos, tp);\n    else update(rt * 2 + 1, mid + 1, right, pos, tp);\n    pull_up(node[rt], node[rt * 2], node[rt * 2 + 1]);\n}\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>> &queries) {\n\n        int n = 0;\n        for (int i = 0; i < queries.size(); ++i) {\n            n = max(n, queries[i][1]);\n        }\n        ++n;\n        build(1, 1, n);\n\n        vector<bool> ret;\n        for (int j = 0; j < queries.size(); ++j) {\n            const auto &item = queries[j];\n            // for (int i = 0; i < n * 4; ++i) {\n            //     printf(\"node[%d](%d -> %d).mx = %d, .mxLeft=  %d, .mxRight = %d\\n\", i, node[i].left, node[i].right,\n            //            node[i].mx, node[i].mxLeft, node[i].mxRight);\n            // }\n            // printf(\"j = %d\\n\", j);\n\n            if (item[0] == 1) {\n                update(1, 1, n, item[1], 1);\n                update(1, 1, n, item[1] + 1, 0);\n            } else {\n                Node cur = query(1, 1, n, 1, item[1]);\n                ret.emplace_back(cur.mx >= item[2]);\n            }\n        }\n        return ret;\n    }\n};",
    "submit_ts": 1716652010.0
}