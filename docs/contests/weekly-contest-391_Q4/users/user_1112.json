{
    "username": "lastprism",
    "submission": "using L = long long;\n\n\nstruct point{L x,y;}a[500005],s[500005],b[500005];\nint mp[500005];\nL det(L x1,L y1,L x2,L y2){return x1*y2-x2*y1;}\nL cross(const point &a,const point &b,const point &c){return det(b.x-a.x,b.y-a.y,c.x-a.x,c.y-a.y);}\nint operator<(const point &a,const point &b){\n    return a.y==b.y?a.x<b.x:a.y<b.y;\n}\nint operator==(const point &a,const point &b){\n    return a.x==b.x && a.y==b.y;\n}\nint n,top;\nvoid graham(){\n    sort(a,a+n);\n    s[top=0]=a[0];\n    mp[top] = 0;\n    for (int i=1;i<n;i++){\n        if(a[i]==a[i-1])continue;\n        while(top>0 && cross(s[top-1],s[top],a[i])<=0)top--;\n        s[++top]=a[i];\n        mp[top] = i;\n    }\n    int tmp=top;\n    for (int i=n-2;i>=0;i--){\n        if(a[i]==a[i+1])continue;\n        while(top>tmp && cross(s[top-1],s[top],a[i])<=0)top--;\n        s[++top]=a[i];\n        mp[top] = i;\n    }\n}\n\nL ans=0;\nL ans2=0;\nset<point> idx;\nL dis2(const point &a,const point &b){return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\nL dis(const point &a,const point &b){return abs(a.x-b.x)+abs(a.y-b.y);}\nvoid rc(){\n    idx.clear();\n    ans = 0;\n    ans2 = 0;\n    int t=1;\n    for (int i=0;i<top;i++){\n         while(cross(s[t],s[i],s[i+1])<cross(s[t+1],s[i],s[i+1]))t=t==top-1?0:t+1;\n         ans=max(ans,max(dis(s[i],s[t]),dis(s[i+1],s[t])));\n    }\n    for (int i=0;i<top;i++){\n         while(cross(s[t],s[i],s[i+1])<cross(s[t+1],s[i],s[i+1]))t=t==top-1?0:t+1;\n        if( dis(s[i],s[t]) == ans ){\n            idx.insert(s[i]);\n            idx.insert(s[t]);\n        }\n        if( dis(s[i+1],s[t]) == ans ){\n            idx.insert(s[i+1]);\n            idx.insert(s[t]);\n        }\n    }\n}\n\nclass Solution {\npublic:\n    int minimumDistance(vector<vector<int>>& p) {\n        n = p.size();\n        \n        for (int i=0;i<n;i++) a[i].x = p[i][0], a[i].y = p[i][1];\n        graham();\n        rc();\n        if(ans == 0)return ans;\n        // cout << ans << endl;\n        auto idx_t = idx;\n        L ans_t{INT_MAX};\n        for(auto iter: idx_t){\n            // cout << \"# \" << iter.x << \" \" << iter.y << endl;\n            int is_move = 0;\n            for (int i=0;i<p.size();i++) {\n                if(p[i][0] == iter.x && p[i][1] == iter.y && is_move == 0){\n                    is_move = 1;\n                    continue;\n                }\n                a[i-is_move].x = p[i][0], a[i-is_move].y = p[i][1];\n            }\n            n = p.size()-1;\n            // for(int i = 0; i < n; i++){\n            //     printf(\"(%d %d) \",a[i].x, a[i].y);\n            // }\n            // cout << endl;\n            graham();\n            rc();\n            // cout << \"@\" << ans << endl;\n            ans_t = min(ans_t, ans);\n        }\n        return ans_t;\n        \n    }\n};"
}