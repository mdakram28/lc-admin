{
    "username": "anshu_2211_",
    "submission": "\n\n\n\n\nclass BitwiseANDSegmentTree {\npublic:\n    vector<int> segTree;\n    int size;\n\n    BitwiseANDSegmentTree(vector<int>& inputArray)\n    {\n        size = inputArray.size();\n        segTree.resize(4 * size);\n        buildTree(inputArray, 0, 0, size - 1);\n    }\n    \n    void buildTree(vector<int>& inputArray, int currentNode, int segmentStart, int segmentEnd)\n    {\n        if (segmentStart == segmentEnd) {\n            segTree[currentNode] = inputArray[segmentStart];\n        }\n        else {\n            int mid = getMid(segmentStart, segmentEnd);\n            buildTree(inputArray, 2 * currentNode + 1, segmentStart, mid);\n            buildTree(inputArray, 2 * currentNode + 2, mid + 1, segmentEnd);\n            segTree[currentNode] = combine(segTree[2 * currentNode + 1], segTree[2 * currentNode + 2]);\n        }\n    }\n\n    int queryRange(int currentNode, int segmentStart, int segmentEnd, int queryStart, int queryEnd)\n    {\n        if (isOutOfRange(segmentStart, segmentEnd, queryStart, queryEnd)) {\n            return INT_MAX;\n        }\n        if (isWithinRange(segmentStart, segmentEnd, queryStart, queryEnd)) {\n            return segTree[currentNode];\n        }\n        int mid = getMid(segmentStart, segmentEnd);\n        int leftChildResult = queryRange(2 * currentNode + 1, segmentStart, mid, queryStart, queryEnd);\n        int rightChildResult = queryRange(2 * currentNode + 2, mid + 1, segmentEnd, queryStart, queryEnd);\n        return combine(leftChildResult, rightChildResult);\n    }\n\nprivate:\n    int getMid(int start, int end) {\n        return (start + end) / 2;\n    }\n\n    int combine(int leftResult, int rightResult) {\n        return leftResult & rightResult;\n    }\n\n    bool isOutOfRange(int segmentStart, int segmentEnd, int queryStart, int queryEnd) {\n        return queryEnd < segmentStart || segmentEnd < queryStart;\n    }\n\n    bool isWithinRange(int segmentStart, int segmentEnd, int queryStart, int queryEnd) {\n        return queryStart <= segmentStart && segmentEnd <= queryEnd;\n    }\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Solution {\npublic:\n    \n    void binarySearch(int& mid, int& left, int& right, int& target, BitwiseANDSegmentTree& segTree, int& i,int&size)\n{\n    while (right - left > 1) {\n        mid = (left + right) / 2;\n        if (segTree.queryRange(0, 0, size - 1, i, mid) >= target)\n            left = mid;\n        else\n            right = mid;\n    }\n}\n\nint getClosestDifference(int currentDifference, int newDifference) {\n    return min(currentDifference, newDifference);\n}\n\n    \n    \n    int minimumDifference(vector<int>& nums, int k) {\n        \n        int arraySize = nums.size();\n    BitwiseANDSegmentTree segTree(nums);\n    int closestDifference = INT_MAX;\n\n    for (int i = 0; i < arraySize; i++) {\n        int left = i - 1, right = arraySize - 1, mid;\n        binarySearch(mid, left, right, k, segTree, i,arraySize);\n\n        if (left != i - 1)\n            closestDifference = getClosestDifference(closestDifference, abs(segTree.queryRange(0, 0, arraySize - 1, i, left) - k));\n        \n        closestDifference = getClosestDifference(closestDifference, abs(k - segTree.queryRange(0, 0, arraySize - 1, i, right)));\n    }\n    return closestDifference;\n    }\n};\n\n",
    "submit_ts": 1717300595.0
}