{
    "username": "_lemonjuice_",
    "submission": "class Solution {\npublic:\n    int getMid(int s, int e) \n{\n    return s + (e - s) / 2;\n}\n \n/*  A recursive function to get the sum of\n    values in given range of the array. \n    The following are parameters for this\n    function.\n \n    st       -> Pointer to segment tree\n    node     -> Index of current node in \n                the segment tree .\n    ss & se  -> Starting and ending indexes \n                of the segment represented\n                by current node, i.e., st[node]\n    l & r    -> Starting and ending indexes \n                of range query */\nint MaxUtil(int* st, int ss, int se, int l, \n            int r, int node)\n{\n    // If segment of this node is completely\n    // part of given range, then return \n    // the max of segment\n    if (l <= ss && r >= se)\n        return st[node];\n \n    // If segment of this node does not\n    // belong to given range\n    if (se < l || ss > r)\n        return -1;\n \n    // If segment of this node is partially\n    // the part of given range\n    int mid = getMid(ss, se);\n     \n    return max(MaxUtil(st, ss, mid, l, r, \n                       2 * node + 1),\n               MaxUtil(st, mid + 1, se, l, \n                       r, 2 * node + 2));\n}\n \n/* A recursive function to update the nodes \n   which have the given index in their range. \n   The following are parameters st, ss and \n   se are same as defined\n   above index -> index of the element \n   to be updated.*/\nvoid updateValue(int arr[], int* st, int ss, int se, \n                 int index, int value, int node)\n{\n    if (index < ss || index > se) \n    {\n        cout << \"Invalid Input\" << endl;\n        return;\n    }\n     \n    if (ss == se) \n    {   \n        // update value in array and in segment tree\n        arr[index] = value;\n        st[node] = value;\n    }\n    else {\n            int mid = getMid(ss, se);\n             \n            if (index >= ss && index <= mid)\n                updateValue(arr, st,\n                            ss, mid, index, \n                            value, 2 * node + 1);\n            else\n                updateValue(arr, \n                            st, mid + 1, se, \n                            index,\n                            value, 2 * node + 2);\n             \n            st[node] = max(st[2 * node + 1], \n                       st[2 * node + 2]);\n    }\n    return;\n}\n \n// Return max of elements in range from\n// index l (query start) to r (query end).\nint getMax(int* st, int n, int l, int r)\n{\n    // Check for erroneous input values\n    if (l < 0 || r > n - 1 || l > r) \n    {\n        return -1;\n    }\n \n    return MaxUtil(st, 0, n - 1, l, r, 0);\n}\n \n// A recursive function that constructs Segment\n// Tree for array[ss..se]. si is index of \n// current node in segment tree st\nint constructSTUtil(int arr[], int ss, int se, \n                    int* st, int si)\n{\n    // If there is one element in array, store\n    // it in current node of \n    // segment tree and return\n    if (ss == se) \n    {\n        st[si] = arr[ss];\n        return arr[ss];\n    }\n \n    // If there are more than one elements, then\n    // recur for left and right subtrees and \n    // store the max of values in this node\n    int mid = getMid(ss, se);\n     \n    st[si] = max(constructSTUtil(arr, ss, mid, st, \n                                 si * 2 + 1),\n                 constructSTUtil(arr, mid + 1, se, \n                                 st, si * 2 + 2));\n     \n    return st[si];\n}\n \n/* Function to construct segment tree \n   from given array.\n   This function allocates memory for \n   segment tree.*/\nint* constructST(int arr[], int n)\n{\n    // Height of segment tree\n    int x = (int)(ceil(log2(n)));\n \n    // Maximum size of segment tree\n    int max_size = 2 * (int)pow(2, x) - 1;\n \n    // Allocate memory\n    int* st = new int[max_size];\n \n    // Fill the allocated memory st\n    constructSTUtil(arr, 0, n - 1, st, 0);\n \n    // Return the constructed segment tree\n    return st;\n}\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector <bool> res;\n        int n = 50001;\n        int arr [n];\n        for(int i = 0 ; i < n; i++){\n            arr[i] = 0;\n        }\n        arr[0] = 1e9;\n        int* st = constructST(arr, n);\n        set <int> s;\n        s.insert(0);\n        for(auto it : queries){\n            if(it[0] == 1){\n                auto it1 = s.upper_bound(it[1]);\n                if(it1 == s.end()){\n                    updateValue(arr, st, 0, n - 1, it[1],1e9, 0);\n                }\n                else{\n                    updateValue(arr, st, 0, n - 1,it[1],*it1 - it[1], 0);\n                }\n                auto it2 = s.lower_bound(it[1]);\n                if(it2 == s.begin()){\n                    updateValue(arr, st, 0, n - 1,*it2,it[1] - *it2, 0);\n                }\n                else{\n                    it2 --;\n                    updateValue(arr, st, 0, n - 1,*it2,it[1] - *it2, 0);\n                }\n                s.insert(it[1]);\n            }\n            else{\n                auto it1 = s.lower_bound(it[1]);\n                it1--;\n                    int ans = it[1] - *it1;\n                    ans = max(ans,getMax(st, n, 0, *it1 - 1));\n                    if(ans >= it[2]){\n                        res.push_back(true);\n                    }\n                    else{\n                        res.push_back(false);\n                    }\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1716652322.0
}