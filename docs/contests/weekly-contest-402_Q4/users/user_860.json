{
    "username": "Harshitcode",
    "submission": "class SegmentTree {\npublic:\n    SegmentTree(vector<int>& nums) {\n        n = nums.size();\n        peaks.assign(4 * n, 0);\n        arr = nums;\n        build(0, 0, n - 1);\n    }\n\n    int query(int l, int r) {\n        return queryUtil(0, 0, n - 1, l+1, r-1);\n    }\n\n    void update(int index, int value) {\n        arr[index] = value;\n        if (index > 0) updateUtil(0, 0, n - 1, index - 1); // Update previous element\n        updateUtil(0, 0, n - 1, index); // Update current element\n        if (index < n - 1) updateUtil(0, 0, n - 1, index + 1); // Update next element\n    }\n\nprivate:\n    vector<int> peaks;\n    vector<int> arr;\n    int n;\n\n    bool isPeak(int i) {\n        if (i <= 0 || i >= n - 1) return false;\n        return arr[i] > arr[i - 1] && arr[i] > arr[i + 1];\n    }\n\n    void build(int node, int start, int end) {\n        if (start == end) {\n            peaks[node] = isPeak(start);\n        } else {\n            int mid = (start + end) / 2;\n            build(2 * node + 1, start, mid);\n            build(2 * node + 2, mid + 1, end);\n            peaks[node] = peaks[2 * node + 1] + peaks[2 * node + 2];\n        }\n    }\n\n    int queryUtil(int node, int start, int end, int l, int r) {\n        if (start > r || end < l) {\n            return 0;\n        }\n        if (start >= l && end <= r) {\n            return peaks[node];\n        }\n        int mid = (start + end) / 2;\n        int left = queryUtil(2 * node + 1, start, mid, l, r);\n        int right = queryUtil(2 * node + 2, mid + 1, end, l, r);\n        return left + right;\n    }\n\n    void updateUtil(int node, int start, int end, int idx) {\n        if (start == end) {\n            peaks[node] = isPeak(start);\n        } \n        else {\n            int mid = (start + end) / 2;\n            if (idx <= mid) {\n                updateUtil(2 * node + 1, start, mid, idx);\n            } else {\n                updateUtil(2 * node + 2, mid + 1, end, idx);\n            }\n            peaks[node] = peaks[2 * node + 1] + peaks[2 * node + 2];\n        }\n        // if (idx > 0 && idx - 1 >= start && idx - 1 <= end) {\n        //     if (start == end) {\n        //         peaks[node] = isPeak(start) ? 1 : 0;\n        //     } else {\n        //         int mid = (start + end) / 2;\n        //         if (idx - 1 <= mid) {\n        //             updateUtil(2 * node + 1, start, mid, idx - 1);\n        //         } else {\n        //             updateUtil(2 * node + 2, mid + 1, end, idx - 1);\n        //         }\n        //         peaks[node] = peaks[2 * node + 1] + peaks[2 * node + 2];\n        //     }\n        // }\n        // if (idx < n - 1 && idx + 1 >= start && idx + 1 <= end) {\n        //     if (start == end) {\n        //         peaks[node] = isPeak(start) ? 1 : 0;\n        //     } else {\n        //         int mid = (start + end) / 2;\n        //         if (idx + 1 <= mid) {\n        //             updateUtil(2 * node + 1, start, mid, idx + 1);\n        //         } else {\n        //             updateUtil(2 * node + 2, mid + 1, end, idx + 1);\n        //         }\n        //         peaks[node] = peaks[2 * node + 1] + peaks[2 * node + 2];\n        //     }\n        // }\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n                SegmentTree segTree(nums);\n        vector<int> result;\n        \n        for (const auto& query : queries) {\n            if (query[0] == 1) {\n                result.push_back(segTree.query(query[1], query[2]));\n            } else if (query[0] == 2) {\n                segTree.update(query[1], query[2]);\n            }\n        }\n        \n        return result;\n\n    }\n};",
    "submit_ts": 1718507155.0
}