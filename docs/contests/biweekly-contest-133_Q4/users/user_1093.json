{
    "username": "Parth0100",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//using namespace __gnu_pbds;\n// #define int long long\n#define read(arr,n) vector<int>arr(n); for(int i=0;i<n;i++)cin>>arr[i];\n#define sortv(x) sort(x.begin(),x.end());\n#define sorta(x,n) sort(x,x+n);\n#define fori(i,x,n) for(int i=x;i<n;i++)\n#define fore(i,x,n) for(int i=n-1;i>=x;i--)\n#define gcd(a,b) __gcd(a,b)\n#define pb push_back\n#define um unordered_map\n#define maxheap(type) priority_queue<type>;\n#define minheap(type) priority_queue<type,vector<type>,greater<type>>;\n#define cout(v) for(auto &i : v) cout<<i<<\" \"; cout<<endl;\n#define maxe(v) max_element(v.begin(),v.end())\n#define mine(v) min_element(v.begin(),v.end())\n#pragma GCC target(\"popcnt\")\n//typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set;\nconst int MOD=1e9+7;\n\nclass dsu{\npublic:\nvector<int>rank,parent,size;\ndsu(int n)\n{\n    rank.resize(n+1,0);\n    parent.resize(n+1,0);\n    for(int i=1;i<=n;i++)parent[i]=i;\n    size.resize(n+1,1);\n}\nint findUparent(int node)\n{\n    if(parent[node]==node)return node;\n    return parent[node]=findUparent(parent[node]);\n}\nvoid UnionByRank(int u,int v)\n{\n    int ulp_u=findUparent(u);\n    int ulp_v=findUparent(v);\n    if(ulp_u==ulp_v)return;\n    if(rank[ulp_u]<rank[ulp_v])\n    parent[ulp_u]=ulp_v;\n    else\n    {\n        parent[ulp_v]=ulp_u;\n        rank[ulp_u]++;\n    }\n}\nvoid UnionBySize(int u,int v)\n{\n    int ulp_u=findUparent(u);\n    int ulp_v=findUparent(v);\n    if(ulp_u==ulp_v)return;\n    if(size[ulp_u]<size[ulp_v])\n    {\n    parent[ulp_u]=ulp_v;\n    size[ulp_v]+=size[ulp_u];\n    }\n    else\n    {\n        parent[ulp_v]=ulp_u;\n        size[ulp_u]+=size[ulp_v];\n    }\n}\n};\nbool isPrime(int n)\n{\n    if (n <= 1)\n        return false;\n    if (n == 2 || n == 3)\n        return true;\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n     \n    for (int i = 5; i <= sqrt(n); i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n \n    return true;\n}\nint power(int x, int y)\n{\nif (y == 0)\nreturn 1;\nelse if (y % 2 == 0)\nreturn power(x, y / 2) * power(x, y / 2);\nelse\nreturn x * power(x, y / 2) * power(x, y / 2);\n}\n\nclass seg_tree{\n    public:\nvector<int>seg;\nseg_tree(int n)\n{\n    seg.resize(4*n+1);\n}\nvoid build(int ind,int low,int high,vector<int>&arr)\n{\n    if(low==high)\n    {\n        seg[ind]=arr[low];\n        return;\n    }\n    int mid=(low+high)/2;\n    build(2*ind+1,low,mid,arr);\n    build(2*ind+2,mid+1,high,arr);\n    seg[ind]=min(seg[2*ind+1],seg[2*ind+2]);\n}\nint query(int ind,int low,int high,int l,int r)\n{\n    if(r<low || l>high)return INT_MAX;\n    if(low>=l && high<=r)return seg[ind];\n    int mid=(low+high)>>1;\n    int left=query(2*ind+1,low,mid,l,r);\n    int right=query(2*ind+2,mid+1,high,l,r);\n    return min(left,right);\n}\nvoid update(int ind,int low,int high,int i,int val)\n{\n    if(low==high)\n    {\n        seg[ind]=val;\n        return;\n    }\n    int mid =(low+high)>>1;\n    if(i<=mid)update(2*ind+1,low,mid,i,val);\n    else\n    update(2*ind+2,mid+1,high,i,val);\n\n    seg[ind]=min(seg[2*ind+1],seg[2*ind+2]);\n}\n};\n\n\nclass Solution {\npublic:\n    int numberOfPermutations(int n, vector<vector<int>>& requirements) {\n        \n        seg_tree s1(requirements.size());\n        int z=0;\n        vector<int>arr(requirements.size());\n        for(auto it:requirements)\n            arr[z++]=it[0];\n        \n        s1.build(0,0,z-1,arr);\n        \n        \n        \n    vector<vector<int>> dp(n + 1, vector<int>(401, 0));\n    dp[0][0] = 1;\n     map<int, int> mp;\n    for (auto it : requirements) {\n        mp[it[0] + 1] = it[1];\n    }\n    fori(i,1,n+1)\n    {\n        fori(j,0,401)\n         {\n           fori(k,0,i)\n            {\n                if ((j-k)>= 0) {\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j-k]) % MOD;\n                }\n            }\n        }\n        \n\n        if (mp.count(i)) {\n            fori(j,0,401) {\n                if (j != mp[i]) {\n                    dp[i][j] = 0;\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for (auto it :dp[n]) {\n        ans = (ans %MOD+ it%MOD) % MOD;\n    }\n\n    return (ans);\n    }\n};",
    "submit_ts": 1719071389.0
}