{
    "username": "Positron23",
    "submission": "class DSU:\n    def __init__(self, n):\n        self.n = n\n        self.parent = [i for i in range(n + 1)]\n        self.rank = [1 for i in range(n + 1)]\n\n    def find(self, x):\n        while x != self.parent[x]:\n            self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x\n\n    # returns 1 if two components joined, 0 if same component\n    def union(self, x, y):\n        rootx = self.find(x)\n        rooty = self.find(y)\n        if rootx == rooty:\n            return 0\n        \n        if self.rank[rootx] > self.rank[rooty]:\n            self.rank[rootx] += self.rank[rooty]\n            self.parent[rooty] = rootx\n        else:\n            self.rank[rooty] += self.rank[rootx]\n            self.parent[rootx] = rooty\n        self.n -= 1\n        return 1\n\n\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        def circleFullyWithinRectangle(x, y, r):\n            return x - r > 0 and x + r < X and y - r > 0 and y + r < Y\n        def getCircleBadTypes(x, y, r):\n            badTypes = set()\n            if x - r <= 0:\n                badTypes.add(\"left\")\n            if x + r >= X:\n                badTypes.add(\"right\")\n            if y - r <= 0:\n                badTypes.add(\"bottom\")\n            if y + r >= Y:\n                badTypes.add(\"top\")\n            return badTypes\n        def circlesIntersect(circle1, circle2):\n            # or are tangent\n            x1, y1, r1 = circle1\n            x2, y2, r2 = circle2\n            return (x2 - x1) ** 2 + (y2 - y1) ** 2 <= (r1 + r2) ** 2\n\n        neighbours = [[] for i in range(len(circles))]\n        circleDSU = DSU(len(circles))\n        for i in range(len(circles)):\n            for j in range(len(circles)):\n                if i == j:\n                    continue\n                if circlesIntersect(circles[i], circles[j]):\n                    neighbours[i].append(j)\n                    neighbours[j].append(i)\n                    circleDSU.union(i + 1, j + 1) # 1-indexed because of my DSU implementation\n\n        groupToBadTypes = dict()    \n        for i in range(1, len(circles) + 1):\n            par = circleDSU.find(i)\n            if par not in groupToBadTypes:\n                groupToBadTypes[par] = set()\n            \n            x, y, r = circles[i - 1]\n            badTypes = getCircleBadTypes(x, y, r)\n            groupToBadTypes[par] = groupToBadTypes[par].union(badTypes)\n\n        # print(f\"groupToBadTypes: {groupToBadTypes}\")\n\n        for par in groupToBadTypes:\n            badTypes = groupToBadTypes[par]\n            if \"bottom\" in badTypes and \"top\" in badTypes:\n                return False\n            if \"left\" in badTypes and \"right\" in badTypes:\n                return False\n            if \"bottom\" in badTypes and \"left\" in badTypes:\n                return False\n            if \"top\" in badTypes and \"right\" in badTypes:\n                return False\n        return True\n\n        \n\n\n        \n        ",
    "submit_ts": "1722137647",
    "subm_id": "1335769758"
}