{
    "username": "monika2240",
    "submission": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\nprivate:\n    vector<int> nums;\n    vector<int> isPeak;\n    vector<int> segTree;\n    int n;\n    \n    void buildPeakArray() {\n        for (int i = 1; i < n - 1; ++i) {\n            if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {\n                isPeak[i] = 1;\n            } else {\n                isPeak[i] = 0;\n            }\n        }\n    }\n    \n    void buildSegTree(int node, int start, int end) {\n        if (start == end) {\n            segTree[node] = isPeak[start];\n        } else {\n            int mid = (start + end) / 2;\n            buildSegTree(2 * node + 1, start, mid);\n            buildSegTree(2 * node + 2, mid + 1, end);\n            segTree[node] = segTree[2 * node + 1] + segTree[2 * node + 2];\n        }\n    }\n    \n    void updateSegTree(int node, int start, int end, int idx, int value) {\n        if (start == end) {\n            segTree[node] = value;\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid) {\n                updateSegTree(2 * node + 1, start, mid, idx, value);\n            } else {\n                updateSegTree(2 * node + 2, mid + 1, end, idx, value);\n            }\n            segTree[node] = segTree[2 * node + 1] + segTree[2 * node + 2];\n        }\n    }\n    \n    int querySegTree(int node, int start, int end, int L, int R) {\n        if (R < start || end < L) {\n            return 0;\n        }\n        if (L <= start && end <= R) {\n            return segTree[node];\n        }\n        int mid = (start + end) / 2;\n        int leftQuery = querySegTree(2 * node + 1, start, mid, L, R);\n        int rightQuery = querySegTree(2 * node + 2, mid + 1, end, L, R);\n        return leftQuery + rightQuery;\n    }\n    \n    void updatePeakArray(int idx) {\n        if (idx > 0 && idx < n - 1) {\n            isPeak[idx] = (nums[idx] > nums[idx - 1] && nums[idx] > nums[idx + 1]) ? 1 : 0;\n        }\n    }\n    \n    void updateValue(int idx, int value) {\n        nums[idx] = value;\n        if (idx > 0 && idx < n - 1) {\n            updatePeakArray(idx - 1);\n            updateSegTree(0, 0, n - 1, idx - 1, isPeak[idx - 1]);\n            updatePeakArray(idx);\n            updateSegTree(0, 0, n - 1, idx, isPeak[idx]);\n            updatePeakArray(idx + 1);\n            updateSegTree(0, 0, n - 1, idx + 1, isPeak[idx + 1]);\n        } else if (idx == 0 && n > 1) {\n            updatePeakArray(1);\n            updateSegTree(0, 0, n - 1, 1, isPeak[1]);\n        } else if (idx == n - 1 && n > 1) {\n            updatePeakArray(n - 2);\n            updateSegTree(0, 0, n - 1, n - 2, isPeak[n - 2]);\n        }\n    }\n    \n    int queryPeakCount(int L, int R) {\n        return querySegTree(0, 0, n - 1, L, R);\n    }\n    \npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        this->nums = nums;\n        n = nums.size();\n        isPeak.resize(n, 0);\n        segTree.resize(4 * n, 0);\n        \n        buildPeakArray();\n        buildSegTree(0, 0, n - 1);\n        \n        vector<int> result;\n        for (auto& query : queries) {\n            if (query[0] == 1) {\n                int li = query[1], ri = query[2];\n                result.push_back(queryPeakCount(li + 1, ri - 1)); // Peaks cannot be the first or last element\n            } else if (query[0] == 2) {\n                int index = query[1], value = query[2];\n                updateValue(index, value);\n            }\n        }\n        \n        return result;\n    }\n};\n",
    "submit_ts": "1718507726",
    "subm_id": "1289660573"
}