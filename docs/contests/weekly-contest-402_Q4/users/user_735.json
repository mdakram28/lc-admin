{
    "username": "sgr84ayushi",
    "submission": "class SegmentTree {\nprivate:\n    vector<int> tree;\n    int n;\n\n    void build(const vector<int>& peaks, int v, int tl, int tr) {\n        if (tl == tr) {\n            tree[v] = peaks[tl];\n        } else {\n            int tm = (tl + tr) / 2;\n            build(peaks, v * 2, tl, tm);\n            build(peaks, v * 2 + 1, tm + 1, tr);\n            tree[v] = tree[v * 2] + tree[v * 2 + 1];\n        }\n    }\n\n    int query(int v, int tl, int tr, int l, int r) {\n        if (l > r)\n            return 0;\n        if (l == tl && r == tr)\n            return tree[v];\n        int tm = (tl + tr) / 2;\n        return query(v * 2, tl, tm, l, min(r, tm))\n             + query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);\n    }\n\n    void update(int v, int tl, int tr, int pos, int new_val) {\n        if (tl == tr) {\n            tree[v] = new_val;\n        } else {\n            int tm = (tl + tr) / 2;\n            if (pos <= tm)\n                update(v * 2, tl, tm, pos, new_val);\n            else\n                update(v * 2 + 1, tm + 1, tr, pos, new_val);\n            tree[v] = tree[v * 2] + tree[v * 2 + 1];\n        }\n    }\n\npublic:\n    SegmentTree(const vector<int>& peaks) {\n        n = peaks.size();\n        tree.resize(n * 4);\n        build(peaks, 1, 0, n - 1);\n    }\n\n    int query(int l, int r) {\n        return query(1, 0, n - 1, l, r);\n    }\n\n    void update(int pos, int new_val) {\n        update(1, 0, n - 1, pos, new_val);\n    }\n};\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n         int n = nums.size();\n        vector<int> peaks(n, 0);\n\n        for (int i = 1; i < n - 1; ++i) {\n            if (isPeak(nums, i)) {\n                peaks[i] = 1;\n            }\n        }\n\n        SegmentTree segTree(peaks);\n\n        vector<int> result;\n\n        for (const auto& q : queries) {\n            if (q[0] == 1) {\n                int l = q[1];\n                int r = q[2];\n                if (l < r - 1) {\n                    result.push_back(segTree.query(l + 1, r - 1));\n                } else {\n                    result.push_back(0);\n                }\n            } else if (q[0] == 2) {\n                int index = q[1];\n                int new_val = q[2];\n                nums[index] = new_val;\n                for (int i = max(1, index - 1); i <= min(n - 2, index + 1); ++i) {\n                    int new_peak = isPeak(nums, i) ? 1 : 0;\n                    segTree.update(i, new_peak);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    bool isPeak(const vector<int>& nums, int i) {\n        if (i <= 0 || i >= nums.size() - 1) return false;\n        return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    }\n    \n};",
    "submit_ts": 1718507594.0
}