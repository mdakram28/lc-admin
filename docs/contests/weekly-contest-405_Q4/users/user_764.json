{
    "username": "balakrishnan_v",
    "submission": "#define ll long long\nclass Solution {\npublic:\n    \n    \n//     int Solve(const string& target, int pos, const vector<string>& words, const vector<int>& costs) {\n//         int n=target.size();\n//         if (pos==n) return 0;\n//         for()\n//     }\n    \n    \n    vector<vector<int>> next_node;\n    vector<int> min_cost;\n    \n    void Construct(const string& word, int pos, int curr_node, int cost) {\n        if (pos == word.size()) {\n            if (min_cost[curr_node]==-1 || min_cost[curr_node]>cost) min_cost[curr_node]=cost;\n            return;\n        }\n        int c = word[pos]-'a';\n        if (next_node[curr_node][c]==-1) {\n            next_node.push_back(vector<int>(26,-1));\n            min_cost.push_back(-1);\n            next_node[curr_node][c]=next_node.size()-1;\n        }\n        Construct(word, pos+1, next_node[curr_node][c],cost);\n    }\n    \n    int GetMin(int x,int y) {\n        if (x==-1) return y;\n        if (y==-1) return x;\n        return min(x,y);\n    }\n    \n    int Add(int x,int y) {\n        if (x==-1 || y==-1) return -1;\n        return x+y;\n    }\n    \n    map<pair<int,int>,int> H;\n    int Solve(const string& word, int pos, int trie_node) {\n        int n=word.size();\n        if (pos == n) {\n            return min_cost[trie_node];\n        }        \n        auto it = H.find({pos,trie_node});\n        if (it != H.end()) return it->second;\n        int c = word[pos]-'a';\n        int ans=-1;\n        if (min_cost[trie_node]!=-1) {\n             ans=GetMin(ans, Add(min_cost[trie_node],Solve(word,pos,0)));\n        }\n        if (next_node[trie_node][c]!=-1) {\n            ans = GetMin(ans, Solve(word, pos+1, next_node[trie_node][c]));\n        }\n        return H[{pos,trie_node}]=ans;\n        \n    }\n    \n    \n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        next_node=vector<vector<int>>(1,vector<int>(26,-1));\n        min_cost=vector<int>(1,-1);\n        for(int i=0;i<words.size();i++) {\n            Construct(words[i], 0, 0, costs[i]);\n        }\n        int n=target.size();\n        vector<ll> dp(n+1,-1);\n        dp[n]=0;\n        for(int i=n-1;i>=0;i--) {\n            int curr_trie_node=0;\n            for(int j=i;j<n;j++) {\n                char c = target[j]-'a';\n                curr_trie_node = next_node[curr_trie_node][c];\n                if (curr_trie_node==-1) break;\n                if (min_cost[curr_trie_node]!=-1) dp[i]=GetMin(dp[i],Add(dp[j+1],min_cost[curr_trie_node]));\n            }\n        }\n        return dp[0];\n        \n        \n        set<vector<ll>> Q;\n        Q.insert({0,0,0});\n        while(!Q.empty()) {\n            auto it = Q.begin();\n            ll curr_cost = it->at(0);\n            int pos = it->at(1);\n            int trie_node = it->at(2);\n            if (pos == n && trie_node==0) return curr_cost;\n            Q.erase(it);\n            if (min_cost[trie_node]!=-1) {\n                Q.insert({curr_cost+min_cost[trie_node], pos,0 });\n            }\n            if (pos!=n) {\n                int c = target[pos]-'a';\n                if (next_node[trie_node][c]!=-1) {\n                    Q.insert({curr_cost, pos+1, next_node[trie_node][c]});\n                }\n            }\n        }\n        \n        return -1;\n    }\n};",
    "submit_ts": "1720322072",
    "subm_id": "1312339944"
}