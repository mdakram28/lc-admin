{
    "username": "jendolkk",
    "submission": "template <class node, auto push = nullptr>\nstruct segtree {\n  int n;\n  vector<node> tree;\n\n  segtree(int _n): n(_n), tree(4 << __lg(_n)) {\n    build(1, 0, n - 1);\n  }\n\n  template <typename T>\n  segtree(const vector<T> &v): n(int(v.size())), tree(4 << __lg(n)) {\n    build(1, 0, n - 1, v);\n  }\n\n  void pull(int id) {\n    tree[id] = tree[id << 1] + tree[id << 1 | 1];\n  }\n\n  void build(int id, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int mid = l + r >> 1;\n    build(id << 1, l, mid);\n    build(id << 1 | 1, mid + 1, r);\n    pull(id);\n  }\n \n  template <typename T>\n  void build(int id, int l, int r, const vector<T> &a) {\n    if (l == r) {\n      tree[id].apply(l, r, a[l]);\n      return;\n    }\n    int mid = l + r >> 1;\n    build(id << 1, l, mid, a);\n    build(id << 1 | 1, mid + 1, r, a);\n    pull(id);\n  }\n\n  node get(int id, int l, int r, int ql, int qr) {\n    if (ql <= l && r <= qr) {\n      return tree[id];\n    }\n    if constexpr (push != nullptr) {\n      push(tree, id, l, r);\n    }\n    node res{};\n    int mid = l + r >> 1;\n    if (ql <= mid) {\n      res = get(id << 1, l, mid, ql, qr);\n    }\n    if (qr > mid) {\n      if (ql <= mid) {\n        res = res + get(id << 1 | 1, mid + 1, r, ql, qr);\n      } else {\n        res = get(id << 1 | 1, mid + 1, r, ql, qr);\n      }\n    }\n    return res;\n  }\n\n  node get(int ql, int qr) {\n    assert(0 <= ql && ql <= qr && qr <= n - 1);\n    return get(1, 0, n - 1, ql, qr);\n  }\n \n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(1, 0, n - 1, p, p);\n  }\n\n  template <class... Ts>\n  void modify(int id, int l, int r, int ql, int qr, const Ts&... v) {\n    if (ql <= l && r <= qr) {\n      tree[id].apply(l, r, v...);\n      return;\n    }\n    int mid = l + r >> 1;\n    if constexpr (push != nullptr) {\n      push(tree, id, l, r);\n    }\n    if (ql <= mid) {\n      modify(id << 1, l, mid, ql, qr, v...);\n    }\n    if (qr > mid) {\n      modify(id << 1 | 1, mid + 1, r, ql, qr, v...);\n    }\n    pull(id);\n  }\n\n  template <class... Ts>\n  void modify(int ql, int qr, const Ts&... v) {\n    assert(0 <= ql && ql <= qr && qr <= n - 1);\n    modify(1, 0, n - 1, ql, qr, v...);\n  }\n\n  int min_left(int id, int l, int r, int ql, int qr, const function<bool(const node&)>& verify) {\n    if (qr < l || r < ql) {\n      return -1;\n    }\n    if (ql <= l && r <= qr && !verify(tree[id])) {\n      return -1;\n    }\n    if (l == r) {\n      return l;\n    }\n    if constexpr (push != nullptr) {\n      push(tree, id, l, r);\n    }\n    int mid = l + r >> 1;\n    int res = min_left(id << 1, l, mid, ql, qr, verify);\n    if (res == -1) {\n      res = min_left(id << 1 | 1, mid + 1, r, ql, qr, verify);\n    }\n    return res;\n  }\n\n  int min_left(int ql, int qr, const function<bool(const node&)>& verify) {\n    return min_left(1, 0, n - 1, ql, qr, verify);\n  }\n\n  int max_right(int id, int l, int r, int ql, int qr, const function<bool(const node&)>& verify) {\n    if (qr < l || r < ql) {\n      return -1;\n    }\n    if (ql <= l && r <= qr && !verify(tree[id])) {\n      return -1;\n    }\n    if (l == r) {\n      return l;\n    }\n    if constexpr (push != nullptr) {\n      push(tree, id, l, r);\n    }\n    int mid = l + r >> 1;\n    int res = max_right(id << 1 | 1, mid + 1, r, ql, qr, verify);\n    if (res == -1) {\n      res = max_right(id << 1, l, mid, ql, qr, verify);\n    }\n    return res;\n  }\n\n  int max_right(int ql, int qr, const function<bool(const node&)>& verify) {\n    return max_right(1, 0, n - 1, ql, qr, verify);\n  }\n};\n\nstruct node {\n  int64_t sum = 0;\n  \n  void apply(int l, int r, int64_t v) {\n    sum = v;\n  }\n};\n\nnode operator+(const node& a, const node& b) {\n  node res{};\n  res.sum = a.sum + b.sum;\n  return res;\n}\n\n// void push(vector<node>& tree, int id, int l, int r) {\n//   int mid = l + r >> 1;\n//   if (tree[id].add != 0) {\n//     tree[id << 1].apply(l, mid, tree[id].add);\n//     tree[id << 1 | 1].apply(mid + 1, r, tree[id].add);\n//     tree[id].add = 0;\n//   }\n// }\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& q) {\n      int n = a.size();\n      vector<int> b(n);\n      for (int i = 1; i < n - 1; i++) {\n        if (a[i] > a[i - 1] && a[i] > a[i + 1]) {\n          b[i] = 1;\n        }\n      }\n      segtree<node> st(b);\n      vector<int> ans;\n      for (auto &qr : q) {\n        int op = qr[0], l = qr[1], r = qr[2];\n        if (op == 1) {\n          l++; r--;\n          if (l > r) ans.push_back(0);\n          else ans.push_back(st.get(l, r).sum);\n        } else {\n          a[l] = r;\n          if (l > 0 && l < n - 1) {\n            int t = a[l] > a[l - 1] && a[l] > a[l + 1];\n            st.modify(l, l, t);\n          }\n          if (l - 1 > 0) {\n            int t = a[l - 1] > a[l - 2] && a[l - 1] > a[l];\n            st.modify(l - 1, l - 1, t);\n          }\n          if (l + 1 < n - 1) {\n            int t = a[l + 1] > a[l] && a[l + 1] > a[l + 2];\n            st.modify(l + 1, l + 1, t);\n          }\n        }\n      }\n      return ans;\n    }\n};",
    "submit_ts": 1718506627.0
}