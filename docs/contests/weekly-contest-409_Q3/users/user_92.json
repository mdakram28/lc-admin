{
    "username": "SR3mix",
    "submission": "// LazySegmentTree\ntemplate <typename T> class LazySegmentTree {\n// MODIFY THE FOLLOWING AT MINIMUM:\n// 1. compare_operation()\n// 2. push function\n// 3. l == tl && r == tr case in rupdate\nprivate:\n    T seg[800080];\n    T adding[800080];\n    T setting[800080];\npublic:\n    T segBase;\n    int n = 0;\n    LazySegmentTree(T newSegBase) {\n        segBase = newSegBase;\n    }\n    void reset(int newN) {\n        n = newN;\n        assert(n * 4 <= sizeof(seg)/sizeof(seg[0]));\n        for (int i= 0; i<(4 * n + 20); i++) {seg[i] = segBase; adding[i] = 0; setting[i] = 0;}\n    }\n    void update(int pos, T x) {assert(pos >= 1 && pos <= n); doUpdate(1,1,n,pos,x);}\n    void doUpdate(int v, int tl, int tr, int pos, T x) {\n        if (tl == tr) seg[v] = update_operation(seg[v], x);\n        else {\n            int tm = (tl+tr) >> 1;\n            if (pos <= tm) doUpdate(v<<1, tl, tm, pos, x);\n            else doUpdate(v<<1|1, tm+1, tr, pos, x);\n            seg[v] = compare_operation(seg[v<<1], seg[v<<1|1]);\n        }\n    }\n    void push(int v,int tl,int tr) {\n        int tm = (tl+tr) >> 1;\n        T amt1 = tm - tl + 1;\n        T amt2 = tr - tm;\n        if (setting[v]) {\n            seg[v<<1] = setting[v] * amt1;\n            seg[v<<1|1] = setting[v] * amt2;\n            setting[v<<1] = setting[v<<1|1] = setting[v];\n            adding[v<<1] = adding[v<<1|1] = 0;\n        }\n        seg[v<<1] += (adding[v] * amt1);\n        adding[v<<1] += adding[v];  \n        seg[v<<1|1] += (adding[v] * amt2);\n        adding[v<<1|1] += adding[v];\n        setting[v] = adding[v] = 0;\n    }\n    void rupdate(int l, int r, T add, T set) {\n        assert(l >= 1 && l <= r && r <= n);\n        doRUpdate(1,1,n,l,r,add,set);\n    }\n    void doRUpdate(int v, int tl, int tr, int l, int r, T add, T set) {\n        if (l > r) return;\n        T amt = tr - tl + 1; \n        if (l == tl && r == tr) {\n            if (set != 0) {seg[v] = set * amt; setting[v] = set; adding[v] = 0;}\n            seg[v] += (amt * add); adding[v] += add;\n        }\n        else {\n            push(v,tl,tr);\n            int tm = (tl+tr) >> 1;\n            doRUpdate(v<<1, tl, tm, l, min(r, tm), add, set);\n            doRUpdate(v<<1|1, tm+1, tr, max(l, tm+1), r, add, set);\n            seg[v] = compare_operation(seg[v<<1], seg[v<<1|1]);\n        }\n    }\n    T query(int l, int r) {assert(l >= 1 && l <= r && r <= n); return doQuery(1,1,n,l,r);}\n    T doQuery(int v, int tl, int tr, int l, int r) {\n        if (l > r) return segBase;\n        if (l == tl && r == tr) {return seg[v];}\n        push(v,tl,tr);\n        int tm = (tl+tr) >> 1;\n        return compare_operation(doQuery(v<<1, tl, tm, l, min(r, tm)), doQuery(v<<1|1, tm+1, tr, max(l, tm+1), r));\n    }\n    T update_operation(T originalVal, T newVal) {return newVal;}\n    T compare_operation(T a, T b) {return a + b;}\n};\n// CREDIT TO numb3r5 FOR THIS TEMPLATE -> https://leetcode.com/numb3r5/\n\nLazySegmentTree seg(0);\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        seg.reset(n);\n        int curr = n - 1;\n        for (int i = 1; i <= n; i++) seg.update(i,0);\n        vector<int>res;\n        for (auto i : queries) {\n            int s = i[0]+1, e = i[1]+1;\n            if (s < e - 1) {\n                int done = seg.query(s+1,e-1);\n                int tot = e - s - 1;\n                int skip = tot - done;\n                //cout << tot << \",\" << done << \",\" << skip << endl;\n                curr -= skip;\n                seg.rupdate(s+1,e-1,0,1);\n            }\n            res.push_back(curr);\n        }\n        return res;\n    }\n};",
    "submit_ts": "1722739418",
    "subm_id": "1343693971"
}