{
    "username": "hhuuuu",
    "submission": "#include <bits/stdc++.h>\n#include <unistd.h>\n#ifdef _LOCAL_\n#define debug(args...) print(\"[line:\", __LINE__, \":\" #args \"]\", ##args)\n#else\n#define debug(...) 666\n#endif\n#define all(a) a.begin(), a.end()\nusing namespace std;using llong = long long;\n#define to(container, a) [](auto &&A) { return container(all(A)); }(a)\ntemplate <typename... Args>llong pow(llong x, auto b, auto MOD) { if (b < 0) x = pow(x, MOD - 2, MOD), b = -b; if (not x) return x; llong res = 1; for (; b; (x *= x) %= MOD, b >>= 1) if (b & 1) (res *= x) %= MOD; return res;} //\ntemplate <typename T> T sum(auto &&a, T res) { for (auto x : a) res += x; return res;}//\ntemplate <typename T> llong sum(T &&a) { return sum(forward<T>(a), 0ll); }    //\ntemplate <typename T> T reversed(T a) { ranges::reverse(a); return a;} //\ntemplate <typename T> T uniqued(T a) { ranges::sort(a); a.resize(unique(begin(a), end(a)) - begin(a)); return a;} //\ntemplate <typename... Args>auto sorted(auto a, Args &&...args) { sort(begin(a), end(a), args...); return a;} //\ntemplate <typename T>vector<T> &operator+=(vector<T> &a, const vector<T> &b) { a.insert(end(a), begin(b), end(b)); return a;};template <typename T>vector<T> operator+(vector<T> a, const vector<T> &b) { return a += b; }; //\ntemplate <typename T>vector<T> &operator*=(vector<T> &a, int k) { if (k <= 0) a.clear(); else { assert(a.size() * k < INT_MAX); int N = a.size() * k; a.reserve(N); while (a.size() * 2 <= N) a += a; a.insert(end(a), begin(a), begin(a) + (N - a.size())); } return a;};template <typename T>vector<T> operator*(vector<T> a, int k) { return a *= k; }; //\nstruct range { struct Iterator { using iterator_category = std::random_access_iterator_tag; using value_type = int64_t; using difference_type = ptrdiff_t; using pointer = int64_t; using reference = int64_t &; int64_t val, d; Iterator(){}; Iterator(int64_t val, int64_t d) : val(val), d(d){}; value_type operator*() const { return val; } Iterator &operator++() { return val += d, *this; } difference_type operator-(const Iterator &other) const { return (val - other.val) / d; } bool operator==(const Iterator &other) const { return val == other.val; } }; Iterator Begin, End; range(int64_t n) : Begin(0, 1), End(max(n, int64_t{0}), 1){}; range(int64_t a, int64_t b, int64_t d = int64_t(1)) : Begin(a, d), End(b, d) { int64_t cnt = (b - a) / d + bool((b - a) % d); End.val = a + max(cnt, int64_t(0)) * d; }; Iterator begin() const { return Begin; } Iterator end() const { return End; }}; //\ntemplate <typename RET>auto make_vector(RET x) { return x; }template <typename T1, typename T2, typename... Args>auto make_vector(T1 m, T2 n, Args... arg) { return vector(m, make_vector(n, arg...)); }\n/* print */ template <typename Tuple, typename F, size_t... N> void TupleCall(Tuple &t, F &&f, std::index_sequence<N...>) { (f(get<N>(t)), ...); }template <typename... Args>std::ostream &operator<<(std::ostream &out, const std::tuple<Args...> &t) { TupleCall(t, [&](auto &&a) { out << a << ' '; }, make_index_sequence<sizeof...(Args)>{}); return out;}template <typename T1, typename T2>std::ostream &operator<<(std::ostream &out, const std::pair<T1, T2> &t) { return out << t.first << ' ' << t.second; }template <typename T>std::ostream &operator<<(std::ostream &out, const std::vector<T> &v) { for (size_t i = 0, n = v.size(); i < n; ++i) out << v[i] << ' '; return out;}template <typename T, typename... Args>void print(const T &t, const Args &...args) { cout << t; if constexpr (sizeof...(args)) { cout << ' '; print(args...); } else { cout << endl; }} //\nauto io = [](){return cin.tie(nullptr) -> sync_with_stdio(false);}();\n// ##########################################################################################\n template <typename VAL, typename OP, typename UPDATET>\nclass SegmentTree {\n#define SON (2 * i)\n#define A(i) A[i]\npublic:\n    vector<VAL> A;\n    int _queryleft, _queryright;\n    VAL _query(int i, int l, int r) {\n        if(_queryleft <= l && r <= _queryright) return A[i];\n        auto mid = l + (r - l) / 2;\n        if (mid >= _queryright) return _query(SON, l, mid);\n        if (mid < _queryleft) return _query(SON + 1, mid + 1, r);\n        return op(_query(SON, l, mid), _query(SON + 1, mid + 1, r));\n    }\n    int _findRight(int i, int l, int r, int x, auto &&pred) {\n        if (x == l and not pred(A(i))) return findVal = A(i), right + 1;\n        if (x == l and l == r) return findVal = A(i), x;\n        if (l == r) return pred(findVal = op(findVal, A(i))) ? l : right + 1;\n        if (x < l and not pred(op(findVal, A(i)))) return findVal = op(findVal, A(i)), right + 1;\n        auto mid = l + (int64_t(r) - l) / 2;\n        if (mid < x) return _findRight(SON + 1, mid + 1, r, x, pred);\n        int res = _findRight(SON, l, mid, x, pred);\n        if (res != right + 1) return res;\n        return _findRight(SON + 1, mid + 1, r, x, pred);\n    }\n    int _findLeft(int i, int l, int r, int x, auto &&pred) {\n        if (x == r and not pred(A(i))) return findVal = A(i), left - 1;\n        if (x == r and l == r) return findVal = A(i), x;\n        if (l == r) return pred(findVal = op(A(i), findVal)) ? r : left - 1;\n        if (x > r and not pred(op(A(i), findVal))) return findVal = op(A(i), findVal), left - 1;\n        auto mid = l + (int64_t(r) - l) / 2;\n        if (mid >= x) return _findLeft(SON, l, mid, x, pred);\n        int res = _findLeft(SON + 1, mid + 1, r, x, pred);\n        if (res != left - 1) return res;\n        return _findLeft(SON, l, mid, x, pred);\n    }\n\n\n    int n = 0, N = 0, left = 0, right, _right;\n    VAL findVal;\n    OP op;\n    UPDATET updateT;\n    SegmentTree(VAL x, OP op, UPDATET updateT) : op(op), updateT(updateT){};\n    void init(auto &&v) {\n        A.clear();\n        for (auto x : v)\n            A.push_back(x);\n        n = A.size();\n        N = 1 << __lg(2 * n - 1);\n        right = n - 1, _right = N - 1;\n        A.resize(N + n);\n        memcpy(A.data() + N, A.data(), n * sizeof(VAL));\n        for (int L = N, R = N + n - 1; L > 1; L /= 2, R /= 2)\n            for (int i = L; i <= R; i += 2)\n                A(i / 2) = i == R ? A(i) : op(A(i), A(i + 1));\n    }\n    void update(int i, const VAL &b) {\n        updateT(A(i + N), b);\n        for (int I = i + N, R = N + n - 1; I > 1; I /= 2, R /= 2)\n            A(I / 2) = I % 2 == 0 and I == R ? A(I) : op(A(I & ~1), A(I | 1));\n    }\n    VAL &query() { return A(1); }\n    VAL &query(int i) { return A(i + N); }\n    VAL query(int l, int r) {\n        _queryleft = max(l, left), _queryright = min(r, right);\n        assert(_queryleft <= _queryright);\n        return _query(1, left, _right);\n    }\n    int findRight(int x, auto &&pred) { return x > right ? right + 1 : _findRight(1, left, _right, x, pred); }\n    int findLeft(int x, auto &&pred) { return x < left ? left - 1 : _findLeft(1, left, _right, x, pred); }\n#undef SON\n#undef A\n};\nSegmentTree tree(int(), [](int x, int y) { return x + y; }, [](int &a, int b) { a = b; }); // a=b,a+=b\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(); \n        auto get = [&](int i)->int{\n            return i <= 0 or i >= n - 1 ? 0 : nums[i-1] < nums[i] and nums[i+1] < nums[i];\n        };\n        vector<int> tmp(n),res;\n        for(int i : range(n)) tmp[i] = get(i); \n        tree.init(tmp);\n        for(auto &v : queries){\n            if(v[0] == 1){ \n                if(v[1] + 1 > v[2] - 1) res.emplace_back(0); \n                else res.emplace_back(tree.query(v[1]+1,v[2]-1));\n            }else{\n                nums[v[1]] = v[2];\n                for(int i : range(max(v[1]-1,0),min(v[1]+2,n)))\n                    tree.update(i,get(i));\n            }\n            // print(tree.A);\n        }\n        return res;\n    }\n};\n\n// ##########################################################################################\n#ifdef OY_LOCAL\n#include \"./other/FastIO.h\"\n#include \"./other/LeetcodeIO.h\"\nint main() {\n    REGISTER_CONSTRUCTOR_SOLUTION;                             // \u672c\u884c\u586b\u5199\u7c7b\u540d\u3001\u6784\u9020\u51fd\u6570\u7684\u6240\u6709\u53c2\u6570\u7c7b\n    REGISTER_MEMBERFUNCTION_SOLUTION(countOfPeaks); // \u672c\u884c\u586b\u5199\u7c7b\u540d\u3001\u8981\u8c03\u7528\u7684\u6210\u5458\u65b9\u6cd5\u540d\n    while (true) {\n        executor.constructSolution();\n        executor.executeSolution();\n    }\n}\n#endif",
    "submit_ts": "1718506660",
    "subm_id": "539776400"
}