{
    "username": "Cipher_07",
    "submission": "// 1. BIT t(size of the array);\n// 2. t.build(the input array as vector)\n// 3. use 1-based indexing for t.sum(from index, to index) and t.add(index, value to be added);\n\nclass BIT {\n    vector<long long> tree;\n    int N;\n\n    long long sum(int i) {\n        long long ans = 0;\n        for (; i > 0; i -= (i & (-i)))\n            ans += tree[i];\n        return ans;\n    }\n\npublic:\n    BIT(int n) {\n        N = n;\n        tree.resize(n + 1);\n    }\n\n    long long sum(int l, int r) {\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int i, long long x) {\n        for (; i <= N; i += (i & (-i)))\n            tree[i] += x;\n    }\n\n    void build(vector<int> &v) {\n        for (int i = 0; i < N; i++)\n            add(i + 1, v[i]);\n    }\n};\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        BIT bt(n + 1);\n        for (int i = 1; i < n - 1; i++) {\n            if (nums[i] > nums[i + 1] && nums[i] > nums[i - 1])\n                bt.add(i + 1, 1);\n        }\n\n        vector<int> ans;\n        for (auto &q : queries) {\n            if (q[0] == 1) {\n                int c = bt.sum(q[1] + 1, q[2] + 1);\n                // cout << c << endl;\n                if (q[1] > 0 && q[1] < n - 1 && nums[q[1]] > nums[q[1] - 1] && nums[q[1]] > nums[q[1] + 1])\n                    c--;\n                if (q[1] != q[2] && q[2] > 0 && q[2] < n - 1 && nums[q[2]] > nums[q[2] - 1] && nums[q[2]] > nums[q[2] + 1])\n                    c--;\n\n                ans.push_back(c);\n            } else {\n                int i = q[1], x = q[2];\n                if (i > 0 && i < n - 1 && nums[i] > nums[i + 1] && nums[i] > nums[i - 1])\n                    bt.add(i + 1, -1);\n\n                if (i - 1 > 0 && nums[i - 1] > nums[i] && nums[i - 1] > nums[i - 2])\n                    bt.add(i, -1);\n\n                if (i + 1 < n - 1 && nums[i + 1] > nums[i] && nums[i + 1] > nums[i + 2])\n                    bt.add(i + 2, -1);\n\n                nums[i] = x;\n\n                if (i > 0 && i < n - 1 && nums[i] > nums[i + 1] && nums[i] > nums[i - 1])\n                    bt.add(i + 1, 1);\n\n                if (i - 1 > 0 && nums[i - 1] > nums[i] && nums[i - 1] > nums[i - 2])\n                    bt.add(i, 1);\n\n                if (i + 1 < n - 1 && nums[i + 1] > nums[i] && nums[i + 1] > nums[i + 2])\n                    bt.add(i + 2, 1);\n\n            }\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": "1718508191",
    "subm_id": "1289674235"
}