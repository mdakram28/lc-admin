{
    "username": "shik",
    "submission": "// {{{ ModInt\ntemplate<int _MOD>\nstruct ModInt {\n  static const auto MOD = _MOD;\n  template<class T> using integral_only = typename enable_if<is_integral<T>::value>::type;\n\n  int x;\n  constexpr ModInt() : x() {}\n  template<class T, integral_only<T>* = nullptr>\n    ModInt(T _x) {\n      x = _x % MOD;\n      if (x < 0) x += MOD;\n    }\n  ModInt operator-() const { return {x == 0 ? 0 : MOD-x}; }\n  ModInt& operator+=(ModInt rhs) {\n    x += rhs.x;\n    if (x >= MOD) x -= MOD;\n    return *this;\n  }\n  ModInt& operator-=(ModInt rhs) {\n    x -= rhs.x;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  ModInt& operator*=(ModInt rhs) {\n    x = (long long)x * rhs.x % MOD;\n    return *this;\n  }\n  ModInt& operator/=(ModInt rhs) {\n    return *this *= rhs.inv();\n  }\n  ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n  ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n  ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n  ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n  ModInt inv() const {\n    // should work for non-prime MOD if gcd(x, MOD) = 1\n    int a = x, b = MOD, u = 1, v = 0;\n    while (b != 0) {\n      int t = a / b;\n      a -= t * b;\n      u -= t * v;\n      swap(a, b);\n      swap(u, v);\n    }\n    return u;\n  }\n  template<class T, integral_only<T>* = nullptr>\n    ModInt pow(T e) {\n      ModInt r = 1, p = *this;\n      while (e) {\n        if (e & 1) r *= p;\n        p *= p;\n        e >>= 1;\n      }\n      return r;\n    }\n  bool operator==(ModInt rhs) const { return x == rhs.x; }\n  bool operator!=(ModInt rhs) const { return x != rhs.x; }\n  bool operator<(ModInt rhs) const { return x < rhs.x; }\n  bool operator<=(ModInt rhs) const { return x <= rhs.x; }\n  bool operator>(ModInt rhs) const { return x > rhs.x; }\n  bool operator>=(ModInt rhs) const { return x >= rhs.x; }\n  friend string to_string(ModInt i) { return to_string(i.x); }\n  friend ostream& operator<<(ostream &os, ModInt i) { return os << i.x; }\n};\n// }}}\n\nusing mint = ModInt<1000000007>;\n\nconst int N = 1001;\nclass Solution {\n  public:\n    mint dp[2][N];\n    int countOfPairs(vector<int>& nums) {\n      int n = nums.size();\n      dp[0][0] = 1;\n      for (int ii = 0; ii < n; ii++) {\n        int i = ii & 1;\n        int ni = i ^ 1;\n        memset(dp[ni], 0, sizeof(dp[ni]));\n        for (int x = 0; x < N; x++) {\n          auto me = dp[i][x];\n          if (me == 0) continue;\n          int l = x;\n          if (ii > 0) l = max(l, nums[ii] - nums[ii - 1] + x);\n          int r = nums[ii];\n          if (l > r) continue;\n          dp[ni][l] += me;\n          if (r + 1 < N) dp[ni][r + 1] -= me;\n        }\n        for (int x = 1; x < N; x++) {\n          dp[ni][x] += dp[ni][x - 1];\n        }\n      }\n      mint ans = 0;\n      for (int i = 0; i < N; i++) {\n        ans += dp[n & 1][i];\n      }\n      return ans.x;\n    }\n};\n",
    "submit_ts": "1723345591",
    "subm_id": "1351559065"
}