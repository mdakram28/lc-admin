{
    "username": "OTTFF",
    "submission": "template<long long Mo=998244353> struct ModInt {\n  static long long MO;\n  static void setMo(long long mo) { MO = mo; }\n  long long x;\n  ModInt(long long x=0) : x(x){ norm(); }\n  friend istream &operator>>(istream& in, ModInt &B) { in>>B.x; return in; }\n  friend ostream &operator<<(ostream& out, const ModInt &B) { \n    out<<B.x; return out; }\n  // ModInt operator=(int x_) { x=x_; norm(); return *this; }\n  void norm() { x = (x%MO + MO) % MO; }\n  long long get() { return x; }\n\n  ModInt operator-() const { return ModInt(MO - x); }\n  ModInt operator+=(const ModInt &B) { x+=B.x; if(x>=MO) x-=MO; return *this; }\n  ModInt operator-=(const ModInt &B) { x-=B.x; if(x<0) x+=MO; return *this; }\n  ModInt operator*=(const ModInt &B) { x=x*B.x%MO; return *this; }\n  ModInt operator+(const ModInt &B) const { ModInt ans=*this; return ans+=B; }\n  ModInt operator-(const ModInt &B) const { ModInt ans=*this; return ans-=B; }\n  ModInt operator*(const ModInt &B) const { ModInt ans=*this; return ans*=B; }\n  ModInt operator^(long long n) const  {\n    ModInt a=*this; ModInt ans(1);\n    while(n) { if(n&1) ans*=a; a*=a; n>>=1; }\n    return ans;\n  }\n  ModInt inv() const { return (*this)^(MO-2); } // if MO is prime\n  ModInt operator/=(const ModInt &B) { (*this)*=B.inv(); return *this; }\n  ModInt operator/(const ModInt &B) const { ModInt ans=*this; return ans/=B; }\n\n  bool operator<(const ModInt &B) const { return x<B.x; }\n  bool operator==(const ModInt &B) const { return x==B.x; }\n  bool operator!=(const ModInt &B) const { return x!=B.x; }\n};\ntemplate<long long Mo> long long ModInt<Mo>::MO = Mo;\n// typedef ModInt<998244353> Mint;\ntypedef ModInt<1'000'000'007> Mint;\nclass Solution {\npublic:\n/*\ndp[i][j] after i the last in a is j\ndp[i + 1][k]\nk = j ~ nums[i + 1]\n\nlast in b is nums[i] - j\nnums[i] - j >= nums[i + 1] - k\nk >= nums[i + 1] - nums[i] + j\n*/\n    int countOfPairs(vector<int>& nums) {\n        int n = nums.size();\n        int mx = 0;\n        for (int i : nums) {\n            mx = max(mx, i);\n        }\n        vector<Mint> dp(mx + 2, 0), tmp;\n        for (int i = 0; i <= nums[0]; i++) {\n            dp[i] = 1;\n        }\n\n        for (int i = 0; i < n - 1; i++) {\n            tmp = dp;\n            for (int j = 0; j <= mx; j++) dp[j] = 0;\n\n            for (int j = 0; j <= nums[i]; j++) {\n                int k = max(j, nums[i + 1] - nums[i] + j);\n                // cout << \"    \" << j << ' ' << k << ' ' << nums[i + 1] << endl;\n                if (k <= nums[i + 1]) {\n                    dp[k] += tmp[j];\n                    dp[nums[i + 1] + 1] -= tmp[j];\n                }\n            }\n            for (int j = 1; j <= mx; j++) {\n                dp[j] += dp[j - 1];\n            }\n            // for (int j = 0; j <= mx; j++) {\n            //     cout << dp[j] << ' ';\n            // }\n            // cout << endl;\n        }\n\n        Mint ans = 0;\n        for (int i = 0; i <= mx; i++) {\n            ans += dp[i];\n        }\n        return ans.x;\n    }\n};",
    "submit_ts": "1723344788",
    "subm_id": "1351542043"
}