{
    "username": "IceKnight1093",
    "submission": "/**\n * Disjoint Set\n * Source: Adapted from Aeren and Atcoder Library\n * Description: Data structure to keep a collection of disjoint sets which contain the elements {0, 1, ..., n-1}\n *              Implements both path compression and union by size\n * Methods:\n * (1) int get_root(int u): Find a representative of the set containing u\n * (2) int size(int u): Returns the size of the set containing u\n * (3) bool same_set(int u, int v): Check whether u and v are in the same set\n * (4) bool merge(int u, int v): Merge the sets containing u and v if they are different, returns success of merge\n * (5) vector group_up(): Returns the collection of disjoint sets as a vector of vectors\n * \n * Time: Amortized O(n alpha(n)) for n operations\n * Space: O(n)\n * Tested on Codeforces EDU\n */\n\nstruct DSU {\nprivate:\n\tstd::vector<int> parent_or_size;\npublic:\n\tDSU(int n = 1): parent_or_size(n, -1) {}\n\tint get_root(int u) {\n\t\tif (parent_or_size[u] < 0) return u;\n\t\treturn parent_or_size[u] = get_root(parent_or_size[u]);\n\t}\n\tint size(int u) { return -parent_or_size[get_root(u)]; }\n\tbool same_set(int u, int v) {return get_root(u) == get_root(v); }\n\tbool merge(int u, int v) {\n\t\tu = get_root(u), v = get_root(v);\n\t\tif (u == v) return false;\n\t\tif (parent_or_size[u] > parent_or_size[v]) std::swap(u, v);\n\t\tparent_or_size[u] += parent_or_size[v];\n\t\tparent_or_size[v] = u;\n\t\treturn true;\n\t}\n\tstd::vector<std::vector<int>> group_up() {\n\t\tint n = parent_or_size.size();\n\t\tstd::vector<std::vector<int>> groups(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tgroups[get_root(i)].push_back(i);\n\t\t}\n\t\tgroups.erase(std::remove_if(groups.begin(), groups.end(), [&](auto &s) { return s.empty(); }), groups.end());\n\t\treturn groups;\n\t}\n};\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n        DSU D(n+4);\n        using ll = long long int;\n\n        for (int i = 0; i < n; ++i) {\n            int x1 = circles[i][0], y1 = circles[i][1], r1 = circles[i][2];\n            for (int j = i+1; j < n; ++j) {\n                int x2 = circles[j][0], y2 = circles[j][1], r2 = circles[j][2];\n\n                // intersect if dist((x1, y1), (x2, y2)) <= r1 + r2\n                ll d = 1ll*(x1-x2)*(x1-x2) + 1ll*(y1-y2)*(y1-y2);\n                ll d2 = 1ll*(r1+r2)*(r1+r2);\n                if (d <= d2) D.merge(i, j);\n            }\n\n            for (int x : {0, X}) {\n                // (x-x1)^2 + (y-y1)^2 = r1^2\n                if (abs(x-x1) > r1) continue;\n\n                ll d = 1ll*r1*r1 - 1ll*(x-x1)*(x-x1);\n                long double rt = sqrtl(d);\n                \n                long double lo = y1 - rt, hi = y1 + rt;\n\n                if (lo >= Y or hi <= 0) continue;\n                if (x == 0) D.merge(i, n);\n                else D.merge(i, n+1);\n            }\n\n            for (int y : {0, Y}) {\n                if (abs(y-y1) > r1) continue;\n\n                ll d = 1ll*r1*r1 - 1ll*(y-y1)*(y-y1);\n                long double rt = sqrtl(d);\n                \n                long double lo = x1 - rt, hi = x1 + rt;\n\n                if (lo >= X or hi <= 0) continue;\n                if (y == 0) D.merge(i, n+2);\n                else D.merge(i, n+3);\n            }\n        }\n\n        if (D.same_set(n, n+1) or D.same_set(n, n+2) or D.same_set(n+2, n+3) or D.same_set(n+1, n+3)) return false;\n        return true;\n    }\n};",
    "submit_ts": "1722135301",
    "subm_id": "1335696999"
}