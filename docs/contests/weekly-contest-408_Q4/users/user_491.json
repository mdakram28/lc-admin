{
    "username": "vrangr",
    "submission": "typedef long long int ll;\n#define top 0\n#define right 1\n#define down 2\n#define left 3\nclass DSU {\npublic:\n    ll n;\n    vector<ll> parent, rank;\n    DSU(ll gn) : parent(gn,-1), rank(gn,1) {\n        n = gn;\n    }\n    \n    ll find(ll x) {\n        if (parent[x] == -1) return x;\n        return parent[x] = find(parent[x]);\n    }\n    \n    void unite(ll x, ll y) {\n        ll px = find(x), py = find(y);\n        if (px == py) return;\n        if (rank[px] > rank[py]) swap(px,py);\n        parent[px] = py;\n        if (rank[px] == rank[py]) ++rank[py];\n    }\n};\nclass Solution {\npublic:\n    bool canReachCorner(ll tx, int ty, vector<vector<int>>& circles) {\n        auto inside = [](ll x, ll y, ll r, ll tx, ll ty) -> bool {\n            return (x-tx)*(x-tx) + (y-ty)*(y-ty) <= r*r;\n        };\n        for (auto &c : circles) {\n            ll x = c[0], y = c[1], r = c[2];\n            if (inside(x,y,r,0,0) || inside(x,y,r,tx,ty)) return false;\n        }\n        ll n = circles.size();\n        auto insiderect = [&](ll i) -> bool {\n            auto &c = circles[i];\n            ll x = c[0], y = c[1], r = c[2];\n            if (x >= 0 && x <= tx && y >= 0 && y <= ty) return true;\n            return llabs(x-tx) <= r || x <= r || y <= r || llabs(y-ty) <= r;\n        };\n        DSU dsu(n);\n        for (ll i = 0; i < n; ++i) {\n            auto &c1 = circles[i];\n            ll x1 = c1[0], y1 = c1[1], r1 = c1[2];\n            for (ll j = i+1; j < n; ++j) {\n                auto &c2 = circles[j];\n                ll x2 = c2[0], y2 = c2[1], r2 = c2[2];\n                if ((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) > r1*r1 + r2*r2 + 2ll*r1*r2) continue;\n                if (!insiderect(i) || !insiderect(j)) continue;\n                dsu.unite(i,j);\n            }\n        }\n        // vector<vector<vector<ll>>> cs(4);\n        vector<vector<ll>> cs(4);\n        for (ll i = 0; i < n; ++i){\n            auto &c = circles[i];\n            ll x = c[0], y = c[1], r = c[2];\n            if (llabs(x-tx) > r && x > r && llabs(y-ty) > r && llabs(y) > r) continue;\n            bool tp = false, lt = false, rt = false, dn = false;\n            if (llabs(x-tx) <= r) {\n                // cs[top].push_back({x,y,r});\n                cs[top].push_back(i);\n                tp = true;\n            }\n            if (x <= r) {\n                // cs[down].push_back({x,y,r});\n                cs[down].push_back(i);\n                dn = true;\n            }\n            if (llabs(y-ty) <= r) {\n                // cs[right].push_back({x,y,r});\n                cs[right].push_back(i);\n                rt = true;\n            }\n            if (y <= r) {\n                // cs[left].push_back({x,y,r});\n                cs[left].push_back(i);\n                lt = true;\n            }\n            if (tp && dn) return false;\n            if (lt && rt) return false;\n            if (tp && rt) return false;\n            if (lt && dn) return false;\n        }\n        auto check = [&](ll d1, ll d2) -> bool {\n            // for (auto &ic1 : cs[d1]) {\n            //     auto &c1 = circles[ic1];\n            //     ll x1 = c1[0], y1 = c1[1], r1 = c1[2];\n            //     for (auto &ic2 : cs[d2]) {\n            //         auto &c2 = circles[ic2];\n            //         ll x2 = c2[0], y2 = c2[1], r2 = c2[2];\n            //         if ((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) <= r1*r1 + r2*r2 + 2ll*r1*r2) return true;\n            //     }\n            // }\n            for (auto &ic1 : cs[d1]) {\n                for (auto &ic2 : cs[d2]) {\n                    if (dsu.find(ic1) == dsu.find(ic2)) return true;\n                }\n            }\n            return false;\n        };\n        if (check(top,down) || check(left,right)) return false;\n        auto comp = [](ll x1, ll y1, ll x2, ll y2, ll cx, ll cy) -> ll {\n            return (cy-y1)*(x2-x1) - (cx-x1)*(y2-y1);\n        };\n        auto sameside = [&comp](ll x1, ll y1, ll x2, ll y2, ll cx1, ll cy1, ll cx2, ll cy2) -> bool {\n            ll c1 = comp(x1,y1,x2,y2,cx1,cy1), c2 = comp(x1,y1,x2,y2,cx2,cy2);\n            return (c1 > 0 && c2 > 0) || (c1 < 0 && c2 < 0);\n        };\n        for (auto &ic1 : cs[top]) {\n            // auto &c1 = circles[ic1];\n            // ll x1 = c1[0], y1 = c1[1], r1 = c1[2];\n            for (auto &ic2 : cs[right]) {\n                // auto &c2 = circles[ic2];\n                if (dsu.find(ic1) == dsu.find(ic2)) return false;\n                // ll x2 = c2[0], y2 = c2[1], r2 = c2[2];\n                // if ((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) > r1*r1 + r2*r2 + 2ll*r1*r2) continue;\n                // if (sameside(x1,y1,x2,y2,0,0,tx,ty)) continue;\n                // return false;\n            }\n        }\n        for (auto &ic1 : cs[left]) {\n            // auto &c1 = circles[ic1];\n            // ll x1 = c1[0], y1 = c1[1], r1 = c1[2];\n            for (auto &ic2 : cs[down]) {\n                if (dsu.find(ic2) == dsu.find(ic1)) return false;\n                // auto &c2 = circles[ic2];\n                // ll x2 = c2[0], y2 = c2[1], r2 = c2[2];\n                // if ((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) > r1*r1 + r2*r2 + 2ll*r1*r2) continue;\n                // if (sameside(x1,y1,x2,y2,0,0,tx,ty)) continue;\n                // return false;\n            }\n        }\n        return true;\n    }\n};\n/*\n\n5\n8\n[[4,7,1]]\nfalse\n\n6\n13\n[[1,5,1],[1,5,1],[5,7,1],[3,7,2],[5,5,1],[2,10,1],[2,1,1]]\nfalse\n\n3\n4\n[[2,1,1]]\n3\n3\n[[1,1,2]]\n3\n3\n[[2,1,1],[1,2,1]]\n5\n8\n[[4,7,1]]\n6\n13\n[[1,5,1],[1,5,1],[5,7,1],[3,7,2],[5,5,1],[2,10,1],[2,1,1]]\n*/",
    "submit_ts": "1722137003",
    "subm_id": "1335751296"
}