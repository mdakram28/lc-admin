{
    "username": "Sandeep_P",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        \n        g=defaultdict(list)\n        for x,y in edges1:\n            g[x].append(y)\n            g[y].append(x)\n        g2=defaultdict(list)\n        for x,y in edges2:\n            g2[x].append(y)\n            g2[y].append(x)\n        \n        def bfs(start, g):\n            visited = {}\n            queue = deque([(start, 0)])\n            farthest_node = start\n            max_dist = 0\n            \n            while queue:\n                current, dist = queue.popleft()\n                visited[current] = dist\n                \n                for neighbor in g[current]:\n                    if neighbor not in visited:\n                        queue.append((neighbor, dist + 1))\n                        if dist + 1 > max_dist:\n                            max_dist = dist + 1\n                            farthest_node = neighbor\n            \n            return farthest_node, max_dist\n        \n        def helper(g):\n            a,_=bfs(0,g)\n            b,d=bfs(a,g)\n            return a,b,d\n        \n        a,b,d1=helper(g)\n        c,d,d2=helper(g2)\n        return max(d1,d2,d1-(d1//2)+d2-(d2//2)+1)",
    "submit_ts": "1719718558",
    "subm_id": "1304420275"
}