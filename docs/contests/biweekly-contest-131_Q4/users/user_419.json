{
    "username": "e7x0pbWqIm",
    "submission": "typedef long long ll;\nstruct seg_tree\n{\n    vector<ll> seg;\n \npublic:\n    seg_tree(int n)\n    {\n        seg.resize(4 * n + 1, 0);\n    }\n \n    void build(int ind, int low, int high, vector<ll> &arr)\n    {\n        if (low == high)\n        {\n            seg[ind] = arr[low];\n            return;\n        }\n \n        int mid = (low + high) / 2;\n        build(2 * ind + 1, low, mid, arr);\n        build(2 * ind + 2, mid + 1, high, arr);\n \n        seg[ind] = max(seg[2 * ind + 1] , seg[2 * ind + 2]);\n    }\n \n    void update(int ind, int low, int high, int i, ll val)\n    {\n        if (low == high)\n        {\n            seg[ind] = val;\n            return;\n        }\n \n        int mid = (low + high) / 2;\n \n        if (i <= mid)\n            update(2 * ind + 1, low, mid, i, val);\n        else\n            update(2 * ind + 2, mid + 1, high, i, val);\n \n        seg[ind] = max(seg[2 * ind + 1] , seg[2 * ind + 2]);\n    }\n \n    ll query(int ind, int low, int high, int l, int r)\n    {\n        if (r < low || high < l)\n            return 0;\n \n        if (low >= l && high <= r)\n            return seg[ind];\n \n        int mid = (low + high) / 2;\n \n        ll left = query(2 * ind + 1, low, mid, l, r);\n        ll right = query(2 * ind + 2, mid + 1, high, l, r);\n \n        return max(left , right);\n    }\n};\n \n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector<bool>ans;\n        set<int>blocked_states;\n\n        int n = 100000;\n        blocked_states.insert(0);\n        blocked_states.insert(n);\n\n        seg_tree st(n);\n        st.update(0,0,n-1,0,n);\n\n        for(auto &x : queries){\n            if(x[0] == 1){\n                int curr_cell = x[1];\n                auto it = blocked_states.lower_bound(curr_cell);\n                int next_block_cell = *(it);\n                int prev_block_cell = *(--it);\n\n                \n\n                st.update(0,0,n-1,prev_block_cell,curr_cell - prev_block_cell);\n                st.update(0,0,n-1,curr_cell,next_block_cell - curr_cell);\n\n                blocked_states.insert(curr_cell);\n            }else{\n                int curr_cell = x[1],syz = x[2];\n                \n                 auto it = blocked_states.lower_bound(curr_cell);\n                int next_block_cell = *(it);\n                int prev_block_cell = *(--it);\n\n                if(next_block_cell == curr_cell){\n                     int mx_avail_space = st.query(0,0,n-1,0,curr_cell - 1);\n                     ans.push_back(mx_avail_space >= syz);\n                }else{\n\n                int mx_avail_space = st.query(0,0,n-1,0,prev_block_cell - 1);\n\n                mx_avail_space = max(mx_avail_space,curr_cell - prev_block_cell);\n\n                ans.push_back(mx_avail_space >= syz);\n\n                }\n\n            }\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": 1716652569.0
}