{
    "username": "shchen527",
    "submission": "class Solution {\npublic:\n    int f(vector<vector<int>>& edges) {\n        int l = edges.size();\n        vector<bool> visited(l + 1, false);\n\n        vector<vector<int>> e(l + 1);\n        for (const auto& ed : edges) {\n            e[ed[0]].push_back(ed[1]);\n            e[ed[1]].push_back(ed[0]);\n        }\n\n        queue<int> q;\n        q.push(0);\n        visited[0] = true;\n\n        int last = 0;\n        while (!q.empty()) {\n            last = q.front();\n            q.pop();\n            for (int next : e[last]) {\n                if (!visited[next]) {\n                    visited[next] = true;\n                    q.push(next);\n                }\n            }\n        }\n\n        int u = last;\n\n        for (int i = 0; i <= l; ++i) {\n            visited[i] = false;\n        }\n\n        visited[last] = true;\n        q.push(last);\n        q.push(-1);\n\n        vector<int> prev(l + 1, -1);\n        int len = 0;\n        while (!q.empty()) {\n            last = q.front();\n            q.pop();\n\n            if (last == -1) {\n                ++len;\n                if (!q.empty()) {\n                    q.push(-1);\n                }\n                continue;\n            }\n\n            for (int next : e[last]) {\n                if (!visited[next]) {\n                    visited[next] = true;\n                    q.push(next);\n                    prev[next] = last;\n                }\n            }\n        }\n\n        int v = last;\n        return len;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int len1 = f(edges1);\n        int len2 = f(edges2);\n\n        return max(max(len1 - 1, len2 - 1), len1 / 2 + len2 / 2 + 1);\n    }\n};",
    "submit_ts": 1719718423.0
}