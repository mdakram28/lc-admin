{
    "username": "snamy520",
    "submission": "impl Solution {\n        pub fn minimum_distance(points: Vec<Vec<i32>>) -> i32 {\n            let mut ms_x_add_y = MultiSet::new();\n            let mut ms_x_sub_y = MultiSet::new();\n            for pt in points.iter() {\n                let (x, y) = (pt[0], pt[1]);\n                ms_x_add_y.insert(x + y);\n                ms_x_sub_y.insert(x - y);\n            }\n            let mut res = i32::MAX;\n            for pt in points.iter() {\n                let (x, y) = (pt[0], pt[1]);\n                ms_x_add_y.remove(&(x + y));\n                ms_x_sub_y.remove(&(x - y));\n                let cur1 = ms_x_add_y.last().unwrap() - ms_x_add_y.first().unwrap();\n                let cur2 = ms_x_sub_y.last().unwrap() - ms_x_sub_y.first().unwrap();\n                res = res.min(cur1.max(cur2));\n                ms_x_add_y.insert(x + y);\n                ms_x_sub_y.insert(x - y);\n            }\n            res\n        }\n}\n        use std::collections::{btree_map::Entry, BTreeMap};\n\n        #[derive(Debug)]\n        pub struct MultiSet<T> {\n            inner: BTreeMap<T, usize>,\n            n: usize,\n        }\n\n        impl<T> MultiSet<T>\n        where\n            T: Ord + Clone,\n        {\n            pub fn new() -> Self {\n                Self {\n                    inner: BTreeMap::new(),\n                    n: 0,\n                }\n            }\n\n            pub fn len(&self) -> usize {\n                self.n\n            }\n\n            pub fn clear(&mut self) {\n                self.inner.clear();\n                self.n = 0;\n            }\n\n            pub fn contains(&self, d: &T) -> bool {\n                self.inner.contains_key(&d)\n            }\n\n            pub fn first(&self) -> Option<&T> {\n                self.inner.first_key_value().map(|(k, _)| k)\n            }\n\n            pub fn last(&self) -> Option<&T> {\n                self.inner.last_key_value().map(|(k, _)| k)\n            }\n\n            pub fn insert(&mut self, d: T) {\n                self.inner.entry(d).and_modify(|c| *c += 1).or_insert(1);\n                self.n += 1;\n            }\n\n            pub fn remove(&mut self, d: &T) -> bool {\n                let k = d.clone();\n                match self.inner.entry(k) {\n                    Entry::Vacant(e) => false,\n                    Entry::Occupied(mut e) => {\n                        self.n -= 1;\n                        if *e.get() == 1 {\n                            e.remove();\n                        } else {\n                            *e.get_mut() -= 1;\n                        }\n                        true\n                    }\n                }\n            }\n\n            pub fn pop_first(&mut self) -> Option<T> {\n                if let Some(mut e) = self.inner.first_entry() {\n                    self.n -= 1;\n                    Some(if *e.get() == 1 {\n                        e.remove_entry().0\n                    } else {\n                        *e.get_mut() -= 1;\n                        e.key().clone()\n                    })\n                } else {\n                    None\n                }\n            }\n\n            pub fn pop_last(&mut self) -> Option<T> {\n                if let Some(mut e) = self.inner.last_entry() {\n                    self.n -= 1;\n                    Some(if *e.get() == 1 {\n                        e.remove_entry().0\n                    } else {\n                        *e.get_mut() -= 1;\n                        e.key().clone()\n                    })\n                } else {\n                    None\n                }\n            }\n        }"
}