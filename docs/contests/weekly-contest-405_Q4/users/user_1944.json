{
    "username": "rastsislau",
    "submission": "class Solution {\npublic:\n    class TrieNode {\n    public:\n        array<TrieNode*, 26> children;\n        int cost;\n\n        TrieNode() {\n            cost = 1e9;\n            fill(children.begin(), children.end(), nullptr);\n        }\n    };\n\n    void addWord(TrieNode* root, const string& s, int cost) {\n        TrieNode* cur = root;\n        for (char x : s) {\n            if (cur->children[x - 'a'] == nullptr) {\n                cur->children[x - 'a'] = new TrieNode();\n            }\n            cur = cur->children[x - 'a'];\n        }\n        cur->cost = min(cost, cur->cost);\n    }\n\n    void deleteTrie(TrieNode* root) {\n        for (int i = 0; i < 26; ++i) {\n            if (root->children[i] != nullptr) {\n                deleteTrie(root->children[i]);\n            }\n        }\n        delete root;\n    }\n\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        TrieNode* trie = new TrieNode();\n        int n1 = words.size();\n        for (int i = 0; i < n1; i++) {\n            addWord(trie, words[i], costs[i]);\n        }\n\n        int n = target.size();\n        vector <int> dp(n+1,2e9);\n        dp[0] = 0;\n        for (int i = 0; i < n; i++) {\n            TrieNode* cur = trie;\n            int j = i;\n            while (j < target.size() && cur->children[target[j] - 'a'] != nullptr) {\n                cur = cur->children[target[j] - 'a'];\n                if (cur->cost < 1e7) {\n                    dp[j+1] = min(dp[j+1], dp[i] + cur->cost);\n                }\n                j++;\n            }\n        }\n\n        if (dp[n] >= 2e9)\n        {\n            return -1;\n        }\n\n        return dp[n];\n        /*\n\n        deleteTrie(trie);\n\n        vector<int> d (n+1, 1e9);\n        d[0] = 0;\n\n        auto comparator = [&d](int left, int right) {\n            return d[left] < d[right] || (d[left] == d[right] && left < right);\n        };\n        set<int, decltype(comparator)> q(comparator);\n        q.insert(0);\n\n        while (!q.empty()) {\n            int v = *q.begin();\n            q.erase(q.begin());\n\n           //cout << v << \" \" << d[v] << endl;\n\n            if (v == n) {\n                return d[n];\n            }\n            for (const auto& edge : g[v]) {\n                int to = edge.first, len = edge.second;\n               // cout << v << \" - \" << to << \" cur : \" << d[to] << \" new : \" << d[v] + len << endl;\n                if (d[v] + len < d[to]) {\n                    d[to] = d[v] + len;\n                    q.insert(to);\n                }\n            }\n        }\n        return -1;\n        */\n    }\n};\n",
    "submit_ts": "1720323842",
    "subm_id": "1312385356"
}