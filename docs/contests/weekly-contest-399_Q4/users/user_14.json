{
    "username": "STARs_56789",
    "submission": "#ifndef LOCAL\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nnamespace mitsuha {\ntemplate <class T> bool chmin(T& x, const T& y) { return y >= x ? false : (x = y, true); }\ntemplate <class T> bool chmax(T& x, const T& y) { return y <= x ? false : (x = y, true); }\ntemplate <class T> constexpr T floor(const T x, const T y) { T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); }\ntemplate <class T> constexpr T ceil(const T x, const T y) { T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); }\ntemplate <class T> constexpr T bmod(const T x, const T y) { return x - y * floor(x, y); }\n}\n\nnamespace mitsuha::macro {\n#define IMPL_REPITER(cond) auto& begin() { return *this; } auto end() { return nullptr; } auto& operator*() { return _val; } auto& operator++() { return _val += _step, *this; } bool operator!=(std::nullptr_t) { return cond; }\ntemplate <class Int, class IntL = Int, class IntStep = Int, std::enable_if_t<(std::is_signed_v<Int> == std::is_signed_v<IntL>), std::nullptr_t> = nullptr> struct rep_impl {\n    Int _val; const Int _end, _step;\n    rep_impl(Int n) : rep_impl(0, n) {}\n    rep_impl(IntL l, Int r, IntStep step = 1) : _val(l), _end(r), _step(step) {}\n    IMPL_REPITER((_val < _end))\n};\ntemplate <class Int, class IntL = Int, class IntStep = Int, std::enable_if_t<(std::is_signed_v<Int> == std::is_signed_v<IntL>), std::nullptr_t> = nullptr> struct rrep_impl {\n    Int _val; const Int _end, _step;\n    rrep_impl(Int n) : rrep_impl(0, n) {}\n    rrep_impl(IntL l, Int r) : _val(r - 1), _end(l), _step(-1) {}\n    rrep_impl(IntL l, Int r, IntStep step) : _val(l + floor<Int>(r - l - 1, step) * step), _end(l), _step(-step) {}\n    IMPL_REPITER((_val >= _end))\n};\n#undef IMPL_REPITER\n}\n\n#include <unistd.h>\nnamespace mitsuha::io {\nstatic constexpr uint32_t SZ = 1 << 17;\nchar ibuf[SZ], obuf[SZ], out[100];\nuint32_t pil = 0, pir = 0, por = 0;\nstruct Pre {\n    char num[10000][4];\n    constexpr Pre() : num() {\n        for (int i = 0; i < 10000; i++) {\n            int n = i;\n            for (int j = 3; j >= 0; j--) { num[i][j] = n % 10 | '0'; n /= 10; }\n        }\n    }\n} constexpr pre;\n\ninline void load() {\n    memcpy(ibuf, ibuf + pil, pir - pil);\n    pir = pir - pil + fread(ibuf + pir - pil, 1, SZ - pir + pil, stdin);\n    pil = 0;\n}\ninline void flush() { fwrite(obuf, 1, por, stdout); por = 0; }\n\nvoid rd(char &c) { do { if (pil + 1 > pir) load(); c = ibuf[pil++]; } while (isspace(c)); }\nvoid rd(std::string &x) {\n    x.clear(); char c;\n    do { if (pil + 1 > pir) load(); c = ibuf[pil++]; } while (isspace(c));\n    do { x += c; if (pil == pir) load(); if (pil == pir) break; c = ibuf[pil++]; } while (!isspace(c));\n}\ntemplate <typename T> void rd_real(T &x) { std::string s; rd(s); x = stod(s); }\ntemplate <typename T>\nvoid rd_integer(T &x) {\n    if (pil + 100 > pir) load();\n    char c;\n    do { c = ibuf[pil++]; }while (c < '-');\n    bool minus = 0;\n    if constexpr (std::is_signed<T>::value || std::is_same_v<T, __int128>) { if (c == '-') { minus = 1, c = ibuf[pil++]; } }\n    x = 0;\n    while (c >= '0') { x = x * 10 + (c & 15), c = ibuf[pil++]; }\n    if constexpr (std::is_signed<T>::value || std::is_same_v<T, __int128>) { if (minus) x = -x; }\n}\n\nvoid rd(int &x) { rd_integer(x); }\nvoid rd(long int x) { rd_integer(x); }\nvoid rd(long long &x) { rd_integer(x); }\nvoid rd(__int128 &x) { rd_integer(x); }\nvoid rd(unsigned int &x) { rd_integer(x); }\nvoid rd(unsigned long long &x) { rd_integer(x); }\nvoid rd(unsigned __int128 &x) { rd_integer(x); }\nvoid rd(double &x) { rd_real(x); }\nvoid rd(long double &x) { rd_real(x); }\nvoid rd(__float128 &x) { rd_real(x); }\n    \ntemplate <class T, class U> void rd(std::pair<T, U> &p) { return rd(p.first), rd(p.second); }\ntemplate <size_t N = 0, typename T>\nvoid rd(T &t) { if constexpr (N < std::tuple_size<T>::value) { auto &x = std::get<N>(t); rd(x); rd<N + 1>(t); } }\ntemplate <class... T> void rd(std::tuple<T...> &tpl) { rd(tpl); }\ntemplate <size_t N = 0, typename T> void rd(std::array<T, N> &x) { for (auto &d: x) rd(d); }\ntemplate <class T> void rd(std::vector<T> &x) { for (auto &d: x) rd(d); }\n\nvoid read() {}\ntemplate <class H, class... T> void read(H &h, T &... t) { rd(h), read(t...); }\n\nvoid wt(const char c) { if (por == SZ) flush(); obuf[por++] = c; }\nvoid wt(const std::string &s) { for (char c: s) wt(c); }\nvoid wt(const char *s) { size_t len = strlen(s); for (size_t i = 0; i < len; i++) wt(s[i]); }\ntemplate <typename T> void wt_integer(T x) {\n    if (por > SZ - 100) flush();\n    if (x < 0) { obuf[por++] = '-', x = -x; }\n    int outi;\n    for (outi = 96; x >= 10000; outi -= 4) { memcpy(out + outi, pre.num[x % 10000], 4); x /= 10000; }\n    if (x >= 1000) { memcpy(obuf + por, pre.num[x], 4); por += 4; } \n    else if (x >= 100) { memcpy(obuf + por, pre.num[x] + 1, 3); por += 3; } \n    else if (x >= 10) { int q = (x * 103) >> 10; obuf[por] = q | '0'; obuf[por + 1] = (x - q * 10) | '0'; por += 2; } \n    else obuf[por++] = x | '0';\n    memcpy(obuf + por, out + outi + 4, 96 - outi); por += 96 - outi;\n}\ntemplate <typename T>\nvoid wt_real(T x) {\n    std::ostringstream oss; oss << std::fixed << std::setprecision(15) << double(x);\n    std::string s = oss.str(); wt(s);\n}\nvoid wt(int x) { wt_integer(x); }\nvoid wt(long int x) { wt_integer(x); }\nvoid wt(long long x) { wt_integer(x); }\nvoid wt(__int128 x) { wt_integer(x); }\nvoid wt(unsigned int x) { wt_integer(x); }\nvoid wt(unsigned long long x) { wt_integer(x); }\nvoid wt(unsigned __int128 x) { wt_integer(x); }\nvoid wt(double x) { wt_real(x); }\nvoid wt(long double x) { wt_real(x); }\nvoid wt(__float128 x) { wt_real(x); }\n    \ntemplate <class T, class U> void wt(const std::pair<T, U> val) { wt(val.first); wt(' '); wt(val.second); }\ntemplate <size_t N = 0, typename T> void wt_tuple(const T t) {\n    if constexpr (N < std::tuple_size<T>::value) {\n        if constexpr (N > 0) { wt(' '); }\n        const auto x = std::get<N>(t);\n        wt(x); wt_tuple<N + 1>(t);\n    }\n}\ntemplate <class... T> void wt(std::tuple<T...> tpl) { wt_tuple(tpl); }\ntemplate <class T, size_t S> void wt(const std::array<T, S> val) {\n    auto n = val.size(); for (size_t i = 0; i < n; i++) { if (i) wt(' '); wt(val[i]); }\n}\ntemplate <class T> void wt(const std::vector<T> val) {\n    auto n = val.size(); for (size_t i = 0; i < n; i++) { if (i) wt(' '); wt(val[i]); }\n}\n\nvoid print() { wt('\\n'); }\ntemplate <class Head, class... Tail>\nvoid print(Head &&head, Tail &&... tail) { wt(head); if (sizeof...(Tail)) wt(' '); print(std::forward<Tail>(tail)...); }\nvoid __attribute__((destructor)) _d() { flush(); }\n} // namespace mitsuha::io\nnamespace mitsuha{ using io::read; using io::print; using io::flush; }\n\nnamespace mitsuha {\ntemplate <class T, class ToKey, class CompKey = std::less<>, std::enable_if_t<std::conjunction_v<std::is_invocable<ToKey, T>, std::is_invocable_r<bool, CompKey, std::invoke_result_t<ToKey, T>, std::invoke_result_t<ToKey, T>>>, std::nullptr_t> = nullptr>\nauto lambda(const ToKey& to_key, const CompKey& comp_key = std::less<>()) {\n    return [=](const T& x, const T& y) { return comp_key(to_key(x), to_key(y)); };\n}\ntemplate <class Compare, std::enable_if_t<std::is_invocable_r_v<bool, Compare, int, int>, std::nullptr_t> = nullptr>\nstd::vector<int> sorted_indices(int n, const Compare& compare) {\n    std::vector<int> p(n);\n    return std::iota(p.begin(), p.end(), 0), std::sort(p.begin(), p.end(), compare), p;\n}\ntemplate <class ToKey, std::enable_if_t<std::is_invocable_v<ToKey, int>, std::nullptr_t> = nullptr>\nstd::vector<int> sorted_indices(int n, const ToKey& to_key) { return sorted_indices(n, lambda<int>(to_key)); }\n\ntemplate <typename T, typename Gen>\nauto generate_vector(int n, Gen generator) { std::vector<T> v(n); for (int i = 0; i < n; ++i) v[i] = generator(i); return v; }\ntemplate <typename T> auto generate_range(T l, T r) { return generate_vector<T>(r - l, [l](int i) { return l + i; }); }\ntemplate <typename T> auto generate_range(T n) { return generate_range<T>(0, n); }\n\ntemplate <class Iterable>\nvoid settify(Iterable& a) { std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); }\n\ntemplate <size_t D> struct Dim : std::array<int, D> {\n    template <typename ...Ints> Dim(const Ints& ...ns) : std::array<int, D>::array{ static_cast<int>(ns)... } {}\n};\ntemplate <typename ...Ints> Dim(const Ints& ...) -> Dim<sizeof...(Ints)>;\ntemplate <class T, size_t D, size_t I = 0>\nauto ndvec(const Dim<D> &ns, const T& value = {}) {\n    if constexpr (I + 1 < D) {\n        return std::vector(ns[I], ndvec<T, D, I + 1>(ns, value));\n    } else {\n        return std::vector<T>(ns[I], value);\n    }\n} \n} // namescape mitsuha\n\nnamespace mitsuha {\nusing str = std::string;\nusing int128 = __int128;\nusing uint128 = unsigned __int128;\ntemplate <class T> using min_priority_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T> using max_priority_queue = std::priority_queue<T, std::vector<T>, std::less<T>>;\n}\nnamespace mitsuha { const std::string Yes = \"Yes\", No = \"No\", YES = \"YES\", NO = \"NO\"; }\n\n#define Int(...) int __VA_ARGS__; read(__VA_ARGS__)\n#define Ll(...) long long __VA_ARGS__; read(__VA_ARGS__)\n#define Dbl(...) double __VA_ARGS__; read(__VA_ARGS__)\n#define Chr(...) char __VA_ARGS__; read(__VA_ARGS__)\n#define Str(...) string __VA_ARGS__; read(__VA_ARGS__)\n#define Vt(type, name, size) vector<type> name(size); read(name)\n#define Vvt(type, name, h, w) vector<vector<type>> name(h, vector<type>(w)); read(name)\n#define die(...)  do { print(__VA_ARGS__); return; } while (false)\n#define kill(...) do { print(__VA_ARGS__); return 0; } while (false)\n\n#define Each(e, v) for (auto &&e : v)\n#define CFor(e, v) for (const auto &e : v)\n#define For(i, ...) CFor(i, mitsuha::macro::rep_impl(__VA_ARGS__))\n#define Frr(i, ...) CFor(i, mitsuha::macro::rrep_impl(__VA_ARGS__))\n#define Loop(n) for ([[maybe_unused]] const auto& _ : mitsuha::macro::rep_impl(n))\n\n#define All(iterable) std::begin(iterable), std::end(iterable)\n#define len(iterable) (long long) iterable.size()\n#define elif else if\n \nusing namespace mitsuha;\nusing namespace std;\n\n#ifdef LOCAL\n/*Local Debug*/ #include \"library/debug/pprint.hpp\"\n#else\n#define debug(...) void(0)\n#endif\n \nconstexpr int iinf = std::numeric_limits<int>::max() / 2;\nconstexpr long long linf = std::numeric_limits<long long>::max() / 2;\n\nnamespace mitsuha{\n    template <typename ...Constraints> using constraints_t = std::enable_if_t<std::conjunction_v<Constraints...>, std::nullptr_t>;\n    template <typename ReturnType, typename Callable, typename ...Args>\n    using is_same_as_invoke_result = std::is_same<std::invoke_result_t<Callable, Args...>, ReturnType>;\n}\n\nnamespace mitsuha{\ntemplate <typename T, typename UpdateFunc, constraints_t<std::is_invocable<UpdateFunc>> = nullptr>\nstruct UpdateProxyObject {\npublic:\n    UpdateProxyObject(T &v, UpdateFunc update) : v(v), update(update) {}\n    operator T() const { return v; }\n    auto& operator++() && { ++v, update(); return *this; }\n    auto& operator--() && { --v, update(); return *this; }\n    auto& operator+=(const T &val) && { v += val, update(); return *this; }\n    auto& operator-=(const T &val) && { v -= val, update(); return *this; }\n    auto& operator*=(const T &val) && { v *= val, update(); return *this; }\n    auto& operator/=(const T &val) && { v /= val, update(); return *this; }\n    auto& operator%=(const T &val) && { v %= val, update(); return *this; }\n    auto& operator =(const T &val) && { v  = val, update(); return *this; }\n    auto& operator<<=(const T &val) && { v <<= val, update(); return *this; }\n    auto& operator>>=(const T &val) && { v >>= val, update(); return *this; }\n    template <typename F, constraints_t<is_same_as_invoke_result<T, F, T>> = nullptr>\n    auto& apply(F f) && { v = f(v), update(); return *this; }\nprivate:\n    T &v;       \n    UpdateFunc update;\n};\n} // namespace mitsuha\n\nnamespace mitsuha{\ntemplate <class Monoid>\nstruct SegTree {\n    using MX = Monoid;\n    using T = typename MX::value_type;\n    int n, m;\n    \n    SegTree() : SegTree(0) {}\n    SegTree(int n) { build(n, [](int){ return MX::unit(); }); }\n    template<class F> SegTree(int n, const F &f) { build(n, f); }\n    SegTree(const std::vector<T> &a) {\n        build(a.size(), [&](int i){ return a[i]; });\n    }\n    \n    template<class F>\n    void build(int _n, const F &f) {\n        n = _n, m = ceil_pow2(_n);\n        data.assign(m << 1, MX::unit());\n        for (int i = 0; i < n; ++i) data[i + m] = f(i);\n        for (int k = m - 1; k > 0; --k) update(k);\n    }\n    const T& get(int i) const {\n        assert(0 <= i and i < n);\n        return data[i + m];\n    }\n    T operator()(int l, int r) const {\n        assert(0 <= l && l <= r && r <= n);\n        T res_l = MX::unit(), res_r = MX::unit();\n        for (l += m, r += m; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) res_l = MX::op(res_l, data[l++]);\n            if (r & 1) res_r = MX::op(data[--r], res_r);\n        }\n        return MX::op(res_l, res_r);\n    }\n    T prod(int l, int r) const { return (*this)(l, r); }\n    T prod_left(int r) const { return (*this)(0, r); }\n    T prod_right(int l) const { return (*this)(l, m); }\n    T prod_all() const { return data[1]; }\n\n    void multiply(int i, const T &x) {\n        assert(i < n);\n        i += m;\n        data[i] = MX::op(data[i], x);\n        while (i >>= 1) update(i);\n    }\n    void set(int i, const T &val) {\n        (*this)[i] = val;\n    }\n    auto operator[](int i) {\n        assert(0 <= i and i < n);\n        int k = i + m;\n        return UpdateProxyObject { data[k], [this, k]{ update_from(k); } };\n    }\n    vector<T> get_all() {\n        vector<T> ret(n);\n        for (int i = 0; i < n; ++i){\n            ret[i] = (*this)[i];\n        }\n        return ret;\n    }\n\n    template <typename F>\n    int max_right(int l, const F &f) const {\n        assert(0 <= l and l <= n);\n        assert(f(MX::unit()));\n        if (l == n) return n;\n        l += m;\n        T sum_l = MX::unit();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (not f(MX::op(sum_l, data[l]))) {\n                while (l < m) {\n                    l = 2 * l;\n                    if (f(MX::op(sum_l, data[l]))) sum_l = MX::op(sum_l, data[l++]);\n                }\n                return l - m;\n            }\n            sum_l = MX::op(sum_l, data[l]);\n            l++;\n        } while ((l & -l) != l);\n        return n;\n    }\n\n    template <class F>\n    int min_left(int r, const F &f) const {\n        assert(0 <= r && r <= n);\n        assert(f(MX::unit()));\n        if (r == 0) return 0;\n        r += m;\n        T sum_r = MX::unit();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (not f(MX::op(data[r], sum_r))) {\n                while (r < m) {\n                    r = 2 * r + 1;\n                    if (f(MX::op(data[r], sum_r))) sum_r = MX::op(data[r--], sum_r);\n                }\n                return r + 1 - m;\n            }\n            sum_r = MX::op(data[r], sum_r);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\nprivate:\n    std::vector<T> data;\n\n    static constexpr int ceil_pow2(int n) {\n        int m = 1;\n        while (m < n) m <<= 1;\n        return m;\n    }\n    void update_from(int k) {\n        for (k >>= 1; k; k >>= 1) update(k);\n    }\n    void update(int k) {\n        data[k] = MX::op(data[k * 2], data[k * 2 + 1]);\n    }\n};\n\ntemplate<class Monoid>\nstd::ostream &operator<<(std::ostream &out, const SegTree<Monoid> &_seg){\n    auto seg = _seg;\n    out << \"[\";\n    for(auto i = 0; i < seg.n; ++ i){\n        out << seg[i];\n        if(i != seg.n - 1) out << \", \";\n    }\n    return out << ']';\n}\n} // namespace mitsuha\n\nstruct Monoid {\n    using X = array<long long, 4>;\n    using value_type = X;\n    static constexpr X op(const X &x, const X &y) noexcept { \n        X ret = unit();\n        for(int l = 0; l < 4; l++) for(int r = 0; r < 4; r++){\n            if (not ((l & 1) and (r & 2))){\n                chmax(ret[(l & 2) | (r & 1)], x[l] + y[r]);\n            }\n        }\n        return ret;\n    }\n    static constexpr X unit() { \n        return {0, 0, 0, 0};\n    }\n    static constexpr bool commute = false;\n};\n\nnamespace mitsuha{\nstruct has_mod_impl {\n    template <class T>\n    static auto check(T &&x) -> decltype(x.get_mod(), std::true_type{});\n    template <class T>\n    static auto check(...) -> std::false_type;\n};\n\ntemplate <class T>\nclass has_mod : public decltype(has_mod_impl::check<T>(std::declval<T>())) {};\n\ntemplate <typename mint>\nmint inv(int n) {\n    static const int mod = mint::get_mod();\n    static vector<mint> dat = {0, 1};\n    assert(0 <= n);\n    if (n >= mod) n %= mod;\n    while (len(dat) <= n) {\n        int k = len(dat);\n        int q = (mod + k - 1) / k;\n        dat.emplace_back(dat[k * q - mod] * mint::raw(q));\n    }\n    return dat[n];\n}\n\ntemplate <typename mint>\nmint fact(int n) {\n    static const int mod = mint::get_mod();\n    assert(0 <= n && n < mod);\n    static vector<mint> dat = {1, 1};\n    while (len(dat) <= n) dat.emplace_back(dat[len(dat) - 1] * mint::raw(len(dat)));\n    return dat[n];\n}\n\ntemplate <typename mint>\nmint fact_inv(int n) {\n    static vector<mint> dat = {1, 1};\n    if (n < 0) return mint(0);\n    while (len(dat) <= n) dat.emplace_back(dat[len(dat) - 1] * inv<mint>(len(dat)));\n    return dat[n];\n}\n\ntemplate <class mint, class... Ts>\nmint fact_invs(Ts... xs) {\n    return (mint(1) * ... * fact_inv<mint>(xs));\n}\n\ntemplate <typename mint, class Head, class... Tail>\nmint multinomial(Head &&head, Tail &&... tail) {\n    return fact<mint>(head) * fact_invs<mint>(std::forward<Tail>(tail)...);\n}\n\ntemplate <typename mint>\nmint C_dense(int n, int k) {\n    static vector<vector<mint>> C;\n    static int H = 0, W = 0;\n    auto calc = [&](int i, int j) -> mint {\n        if (i == 0) return (j == 0 ? mint(1) : mint(0));\n        return C[i - 1][j] + (j ? C[i - 1][j - 1] : 0);\n    };\n    if (W <= k) {\n        for(int i = 0; i < H; ++i) {\n            C[i].resize(k + 1);\n            for(int j = W; j < k + 1; ++j) { C[i][j] = calc(i, j); }\n        }\n        W = k + 1;\n    }\n    if (H <= n) {\n        C.resize(n + 1);\n        for(int i = H; i < n + 1; ++i) {\n            C[i].resize(W);\n            for(int j = 0; j < W; ++j) { C[i][j] = calc(i, j); }\n        }\n        H = n + 1;\n    }\n    return C[n][k];\n}\n\ntemplate <typename mint, bool large = false, bool dense = false>\nmint C(long long n, long long k) {\n    assert(n >= 0);\n    if (k < 0 || n < k) return 0;\n    if constexpr (dense) return C_dense<mint>(n, k);\n    if constexpr (!large) return multinomial<mint>(n, k, n - k);\n    k = min(k, n - k);\n    mint x(1);\n    for(int i = 0; i < k; ++i) x *= mint(n - i);\n    return x * fact_inv<mint>(k);\n}\n\ntemplate <typename mint, bool large = false>\nmint C_inv(long long n, long long k) {\n    assert(n >= 0);\n    assert(0 <= k && k <= n);\n    if (not large) return fact_inv<mint>(n) * fact<mint>(k) * fact<mint>(n - k);\n    return mint(1) / C<mint, true>(n, k);\n}\n\n// [x^d](1-x)^{-n}\ntemplate <typename mint, bool large = false, bool dense = false>\nmint C_negative(long long n, long long d) {\n    assert(n >= 0);\n    if (d < 0) return mint(0);\n    if (n == 0) { return (d == 0 ? mint(1) : mint(0)); }\n    return C<mint, large, dense>(n + d - 1, d);\n}\n} // namespace mitsuha\n\nnamespace mitsuha{\ntemplate <int mod>\nstruct modint {\n    static constexpr unsigned int umod = (unsigned int)(mod);\n    static_assert(umod < 1U << 31);\n    unsigned int val;\n\n    static modint raw(unsigned int v) {\n        modint x;\n        x.val = v;\n        return x;\n    }\n    constexpr modint() : val(0) {}\n    constexpr modint(unsigned int x) : val(x % umod) {}\n    constexpr modint(unsigned long long x) : val(x % umod) {}\n    constexpr modint(unsigned __int128 x) : val(x % umod) {}\n    constexpr modint(int x) : val((x %= mod) < 0 ? x + mod : x){};\n    constexpr modint(long long x) : val((x %= mod) < 0 ? x + mod : x){};\n    constexpr modint(__int128 x) : val((x %= mod) < 0 ? x + mod : x){};\n    bool operator<(const modint &other) const { return val < other.val; }\n    modint &operator+=(const modint &p) {\n        if ((val += p.val) >= umod) val -= umod;\n        return *this;\n    }\n    modint &operator-=(const modint &p) {\n        if ((val += umod - p.val) >= umod) val -= umod;\n        return *this;\n    }\n    modint &operator*=(const modint &p) {\n        val = (unsigned long long)(val) * p.val % umod;\n        return *this;\n    }\n    modint &operator/=(const modint &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n    modint operator-() const { return modint::raw(val ? mod - val : 0U); }\n    modint operator+(const modint &p) const { return modint(*this) += p; }\n    modint operator-(const modint &p) const { return modint(*this) -= p; }\n    modint operator*(const modint &p) const { return modint(*this) *= p; }\n    modint operator/(const modint &p) const { return modint(*this) /= p; }\n    bool operator==(const modint &p) const { return val == p.val; }\n    bool operator!=(const modint &p) const { return val != p.val; }\n    modint inverse() const {\n        int a = val, b = mod, u = 1, v = 0, t;\n        while (b > 0) {\n            t = a / b;\n            swap(a -= t * b, b), swap(u -= t * v, v);\n        }\n        return modint(u);\n    }\n    modint pow(long long n) const {\n        assert(n >= 0);\n        modint ret(1), mul(val);\n        while (n > 0) {\n            if (n & 1) ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    static constexpr int get_mod() { return mod; }\n   // (n, r), r is the 2^nth root of 1\n    static constexpr pair<int, int> ntt_info() {\n        if (mod == 120586241) return {20, 74066978};\n        if (mod == 167772161) return {25, 17};\n        if (mod == 469762049) return {26, 30};\n        if (mod == 754974721) return {24, 362};\n        if (mod == 880803841) return {23, 211};\n        if (mod == 943718401) return {22, 663003469};\n        if (mod == 998244353) return {23, 31};\n        if (mod == 1045430273) return {20, 363};\n        if (mod == 1051721729) return {20, 330};\n        if (mod == 1053818881) return {20, 2789};\n        return {-1, -1};\n    }\n    static constexpr bool can_ntt() { return ntt_info().first != -1; }\n};\n\ntemplate<int _mod>  \nvoid rd(modint<_mod> &number){\n    io::rd(number.val);\n    number.val %= _mod;\n}\ntemplate<int _mod>\nvoid wt(const modint<_mod> &number){\n    io::wt(number.val);\n}\ntemplate<int _mod>\nostream &operator<<(ostream &out, const modint<_mod> &number){ return out << number.val; }\n\nusing modint107 = modint<1000000007>;\nusing modint998 = modint<998244353>;\n} // namespace mitsuha\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        int n = len(nums);\n        int q = len(queries);\n\n        using mint = modint107;\n        mint ret = 0;\n\n        SegTree<Monoid> Seg(n, [&](int i){\n            auto X = Monoid::unit();\n            X[3] = nums[i];\n            return X;\n        });\n\n        For(x, q){\n            Seg[queries[x][0]] = {0, 0, 0, queries[x][1]};\n            auto X = Seg.prod_all();\n            long long res = 0;\n            For(y, 4) chmax(res, X[y]);\n            ret += res;\n        }\n        return ret.val;\n    }\n};\n\n",
    "submit_ts": 1716691431.0
}