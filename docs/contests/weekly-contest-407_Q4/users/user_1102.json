{
    "username": "simon791110",
    "submission": "class Solution {\n    struct Partition {\n        int startIdx;\n        int endIdx;\n        bool needIncrement;\n        int diff;\n\n        bool operator<(const Partition& other) const {\n            return static_cast<long long>(endIdx - startIdx) * diff < static_cast<long long>(other.endIdx - other.startIdx) * other.diff;\n        }\n    };\npublic:\n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n        priority_queue<Partition> pq;\n\n        auto findPartition = [&](int start, int end) {\n            if (start > end) {\n                return;\n            }\n\n            int compare = 0;\n\n            if (target[start] > nums[start]) {\n                compare = 1;\n            } else if (target[start] < nums[start]) {\n                compare = -1;\n            }\n\n            int diff = abs(nums[start] - target[start]);\n\n            if (start == end && compare != 0) {\n                pq.push(Partition(start, end, (compare > 0) ? true : false, diff));\n                return;\n            }\n\n            int lastCompare = compare;\n            int head = start;\n\n            for (int i = start + 1; i <= end; i++) {\n                int compare = 0;\n\n                if (target[i] > nums[i]) {\n                    compare = 1;\n                } else if (target[i] < nums[i]) {\n                    compare = -1;\n                }\n\n                if (compare != lastCompare) {\n                    if (lastCompare != 0) {\n                        pq.push(Partition(head, i - 1, (lastCompare > 0) ? true : false, diff));\n                    }\n\n                    head = i;\n                    lastCompare = compare;\n                    diff = abs(nums[i] - target[i]);\n                } else {\n                    diff = min(diff, abs(nums[i] - target[i]));\n                }\n            }\n\n            if (lastCompare != 0) {\n                pq.push(Partition(head, end, (lastCompare > 0) ? true : false, diff));\n            }\n        };\n\n        long long ret = 0;\n\n        findPartition(0, nums.size() - 1);\n\n        while (pq.size()) {\n            //cout << pq.top().startIdx << \",\" << pq.top().endIdx << \":\" << pq.top().needIncrement << endl;\n            auto partition = pq.top();\n            pq.pop();\n            ret += partition.diff;\n            for (int i = partition.startIdx; i <= partition.endIdx; i++) {\n                if (partition.needIncrement) {\n                    nums[i] += partition.diff;\n                } else {\n                    nums[i] -= partition.diff;\n                }\n            }\n\n            findPartition(partition.startIdx, partition.endIdx);\n        }\n\n        return ret;\n    }\n};",
    "submit_ts": "1721531793",
    "subm_id": "1327969996"
}