{
    "username": "mhrydv",
    "submission": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define pb push_back \n#define mp make_pair \n#define all(x) (x).begin(),(x).end()\n#define allb(x) (x).rbegin(),(x).rend()\n#define rep_u(ii, aa, bb) for(int ii = aa; ii < bb; ii++)\n#define rep_d(ii, aa, bb) for(int ii = aa; ii >= bb; ii--)\n#define ff first\n#define ss second\n#define yes cout << \"YES\" << endl;\n#define no cout << \"NO\" << endl;\n#define ordered_set(type) tree<type, null_type,less_equal<type>, rb_tree_tag,tree_order_statistics_node_update>\n\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef priority_queue<ll> maxhi;\ntypedef priority_queue <ll, vector<ll>, greater<ll>> minhi;\n\n#ifndef ONLINE_JUDGE\n#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;\n#else\n#define debug(x)\n#endif\n\nvoid _print(ll t) {cerr << t;}\nvoid _print(int t) {cerr << t;}\nvoid _print(string t) {cerr << t;}\nvoid _print(char t) {cerr << t;}\n\ntemplate <class T, class V> void _print(pair <T, V> p);\ntemplate <class T> void _print(vector <T> v);\ntemplate <class T> void _print(set <T> v);\ntemplate <class T, class V> void _print(map <T, V> v);\ntemplate <class T> void _print(multiset <T> v);\ntemplate <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}\ntemplate <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\ntemplate <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\ntemplate <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\ntemplate <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\n\ntemplate<class container>void print(container start,container end){while(start!=end){cout<<*start<<\" \";start++;}cout<<endl;}\nll modpow(ll a, ll n, ll mod) {ll res = 1;while (n > 0) {if (n & 1) res = res * a % mod;a = a * a % mod;n >>= 1;}return res;}\nll gcd(ll a, ll b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}\nll lcm(ll a,ll b){return (a*b)/gcd(a,b);}\nll expo(ll a, ll b, ll mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}\nvoid extendgcd(ll a, ll b, ll*v) {if (b == 0) {v[0] = 1; v[1] = 10; v[2] = a; return ;} extendgcd(b, a % b, v); ll x = v[1]; v[1] = v[0] - v[1] * (a / b); v[0] = x; return;} //pass an array of size 3\nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\nll mminv(ll a, ll b) {ll arr[3]; extendgcd(a, b, arr); return mod_add(arr[0], 0, b);} //for non prime b (using extended euclid gcd)\nll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}   // for prime b (using fermat little theorem)\nll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m\nbool sortcol(const vector<ll>& v1, const vector<ll>& v2){return v1[1] < v2[1];}\nvoid fastio(){ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);}\nstring binary(ll n){return bitset<32>(n).to_string();}\n\nconst int maxn = 1e5+10;\nvll seive(maxn,1),lpf(maxn,0),hpf(maxn,0),pf,divisors[maxn];\nvoid primes(){seive[0]=0,seive[1]=0;lpf[1]=1;hpf[1]=1;for(int i=2;i*i<=maxn;i++){if(seive[i]){lpf[i]=hpf[i]=i;for(int j=2*i;j<maxn;j+=i){seive[j]=0;hpf[j]=i;if(lpf[j]==0){lpf[j]=i;}}}}}\nvoid primefactors(ll n){while(n>1){ll spf=lpf[n];while(n%spf==0){n=n/spf;pf.pb(spf);}}}\nvoid divisor(){for(int i=2;i*i<=maxn;i++){for(int j=i;j<maxn;j+=i){divisors[j].pb(i);}}}\n\n#define MOD 1e9+7\nclass Solution {\npublic:\n    int minimumDistance(vector<vector<int>>& points) {\n        int n=points.size();\n        multiset<ll> v1,v2;\n        vector<pair<ll,ll>> arr(n);\n        forn(i,n){\n            arr[i].ff=points[i][0];\n            arr[i].ss=points[i][1];\n            v1.insert(points[i][0]+points[i][1]);\n            v2.insert(points[i][0]-points[i][1]);\n            \n        }\n        int mini=INT_MAX;\n        for(auto it:arr){\n            auto it1 = v1.find(it.ff + it.ss);\n            if (it1 != v1.end()) v1.erase(it1);\n            auto it2 = v2.find(it.ff - it.ss);\n            if (it2 != v2.end()) v2.erase(it2);\n            int dist=max(*v1.rbegin()-*v1.begin(),*v2.rbegin()-*v2.begin());\n            mini=min(mini,dist);\n            v1.insert(it.ff+it.ss);\n            v2.insert(it.ff-it.ss);\n            \n        }\n        return mini;\n        \n    }\n};"
}