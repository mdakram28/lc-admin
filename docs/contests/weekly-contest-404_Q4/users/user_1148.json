{
    "username": "Sujal_Mahalaha",
    "submission": "#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int diameter1 = calculateDiameter(edges1);\n        int diameter2 = calculateDiameter(edges2);\n\n        // The maximum possible height of the trees (height = diameter / 2 rounded up)\n        int height1 = (diameter1 + 1) / 2;\n        int height2 = (diameter2 + 1) / 2;\n\n        // The minimum possible diameter after merging the trees\n        int mergedDiameter = max(max(diameter1, diameter2), height1 + height2 + 1);\n\n        return mergedDiameter;\n    }\n\nprivate:\n    int calculateDiameter(vector<vector<int>>& edges) {\n        if (edges.empty()) return 0;\n        \n        // Build the graph from edges\n        int n = edges.size() + 1;\n        vector<vector<int>> graph(n);\n        for (auto& edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n\n        // Find the farthest node from an arbitrary node (0) to get one end of the diameter\n        vector<int> farthest = bfs(graph, 0);\n        // Find the farthest node from the previously found node to get the diameter\n        farthest = bfs(graph, farthest[0]);\n\n        // The distance to this node is the diameter of the tree\n        return farthest[1];\n    }\n\n    vector<int> bfs(vector<vector<int>>& graph, int start) {\n        int n = graph.size();\n        vector<bool> visited(n, false);\n        queue<pair<int, int>> q;\n        q.push({start, 0});\n        visited[start] = true;\n\n        pair<int, int> farthest = {start, 0}; // {node, distance}\n        while (!q.empty()) {\n            auto node = q.front();\n            q.pop();\n            int currentNode = node.first;\n            int currentDistance = node.second;\n            farthest = {currentNode, currentDistance};\n\n            for (int neighbor : graph[currentNode]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    q.push({neighbor, currentDistance + 1});\n                }\n            }\n        }\n\n        return {farthest.first, farthest.second};\n    }\n};\n",
    "submit_ts": "1719719623",
    "subm_id": "1304446511"
}