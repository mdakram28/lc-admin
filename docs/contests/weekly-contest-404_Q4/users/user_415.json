{
    "username": "_saraswat",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, n) for (lli i = (a); i < (n); ++i)\n#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define sz(a) ((int)a.size())\n#define YES cout << \"YES\" << endl;\n#define NO cout << \"NO\" << endl;\n#define endl '\\n'\n#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);\n#define pb push_back\n#define pp pop_back()\n#define fi first\n#define si second\n#define v(a) vector<int>(a)\n#define vv(a) vvi(a)\n#define present(c, x) ((c).find(x) != (c).end())\n#define set_bits __builtin_popcountll\n#define MOD 1000000007\n// #define int long long\n\ntypedef long long lli;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<lli, lli> pll;\ntypedef pair<int, int> pii;\ntypedef unordered_map<int, int> umpi;\ntypedef map<int, int> mpi;\ntypedef vector<pii> vp;\ntypedef vector<lli> vll;\ntypedef vector<vll> vvll;\n\nclass Solution\n{\n    void dfsVisit(vi &visited, const vvi &graph, int &des, int src, int d)\n    {\n        visited[src] = d;\n        if (d <= visited[des])\n        {\n        }\n        else\n            des = src;\n\n        for (int neighbor : graph[src])\n        {\n            if (visited[neighbor] != -1)\n            {\n                continue;\n            }\n            dfsVisit(visited, graph, des, neighbor, d + 1);\n        }\n    };\n\n    int dfs(const vvi &graph, int src, int &des)\n    {\n        int n = graph.size();\n        vi visited(n, -1);\n        des = src;\n        dfsVisit(visited, graph, des, src, 0);\n        return visited[des];\n    };\n    vvi adj1, adj2;\n    void fill(vvi &edges1, vvi &edges2, int &n, int &m)\n    {\n        n++;\n        m++;\n        adj1.resize(n), adj2.resize(m);\n        for (auto &e : edges1)\n        {\n            adj1[e[0]].pb(e[1]);\n            adj1[e[1]].pb(e[0]);\n        }\n        for (const auto &edge : edges2)\n        {\n            adj2[edge[0]].pb(edge[1]);\n            adj2[edge[1]].pb(edge[0]);\n        }\n    }\n\npublic:\n    int minimumDiameterAfterMerge(vvi &edges1, vvi &edges2)\n    {\n        int n = sz(edges1);\n        int m = sz(edges2);\n        fill(edges1, edges2, n, m);\n        int ans1 = 0;\n        dfs(adj1, 0, ans1);\n        int op1 = dfs(adj1, ans1, ans1);\n\n        int ans2 = 0;\n        dfs(adj2, 0, ans2);\n        int op2 = dfs(adj2, ans2, ans2);\n\n        return max({op1, op2, ((op1 + 1) / 2) + ((op2 + 1) / 2) + 1});\n    }\n};\n",
    "submit_ts": "1719717362",
    "subm_id": "1304389569"
}