{
    "username": "bibimoni",
    "submission": "template <int MOD_> struct modnum {\n  static constexpr int MOD = MOD_;\n  static_assert(MOD_ > 0, \"MOD must be positive\");\nprivate:\n  int v;\n  static int minv(int a, int m) {\n    a %= m;\n    assert(a);\n    return a == 1 ? 1 : m - minv(m, a) * m / a;\n  }\npublic:\n  modnum() : v(0) {}\n  modnum(int v_) : v(v_ % MOD) { if (v < 0) v += MOD; }\n  explicit operator int() const { return v; }\n  friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << static_cast<int>(n); }\n  friend std::istream& operator >> (std::istream& in, modnum& n) { int v_; in >> v_; n = modnum(v_); return in; }\n  friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n  friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n  modnum inv() const {\n    modnum res;\n    res.v = minv(v, MOD);\n    return res;\n  }\n  friend modnum inv(const modnum& m) { return m.inv(); }\n  modnum neg() const {\n    modnum res;\n    res.v = v ? MOD-v : 0;\n    return res;\n  }\n  friend modnum neg(const modnum& m) { return m.neg(); }\n  modnum operator- () const {\n    return neg();\n  }\n  modnum operator+ () const {\n    return modnum(*this);\n  }\n  modnum& operator ++ () {\n    v ++;\n    if (v == MOD) v = 0;\n    return *this;\n  }\n  modnum& operator -- () {\n    if (v == 0) v = MOD;\n    v --;\n    return *this;\n  }\n  modnum& operator += (const modnum& o) {\n    v += o.v;\n    if (v >= MOD) v -= MOD;\n    return *this;\n  }\n  modnum& operator -= (const modnum& o) {\n    v -= o.v;\n    if (v < 0) v += MOD;\n    return *this;\n  }\n  modnum& operator *= (const modnum& o) {\n    v = v * o.v % MOD;\n    return *this;\n  }\n  modnum& operator /= (const modnum& o) {\n    return *this *= o.inv();\n  }\n  friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n  friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n  friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n  friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n \nconst int md = int(1e9) + 7;\n \nusing Mint = modnum<md>;\n \nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n \ntemplate<int M, typename U>\nmodnum<M> power(const modnum<M>& a, const U& b) {\n  assert(b >= 0);\n  modnum<M> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n \nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  k = min(k, n - k);\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nclass Solution {\npublic:\n    int countOfPairs(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> a(n + 1);\n        a.insert(a.begin() + 1, nums.begin(), nums.end());\n        int mx = *max_element(nums.begin(), nums.end());\n        vector<vector<vector<Mint>>> dp(n + 1, vector<vector<Mint>>(mx + 1, vector<Mint>(mx + 1, 0)));\n        for (int j = 0; j <= a[1]; j++) {\n            int k = a[1] - j;\n            dp[1][j][k] = 1;\n        }        \n        for (int i = 2; i <= n; i++) {\n            for (int j = 0; j <= a[i]; j++) {\n                for (int m = 0; m <= min(j, a[i - 1]); m++) {\n                    int k = a[i] - j;\n                    int m2 = a[i - 1] - m;\n                    if (m2 < k) {\n                        continue;\n                    }\n                    dp[i][j][k] += dp[i - 1][m][m2];\n                }\n            }\n        }\n        Mint ans = 0;\n        for (int j = 0; j <= a[n]; j++) {\n            int k = a[n] - j;\n            ans += dp[n][j][k];\n        }\n        return int(ans);\n    }\n};",
    "submit_ts": "1723345428",
    "subm_id": "1351555575"
}