{
    "username": "NULLgorithm",
    "submission": "\n\n\n\nstruct node{\n    //size \n    node *child[26];\n\n    //no of strings having it as prefix\n    int prefix;\n\n    //no of strings ending here\n    int end;\n\n    //string that ends here\n    // vector<string> wend;\n    \n    int cost;\n\n    node(){\n        prefix=0;\n        end=0;\n        cost=1e9;\n        for(int i=0;i<26;i++){\n            child[i]=NULL;\n        }\n    }\n};\n\nstruct str_trie{\n\n    node *root;\n\n    str_trie(){\n        root=new node;\n    }\n\n    void insert(string& s, int c){\n        node *curr=root;\n        for(int i=0;i<s.length();i++){\n            curr->prefix++;\n            //change according to size of node!!\n            int x=s[i]-'a';\n            if(curr->child[x]==NULL){\n                curr->child[x]=new node;\n            }\n            curr=curr->child[x];\n        }\n        // curr->wend.push_back(s);\n        curr->end++;\n        curr->cost=min(curr->cost, c);\n    }\n\n    bool present(string& s){\n        node *curr=root;\n        for(int i=0;i<s.length();i++){\n            //change according to size of node!!\n            int x=s[i]-'a';\n            if(curr->child[x]==NULL) return false;\n            curr=curr->child[x];\n        }\n        if(curr->end==0) return false;\n        return true;\n    }\n\n    void del(string& s){\n        if(!present(s)) return;\n        node *curr=root;\n        for(int i=0;i<s.length();i++){\n            curr->prefix--;\n            //change according to size of node!!\n            int x=s[i]-'a';\n            curr=curr->child[x];\n        }\n        // curr->wend.pop_back();\n        curr->end--;\n    }\n    \n    void longest_pref(string& s, vector<int>& dp, int st){\n        node* curr=root;\n        int n=s.length();\n        int i=0;\n        for(i=st;i<s.length();i++){\n            //change according to size of node!!\n            int x=s[i]-'a';\n            if(curr->child[x]!=NULL){\n                curr=curr->child[x];\n            }else{\n                break;\n            }\n            if(curr->end>0){\n                if(dp[i+1]==-1) dp[i+1]=curr->cost+dp[st];\n                else dp[i+1]=min(dp[i+1], curr->cost+dp[st]);\n            }\n        }\n    }\n\n};\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int n=target.length();\n        vector<int> dp(n+1, -1);\n        str_trie st;\n        for(int i=0;i<words.size();i++) st.insert(words[i], costs[i]);\n        dp[0]=0;\n        for(int i=1;i<=n;i++){\n            if(dp[i-1]!=-1){\n                st.longest_pref(target, dp, i-1);\n            }\n        }\n        return dp[n];\n    }\n};",
    "submit_ts": "1720323161",
    "subm_id": "1312368829"
}