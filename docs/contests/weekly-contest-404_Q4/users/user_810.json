{
    "username": "saikat93ify",
    "submission": "class Solution {\npublic:\n    \n    void build(vector <vector <int> > &tree, vector <vector <int> > &edges)\n    {\n        for(int i = 0; i < edges.size(); i++)\n        {\n            int u = edges[i][0], v = edges[i][1]; \n            tree[u].push_back(v); \n            tree[v].push_back(u);\n           // cout << \"Edge from \" << u << \" to \" << v << \"\\n\";\n        }\n        //cout << \"Finished Build of size = \" << tree.size() << \"\\n\";\n    }\n    \n    void dfs(int v, int parent_v, vector <vector <int> > &tree, vector <int> &distance)\n    {\n        //cout << \"Reached DFS\\n\";\n        for(int child_v : tree[v])\n        {\n            if(child_v == parent_v)\n            {\n                continue;\n            }\n            \n            distance[child_v] = distance[v] + 1; \n            dfs(child_v, v, tree, distance);\n        }\n    }\n    \n    int calculate_min_distance_from_diameter(vector <vector <int> > &tree, int &diameter)\n    {\n        int v = 0; \n        while(tree[v].size() != 1)\n        {\n            v++;\n        }\n        \n        vector <int> distance_v(tree.size());\n        dfs(v, -1, tree, distance_v);\n        \n        int end1 = 0; \n        for(int i = 0; i < tree.size(); i++)\n        {\n            if(distance_v[end1] < distance_v[i])\n            {\n                end1 = i;\n            }\n        }\n        \n        vector <int> distance_end1(tree.size()); \n        dfs(end1, -1, tree, distance_end1);\n        \n        int end2 = 0; \n        for(int i = 0; i < tree.size(); i++)\n        {\n            if(distance_end1[end2] < distance_end1[i])\n            {\n                end2 = i;\n            }\n        }\n        \n        vector <int> distance_end2(tree.size()); \n        dfs(end2, -1, tree, distance_end2);\n        diameter = distance_end1[end2];\n        \n       // cout << \"End1 = \" << end1 << \" End2 = \" << end2 << \" Diameter = \" << distance_end1[end2] << \"\\n\";\n        \n        int minimum_distance_from_diameter = tree.size(); \n        for(int i = 0; i < tree.size(); i++)\n        {\n            int maximum_distance_from_diameter_for_this_vertex = max(distance_end1[i], distance_end2[i]);\n            minimum_distance_from_diameter = min(minimum_distance_from_diameter, maximum_distance_from_diameter_for_this_vertex);\n            \n            //cout << \"V = \" << i << \" Distance from \" << end1 << \" = \" << distance_end1[i] << \" Distance from \" << end2 << \" = \" << distance_end2[i] << \"\\n\";\n        }\n        \n        return minimum_distance_from_diameter;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) \n    {\n        int no_of_vertices_1 = edges1.size() + 1; \n        vector <vector <int> > tree_1(no_of_vertices_1);\n        build(tree_1, edges1);\n        int diameter_1;\n        int minimum_distance_to_diameter_1 = (edges1.size() > 0 ? calculate_min_distance_from_diameter(tree_1, diameter_1) : 0);\n        \n        int no_of_vertices_2 = edges2.size() + 1; \n        vector <vector <int> > tree_2(no_of_vertices_2);\n        build(tree_2, edges2);\n        int diameter_2;\n        int minimum_distance_to_diameter_2 = (edges2.size() > 0 ? calculate_min_distance_from_diameter(tree_2, diameter_2) : 0);\n        \n        int answer = max(diameter_1, diameter_2); \n        answer = max(answer, minimum_distance_to_diameter_1 + 1 + minimum_distance_to_diameter_2);\n        \n        return answer;\n    }\n};",
    "submit_ts": 1719717799.0
}