{
    "username": "Rohit_Meena",
    "submission": "#define ll long long\ntemplate<class T, class U>\nstruct segtree{\n    ll n; vector<T>st; T identity_element;\n    // Definition of identity_element: the element I such that combine(x,I) = x\n\n    segtree() {}\n    segtree(ll n,T identity_element){\n        init(n,identity_element);\n    }\n    void init(ll n, T identity_element){ this->n = n; this->identity_element = identity_element; st.assign(4*n,identity_element);}\n    \n    // Combine two nodes l and r.\n    T combine(T l, T r){\n        T ans = (l&r);\t       // Sum\n        // T ans = min(l,r);\t   // Min\n        // T ans = max(l,r);\t   // Max\n        return ans;\n    }\n    \n    // Apply update upd to node curr.\n    T apply(T curr, U upd){\n        // T ans = upd;             \t  // set to upd\n        T ans = curr + upd;        // increment by upd\n        return ans;\n    }\n\n    void buildUtil(ll v, ll tl, ll tr, vector<T>&a){\n        if(tl == tr){\n            st[v] = a[tl];\n            return;\n        }\n        ll tm = (tl + tr)>>1;\n        buildUtil(2*v + 1, tl, tm,a);\n        buildUtil(2*v + 2,tm+1,tr,a);\n        st[v] = combine(st[2*v + 1], st[2*v + 2]);\n    }\n\n    T queryUtil(ll v, ll tl, ll tr, ll l, ll r){\n        if(l > r) return identity_element;\n        if(tr < l or tl > r) return identity_element;\n        if(l <= tl and r >= tr) return st[v];\n        ll tm = (tl + tr)>>1;\n        return combine(queryUtil(2*v+1,tl,tm,l,r), queryUtil(2*v+2,tm+1,tr,l,r));\n    }\n    void updateUtil(ll v, ll tl, ll tr, ll pos, U upd){\n        if(tl == tr){\n            st[v] = apply(st[v],upd);\n            return;\n        }\n        ll tm = (tl + tr)>>1;\n        if(pos<= tm) updateUtil(2*v+1,tl,tm,pos,upd);\n        else updateUtil(2*v+2,tm+1,tr,pos,upd);\n        st[v] = combine(st[2*v + 1], st[2*v+2]);\n    }\n\n    void build(vector<T>a){\n        assert( (ll)a.size() == n);\n        buildUtil(0,0,n-1,a);\n    }\n    T query(ll l, ll r){\n        return queryUtil(0,0,n-1,l,r);\n    }\n    void update(ll pos, U upd){\n        updateUtil(0,0,n-1,pos,upd);\n    }\n};\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        int n = nums.size();\n        int id = (1<<30) - 1;\n        segtree<int,int> st(n,id);\n        st.build(nums);\n\n        // int res = st.query(0,n-1);\n        // cout<<res<<endl;\n        \n        ll ans = 0;\n        for(int i = 0;i<n;i++){\n            int l = i, r = n-1;\n            int L = -1, R = -1;\n            while(l<=r){\n                int mid = l + (r-l)/2;\n                int qq = st.query(i,mid);\n                if(qq >= k){\n                    if(qq == k) L = mid;\n                    l = mid+1;\n                }else r = mid-1;\n            }\n            l = i, r = n-1;\n            while(l<=r){\n                int mid = l + (r-l)/2;\n                int qq = st.query(i,mid);\n                if(qq <= k){\n                    if(qq == k) R = mid;\n                    r = mid-1;\n                }else l = mid+1;\n            }\n            // cout<<i<<' '<<L<<\" \"<<R<<\" \"<<endl;\n            if(L!=-1 && R!=-1) ans += L - R+1;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720278817",
    "subm_id": "1311725586"
}