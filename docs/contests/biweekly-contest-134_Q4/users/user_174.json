{
    "username": "WORTH_IT",
    "submission": "// import java.util.*;\n// import java.util.function.*;\n\n// public class Main {\n//     public static void main(String[] args) throws Exception {\n//         System.out.println(new Solution().solve());\n//     }\n// }\n\nclass Solution {\n    public long countSubarrays(int[] nums, int k) {\n        int n = nums.length;\n        IntSparseTable st = new IntSparseTable(nums, (asd, jkl) -> asd & jkl);\n\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            int I = i;\n            int l = BS.firstTrue(0, i, new IntPredicate() {\n                @Override\n                public boolean test(int j) {\n                    return st.query(j, I) >= k;\n                }\n            });\n            int r = BS.lastTrue(0, i, new IntPredicate() {\n                @Override\n                public boolean test(int j) {\n                    return st.query(j, I) <= k;\n                }\n            });\n\n            ans += Math.max(r - l + 1, 0);\n        }\n\n        return ans;\n    }\n}\n\n// Source: https://github.com/SarthakMathur2182/CompetitiveProgramming/tree/main/SparseTable\n\nclass IntRMQ {\n    private static int highestBit(int x) {\n        return x == 0 ? -1 : 31 - Integer.numberOfLeadingZeros(x);\n    }\n\n    private final int n;\n    private final int[] values;\n    private int[][] rangeIndex;\n    private final boolean findingMaximum;\n\n    /**\n     * @param findingMaximum If {@code false}, we are doing Range Minimum Query.\n     *                       <p>If {@code true}, we are doing Range Maximum Query.\n     */\n    public IntRMQ(int[] values, boolean findingMaximum) {\n        this.n = values.length;\n        this.values = Arrays.copyOf(values, n);\n        this.findingMaximum = findingMaximum;\n        build();\n    }\n\n    /**\n     * Returns the index having the minimum/maximum value, depending on what we've defined.\n     * <p> If both the values are the same, {@code b} is returned.\n     */\n    private int betterIndex(int a, int b) {\n        return (findingMaximum ? values[b] < values[a] : values[a] < values[b]) ? a : b;\n    }\n\n    private void build() {\n        int levels = highestBit(n) + 1;\n        rangeIndex = new int[levels][];\n\n        rangeIndex[0] = new int[n];\n        for (int i = 0; i < n; i++)\n            rangeIndex[0][i] = i;\n\n        for (int k = 1; k < levels; k++) {\n            rangeIndex[k] = new int[n - (1 << k) + 1];\n            for (int i = 0; i <= n - (1 << k); i++)\n                rangeIndex[k][i] = betterIndex(rangeIndex[k - 1][i], rangeIndex[k - 1][i + (1 << (k - 1))]);\n        }\n    }\n\n    /**\n     * Returns the index having the smallest (or the largest) value in the range {@code [a, b]} (both inclusive).\n     * <p>If there are multiple possible indices, we're considering the largest index.\n     *\n     * @see #queryValue(int, int)\n     */\n    public int queryIndex(int a, int b) {\n        int level = highestBit(b - a + 1);\n        return betterIndex(rangeIndex[level][a], rangeIndex[level][b - (1 << level) + 1]);\n    }\n\n    /**\n     * Returns the smallest (or the largest) value in the index range {@code [a, b]} (both inclusive).\n     *\n     * @see #queryIndex(int, int)\n     */\n    public int queryValue(int a, int b) {\n        return values[queryIndex(a, b)];\n    }\n}\n\nclass LongRMQ {\n    private static int highestBit(int x) {\n        return x == 0 ? -1 : 31 - Integer.numberOfLeadingZeros(x);\n    }\n\n    private final int n;\n    private final long[] values;\n    private int[][] rangeIndex;\n    private final boolean findingMaximum;\n\n    /**\n     * @param findingMaximum If {@code false}, we are doing Range Minimum Query.\n     *                       <p>If {@code true}, we are doing Range Maximum Query.\n     */\n    public LongRMQ(long[] values, boolean findingMaximum) {\n        this.n = values.length;\n        this.values = Arrays.copyOf(values, n);\n        this.findingMaximum = findingMaximum;\n        build();\n    }\n\n    /**\n     * Returns the index having the minimum/maximum value, depending on what we've defined.\n     * <p> If both the values are the same, {@code b} is returned.\n     */\n    private int betterIndex(int a, int b) {\n        return (findingMaximum ? values[b] < values[a] : values[a] < values[b]) ? a : b;\n    }\n\n    private void build() {\n        int levels = highestBit(n) + 1;\n        rangeIndex = new int[levels][];\n\n        rangeIndex[0] = new int[n];\n        for (int i = 0; i < n; i++)\n            rangeIndex[0][i] = i;\n\n        for (int k = 1; k < levels; k++) {\n            rangeIndex[k] = new int[n - (1 << k) + 1];\n            for (int i = 0; i <= n - (1 << k); i++)\n                rangeIndex[k][i] = betterIndex(rangeIndex[k - 1][i], rangeIndex[k - 1][i + (1 << (k - 1))]);\n        }\n    }\n\n    /**\n     * Returns the index having the smallest (or the largest) value in the range {@code [a, b]} (both inclusive).\n     * <p>If there are multiple possible indices, we're considering the largest index.\n     *\n     * @see #queryValue(int, int)\n     */\n    public int queryIndex(int a, int b) {\n        int level = highestBit(b - a + 1);\n        return betterIndex(rangeIndex[level][a], rangeIndex[level][b - (1 << level) + 1]);\n    }\n\n    /**\n     * Returns the smallest (or the largest) value in the index range {@code [a, b]} (both inclusive).\n     *\n     * @see #queryIndex(int, int)\n     */\n    public long queryValue(int a, int b) {\n        return values[queryIndex(a, b)];\n    }\n}\n\nclass RMQ<T> {\n    private static int highestBit(int x) {\n        return x == 0 ? -1 : 31 - Integer.numberOfLeadingZeros(x);\n    }\n\n    private final int n;\n    private final T[] values;\n    private int[][] rangeIndex;\n    private final Comparator<T> comparator;\n\n    /**\n     * @param comparator The comparator we'll use to compare values.\n     *                   The smaller value (according to the comparator) will be considered.\n     */\n    public RMQ(T[] values, Comparator<T> comparator) {\n        this.n = values.length;\n        this.values = Arrays.copyOf(values, n);\n        this.comparator = comparator;\n        build();\n    }\n\n    /**\n     * Returns the index having the minimum value according to the comparator.\n     * <p> If both the values are the same, {@code b} is returned.\n     */\n    private int betterIndex(int a, int b) {\n        return comparator.compare(values[a], values[b]) < 0 ? a : b;\n    }\n\n    private void build() {\n        int levels = highestBit(n) + 1;\n        rangeIndex = new int[levels][];\n\n        rangeIndex[0] = new int[n];\n        for (int i = 0; i < n; i++)\n            rangeIndex[0][i] = i;\n\n        for (int k = 1; k < levels; k++) {\n            rangeIndex[k] = new int[n - (1 << k) + 1];\n            for (int i = 0; i <= n - (1 << k); i++)\n                rangeIndex[k][i] = betterIndex(rangeIndex[k - 1][i], rangeIndex[k - 1][i + (1 << (k - 1))]);\n        }\n    }\n\n    /**\n     * Returns the index having the smallest value (according to the comparator) in the range {@code [a, b]} (both inclusive).\n     * <p>If there are multiple possible indices, we're considering the largest index.\n     *\n     * @see #queryValue(int, int)\n     */\n    public int queryIndex(int a, int b) {\n        int level = highestBit(b - a + 1);\n        return betterIndex(rangeIndex[level][a], rangeIndex[level][b - (1 << level) + 1]);\n    }\n\n    /**\n     * Returns the smallest value (according to the comparator) in the index range {@code [a, b]} (both inclusive).\n     *\n     * @see #queryIndex(int, int)\n     */\n    public T queryValue(int a, int b) {\n        return values[queryIndex(a, b)];\n    }\n}\n\nclass IntSparseTable {\n    private static int highestBit(int x) {\n        return x == 0 ? -1 : 31 - Integer.numberOfLeadingZeros(x);\n    }\n\n    private int[][] rangeValue;\n    private final IntBinaryOperator operator;\n\n    public IntSparseTable(int[] values, IntBinaryOperator operator) {\n        this.operator = operator;\n        build(values);\n    }\n\n    private void build(int[] values) {\n        int n = values.length;\n        int levels = highestBit(n) + 1;\n\n        rangeValue = new int[levels][];\n        rangeValue[0] = new int[n];\n        System.arraycopy(values, 0, rangeValue[0], 0, n);\n\n        for (int k = 1; k < levels; k++) {\n            rangeValue[k] = new int[n - (1 << k) + 1];\n            for (int i = 0; i <= n - (1 << k); i++)\n                rangeValue[k][i] = operator.applyAsInt(rangeValue[k - 1][i], rangeValue[k - 1][i + (1 << (k - 1))]);\n        }\n    }\n\n    public int query(int a, int b) {\n        int level = highestBit(b - a + 1);\n        return operator.applyAsInt(rangeValue[level][a], rangeValue[level][b - (1 << level) + 1]);\n    }\n}\n\nclass LongSparseTable {\n    private static int highestBit(int x) {\n        return x == 0 ? -1 : 31 - Integer.numberOfLeadingZeros(x);\n    }\n\n    private long[][] rangeValue;\n    private final LongBinaryOperator operator;\n\n    public LongSparseTable(long[] values, LongBinaryOperator operator) {\n        this.operator = operator;\n        build(values);\n    }\n\n    private void build(long[] values) {\n        int n = values.length;\n        int levels = highestBit(n) + 1;\n\n        rangeValue = new long[levels][];\n        rangeValue[0] = new long[n];\n        System.arraycopy(values, 0, rangeValue[0], 0, n);\n\n        for (int k = 1; k < levels; k++) {\n            rangeValue[k] = new long[n - (1 << k) + 1];\n            for (int i = 0; i <= n - (1 << k); i++)\n                rangeValue[k][i] = operator.applyAsLong(rangeValue[k - 1][i], rangeValue[k - 1][i + (1 << (k - 1))]);\n        }\n    }\n\n    public long query(int a, int b) {\n        int level = highestBit(b - a + 1);\n        return operator.applyAsLong(rangeValue[level][a], rangeValue[level][b - (1 << level) + 1]);\n    }\n}\n\nclass SparseTable<T> {\n    private static int highestBit(int x) {\n        return x == 0 ? -1 : 31 - Integer.numberOfLeadingZeros(x);\n    }\n\n    private T[][] rangeValue;\n    private final BinaryOperator<T> operator;\n\n    public SparseTable(T[] values, BinaryOperator<T> operator) {\n        this.operator = operator;\n        build(values);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void build(T[] values) {\n        int n = values.length;\n        int levels = highestBit(n) + 1;\n\n        rangeValue = (T[][]) new Object[levels][];\n        rangeValue[0] = (T[]) new Object[n];\n        System.arraycopy(values, 0, rangeValue[0], 0, n);\n\n        for (int k = 1; k < levels; k++) {\n            rangeValue[k] = (T[]) new Object[n - (1 << k) + 1];\n            for (int i = 0; i <= n - (1 << k); i++)\n                rangeValue[k][i] = operator.apply(rangeValue[k - 1][i], rangeValue[k - 1][i + (1 << (k - 1))]);\n        }\n    }\n\n    public T query(int a, int b) {\n        int level = highestBit(b - a + 1);\n        return operator.apply(rangeValue[level][a], rangeValue[level][b - (1 << level) + 1]);\n    }\n}\n\nclass BS {\n\n    public static int firstTrue(int l, int r, java.util.function.IntPredicate predicate) {\n        r++;\n        while (l < r) {\n            int m = l + (r - l) / 2;\n\n            if (predicate.test(m)) r = m;\n            else l = m + 1;\n        }\n\n        return r;\n    }\n\n    public static long firstTrue(long l, long r, java.util.function.LongPredicate predicate) {\n        r++;\n        while (l < r) {\n            long m = l + (r - l) / 2;\n\n            if (predicate.test(m)) r = m;\n            else l = m + 1;\n        }\n\n        return r;\n    }\n\n    public static int lastTrue(int l, int r, java.util.function.IntPredicate predicate) {\n        return lastFalse(l, r, predicate.negate());\n    }\n\n    public static long lastTrue(long l, long r, java.util.function.LongPredicate predicate) {\n        return lastFalse(l, r, predicate.negate());\n    }\n\n    public static int firstFalse(int l, int r, java.util.function.IntPredicate predicate) {\n        return firstTrue(l, r, predicate.negate());\n    }\n\n    public static long firstFalse(long l, long r, java.util.function.LongPredicate predicate) {\n        return firstTrue(l, r, predicate.negate());\n    }\n\n    public static int lastFalse(int l, int r, java.util.function.IntPredicate predicate) {\n        return firstTrue(l, r, predicate) - 1;\n    }\n\n    public static long lastFalse(long l, long r, java.util.function.LongPredicate predicate) {\n        return firstTrue(l, r, predicate) - 1;\n    }\n\n\n    public static int lowerBound(int[] a, int l, int r, int x) {\n        return firstTrue(l, r, (java.util.function.IntPredicate) m -> a[m] >= x);\n    }\n\n    public static int lowerBound(int[] a, int x) {\n        return lowerBound(a, 0, a.length - 1, x);\n    }\n\n    public static int lowerBound(long[] a, int l, int r, long x) {\n        return firstTrue(l, r, (java.util.function.IntPredicate) m -> a[m] >= x);\n    }\n\n    public static int lowerBound(long[] a, long x) {\n        return lowerBound(a, 0, a.length - 1, x);\n    }\n\n    public static <T extends Comparable<T>> int lowerBound(T[] a, int l, int r, T x) {\n        return lowerBound(a, l, r, x, T::compareTo);\n    }\n\n    public static <T extends Comparable<T>> int lowerBound(T[] a, T x) {\n        return lowerBound(a, 0, a.length - 1, x);\n    }\n\n    public static <T> int lowerBound(T[] a, int l, int r, T x, java.util.Comparator<T> comparator) {\n        return firstTrue(l, r, (java.util.function.IntPredicate) m -> comparator.compare(a[m], x) >= 0);\n    }\n\n    public static <T> int lowerBound(T[] a, T x, java.util.Comparator<T> comparator) {\n        return lowerBound(a, 0, a.length - 1, x, comparator);\n    }\n\n\n    public static int upperBound(int[] a, int l, int r, int x) {\n        return firstTrue(l, r, (java.util.function.IntPredicate) m -> a[m] > x);\n    }\n\n    public static int upperBound(int[] a, int x) {\n        return upperBound(a, 0, a.length - 1, x);\n    }\n\n    public static int upperBound(long[] a, int l, int r, long x) {\n        return firstTrue(l, r, (java.util.function.IntPredicate) m -> a[m] > x);\n    }\n\n    public static int upperBound(long[] a, long x) {\n        return upperBound(a, 0, a.length - 1, x);\n    }\n\n    public static <T extends Comparable<T>> int upperBound(T[] a, int l, int r, T x) {\n        return upperBound(a, l, r, x, T::compareTo);\n    }\n\n    public static <T extends Comparable<T>> int upperBound(T[] a, T x) {\n        return upperBound(a, 0, a.length - 1, x);\n    }\n\n    public static <T> int upperBound(T[] a, int l, int r, T x, java.util.Comparator<T> comparator) {\n        return firstTrue(l, r, (java.util.function.IntPredicate) m -> comparator.compare(a[m], x) > 0);\n    }\n\n    public static <T> int upperBound(T[] a, T x, java.util.Comparator<T> comparator) {\n        return upperBound(a, 0, a.length - 1, x, comparator);\n    }\n}",
    "submit_ts": "1720277657",
    "subm_id": "1311673938"
}