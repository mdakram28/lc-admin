{
    "username": "lequan",
    "submission": "class Solution:\n    def minimumOperations(self, nums: List[int], target: List[int]) -> int:\n        \"\"\"\n        greedy? sort of. since the windows are not constant,\n        we march maximal subarrays towards their target.\n        we do not need to simulate, \n        just keep track of the direction \n\n        i wonder if this is sliding window.\n\n        how many operations do we need? t - n ops\n        then for [j+1], \n            if its greater, then we add the additional amount\n            if its less, then we do nothing and update prev\n        \"\"\"\n        ans = prev = 0\n        for n, t in zip(nums, target):\n            curr = t - n\n            if curr * prev >= 0:\n                delta = abs(curr) - abs(prev)\n                if delta > 0:\n                    ans += delta\n            else:\n                ans += abs(curr)\n            prev = curr\n\n        return ans\n        ",
    "submit_ts": "1721531364",
    "subm_id": "1327959087"
}