{
    "username": "vivek2943",
    "submission": "class SegmentTree{\npublic:\n    vector<int> segtree;\n    const int M = (1LL << 31) - 1;\n    SegmentTree(int n){\n        segtree.resize(4*n+1, M);\n    }\n    \n    void merge(int node,int lo, int hi){\n        segtree[node] = (segtree[2*node+1] & segtree[2*node+2]);\n    }\n    \n    \n    void build(int lo, int hi, vector<int>&v, int node){\n        if(lo == hi){\n            segtree[node] = v[lo];\n            return;\n        }\n        \n        int mid = lo + (hi - lo)/2;\n        build(lo, mid, v, 2*node+1);\n        build(mid+1, hi, v, 2*node+2);\n        merge(node, lo, hi);\n    }\n\n    int find(int l, int r, int node, int lo, int hi){\n        if(lo > r || hi < l) return M;\n        if(lo >= l && hi <= r) return segtree[node];\n        \n        int mid = lo + (hi - lo)/2;\n        int L = find(l, r, 2*node+1, lo, mid);\n        int R = find(l, r, 2*node+2, mid+1, hi);\n        merge(node, lo, hi);\n        \n        return (L & R);\n    }\n}; \n\n#define ll long long\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& v, int k) {\n        int n = v.size();\n        \n        vector<vector<int>> pre(31, vector<int> (n+1));\n        for(int i = 0;i < n;i++){\n            for(int j = 0;j < 31;j++){\n                if(v[i] >> j & 1){\n                    pre[j][i+1] = 1;\n                }\n            }\n        }\n        \n        for(int j = 1;j <= n;j++){\n            for(int i = 0;i < 31;i++){\n                pre[i][j] += pre[i][j-1];\n            }\n        }\n        \n        auto get = [&](int l, int r){\n            l++, r++;\n            l--;\n            int len = (r - l);\n            ll ans = 0;\n            for(int i = 0;i < 31;i++){\n                int cur = pre[i][r] - pre[i][l];\n                if(cur == len){\n                    ans += (1LL << i);\n                }\n            }\n            \n            return ans;\n        };\n        \n        auto chk = [&](int l, int r, int k){\n            int a = get(l, r);\n            return a >= k;\n        };\n        \n        auto chk1 = [&](int l, int r, int k){\n            int a = get(l, r);\n            \n            return a <= k;\n        };\n        \n        ll ans = 0;\n        for(int i = 0;i < n;i++){\n            int st = i, e = n-1, a1 = -1;\n            // highest\n            while(st <= e){\n                int mid = (st + e)/2;\n                if(chk(i, mid, k)){\n                    a1 = mid;\n                    st = mid+1;\n                }\n                else{\n                    e = mid-1;\n                }\n            }\n            if(a1 == -1 || get(i, a1) != k) continue;\n            \n            st = i, e = a1;\n            int a2 = -1;\n            //lowest\n            while(st <= e){\n                int mid = (st + e)/2;\n                if(chk1(i, mid, k)){\n                    a2 = mid;\n                    e = mid-1;\n                }\n                else{\n                    st = mid+1;\n                }\n            }\n            \n            ll len = (a1 - a2 + 1);\n            ans += len;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720278072",
    "subm_id": "1311693095"
}