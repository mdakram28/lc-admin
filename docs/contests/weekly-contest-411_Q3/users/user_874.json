{
    "username": "gopoma",
    "submission": "//* sometimes pragmas don't work, if so, just comment it!\n#pragma GCC optimize (\"Ofast\")\n//? #pragma GCC target (\"avx,avx2\")\n//! #pragma GCC optimize (\"trapv\")\n\n#undef _GLIBCXX_DEBUG //? for Stress Testing\n\n#include <bits/stdc++.h> //? if you don't want IntelliSense\n\nusing namespace std;\n\n// building blocks\nusing ll  = long long;\nusing db  = long double; // or double, if TL is tight\nusing str = string;      // yay python!\n\n//? priority_queue for minimum\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\nusing ull  = unsigned long long;\n//? using i64  = long long;\n//? using u64  = uint64_t;\n//? using i128 = __int128;\n//? using u128 = __uint128_t;\n//? using f128 = __float128;\n\n\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n\n#define mp make_pair\n#define f  first\n#define s  second\n\n\n\n#define tcT template <class T\n#define tcTU tcT, class U\n//! ^ lol this makes everything look weird but I'll try it\n\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n#define ts to_string\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\n\n\nconst int MOD = 1e9 + 7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  //? not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  //? for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\n\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\n\n\n#define tcTUU tcT, class ...U\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for read\");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? \",\" : \"\"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? '\\n'\n\t\t                                                             : ' ';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << '{';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << '}';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << '(';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << \" \", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << ')';\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for print\");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << \"\\033[0;31m\";\n\t\tImpl(t);\n\t\tif (debug) os << \"\\033[0m\";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << '\\n'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep(\" \", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\n\n#ifdef LOCAL\n#include \"helpers/debug.h\"\n\n#define chk(...) if (!(__VA_ARGS__)) cerr << \"\\033[41m\" << \"Line(\" << __LINE__ << \") -> function(\" \\\n\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\033[0m\" << \"\\n\", exit(0);\n\n#define MACRO(code) do {code} while (false)\n#define RAYA MACRO(cerr << \"\\033[101m\" << \"================================\" << \"\\033[0m\" << endl;)\n#else\n//? #define dbg(...)\n\n#define chk(...)\n//? #define RAYA\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\n\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), \"r\", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), \"w\", stdout); }\nvoid setIO(str s = \"\") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\t//? cout << fixed << setprecision(12);\n    //? cerr << fixed << setprecision(12);\n\tcin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + \".in\"), setOut(s + \".out\");  // for old USACO\n}\n}  // namespace FileIO\n\n\n\n//? Custom Helpers\ntemplate <typename T>\ninline T gcd(T a, T b) { while (b != 0) swap(b, a %= b); return a; }\n\nlong long binpow(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a;\n        a = a * a;\n        b >>= 1;\n    }\n    return res;\n}\n\nconst int dddx[8]{1, 0, -1,  0, 1,  1, -1, -1};\nconst int dddy[8]{0, 1,  0, -1, 1, -1,  1, -1};\n\nusing vvi = V<vi>;\nusing vvl = V<vl>;\nusing vvb = V<vb>;\n//? /Custom Helpers\n\n#define dbg(x) ps(#x); ps(x)\n#define RAYA ps(\"================================\")\n\n//* Template\n//* /Template\n\nclass Solution {\npublic:\n    string largestPalindrome(int n, int k) {\n        bool odd = n % 2 == 1;\n        vi powers(n + 5);\n        powers[0] = 1 % k;\n        for(int i = 1; i <= n; i++) {\n            powers[i] = (powers[i - 1] * 10) % k;\n        }\n\n        const int xd = (n - 1) / 2;\n        pair<bool, tuple<int, int, int>> dp[100005][10];\n        for(int idx = xd + 1; idx >= 0; idx--) {\n            for(int R = 0; R < k; R++) {\n                if(idx == xd + 1) {\n                    dp[idx][R] = mp(R == 0, make_tuple(-1, -1, -1));\n                    continue;\n                }\n\n                bool ok = false;\n                tuple<int, int, int> response = make_tuple(-1, -1, -1);\n                for(int d = 9; d >= (idx == 0)? 1 : 0; d--) {\n                    int new_R = (R + (d * powers[(n - 1) - idx])) % k;\n                    if(!(idx == xd && odd)) {\n                        new_R += (d * powers[idx]);\n                        new_R %= k;\n                    }\n                    assert(0 <= new_R && new_R < k);\n\n                    if(dp[idx + 1][new_R].f) {\n                        ok = true;\n                        response = make_tuple(d, idx + 1, new_R);\n                        break;\n                    }\n                }\n                dp[idx][R] = mp(ok, response);\n            }\n        }\n\n        str ans;\n        bool rage = false;\n        pair<bool, tuple<int, int, int>> current;\n        for(int R = 0; R < k; R++) {\n            for(int d = 9; d >= 1; d--) {\n                int new_R = (R + (d * powers[(n - 1) - 0])) % k;\n                if(!(0 == xd && odd)) {\n                    new_R += (d * powers[0]);\n                    new_R %= k;\n                }\n                assert(0 <= new_R && new_R < k);\n\n                if(dp[0 + 1][new_R].f) {\n                    ans.pb(ts(d).ft);\n                    current = dp[0 + 1][new_R];\n                    rage = true;\n                    break;\n                }\n            }\n            if(rage) break;\n        }\n        assert(rage);\n        //? dbg(current);\n\n        while(get<0>(current.s) != -1) {\n            ans.pb(ts(get<0>(current.s)).ft);\n            current = dp[get<1>(current.s)][get<2>(current.s)];\n        }\n\n        //? dbg(ans);\n        str other;\n        for(int i = 0; i < (odd ? sz(ans) - 1 : sz(ans)); i++) other.pb(ans[i]);\n        reverse(all(other));\n        each(c, other) ans.pb(c);\n        return ans;\n\n//?        str ans;\n//?        function<bool(int, int)> dp = [&](int idx, int R) -> bool {\n//?            if(idx == xd + 1) {\n//?                return (R == 0);\n//?            }\n//?            if(vis[idx][R]) return memo[idx][R];\n//?            vis[idx][R] = true;\n//?\n//?            for(int d = 9; d >= (idx == 0)? 1 : 0; d--) {\n//?                int new_R = (R + (d * powers[(n - 1) - idx]) + (d * powers[idx])) % k;\n//?                if(idx == xd && odd) {\n//?                    new_R -= (d * powers[idx]);\n//?                    new_R += k + k;\n//?                    new_R %= k;\n//?                }\n//?                if(dp(idx + 1, new_R)) {\n//?                    ans.pb(ts(d).ft);\n//?                    return memo[idx][R] = true;\n//?                }\n//?            }\n//?            return memo[idx][R] = false;\n//?        };        \n//?        dp(0, 0);\n//?        reverse(all(ans));\n//?        //? dbg(ans);\n//?        str other;\n//?        for(int i = 0; i < (odd ? sz(ans) - 1 : sz(ans)); i++) other.pb(ans[i]);\n//?        reverse(all(other));\n//?        each(c, other) ans.pb(c);\n//?        return ans;\n    }\n};",
    "submit_ts": "1723953325",
    "subm_id": "1359818251"
}