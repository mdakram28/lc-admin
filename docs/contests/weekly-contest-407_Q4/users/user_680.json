{
    "username": "sgdfbahjbhbaisdufg",
    "submission": "#define ll long long\n\nstruct UnionFind {\n    int n;\n    vector<int> p, l, r, h;\n    \n    UnionFind(const vector<int>& diff) : n(diff.size()), p(n), l(n), r(n), h(diff) {\n        for (int i = 0; i < n; ++i) {\n            l[i] = r[i] = p[i] = i;\n        }\n    }\n    \n    int Find(int u) {\n        if (p[u] != u) {\n            p[u] = Find(p[u]);\n        }\n        return p[u];\n    }\n    \n    int Union(int u, int v) {\n        int rtu = Find(u), rtv = Find(v);\n        if (rtu == rtv) {\n            return -10000;\n        }\n        assert(l[rtu] == r[rtv] + 1 || l[rtv] == r[rtu] + 1);\n        assert(h[rtu] == h[rtv]);\n        p[rtu] = rtv;\n        l[rtu] = l[rtv] = min(l[rtu], l[rtv]);\n        r[rtu] = r[rtv] = max(r[rtu], r[rtv]);\n        return rtu;\n    }\n};\n\nclass Solution {\n    ll solve(vector<int>& diff) {\n        int n = diff.size();\n        \n        UnionFind dsu(diff);\n        for (int i = 1; i < n; ++i) {\n            if (diff[i - 1] == diff[i]) {\n                dsu.Union(i - 1, i);\n            }\n        }\n        \n        set<pair<ll, int>> pq;\n        for (int i = 0; i < n; ++i) {\n            if (dsu.p[i] == i) {\n                pq.insert({ diff[i], i });\n            }\n        }\n        \n        ll ans = 0;\n        \n        while (pq.rbegin()->first > 0) {\n            auto [v, i] = *pq.rbegin();\n            int rti = dsu.Find(i);\n            assert(rti == i);\n            int l = dsu.l[rti], r = dsu.r[rti];\n            int neil_rt = dsu.Find(l - 1);\n            int neir_rt = dsu.Find(r + 1);\n            int targeth = max(dsu.h[neil_rt], dsu.h[neir_rt]);\n            ans += v - targeth;\n            dsu.h[rti] = targeth;\n            \n            pq.erase({ v , i });\n            if (targeth == dsu.h[neil_rt]) {\n                pq.erase({ dsu.h[neil_rt] , neil_rt });\n                dsu.Union(rti, neil_rt);\n            }\n            if (targeth == dsu.h[neir_rt]) {\n                pq.erase({ dsu.h[neir_rt] , neir_rt });\n                dsu.Union(rti, neir_rt);\n            }\n            int newrti = dsu.Find(i);\n            pq.insert({ dsu.h[newrti], newrti });\n        }\n        \n        return ans;\n    }\n    \npublic:\n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n        int n = nums.size();\n        ll ans = 0;\n        {\n            vector<int> diff;\n            diff.push_back(0);\n            for (int i = 0; i < n; ++i) {\n                diff.push_back(max(target[i] - nums[i], 0));\n            }\n            diff.push_back(0);\n            \n            ll cans = solve(diff);\n            ans += cans;\n        }\n        \n        {\n            vector<int> diff;\n            diff.push_back(0);\n            for (int i = 0; i < n; ++i) {\n                diff.push_back(max(-target[i] + nums[i], 0));\n            }\n            diff.push_back(0);\n            \n            ll cans = solve(diff);\n            ans += cans;\n        }\n        return ans;\n        \n        \n        \n    }\n};",
    "submit_ts": "1721531071",
    "subm_id": "1327951417"
}