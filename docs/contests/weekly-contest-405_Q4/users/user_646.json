{
    "username": "shivambhagat02",
    "submission": "class ComputeHash:\n\n    def __init__(self, s, p=31, mod=10**9 + 7):\n        n = len(s)\n        self.hash = [0] * n\n        self.inv_mod = [0] * n\n        self.mod = mod\n        self.p = p\n\n        p_pow = 1\n        hash_value = 0\n\n        for i in range(n):\n            c = ord(s[i]) - 97 + 1\n            hash_value = (hash_value + c * p_pow) % self.mod\n            self.hash[i] = hash_value\n            self.inv_mod[i] = pow(p_pow, self.mod - 2, self.mod)\n            p_pow = (p_pow * self.p) % self.mod\n\n    def get_hash(self, l, r):\n        if l == 0:\n            return self.hash[r]\n        window = (self.hash[r] - self.hash[l - 1]) % self.mod\n        return (window * self.inv_mod[l]) % self.mod\n\ndef get_hash(s, p=31, mod=10**9 + 7):\n    n = len(s)\n\n    p_pow = 1\n    hash_value = 0\n\n    for i in range(n):\n        c = ord(s[i]) - 97 + 1\n        hash_value = (hash_value + c * p_pow) % mod\n        p_pow = (p_pow * p) % mod\n\n    return hash_value\n    \n\nclass Hash:\n\n    def __init__(self, s):\n        self.hash_a = ComputeHash(s, 31, 10 ** 9 + 9)\n        self.hash_b = ComputeHash(s, 37, 10 ** 9 + 7)\n\n    def __getitem__(self, R: tuple) -> tuple:\n        h1 = self.hash_a.get_hash(R[0], R[1])\n        h2 = self.hash_b.get_hash(R[0], R[1])\n        return h1, h2\n    \ndef minCostToFormTarget(target, words, costs):\n    n = len(target)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0  # Cost to form an empty prefix is 0\n    \n    for i in range(1, n + 1):\n        for j in range(len(words)):\n            word = words[j]\n            cost = costs[j]\n            if i >= len(word) and target[i - len(word):i] == word:  # Check if word can extend the prefix to i\n                dp[i] = min(dp[i], dp[i - len(word)] + cost)\n    \n    return dp[n] if dp[n] != float('inf') else -1 \n\nimport heapq\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.cost = float('inf')\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word, cost):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.cost = min(node.cost, cost)\n    \n    def get_words_starting_at(self, target, start_index):\n        node = self.root\n        results = []\n        current_cost = 0\n        for i in range(start_index, len(target)):\n            if target[i] not in node.children:\n                break\n            node = node.children[target[i]]\n            current_cost = node.cost\n            if current_cost != float('inf'):\n                results.append((i + 1, current_cost))  # (end_index, cost)\n        return results\n\ndef minCostToFormTarget(target, words, costs):\n    n = len(target)\n    \n    # Build Trie\n    trie = Trie()\n    for word, cost in zip(words, costs):\n        trie.insert(word, cost)\n    \n    # Min-heap to keep track of the minimum cost to reach each position\n    min_heap = [(0, 0)]  # (cost, index)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    while min_heap:\n        current_cost, i = heapq.heappop(min_heap)\n        \n        if current_cost > dp[i]:\n            continue\n        \n        for end_index, word_cost in trie.get_words_starting_at(target, i):\n            new_cost = current_cost + word_cost\n            if new_cost < dp[end_index]:\n                dp[end_index] = new_cost\n                heapq.heappush(min_heap, (new_cost, end_index))\n    \n    return dp[n] if dp[n] != float('inf') else -1\n\n\nclass Solution:\n    def minimumCost(self, t: str, w: List[str], c: List[int]) -> int:\n        return minCostToFormTarget(t, w, c)\n    \n#         INF = 1000000000\n        \n#         n = len(t)\n        \n#         mp = {}\n#         for v, cst in zip(w, c):\n#             x = get_hash(v)\n#             if x not in mp:\n#                 mp[x] = INF\n#             mp[x] = min(mp[x], cst)\n            \n        \n#         dp = [0] + [INF for _ in range(n)]\n        \n#         H = ComputeHash(t)\n        \n#         for i in range(1, n + 1):\n#             for j in range(i):\n                \n#                 key = H.get_hash(j, i - 1)\n                \n#                 if key in mp:\n\n#                     dp[i] = min(dp[i], mp[key] + dp[j])\n        \n#         if dp[-1] == INF:\n#             dp[-1] = -1\n        \n#         return dp[-1]",
    "submit_ts": "1720322609",
    "subm_id": "1312354456"
}