{
    "username": "cybsbbbb",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        n = len(edges1) + 1\n        m = len(edges2) + 1\n        \n        tree1 = collections.defaultdict(list)\n        for edge in edges1:\n            tree1[edge[0]].append(edge[1])\n            tree1[edge[1]].append(edge[0])\n        \n        tree2 = collections.defaultdict(list)\n        for edge in edges2:\n            tree2[edge[0]].append(edge[1])\n            tree2[edge[1]].append(edge[0])\n        \n        def find_farest(node, tree):\n            seen = set()\n            seen.add(node)\n            farest_depth = 0\n            farest_node = node\n            curr_lvl = [node]\n            while len(curr_lvl) > 0:\n                nxt_lvl = []\n                for cur_node in curr_lvl:\n                    for nxt_node in tree[cur_node]:\n                        if nxt_node not in seen:\n                            nxt_lvl.append(nxt_node)\n                            seen.add(nxt_node)\n                if len(nxt_lvl) > 0:\n                    farest_depth += 1\n                    farest_node = nxt_lvl[0]\n                curr_lvl = nxt_lvl\n            \n            return farest_depth, farest_node\n        \n        farest_depth_1, farest_node_1 = find_farest(0, tree1)\n        longest_1 = find_farest(farest_node_1, tree1)[0]\n        \n        farest_depth_2, farest_node_2 = find_farest(0, tree2)\n        longest_2 = find_farest(farest_node_2, tree2)[0]\n        \n        # print(longest_1, longest_2)\n        \n        ans = max(longest_1, longest_2, (longest_1 + 1) // 2 + (longest_2 + 1) // 2 + 1)\n        \n        return ans\n",
    "submit_ts": "1719716762",
    "subm_id": "1304373370"
}