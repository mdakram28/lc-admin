{
    "username": "DasariUdayasri",
    "submission": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int diameter1 = findDiameter(edges1);\n        int diameter2 = findDiameter(edges2);\n\n        return Math.max(Math.max(diameter1, diameter2), (diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1);\n    }\n\n    private int findDiameter(int[][] edges) {\n        int n = edges.length + 1;\n        List<Integer>[] tree = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            tree[i] = new ArrayList<>();\n        }\n        for (int[] edge : edges) {\n            tree[edge[0]].add(edge[1]);\n            tree[edge[1]].add(edge[0]);\n        }\n\n        int[] farthest = bfs(tree, 0);\n        int[] farthestFromFarthest = bfs(tree, farthest[0]);\n\n        return farthestFromFarthest[1];\n    }\n\n    private int[] bfs(List<Integer>[] tree, int start) {\n        int n = tree.length;\n        int[] dist = new int[n];\n        Arrays.fill(dist, -1);\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(start);\n        dist[start] = 0;\n\n        int farthestNode = start;\n        int maxDist = 0;\n\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            for (int neighbor : tree[node]) {\n                if (dist[neighbor] == -1) {\n                    dist[neighbor] = dist[node] + 1;\n                    queue.add(neighbor);\n                    if (dist[neighbor] > maxDist) {\n                        maxDist = dist[neighbor];\n                        farthestNode = neighbor;\n                    }\n                }\n            }\n        }\n\n        return new int[] {farthestNode, maxDist};\n    }\n}",
    "submit_ts": "1719718664",
    "subm_id": "1304422985"
}