{
    "username": "sarvottam kumar",
    "submission": "class Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& board) {\n//         int m = board.size();\n//     int n = board[0].size();\n//     int max_sum = INT_MIN;\n\n//     // Iterate over all combinations of 3 rows\n//     for (int r1 = 0; r1 < m; ++r1) {\n//         for (int r2 = r1 + 1; r2 < m; ++r2) {\n//             for (int r3 = r2 + 1; r3 < m; ++r3) {\n//                 // Iterate over all combinations of 3 columns\n//                 for (int c1 = 0; c1 < n; ++c1) {\n//                     for (int c2 = c1 + 1; c2 < n; ++c2) {\n//                         for (int c3 = c2 + 1; c3 < n; ++c3) {\n//                             // Calculate the sum of the selected cells\n//                             int current_sum = board[r1][c1] + board[r2][c2] + board[r3][c3];\n//                             max_sum = max(max_sum, current_sum);\n//                         }\n//                     }\n//                 }\n//             }\n//         }\n//     }\n\n//     return max_sum;\n//     int n = board.size();\n//     int m = board[0].size();\n//         vector<vector<vector<long long int>>> vec(n , vector<vector<long long int>> (m , vector<long long int> (3)));\n//         for(int i=0;i<n;i++){\n//             for(int j=0;j<m;j++){\n//                 vec[i][j] = {board[i][j] , i,j};\n//             }\n//             sort(vec[i].begin(),vec[i].end());\n//         }\n        \n    \n    \n//         long long ans = LLONG_MIN; // Initialize with the smallest possible value for long long\n\n//     // Iterate over all combinations of 3 rows and 3 columns\n//     for (int r1 = 0; r1 < n; r1++) {\n//         for (int r2 = 0; r2 < n; r2++) {\n//             for (int r3 = 0; r3 < n; r3++) {\n//                 for (int c1 = m-3; c1 < m; c1++) {\n//                     for (int c2 = m-3; c2 < m; c2++) {\n//                         for (int c3 = m-3; c3 < m; c3++) {\n//                             int x1 = vec[r1][c1][1] , y1 = vec[r1][c1][2] , x2 = vec[r2][c2][1] , y2 = vec[r2][c2][2] , x3 = vec[r3][c3][1] , y3 = vec[r3][c3][2];\n//                             if(x1!=x2 && x2!=x3 && x3!=x1 && y1!=y2 && y2!=y3 && y3!=y1){\n//                                 long long int val = 1ll*vec[r1][c1][0] + (long long)vec[r2][c2][0] + 1ll*vec[r3][c3][0];\n//                                 ans = max( ans , val);\n//                             }\n//                         }\n//                     }\n//                 }\n//             }\n//         }\n//     }\n//     return ans;\n        int n = board.size();\n    int m = board[0].size();\n    long long ans = LLONG_MIN;\n\n    // Store the top 3 values in each row along with their positions\n    vector<vector<tuple<int, int, int>>> top3Rows(n); // (value, row, column)\n\n    for (int i = 0; i < n; ++i) {\n        vector<tuple<int, int, int>> row;\n        for (int j = 0; j < m; ++j) {\n            row.push_back({board[i][j], i, j});\n        }\n        sort(row.rbegin(), row.rend()); // Sort in descending order\n        if (row.size() > 3) row.resize(3); // Keep only the top 3 elements\n        top3Rows[i] = row;\n    }\n\n    // Iterate over combinations of rows\n    for (int r1 = 0; r1 < n; ++r1) {\n        for (int r2 = r1 + 1; r2 < n; ++r2) {\n            for (int r3 = r2 + 1; r3 < n; ++r3) {\n                // Consider all combinations of top 3 elements in these rows\n                for (auto [v1, x1, y1] : top3Rows[r1]) {\n                    for (auto [v2, x2, y2] : top3Rows[r2]) {\n                        for (auto [v3, x3, y3] : top3Rows[r3]) {\n                            if (y1 != y2 && y2 != y3 && y1 != y3) {\n                                long long val = 1LL * v1 + v2 + v3;\n                                ans = max(ans, val);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return ans;\n    }\n};",
    "submit_ts": "1723909029",
    "subm_id": "1359176758"
}