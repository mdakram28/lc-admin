{
    "username": "07socalledcoder859",
    "submission": "#include <bits/stdc++.h>\n\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define yes cout << \"YES\\n\";\n#define no cout << \"NO\\n\";\n#define maxofvec(v) *max_element(v.begin(), v.end())\n#define minofvec(v) *min_element(v.begin(), v.end())\n#define getv(v, n)              \\\n    for (int i = 0; i < n; i++) \\\n        cin >> v[i];\n#define vi(v, n) vector<int> v(n);\n#define pv(v, n)                \\\n    for (int i = 0; i < n; i++) \\\n        cout << v[i] << \" \";\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define ff first\n#define ss second\n#define nl cout << \"\\n\";\n#define inf LLONG_MAX\n#define inm LLONG_MIN\n#define mod 1e9 + 7\n\nclass TrieNode {\npublic:\n    vector<TrieNode*> sid_children;\n    int sid_cost;\n    bool sid_isEndOfWord;\n\n    TrieNode() : sid_children(26, nullptr), sid_cost(INT_MAX), sid_isEndOfWord(false) {}\n};\n\nclass Trie {\npublic:\n    TrieNode* sid_root;\n\n    Trie() {\n        sid_root = new TrieNode();\n    }\n\n    void insertWord(const string& sid_word, int sid_cost) {\n        TrieNode* sid_currentNode = sid_root;\n        for (char c : sid_word) {\n            if (!sid_currentNode->sid_children[c - 'a']) {\n                sid_currentNode->sid_children[c - 'a'] = new TrieNode();\n            }\n            sid_currentNode = sid_currentNode->sid_children[c - 'a'];\n        }\n        sid_currentNode->sid_cost = min(sid_cost, sid_currentNode->sid_cost);\n        sid_currentNode->sid_isEndOfWord = true;\n    }\n\n    TrieNode* getRoot() {\n        return sid_root;\n    }\n};\n\nclass Solution {\npublic:\n    int minimumCost(string sid_target, vector<string>& sid_words, vector<int>& sid_costs) {\n        Trie sid_trie;\n        int sid_targetLength = sid_target.size();\n        vector<int> sid_minimumCosts(sid_targetLength + 1, INT_MAX);\n\n        for (int i = 0; i < sid_words.size(); ++i) {\n            sid_trie.insertWord(sid_words[i], sid_costs[i]);\n        }\n\n        sid_minimumCosts[0] = 0;\n\n        for (int i = 0; i < sid_targetLength; ++i) {\n            if (sid_minimumCosts[i] == INT_MAX) continue;\n\n            TrieNode* sid_currentNode = sid_trie.getRoot();\n            for (int j = i; j < sid_targetLength; ++j) {\n                char c = sid_target[j];\n                if (!sid_currentNode->sid_children[c - 'a']) break;\n                sid_currentNode = sid_currentNode->sid_children[c - 'a'];\n                if (sid_currentNode->sid_isEndOfWord) {\n                    sid_minimumCosts[j + 1] = min(sid_minimumCosts[j + 1], sid_minimumCosts[i] + sid_currentNode->sid_cost);\n                }\n            }\n        }\n\n        return sid_minimumCosts[sid_targetLength] == INT_MAX ? -1 : sid_minimumCosts[sid_targetLength];\n    }\n};\n",
    "submit_ts": "1720323372",
    "subm_id": "1312373942"
}