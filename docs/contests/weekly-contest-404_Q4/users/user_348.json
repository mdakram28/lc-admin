{
    "username": "misakimirai",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n       auto r1 = bfs(edges1, 0);\n    //    cout << \"start: \" << r1[1];\n       r1 = bfs(edges1, r1[1]);\n    //    cout << \". length: \" << r1[0] << endl;\n       auto r2 = bfs(edges2, 0);\n    //    cout << \"start: \" << r2[1];\n       r2 = bfs(edges2, r2[1]);\n    //    cout << \". length: \" << r2[0] << endl;\n       return max((r1[0] + 1) / 2 + 1 + (r2[0] + 1) / 2, max(r1[0], r2[0]));\n    }\n\n    vector<int> bfs(vector<vector<int>>& g, int start) {\n        int n = g.size()+1;\n        deque<int> dq;\n        dq.push_back(start);\n        vector<bool> visited(n, false);\n        visited[start] = true;\n        vector<vector<int>> graph(n);\n        for (vector<int>& edge : g) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n\n        int ans = 0;\n        int last = start;\n        while (!dq.empty()) {\n            int curr_size = dq.size();\n            for (int i = 0; i < curr_size; i++) {\n                int curr = dq.front();\n                dq.pop_front();\n                for (int j : graph[curr]) {\n                    if (!visited[j]) {\n                        dq.push_back(j);\n                        visited[j] = true;\n                    }\n                }\n\n                last = curr;\n            }\n\n            ans++;\n        }\n\n        return {ans - 1, last};\n    }\n};",
    "submit_ts": 1719718604.0
}