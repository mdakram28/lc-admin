{
    "username": "vedantvardhan18",
    "submission": "typedef long long ll;\n//Dont forget to reset MOD if some other MOD is needed\nconst ll MOD = 1e9+7;\n \n//Comment the line above and uncomment the line below if problem requires more than 1 MOD\n//After uncommenting the below line, declaration of mint becomes [ mint<mod> M; ]\n \n//template<ll MOD>\nclass mint\n{\n    //WARNING:\n    //Be very careful not to use two mints with different mods for any operation\n    //No guarantee of behavior in this case\n    public:\n    ll val;\n    static ll mod_exp(ll a, ll b){ ll res=1;   a=a%MOD; while(b>0){ if(b%2==1) res=(res*a)%MOD; b/=2; a=(a*a)%MOD; } return res; }\n    static ll gcdExtended(ll a, ll b, ll *x, ll *y) { if (a == 0) { *x = 0, *y = 1; return b; } ll x1, y1; ll gcd = gcdExtended(b%a, a, &x1, &y1);*x = y1 - (b/a) * x1; *y = x1; return gcd; }\n    static ll modInverse(ll a) { ll x, y; \tll g = gcdExtended(a, MOD, &x, &y); g++; ll res = (x%MOD);\tif(res < 0) res += MOD;\treturn res;} \n    mint(){\tval = 0;} \n    mint(ll x){\tval = x%MOD;\tif(val < 0) val += MOD;}\n    mint& operator +=(const mint &other){\tval += other.val;\tif(val >= MOD) val -= MOD; return (*this); }\n    mint& operator -=(const mint &other){   val -= other.val;if(val < 0) val += MOD;  return (*this); }\n    mint& operator *=(const mint &other){\tval = (val * other.val)%MOD; return (*this); }\n    mint& operator /=(const mint &other){\tval = (val * modInverse(other.val)) % MOD; return (*this); }\n    mint& operator =(const mint &other) { \tval = other.val; return (*this); }\n    mint operator +(const mint &other) const {\treturn mint(*this) += other; }\n    mint operator -(const mint &other) const {\treturn mint(*this) -= other; }\n    mint operator *(const mint &other) const {\treturn mint(*this) *= other; }\n    mint operator /(const mint &other) const {\treturn mint(*this) /= other; }\n    bool operator ==(const mint &other) const {   return val == other.val; }\n \n    mint operator ++() { ++val; if(val == MOD) val = 0; return (*this); }\n    mint operator ++(int) { val++; if(val == MOD) val = 0; return mint(val-1); }\n    mint operator --() { --val; if(val == -1) val = MOD-1; return (*this); }\n    mint operator --(int) { val--; if(val == -1) val = MOD-1; return mint(val+1); }\n \n    // ^ has very low precedence, careful!!\n \n    template<typename T>\n    mint& operator ^=(const T &other){   val = mod_exp(val, other); return (*this); }\n    template<typename T>\n    mint operator ^(const T &other) const {  return mint(*this) ^= other; }\n \n    mint& operator ^=(const mint &other){   val = mod_exp(val, other.val); return (*this); }\n    mint operator ^(const mint &other) const {  return mint(*this) ^= other; }\n \n    template<typename T>\n    explicit operator T() {\treturn (T)val; }\n    template<typename T>\n    friend mint operator +(T other, const mint &M){\treturn mint(other) + M; }\n    template<typename T>\n    friend mint operator -(T other, const mint &M){\treturn mint(other) - M; }\n    template<typename T>\n    friend mint operator *(T other, const mint &M){\treturn mint(other) * M; }\n    template<typename T>\n    friend mint operator /(T other, const mint &M){\treturn mint(other) / M; }\n    template<typename T>\n    friend mint operator ^(T other, const mint &M){\treturn mint(other) ^ M; }\n \n \n    friend std::ostream &operator << (std::ostream &output, const mint &M){  return output << M.val; }\n    friend std::istream &operator >> (std::istream &input, mint &M) { input >> M.val;\tM.val %= MOD;\treturn input;}\n};\nclass Solution {\npublic:\n    int numberOfPermutations(int n, vector<vector<int>> &req) {\n        vector<int>cnt(n,-1);\n        // long long ans=1;\n        for(int i=0;i<req.size();i++){\n            if(cnt[req[i][0]]!=-1){\n                if(cnt[req[i][0]]!=req[i][1]){\n                    return 0;\n                }\n            }\n            cnt[req[i][0]]=req[i][1];\n        }\n        if(cnt[0]>0){\n            return 0;\n        }\n        int mnrng=0;\n        int mxrng=0;\n        vector<vector<mint>>dp(n,vector<mint>(401));\n        dp[0][0]=1;\n        for(int i=1;i<n;i++){\n            mint sum=0;\n            for(int j=0;j<=400;j++){\n                sum+=dp[i-1][j];\n                if((j-i-1)>=0){\n                    sum-=dp[i-1][j-i-1];\n                }\n                dp[i][j]=sum;\n            }\n            if(cnt[i]!=-1){\n                for(int j=0;j<=400;j++){\n                    if(j==cnt[i]){\n                        continue;\n                    }\n                    dp[i][j]=0;\n                }\n            }\n        }\n        return (int)dp[n-1][cnt[n-1]];\n        \n        \n    }\n};",
    "submit_ts": 1719069053.0
}