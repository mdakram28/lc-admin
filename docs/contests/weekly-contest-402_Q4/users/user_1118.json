{
    "username": "dewanshK",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define pb push_back\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<char>> vvc;\ntypedef vector<vector<long long>> vvl;\n#define all(x) (x).begin(), (x).end()\n#define vi vector<int> \n#define vll vector<long long>\ntypedef long double lld;\n\nint mod = 998244353;\nint mod1 = 1e9 +7;\n#define set_bits __builtin_popcountll\n#define sz(x) ((int)(x).size())\n \nvoid print(vector <int> v){int s=v.size();for (int i=0;i<s;i++){cout<<v[i]<<' ';}cout<<\"\\n\";}\nvoid print(vector <ll> v){int s=v.size();for (int i=0;i<s;i++){cout<<v[i]<<' ';}cout<<\"\\n\";}\n\nvector <ll> pre_sum(vector<ll>v){vector <ll>ans={0};for (int i=0;i<v.size();i++)\n    {if (i==0){ans.push_back(v[0]);}\n    else {ans.push_back((ll)ans[i] + (ll)v[i]);}}return ans;}\n\nvector<ll> suf_sum(vector<ll>v){int cnt=-2; vector<ll>ans={};\n    for (int i=v.size()-1;i>=0;i--){cnt++;\n        if (i== v.size()-1){ans.push_back(v[i]);}else{ans.push_back(v[i]+ans[cnt]);}}return ans;}\n\nll nc2(ll n){ll t=1LL*n*(n-1)/2;return t;}\nll nCr(ll n, ll r) {if (r > n) return 0;\n    if (r == 0 || n == r) return 1;long double res = 0;\n    for (int i = 0; i < r; i++) {res += log(n-i) - log(i+1);}return (ll)round(exp(res));}\n\nll fibonacci(int n){\n    ll a=0,b=1,c,i;if(n==0){return a;}for (i=2;i<=n;i++){c=a+b;a=b;b=c;}return b;}\n\nbool isPerfectSquare(ll n){return sqrtl(n)== (ll)sqrtl(n);}\n\nvector<ll> solve_quad(ll a,ll b, ll c){\n    vector<ll>ans; vector<ll>temp={};\n    ll d=b*b; ll e= 4*a*c;\n    if (isPerfectSquare((ll) d-e)){\n        ans.pb((-b + (ll)sqrtl(d-e))/2);\n        ans.pb((-b - (ll)sqrtl(d-e))/2);\n    }\n    if (ans.size()!=0 && ans[0]+ans[1] == -b/a && ans[0]*ans[1]==c/a){return ans;}\n    else {return temp;}\n}\nlong long binpow(long long a, long long b, long long m) {\n    a %= m;\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a % m;\n        a = a * a % m;\n        b >>= 1;\n    }\n    return res;\n}\n\nbool is_prime(ll n){for (ll i=2;1ll*i*i<=n;i++){if (n%i ==0 ) return false;}return true;}\n\nvoid sieve(int lim, vector<ll>&pr) {\n    vector<bool> isPrime(lim + 1, true);\n    for (int p = 2; p * p <= lim; ++p) {\n        if (isPrime[p]) {\n            for (int i = p * p; i <= lim; i += p)\n                isPrime[i] = false;\n        }\n    }\n    for (int p = 2; p <= lim; ++p) {\n        if (isPrime[p])\n            pr.pb(p);\n    }\n}\n//****************************************************************************************************************//\n\nstring to_binary(int n,int len){string binary;for (unsigned i=(1 << len-1);i>0;i=i/2){\n        binary += (n & i) ? \"1\" : \"0\";}return binary;}\n\nll bits_count(ll a){ll n=a;ll cnt=0;\n    while (n!=0){n=(n>>1);cnt++;}return cnt;}\n\nint flipped (ll n, ll k){return (n ^ (1 << (k-1)));}  // 1 indexed from r\n//***************************************************************************************************************//\n\nll gcd(ll a, ll b) {while (b != 0) {ll temp = b;b = a % b;a = temp;}return a;}\nint vectorGCD(vector<ll> ms) {\n    int rs = ms[0];for (int i = 1; i < ms.size(); ++i) {rs = gcd(rs, ms[i]);}return rs;}\n\nvoid get(vector<ll>&v,ll n){for (ll i=0;i<n;i++){if (v.size()==i){ll a; cin>>a; v.pb(a);}else{cin>>v[i];}}}\n\nvector<int> perm_array(vi &v, int size) {   // gives relative ordering such as a permutation (handles dup)\n    vector<int> perm(size);\n    iota(perm.begin(), perm.end(), 0); // Fill with 0, 1, 2, ...\n    sort(perm.begin(), perm.end(), [&v](int a, int b) { return v[a] < v[b]; });\n    vector<int> result(size);\n    int rank = 0;\n    result[perm[0]] = rank;\n    for (int i = 1; i < size; ++i) {\n        if (v[perm[i]] != v[perm[i - 1]]) {\n            rank++;\n        }\n        result[perm[i]] = rank;\n    }\n\n    return result;\n}\n\n//****************************************************************************************************************//\n\n#define debug(x) cout << #x <<\" = \"; _print(x); cout << endl;            // comment this line before submitting\n//#define debug(a)                                                    // uncomment this before submitting\n\ntemplate <typename T>\nvoid _print(T t) {cout << t;}\n\ntemplate <class T, class V> void _print(map <T, V> v);\ntemplate <class T> void _print(vector <T> v);\ntemplate <class T, class V> void _print(pair <T, V> p);\ntemplate <class T> void _print(set <T> v);\ntemplate <class T> void _print(vector<vector<T>> v);\n\ntemplate <class T, class V> void _print(map <T, V> v) {cout << \"[ \"; for (auto i : v) {_print(i); cout << \" \";} cout << \"]\";}\ntemplate <class T> void _print(vector <T> v) {cout << \"[ \"; for (T i : v) {_print(i); cout << \" \";} cout << \"]\";}\ntemplate <class T, class V> void _print(pair <T, V> p) {cout << \"{\"; _print(p.first); cout << \",\"; _print(p.second); cout << \"}\";}\ntemplate <class T> void _print(set <T> v) {cout << \"[ \"; for (T i : v) {_print(i); cout << \" \";} cout << \"]\";}\ntemplate <class T> void _print(vector<vector<T>> v){cout<<\"[ \";for(const auto &iv:v) {_print(iv);cout << \" \";}cout << \"]\";}\n\ntemplate <class T> void _print(queue<T> q) {cout << \"[ \";while (!q.empty()) {_print(q.front());cout << \" \";q.pop();}cout << \"]\";}\ntemplate <class T> void _print(stack<T> s) {cout << \"[ \";stack<T> temp;while (!s.empty()) {temp.push(s.top());s.pop();}\n    while (!temp.empty()) {_print(temp.top());cout << \" \";s.push(temp.top());temp.pop();}cout << \"]\";}\ntemplate <class T> void _print(deque<T> d) {cout << \"[ \";for (auto i : d) {_print(i);cout << \" \";}cout << \"]\";}\n//****************************************************************************************************************//\n\n\nclass SegmentTree {\nprivate:\n    vector<int> segTree;\n    vector<int> nums;\n    int n;\n    \n    int leftChild(int node) { return 2 * node + 1; }\n    int rightChild(int node) { return 2 * node + 2; }\n    \n    bool isPeak(int i) {\n        if (i <= 0 || i >= n - 1) return false;\n        return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    }\n    \n    int buildTree(int start, int end, int node) {\n        if (start == end) {\n            return segTree[node] = isPeak(start) ? 1 : 0;\n        }\n        int mid = start + (end - start) / 2;\n        return segTree[node] = buildTree(start, mid, leftChild(node)) + buildTree(mid + 1, end, rightChild(node));\n    }\n    \n    int rangeQuery(int node, int start, int end, int l, int r) {\n        if (r < start || l > end) return 0;\n        if (l <= start && end <= r) return segTree[node];\n        int mid = start + (end - start) / 2;\n        return rangeQuery(leftChild(node), start, mid, l, r) + rangeQuery(rightChild(node), mid + 1, end, l, r);\n    }\n    \n    void pointUpdate(int start, int end, int node, int index) {\n        if (start == end) {\n            segTree[node] = isPeak(index) ? 1 : 0;\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        if (index <= mid) pointUpdate(start, mid, leftChild(node), index);\n        else pointUpdate(mid + 1, end, rightChild(node), index);\n        segTree[node] = segTree[leftChild(node)] + segTree[rightChild(node)];\n    }\n    \npublic:\n    SegmentTree(const vector<int>& arr) : nums(arr) {\n        n = nums.size();\n        segTree.resize(4 * n);\n        buildTree(0, n - 1, 0);\n    }\n    \n    int rangeQuery(int l, int r) {\n        if (l >= r) return 0;\n        return rangeQuery(0, 0, n - 1, l + 1, r - 1);\n    }\n    \n    void pointUpdate(int index, int value) {\n        nums[index] = value;\n        if (index > 0) pointUpdate(0, n - 1, 0, index - 1);\n        pointUpdate(0, n - 1, 0, index);\n        if (index < n - 1) pointUpdate(0, n - 1, 0, index + 1);\n    }\n};\n\n\nclass DSU {\nprivate:\n    vector<int> par, rank;\npublic:\n    DSU(int n) {par.resize(n); rank.resize(n, 0); for (int i = 0; i < n; i++) par[i] = i;}\n\n    int find(int node) {if (par[node] == node) return node; return par[node] = find(par[node]); }\n\n    void uni(int u, int v) {\n        int paru = find(u); int parv = find(v); if (paru == parv) return;\n        if (rank[paru] > rank[parv]) {par[parv] = paru;} else if (rank[paru] < rank[parv]) {par[paru] = parv;} \n        else {par[paru] = parv;rank[parv]++;}\n    }\n\n    bool oneseg() {map<int, int> m;for (int i = 0; i < par.size(); i++) {m[find(i)]++;}return m.size() == 1;}\n};\n//****************************************************************************************************************//\n\n// int lim = 100005;\n// vi primes = sieve(lim-1);\n// vvi prime_fac(lim);\n// for (int p:primes){\n//     for (int i=p;i<=lim-1;i+=p){\n//         prime_fac[i].pb(p);\n//     }\n// }\n\n//****************************************************************************************************************//\n\n// interval ans on ids/size only\n// dp - prev states\n// see tc short examples // brute force some testcases by writing code \n// bs - whenever max/min comes think bs/linear search on ANSWER  \n// manacher\n// median - replace with 1 and -1\n// don't try on whole array at one, try on analyzing one/two/some elements \n// in operations think elementwise contri and which element is must to do operation on\n// prefix xor\n// make hypothesis check hypothesis !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// reverse simulation whenever asked from front\n// simulate first \n\n// VVI - always write boolean operators &, |, ^ etc. in seperate brackets !!!!!!!!!!!!!!\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        SegmentTree st(nums);\n        vector<int> result;\n        for (auto& query : queries) {\n            if (query[0] == 1) {\n                int li = query[1];\n                int ri = query[2];\n                result.push_back(st.rangeQuery(li, ri));\n            } \n            else {\n                int index = query[1];\n                int value = query[2];\n                st.pointUpdate(index, value);\n            }\n        }\n        \n        return result;\n    }\n};",
    "submit_ts": 1718508986.0
}