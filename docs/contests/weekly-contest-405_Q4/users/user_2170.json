{
    "username": "suraj_0491",
    "submission": "const int redit = INT_MAX;\n\n// TrieNode structure for Trie implementation\nstruct facbk {\n    vector<facbk *> elite; \n    int edit;                   \n    bool isEnd;                  \n\n    facbk() : \n        elite(26, nullptr),   \n        edit(redit),         \n        isEnd(false)             \n    {}\n};\n\n// Trie class for storing words and associated costs\nclass Trie\n{\npublic:\n    facbk *root; // Rename facbk to root\n\n    Trie()\n    {\n        root = new facbk(); \n    }\n\n    // Method to add a word and its associated cost to the Trie\n    void continAaddi(const string &word, int cost)\n    {\n        facbk *node = root;\n        int i = 0;\n        while (i < word.size())\n        {\n            char c = word[i];\n            if (!node->elite[c - 'a'])\n            {\n                node->elite[c - 'a'] = new facbk(); \n            }\n            node = node->elite[c - 'a']; \n            i++;\n        }\n\n        node->edit = min(cost, node->edit); \n        node->isEnd = true; \n    }\n\n    // Method to get the root node of the Trie\n    facbk *getRoot()\n    {\n        return root;\n    }\n};\n\n// Solution class containing the algorithm to find minimum cost for forming target string from words\nclass Solution\n{\npublic:\n    // Function to find minimum cost to form target string from given words\n    int minimumCost(string target, vector<string> &words, vector<int> &costs)\n    {\n        Trie trie;\n        int len = target.size();\n        vector<int> minCost(len + 1, redit); \n\n        // Insert all words and their costs into Trie\n        int i = 0;\n        while (i < words.size())\n        {\n            trie.continAaddi(words[i], costs[i]);\n            i++;\n        }\n\n        minCost[0] = 0; \n\n        // Calculate minimum cost for each prefix of target string\n        for (int i = 0; i < len; ++i)\n        {\n            if (minCost[i] == redit)\n                continue; \n\n            facbk *node = trie.getRoot();\n            int j = i;\n            while (j < len && node->elite[target[j] - 'a'])\n            {\n                node = node->elite[target[j] - 'a']; \n                if (node->isEnd)\n                {\n                    minCost[j + 1] = min(minCost[j + 1], minCost[i] + node->edit);\n                }\n                ++j;\n            }\n        }\n\n        // Return minimum cost to form the entire target string; return -1 if not possible\n        return minCost[len] == redit ? -1 : minCost[len];\n    }\n};\n",
    "submit_ts": "1720324329",
    "subm_id": "1312396883"
}