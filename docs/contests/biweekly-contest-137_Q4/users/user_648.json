{
    "username": "Aastha222002",
    "submission": "class Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& board) {\n        /* int m = board.size();\n        int n = board[0].size();\n        long long maxSum = LLONG_MIN;\n\n        // Iterate over all possible combinations of rows and columns\n        for (int r1 = 0; r1 < m; ++r1) {\n            for (int r2 = 0; r2 < m; ++r2) {\n                if (r2 == r1) continue; // Ensure different rows\n\n                for (int r3 = 0; r3 < m; ++r3) {\n                    if (r3 == r1 || r3 == r2) continue; // Ensure different rows\n                    \n                    // Iterate over all possible columns\n                    for (int c1 = 0; c1 < n; ++c1) {\n                        for (int c2 = 0; c2 < n; ++c2) {\n                            if (c2 == c1) continue; // Ensure different columns\n                            \n                            for (int c3 = 0; c3 < n; ++c3) {\n                                if (c3 == c1 || c3 == c2) continue; // Ensure different columns\n\n                                // Calculate the sum for the current configuration of rooks\n                                long long currentSum = static_cast<long long>(board[r1][c1]) \n                                                     + static_cast<long long>(board[r2][c2]) \n                                                     + static_cast<long long>(board[r3][c3]);\n\n                                maxSum = max(maxSum, currentSum);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return maxSum; */\n\n         int m = board.size();\n    int n = board[0].size();\n    \n    // Step 1: Find top 3 elements in each row\n    vector<vector<pair<int, int>>> topThree(m);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            topThree[i].push_back({board[i][j], j});\n        }\n        partial_sort(topThree[i].begin(), topThree[i].begin() + min(3, (int)topThree[i].size()), topThree[i].end(),\n                     greater<pair<int, int>>());\n        topThree[i].resize(min(3, (int)topThree[i].size()));\n    }\n    \n    // Step 2: Sort rows based on their maximum element\n    vector<int> rowOrder(m);\n    iota(rowOrder.begin(), rowOrder.end(), 0);\n    sort(rowOrder.begin(), rowOrder.end(),\n         [&](int a, int b) { return topThree[a][0].first > topThree[b][0].first; });\n    \n    long long maxSum = LLONG_MIN;\n    \n    // Step 3: Generate combinations and check column constraint\n    for (int i = 0; i < min(5, m); i++) {\n        for (int j = i + 1; j < min(6, m); j++) {\n            for (int k = j + 1; k < min(7, m); k++) {\n                for (auto& x : topThree[rowOrder[i]]) {\n                    for (auto& y : topThree[rowOrder[j]]) {\n                        for (auto& z : topThree[rowOrder[k]]) {\n                            if (x.second != y.second && y.second != z.second && z.second != x.second) {\n                                maxSum = max(maxSum, (long long)x.first + y.first + z.first);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return maxSum;\n    }\n};",
    "submit_ts": "1723910279",
    "subm_id": "1359224123"
}