{
    "username": "arthur_g",
    "submission": "class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Python3 implementation of the approach\n        MAX = 300000\n\n        # Ideally, we should not use global variables\n        # and large constant-sized arrays, we have\n        # done it here for simplicity.\n        tree = [0] * MAX  # To store segment tree\n        lazy = [0] * MAX; \n\n        \"\"\" si -> index of current node in segment tree \n            ss and se -> Starting and ending indexes of elements \n                        for which current nodes stores sum. \n            us and ue -> starting and ending indexes of update query \n            diff -> which we need to add in the range us to ue \"\"\"\n\n\n        def updateRangeUtil(si, ss, se, us, ue, diff) : \n        \n            # If lazy value is non-zero for current node\n            # of segment tree, then there are some \n            # pending updates. So we need to make sure \n            # that the pending updates are done before \n            # making new updates. Because this value may be \n            # used by parent after recursive calls \n            # (See last line of this function) \n            if (lazy[si] != 0) :\n                \n                # Make pending updates using value \n                # stored in lazy nodes \n                tree[si] = 0; \n        \n                # checking if it is not leaf node because if \n                # it is leaf node then we cannot go further \n                if (ss != se) :\n                \n                    # We can postpone updating children we don't \n                    # need their new values now. \n                    # Since we are not yet updating children of si, \n                    # we need to set lazy flags for the children \n                    lazy[si * 2 + 1] += lazy[si]; \n                    lazy[si * 2 + 2] += lazy[si]; \n                \n                # Set the lazy value for current node \n                # as 0 as it has been updated \n                lazy[si] = 0; \n            \n            # out of range \n            if (ss > se or ss > ue or se < us) :\n                return ; \n        \n            # Current segment is fully in range \n            if (ss >= us and se <= ue) :\n                \n                # Add the difference to current node \n                tree[si] = 0; \n        \n                # same logic for checking leaf node or not \n                if (ss != se) :\n                \n                    # This is where we store values in lazy nodes, \n                    # rather than updating the segment tree itself \n                    # Since we don't need these updated values now \n                    # we postpone updates by storing values in lazy[] \n                    lazy[si * 2 + 1] = 1; \n                    lazy[si * 2 + 2] = 1; \n                \n                return; \n        \n            # If not completely in rang, but overlaps, \n            # recur for children, \n            mid = (ss + se) // 2; \n            updateRangeUtil(si * 2 + 1, ss,\n                            mid, us, ue, diff); \n            updateRangeUtil(si * 2 + 2, mid + 1, \n                            se, us, ue, diff); \n        \n            # And use the result of children calls \n            # to update this node \n            tree[si] = tree[si * 2 + 1] + \\\n                    tree[si * 2 + 2]; \n\n\n        ''' us and eu -> starting and ending indexes \n                        of update query \n            ue -> ending index of update query \n            diff -> which we need to add in the range us to ue '''\n\n\n        def updateRange(n, us, ue, diff):\n            updateRangeUtil(0, 0, n - 1, us, ue, diff)\n\n\n        ''' A recursive function to get the sum of values \n            in given range of the array. The following are \n            parameters for this function. \n            si --> Index of current node in the segment tree. \n                Initially 0 is passed as root is always at' \n                index 0 \n            ss & se --> Starting and ending indexes of the \n                        segment represented by current node, \n                        i.e., tree[si] \n            qs & qe --> Starting and ending indexes of query \n                        range '''\n\n\n        def getSumUtil(ss, se, qs, qe, si):\n\n            # Out of range\n            if (ss > se or ss > qe or se < qs):\n                return 0\n\n            # At this point we are sure that\n            # pending lazy updates are done for\n            # current node. So we can return value\n            # (same as it was for query in our previous post)\n\n            # If this segment lies in range\n            if (ss >= qs and se <= qe):\n                return tree[si]\n\n            # If a part of this segment overlaps\n            # with the given range\n            mid = (ss + se) // 2\n            return (getSumUtil(ss, mid, qs, qe, 2 * si + 1) +\n                    getSumUtil(mid + 1, se, qs, qe, 2 * si + 2))\n\n        # Return sum of elements in range from\n        # index qs (query start) to qe (query end).\n        # It mainly uses getSumUtil()\n\n\n        def getSum(n, qs, qe):\n\n            # Check for erroneous input values\n            if (qs < 0 or qe > n - 1 or qs > qe):\n                print(\"Invalid Input\")\n                return -1\n\n            return getSumUtil(0, n - 1, qs, qe, 0)\n\n        # A recursive function that constructs\n        # Segment Tree for array[ss..se].\n        # si is index of current node in segment\n        # tree st.\n\n\n        def constructSTUtil(arr, ss, se, si):\n\n            # out of range as ss can never be\n            # greater than se\n            if (ss > se):\n                return\n\n            # If there is one element in array,\n            # store it in current node of\n            # segment tree and return\n            if (ss == se):\n\n                tree[si] = arr[ss]\n                return\n\n            # If there are more than one elements,\n            # then recur for left and right subtrees\n            # and store the sum of values in this node\n            mid = (ss + se) // 2\n            constructSTUtil(arr, ss, mid, si * 2 + 1)\n            constructSTUtil(arr, mid + 1, se, si * 2 + 2)\n\n            tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2]\n\n\n        ''' Function to construct segment tree \n        from given array. This function allocates memory \n        for segment tree and calls constructSTUtil() \n        to fill the allocated memory '''\n\n\n        def constructST(arr, n):\n\n            # Fill the allocated memory st\n            constructSTUtil(arr, 0, n - 1, 0)\n\n        arr = [1] * (n - 1)\n        constructST(arr, n-1)\n\n        ans = []\n        for i, j in queries:\n            # s = getSum(n - 1, i, j-2)\n            # delta = s / (j-1 - i)\n            # print(\"Set \", i, j-2, delta)\n            updateRange(n - 1, i, j-2, 0)\n\n            ans_curr = int(getSum(n, 0, n-1))\n            ans.append(ans_curr)\n        return ans \n\n",
    "submit_ts": "1722743645",
    "subm_id": "1343796538"
}