{
    "username": "MayankSavaliya",
    "submission": "class Solution {\npublic:\n    class Graph\n    {\n        public:\n            int num_of_vertices;\n            vector<int> *adj;\n            vector<int> degree;\n            Graph(int num)\n            {\n                this->num_of_vertices = num;\n                adj = new vector<int>[num_of_vertices];\n\n                for (int i = 0; i < num_of_vertices; i++)\n                    degree.push_back(0);\n            }    \n            void AddEdge(int v1, int v2)\n            {\n                adj[v1].push_back(v2);\n                adj[v2].push_back(v1);\n                degree[v1]++;        \n                degree[v2]++;        \n            }\n\n            int MinimumHeight()\n            {\n                queue<int> q;\n                for (int iter = 0; iter < num_of_vertices; iter++)\n                    if (degree[iter] == 1)\n                        q.push(iter);\n                while (num_of_vertices > 2)\n                {\n                    num_of_vertices = num_of_vertices - q.size();\n\n                    int tmp=q.size();\n\n                    for (int i = 0; i < tmp; i++)\n                    {\n                        int root = q.front();\n                        q.pop();\n\n                        for (auto current_node = adj[root].begin(); current_node != adj[root].end();current_node++)\n                        {\n                            degree[*current_node] -= 1;\n                            if (degree[*current_node] == 1)\n                                q.push(*current_node);\n                        }\n                    }\n                }\n                int ans=0;\n                while (!q.empty())\n                {\n                    ans=q.front();\n                    break;\n                }\n                return ans;\n            }\n    };\n    int dfs(int node,int parent,vector<vector<int>> &v){\n        int ans=1;\n        for(auto it:v[node]){\n            if(it==parent) continue;\n             ans=max(ans,1+dfs(it,node,v));\n        }\n        return ans;\n    }\n    int checkheight(int n,vector<vector<int>> &v){\n        vector<bool> vis(n, false);\n        queue<int> q;\n        q.push(0);\n        vis[0] = true;\n        int nLast;\n        while (!q.empty())\n        {\n            int node = q.front();\n            nLast = node;\n            q.pop();\n            for (auto it : v[node])\n            {\n                if (!vis[it])\n                {\n                    vis[it] = true;\n                    q.push(it);\n                }\n            }\n        }\n        for (int i = 0; i < n; i++)\n        {\n            vis[i] = false;\n        }\n        return dfs(nLast,-1 ,v);\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n=edges1.size()+1,m=edges2.size()+1;\n        Graph G1(n),G2(m);\n        vector<vector<int>> v1(n),v2(m);\n        for(auto it:edges1) G1.AddEdge(it[0],it[1]);\n        for(auto it:edges2) G2.AddEdge(it[0],it[1]);\n        for(auto it:edges1){\n            v1[it[0]].push_back(it[1]);\n            v1[it[1]].push_back(it[0]);\n        }\n        for(auto it:edges2){\n            v2[it[0]].push_back(it[1]);\n            v2[it[1]].push_back(it[0]);\n        }\n        int root1=G1.MinimumHeight(),root2=G2.MinimumHeight();\n        cout<<root1<<\" \"<<root2<<endl;\n        int ans=dfs(root1,-1,v1)+dfs(root2,-1,v2);\n        ans=max(ans,checkheight(n,v1));\n        ans=max(ans,checkheight(m,v2));\n        return ans-1;\n    }\n};",
    "submit_ts": "1719719062",
    "subm_id": "1304432826"
}