{
    "username": "prakharrrr4",
    "submission": "#define ll long long\n\ntemplate<class S,\n  S(*op)(S, S),\n  S(*e)(),\n  class F,\n  S(*mapping)(F, S),\n  F(*composition)(F, F),\n  F(*id)()>\n  struct lazy_segtree {\n\n  private:\n    int s, _n;\n    vector<S> st;\n    vector<F> lt;\n    void construct(int pos, int l, int r, vector<S>& ind)\n    {\n\n      if (l == r)\n      {\n        st[pos] = ind[l];\n        return;\n      }\n      int mid = (l + r) / 2;\n      construct(pos * 2 + 1, l, mid, ind);\n      construct(pos * 2 + 2, mid + 1, r, ind);\n      st[pos] = op(st[pos * 2 + 1], st[pos * 2 + 2]);\n    }\n    void update(int i, int j, int l, int r, F val, int pos)\n    {\n\n      st[pos] = mapping(lt[pos], st[pos]);\n      if (l != r)\n      {\n        lt[pos * 2 + 1] = composition(lt[pos], lt[pos * 2 + 1]);\n        lt[pos * 2 + 2] = composition(lt[pos], lt[pos * 2 + 2]);\n      }\n      lt[pos] = id();\n\n\n\n      if (l > r || l > j || r < i)\n        return;\n\n      if (i <= l && j >= r)\n      {\n        st[pos] = mapping(val, st[pos]);\n        if (l != r)\n        {\n          lt[pos * 2 + 1] = composition(val, lt[pos * 2 + 1]);\n          lt[pos * 2 + 2] = composition(val, lt[pos * 2 + 2]);\n        }\n        return;\n      }\n      int mid = (l + r) / 2;\n      update(i, j, l, mid, val, 2 * pos + 1);\n      update(i, j, mid + 1, r, val, 2 * pos + 2);\n      st[pos] = op(st[pos * 2 + 1], st[pos * 2 + 2]);\n    }\n    void update(int i, int j, int l, int r, S val, int pos)\n    {\n\n\n      st[pos] = mapping(lt[pos], st[pos]);\n      if (l != r)\n      {\n        lt[pos * 2 + 1] = composition(lt[pos], lt[pos * 2 + 1]);\n        lt[pos * 2 + 2] = composition(lt[pos], lt[pos * 2 + 2]);\n      }\n      lt[pos] = id();\n\n\n\n      if (l > r || l > j || r < i)\n        return;\n\n      if (l == r)\n      {\n        st[pos] = val;\n        return;\n      }\n\n\n      int mid = (l + r) / 2;\n      update(i, j, l, mid, val, 2 * pos + 1);\n      update(i, j, mid + 1, r, val, 2 * pos + 2);\n      st[pos] = op(st[pos * 2 + 1], st[pos * 2 + 2]);\n    }\n    S query(int i, int j, int l, int r, int pos)\n    {\n      st[pos] = mapping(lt[pos], st[pos]);\n      if (l != r)\n      {\n        lt[pos * 2 + 1] = composition(lt[pos], lt[pos * 2 + 1]);\n        lt[pos * 2 + 2] = composition(lt[pos], lt[pos * 2 + 2]);\n      }\n      lt[pos] = id();\n\n\n      if (l > r || l > j || r < i)\n        return e();\n      if (i <= l && j >= r)\n        return st[pos];\n      int mid = (l + r) / 2;\n      return  op(query(i, j, l, mid, pos * 2 + 1), query(i, j, mid + 1, r, pos * 2 + 2));\n\n    }\n\n    /*\n    * bs() will function as follows:-\n    * For a range (l,r)\n    * we will consider following terms:\n    * op(l,l), op(l,l+1), op(l,l+2).... op(l,l+r)\n    * [True,True,False,False...False]\n    * It will then return the index on which first false value occurs\n    */\n    void bs(int i, int j, int l, int r, int pos, bool(*fun)(S), int& ans)\n    {\n      assert(l >= 0 && l < _n);\n      assert(r >= 0 && r < _n);\n      assert(r >= l);\n\n      st[pos] = mapping(lt[pos], st[pos]);\n      if (l != r)\n      {\n        lt[pos * 2 + 1] = composition(lt[pos], lt[pos * 2 + 1]);\n        lt[pos * 2 + 2] = composition(lt[pos], lt[pos * 2 + 2]);\n      }\n      lt[pos] = id();\n\n\n\n      if (l > r || l > j || r < i)\n        return;\n\n      if (l == r)\n      {\n        if (fun(st[pos]) == false)\n\n        {\n        \n          ans = min(ans, r);\n        }\n        return;\n      }\n\n      if (i <= l && j >= r)\n      {\n        if (fun(st[pos]) == false)\n        {\n           \n          ans = min(ans, r);\n\n          int mid = (l + r) / 2;\n          \n          if (fun(mapping(lt[pos*2+1],st[pos*2+1])) == false)\n          {\n            bs(i, j, l, mid, 2 * pos + 1, fun, ans);\n          }\n          else if (fun(mapping(lt[pos * 2 + 2], st[pos * 2 + 2])) == false) bs(i, j, mid + 1, r, 2 * pos + 2, fun, ans);\n\n        }\n        return;\n      }\n\n\n      int mid = (l + r) / 2;\n      bs(i, j, l, mid, 2 * pos + 1, fun, ans);\n      bs(i, j, mid + 1, r, 2 * pos + 2, fun, ans);\n\n      return;\n    }\n    /*\n    * rbs() will function as follows:-\n    * For a range (l,r)\n    * we will consider following terms:\n    * op(l,r), op(l+1,r), op(l+3,r).... op(r,r)\n    * [False,False,True,True,True]\n    * It will then return the index on which last false value occurs\n    */\n    void rbs(int i, int j, int l, int r, int pos, bool(*fun)(S), int& ans)\n    {\n      assert(l >= 0 && l < _n);\n      assert(r >= 0 && r < _n);\n      assert(r >= l);\n\n      st[pos] = mapping(lt[pos], st[pos]);\n      if (l != r)\n      {\n        lt[pos * 2 + 1] = composition(lt[pos], lt[pos * 2 + 1]);\n        lt[pos * 2 + 2] = composition(lt[pos], lt[pos * 2 + 2]);\n      }\n      lt[pos] = id();\n\n\n\n      if (l > r || l > j || r < i)\n        return;\n\n      if (l == r)\n      {\n        if (fun(st[pos]) == false)\n          ans = max(ans, l);\n        return;\n      }\n\n      if (i <= l && j >= r)\n      {\n        if (fun(st[pos]) == false)\n        {\n          ans = max(ans, l);\n\n          int mid = (l + r) / 2;\n          if (fun(mapping(lt[pos*2+2],st[pos*2+2])) == false) rbs(i, j, l, mid, 2 * pos + 2, fun, ans);\n          else if(fun(mapping(lt[pos * 2 + 1], st[pos * 2 + 1]))==false) rbs(i, j, mid + 1, r, 2 * pos + 1, fun, ans);\n\n        }\n        return;\n      }\n\n\n      int mid = (l + r) / 2;\n      rbs(i, j, mid + 1, r, 2 * pos + 2, fun, ans);\n      rbs(i, j, l, mid, 2 * pos + 1, fun, ans);\n\n\n      return;\n    }\n  public:\n    lazy_segtree() :lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(vector<S>(n, e())) {}\n    lazy_segtree(vector<S>& v) : _n(int(v.size())) {\n      assert(_n > 0);\n      int s = ceil(log2(_n));\n      s = pow(2, s + 1) - 1;\n      st.clear();\n      st.resize(s, e());\n      construct(0, 0, _n - 1, v);\n      lt.clear();\n      lt.resize(s, id());\n    }\n    void update(int i, F val)\n    {\n      assert(i >= 0 && i < _n);\n      update(i, i, 0, _n - 1, val, 0);\n    }\n    void set(int i, S val)\n    {\n      assert(i >= 0 && i < _n);\n      update(i, i, 0, _n - 1, val, 0);\n    }\n    void update(int i, int j, F val)\n    {\n      assert(i >= 0 && i < _n);\n      assert(i <= j && j >= 0 && j < _n);\n      update(i, j, 0, _n - 1, val, 0);\n    }\n    S query(int i)\n    {\n      assert(i >= 0 && i < _n);\n      return query(i, i, 0, _n - 1, 0);\n    }\n    S query(int i, int j)\n    {\n      assert(i >= 0 && i < _n);\n      assert(i <= j && j >= 0 && j < _n);\n      return query(i, j, 0, _n - 1, 0);\n    }\n    template<bool (*fun)(S)>int bs(int l, int r)\n    {\n      assert(l >= 0 && l < _n);\n      assert(r >= l && r >= 0 && r < _n);\n      assert(fun(e()) == true);\n      int ans = r + 1;\n      bs(l, r, 0, _n - 1, 0, fun, ans);\n      return ans;\n    }\n    template<bool (*fun)(S)>int rbs(int l, int r)\n    {\n      assert(l >= 0 && l < _n);\n      assert(r >= l && r >= 0 && r < _n);\n      assert(fun(e()) == true);\n      int ans = l - 1;\n      rbs(l, r, 0, _n - 1, 0, fun, ans);\n      return ans;\n    }\n\n};\nstruct S\n{\n  ll sum, len; \n};\nstruct F\n{\n  ll a,b;\n};\nS op(S l, S r)\n{\n  return S{ l.sum+r.sum,l.len+r.len };\n}\nS e()\n{\n  return S{0,0};\n}\nS mapping(F l, S r)\n{\n  ll a = r.sum*l.a + r.len * l.b;\n  return S{ a,r.len };\n}\nF composition(F l, F r)\n{\n  ll a, b;\n  a = l.a * r.a;\n  b = l.a * r.b + l.b;\n  return F{ a,b };\n}\nF id() {\n  return F{1,0};\n}\n\n\n\n\nclass Solution {\npublic:\n\n  \n    \n\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int> ret;\n        vector<S> node(n+1,S{1,1});\n        lazy_segtree<S,op,e,F,mapping,composition,id> seg(node);\n        int ans = n-1;\n        for(auto q:queries)\n        {\n            int l = q[0]+1;\n            int r = q[1];\n            if(l<=r)\n            {\n                auto v = seg.query(l,r).sum;\n                if(v!=0)\n                {\n                    ans += 1 - v;\n                    seg.update(l,r,F{0,0});\n                    seg.update(r,r,F{1,1});\n                }\n                ret.push_back(ans);\n            }\n            \n        }\n        return ret;\n    }\n};",
    "submit_ts": "1722742223",
    "subm_id": "1343763933"
}