{
    "username": "sepehry",
    "submission": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nclass SegmentTree {\npublic:\n    SegmentTree(std::function<int(int, int)> combine_op, int default_val, const std::vector<int>& arr = {}) \n        : _combine(combine_op), _default_val(default_val) {\n        if (!arr.empty()) {\n            n = arr.size();\n            heap.resize(_calculate_heap_size(n), default_val);\n            _initialize_heap(arr);\n        } else {\n            n = 0;\n        }\n    }\n\n    int operator[](int i) const {\n        return heap[_heap_index(i)];\n    }\n\n    void update(int i, int x) {\n        int node = _heap_index(i);\n        heap[node] = x;\n        while (node) {\n            node = _parent(node);\n            heap[node] = _combine_children(node);\n        }\n    }\n\n    int query(int i, int j) const {\n        int node1 = _heap_index(i), node2 = _heap_index(j);\n        if (node1 == node2) {\n            return heap[node1];\n        }\n        int result1 = heap[node1];\n        int result2 = heap[node2];\n        while (_parent(node1) != _parent(node2)) {\n            if (_is_left(node1)) {\n                result1 = _combine(result1, heap[_sibling(node1)]);\n            }\n            if (_is_right(node2)) {\n                result2 = _combine(heap[_sibling(node2)], result2);\n            }\n            node1 = _parent(node1);\n            node2 = _parent(node2);\n        }\n        return _combine(result1, result2);\n    }\n\n    int query_all() const {\n        return heap[0];\n    }\n\nprivate:\n    std::vector<int> heap;\n    std::function<int(int, int)> _combine;\n    int _default_val;\n    int n;\n\n    void _initialize_heap(const std::vector<int>& arr) {\n        int node0 = _heap_index(0);\n        std::copy(arr.begin(), arr.end(), heap.begin() + node0);\n        while (node0) {\n            node0 = _parent(node0);\n            for (int node = node0; node < _left(node0); ++node) {\n                heap[node] = _combine_children(node);\n            }\n        }\n    }\n\n    int _combine_children(int parent) const {\n        return _combine(heap[_left(parent)], heap[_right(parent)]);\n    }\n\n    int _parent(int node) const {\n        return (node - 1) >> 1;\n    }\n\n    int _left(int node) const {\n        return 1 + (node << 1);\n    }\n\n    int _right(int node) const {\n        return 2 + (node << 1);\n    }\n\n    int _sibling(int node) const {\n        return node + ((node & 1) << 1) - 1;\n    }\n\n    bool _is_left(int node) const {\n        return (node & 1) == 1;\n    }\n\n    bool _is_right(int node) const {\n        return (node & 1) == 0;\n    }\n\n    int _heap_index(int node) const {\n        return _parent(heap.size()) + node;\n    }\n\n    int _calculate_heap_size(int arr_size) const {\n        return (1 << (1 + static_cast<int>(std::ceil(std::log2(arr_size))))) - 1;\n    }\n};\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        SegmentTree st([](int a, int b) { return a & b; }, 0, nums);\n        \n        struct SA {\n            const SegmentTree& st;\n            int i0;\n\n            SA(const SegmentTree& st, int i0) : st(st), i0(i0) {}\n\n            int operator[](int j) const {\n                return -st.query(i0, j);\n            }\n        };\n\n        int n = nums.size();\n        int sol = std::numeric_limits<int>::max();\n        for (int i0 = 0; i0 < n; ++i0) {\n            SA sa(st, i0);\n\n            // Manually implement binary search\n            int low = i0, high = n;\n            while (low < high) {\n                int mid = low + (high - low) / 2;\n                if (sa[mid] < -k) {\n                    low = mid + 1;\n                } else {\n                    high = mid;\n                }\n            }\n            int j = low;\n\n            if (j < n) {\n                sol = std::min(sol, std::abs(st.query(i0, j) - k));\n            }\n            if (j > i0) {\n                sol = std::min(sol, std::abs(st.query(i0, j - 1) - k));\n            }\n        }\n        return sol;\n    }\n};\n",
    "submit_ts": "1717298880",
    "subm_id": "1274794402"
}