{
    "username": "Amit_321",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace chrono;\n\n#define D             double\n#define in          long long\n#define ll           long long\n#define PI           3.1415926535897932384626\n#define rep(i,num)     for(int i=0;i<num;i++)\n#define repk(i,k,num)  for(int i=k;i<num;i++)\n#define pb           push_back\n#define vec          vector<in>\n#define vecc         vector<vector<in>>\n#define veccc        vector<vector<vector<in>>>\n#define vecll          vector<ll>\n#define vecp         vector<pair<in,in>>\n#define pii            pair<in,in>\n#define pll            pair<ll,ll>\n#define nl             '\\n'\n#define np           cout<<-1<<nl;\n#define ff           first\n#define ss           second\n#define yes          {cout << \"YES\" << nl;}\n#define no           {cout << \"NO\" << nl;}\n#define all(v)       v.begin(),v.end()\n#define rall(v)      v.rbegin(),v.rend()\n#define seev(v)          for(auto i:v)cout<<i<<\" \";\n#define checking            cout<<\"Checking\"<<nl;\n#define pr              pair<int , int >\n#define S                string\n#define print(a)           for(auto x : a) cout << x << \" \";cout<<nl;\n#define printpair(a)       for(auto x : a) cout << x.first << \" \" << x.second<< nl;\n#define c(n)            cin>> n ;\n#define cc(a,b)     cin>>a>>b;\n#define ccc(a,b,c)      cin>>a>>b>>c;\n#define p(n)            cout<<n<<nl;\n#define ps(n)           cout<<n<<' ';\n#define pp(a,b)         cout<<a<<' '<<b<<nl;\n#define ppp(a,b,c)      cout<<a<<' '<<b<<' '<<c<<nl ;\n#define si( v )             (int)v.size()\n#define vin(v) for(int i = 0; i < (int)v.size(); i++) cin>>v[i];\nll bits(ll x) { ll cnt = 0; while (x > 0) { cnt++; x >>= 1; } return cnt; }\nll setbits(ll x) { ll cnt = 0; while (x > 0) { cnt += (x & 1); x >>= 1; } return cnt; }\nint Add(vec a ) {int s = 0 ; for (auto &i : a) s += i ; return s ;}\ntemplate <typename T> void put(T s) { cout << s << '\\n';}\ntemplate <typename T> void puts(T s) { cout << s << \" \";}\n#define ins         insert\n#define pob         pop_back\n#define im          p(\"IMPOSSIBLE\")\n/*****************************#define*************************/\n#define w(x)int x ; cin>>x ;while(x--)\n/******************** Policy_Based****************************/\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate<typename T> using ordset = tree<T, null_type, less_equal<T>, rb_tree_tag,\n                           tree_order_statistics_node_update> ;\n\n// *s.find_by_order(k) -> kth largest element\n// s.order_of_key( val )-> Numbers stricly smaller than val\ntemplate<typename T >\nvoid myerase(ordset<T> & t, T v) {\n    int rank = t.order_of_key(v);//Number of elements that are less than v in t\n    auto   it = t.find_by_order(rank); //Iterator that points to the (rank+1)th element in t\n    t.erase(it);\n}\n\n/******************** Policy_Based****************************/\nconst int modi = 998244353;\nconst int mod = 1e9 + 7;\nconst int N6 = 1000005;\nconst int N5 = 100005 ;\nconst int N3 = 1005 ;\nconst ll INF = 1e18 ;\n\nauto init = []()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 'c';\n}();\n\n\nclass Solution {\npublic:\n    int find( int s , int e , int n , int m , vector<vector<int>>&grid )\n    {\n        int tr = -1 , br = n , lc = e , rc = m ;\n        repk( i , s , n )\n        {\n            int f = 0 ;\n            repk( j, e , m )\n            {\n                if( grid[i][j] == 1 )f = 1 ;\n                // tr = i ;\n            }\n            if( f == 1 )\n                {\n                    tr = i ; break;\n                }\n        }\n        // p(tr) ;\n        for( int i = n-1 ; i >= s ; i-- )\n        {\n            int  f = 0 ; \n            repk( j, e , m )\n            {\n                if( grid[i][j] == 1 )f = 1 ;\n            }\n            // br = i ;\n            if( f == 1 )\n            {\n                br = i ; break ;\n            }\n        }\n        // p(br);\n        if( tr == -1  )return 0 ;\n\n        repk( j ,e ,  m )\n        {\n            int f = 0 ; \n            repk( i, s , n )\n            {\n                if( grid[i][j] == 1 )f =1 ;\n            }\n            if( f )\n            {\n                lc = j ; break ;\n            }\n        }\n        for( int j = m-1 ; j >= e ; j-- )\n        {\n            int f = 0 ; \n            repk( i, s ,n )\n            {\n                if( grid[i][j] == 1 )f = 1 ;\n            }\n            if( f == 1 )\n            {\n                rc = j ; break;\n            }\n        }\n        // pp( tr , br );\n        return ( br - tr + 1 )*(rc  - lc + 1 ) ;\n    }\n    int minimumSum(vector<vector<int>>& grid) {\n        int n = si(grid) , m = si(grid[0]) ;\n\n        int r = 1e9 ;\n\n        rep( i , n )\n        {\n            int a = find(0 , 0 , i+1 , m , grid  );\n            rep( j , m )\n            {\n                int c = find(i+1 , 0 , n , j+1 ,grid ) ;\n                int b = find(i+1 , j+1 , n , m , grid ) ;\n\n                r = min( r , a + b + c ) ;\n            }\n            repk( j , i+1 ,  n )\n            {\n                int b = find( i+1 , 0 , j+1 , m  ,grid );\n                int c = find( j+1 , 0 , n , m , grid ) ;\n\n                r = min( r , a+ b + c ) ;\n            }\n            a = find( i , 0 , n , m , grid );\n            rep( j , m )\n            {\n                int b = find( 0 , 0 , i , j + 1 ,grid );\n                int c = find( 0 , j + 1 , i , m , grid ) ;\n\n                r = min( r  , a + b + c );\n            }\n        }\n        rep( j , m )\n        {\n            int a = find( 0 , 0 , n , j + 1 , grid );\n            rep( i , n )\n            {\n                int b = find( 0 , j+1 , i+1 , m , grid );\n                int c = find( i+1 , j+1 , n , m , grid );\n                r = min( r , a + b + c );\n            }\n            repk( i , j + 1 , m )\n            {\n                int b = find(0 , j+1 , n , i+1 , grid );\n                int c = find( 0 , i + 1 , n , m , grid  ) ;\n\n                r = min( r , a + b  + c );\n            }\n            a = find( 0 , j , n , m , grid );\n            rep( i , n )\n            {\n                int b = find( 0 ,0 , i + 1 , j , grid );\n                int c = find( i+1 , 0 , n , j , grid );\n\n                r = min( r , a + b + c ) ;\n            }\n        }\n        return r ;\n    }\n};",
    "submit_ts": 1719114034.0
}