{
    "username": "07dishwasherbob8",
    "submission": "\ntypedef long long ll;\ntypedef long double ld;\nconst ll MOD = 1e9 + 7;\n\nstruct Tree {\n\ttypedef int T;\n\tstatic constexpr T unit = INT_MAX;\n\tT f(T a, T b) { return a & b; } // (any associative fn)\n\tvector<T> s; int n;\n\tTree(int n = 0, T def = unit) : s(2*n, def), n(n) {}\n\tvoid update(int pos, T val) {\n\t\tfor (s[pos += n] = val; pos /= 2;)\n\t\t\ts[pos] = f(s[pos * 2], s[pos * 2 + 1]);\n\t}\n\tT query(int b, int e) { // query [b, e)\n\t\tT ra = unit, rb = unit;\n\t\tfor (b += n, e += n; b < e; b /= 2, e /= 2) {\n\t\t\tif (b % 2) ra = f(ra, s[b++]);\n\t\t\tif (e % 2) rb = f(s[--e], rb);\n\t\t}\n\t\treturn f(ra, rb);\n\t}\n};\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        int n = nums.size();\n        Tree tree(n);\n        for(int i = 0; i < n; i++) {\n            tree.update(i,nums[i]);\n        }\n        ll res = 0;\n        for(int i = 0; i < n; i++) {\n            if((nums[i] & k) == k) {\n                int l1 = i + 1, r1 = n+1, l2 = i + 1, r2 = n;\n                //l1 and r1 find first index s.t. <= k\n                //l2 and r2 find last index s.t. >= k\n                while(l1 != r1) {\n                    int m = (l1 + r1) / 2;\n                    if(tree.query(i,m) <= k) {\n                        r1 = m;\n                    } else {\n                        l1 = m + 1;\n                    }\n                }\n                while(l2 != r2) {\n                    int m = (l2 + r2 + 1) / 2;\n                    if(tree.query(i,m) >= k) {\n                        l2 = m;\n                    } else {\n                        r2 = m - 1;\n                    }\n                }\n                // cout << \"i : \" << i << \" l1 : \" << l1 << \" l2 : \" << l2 << '\\n';\n                res += l2 - l1 + 1;\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": "1720276896",
    "subm_id": "1311637977"
}