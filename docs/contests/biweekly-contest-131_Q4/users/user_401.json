{
    "username": "hoanghonghieu",
    "submission": "class Segment\n{\npublic:\n    int mMin;\n    int mMax;\n    int mMaxBlock;\n    Segment* mLeftHalf;\n    Segment* mRightHalf;\n    \n    Segment(int min_, int max_) : mMin(min_), mMax(max_), mLeftHalf(nullptr), mRightHalf(nullptr), mMaxBlock(0)\n    {\n        // Do nothing\n    }\n    \n    void insert(int value, int max_block)\n    {\n        if (mMin != mMax)\n        {\n            // Add value to sub-segments\n            int leftMiddle = (mMin + mMax) / 2;\n            if (value <= leftMiddle)\n            {\n                if (mLeftHalf == nullptr) mLeftHalf = new Segment(mMin, leftMiddle);\n                mLeftHalf->insert(value, max_block);\n                mMaxBlock = max(mLeftHalf->mMaxBlock, (mRightHalf == nullptr ? 0 : mRightHalf->mMaxBlock));\n            }\n            else\n            {\n                if (mRightHalf == nullptr) mRightHalf = new Segment(leftMiddle + 1, mMax);\n                mRightHalf->insert(value, max_block);\n                mMaxBlock = max(mRightHalf->mMaxBlock, (mLeftHalf == nullptr ? 0 : mLeftHalf->mMaxBlock));\n            }\n        } else {\n            mMaxBlock = max_block;\n        }\n    }\n    \n    int max_block(int value)\n    {\n        // cout << \"max_block \" << value << \" mMin \" << mMin << \" mMax \" << mMax << \" mMaxBlock \" << mMaxBlock << endl;\n        // Leave segment\n        if (mMin == mMax) {\n            if (mMin < value)\n                return mMaxBlock;\n            else\n                return 0;\n        }\n\n        int leftMiddle = (mMin + mMax) / 2;\n        int ans = 0;\n        if (value <= leftMiddle) {\n            ans = mLeftHalf != nullptr ? mLeftHalf->max_block(value) : 0;\n        }\n        else {\n            ans =  mLeftHalf != nullptr ? mLeftHalf->mMaxBlock : 0;\n            ans = max(ans, mRightHalf != nullptr ? mRightHalf->max_block(value) : 0);\n        }\n        // // Left half\n        // if (value < mMin)\n        //     ans += mLeftHalf != nullptr ? mLeftHalf->count : 0;\n        // else if (value < leftMiddle)\n        //     ans += mLeftHalf != nullptr ? mLeftHalf->greaterCount(value) : 0;\n        // // Right half\n        // if (value <= leftMiddle)\n        //     ans += mRightHalf != nullptr ? mRightHalf->count : 0;\n        // else\n        //     ans += mRightHalf != nullptr ? mRightHalf->greaterCount(value) : 0;\n        return ans;\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector<bool> ans;\n        set<int> obstacles;\n        Segment root(0, 50000);\n        obstacles.insert(0);\n        for (auto query : queries) {\n            if (query[0] == 1) {\n                auto low_it = obstacles.lower_bound(query[1]);\n                int prev_obstacle =  *prev(low_it);\n                // Gaurentee there are one obstacle at position 0\n                // if (low_it != obstacles.begin()) {\n                //     prev_obstacle = *prev(low_it);\n                // }\n                root.insert(prev_obstacle, query[1] - prev_obstacle);\n                if (low_it != obstacles.end()) {\n                    root.insert(query[1], *low_it - query[1]);\n                } else {\n                    root.insert(query[1], 0);\n                }\n                obstacles.insert(query[1]);\n            } else {\n                int x = query[1];\n                int len = query[2];\n                auto low_it = obstacles.lower_bound(query[1]);\n                int new_max = 0;\n                int prev_obstacle =  *prev(low_it);\n                new_max = x - prev_obstacle;\n                // cout << prev_obstacle << \" \" <<  root.max_block(x) << endl;\n                // cout << \"x \" << x << \" root.max_block(x) \" << root.max_block(x) << endl;\n                ans.push_back(max(root.max_block(prev_obstacle - 1), new_max) >= len);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1716652700",
    "subm_id": "1267669736"
}