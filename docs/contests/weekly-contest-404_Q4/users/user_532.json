{
    "username": "coder_amitk0091",
    "submission": "class Solution {\n    \npublic:\n      int dia;\n      int helping(int node, vector<vector<int>>& graph, vector<bool>& vis) {\n        vis[node] = true;\n        int d1 = 0, sd1 = 0;\n\n        for (int neigh : graph[node]) {\n            if (!vis[neigh]) {\n                int depth = helping(neigh, graph, vis);\n                if (depth > d1) {\n                    sd1 = d1;\n                    d1 = depth;\n                } else if (depth > sd1) {\n                    sd1 = depth;\n                }\n            }\n        }\n        dia = max(dia, d1 + sd1);\n        return d1 + 1;\n    }\n\n    \n    int ctd(vector<vector<int>>& edges, int nodes) {\n        vector<vector<int>> g(nodes);\n        for (auto& e : edges) {\n            g[e[0]].push_back(e[1]);\n            g[e[1]].push_back(e[0]);\n        }\n\n        vector<bool> vis(nodes, false);\n        dia = 0;\n        helping(0, g, vis); \n        return dia;\n    }\n\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& t1, vector<vector<int>>& t2) {\n         int d1 = ctd(t1, t1.size() + 1);\n        int d2 = ctd(t2, t2.size() + 1);\n        int od = (d1 + 1) / 2 + (d2 + 1) / 2 + 1;\n        int cmd = max(d1, d2);\n        \n\n        return max(cmd, od);\n\n    }\n};",
    "submit_ts": 1719719039.0
}