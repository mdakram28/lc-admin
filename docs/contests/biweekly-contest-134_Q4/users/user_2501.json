{
    "username": "mightBeSam",
    "submission": "template<class T>\nclass bit_prefix {\n\nprivate :\n    vector<vector<T>> prefix;\n    int MSB, MAX;\npublic: \n    bit_prefix (vector<T>& a) {\n        MAX = *max_element(begin(a), end(a));\n        MSB = 32 - __builtin_clz(MAX);\n        prefix.assign(int(a.size()), vector<int>(MSB));\n\n        for (int i = 0; i < int(a.size()); ++i) {\n            for (int j = 0; j < MSB; ++j) {\n                if (a[i] >> j & 1)\n                    prefix[i][j] += 1;\n                if (i > 0)\n                    prefix[i][j] += prefix[i - 1][j];\n            }\n        }\n    }\n\n    T range_and(int l, int r) {\n        T sum = 0;\n        for (int i = 0; i < MSB; ++i) {\n            int count = prefix[r][i] - (l > 0 ? prefix[l - 1][i] : 0);\n            if (count == (r - l + 1))\n                sum |= 1 << i;\n        }\n\n        return sum;\n    }\n\n    T range_xor(int l, int r) {\n        T sum = 0;\n        for (int i = 0; i < MSB; ++i) {\n            int count = prefix[r][i] - (l > 0 ? prefix[l - 1][i] : 0);\n            if (count & 1)\n                sum |= 1 << i;\n        }\n\n        return sum;\n    }\n\n\n    T range_or(int l, int r) {\n        T sum = 0;\n        for (int i = 0; i < MSB; ++i) {\n            int count = prefix[r][i] - (l > 0 ? prefix[l - 1][i] : 0);\n            if (count > 0)\n                sum |= 1 << i;\n        }\n\n        return sum;\n    }\n};\n\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        const int n = (int) nums.size();\n        bit_prefix p(nums);\n        long long answer = 0;\n        for (int i = 0; i < n; ++i) {\n            int low = i, high = n - 1, start = -1, end = -1;\n            while (low <= high) {\n                int mid = (low + high) / 2;\n                if (p.range_and(i, mid) > k) {\n                    low = mid + 1, start = mid;\n                } else {\n                    high = mid - 1;\n                }\n            }\n            low = i, high = n - 1;\n            while (low <= high) {\n                int mid = (low + high) / 2;\n                if (p.range_and(i, mid) >= k) {\n                    low = mid + 1, end = mid;\n                } else {\n                    high = mid - 1;\n                }\n            }\n            if (start == -1) start = i;\n            if (end == -1) end = n - 1;\n            while (start <= end && p.range_and(i, start) > k)\n                ++start;\n            while (end >= start && p.range_and(i, end) < k)\n                --end;\n            if (start <= end && p.range_and(i, start) == k && p.range_and(i, end) == k)\n                    answer += end - start + 1;\n        }\n        \n        return answer;\n    }\n};",
    "submit_ts": "1720278315",
    "subm_id": "1311703817"
}