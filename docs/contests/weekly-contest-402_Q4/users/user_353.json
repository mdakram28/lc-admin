{
    "username": "aadritoD",
    "submission": "template<typename ValueType, class Updater, bool range_update = false>\nclass SegmentTree {\n\npublic:\n\n    uint32_t N;\n\n    explicit SegmentTree(std::vector<ValueType>&& data) : N(data.size()), _height(get_height(data.size())), _tree(data.size()) {\n        _data = std::vector<ValueType>(std::move(data));\n        if constexpr (!range_update) build_range(N, 2 * N - 1);\n    }\n\n    explicit SegmentTree(const std::vector<ValueType>& data) : N(data.size()), _height(get_height(data.size())), _tree(data.size()) {\n        _data = std::vector<ValueType>(data);\n        if constexpr (!range_update) build_range(N, 2 * N - 1);\n    }\n\n    explicit SegmentTree(uint32_t size) : N(size), _height(get_height(size)), _tree(size) {\n        _data = std::vector<ValueType>(size);\n        if constexpr (!range_update) build_range(N, 2 * N - 1);\n    }\n\n\n    template <typename... Args>\n    void update_range(uint32_t L, uint32_t R, Args&&... args) {\n        Updater updater;\n        if constexpr (is_lazy()) {\n            updater = Updater(std::forward<Args>(args)...);\n        }\n\n        L += N;\n        R += N;\n\n        const uint32_t orig_L = L, orig_R = R;\n\n        if constexpr (is_lazy()) {\n            push_range(L, L + 1);\n            push_range(R, R + 1);\n        }\n\n        while (L <= R) {\n\n            if constexpr (is_lazy()) {\n\n                if (is_left_child(R)) {\n                    apply_lazy(R, updater);\n                    R--;\n                }\n\n                if (is_right_child(L)) {\n                    apply_lazy(L, updater);\n                    L++;\n                }\n\n            }\n            else {\n                if (is_left_child(R)) {\n                    apply(R, std::forward<Args>(args)...);\n                    R--;\n                }\n\n                if (is_right_child(L)) {\n                    apply(L, std::forward<Args>(args)...);\n                    L++;\n                }\n            }\n\n            L = parent(L);\n            R = parent(R);\n        }\n\n        if constexpr (is_lazy()) {\n            build_range(orig_L, orig_L + 1);\n            build_range(orig_R, orig_R + 1);\n        }\n    }\n\n    ValueType query_range(uint32_t L, uint32_t R) {\n\n        L += N;\n        R += N;\n\n        if constexpr (is_lazy()) {\n            push_range(L, L + 1);\n            push_range(R, R + 1);\n        }\n\n        ValueType retval_L{}, retval_R{};\n        bool started_L = false, started_R = false;\n\n        while (L <= R) {\n\n            if (is_left_child(R)) {\n                if (started_R) {\n                    ValueType temp = access(R);\n                    Updater::accumulate(temp, retval_R);\n                    retval_R = temp;\n                }\n                else {\n                    retval_R = access(R);\n                    started_R = true;\n                }\n                R--;\n            }\n\n            if (is_right_child(L)) {\n                if (started_L) {\n                    Updater::accumulate(retval_L, access(L));\n                }\n                else {\n                    retval_L = access(L);\n                    started_L = true;\n                }\n                L++;\n            }\n\n            R = parent(R);\n            L = parent(L);\n        }\n\n        if (!started_L) {\n            return retval_R;\n        }\n\n        if (!started_R) {\n            return retval_L;\n        }\n\n        Updater::accumulate(retval_L, retval_R);\n\n        return retval_L;\n    }\n\n    ValueType query(uint32_t index) {\n        if constexpr (is_lazy()) {\n            return query_range(index, index);\n        }\n        index += N;\n        ValueType retval = access(index);\n        index = parent(index);\n        while (index > 0) {\n            Updater::accumulate(retval, _tree[index].value);\n            index = parent(index);\n        }\n        return retval;\n    }\n\n    template <typename... Args>\n    void update(uint32_t index, Args&&... args) {\n        if constexpr (is_lazy()) {\n            return update_range(index, index, std::forward<Args>(args)...);\n        }\n        Updater::update(_data[index], std::forward<Args>(args)...);\n        index += N;\n        index = parent(index);\n        while (index > 0) {\n            recalc(index);\n            index = parent(index);\n        }\n    }\n\n\nprivate:\n\n\n    void build_range(uint32_t L, uint32_t R) {\n        while (L > 1) {\n            L = parent(L);\n            R = parent(R);\n            for (uint32_t i = R; i >= L; i--) { //reverse ordering to handle overlaps from arbitrary indexing\n                recalc(i);\n            }\n        }\n    }\n\n    void push_range(uint32_t L, uint32_t R) {\n        for (uint32_t layer = _height; layer > 0; layer--) {\n            for (uint32_t i = L >> layer; i <= R >> layer; i++) {\n                if (i >= N) break;\n                apply_lazy(left_child(i), _tree[i].lazy_data);\n                apply_lazy(right_child(i), _tree[i].lazy_data);\n                _tree[i].lazy_data = Updater();\n            }\n        }\n    }\n\n    void push(uint32_t index) {\n        if constexpr (!is_lazy()) return;\n        if (index < N) {\n            apply_lazy(left_child(index), _tree[index].lazy_data);\n            apply_lazy(right_child(index), _tree[index].lazy_data);\n            _tree[index].lazy_data = Updater();\n        }\n    }\n\n    void apply_lazy(uint32_t index, const Updater& updater) {\n        if (index < N) _tree[index].lazy_data.compose(updater);\n        updater.update(access(index));\n    }\n\n    template<typename... Args>\n    inline void apply(uint32_t index, Args&&... args) {\n        Updater::update(access(index), std::forward<Args>(args)...);\n    }\n    \n\n    void recalc(uint32_t index) {\n        if (index < N) {\n            ValueType left = access(left_child(index));\n            Updater::accumulate(left, access(right_child(index)));\n            _tree[index].value = std::move(left);\n            if constexpr (is_lazy()) {\n                _tree[index].lazy_data.update(_tree[index].value);\n            }\n        }\n    }\n\n    inline ValueType& access(uint32_t index) {\n        if (index < N) {\n            return _tree[index].value;\n        }\n        else {\n            return _data[index - N];\n        }\n    }\n\n#ifdef __GNUC__\n    static inline constexpr uint32_t clz(uint32_t x) {\n        return __builtin_clz(x);\n    }\n#elif defined(_MSVC_LANG)\n    static inline constexpr uint32_t clz(uint32_t x) {\n        return __lzcnt(x);\n    }\n#else\n    static inline constexpr uint32_t clz(uint32_t x) {\n        x |= (x >> 1);\n        x |= (x >> 2);\n        x |= (x >> 4);\n        x |= (x >> 8);\n        x |= (x >> 16);\n        return 32 - std::bitset<32>(x).count();\n    }\n#endif\n\n    inline constexpr uint32_t get_height(uint32_t size) {\n        return sizeof(int) * 8 - clz(size);\n    }\n\n    inline constexpr bool is_left_child(uint32_t node) {\n        return node % 2 == 0;\n    }\n\n    inline constexpr bool is_right_child(uint32_t node) {\n        return node % 2 == 1;\n    }\n\n    inline constexpr uint32_t parent(uint32_t node) {\n        return node / 2;\n    }\n\n    inline constexpr uint32_t left_child(uint32_t node) {\n        return node * 2;\n    }\n\n    inline constexpr uint32_t right_child(uint32_t node) {\n        return node * 2 + 1;\n    }\n\n    constexpr static bool is_lazy() {\n        return !std::is_empty_v<Updater>;\n    }\n\n    struct Node {\n\n        Updater lazy_data;\n        ValueType value;\n\n        Node() : lazy_data(), value() {}\n\n    };\n\n    std::vector<Node> _tree;\n    std::vector<ValueType> _data;\n    uint32_t _height;\n\n};\n\nusing ll = long long;\n\nstruct RMQ {\n    \n    static void accumulate(ll& a, ll b) {\n        a += b;\n    }\n    \n    static void update(ll& a, ll n_val) {\n        a = n_val;\n    }\n    \n};\n\nvoid check_and_update_peak(vector<int>& nums, vector<ll>& peaks, SegmentTree<ll, RMQ>& ds, int index) {\n    if (index < 0) return;\n    if (index >= nums.size()) return;\n    if (index != 0 && index != nums.size() - 1 && (nums[index] > nums[index - 1]) && (nums[index] > nums[index + 1] )) {\n        peaks[index] = 1;\n    } else {\n        peaks[index] = 0;\n    }\n    ds.update(index, peaks[index]);\n}\n\nclass Solution {\npublic:\n    \n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        vector<ll> peaks(nums.size(), 0);\n        for (int i = 0; i < nums.size(); i++) {\n            if (i > 0 && i < nums.size() - 1) {\n                if ((nums[i] > nums[i + 1]) && (nums[i] > nums[i - 1])) {\n                    peaks[i] = 1;\n                }\n            }\n        }\n        \n        SegmentTree<ll, RMQ> ds(peaks);\n        \n        vector<int> ans;\n        \n        \n        for (auto& query : queries) {\n            if (query[0] == 1) {\n                ll a = ds.query_range(query[1], query[2]);\n                if (query[1] == query[2]) {\n                    ans.push_back(0);\n                } else {\n                    a -= peaks[query[1]];\n                    a -= peaks[query[2]];\n                    ans.push_back(a);\n                }\n            } else {\n                nums[query[1]] = query[2];\n                check_and_update_peak(nums, peaks, ds, query[1]);\n                check_and_update_peak(nums, peaks, ds, query[1] - 1);\n                check_and_update_peak(nums, peaks, ds, query[1] + 1);\n            }\n        }\n        \n        return ans;\n        \n    }\n};",
    "submit_ts": 1718507593.0
}