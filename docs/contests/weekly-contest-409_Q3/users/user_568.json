{
    "username": "Dipu_1",
    "submission": "#define f first\n#define s second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (long long)(x).size()\n#define pii pair<long long, long long>\n\ntemplate <class T> class SegmentTree {\nprivate:\n    const T DEFAULT = 0;\n    vector<T> segtree;\n    long long len;\n\npublic:\n    T f(T a, T b) {\n        return a + b;\n    }\n\n    SegmentTree(long long sze) {\n        for (long long i = 0; i < 30; i++) {\n            if (sze <= (1 << i)) {\n                sze = (1 << i);\n                break;\n            }\n        }\n        len = sze;\n        segtree.assign(2 * len, DEFAULT);\n    }\n\n    void set(long long l, long long r, T val, long long x, long long L, long long R) {\n        if (L >= r || R <= l)\n            return;\n        if (L >= l && R <= r) {\n            segtree[x] = f(segtree[x], val);\n            return;\n        }\n        long long mid = (L + R) / 2;\n        set(l, r, val, x * 2 + 1, L, mid);\n        set(l, r, val, x * 2 + 2, mid, R);\n    }\n\n    void set(long long l, long long r, T val) {\n        set(l, r, val, 0, 0, len);\n    }\n\n    T get(long long idx, long long x, long long L, long long R) {\n        if (R - L == 1) {\n            return segtree[x];\n        }\n        long long mid = (L + R) / 2;\n        T ret = DEFAULT;\n        if (idx < mid) {\n            ret = get(idx, x * 2 + 1, L, mid);\n        }\n        else {\n            ret = get(idx, x * 2 + 2, mid, R);\n        }\n        return f(ret, segtree[x]);\n    }\n\n    T get(long long idx) {\n        return get(idx, 0, 0, len);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>> queries) {\n        SegmentTree<int> seg(n);\n        for (int i = 0; i < n; i++) {\n            seg.set(i, i + 1, n - 1 - i);\n        }\n        set<pii> seen;\n        seen.insert({INT_MAX, INT_MAX});\n        vector<int> ans;\n        for (auto q : queries) {\n            int from = q[0];\n            int to = q[1];\n            pii prr = {from, -INT_MAX};\n            auto idx = seen.lower_bound({from, to});\n            if (idx != seen.begin() && idx != seen.end()) {\n                auto prev = std::prev(idx);\n                if (prev->first <= from && prev->second >= to) {\n                    ans.pb(seg.get(0));\n                    continue;\n                }\n                else if (idx != seen.end() && idx->first <= from && idx->second >= to) {\n                    ans.pb(seg.get(0));\n                    continue;\n                }\n            }\n            else if (idx != seen.end() && idx->first <= from && idx->second >= to) {\n                ans.pb(seg.get(0));\n                continue;\n            }\n            if (seg.get(to) + 1 < seg.get(from)) {\n                int diff = seg.get(from) - 1 - seg.get(to);\n                seg.set(0, from + 1, -diff);\n            }\n            ans.pb(seg.get(0));\n            seen.insert({from, to});\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722741716",
    "subm_id": "1343751759"
}