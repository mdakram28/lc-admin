{
    "username": "truongphamminh17",
    "submission": "/**\n * @param {number} n\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar shortestDistanceAfterQueries = function (n, queries) {\n  class SegmentTree {\n    constructor(size) {\n      this.n = size;\n      this.tree = new Array(4 * size).fill(0);\n      this.lazy = new Array(4 * size).fill(null);\n    }\n\n    build(arr, start, end, node) {\n      if (start === end) {\n        this.tree[node] = arr[start];\n        return;\n      }\n      const mid = Math.floor((start + end) / 2);\n      this.build(arr, start, mid, 2 * node + 1);\n      this.build(arr, mid + 1, end, 2 * node + 2);\n      this.tree[node] = this.tree[2 * node + 1] + this.tree[2 * node + 2];\n    }\n\n    updateRange(l, r, val, start = 0, end = this.n - 1, node = 0) {\n      this.propagate(start, end, node);\n\n      if (start > end || start > r || end < l) {\n        return;\n      }\n\n      if (start >= l && end <= r) {\n        this.tree[node] = (end - start + 1) * val;\n        if (start !== end) {\n          this.lazy[2 * node + 1] = val;\n          this.lazy[2 * node + 2] = val;\n        }\n        return;\n      }\n\n      const mid = Math.floor((start + end) / 2);\n      this.updateRange(l, r, val, start, mid, 2 * node + 1);\n      this.updateRange(l, r, val, mid + 1, end, 2 * node + 2);\n      this.tree[node] = this.tree[2 * node + 1] + this.tree[2 * node + 2];\n    }\n\n    queryRange(l, r, start = 0, end = this.n - 1, node = 0) {\n      this.propagate(start, end, node);\n\n      if (start > end || start > r || end < l) {\n        return 0;\n      }\n\n      if (start >= l && end <= r) {\n        return this.tree[node];\n      }\n\n      const mid = Math.floor((start + end) / 2);\n      const leftQuery = this.queryRange(l, r, start, mid, 2 * node + 1);\n      const rightQuery = this.queryRange(l, r, mid + 1, end, 2 * node + 2);\n      return leftQuery + rightQuery;\n    }\n\n    propagate(start, end, node) {\n      if (this.lazy[node] !== null) {\n        this.tree[node] = (end - start + 1) * this.lazy[node];\n        if (start !== end) {\n          this.lazy[2 * node + 1] = this.lazy[node];\n          this.lazy[2 * node + 2] = this.lazy[node];\n        }\n        this.lazy[node] = null;\n      }\n    }\n  }\n\n  const tree = new SegmentTree(n)\n  const result = []\n  for (const [start, end] of queries) {\n    tree.updateRange(start + 1, end - 1, 1)\n    result.push(n - 1 - tree.queryRange(0, n - 1))\n  }\n  return result\n\n};",
    "submit_ts": "1722743107",
    "subm_id": "1343784494"
}