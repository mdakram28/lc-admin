{
    "username": "tmoux",
    "submission": "struct DSU {\n  int n;\n  vector<int> par;\n  DSU(int _n) {\n    n = _n;\n    par.resize(n+1, -1);\n  }\n\n  int Find(int i) {\n    return par[i] < 0 ? i : par[i] = Find(par[i]);\n  }\n\n  bool Union(int x, int y) { //return true if x and y were not connected\n    x = Find(x);\n    y = Find(y);\n    if (x == y) return false;\n    if (par[x] > par[y]) swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n    return true;\n  }\n};\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int N = circles.size();\n        using ll = long long;\n        DSU dsu(N + 2); // N = top-left, N+1 = bot-right\n        for (int i = 0; i < N; i++) {\n            for (int j = i+1; j < N; j++) {\n                int d = circles[i][2] + circles[j][2];\n                int dx = abs(circles[i][0] - circles[j][0]);\n                int dy = abs(circles[i][1] - circles[j][1]);\n                if (1LL * dx * dx + 1LL * dy * dy <= 1LL * d * d) {\n                    dsu.Union(i, j);\n                }\n            }\n        }\n        for (int i = 0; i < N; i++) {\n            int r = circles[i][2];\n            int x = circles[i][0];\n            int y = circles[i][1];\n            if (x <= r || Y-y <= r) {\n                dsu.Union(i, N);\n            }\n        }\n        for (int i = 0; i < N; i++) {\n            int r = circles[i][2];\n            int x = circles[i][0];\n            int y = circles[i][1];\n            if (X-x <= r || y <= r) {\n                dsu.Union(i, N+1);\n            }\n        }\n\n        return dsu.Find(N) != dsu.Find(N+1);\n    }\n};",
    "submit_ts": "1722135132",
    "subm_id": "1335690904"
}