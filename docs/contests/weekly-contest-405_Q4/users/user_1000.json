{
    "username": "Wibo",
    "submission": "\nconst int maxn = 5e4+3, nh = 2;\nconst long long base[] = {37, 39}, mod[] = {1000000007, 1000000009};\nlong long pw[maxn][nh], ipw[maxn][nh];\n\nlong long modpow(long long a, long long b, long long m) {\n    long long ret = 1;\n    for (; b; b>>=1) {\n        if (b&1) ret = ret * a % m;\n        a = a * a % m;\n    }\n    return ret;\n}\n\nvoid init() {\n    for (int i=0; i<nh; i++) pw[0][i] = 1;\n    for (int i=1; i<maxn; i++) {\n        for (int j=0; j<nh; j++) {\n            pw[i][j] = pw[i-1][j] * base[j] % mod[j];\n        }\n    }\n    for (int i=0; i<nh; i++) ipw[maxn-1][i] = modpow(pw[maxn-1][i], mod[i]-2, mod[i]);\n    for (int i=maxn-1; i>0; i--) {\n        for (int j=0; j<nh; j++) {\n            ipw[i-1][j] = ipw[i][j] * base[j] % mod[j];\n        }\n    }\n    assert(pw[5][0] * ipw[5][0] % mod[0] == 1);\n}\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        init();\n        int n = target.size(), m = words.size();\n\n        vector<int> lengths(m);\n        for (int i=0; i<m; i++) lengths[i] = words[i].size();\n        sort(lengths.begin(), lengths.end());\n        lengths.resize(unique(lengths.begin(), lengths.end()) - lengths.begin());\n\n        vector<array<long long, nh>> ph(n+1, {0});\n        for (int i=1; i<=n; i++) {\n            for (int j=0; j<nh; j++) {\n                ph[i][j] = (ph[i-1][j] + (target[i-1] - 'a' + 1) * pw[i][j]) % mod[j];\n            }\n        }\n\n        vector<pair<array<long long, nh>, int>> htc2;\n        for (int i=0; i<m; i++) {\n            array<long long, nh> ch = {0};\n            for (int j=1; j<=(int)words[i].size(); j++) {\n                for (int k=0; k<nh; k++) {\n                    ch[k] = (ch[k] + (words[i][j-1] - 'a' + 1) * pw[j][k]) % mod[k];\n                }\n            }\n            htc2.emplace_back(ch, costs[i]);\n        }\n\n        sort(htc2.begin(), htc2.end());\n        vector<pair<array<long long, nh>, int>> htc;\n        for (int l=0; l<m; ) {\n            int r = l;\n            while (r < m && htc2[l].first == htc2[r].first) r++;\n            htc.push_back(htc2[l]);\n            l = r;\n        }\n        \n        const int inf = 1e9+3;\n        auto cost = [&](array<long long, nh> &h) -> int {\n            auto it = lower_bound(htc.begin(), htc.end(), make_pair(h, -1));\n            return ((it != htc.end() && it->first == h) ? it->second : inf);\n        };\n\n        auto cut = [&](int l, int r) -> array<long long, nh> {\n            array<long long, nh> ret;\n            for (int i=0; i<nh; i++) {\n                ret[i] = (ph[r][i] - ph[l-1][i] + mod[i]) * ipw[l-1][i] % mod[i];\n            }\n            return ret;\n        };\n\n        vector<int> dp(n+1, inf);\n        dp[0] = 0;\n        // for (int i=1; i<=n; i++) {\n        //     for (int len : lengths) {\n        //         if (i - len < 0 || dp[i - len] == inf || dp[i - len] >= dp[i]) continue;\n        //         auto cur = cut(i - len + 1, i);\n        //         dp[i] = min(dp[i], dp[i - len] + cost(cur));\n        //     }\n        // }\n        for (int i=0; i<n; i++) {\n            for (int len : lengths) {\n                if (i + len > n || dp[i] == inf || dp[i + len] <= dp[i]) continue;\n                auto cur = cut(i + 1, i + len);\n                dp[i + len] = min(dp[i + len], dp[i] + cost(cur));\n            }\n        }\n\n        return (dp[n] == inf ? -1 : dp[n]);\n    }\n};",
    "submit_ts": "1720322041",
    "subm_id": "1312339099"
}