{
    "username": "hughstudy-n",
    "submission": "class Solution {\n    class DSU{\n        int[] parent;\n        int[] countTotal, countOri;\n\n        public DSU(int n, int[][] grid) {\n            parent = new int[n];\n            countTotal = new int[n];\n            countOri = new int[n];\n            for (int i = 0; i < n; ++i) {\n                parent[i] = i;\n                countTotal[i] = 1;\n                countOri[i] = grid[i / grid[0].length][i % grid[0].length];\n            }\n        }\n\n        public int find(int x) {\n            if (parent[x] != x) parent[x] = find(parent[x]);\n            return parent[x];\n        }\n\n        public void union(int x, int y) {\n            int fx = find(x), fy = find(y);\n            if (fx != fy) {\n                parent[fx] = fy;\n                countTotal[fy] += countTotal[fx];\n                countOri[fy] += countOri[fx];\n            }\n        }\n    }\n\n\n    public int minFlips(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        DSU uf = new DSU(m * n, grid);\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                uf.union(i * n + j, (m - 1 - i) * n + j);\n                uf.union(i * n + j, i * n + (n - 1 - j));\n            }\n        }\n\n        int[] mem = new int[4];\n        Arrays.fill(mem, Integer.MAX_VALUE);\n        mem[0] = 0;\n\n        boolean[] isUsed = new boolean[m * n];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int f = uf.find(i * n + j);\n                if (!isUsed[f]) {\n                    int turnZero = uf.countOri[f], turnOne = uf.countTotal[f] - uf.countOri[f];\n                    int[] nextMem = new int[4];\n                    Arrays.fill(nextMem, Integer.MAX_VALUE);\n                    isUsed[f] = true;\n                    for (int k = 0; k < 4; ++k) {\n                        if (mem[k] != Integer.MAX_VALUE) {\n                            nextMem[k] = Math.min(nextMem[k], mem[k] + turnZero);\n                            nextMem[(k + uf.countTotal[f]) % 4] = Math.min(nextMem[(k + uf.countTotal[f]) % 4], mem[k] + turnOne);\n                        }\n                    }\n                    mem = nextMem;\n                }\n            }\n        }\n        return mem[0];\n    }\n}",
    "submit_ts": "1722698801",
    "subm_id": "552272583"
}