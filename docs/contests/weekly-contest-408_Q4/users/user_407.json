{
    "username": "suganth_a",
    "submission": "import java.util.*;\n\nclass Solution {\n    public int characterReplacement(String s, int k) {\n        int l = 0, r = 0, maxfreq = 0, maxlen = 0;\n        int change = 0;\n        int[] hash = new int[26];\n        \n        while (r < s.length()) {\n            hash[s.charAt(r) - 'A']++;\n            maxfreq = Math.max(hash[s.charAt(r) - 'A'], maxfreq);\n            change = (r - l + 1) - maxfreq;\n            \n            while (change > k) {\n                hash[s.charAt(l) - 'A']--;\n                maxfreq = 0;\n                for (int i = 0; i < 26; i++) {\n                    maxfreq = Math.max(maxfreq, hash[i]);\n                }\n                change--;\n                l++;\n            }\n            \n            if (change <= k) {\n                maxlen = Math.max(r - l + 1, maxlen);\n            }\n            r++;\n        }\n        \n        return maxlen;\n    }\n    \n    public boolean canReachCorner(int X, int Y, int[][] circles2) {\n        int nc = circles2.length;\n        List<int[]> circles = new ArrayList<>();\n        for (int[] circle : circles2) {\n            circles.add(circle);\n        }\n\n        List<List<Integer>> graph = new ArrayList<>(nc + 4);\n        for (int i = 0; i < nc + 4; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < nc; i++) {\n            int cx = circles.get(i)[0];\n            int cy = circles.get(i)[1];\n            int r = circles.get(i)[2];\n\n            if (cx <= r) {\n                graph.get(nc).add(i);\n                graph.get(i).add(nc);\n            }\n            if (X - cx <= r) {\n                graph.get(nc + 2).add(i);\n                graph.get(i).add(nc + 2);\n            }\n            if (cy <= r) {\n                graph.get(nc + 1).add(i);\n                graph.get(i).add(nc + 1);\n            }\n            if (Y - cy <= r) {\n                graph.get(nc + 3).add(i);\n                graph.get(i).add(nc + 3);\n            }\n            for (int j = i + 1; j < nc; j++) {\n                int cx2 = circles.get(j)[0];\n                int cy2 = circles.get(j)[1];\n                int r2 = circles.get(j)[2];\n\n                double d = Math.sqrt(Math.pow(cx - cx2, 2) + Math.pow(cy - cy2, 2));\n                int radiusSum = r + r2;\n                if (radiusSum >= d) {\n                    graph.get(i).add(j);\n                    graph.get(j).add(i);\n                }\n            }\n        }\n\n        int isb = 0;\n        isb = Math.max(isb, bfs(graph, nc, nc + 1, nc + 2, nc + 4));\n        isb = Math.max(isb, bfs(graph, nc + 3, nc + 2, nc + 1, nc + 4));\n\n        return isb == 0;\n    }\n\n    private int bfs(List<List<Integer>> graph, int start, int t1, int t2, int nodes) {\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] vis = new boolean[nodes + 4];\n        queue.add(start);\n        vis[start] = true;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (int v : graph.get(u)) {\n                if (!vis[v]) {\n                    queue.add(v);\n                    vis[v] = true;\n                }\n            }\n        }\n        return vis[t1] || vis[t2] ? 1 : 0;\n    }\n}\n",
    "submit_ts": "1722137027",
    "subm_id": "1335751995"
}