{
    "username": "XKTZ",
    "submission": "typedef long long ll;\n\nconstexpr ll MAXN = 1e5 + 5;\n\nll N, M;\n\nvector<ll> adj1[MAXN], adj2[MAXN];\n\nll dis[MAXN];\n\ntemplate<typename T>\nvoid bfs(ll n, ll x, T &&adj) {\n    for (ll i = 0; i < n; i ++) {\n        dis[i] = 0x3f3f3f3f;\n    }\n    queue<ll> q;\n    q.push(x);\n    dis[x] = 0;\n    while (!q.empty()) {\n        auto u = q.front();\n        q.pop();\n        for (auto v: adj[u])  {\n            if (dis[v] == 0x3f3f3f3f) {\n                dis[v] = dis[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n}\n\ntemplate<typename T>\nll finddia(ll n, T &&adj) {\n    bfs(n, 0, adj);\n    ll mx = max_element(dis, dis + n) - dis;\n    bfs(n, mx, adj);\n    return *max_element(dis, dis + n);\n}\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        ll n = edges1.size() + 1, m = edges2.size() + 1;\n        for (ll i = 0; i < n; i ++) {\n            adj1[i].clear();\n        }\n        for (ll i = 0; i < m ; i ++) {\n            adj2[i].clear();\n        }\n        for (auto &v: edges1) {\n            adj1[v[0]].push_back(v[1]);\n            adj1[v[1]].push_back(v[0]);\n        }\n        for (auto &v: edges2) {\n            adj2[v[0]].push_back(v[1]);\n            adj2[v[1]].push_back(v[0]);\n        }\n        ll d1 = finddia(n, adj1);\n        ll d2 = finddia(m, adj2);\n        return max({d1, d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1});\n    }\n};",
    "submit_ts": "1719717370",
    "subm_id": "1304389769"
}