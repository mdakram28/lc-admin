{
    "username": "abhik2003",
    "submission": "\nclass Solution\n{\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>> &edges1, vector<vector<int>> &edges2)\n    {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        vector<vector<int>> tree1(n), tree2(m);\n\n        for (auto e: edges1){\n            tree1[e[0]].push_back(e[1]);\n            tree1[e[1]].push_back(e[0]);\n        }\n        for (auto e: edges2){\n            tree2[e[0]].push_back(e[1]);\n            tree2[e[1]].push_back(e[0]);\n        }\n\n        int d1 = dia(tree1, n);\n        int d2 = dia(tree2, m);\n        // cout<<d1<<\" \"<<d2;\n\n        return max({(1 + (d1 + 1) / 2 + (d2 + 1) / 2),d1,d2});\n    }\n    int maxNode(int n, int node,vector<vector<int>>& tree) \n    {\n        vector<bool> vis(n);\n        queue<int> q;\n        q.push(node);\n        vis[node] = 1;\n        int ans = 0;\n        while (!q.empty())\n        {\n            int c = q.front();\n            q.pop();\n            ans = c;\n\n            for(int v:tree[c]){\n                if(!vis[v])\n                    q.push(v);\n                vis[v] = 1;\n            }\n        }\n\n        return ans;\n    }\n\n    int maxDist(int n, int node, vector<vector<int>> &tree){\n        vector<bool> vis(n);\n        queue<pair<int,int>> q;\n        q.push({node,0});\n        vis[node] = 1;\n        int ans = 0;\n        while (!q.empty())\n        {\n            int c = q.front().first;\n            int d = q.front().second;\n            q.pop();\n            ans = d;\n\n            for (int v : tree[c])\n            {\n                if (!vis[v])\n                    q.push({v,d+1});\n                vis[v] = 1;\n            }\n        }\n        return ans;\n\n    }\n\n    int dia(vector<vector<int>> &tree, int n){\n        int x = maxNode(n, 0, tree);\n        return maxDist(n, x, tree);\n    }\n};",
    "submit_ts": 1719719624.0
}