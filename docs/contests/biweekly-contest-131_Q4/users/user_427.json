{
    "username": "sepehry",
    "submission": "\nimport math\n\n\nclass SegmentTree:\n    def __init__(self, combine_op, default_val, arr=None, n: int = None):\n        \"\"\"\n        :param combine_op: an associative, commutative operation (e.g., operator.add, operator.xor, min, max)\n        :param default_val: value for heap indices with no corresponding index in arr due to heap length being 2^k\n        :param arr: array of data, it will trigger _initialize_heap()\n        :param n: length of the original arr if it is not provided\n        \"\"\"\n        if n is None:\n            assert (arr is not None)\n            n = len(arr)\n        else:\n            assert (arr is None)\n        self.heap = [default_val] * self._calculate_heap_size(n)\n        self._combine = combine_op\n        if arr is not None:\n            self._initialize_heap(arr)\n\n    def __getitem__(self, i):\n        return self.heap[self._heap_index(i)]\n\n    def __setitem__(self, i: int, x):\n        self.update(i, x)\n\n    def _initialize_heap(self, arr):\n        node0 = self._heap_index(0)\n        self.heap[node0:node0 + len(arr)] = arr\n        while node0:\n            node0 = self._parent(node0)\n            for node in range(node0, self._left(node0)):\n                self.heap[node] = self._combine_children(node)\n\n    def update(self, i: int, x):\n        \"\"\"arr[i] = x\"\"\"\n        node = self._heap_index(i)\n        self.heap[node] = x\n        while node:\n            node = self._parent(node)\n            self.heap[node] = self._combine_children(node)\n\n    def query(self, i: int, j: int):\n        \"\"\"Returns combine_op(arr[i:j+1]) (arr[j] INCLUDED!)\"\"\"\n        node1, node2 = self._heap_index(i), self._heap_index(j)\n        if node1 == node2:\n            return self.heap[node1]\n        result1 = self.heap[node1]\n        result2 = self.heap[node2]\n        while (parent1 := self._parent(node1)) != (parent2 := self._parent(node2)):\n            if self._is_left(node1):\n                result1 = self._combine(result1, self.heap[self._sibling(node1)])\n            if self._is_right(node2):\n                result2 = self._combine(result2, self.heap[self._sibling(node2)])\n            node1 = parent1\n            node2 = parent2\n        return self._combine(result1, result2)\n\n    def query_all(self):\n        return self.heap[0]\n\n    def _combine_children(self, parent):\n        return self._combine(self.heap[self._left(parent)], self.heap[self._right(parent)])\n\n    def _parent(self, node: int) -> int:\n        return (node - 1) >> 1\n\n    def _left(self, node: int) -> int:\n        return 1 + (node << 1)\n\n    def _right(self, node: int) -> int:\n        return 2 + (node << 1)\n\n    def _sibling(self, node: int) -> int:\n        return node + ((node & 1) << 1) - 1\n\n    def _is_left(self, node: int) -> bool:\n        return (node & 1) == 1\n\n    def _is_right(self, node: int) -> bool:\n        return (node & 1) == 0\n\n    def _heap_index(self, node: int) -> int:\n        return self._parent(len(self.heap)) + node\n\n    def _calculate_heap_size(self, arr_size: int):\n        return (1 << (1 + int(math.ceil(math.log2(arr_size))))) - 1\n\n\nimport sortedcontainers\n\n\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        MAX = max(qqq[1] for qqq in queries)\n        st = SegmentTree(max, 0, n=MAX+1)\n        st.update(MAX, MAX)\n        q = sortedcontainers.SortedList()\n\n        def update(x):\n            i = q.bisect_left(x)\n            sz = 0\n            if i > 0:\n                sz = max(sz, x - q[i - 1])\n            else:\n                sz = x\n\n            if i < len(q):\n                y = q[i]\n                sz2 = y - x\n                st.update(y, sz2)\n            q.add(x)\n            st.update(x, sz)\n\n        def answer(x, sz0):\n            i = q.bisect_left(x)\n            sz = 0\n            if i > 0:\n                y = q[i - 1]\n                sz = max(sz, x - y)\n                sz = max(sz, st.query(0, y))\n            else:\n                sz = x\n\n            return sz0 <= sz\n\n        sol = []\n        for qq in queries:\n            if qq[0] == 1:\n                update(qq[1])\n            else:\n                sol.append(answer(qq[1], qq[2]))\n        return sol\n",
    "submit_ts": 1716652517.0
}