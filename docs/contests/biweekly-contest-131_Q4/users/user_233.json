{
    "username": "sunil1906",
    "submission": "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\n\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\n#define ordered_multiset tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update>\n\nclass seg_tree{\npublic:\n    int n, padding = -1;                                         // Initialize Padding Here \n    vector<int> tree;\n    int nearest_power_of_2(int n){\n        return (1 << (int)ceil(log2(n)));\n    }\n    void build(int len){\n        n = nearest_power_of_2(len);\n        tree.resize(2 * n);\n    }\n    void update(int idx, int val){\n        tree[n + idx] = val;\n        for(int parent=(n + idx) / 2; parent >= 1; parent /= 2) \n            tree[parent] = max(tree[2*parent], tree[2*parent+1]);   // Change operation here\n    }\n    int getRange(int &left, int &right, int start, int end, int node){\n        if(right < start or left > end) return -1e9;               // Return 0 for sum, inf for range_min, -inf for range_max\n        if(left <= start and end <= right)  return tree[node];\n        int mid = (start + end) / 2;\n        return max(getRange(left, right, start, mid, 2 * node),    // Change operation here\n               getRange(left, right, mid + 1, end, 2 * node + 1));\n    }\n    int range(int left, int right){\n        return getRange(left, right, 0, n - 1, 1);\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        ordered_multiset s;\n        int i, qn = queries.size(), n = min(50000, 3 * qn) + 100, x, sz, mx;\n        vector<bool> ans;\n        \n        s.insert({n - 1, n - 1});\n        seg_tree seg;\n        seg.build(n);\n        seg.update(n - 1, n - 1);\n        \n        for(i=0;i<qn;i++){\n            if(queries[i][0] == 1){\n                // add block\n                x = queries[i][1];\n                int idx = s.order_of_key({x, -1});\n                \n                if(idx == 0){\n                    pair<int, int> p = *(s.find_by_order(idx));\n                    s.erase(s.find(p));\n                    p.second = p.first - x;\n                    s.insert(p);\n                    seg.update(p.first, p.second);                    \n                    \n                    s.insert({x, x});\n                    seg.update(x, x);\n                }\n                else{\n                    pair<int, int> p1 = *(s.find_by_order(idx - 1));\n                    pair<int, int> p2 = *(s.find_by_order(idx));\n                    s.erase(s.find(p2));\n                    p2.second = p2.first - x;\n                    s.insert(p2);\n                    seg.update(p2.first, p2.second);\n                    \n                    pair<int, int> p3;\n                    p3.first = x;\n                    p3.second = x - p1.first;\n                    s.insert(p3);\n                    seg.update(p3.first, p3.second);\n                }\n            }\n            else{\n                // process\n                x = queries[i][1];\n                sz = queries[i][2];\n                int idx = s.order_of_key({x, -1});\n                if(idx == 0){\n                    mx = x;\n                }\n                else{\n                    pair<int, int> p = *(s.find_by_order(idx - 1));\n                    mx = seg.range(0, p.first);\n                    mx = max(mx, x - p.first);\n                }\n                ans.push_back(mx >= sz);\n            }\n            \n            // for(auto it : s){\n            //     cout<<it.first<<\",\"<<it.second<<\"   \"; \n            // }\n            // cout<<\"\\n\";\n            \n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716651285.0
}