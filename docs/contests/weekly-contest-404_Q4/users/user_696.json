{
    "username": "nimeshnadar",
    "submission": "class Solution {\npublic:\n    void bfs(int s, vector<int>& d, const vector<vector<int>>& adj) {\n        int n;\n        queue<int> qu;\n        qu.push(s);\n        d[s]=0;\n        while(!qu.empty()){\n            n = qu.front();\n            qu.pop();\n            for(auto ng : adj[n]){\n                if(d[ng] == -1){\n                    d[ng] = d[n]+1;\n                    qu.push(ng);\n                }\n            }\n        }\n    }\n    pair<int, int> gm(vector<vector<int>>& edges){\n        int n, u, v, a, b, minm=INT_MAX, maxm=0;\n        n = edges.size()+1;\n        vector<vector<int>> adj(n+1);\n        vector<int> da(n, -1), db(n, -1), dc(n, -1);\n        for(int i=0; i<n-1; i++){\n            u = edges[i][0];\n            v = edges[i][1];\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        bfs(0, da, adj);\n        a = max_element(da.begin(), da.end())-da.begin();\n        bfs(a, db, adj);\n        b = max_element(db.begin(), db.end())-db.begin();\n        bfs(b, dc, adj);\n        for (int i = 0; i < n; ++i) {\n            minm = min(minm, max(db[i], dc[i]));\n            maxm = max(maxm, max(db[i], dc[i]));\n        }\n        return make_pair(minm, maxm);\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {   \n        pair<int, int> p, q;\n        p = gm(edges1);\n        q = gm(edges2);\n        return max((1+p.first+q.first), max(p.second, q.second));\n    }\n};",
    "submit_ts": 1719719884.0
}