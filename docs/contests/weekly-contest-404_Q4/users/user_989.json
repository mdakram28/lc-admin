{
    "username": "rayms",
    "submission": "class Solution {\n    public static int minimumDiameterAfterMerge(int[][] e1, int[][] e2) {\n        int[] r1 = treeDiameter(e1), r2 = treeDiameter(e2);\n        int d1 = r1[0], h1 = r1[1], d2 = r2[0], h2 = r2[1];\n        return Math.max(d1, Math.max(d2, h1 + h2 + 1));\n    }\n\n    private static int[] treeDiameter(int[][] edges) {\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int[] edge : edges) {\n            graph.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(edge[1]);\n            graph.computeIfAbsent(edge[1], k -> new ArrayList<>()).add(edge[0]);\n        }\n\n        int[] farthest = bfs(0, graph);\n        int[] result = bfs(farthest[0], graph);\n        int diameter = result[1];\n        int height = (diameter + 1) / 2;\n        return new int[]{diameter, height};\n    }\n\n    private static int[] bfs(int start, Map<Integer, List<Integer>> graph) {\n        Queue<Integer> queue = new ArrayDeque<>() {{ add(start); }};\n        Set<Integer> visited = new HashSet<>() {{ add(start); }};\n        int lastNode = start, distance = -1;\n        while (!queue.isEmpty()) {\n            distance++;\n            for (int i = 0, size = queue.size(); i < size; i++) {\n                int node = queue.poll();\n                lastNode = node;\n                for (int neighbor : graph.getOrDefault(node, new ArrayList<>())) {\n                    if (visited.add(neighbor)) {\n                        queue.add(neighbor);\n                    }\n                }\n            }\n        }\n\n        return new int[]{lastNode, distance};\n    }\n\n}",
    "submit_ts": "1719717455",
    "subm_id": "1304391976"
}