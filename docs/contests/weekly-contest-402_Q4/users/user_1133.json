{
    "username": "guzh870423",
    "submission": "class Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        int n = nums.length;\n        Node root = Node.build(nums, 0, n - 1);\n        List<Integer> res = new ArrayList<>();\n        for (int[] q : queries) {\n            if (q[0] == 1) {\n                res.add(root.query(q[1] + 1, q[2] - 1));\n            } else {\n                boolean p0 = isPeak(nums, q[1] - 1),p1 = isPeak(nums, q[1]),p2 = isPeak(nums, q[1] + 1);\n                nums[q[1]] = q[2];\n                boolean p0p = isPeak(nums, q[1] - 1),p1p = isPeak(nums, q[1]),p2p = isPeak(nums, q[1] + 1);\n                if (p0 && !p0p) {\n                    root.update(q[1] - 1, -1);\n                } else if (!p0 && p0p) {\n                    root.update(q[1] - 1, 1);\n                }\n                \n                if (p1 && !p1p) {\n                    root.update(q[1], -1);\n                } else if (!p1 && p1p) {\n                    root.update(q[1], 1);\n                }\n                \n                if (p2 && !p2p) {\n                    root.update(q[1] + 1, -1);\n                } else if (!p2 && p2p) {\n                    root.update(q[1] + 1, 1);\n                }\n            }\n        }\n        return res;\n    }\n    \n    static boolean isPeak(int[] nums, int l) {\n        int n = nums.length;\n        return l > 0 && l < n - 1 && nums[l] > nums[l - 1] && nums[l] > nums[l + 1];\n    }\n    \n    static class Node {\n        int l, r, s;\n        Node left, right;\n        \n        Node(int l, int r) {\n            this.l = l;\n            this.r = r;\n        }\n        \n        static Node build(int[] nums, int l, int r) {\n            int n = nums.length;\n            Node node = new Node(l, r);\n            \n            if (l == r) {\n              if (l > 0 && l < n - 1 && nums[l] > nums[l - 1] && nums[l] > nums[l + 1]) {\n                  node.s = 1;\n              }\n              return node;\n            }\n            int m = l + (r - l) / 2;\n            node.left = build(nums, l, m);\n            node.right = build(nums, m + 1, r);\n            node.s = node.left.s + node.right.s;\n            return node;\n        }\n        \n        void update(int i, int v) {\n            if (i < l || i > r) {\n                return;\n            }\n            \n            s += v;\n            if (left != null) left.update(i, v);\n            if (right != null) right.update(i, v);\n        }\n        \n        int query(int ql, int qr) {\n            if (ql > qr || qr < l || ql > r) {\n                return 0;\n            }\n            \n            if (ql <= l && qr >= r) {\n                return s;\n            }\n            int m = l + (r - l) / 2;\n            return left.query(ql, Math.min(m, qr)) + right.query(Math.max(m, ql), qr);\n        }\n    }\n}",
    "submit_ts": 1718509020.0
}