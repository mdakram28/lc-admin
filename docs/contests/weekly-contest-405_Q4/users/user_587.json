{
    "username": "NDR0216",
    "submission": "void COUT(auto x) { // COUT: cout wrapper\n    cout << x;\n}\ntemplate <typename T1, typename T2> void COUT(pair<T1, T2> p) {\n    cout << '{';\n    COUT(p.first);\n    cout << \", \";\n    COUT(p.second);\n    cout << '}';\n}\ntemplate <typename T> void COUT(vector<T> v) {\n    cout << '[';\n    for (int i = 0; i < v.size(); i++) {\n        if (i != 0) {\n            cout << \", \";\n        }\n        COUT(v[i]);\n    }\n    cout << ']';\n}\nvoid PRINT(auto x) {\n    COUT(x);\n    cout << endl;\n}\nvoid PRINT(auto x, auto... args) { // python-like print\n    COUT(x);\n    cout << \", \";\n    PRINT(args...);\n}\nvoid PRINT_ARR(auto* arr, size_t n) { // python-like print for array\n    cout << '[';\n    for (int i = 0; i < n; i++) {\n        if (i != 0) {\n            cout << \", \";\n        }\n        COUT(arr[i]);\n    }\n    cout << ']' << endl;\n}\n\nstruct TrieNode {\n    unordered_map<char, TrieNode*> children;\n    bool isWord = false;\n    int cost = INT_MAX;\n};\n\nclass Trie {\nprivate:\npublic:\n    TrieNode* root;\n    Trie() { root = new TrieNode(); }\n\n    void insert(string word, int cost) {\n        TrieNode* p = root;\n\n        for (int i = 0; i < word.size(); i++) {\n            unordered_map<char, TrieNode*>::iterator iter =\n                p->children.find(word[i]);\n\n            if (iter == p->children.end()) {\n                p->children[word[i]] = new TrieNode();\n            }\n\n            p = p->children[word[i]];\n        }\n\n        p->isWord = true;\n        p->cost = min(p->cost, cost);\n    }\n\n    // bool search(string& word, int start, int end) {\n    //     vector<pair<int, int>> result;\n\n    //     TrieNode* p = root;\n\n    //     for (int i = start; i < end; i++) {\n    //         if (p->children.find(word[i]) == p->children.end()) {\n    //             return result;\n    //         }\n\n    //         p = p->children[word[i]];\n\n    //         result.push_back({i, p->cost});\n    //     }\n\n    //     return result;\n    // }\n\n    // bool startsWith(string prefix) {\n    //     TrieNode* p = root;\n\n    //     for (int i = 0; i < prefix.size(); i++) {\n    //         if (p->children.find(prefix[i]) == p->children.end()) {\n    //             return false;\n    //         }\n\n    //         p = p->children[prefix[i]];\n    //     }\n\n    //     return true;\n    // }\n};\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        // duplicate\n\n        Trie* trie = new Trie();\n        for (int i = 0; i < words.size(); i++) {\n            trie->insert(words[i], costs[i]);\n        }\n\n        vector<int> cost(target.size(), INT_MAX);\n\n        TrieNode* p = trie->root;\n\n        for (int j = 0; j < target.size(); j++) {\n            if (p->children.find(target[j]) == p->children.end()) {\n                break;\n            }\n\n            p = p->children[target[j]];\n\n            // j, p->cost\n\n            if (p->isWord) {\n                cost[j] = p->cost;\n            }\n        }\n\n        for (int i = 0; i < target.size(); i++) {\n            if (cost[i] != INT_MAX) {\n                // int base_cost\n\n                TrieNode* p = trie->root;\n\n                for (int j = i + 1; j < target.size(); j++) {\n                    if (p->children.find(target[j]) == p->children.end()) {\n                        break;\n                    }\n\n                    p = p->children[target[j]];\n\n                    // j, p->cost\n\n                    if (p->isWord) {\n                        cost[j] = min(cost[j], cost[i] + p->cost);\n                    }\n\n                    \n\n                    // result.push_back({i, p->cost});\n                }\n            }\n            \n        }\n\n        if (cost.back() == INT_MAX) {\n            return -1;\n        }\n        return cost.back();\n    }\n};",
    "submit_ts": "1720322509",
    "subm_id": "1312351804"
}