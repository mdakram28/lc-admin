{
    "username": "qdd1999",
    "submission": "using i64 = int64_t;\n\nstruct V {\n  i64 x, y;\n  constexpr V(i64 x = 0, i64 y = 0) : x(x), y(y) {}\n  V operator+(V b) const { return V(x + b.x, y + b.y); }\n  V operator-(V b) const { return V(x - b.x, y - b.y); }\n  i64 len2() const { return x * x + y * y; }\n};\n\nostream& operator<<(ostream& os, V p) { return os << \"(\" << p.x << \", \" << p.y << \")\"; }\nistream& operator>>(istream& is, V& p) { return is >> p.x >> p.y; }\n\nstruct Circle {\n  V o;\n  i64 r;\n  Circle(V o = V(), i64 r = 0) : o(o), r(r) {}\n};\n\nbool intersects(Circle a, Circle b) {\n  i64 d2 = (a.o - b.o).len2();\n  i64 r2 = (a.r + b.r) * (a.r + b.r);\n  return d2 <= r2;\n}\n\nstruct dsu {\n  vector<int> p;\n  dsu(int n) : p(n, -1) {}\n  int find(int x) { return (p[x] < 0) ? x : p[x] = find(p[x]); }\n  bool merge(int x, int y) {\n    x = find(x), y = find(y);\n    if (x == y) return 0;\n    p[y] += p[x];\n    p[x] = y;\n    return 1;\n  }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -p[find(x)]; }\n};\n\nclass Solution {\npublic:\n  bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n    vector<Circle> cs;\n    for (auto& c : circles) {\n      cs.emplace_back(V(c[0], c[1]), c[2]);\n    }\n    int n = cs.size();\n    dsu d(n + 2);\n    for (int i = 0; i < n; i++) {\n      if ((cs[i].o.y + cs[i].r >= Y) || (cs[i].o.x - cs[i].r <= 0)) d.merge(n, i);\n      if ((cs[i].o.y - cs[i].r <= 0) || (cs[i].o.x + cs[i].r >= X)) d.merge(n + 1, i);\n    }\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if (intersects(cs[i], cs[j])) {\n          d.merge(i, j);\n        }\n      }\n    }\n    return !d.same(n, n + 1);\n  }\n};\n",
    "submit_ts": "1722134902",
    "subm_id": "1335682562"
}