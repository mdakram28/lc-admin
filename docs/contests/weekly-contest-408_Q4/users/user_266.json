{
    "username": "Albert_Zhang",
    "submission": "\"\"\" === Method 1. geometry with union-find\n(1) If one circle contains (0, 0) or (X, Y), it fails\n(2) If any circle contains left/top side, any circle contains contains bottom/right side, and they can be connected\n    through multiple circles, it fails. \n    We can group them into 2 groups, and check if they are connected.\nO(n^2) time | O(n) space - where n is the number of circles.\n\"\"\"\nimport math\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        if self.containsOrigin(circles):\n            return False\n        if self.containsXY(X, Y, circles):\n            return False\n        return not self.containsTwoSides(X, Y, circles)\n\n    def containsOrigin(self, circles):\n        return self.containsXY(0, 0, circles)\n\n    def containsXY(self, X, Y, circles):\n        for x, y, r in circles:\n            if (x - X) ** 2 + (y - Y) ** 2 <= r ** 2:\n                return True\n        return False\n\n    def includesPoint(self, X, Y, x, y, r):\n        return (x - X) ** 2 + (y - Y) ** 2 <= r ** 2\n\n    def containsTwoSides(self, X, Y, circles):\n        n = len(circles)\n        unionFind = UnionFind(n)\n        for i in range(n):\n            x1, y1, r1 = circles[i]\n            for j in range(i + 1, n):\n                x2, y2, r2 = circles[j]\n                if (x1 - x2) ** 2 + (y1 - y2) ** 2 <= (r1 + r2) ** 2:\n                    unionFind.union(i, j)\n\n        leftTopIdxs = []\n        rightBottomIdxs = []\n        for idx, (x, y, r) in enumerate(circles):\n            if self.includesPoint(0, Y, x, y, r) or (0 <= y <= Y and abs(x) <= r) or (0 <= x <= X and abs(y - Y) <= r):\n                leftTopIdxs.append(idx)\n            if self.includesPoint(X, 0, x, y, r) or (0 <= x <= X and abs(y) <= r) or (0 <= y <= Y and abs(x - X) <= r):\n                rightBottomIdxs.append(idx)\n\n        for leftTopIdx in leftTopIdxs:\n            for rightBottomIdx in rightBottomIdxs:\n                if unionFind.isConnected(leftTopIdx, rightBottomIdx):\n                    return True\n        return False\n\n        \n\n\n            \n        \n\nclass UnionFind:\n    \"\"\"\n    This is a normal union-find, using path-compression and union-by-rank techniques.\n    You can use this data structure to efficiently: \\n\n    (1) find the group of a certain node; \\n\n    (2) union 2 nodes together into one group; \\n\n    (3) check if 2 nodes are in the same group (connected); \\n\n    (4) count the number of groups in the entire collection.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        This is the initialization of the union-find.\n        For simplicity, we only take in size (a positive integer) \n        as the size of the collection (array, etc.). \\n\n        complexity: O(n) time | O(n) space - where n is the size.\n        \"\"\"\n        self.parents = [idx for idx in range(size)] # the groups of nodes\n        self.sizes = [1 for _ in range(size)] # the sizes (or ranks) of nodes\n\n    def find(self, x):\n        \"\"\"\n        find(self, x) method can find the group (root) of the node x.\n        Here we apply path-compression technique.\n        amortized complexity: O(log*(n)) time | O(1) space - where n is the size.\n        \"\"\"\n        if self.parents[x] != x: # path compression\n            self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n\n    def union(self, x, y):\n        \"\"\"\n        union(self, x, y) can union elements x and y together into the same group,\n        and return the root of the new group.\n        Here we apply union-by-rank technique. \\n\n        amortized complexity: O(log*(n)) time | O(1) space - where n is the size.\n        \"\"\"\n        parentOfX, parentOfY = self.find(x), self.find(y)\n        if parentOfX == parentOfY: # edge case: x and y are already in the same group\n            return parentOfX\n        if self.sizes[parentOfX] > self.sizes[parentOfY]: # make parentOfY the larger group\n            parentOfX, parentOfY = parentOfY, parentOfX\n        self.parents[parentOfX] = parentOfY # union-by-rank\n        self.sizes[parentOfY] += self.sizes[parentOfX]\n        return parentOfY\n\n    def isConnected(self, x, y):\n        \"\"\"\n        isConnected(self, x, y) method can check if 2 elements are connected \n        with each other (in the same group). \\n\n        amortized complexity: O(log*(n)) time | O(1) space - where n is the size.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\n    def countGroups(self):\n        \"\"\"\n        countGroups(self) method can count the number of groups in the collection.\\n\n        amortized complexity: O(nlog*(n)) time | O(1) space - where n is the size.\n        \"\"\"\n        groupCount = 0\n        for idx in range(len(self.parents)):\n            if idx == self.find(idx):\n                groupCount += 1\n        return groupCount\n",
    "submit_ts": "1722136959",
    "subm_id": "1335749987"
}