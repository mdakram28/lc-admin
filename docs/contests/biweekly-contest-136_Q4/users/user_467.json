{
    "username": "magzybogues5191",
    "submission": "class Solution {\npublic:\n    \n    \n    \n    int tree[400005]; // Segment tree\n    int lazy[400005]; // Lazy array to propagate updates\n\n    // Function to build the tree\n    void build(int node, int start, int end)\n    {\n        if(start == end)\n        {\n            // Leaf node will have a single element\n            tree[node] = 0;\n        }\n        else\n        {\n            int mid = (start + end) / 2;\n            // Recur for the 2 children\n            build(2*node, start, mid);\n            build(2*node+1, mid+1, end);\n            // Internal node will have the minimum of both of its children\n            tree[node] = max(tree[2*node], tree[2*node+1]);\n        }\n    }\n\n    // Function to update a node\n    void update(int node, int start, int end, int l, int r, int val)\n    {\n        if(lazy[node] != 0)\n        { \n            // This node needs to be updated\n            tree[node] += lazy[node]; // Update it\n            if(start != end)\n            {\n                lazy[node*2] += lazy[node]; // Mark child as lazy\n                lazy[node*2+1] += lazy[node]; // Mark child as lazy\n            }\n            lazy[node] = 0; // Reset it\n        }\n        if(start > end or start > r or end < l) return; // Current segment is not within range [l, r]\n        if(start >= l and end <= r)\n        {\n            // Segment is fully within range\n            tree[node] += val;\n            if(start != end)\n            {\n                // Not leaf node\n                lazy[node*2] += val;\n                lazy[node*2+1] += val;\n            }\n            return;\n        }\n        int mid = (start + end) / 2;\n        update(node*2, start, mid, l, r, val); // Updating left child\n        update(node*2 + 1, mid + 1, end, l, r, val); // Updating right child\n        tree[node] = max(tree[node*2], tree[node*2+1]); // Updating root with min value \n    }\n\n    // Function to query the tree\n    int query(int node, int start, int end, int l, int r)\n    {\n        if(start > end or start > r or end < l) return 0; // Out of range\n        if(lazy[node] != 0)\n        {\n            // This node needs to be updated\n            tree[node] += lazy[node]; // Update it\n            if(start != end)\n            {\n                lazy[node*2] += lazy[node]; // Mark child as lazy\n                lazy[node*2+1] += lazy[node]; // Mark child as lazy\n            }\n            lazy[node] = 0; // Reset it\n        }\n        if(start >= l and end <= r) // Current segment is totally within range [l, r]\n            return tree[node];\n        int mid = (start + end) / 2;\n        int p1 = query(node*2, start, mid, l, r); // Query left child\n        int p2 = query(node*2 + 1, mid + 1, end, l, r); // Query right child\n        return max(p1, p2);\n    }\n\n    \n    class sparse{\n    public:\n        vector<vector<int>> st;\n        int n;\n        sparse(int n,vector<int> &a){\n            this->n=n;\n            st.resize(n+1);\n            for(int i=0;i<=n;++i){\n                st[i].resize(30);\n            }\n            for(int i=0;i<n;++i){\n                st[i][0]=a[i];\n            }\n            for(int j=1;j<=log2(n);++j){\n                for(int i=0;i+(1<<j)<=n;++i){\n                    st[i][j]=max(st[i][j-1],st[i+(1<<(j-1))][j-1]);\n                }\n            }\n        }\n        int shoot(int l,int r){\n            int j=log2(r-l+1);\n            int ans=max(st[l][j],st[r-(1<<(j))+1][j]);\n            return ans;\n        }\n\n    };\n    \n    int time;\n    \n    void dfs(int node,int par,vector<int> *g,vector<int> &in,vector<int> &out,vector<int> &h,vector<int> &order){\n        in[node]=time++;\n        order.push_back(node);\n        for(auto j:g[node]){\n            if(j!=par){\n                if(j%2){\n                    h[j]=(h[node]+1);\n                }\n                else{\n                    h[j]=(h[node]+2);\n                }\n                dfs(j,node,g,in,out,h,order);\n            }\n        }\n        out[node]=time-1;\n    }\n    \n    \n    void rec(int node,int par,vector<int> *g,vector<int> &in,vector<int> &out,sparse &s,int inwards,int outwards,vector<int> &ans){\n        \n        int n=in.size();\n        if(node!=0){\n            update(1,0,n-1,in[node],out[node],(node&1)?-1:-2);\n            if(in[node]){\n                update(1,0,n-1,0,in[node]-1,(par&1)?1:2);\n            }\n            if(out[node]+1<n){\n                update(1,0,n-1,out[node]+1,n-1,(par&1)?1:2);\n            }\n            ans[node]=query(1,0,n-1,0,n-1);\n        }\n        else{\n            ans[node]=query(1,0,n-1,0,n-1);\n        }\n        for(auto j:g[node]){\n            if(j==par){\n                continue;\n            }\n            int ni=inwards+((j&1)?1:2);\n            int no=outwards+(node&1)?1:2;\n            rec(j,node,g,in,out,s,ni,no,ans);\n        }\n        if(node!=0){\n            update(1,0,n-1,in[node],out[node],(node&1)?1:2);\n            if(in[node]){\n                update(1,0,n-1,0,in[node]-1,(par&1)?-1:-2);\n            }\n            if(out[node]+1<n){\n                update(1,0,n-1,out[node]+1,n-1,(par&1)?-1:-2);\n            }\n        }\n    }\n    \n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        int n=edges.size()+1;\n        vector<int> in(n,0),out(n,0),h(n,0),order;\n        time=0;\n        build(1, 0, n-1);\n        vector<int> g[n];\n        for(auto i:edges){\n            g[i[0]].push_back(i[1]);\n            g[i[1]].push_back(i[0]);\n        }\n        dfs(0,-1,g,in,out,h,order);\n        vector<int> ref(n);\n        for(int i=0;i<n;++i){\n            ref[i]=h[order[i]];\n        }\n        for(int i=0;i<n;++i){\n            update(1, 0, n-1, i,i,ref[i]);\n        }\n        \n        \n        sparse s(n,ref);\n        vector<int> ans(n,0);\n        rec(0,-1,g,in,out,s,0,0,ans);\n        return ans;\n        \n        \n    }\n};",
    "submit_ts": "1722699801",
    "subm_id": "1343222749"
}