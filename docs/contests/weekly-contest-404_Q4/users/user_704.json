{
    "username": "lavishdungerpuriya",
    "submission": "\nclass Solution {\npublic:\n    struct Info {\n        int d;\n        int nd;\n    };\n\n    Info bfs(int s, const vector<vector<int>>& adj) {\n        int n = adj.size();\n        vector<int> dist(n, -1);\n        queue<int> q;\n\n        q.push(s);\n        dist[s] = 0;\n\n        int nd = s;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n\n            for (int x : adj[node]) {\n                if (dist[x] == -1) {\n                    dist[x] = dist[node] + 1;\n                    q.push(x);\n                    if (dist[x] > dist[nd]) {\n                        nd = x;\n                    }\n                }\n            }\n        }\n\n        return {dist[nd], nd};\n    }\n\n    int findd(const vector<vector<int>>& adj) {\n        Info r1 = bfs(0, adj);\n        Info r2 = bfs(r1.nd, adj);\n        return r2.d;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n1 = edges1.size() + 1;\n        int n2 = edges2.size() + 1;\n\n        vector<vector<int>> adj1(n1);\n        vector<vector<int>> adj2(n2);\n\n        for (auto& p : edges1) {\n            adj1[p[0]].push_back(p[1]);\n            adj1[p[1]].push_back(p[0]);\n        }\n\n        for (auto& p : edges2) {\n            adj2[p[0]].push_back(p[1]);\n            adj2[p[1]].push_back(p[0]);\n        }\n        int d1 = findd(adj1);\n        int d2 = findd(adj2);\n        int newDiameter = max({d1, d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1});\n        return newDiameter;\n    }\n};\n\n\n",
    "submit_ts": "1719718162",
    "subm_id": "1304410301"
}