{
    "username": "Quar",
    "submission": "class Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        segtree = [0] * n * 4\n        offset = 2*n\n\n        def is_peak(i):\n            if i == 0 or i == n - 1:\n                return 0\n            return int(nums[i - 1] < nums[i] > nums[i + 1])\n        \n        for i in range(n):\n            segtree[i + offset] = is_peak(i)\n        \n        for i in reversed(range(offset)):\n            segtree[i] = segtree[2*i] + segtree[2*i + 1]\n        \n        def query(l, r):\n            l = l + 1 + offset\n            r = r - 1 + offset + 1\n            ret = 0\n            while l < r:\n                if l % 2:\n                    ret += segtree[l]\n                    l += 1\n                l //= 2\n                if r % 2:\n                    ret += segtree[r - 1]\n                    r -= 1\n                r //= 2\n            return ret\n        \n        def seg_update(i, x):\n            i += offset\n            delta = x - segtree[i]\n            segtree[i] = x\n            while (i := i // 2):\n                segtree[i] += delta\n        \n        def update(i, x):\n            nums[i] = x\n            if i > 0:\n                seg_update(i - 1, is_peak(i - 1))\n            if i < n - 1:\n                seg_update(i + 1, is_peak(i + 1))\n            seg_update(i, is_peak(i))\n        \n        ret = []\n        \n        for t, a, b in queries:\n            if t == 1:\n                # print(segtree)\n                ret.append(query(a, b))\n            else:\n                update(a, b)\n        \n        return ret\n",
    "submit_ts": 1718507548.0
}