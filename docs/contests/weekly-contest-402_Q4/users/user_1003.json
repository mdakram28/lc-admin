{
    "username": "invincible142002",
    "submission": "class Solution {\npublic:\n    \n\nstatic bool isPeak(const vector<int>& arr, int i) {\n    if (i <= 0 || i >= arr.size() - 1) return false;\n    return arr[i] > arr[i-1] && arr[i] > arr[i+1];\n}\n\n\nclass ST {\nprivate:\n    vector<int> tree;\n    int n;\n\n    void bd(const vector<int>& arr, int nd, int start, int end) {\n        if (start == end) {\n            tree[nd] = isPeak(arr, start) ? 1 : 0;\n        } else {\n            int mid = (start + end) / 2;\n            bd(arr, 2 * nd + 1, start, mid);\n            bd(arr, 2 * nd + 2, mid + 1, end);\n            tree[nd] = tree[2 * nd + 1] + tree[2 * nd + 2];\n        }\n    }\n\n    void upd(const vector<int>& arr, int nd, int start, int end, int idx) {\n        if (start == end) {\n            tree[nd] = isPeak(arr, idx) ? 1 : 0;\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid) {\n                upd(arr, 2 * nd + 1, start, mid, idx);\n            } else {\n                upd(arr, 2 * nd + 2, mid + 1, end, idx);\n            }\n            tree[nd] = tree[2 * nd + 1] + tree[2 * nd + 2];\n        }\n    }\n\n    int quq(int nd, int start, int end, int l, int r) {\n        if (r < start || end < l) {\n            return 0;\n        }\n        if (l <= start && end <= r) {\n            return tree[nd];\n        }\n        int mid = (start + end) / 2;\n        int left_quq = quq(2 * nd + 1, start, mid, l, r);\n        int right_quq = quq(2 * nd + 2, mid + 1, end, l, r);\n        return left_quq + right_quq;\n    }\n\npublic:\n    ST(const vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        bd(arr, 0, 0, n - 1);\n    }\n\n    void upd(const vector<int>& arr, int idx) {\n        upd(arr, 0, 0, n - 1, idx);\n    }\n\n    int quq(int l, int r) {\n        return quq(0, 0, n - 1, l, r);\n    }\n};\n\nvector<int> countOfPeaks(vector<int>& arr, vector<vector<int>>& vq) {\n    int n = arr.size();\n    vector<int> ans;\n    ST SegT(arr);\n\n    for (const auto& x : vq) {\n       \n        if (x[0] == 2) {\n            int ix = x[1];\n            int val = x[2];\n            arr[ix] = val;\n            if (ix > 0) SegT.upd(arr, ix - 1);\n            SegT.upd(arr, ix);\n            if (ix < n - 1) SegT.upd(arr, ix + 1);\n        }\n        else if  (x[0] == 1) {\n            int l = x[1];\n            int r = x[2];\n            int dift =l+1;\n            int nift = r-1;\n            ans.push_back(SegT.quq(dift,nift));\n        }\n    }\n\n    return ans;\n}\n};",
    "submit_ts": 1718508682.0
}