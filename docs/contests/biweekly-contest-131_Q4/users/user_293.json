{
    "username": "The_2nd_Derivative",
    "submission": "\n#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)\n// trace std::pair\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){\n    return os<<\"{\"<<P.first<<\":\"<<P.second<<\"}\";\n}\n// trace std::vector\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){\n    os<<\"[ \";for(auto v:V)os<<v<<\" \";return os<<\"]\";\n}\n// trace std::map;\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {\n    os<<\"[ \";for(auto& P : MP) os<<P<<\" \";return os<<\"]\";\n}\n// trace unordred_std::map\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {\n    os<<\"[ \";for(auto& P : MP) os<<P<<\" \";return os<<\"]\";\n}\n// trace std::set\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){\n    os<<\"[ \";for(auto s:S)os<<s<<\" \";return os<<\"]\";\n}\n// trace std::unordered_set\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){\n    os<<\"[ \";for(auto s:S)os<<s<<\" \";return os<<\"]\";\n}\n// std::stack FUN\ntemplate<class T> void F_Stack(std::stack<T> st, std::string& cont) { \n    if(st.empty()) return;\n    T mem=st.top();st.pop();F_Stack(st,cont);cont+=\" \"+to_string(mem);  \n}\n// trace std::stack                                                  \ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {\n    os<<\"[\";std::string cont=\"\";F_Stack(st,cont);return os<<cont<<\" ]\";\n}\n// track std::queue\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {\n    os<<\"[ \";while(!q.empty()) os<<q.front()<<\" \",q.pop();return os<<\"]\";\n}\n\n// for last arg.\ntemplate<typename Arg1>\nvoid __f(const char* name,Arg1&& arg1){\n    std::cout<<name<<\" : \"<<arg1<<std::endl;\n}\n// for variable arg\ntemplate <typename Arg1,typename... Args>\nvoid __f(const char* names,Arg1&& arg1,Args&&... args){\n    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<\" : \"<<arg1<<\" | \";__f(comma+1,args...);\n}\n\n// dbg std::array\ntemplate<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){\n    os<<\"[ \";for(auto v:V)os<<v<<\" \";return os<<\"]\";\n}\n\n// X.find_by_order(k) return iterator to kth element. 0 indexed.\n// X.order_of_key(k) returns count of elements strictly less than k.\n\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// template <class T>\n// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define sz(x) ((ll)(x).size())\n#define nl '\\n'\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n \nusing ll = long long int;\nusing pii = pair<ll,ll>;\nusing mii = map<ll,ll>;\nusing umii = unordered_map<ll,ll>;\nusing vi = vector<int>;\nusing vii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvii = vector<vii>;\n\ntemplate<class T> bool chmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool chmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nconst ll INF = 1e18;\nconst ll MAX = 50000;\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int n = sz(queries);\n        set<int> mark;\n        mark.insert(0);\n        mark.insert(MAX);\n        map<int, set<int>> mp;\n        mp[MAX].insert(MAX);\n        vector<bool> ans;\n        // dbg(mark);\n        // for (auto &it : mp) {\n        //     dbg(it.first, it.second);\n        // }\n        // dbg(nl);\n        for (auto &it : queries) {\n            int type = it[0];\n            if (type == 1) {\n                int x = it[1];\n                if (x == MAX) continue;\n                auto it = mark.lower_bound(x);\n                int rght = *it;\n                int lft = *(prev(it));\n                // dbg(x, lft, rght);\n                int cursiz = rght - lft;\n                mp[cursiz].erase(rght);\n                if (mp[cursiz].empty()) mp.erase(cursiz);\n                mark.insert(x);\n                mp[x - lft].insert(x);\n                mp[rght - x].insert(rght);\n                // dbg(mark);\n                // for (auto &it : mp) {\n                //     dbg(it.first, it.second);\n                // }\n                // dbg(nl);\n            } else {\n                // cout << \"Hi\" << nl;\n                int x = it[1];\n                int reqsiz = it[2];\n                auto it = mark.lower_bound(x);\n                int rght = *it;\n                int lft = *(--it);\n                if (x - lft >= reqsiz) {\n                    ans.push_back(true);\n                    continue;\n                } else {\n                    x = lft;\n                }\n                // dbg(x, reqsiz, lft, rght, mark);\n                // for (auto &it : mp) {\n                //     dbg(it.first, it.second);\n                // }\n                // dbg(nl);\n                bool got = false;\n                for (auto it = mp.rbegin(); it != mp.rend(); it++) {\n                    if (it->first < reqsiz) break;\n                    auto it2 = it->second.upper_bound(x);\n                    if (it2 != it->second.begin()) {\n                        got = true;\n                        break;\n                    }\n                }\n                ans.push_back(got);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716651885.0
}