{
    "username": "gaoyf1235",
    "submission": "namespace atcoder{\ntemplate <typename T, T (*operation)(T, T), T (*default_val)()> \nclass segtree {\nprivate:\n    int _n, size, log;\n    std::vector<T> d;\n    int ceil_pow2(int n) {\n        int x = 0;\n        while ((1U << x) < (unsigned int)(n)) x++;\n        return x;\n    }\n    void update(int k) { d[k] = operation(d[2 * k], d[2 * k + 1]); }\npublic:\n    // Constructor complexity: O(n)\n    segtree(int n) : segtree(std::vector<T>(n, default_val())) {}\n\n    segtree(const std::vector<T>& v) : _n(int(v.size())) {\n        log = ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<T>(2 * size, default_val());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, T x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    T get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n    // calculate operation(a[l], ..., a[r - 1]) in O(logn), where a is the original array data.\n    T prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        T sml = default_val(), smr = default_val();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = operation(sml, d[l++]);\n            if (r & 1) smr = operation(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return operation(sml, smr);\n    }\n\n    T all_prod() { return d[1]; }\n    // Apply binary search on the segment tree. The function bool f(T x) should be defined.\n    // https://atcoder.github.io/ac-library/master/document_en/segtree.html\n    template <bool (*f)(T)> int max_right(int l) {\n        return max_right(l, [](T x) { return f(x); });\n    }\n\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(default_val()));\n        if (l == _n) return _n;\n        l += size;\n        T sm = default_val();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(operation(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(operation(sm, d[l]))) {\n                        sm = operation(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = operation(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(T)> int min_left(int r) {\n        return min_left(r, [](T x) { return f(x); });\n    }\n\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(default_val()));\n        if (r == 0) return 0;\n        r += size;\n        T sm = default_val();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(operation(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(operation(d[r], sm))) {\n                        sm = operation(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = operation(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n};\n\n}  // namespace atcoder\n\n\nclass Solution {\n    static int default_val() {return 0; }\n    static int operation(int a, int b) { return a + b; }\n    template<typename T>\n    void printAll(T& vec, const string& delimiter =  \" \"){\n        for(const auto& x : vec){\n            cout << x << delimiter;\n        }\n        cout << endl;\n    }\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> cnt(n, 0);\n        for(int i = 1; i < n - 1; i++){\n            if(nums[i] > nums[i-1] and nums[i] > nums[i+1]){\n                cnt[i] = 1;\n            }\n        }\n        //printAll(cnt);\n        atcoder::segtree<int, operation, default_val> tree(cnt);\n        vector<int> res;\n        for(auto& q: queries){\n            if(q[0] == 1){\n                int l = q[1];\n                int r = q[2];\n                if(l < r){\n                    auto ans = tree.prod(l + 1, r);\n                    res.push_back(ans);\n                }\n                else res.push_back(0);\n            }\n            else{\n                int id = q[1];\n                int val = q[2];\n                nums[id] = val;\n                for(int i = max(id - 1, 1); i <= min(id + 1, n - 2); i++){\n                    if(nums[i] > nums[i-1] and nums[i] > nums[i+1]){\n                        tree.set(i, 1);\n                    }\n                    else{\n                        tree.set(i, 0);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1718507325.0
}