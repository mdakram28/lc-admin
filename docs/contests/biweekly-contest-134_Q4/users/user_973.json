{
    "username": "aditya_0670",
    "submission": "#define all( v )        v.begin() , v.end()\n#define ff              first\n#define ss              second\n#define pb              push_back\n#define ll              long long\n#define pii             pair<int,int>\n#define rall( v )       v.rbegin() , v.rend()\n#define mxe( v )        *max_element(v.begin() , v.end())\n#define mne( v )        *min_element(v.begin() , v.end())\nclass Solution {\npublic:\n// SEGMENT TREES\n    \n    template<typename Node, typename Update>\n    struct SegTree\n    {\n        vector<Node> tree;\n        vector<int> arr;\n        int n , s;\n\n        SegTree(int a_len, vector<int> &a)\n        {\n            arr = a;\n            n = a_len , s = 1;\n\n            while(s < 2 * n) s = s << 1;\n\n            tree.resize(4 * n);\n            fill(all(tree), Node());\n            build(0, n - 1, 1);\n        }\n\n        void build(int start, int end, int index)\n        {\n            if (start == end)\n            {\n                tree[index] = Node(arr[start]);\n                return;\n            }\n            int mid = (start + end) / 2;\n\n            build(start, mid, 2 * index);\n            build(mid + 1, end, 2 * index + 1);\n\n            tree[index].merge(tree[2 * index], tree[2 * index + 1]);\n        }\n\n        void update(int start, int end, int index, int query_index, Update &u)\n        {\n            if (start == end)\n            {\n                u.apply(tree[index]);\n                return;\n            }\n            int mid = (start + end) / 2;\n\n            if (mid >= query_index)\n                update(start, mid, 2 * index, query_index, u);\n            else\n                update(mid + 1, end, 2 * index + 1, query_index, u);\n\n            tree[index].merge(tree[2 * index], tree[2 * index + 1]);\n        }\n\n        Node query(int start, int end, int index, int left, int right)\n        {\n            if (start > right || end < left)\n                return Node();\n            if (start >= left && end <= right)\n                return tree[index];\n\n            int mid = (start + end) / 2;\n            Node l, r, ans;\n\n            l = query(start, mid, 2 * index, left, right);\n            r = query(mid + 1, end, 2 * index + 1, left, right);\n\n            ans.merge(l, r);\n            return ans;\n        }\n\n        void make_update(int index, int val)\n        {   // pass in as many parameters as required\n            Update new_update = Update(val); // may change\n            update(0, n - 1, 1, index, new_update);\n        }\n        \n        Node make_query(int left, int right)\n        {\n            return query(0, n - 1, 1, left, right);\n        }\n    };\n    \n    struct Node1\n    {\n        int val;\n        Node1()\n        {\n            val = -1;\n        }\n        Node1(int p1)\n        {\n            val = p1;\n        }\n        void merge(Node1 &l, Node1 &r)\n        {\n            val = (l.val&r.val);\n        }\n    };\n    \n    struct UpdateIndex\n    {\n        int val;\n        UpdateIndex(int p1)\n        {\n            val = p1;\n        }\n        void apply(Node1 &a)\n        {\n            a.val = val;\n        }\n    };\n\n    long long countSubarrays(vector<int>& a, int k) {\n        int n = a.size();\n        SegTree< Node1 , UpdateIndex > sgt1(n , a);\n\n        auto findFirstI = [&](int j) {\n            int lo = j, hi = n - 1, res = -1;\n            while (lo <= hi) {\n                int mid = lo + ((hi - lo) >> 1);\n                int val1 = sgt1.make_query( j , mid ).val;\n                \n                if( val1 == k ) res = mid , hi = mid - 1;\n                else if( val1 > k ) lo = mid + 1;\n                else hi = mid - 1;\n                \n            }\n            return res;\n        };\n\n        auto findLastI = [&](int j) {\n            int lo = j, hi = n - 1, res = -1;\n            while (lo <= hi) {\n                int mid = lo + ((hi - lo) >> 1);\n                int val1 = sgt1.make_query( j , mid ).val;\n                \n                if( val1 == k ) res = mid , lo = mid + 1;\n                else if( val1 > k ) lo = mid + 1;\n                else hi = mid - 1;\n            }\n            return res;\n        };\n\n        long long cnt = 0;\n        for (int i = 0; i < n; i++) {\n            int l = findFirstI(i);\n            int r = findLastI(i);\n            \n            if (l == -1 || r == -1) continue;\n            cnt += (r - l + 1);\n        }\n\n        return cnt;\n    }\n};\n",
    "submit_ts": "1720279874",
    "subm_id": "1311768521"
}