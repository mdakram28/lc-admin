{
    "username": "zhiylu528",
    "submission": "// class Solution {\n// public:\n//     int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n//         unordered_map<char, unordered_map<string, int>> combined;\n//         for (int i = 0; i < words.size(); i++) {\n//             if (combined[words[i][0]].count(words[i]) == 0 || combined[words[i][0]][words[i]] > costs[i]) {\n//                 combined[words[i][0]][words[i]] = costs[i];\n//             }\n//         }\n//         unordered_map<int, int> dp;\n//         int res = backtrack(target, 0, combined, dp);\n//         return res == INT_MAX ? -1 : res;\n//     }\n\n//     int backtrack(string& target, int start, unordered_map<char, unordered_map<string, int>>& words, unordered_map<int, int>& dp) {\n//         if (dp.count(start)) {\n//             return dp[start];\n//         } else if (start >= target.size()) {\n//             return 0;\n//         }\n\n//         int res = INT_MAX;\n\n//         for (pair<const string, int>& p : words[target[start]]) {\n//             int len = p.first.size();\n//             if (target.compare(start, len, p.first, 0, len) == 0) {\n//                 int temp = backtrack(target, start + len, words, dp);\n//                 if (temp != INT_MAX) {\n//                     res = min(res, p.second + backtrack(target, start + len, words, dp));\n//                 }\n//             }\n//         }\n\n//         return dp[start] = res;\n//     }\n// };\n\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        unordered_map<char, unordered_map<string, int>> combined;\n        for (int i = 0; i < words.size(); i++) {\n            if (combined[words[i][0]].count(words[i]) == 0 || combined[words[i][0]][words[i]] > costs[i]) {\n                combined[words[i][0]][words[i]] = costs[i];\n            }\n        }\n        \n        int n = target.size();\n        vector<int> dp(n + 1, INT_MAX);  // dp[i] represents the minimum cost to build target[0:i]\n        dp[0] = 0;  // The cost to build an empty string is 0\n\n        // Iterate over each position in the target string\n        for (int i = 0; i < n; ++i) {\n            if (dp[i] == INT_MAX) continue;  // Skip if this position is not reachable\n            // Try to match each word starting from position i\n            for (const auto& entry : combined[target[i]]) {\n                const string& word = entry.first;\n                int word_len = word.size();\n                if (i + word_len <= n && target.compare(i, word_len, word) == 0) {\n                    dp[i + word_len] = min(dp[i + word_len], dp[i] + entry.second);\n                }\n            }\n        }\n\n        return dp[n] == INT_MAX ? -1 : dp[n];\n    }\n};",
    "submit_ts": "1720323722",
    "subm_id": "1312382465"
}