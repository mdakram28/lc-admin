{
    "username": "Silken",
    "submission": "\nnamespace atcoder {\n\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    explicit dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n\n}  // namespace atcoder\nusing i64 = long long;\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        using namespace atcoder;\n        int n = circles.size();\n        dsu u(n);\n        for(int i=0; i < n; i++) {\n            for(int j = i+1; j < n; j++) {\n                i64 dx2 = abs(circles[i][0]-circles[j][0]);\n                dx2 *= dx2;\n                i64 dy2 = abs(circles[i][1]-circles[j][1]);\n                dy2 *= dy2;\n                i64 d2 = circles[i][2] + circles[j][2];\n                d2 *= d2;\n                // printf(\"dx: %ld, dy: %ld, r: %ld\\n\", dx2, dy2, d2);\n                if(dx2 + dy2 <= d2) {\n                    u.merge(i, j);\n                }\n            }\n        }\n\n        auto gr = u.groups();\n        for(auto& g : gr) {\n            bool l=0, r=0, u=0, d=0;\n            for(int i : g) {\n                if(circles[i][0] <= circles[i][2])\n                    l=1;\n                if(X-circles[i][0] <= circles[i][2])\n                    r=1;\n                if(Y-circles[i][1] <= circles[i][2])\n                    u=1;\n                if(circles[i][1] <= circles[i][2])\n                    d=1;\n            }\n            // printf(\"%d %d %d %d\\n\", l, r, u, d);\n            if((l&&r) || (u&&d) || (l&&d) || (u&&r))\n                return false;\n        }\n        return true;\n    }\n};",
    "submit_ts": "1722136765",
    "subm_id": "1335744324"
}