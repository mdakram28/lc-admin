{
    "username": "lotusblume",
    "submission": "#include <cassert>\n#include <vector>\n\n#include <cassert>\n#include <vector>\n\ntypedef int S;\n\nS e() {\n\treturn 0;\n}\n\nS op(S x, S y) {\n\treturn max(x, y);\n}\n\nnamespace atcoder {\n\nstruct segtree {\nprivate:\n\tint n;\n\tstd::vector<S> d;\n\npublic:\n\tsegtree(int _n) : segtree(std::vector<S>(_n, e())) {}\n\n\tsegtree(const std::vector<S>& v) {\n\t\tn = 1;\n\t\twhile (n < (int) v.size()) n <<= 1;\n\t\td.assign(2 * n, e());\n\t\tfor (int i = 0; i < (int) v.size(); i++) d[n + i] = v[i];\n\t\tfor (int i = n - 1; i >= 1; i--) {\n\t\t\td[i] = op(d[2 * i], d[2 * i + 1]);\n\t\t}\n\t}\n\n\tvoid set(int p, S x) {\n\t\tassert(0 <= p && p < n);\n\t\tp += n;\n\t\td[p] = x;\n\t\tfor (p >>= 1; p >= 1; p >>= 1) {\n\t\t\td[p] = op(d[2 * p], d[2 * p + 1]);\n\t\t}\n\t}\n\n\tvoid add(int p, S x) {\n\t\tassert(0 <= p && p < n);\n\t\tset(p, op(d[p + n], x));\n\t}\n\n\tS get(int p) {\n\t\tassert(0 <= p && p < n);\n\t\treturn d[p + n];\n\t}\n\n\tS sum(int l, int r) {\n\t\tassert(0 <= l && l <= r && r < n);\n\t\tS sml = e(), smr = e();\n\t\tl += n;\n\t\tr += n + 1;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) sml = op(sml, d[l++]);\n\t\t\tif (r & 1) smr = op(d[--r], smr);\n\t\t\tl >>= 1;\n\t\t\tr >>= 1;\n\t\t}\n\t\treturn op(sml, smr);\n\t}\n};\n\n} // namespace atcoder\n\n\nclass Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {\n        vector<int> b = nums;\n        sort(b.begin(), b.end());\n        b.erase(unique(b.begin(), b.end()), b.end());\n        int n = (int) nums.size();\n        for (int i = 0; i < n; ++i) {\n            nums[i] = int(lower_bound(b.begin(), b.end(), nums[i]) - b.begin());\n        }\n        int m = (int) b.size();\n        vector<atcoder::segtree> dp(k + 1, atcoder::segtree(m));\n        for (int i = 0; i < n; ++i) {\n            for (int j = k; j >= 0; --j) {\n                int mx = 0;\n                if (nums[i] > 0) mx = max(mx, dp[j].sum(0, nums[i] - 1));\n                if (nums[i] + 1 < m) mx = max(mx, dp[j].sum(nums[i] + 1, m - 1));\n                int cur = dp[j].get(nums[i]);\n                dp[j].set(nums[i], cur + 1);\n                if (j + 1 <= k && dp[j + 1].get(nums[i]) < mx + 1) {\n                    dp[j + 1].set(nums[i], mx + 1);\n                }\n            }\n        }\n        int ans = 0;\n        for (int j = 0; j <= k; ++j) {\n            ans = max(ans, dp[j].sum(0, m - 1));\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1717859119.0
}