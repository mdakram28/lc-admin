{
    "username": "Farras Faddila",
    "submission": "class Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& board) {\n       using ll = long long;\n       int m = board.size();\n       int n = board[0].size();\n       ll ret = -1e18;\n       vector<vector<pair<int, int>>> row(m);\n       for (int i = 0; i < m; i++) {\n           vector<pair<int, int>> tmp;\n           for (int j = 0; j < n; j++) {\n               tmp.emplace_back(board[i][j], j);\n           }\n           sort(tmp.begin(), tmp.end(), greater<>());\n           row[i].push_back(tmp[0]);\n           row[i].push_back(tmp[1]);\n           row[i].push_back(tmp[2]);\n       }\n\n       for (int i = 0; i < m; i++) {\n           for (int j = 0; j < n; j++) {\n                if (j != row[i][0].second && j != row[i][1].second && j != row[i][2].second) continue;\n               int cur = board[i][j];\n               vector<vector<pair<ll, int>>> tmp(m, vector<pair<ll, int>>(2));\n               vector<vector<pair<int, int>>> col(n);\n               vector<vector<int>> best(n);\n               for (int k = 0; k < m; k++) {\n                   if (k == i) continue;\n                   int ptr = 0, x = 0;\n                   while (ptr < 2) {\n                       if (row[k][x].second == j) {\n                           x++; continue;\n                       } else {\n                           tmp[k][ptr] = row[k][x];\n                           ptr++, x++;\n                       }\n                   }\n\n\n                   col[tmp[k][0].second].emplace_back(tmp[k][0].first, k);\n                   col[tmp[k][1].second].emplace_back(tmp[k][1].first, k);\n                   best[tmp[k][0].second].push_back(k);\n               }\n               vector<vector<pair<int, int>>> m1(2, vector<pair<int, int>>(n, make_pair(INT_MIN, -1)));\n               vector<vector<pair<int, int>>> m2(2, vector<pair<int, int>>(n, make_pair(INT_MIN, -1)));\n\n               auto add = [&](int val, int loc, int col, int t) {\n                   if (val >= m1[t][col].first) {\n                       m2[t][col] = m1[t][col];\n                       m1[t][col] = make_pair(val, loc);\n                   } else if (val >= m2[t][col].first) {\n                       m2[t][col] = make_pair(val, loc);\n                   }\n               };\n\n\n               for (int k = 0; k < n; k++) {\n                   if (k > 0) {\n                       m1[0][k] = m1[0][k - 1], m2[0][k] = m2[0][k - 1];\n                   }\n                   if (k == j) continue;\n                   for (auto data : col[k]) {\n                       add(data.first, data.second, k, 0);\n                   }\n               }\n               for (int k = n - 1; k >= 0; k--) {\n                   if (k < n - 1) {\n                       m1[1][k] = m1[1][k + 1], m2[1][k] = m2[1][k + 1];\n                   }\n                   if (k == j) continue;\n                   for (auto data : col[k]) {\n                       add(data.first, data.second, k, 1);\n                   }\n               }\n\n\n               for (int k = 0; k < n; k++) {\n                   if (k == j) continue;\n                   for (auto r : best[k]) {\n                       int oth = INT_MIN;\n                       if (k > 0) {\n                           if (m1[0][k - 1].second != r) oth = max(oth, m1[0][k - 1].first);\n                           if (m2[0][k - 1].second != r) oth = max(oth, m2[0][k - 1].first);\n                       }\n                       if (k < n - 1) {\n                           if (m1[1][k + 1].second != r) oth = max(oth, m1[1][k + 1].first);\n                           if (m2[1][k + 1].second != r) oth = max(oth, m2[1][k + 1].first);\n                       }\n                       ret = max(ret, 1ll * cur + tmp[r][0].first + oth);\n                   }\n               }\n           }\n       }\n       return ret;\n   }\n};",
    "submit_ts": "1723909681",
    "subm_id": "1359201753"
}