{
    "username": "arpit0098",
    "submission": "import java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {\n        Map<String, Integer> wordCostMap = new HashMap<>();\n        for (int i = 0; i < words.length; i++) {\n            wordCostMap.put(words[i], Math.min(wordCostMap.getOrDefault(words[i], Integer.MAX_VALUE), costs[i]));\n        }\n\n        int n = target.length();\n        int[] dp = new int[n + 1];\n        // Initialize dp array with a large number representing infinity\n        for (int i = 1; i <= n; i++) {\n            dp[i] = Integer.MAX_VALUE;\n        }\n        dp[0] = 0; // Base case: cost to form an empty string is 0\n\n        // Iterate through each position in the target string\n        for (int i = 1; i <= n; i++) {\n            for (String word : wordCostMap.keySet()) {\n                int wordLength = word.length();\n                // Check if the current word can form the substring ending at position i\n                if (i >= wordLength && target.startsWith(word, i - wordLength)) {\n                    // Update dp[i] with the minimum cost to form the substring up to i\n                    if (dp[i - wordLength] != Integer.MAX_VALUE) {\n                        dp[i] = Math.min(dp[i], dp[i - wordLength] + wordCostMap.get(word));\n                    }\n                }\n            }\n        }\n\n        return dp[n] == Integer.MAX_VALUE ? -1 : dp[n];\n    }\n}\n",
    "submit_ts": "1720322355",
    "subm_id": "1312347675"
}