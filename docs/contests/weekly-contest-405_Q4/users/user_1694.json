{
    "username": "nicolasalba",
    "submission": "#define ACTIVE_DEBUG\n\n// ############ Ignore macros and debugger ########################\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) (x).begin(), (x).end()\n#define sortt(x) sort(all(x))\n\nusing ll = long long;\nusing ld = long double;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing ti = tuple<long long, long long, long long>;\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vs = vector<string>;\nusing vvl = vector<vl>;\nusing vpl = vector<pl>;\n\ntemplate<class T> using pql = priority_queue<T,vector<T>,greater<T>>;\ntemplate<class T> using pqg = priority_queue<T>;\n\nvoid __print(int x) {cout << x;}\nvoid __print(long long x) {cout << x;}\nvoid __print(string x) {cout << x;}\nvoid __print(char x) {cout << '\\'' << x << '\\'';}\nvoid __print(bool x) {cout << (x ? \"T\" : \"F\");}\n\nvoid __print(map<ll,ll> mp) {\n    for (auto p : mp) {\n        cout << p.F << \":\" << p.S << \",\";\n    }\n}\n\ntemplate<typename T> // for data structures (vector, set, map, etc)\n\nvoid __print(const T &xs)\n{cout << \"[ \"; for (auto &x : xs) {__print(x);cout << ' ';}cout << ']';}\n\nvoid _print()\n{cout << \"]\" << endl;}\n\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v)\n{__print(t); if (sizeof...(v)) cout << \", \"; _print(v...);}\n\n#ifdef ACTIVE_DEBUG\n    #define deb(x...) cout << \"[\" << #x << \"] = [\", _print(x)\n    #define LINE cout << \"-------------------\" << endl;\n#else\n    #define deb(x...) \"C\"\n    #define LINE \"C\"\n#endif\n// ############ Ignore macros and debugger ########################\n\n// use SQRT\n// advance SQRT in each position\n\n// after SQRT advances, you can have atmost SQRT strings with big size, so try all of them\n\n// you can use hashing or a trie to advance\n\nll pot(ll b, ll e , ll m) {\n    ll res = 1;\n    while (e > 0) {\n        if (e&1) res = res * b % m;\n        e >>= 1;\n        b = b * b % m;\n    }\n    return res;\n}\n\nstruct Hash\n{\n\tint p = 997, m[2], in[2];\n\tvector<int> h[2], inv[2];\n\tHash(string s)\n\t{\n\t\tm[0] = 998244353, m[1] = 1000000009;\n\t\tfor(int i = 0; i < 2; i++)\n\t\t{\n\t\t\tin[i] = pot(p, m[i]-2, m[i]);\n\t\t\th[i].resize(s.size() + 1);\n\t\t\tinv[i].resize(s.size() + 1);\n\t\t\tll acu = 1;\n\t\t\th[i][0] = 0, inv[i][0] = 1;\n\t\t\tfor(int j = 0; j < s.size(); j++)\n\t\t\t{\n\t\t\t\th[i][j + 1] = (h[i][j] + acu * s[j]) % m[i];\n\t\t\t\tinv[i][j + 1] = (1ll * inv[i][j] * in[i]) % m[i];\n\t\t\t\tacu = (acu * p) % m[i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Return the hash of the the substring of 's' from index 'b' to 'e' inclusive.\n\t// Note that ABCABC, the hash of 0 to 2 is the same as 3 to 5. \n\tll get(int b, int e)\n\t{\n                e++; // Important to make this inclusive\n\t\tll ha[2];\n\t\tfor(int i = 0; i < 2; i++)\n\t\t\tha[i] = ((((h[i][e] - h[i][b]) * (ll)inv[i][b]) % m[i]) + m[i]) % m[i];\n\t\treturn((ha[0] << 32) | ha[1]) ;\n\t}\n};\n\n\nstruct custom_hash {\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        x ^= FIXED_RANDOM;\n        return x ^ (x >> 16);\n    }\n};\n\n\nconst ll MX = (ll)1e14;\n\n\nclass Solution {\npublic:\n\n    const int SQ = 320;\n\n    vector<tuple<ll,ll,ll>> bigStrings; // hash and sz \n    unordered_map<ll,ll,custom_hash> minCost; // to advance a hashing\n\n\n    struct Trie {\n        map<char,Trie*> nxt;\n        ll costo = MX;\n\n        void add(string &s, ll cst,ll pos) {\n            if (pos == s.size()) {\n                costo = min(costo,cst);\n                return;\n            } \n            char c = s[pos];\n            if (!nxt.count(c)) {\n                nxt[c] = new Trie();\n            }\n\n            nxt[c]->add(s,cst,pos+1);\n        }\n\n        Trie* find(char c) {\n            if (nxt.count(c)) return nxt[c];\n            return nullptr;\n        }\n    };\n\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        Trie minor;\n\n        for (int i =0;i<words.size();i++) {\n            string &w = words[i];\n            if (w.size() >= SQ) {\n                ll h = Hash(w).get(0,w.size()-1);\n                bigStrings.pb({h,w.size(),costs[i]});\n            } else {\n                minor.add(words[i],costs[i],0);\n            }\n        }\n\n        ll n = target.size();\n        Hash h(target);\n        vl dp(n+1,MX); // -1 no answer\n        dp[0] = 0;\n\n        for (int i = 0;i < n;i++) {\n            if (dp[i] == MX) continue;\n\n            // use small strings\n            Trie* actual = &minor;\n\n            for (int j=i;j<min((ll)n,(ll)i+SQ);j++) {\n                actual = actual->find(target[j]);\n                if (actual == nullptr) {\n                    break;\n                }\n                dp[j+1] = min(dp[j+1],dp[i]+actual->costo);\n            }\n\n            for (auto &b : bigStrings) {\n                ll hb, szb, cst;\n                tie(hb,szb,cst) = b;\n                ll start = i;\n                ll end = i+szb-1;\n                if (end < n && h.get(start,end) == hb) {\n                    dp[end+1] = min(dp[end+1],dp[i]+cst);\n                }\n            }\n        }\n        if (dp[n] == MX) dp[n] = -1;\n        return dp[n];\n    }\n};",
    "submit_ts": "1720324505",
    "subm_id": "1312401171"
}