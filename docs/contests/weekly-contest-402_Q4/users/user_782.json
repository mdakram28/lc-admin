{
    "username": "jaysujae",
    "submission": "class SegmentTree {\nprivate:\n    vector<int> tree;\n    vector<int> nums;\n    int n;\n\n    int build(int start, int end, int node) {\n        if (start == end) {\n            if (start > 0 && start < n - 1 && nums[start] > nums[start - 1] && nums[start] > nums[start + 1]) {\n                tree[node] = 1;\n            } else {\n                tree[node] = 0;\n            }\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        tree[node] = build(start, mid, 2 * node + 1) + build(mid + 1, end, 2 * node + 2);\n        return tree[node];\n    }\n\n    int query(int start, int end, int l, int r, int node) {\n        if (r < start || end < l) {\n            return 0;\n        }\n        if (l <= start && end <= r) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        return query(start, mid, l, r, 2 * node + 1) + query(mid + 1, end, l, r, 2 * node + 2);\n    }\n\n    void update(int start, int end, int idx, int node) {\n        if (start == end) {\n            if (start > 0 && start < n - 1 && nums[start] > nums[start - 1] && nums[start] > nums[start + 1]) {\n                tree[node] = 1;\n            } else {\n                tree[node] = 0;\n            }\n            return;\n        }\n        int mid = (start + end) / 2;\n        if (idx <= mid) {\n            update(start, mid, idx, 2 * node + 1);\n        } else {\n            update(mid + 1, end, idx, 2 * node + 2);\n        }\n        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n    }\n\npublic:\n    SegmentTree(vector<int>& nums) : nums(nums) {\n        n = nums.size();\n        tree.resize(4 * n, 0);\n        build(0, n - 1, 0);\n    }\n\n    int query(int l, int r) {\n        if (l >= r - 1) return 0; // No peaks possible if subarray is of size < 3\n        return query(0, n - 1, l + 1, r - 1, 0); // Query inside the bounds\n    }\n\n    void update(int idx, int val) {\n        nums[idx] = val;\n        // Update affected range\n        for (int i = max(1, idx - 1); i <= min(n - 2, idx + 1); ++i) {\n            update(0, n - 1, i, 0);\n        }\n    }\n};\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        SegmentTree segTree(nums);\n        vector<int> result;\n        for (const auto& query : queries) {\n            if (query[0] == 1) {\n                int l = query[1], r = query[2];\n                result.push_back(segTree.query(l, r));\n            } else if (query[0] == 2) {\n                int index = query[1], value = query[2];\n                segTree.update(index, value);\n            }\n        }\n        return result;\n    }\n};",
    "submit_ts": 1718506970.0
}