{
    "username": "louisfghbvc",
    "submission": "class Solution {\npublic:\n    int countOfPairs(vector<int>& nums) {\n        // goal: find out the number of pairs such that\n        // arr1 is increase, arr2 is decreasing\n        \n        // idea:\n        // dp\n        \n        // dfs(i, x): starting from index i, the last number of arr1 is x, arr2 is nums[i]-x;\n        // TC: O(n*x*x)\n        \n        // how to improve?\n        // dp[i][last] = dp[i+1][x], if x >= last && nums[i] - x <= nums[i-1] - last, x - last >= 0, nums[i] - nums[i-1] <= x - last, x - last >= max(0, nums[i] - nums[i-1])\n        \n        // dp[i][x] = sum of (dp[i-1][y]), y = 0 ~ x-(nums[i]-nums[i-1])\n        // x - (nums[i]-nums[i-1]) >= last\n        \n        // if (x >= last && nums[i] - x <= nums[i-1] - last)\n        // last <= x\n        // last <= x + nums[i-1] - nums[i]\n        // \n        \n        \n        // make transition to O(1)\n        \n        int n = nums.size();\n        int mod = 1e9+7;\n        \n        int MX = 2e3+5;\n        \n        vector dp(n, vector(MX, 0));\n        for (int x = 0; x <= nums[0]; ++x)\n            dp[0][x] = 1;\n        \n        for (int i = 1; i < n; ++i) {\n            vector<long> pre(MX);\n            pre[0] = dp[i-1][0];\n            for (int x = 1; x < MX; ++x)\n                pre[x] = (dp[i-1][x] + pre[x-1]) % mod;\n            \n            for (int x = 0; x <= nums[i]; ++x) {\n                int bound = x + min(nums[i-1] - nums[i], 0);\n                if (bound >= 0)\n                    dp[i][x] = pre[bound]; \n            }\n        }\n        \n        long res = 0;\n        for (int x = 0; x < MX; ++x)\n            res = (res + dp[n-1][x]) % mod;\n        return res;\n    }\n};",
    "submit_ts": "1723345283",
    "subm_id": "1351552476"
}