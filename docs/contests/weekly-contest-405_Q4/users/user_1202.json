{
    "username": "Ostosis",
    "submission": "class Solution {\npublic:\n\nstruct TrieNode {\n    bool isWord;\n    unordered_map<char, TrieNode*> children;\n    int val = INT_MAX;\n\n    TrieNode() {\n        isWord = false;\n    }\n\n    TrieNode* add(char c) {\n        auto val = children.find(c);\n\n        if (val == children.end()) {\n            TrieNode* child = new TrieNode;\n            children[c] = child;\n            return child;\n        }\n\n        return (*val).second;\n    }\n\n    TrieNode* next(char c) {\n        return children[c];\n    }\n};\n\nint minimumCost(string target, vector<string>& words, vector<int>& costs) {\n    TrieNode* trie = new TrieNode();\n    int targetLen = target.size();\n\n    for (int i = 0; i < words.size(); i++) {\n        auto& word = words[i];\n        auto& cost = costs[i];\n        TrieNode* curr = trie;\n\n        for (auto c : word) {\n            auto iter = curr->children.find(c);\n\n            if (iter == curr->children.end()) {\n                curr = curr->add(c);\n            }\n            else {\n                curr = iter->second;\n            }\n        }\n\n        curr->isWord = true;\n        curr->val = min(curr->val, cost);\n    }\n\n    vector<pair<int, TrieNode*>> prevNodes = { {0, trie} }; // cost, node\n    vector<pair<int, TrieNode*>> nextNodes; // cost, node\n    int minCost = -1;\n\n    for (int i = 0; i < targetLen; i++) {\n        char c = target[i];\n        nextNodes.clear();\n        minCost = -1;\n\n        for (int j = 0; j < prevNodes.size(); j++) {\n            auto& node = prevNodes[j];\n            int prevCost = node.first;\n            auto t = node.second;\n            auto iter = t->children.find(c);\n\n            \n            if (iter != t->children.end()) {\n                // found char\n                TrieNode* newNode = iter->second;\n                nextNodes.push_back({prevCost, newNode });\n\n                if (newNode->isWord) {\n                    int newCost = prevCost + newNode->val;\n                    minCost = minCost == -1 ? newCost : min(minCost, newCost);\n                }\n            }\n        }\n\n        if (minCost > -1) {\n            nextNodes.push_back({ minCost, trie });\n        }\n\n        if (nextNodes.empty()) {\n            break;\n        }\n\n        std::swap(prevNodes, nextNodes);\n    }\n\n    return minCost;\n}\n};",
    "submit_ts": "1720323683",
    "subm_id": "1312381509"
}