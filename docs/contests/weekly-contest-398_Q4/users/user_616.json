{
    "username": "MiniDanny",
    "submission": "class Solution {\npublic:\n    map<pair<long long, int>, int> yes, no;\n    int dfs(long long stair, int jump, bool back, int k)\n    {\n        if(stair > k+1) return 0;\n        if(back && yes.find({stair, jump}) != yes.end()) return yes[{stair, jump}];\n        else if(no.find({stair, jump}) != no.end()) return no[{stair, jump}];\n        \n        int ans = (stair == k);\n        if(back && stair != 0)\n        {\n            ans += dfs(stair-1, jump, false, k);\n        }\n        ans += dfs(stair+pow(2, jump), jump+1, true, k);\n        \n        if(back) return yes[{stair, jump}] = ans;\n        else return no[{stair, jump}] = ans;\n    }\n    \n    int bfs(int k)\n    {\n        queue<tuple<long long, int, bool>> q;\n        q.push({1, 0, true});\n        int ans = 0;\n        while(!q.empty())\n        {\n            auto [stair, jump, back] = q.front();\n            q.pop();\n            if(stair == k) ans++;\n            \n            if(stair > 0 && back)\n            {\n                q.push({stair-1, jump, false});\n            }\n            if(stair + pow(2, jump) < k+2)\n            {\n                q.push({stair+pow(2,jump), jump+1, true});\n            }\n        }\n        return ans;\n    }\n    int waysToReachStair(int k) {\n        return dfs(1, 0, true, k);\n        //return bfs(k);\n    }\n};",
    "submit_ts": 1716089402.0
}