{
    "username": "Param129",
    "submission": "/**\n * @param {number[][]} popopo\n * @param {number[][]} mkmkmkm\n * @return {number}\n */\nvar maxHeightOfTriangle = function(rose, tulip) {\n    function helper(rose, tulip) {\n        let height = 0;\n        let i = 1;\n\n        do {\n            if (i % 2 === 1) {\n                if (rose >= i) {\n                    rose -= i;\n                } else {\n                    break;\n                }\n            } else {\n                if (tulip >= i) {\n                    tulip -= i;\n                } else {\n                    break;\n                }\n            }\n            height++;\n            i++;\n        } while (true);\n\n        return height;\n    }\n\n    return Math.max(helper(rose, tulip), helper(tulip, rose));\n};\n\nvar minimumDiameterAfterMerge = function(popopo, mkmkmkm) {\n    \n    function bfs(ewewewe, start) {\n        let queue = [start];\n        let distances = new Map();\n        distances.set(start, 0);\n        let uiuoiuh = start;\n\n        while (queue.length > 0) {\n            let node = queue.shift();\n            for (let neighbor of ewewewe.get(node)) {\n                if (!distances.has(neighbor)) {\n                    distances.set(neighbor, distances.get(node) + 1);\n                    queue.push(neighbor);\n                    uiuoiuh = neighbor;\n                }\n            }\n        }\n\n        return [uiuoiuh, distances.get(uiuoiuh)];\n    }\n\n    function dfs(ewewewe, node, parent) {\n        let maxDepth = 0;\n        for (let neighbor of ewewewe.get(node)) {\n            if (neighbor !== parent) {\n                maxDepth = Math.max(maxDepth, dfs(ewewewe, neighbor, node) + 1);\n            }\n        }\n        return maxDepth;\n    }\n\n    function plokij(edges, n) {\n        if (n === 1) {\n            return 0;\n        }\n\n        let ewewewe = new Map();\n        for (let [rose, tulip] of edges) {\n            if (!ewewewe.has(rose)) ewewewe.set(rose, []);\n            if (!ewewewe.has(tulip)) ewewewe.set(tulip, []);\n            ewewewe.get(rose).push(tulip);\n            ewewewe.get(tulip).push(rose);\n        }\n\n        // Start BFS from an arbitrary node to find one endpoint of the diameter\n        let [uiuoiuh] = bfs(ewewewe, 0);\n\n        // Use DFS from the farthest node found to determine the diameter\n        let diameter = dfs(ewewewe, uiuoiuh, -1);\n        return diameter;\n    }\n\n    function minDiameterAfterMerge(popopo, mkmkmkm, n, m) {\n        let awsxdcfv = plokij(popopo, n);\n        let xdcfvgb = plokij(mkmkmkm, m);\n\n        // Calculate the minimum possible diameter after merging the trees\n        return Math.max(awsxdcfv, xdcfvgb, Math.floor((awsxdcfv + 1) / 2) + Math.floor((xdcfvgb + 1) / 2) + 1);\n    }\n\n    let n = popopo.length + 1;\n    let m = mkmkmkm.length + 1;\n\n    return minDiameterAfterMerge(popopo, mkmkmkm, n, m);\n};\n\n\n",
    "submit_ts": "1719716807",
    "subm_id": "1304374559"
}