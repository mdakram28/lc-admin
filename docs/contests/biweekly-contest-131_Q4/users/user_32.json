{
    "username": "liouzhou_101",
    "submission": "#ifndef BITS_H_\n#define BITS_H_\n\n#include <cstdint>\n\n#ifdef __GNUC__\n\n#define bit_popcount __builtin_popcount\n#define bit_ctz __builtin_ctz\n#define bit_clz __builtin_clz\n#define bit_popcountll __builtin_popcountll\n#define bit_ctzll __builtin_ctzll\n#define bit_clzll __builtin_clzll\n\n#else\n\nstatic constexpr inline int32_t bit_popcount(uint32_t x)\n{\n\tconstexpr uint32_t m1 = 0x55555555;\n\tconstexpr uint32_t m2 = 0x33333333;\n\tconstexpr uint32_t m4 = 0x0f0f0f0f;\n\tconstexpr uint32_t h01 = 0x01010101;\n\tx -= (x >> 1) & m1;\n\tx = (x & m2) + ((x >> 2) & m2);\n\tx = (x + (x >> 4)) & m4;\n\treturn (x * h01) >> 24;\n}\n\nstatic constexpr inline int32_t bit_ctz(uint32_t x)\n{\n\treturn bit_popcount((x & -int32_t(x)) - 1);\n}\n\nstatic constexpr inline int32_t bit_clz(uint32_t x)\n{\n\tint n = 0;\n\tif (!(x & 0xffff0000)) n += 16, x <<= 16;\n\tif (!(x & 0xff000000)) n += 8, x <<= 8;\n\tif (!(x & 0xf0000000)) n += 4, x <<= 4;\n\tif (!(x & 0xc0000000)) n += 2, x <<= 2;\n\tif (!(x & 0x80000000)) n += 1;\n\treturn n;\n}\n\nstatic constexpr inline int32_t bit_popcountll(uint64_t x)\n{\n\tconstexpr uint64_t m1 = 0x5555555555555555;\n\tconstexpr uint64_t m2 = 0x3333333333333333;\n\tconstexpr uint64_t m4 = 0x0f0f0f0f0f0f0f0f;\n\tconstexpr uint64_t h01 = 0x0101010101010101;\n\tx -= (x >> 1) & m1;\n\tx = (x & m2) + ((x >> 2) & m2);\n\tx = (x + (x >> 4)) & m4;\n\treturn (x * h01) >> 56;\n}\n\nstatic constexpr inline int32_t bit_ctzll(uint64_t x)\n{\n\treturn bit_popcountll((x & -int64_t(x)) - 1);\n}\n\nstatic constexpr inline int32_t bit_clzll(uint64_t x)\n{\n\tint n = 0;\n\tif (!(x & 0xffffffff00000000)) n += 32, x <<= 32;\n\tif (!(x & 0xffff000000000000)) n += 16, x <<= 16;\n\tif (!(x & 0xff00000000000000)) n += 8, x <<= 8;\n\tif (!(x & 0xf000000000000000)) n += 4, x <<= 4;\n\tif (!(x & 0xc000000000000000)) n += 2, x <<= 2;\n\tif (!(x & 0x8000000000000000)) n += 1;\n\treturn n;\n}\n\n#endif\n\nstatic constexpr inline int32_t bit_lg(uint32_t x)\n{\n\treturn 31 - bit_clz(x);\n}\n\nstatic constexpr inline int32_t bit_lgll(uint64_t x)\n{\n\treturn 63 - bit_clzll(x);\n}\n\n#endif\n\n#ifndef SEGMENTTREE_H_\n#define SEGMENTTREE_H_\n\n#include <cassert>\n#include <algorithm>\n#include <vector>\n\nnamespace data_structure\n{\n\t// 0-indexed segment tree.\n\t// Every query range has the form [l, r).\n\ttemplate<typename ValueType, typename ValueMerge,\n\t\ttypename TagType, typename TagMerge, typename TagSpread>\n\tclass SegmentTree\n\t{\n\tprivate:\n\t\tint n, lg, size;\n\t\tconst ValueType value_init;\n\t\tconst ValueMerge& value_merge;\n\t\tconst TagType tag_init;\n\t\tconst TagMerge& tag_merge;\n\t\tconst TagSpread& tag_spread;\n\t\tstd::vector<ValueType> value;\n\t\tstd::vector<TagType> tag;\n\t\tvoid Update(int k)\n\t\t{\n\t\t\tvalue[k] = value_merge(value[k << 1], value[k << 1 | 1]);\n\t\t}\n\t\tvoid AddTag(int k, const TagType& cur_tag)\n\t\t{\n\t\t\ttag_spread(cur_tag, value[k]);\n\t\t\tif (k < size) tag_merge(cur_tag, tag[k]);\n\t\t}\n\t\tvoid PushTag(int k)\n\t\t{\n\t\t\tAddTag(k << 1, tag[k]);\n\t\t\tAddTag(k << 1 | 1, std::move(tag[k]));\n\t\t\ttag[k] = tag_init;\n\t\t}\n\tpublic:\n\t\ttemplate<typename InputIt>\n\t\texplicit SegmentTree(InputIt first, InputIt last, const ValueType& value_init, const ValueMerge& value_merge,\n\t\t\tconst TagType& tag_init, const TagMerge& tag_merge, const TagSpread& tag_spread) : \n\t\t\tn(last - first), value_init(value_init), value_merge(value_merge), \n\t\t\ttag_init(tag_init), tag_merge(tag_merge), tag_spread(tag_spread)\n\t\t{\n\t\t\tassert(n >= 1);\n\t\t\tlg = bit_lg(2 * n - 1);\n\t\t\tsize = 1 << lg;\n\t\t\tvalue = std::vector<ValueType>(size << 1, value_init);\n\t\t\ttag = std::vector<TagType>(size, tag_init);\n\t\t\tstd::copy(first, last, value.begin() + size);\n\t\t\tfor (int k = size - 1; k >= 1; --k) Update(k);\n\t\t}\n\t\texplicit SegmentTree(const std::vector<ValueType>& data, const ValueType& value_init, const ValueMerge& value_merge,\n\t\t\tconst TagType& tag_init, const TagMerge& tag_merge, const TagSpread& tag_spread) :\n\t\t\tSegmentTree(data.begin(), data.end(), value_init, value_merge, tag_init, tag_merge, tag_spread)\n\t\t{ }\n\t\texplicit SegmentTree(int n, const ValueType& value_init, const ValueMerge& value_merge,\n\t\t\tconst TagType& tag_init, const TagMerge& tag_merge, const TagSpread& tag_spread) :\n\t\t\tSegmentTree(std::vector<ValueType>(n, value_init), value_init, value_merge, tag_init, tag_merge, tag_spread)\n\t\t{ }\n\t\tValueType Query(int left, int right)\n\t\t{\n\t\t\tassert(0 <= left && left <= right && right <= n);\n\t\t\tif (left == right) return value_init;\n\t\t\tleft += size, right += size;\n\t\t\tfor (int k = lg; k >= 1; --k)\n\t\t\t{\n\t\t\t\tif ((left >> k << k) != left) PushTag(left >> k);\n\t\t\t\tif ((right >> k << k) != right) PushTag((right - 1) >> k);\n\t\t\t}\n\t\t\tValueType left_res = value_init, right_res = value_init;\n\t\t\tfor (; left < right; left >>= 1, right >>= 1)\n\t\t\t{\n\t\t\t\tif (left & 1) left_res = value_merge(std::move(left_res), value[left++]);\n\t\t\t\tif (right & 1) right_res = value_merge(value[--right], std::move(right_res));\n\t\t\t}\n\t\t\treturn value_merge(std::move(left_res), std::move(right_res));\n\t\t}\n\t\tValueType Query(int pos)\n\t\t{\n\t\t\tassert(0 <= pos && pos < n);\n\t\t\tpos += size;\n\t\t\tfor (int k = lg; k >= 1; --k) PushTag(pos >> k);\n\t\t\treturn value[pos];\n\t\t}\n\t\tvoid ModifyTag(int left, int right, const TagType& add_tag)\n\t\t{\n\t\t\tassert(0 <= left && left <= right && right <= n);\n\t\t\tif (left == right) return;\n\t\t\tleft += size, right += size;\n\t\t\tfor (int k = lg; k >= 1; --k)\n\t\t\t{\n\t\t\t\tif ((left >> k << k) != left) PushTag(left >> k);\n\t\t\t\tif ((right >> k << k) != right) PushTag((right - 1) >> k);\n\t\t\t}\n\t\t\tfor (int l = left, r = right; l < r; l >>= 1, r >>= 1)\n\t\t\t{\n\t\t\t\tif (l & 1) AddTag(l++, add_tag);\n\t\t\t\tif (r & 1) AddTag(--r, add_tag);\n\t\t\t}\n\t\t\tfor (int k = 1; k <= lg; ++k)\n\t\t\t{\n\t\t\t\tif ((left >> k << k) != left) Update(left >> k);\n\t\t\t\tif ((right >> k << k) != right) Update((right - 1) >> k);\n\t\t\t}\n\t\t}\n\t\tvoid ModifyTag(int pos, const TagType& add_tag)\n\t\t{\n\t\t\tassert(0 <= pos && pos < n);\n\t\t\tpos += size;\n\t\t\tfor (int k = lg; k >= 1; --k) PushTag(pos >> k);\n\t\t\tAddTag(pos, add_tag);\n\t\t\tfor (int k = 1; k <= lg; ++k) Update(pos >> k);\n\t\t}\n\t\tvoid ModifyValue(int pos, const ValueType& new_value)\n\t\t{\n\t\t\tassert(0 <= pos && pos < n);\n\t\t\tpos += size;\n\t\t\tfor (int k = lg; k >= 1; --k) PushTag(pos >> k);\n\t\t\tvalue[pos] = new_value;\n\t\t\tfor (int k = 1; k <= lg; ++k) Update(pos >> k);\n\t\t}\n\t\t// Find the leftmost position \"right\" such that\n\t\t//   1. left < right <= n,\n\t\t//   2. check(value_merge(value[left], ..., value[right - 1])) = true.\n\t\t// If not found, right = -1.\n\t\ttemplate<typename Checker>\n\t\tint FindFirst(int left, const Checker& check)\n\t\t{\n\t\t\tassert(0 <= left && left <= n);\n\t\t\tif (left == n) return -1;\n\t\t\tleft += size;\n\t\t\tfor (int k = lg; k >= 1; --k) PushTag(left >> k);\n\t\t\tValueType cur = value_init;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tleft >>= bit_ctz(left);\n\t\t\t\tif (check(value_merge(cur, value[left])))\n\t\t\t\t{\n\t\t\t\t\twhile (left < size)\n\t\t\t\t\t{\n\t\t\t\t\t\tPushTag(left);\n\t\t\t\t\t\tleft <<= 1;\n\t\t\t\t\t\tif (ValueType tmp = value_merge(cur, value[left]); !check(tmp))\n\t\t\t\t\t\t\tcur = tmp, left += 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn left - size + 1;\n\t\t\t\t}\n\t\t\t\tcur = value_merge(std::move(cur), value[left++]);\n\t\t\t} while ((left & -left) != left);\n\t\t\treturn -1;\n\t\t}\n\t\t// Find the rightmost position \"left\" such that\n\t\t//   1. 0 <= left < right,\n\t\t//   2. check(value_merge(value[left], ..., value[right - 1])) = true.\n\t\t// If not found, left = -1.\n\t\ttemplate<typename Checker>\n\t\tint FindLast(int right, const Checker& check)\n\t\t{\n\t\t\tassert(0 <= right && right <= n);\n\t\t\tif (right == 0) return -1;\n\t\t\tright += size;\n\t\t\tfor (int k = lg; k >= 1; --k) PushTag((right - 1) >> k);\n\t\t\tValueType cur = value_init;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tright >>= bit_ctz(right);\n\t\t\t\tif (right) right -= 1;\n\t\t\t\tif (check(value_merge(value[right], cur)))\n\t\t\t\t{\n\t\t\t\t\twhile (right < size)\n\t\t\t\t\t{\n\t\t\t\t\t\tPushTag(right);\n\t\t\t\t\t\t(right <<= 1) += 1;\n\t\t\t\t\t\tif (ValueType tmp = value_merge(value[right], cur); !check(tmp))\n\t\t\t\t\t\t\tcur = tmp, right -= 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn right - size;\n\t\t\t\t}\n\t\t\t\tcur = value_merge(value[right], std::move(cur));\n\t\t\t} while ((right & -right) != right);\n\t\t\treturn -1;\n\t\t}\n\t};\n}\n\n#endif\n\n\nnamespace algorithm {}\nnamespace data_structure {}\n\nusing namespace algorithm;\nusing namespace data_structure;\n\nclass Solution {\npublic:\n\tvector<bool> getResults(vector<vector<int>>& queries) {\n\t\tstruct ValueType\n\t\t{\n\t\t\tint lc, mc, rc, len;\n\t\t};\n\t\tValueType value_init = { 0, 0, 0, 0 };\n\t\tauto value_merge = [](const ValueType& a, const ValueType& b) -> ValueType\n\t\t{\n\t\t\tValueType c;\n\t\t\tc.lc = a.lc;\n\t\t\tif (a.lc == a.len) c.lc = a.len + b.lc;\n\t\t\tc.rc = b.rc;\n\t\t\tif (b.rc == b.len) c.rc = b.len + a.rc;\n\t\t\tc.mc = max({ a.mc, b.mc, a.rc + b.lc });\n\t\t\tc.len = a.len + b.len;\n\t\t\treturn c;\n\t\t};\n\n\t\tstruct TagType\n\t\t{\n\n\t\t};\n\t\tTagType tag_init = { };\n\t\tauto tag_merge = [](const TagType& a, TagType& b) -> void\n\t\t{\n\t\t};\n\t\tauto tag_spread = [](const TagType& tag, ValueType& value) -> void\n\t\t{\n\t\t};\n\n\t\tint n = 10;\n\t\tfor (auto& e : queries)\n\t\t\tn = max(n, e[1]);\n\t\tn += 10;\n\n\t\tvector<ValueType> a(n);\n\t\tfor (auto& x : a)\n\t\t\tx = { 1,1,1,1 };\n\t\ta[0] = { 0,0,0,1 };\n\n\t\tSegmentTree<ValueType, decltype(value_merge), TagType, decltype(tag_merge), decltype(tag_spread)>\n\t\t\ttree(a.begin(), a.end(), value_init, value_merge, tag_init, tag_merge, tag_spread);\n\n\t\tvector<bool> res;\n\t\tfor (auto& e : queries)\n\t\t{\n\t\t\tif (e[0] == 1)\n\t\t\t{\n\t\t\t\tint x = e[1];\n\t\t\t\ttree.ModifyValue(x, ValueType{ 0, 0, 0, 1 });\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint x = e[1];\n\t\t\t\tauto tmp = tree.Query(0, x);\n\t\t\t\tres.push_back(tmp.mc >= e[2] - 1);\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n};",
    "submit_ts": "1716649524",
    "subm_id": "534766939"
}