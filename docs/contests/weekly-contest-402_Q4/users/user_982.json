{
    "username": "noobcoderr",
    "submission": "class Solution {\npublic:\n    vector<int> A, ST;\n\n    void build(int node, int L, int R)\n    {\n\n        // Leaf node where L == R\n        if (L == R) {\n            ST[node] = A[L];\n        }\n        else {\n\n            // Find the middle element to\n            // split the array into two halves\n            int mid = (L + R) / 2;\n\n            // Recursively travel the\n            // left half\n            build(2 * node, L, mid);\n\n            // Recursively travel the\n            // right half\n            build(2 * node + 1, mid + 1, R);\n\n            // Storing the sum of both the\n            // children into the parent\n            ST[node] = ST[2 * node] + ST[2 * node + 1];\n        }\n    }\n\n    void update(int node, int L, int R, int idx, int val)\n    {\n\n        // Find the lead node and\n        // update its value\n        if (L == R) {\n            A[idx] += val;\n            ST[node] += val;\n        }\n        else {\n\n            // Find the mid\n            int mid = (L + R) / 2;\n\n            // If node value idx is at the\n            // left part then update\n            // the left part\n            if (L <= idx and idx <= mid)\n                update(2 * node, L, mid, idx, val);\n            else\n                update(2 * node + 1, mid + 1, R, idx, val);\n\n            // Store the information in parents\n            ST[node] = ST[2 * node] + ST[2 * node + 1];\n        }\n    }\n\n    int query(int node, int tl, int tr, int l, int r)\n    {\n\n        // If it lies out of range then\n        // return 0\n        if (r < tl or tr < l)\n            return 0;\n\n        // If the node contains the range then\n        // return the node value\n        if (l <= tl and tr <= r)\n            return ST[node];\n        int tm = (tl + tr) / 2;\n\n        // Recursively traverse left and right\n        // and find the node\n        return query(2 * node, tl, tm, l, r)\n               + query(2 * node + 1, tm + 1, tr, l, r);\n    }\n    \n    bool inbound(int i, int n){\n        return 1 <= i && i <= n-2;\n    }\n    \n    void print(vector<int>& v){\n        for(int i: v){\n            cout<<i<<\" \";\n        }\n        cout<<endl;\n    }\n \n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        ST.resize(4 * n);\n        A.resize(n);\n        for(int i=1;i<n-1;++i){\n            A[i] = bool(nums[i] > nums[i-1] && nums[i] > nums[i+1]);\n        }\n        // Build a segment tree\n        build(1, 0, n - 1);\n        vector<int> res;\n        for(vector<int>& q: queries){\n            if(q[0]==1){\n                res.push_back(query(1, 0, n-1, q[1]+1, q[2]-1));\n            }\n            else{\n                nums[q[1]] = q[2];\n                int i=q[1];\n                if(inbound(i-1, n)){\n                    int diff = bool(nums[i-1] > nums[i-2] && nums[i-1] > nums[i]) - A[i-1];\n                    update(1, 0, n-1, i-1, diff);\n                }\n                if(inbound(i, n)){\n                    int diff = bool(nums[i] > nums[i-1] && nums[i] > nums[i+1]) - A[i];\n                    update(1, 0, n-1, i, diff);\n\n                }\n                if(inbound(i+1, n)){\n                    int diff = bool(nums[i+1] > nums[i] && nums[i+1] > nums[i+2]) - A[i+1];\n                    update(1, 0, n-1, i+1, diff);\n                    \n                }\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": "1718508327",
    "subm_id": "1289678123"
}