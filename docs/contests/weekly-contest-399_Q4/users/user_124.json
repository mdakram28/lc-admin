{
    "username": "ashwanthkannan",
    "submission": "#define ll long long\n\n\nstruct node\n{\n\tll val00;\n\tll val01;\n\tll val10;\n\tll val11;\n\tll maxi;\n};\n\nstruct segtree\n{\n\tint size;\n\tvector<struct node> values;\n\t// initial here\n\tstruct node empty_node = {0,0,0,0,0};\n\n\tvoid init(int n)\n\t{\n\t\tsize = 1;\n\t\twhile(size < n) size*=2;\n\t\tvalues.assign(2*size , empty_node);\n\t}\n\n\tstruct node merge(struct node p1 , struct node p2)\n\t{\n\t\tstruct node merge_node = {0,0,0,0,0};\n        \n\t\t// operation here\n\n\t\tmerge_node.val00 = max(merge_node.val00 , p1.val00 + p2.val00);\n\t\tmerge_node.val01 = max(merge_node.val01 , p1.val00 + p2.val01);\n\t\tmerge_node.val00 = max(merge_node.val00 , p1.val00 + p2.val10);\n\t\tmerge_node.val01 = max(merge_node.val01 , p1.val00 + p2.val11);\n\n\t\tmerge_node.val00 = max(merge_node.val00 , p1.val01 + p2.val00);\n\t\tmerge_node.val01 = max(merge_node.val01 , p1.val01 + p2.val01);\n\n\n\t\tmerge_node.val10 = max(merge_node.val10 , p1.val10 + p2.val00);\n\t\tmerge_node.val11 = max(merge_node.val11 , p1.val10 + p2.val01);\n\t\tmerge_node.val10 = max(merge_node.val10 , p1.val10 + p2.val10);\n\t\tmerge_node.val11 = max(merge_node.val11 , p1.val10 + p2.val11);\n\n\t\tmerge_node.val10 = max(merge_node.val10 , p1.val11 + p2.val00);\n\t\tmerge_node.val11 = max(merge_node.val11 , p1.val11 + p2.val01);\n\n\t\tmerge_node.maxi = max(merge_node.maxi , merge_node.val00);\n\t\tmerge_node.maxi = max(merge_node.maxi , merge_node.val01);\n\t\tmerge_node.maxi = max(merge_node.maxi , merge_node.val10);\n\t\tmerge_node.maxi = max(merge_node.maxi , merge_node.val11);\n\n\t\treturn merge_node;\n\t}\n\n\tvoid set(int i , ll v , int x , int  lx , int rx)\n\t{\n\t\tif(rx  - lx == 1)\n\t\t{\n\t\t\tvalues[x].val11 = max(0ll , v);\n\t\t\tvalues[x].val10 = 0;\n\t\t\tvalues[x].val01 = 0;\n\t\t\tvalues[x].val00 = 0;\n            values[x].maxi = max(0ll , v);\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (lx + rx)/2;\n\t\tif( i < m)\n\t\t{\n\t\t\tset(i , v , 2*x + 1 , lx , m);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tset(i , v , 2*x + 2 , m , rx);\n\t\t}\n\n\t\tvalues[x] = merge(values[2*x+1] , values[2*x+2]);\n\t}\n\n\tvoid set(int i , ll v)\n\t{\n\t\tset(i , v, 0 , 0 , size);\n\t}\n\n\tstruct node range_calc(int l , int r , int x , int lx , int rx)\n\t{\n\t\tif(lx >= r || l >= rx) return empty_node;\n\t\tif(l <= lx && r >= rx) return values[x];\n\t\tint m = (lx + rx)/2;\n\n\t\tstruct node s1 = range_calc(l , r , 2*x+1 , lx , m);\n\t\tstruct node s2 = range_calc(l , r , 2*x+2 , m , rx);\n\t\t\n\t\treturn merge(s1 , s2);\n\t}\n\tll range_calc(int l , int r)\n\t{\n\t\treturn range_calc(l , r , 0 , 0 , size).maxi;\n\t}\n\n\n};\n\n\n\n\nclass Solution {\npublic:\n        \n    \n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n    \n        ll fans = 0;\n        ll mod = 1e9 + 7;\n        ll n = nums.size();\n        segtree ss;\n        ss.init(n);\n        \n        for(int i = 0 ; i  < n ; i ++) ss.set(i , nums[i]);\n        \n        \n            \n        for(auto kk : queries)\n        {\n            int x = kk[1];\n            int i = kk[0];\n            \n            ss.set(i , x);\n            fans+= ss.range_calc(0 , n);\n            fans%= mod;\n        }\n        return fans;\n    }\n};",
    "submit_ts": "1716694876",
    "subm_id": "1268127298"
}