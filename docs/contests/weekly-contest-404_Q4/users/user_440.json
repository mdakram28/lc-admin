{
    "username": "LeetCoding_Pro",
    "submission": "class Solution\n{\n    public int minimumDiameterAfterMerge(int[][] ess1, int[][] ess2)\n    {\n        int n = ess1.length + 1;\n        int m = ess2.length + 1;\n        for (int[] es2 : ess2)\n        {\n            es2[0] += n;\n            es2[1] += n;\n        }\n        List<Integer> fromEss1 = minimumDiameterAfterMergeHelper(ess1, 0);\n        List<Integer> fromEss2 = minimumDiameterAfterMergeHelper(ess2, n);\n        int[][] ess3 = new int[n + m - 1][2];\n        for (int i = 0; i <= n - 2; i++)\n        {\n            ess3[i] = ess1[i];\n        }\n        for (int i = 0; i <= m - 2; i++)\n        {\n            ess3[n - 1 + i] = ess2[i];\n        }\n        ess3[n + m - 2][0] = fromEss1.get(fromEss1.size() / 2);\n        ess3[n + m - 2][1] = fromEss2.get(fromEss2.size() / 2);\n        List<Integer> fromEss3 = minimumDiameterAfterMergeHelper(ess3, 0);\n        return fromEss3.size() - 1;\n    }\n    \n    private List<Integer> minimumDiameterAfterMergeHelper(int[][] ess, int root)\n    {\n        if (ess.length == 0)\n        {\n            return List.of(root);\n        }\n        Map<Integer, List<Integer>> neisMap = new HashMap<>();\n        int[] max = new int[]{-1, -1};\n        Map<Integer, List<List<Integer>>> memo = new HashMap<>();\n        for (int[] es : ess)\n        {\n            int a = es[0];\n            int b = es[1];\n            neisMap.putIfAbsent(a, new ArrayList<>());\n            neisMap.putIfAbsent(b, new ArrayList<>());\n            neisMap.get(a).add(b);\n            neisMap.get(b).add(a);\n        }\n        minimumDiameterAfterMergeHelper2(root, neisMap, max, memo, -1);\n        int maxNode = max[0];\n        List<List<Integer>> lists = memo.get(maxNode);\n        List<Integer> res = new ArrayList<>();\n        if (lists.size() == 1)\n        {\n            res = minimumDiameterAfterMergeHelper3(maxNode, memo);\n        }\n        else\n        {\n            List<Integer> left = minimumDiameterAfterMergeHelper3(lists.get(0).get(0), memo);\n            List<Integer> right = minimumDiameterAfterMergeHelper3(lists.get(1).get(0), memo);\n            Collections.reverse(left);\n            left.add(maxNode);\n            left.addAll(right);\n            res = left;\n        }\n        return res;\n    }\n    \n    private int minimumDiameterAfterMergeHelper2(int curr, Map<Integer, List<Integer>> neisMap, int[] max, Map<Integer, List<List<Integer>>> memo, int par)\n    {\n        int maxLengFromChild = 0;\n        List<List<Integer>> memoVal = new ArrayList<>();\n        List<Integer> neis = neisMap.get(curr);\n        for (int nei : neis)\n        {\n            if (nei == par)\n            {\n                continue;\n            }\n            int lengFromChild = minimumDiameterAfterMergeHelper2(nei, neisMap, max, memo, curr);\n            maxLengFromChild = Math.max(maxLengFromChild, lengFromChild);\n            memoVal.add(List.of(nei, lengFromChild));\n        }\n        int maxLeng = 1;\n        if (memoVal.size() == 0)\n        {\n            memo.put(curr, memoVal);\n        }\n        else if (memoVal.size() == 1)\n        {\n            memo.put(curr, memoVal);\n            maxLeng += memoVal.get(0).get(1);\n        }\n        else if (memoVal.size() == 2)\n        {\n            Collections.sort(memoVal, (v1, v2) -> (v2.get(1) - v1.get(1)));\n            memo.put(curr, memoVal);\n            maxLeng += memoVal.get(0).get(1) + memoVal.get(1).get(1);\n        }\n        else\n        {\n            Collections.sort(memoVal, (v1, v2) -> (v2.get(1) - v1.get(1)));\n            memo.put(curr, List.of(memoVal.get(0), memoVal.get(1)));\n            maxLeng += memoVal.get(0).get(1) + memoVal.get(1).get(1);\n        }\n        if (maxLeng > max[1])\n        {\n            max[0] = curr;\n            max[1] = maxLeng;\n        }\n        return maxLengFromChild + 1;\n    }\n    \n    private List<Integer> minimumDiameterAfterMergeHelper3(int curr, Map<Integer, List<List<Integer>>> memo)\n    {\n        List<Integer> list = new ArrayList<>();\n        while (true)\n        {\n            list.add(curr);\n            List<List<Integer>> lists = memo.getOrDefault(curr, new ArrayList<>());\n            if (lists.size() == 0)\n            {\n                break;\n            }\n            else\n            {\n                curr = lists.get(0).get(0);\n            }\n        }\n        return list;\n    }\n}",
    "submit_ts": "1719719243",
    "subm_id": "1304437206"
}