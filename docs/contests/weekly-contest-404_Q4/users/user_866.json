{
    "username": "weiyanzhong",
    "submission": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int[] len1 = getMinLen(edges1);\n        int[] len2 = getMinLen(edges2);\n        return Math.max(len1[0] + len2[0] + 1, Math.max(len1[1], len2[1]));\n    }\n\n    private int[] getMinLen(int[][] edges) {\n        int n = edges.length;\n        int[] counts = new int[n + 1];\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int[] edge : edges) {\n            map.putIfAbsent(edge[0], new ArrayList<>());\n            map.putIfAbsent(edge[1], new ArrayList<>());\n            counts[edge[0]]++;\n            counts[edge[1]]++;\n            map.get(edge[0]).add(edge[1]);\n            map.get(edge[1]).add(edge[0]);\n        }\n        Deque<Integer> queue = new LinkedList<>();\n        Set<Integer> visited = new HashSet<>();\n        for (int i = 0; i <= n; i++) {\n            if (counts[i] == 1) {\n                queue.offer(i);\n                visited.add(i);\n            }\n        }\n        int len = 0;\n        while (queue.size() > 1) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int cur = queue.poll();\n                if (map.containsKey(cur)) {\n                    for (int next : map.get(cur)) {\n                        counts[next]--;\n                        if (counts[next] <= 1 && visited.add(next)) {\n                            queue.offer(next);\n                        }\n                    }\n                }\n            }\n            len++;\n        }\n        int innerLen = queue.isEmpty() ? len * 2 - 1 : len * 2;\n        return new int[]{len , innerLen};\n    }\n}",
    "submit_ts": 1719718717.0
}