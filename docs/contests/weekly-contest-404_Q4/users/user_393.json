{
    "username": "sidhu1454",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def bfs_farthest_node(graph, start):\n            queue = deque([start])\n            visited = {start}\n            distance = {start: 0}\n            farthest_node = start\n            max_distance = 0\n\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n                        distance[neighbor] = distance[node] + 1\n                        if distance[neighbor] > max_distance:\n                            max_distance = distance[neighbor]\n                            farthest_node = neighbor\n\n            return farthest_node, max_distance\n\n        def tree_diameter(graph):\n            start = 0\n            farthest_node, _ = bfs_farthest_node(graph, start)\n            _, diameter = bfs_farthest_node(graph, farthest_node)\n            return diameter\n        n = len(edges1) + 1\n        m = len(edges2) + 1\n\n        graph1 = [[] for _ in range(n)]\n        for u, v in edges1:\n            graph1[u].append(v)\n            graph1[v].append(u)\n\n        graph2 = [[] for _ in range(m)]\n        for u, v in edges2:\n            graph2[u].append(v)\n            graph2[v].append(u)\n\n        diameter1 = tree_diameter(graph1)\n        diameter2 = tree_diameter(graph2)\n\n        return max(diameter1, diameter2, (diameter1 + 1) // 2 + (diameter2 + 1) // 2 + 1)  \n        ",
    "submit_ts": 1719715661.0
}