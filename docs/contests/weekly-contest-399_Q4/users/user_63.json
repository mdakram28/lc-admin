{
    "username": "kaq",
    "submission": "constexpr int mod = 1e9 + 7;\n\nclass SegTree {\npublic:\n    SegTree(const vector<int>& nums) {\n        numsSize = nums.size();\n        arr.resize(4 * numsSize + 10, {LLONG_MIN, LLONG_MIN, LLONG_MIN, LLONG_MIN});\n        _init(1, 0, numsSize - 1, nums);\n    }\n    \n    long long query() {\n        return max({arr[1][0], arr[1][1], arr[1][2], arr[1][3]}) % mod;\n    }\n    \n    void update(int pos, int val) {\n        _update(1, 0, numsSize - 1, pos, val);\n    }\n    \nprivate:\n    // w/o left and right, left only, right only, both left and right\n    vector<array<long long, 4>> arr;\n    int numsSize;\n    \n    void _init(int stIndex, int stLeft, int stRight, const vector<int>& nums) {\n        if (stLeft == stRight) {\n            if (nums[stLeft] <= 0) {\n                arr[stIndex] = {0, 0, 0, 0};\n            } else {\n                arr[stIndex] = {0, 0, 0, nums[stLeft]};\n            }\n        } else {\n            _init(2 * stIndex, stLeft, (stLeft + stRight) / 2, nums);\n            _init(2 * stIndex + 1, (stLeft + stRight) / 2 + 1, stRight, nums);\n            arr[stIndex] = mergeSegments(arr[2 * stIndex], arr[2 * stIndex + 1]);\n        }\n    }\n    \n    void _update(int stIndex, int stLeft, int stRight, int pos, int val) {\n        if (stLeft == stRight) {\n            if (val <= 0) {\n                arr[stIndex] = {0, 0, 0, 0};\n            } else {\n                arr[stIndex] = {0, 0, 0, val};\n            }\n        } else {\n            if (pos <= (stLeft + stRight) / 2) {\n                _update(2 * stIndex, stLeft, (stLeft + stRight) / 2, pos, val);\n            } else {\n                _update(2 * stIndex + 1, (stLeft + stRight) / 2 + 1, stRight, pos, val);\n            }\n            arr[stIndex] = mergeSegments(arr[2 * stIndex], arr[2 * stIndex + 1]);\n        }\n    }\n    \n    array<long long, 4> mergeSegments(array<long long, 4> left, array<long long, 4> right) {\n        array<long long, 4> res;\n        res[0] = max({left[0] + right[0], left[0] + right[1], left[2] + right[0]});\n        res[1] = max({left[1] + right[0], left[1] + right[1], left[3] + right[0]});\n        res[2] = max({left[0] + right[2], left[0] + right[3], left[2] + right[2]});\n        res[3] = max({left[1] + right[3], left[3] + right[2], left[1] + right[2]});\n        return res;\n    }\n};\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        SegTree st(nums);\n        long long total = 0;\n        for (auto& query : queries) {\n            int pos = query[0];\n            int val = query[1];\n            st.update(pos, val);\n            total = (total + st.query()) % mod;\n        }\n        return total;\n    }\n};",
    "submit_ts": "1716693792",
    "subm_id": "1268097205"
}