{
    "username": "chaochaochao1",
    "submission": "class Solution {\n      public int[] shortestDistanceAfterQueries(int n, int[][] queries) {\n        SegmentTree segmentTree = new SegmentTree(n);\n        int[] res = new int[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            int from = queries[i][0];\n            int to = queries[i][1];\n            if (from +1 <= to - 1){\n                segmentTree.update(from+1,to-1,0);\n            }\n            res[i]=segmentTree.query()-1;\n        }\n        return res;\n    }\n\n\n    public static class SegmentTree {\n        int[] data;\n        boolean[] cache;\n        int size;\n\n        public SegmentTree(int n) {\n            data = new int[n << 2];\n            cache = new boolean[n << 2];\n            size = n;\n            build(0, size - 1, 1);\n        }\n\n        private void build(int start, int end, int index) {\n            if (start == end) {\n                data[index] = 1;\n                return;\n            }\n            int mid = (start + end) / 2;\n            build(start, mid, index * 2);\n            build(mid + 1, end, index * 2 + 1);\n            data[index] = data[index * 2] + data[index * 2 + 1];\n        }\n\n        public void update(int s, int e, int v) {\n            update(s, e, v, 0, size - 1, 1);\n        }\n\n\n        public int query() {\n            return data[1];\n        }\n\n\n        private void update(int s, int e, int v, int START, int END, int index) {\n            if (s == START && e == END) {\n                data[index] = v;\n                if (s != e) {\n                    cache[index] = true;\n                }\n                return;\n            }\n\n            downCache(START, END, index);\n\n            int MID = (START + END) / 2;\n            if (e <= MID) {\n                update(s, e, v, START, MID, index * 2);\n            } else if (s > MID) {\n                update(s, e, v, MID + 1, END, index * 2 + 1);\n            } else {\n                update(s, MID, v, START, MID, index * 2);\n                update(MID + 1, e, v, MID + 1, END, index * 2 + 1);\n            }\n            data[index] = data[index * 2] + data[index * 2+1];\n        }\n\n        private void downCache(int START, int END, int index) {\n            if (!cache[index]) {\n                return;\n            }\n            if (START != (START + END) / 2) {\n                cache[index * 2] = cache[index];\n                cache[index * 2 + 1] = cache[index];\n            }\n\n            data[index * 2] = data[index];\n            data[index * 2 + 1] = data[index];\n            cache[index] = false;\n\n        }\n    }\n}",
    "submit_ts": "1722743311",
    "subm_id": "552350064"
}