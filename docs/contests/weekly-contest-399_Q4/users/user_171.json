{
    "username": "raararaara",
    "submission": "using lint = long long;\nusing ii = pair<int, int>;\nusing il = pair<int, lint>;\nusing li = pair<lint, int>;\nusing ll = pair<lint, lint>;\n\nconst int mxn = 1000100, mxp = 1000001;\nconst int MOD = 1e9+7, inf = -1e9 - 7, INF = 1e9 + 1;\nconst lint lnf = -4e18, LNF = 5e18;\nconst double eps = 1e-10;\nconst int sqrtN = 200;\n\n#define sz(x) int(size(x))\n#define all(x) (x).begin(),(x).end()\n#define compress(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())\n#define lb(x, v) (lower_bound(all(x), v) - (x).begin())\n#define ub(x, v) (upper_bound(all(x), v) - (x).begin())\n#define eb emplace_back\n#define pb push_back\n#define getName(var)  #var\nvector<lint> xl, yl;\n\n#define Yes \"Yes\\n\"\n#define No \"No\\n\"\n\nconst int dr[] = {-1, 0, 1, 0};\nconst int dc[] = {0, -1, 0, 1};\n\ninline int inRange(int r, int c, int R, int C) {\n    return 0 <= r && r < R && 0 <= c && c < C;\n}\n\nint N, M, Q, R, C, H, K, T;\n\nvoid init() {\n\n}\n\nstruct P {\n    lint tot, LR, lr, lR, Lr, mx;\n    P() {\n        tot = LR = lr = lR = Lr = mx = 0;\n    }\n    P(lint x): tot(x), LR(x), lr(0), lR(0), Lr(0), mx(x) {}\n//    P(lint tot, lint LL, lint RR, lint mx) :tot(tot), LL(LL), RR(RR), mx(mx) {}\n    P operator + (const P&rhs) {\n        P ret;\n        ret.tot = tot + rhs.tot;\n        ret.LR = max(LR + rhs.lR, Lr + rhs.LR);\n        ret.lr = max(lR + rhs.lr, lr + max(rhs.Lr, rhs.lr));\n        ret.lR = max(lR + rhs.lR, lr + max(rhs.LR, rhs.lR));\n        ret.Lr = max(LR + rhs.lr, Lr + max(rhs.Lr, rhs.lr));\n        ret.mx = max({ ret.LR, ret.lr, ret.lR, ret.Lr, mx, rhs.mx });\n        return ret;\n    }\n    P& operator = (const P&rhs) = default;\n};\n\ntemplate<typename T_Node, typename F>\nstruct SegTree {\n    int N{}, base{};\n    vector<T_Node> tree;\n    const F f{};\n    const T_Node I;\n\n    SegTree(int n, F _f, const T_Node &I) : N(n), f(_f), I(I) {\n        for (base = 1; base < N; base <<= 1);\n        tree = vector<T_Node>(base<<1|1, I);\n    }\n\n    SegTree(vector<T_Node> &v, F _f, const T_Node &I) : N(int(size(v))), f(_f), I(I) {\n        for (base = 1; base < N; base <<= 1);\n        tree = vector<T_Node>(base<<1|1, I);\n        copy(all(v), tree.begin() + base);\n        for(int i = base-1; ~i; --i) adjust(i);\n    }\n\n    T_Node get(int i) { return tree[i + base]; }\n\n    T_Node top() { return tree[1]; }\n\n    void upd(int i, T_Node v) {\n        tree[i += base] = v;\n        while (i >>= 1) adjust(i);\n    }\n\n    void adjust(int i) { tree[i] = f(tree[i << 1], tree[i << 1 | 1]); }\n\n    T_Node qry(int l, int r) {\n        T_Node retL = I, retR = I;\n        for (l += base, r += base; l <= r; l >>= 1, r >>= 1) {\n            if (l & 1) retL = f(retL, tree[l++]);\n            if (~r & 1) retR = f(tree[r--], retR);\n        }\n        return f(retL, retR);\n    }\n};\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& a, vector<vector<int>>& queries) {\n        N = sz(a);\n        auto f = [](P a, P b) { return a + b; };\n        SegTree<P, decltype(f)> seg(N, f, P());\n        for(int i = 0; i < N; i++) {\n            seg.upd(i, P(a[i]));\n        }\n        \n        lint ret = 0;\n        for(auto &q: queries) {\n            int i = q[0], v = q[1];\n            a[i] = v;\n            seg.upd(i, P(v));\n            ret = (ret + seg.qry(0, N-1).mx);\n            ret %= MOD;\n        }\n        return int(ret);\n    }\n};",
    "submit_ts": 1716695095.0
}