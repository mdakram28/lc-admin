{
    "username": "3PQeaIB0Wk",
    "submission": "class Solution {\npublic:\n    unordered_map<int, set<int>> m1;\n    unordered_map<int, set<int>> m2;\n    vector<int> outdegree1;\n    vector<int> outdegree2;\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = 0, m = 0;\n        for (auto& e : edges1) {\n            n = max(n, e[0] + 1);\n            n = max(n, e[1] + 1);\n        }\n\n        for (auto& e : edges2) {\n            m = max(m, e[0] + 1);\n            m = max(m, e[1] + 1);\n        }\n\n        outdegree1 = vector<int>(n, 0);\n        for (auto& e : edges1) {\n            outdegree1[e[0]]++;\n            outdegree1[e[1]]++;\n            m1[e[0]].insert(e[1]);\n            m1[e[1]].insert(e[0]);\n        }\n\n        outdegree2 = vector<int>(m, 0);\n        for (auto& e : edges2) {\n            outdegree2[e[0]]++;\n            outdegree2[e[1]]++;\n            m2[e[0]].insert(e[1]);\n            m2[e[1]].insert(e[0]);\n        }\n\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (outdegree1[i] == 1) {\n                dfs(i, -1, m1, res);\n                break;\n            }\n        }\n\n        for (int i = 0; i < m; i++) {\n            if (outdegree2[i] == 1) {\n                dfs(i, -1, m2, res);\n                break;\n            }\n        }\n\n        res = max(res, topoSort(outdegree1, m1) + topoSort(outdegree2, m2) + 1);\n\n        return res;\n    }\n\n    int topoSort(vector<int>& v, unordered_map<int, set<int>>& mp) {\n        if (v.size() <= 1) return v.size();\n        queue<int> q;\n        for (int i = 0; i < v.size(); i++) {\n            if (v[i] == 1) {\n                q.push(i);\n                v[i] = 0;\n            }\n        }\n\n        int mxLen = -1;\n        while (!q.empty()) {\n            int sz = q.size();\n            int tmp = sz;\n            while (sz--) {\n                int curr = q.front();\n                q.pop();\n                for (int next : mp[curr]) {\n                    mp[next].erase(curr);\n                    v[next]--;\n                    if (v[next] == 1) {\n                        q.push(next);\n                        v[next] = 0;\n                    }\n                }\n            }\n            if (q.empty() && tmp > 1) mxLen++;\n            mxLen++;\n        }\n\n        return max(1, mxLen);\n    }\n\n    int dfs(int node, int parent, unordered_map<int, set<int>>& mp, int& res) {\n        int mx = 0;\n        int mx1 = 0, mx2 = 0;\n        for (int next : mp[node]) {\n            if (next == parent) continue;\n            int p = dfs(next, node, mp, res);\n            if (p > mx2) mx2 = p;\n            if (mx2 > mx1) swap(mx1, mx2);\n            res = max(res, mx1 + mx2);\n            mx = max(mx, p);\n        }\n        res = max(res, mx);\n        return mx + 1;\n    }\n};",
    "submit_ts": 1719717783.0
}