{
    "username": "serialcomder",
    "submission": "class Solution {\npublic:\n    struct dat {\n    int mn;\n    dat() : mn(0) {};\n};\n\nstruct SegTree {\n    int N;\n    vector<dat> st;\n\n    void init(int n) {\n        N = n;\n        st.resize(4 * N + 5);\n    }\n\n    void merge(dat &cur, dat &l, dat &r) {\n        cur.mn = max(l.mn, r.mn);\n    }\n\n    dat Query(int node, int L, int R, int i, int j) {\n        if(j < L || i > R) return dat();\n        if(i <= L && R <= j) return st[node];\n        int M = (L + R) / 2;\n        dat left = Query(node * 2, L, M, i, j);\n        dat right = Query(node * 2 + 1, M + 1, R, i, j);\n        dat cur;\n        merge(cur, left, right);\n        return cur;\n    }\n\n    dat pQuery(int node, int L, int R, int pos) {\n        if(L == R) return st[node];\n        int M = (L + R) / 2;\n        if(pos <= M) return pQuery(node * 2, L, M, pos);\n        else return pQuery(node * 2 + 1, M + 1, R, pos);\n    }\n\n    void pUpdate(int node, int L, int R, int pos, int val) {\n        if(L == R) {\n            st[node].mn = val;\n            return;\n        }\n        int M = (L + R) / 2;\n        if(pos <= M) pUpdate(node * 2, L, M, pos, val);\n        else pUpdate(node * 2 + 1, M + 1, R, pos, val);\n        merge(st[node], st[node * 2], st[node * 2 + 1]);\n    }\n\n    dat query(int pos) {\n        return pQuery(1, 1, N, pos);\n    }\n\n    dat query(int l, int r) {\n        return Query(1, 1, N, l, r);\n    }\n\n    void update(int pos, int val) {\n        pUpdate(1, 1, N, pos, val);\n    }\n};\n\nint maximumLength(vector<int>& b, int k) {\n    vector<int> a = b;\n    int ind = 1;\n    map<int, int> mp;\n    for(auto &i : a) {\n        if(mp.count(i)) continue;\n        else mp[i] = ind++;\n    }\n    for(auto &i : a) {\n        i = mp[i];\n    }\n    int n = a.size();\n    vector<SegTree> dp(k + 1);\n    for(auto &i : dp) {\n        i.init(n + 1);\n    }\n    for(auto &i : a) {\n        for(int l = k; l >= 0; l--) {        \n            int mx = dp[l].query(i).mn + 1;\n            if(l < k) mx = max({mx, dp[l + 1].query(1, i - 1).mn + 1, dp[l + 1].query(i + 1, n).mn + 1});\n            dp[l].update(i, mx);\n        }\n    }\n    int mx = 0;\n    for(int i = 1; i <= n; i++) {\n        for(int l = 0; l <= k; l++) {\n            mx = max(mx, dp[l].query(i).mn);\n        }\n    }\n    return mx;\n}\n};",
    "submit_ts": 1717859754.0
}