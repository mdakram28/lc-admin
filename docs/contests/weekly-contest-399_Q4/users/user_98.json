{
    "username": "WORTH_IT",
    "submission": "    class Solution {\n\n        final int MOD = (int) 1e9 + 7;\n\n        public int maximumSumSubsequence(int[] nums, int[][] queries) {\n            int n = nums.length;\n            SegmentTree st = new SegmentTree(nums);\n\n            long sum = 0;\n            for (int[] temp : queries) {\n                int i = temp[0], x = temp[1];\n                st.update(1, 0, st.size() - 1, i, x);\n                sum += st.node[1].sum[0];\n                if (sum >= MOD)\n                    sum -= MOD;\n            }\n\n            return (int) sum;\n        }\n    }\n\n    class SegmentTree {\n\n        static class Node {\n    //        sum[0] = [l, r]\n    //        sum[1] = [l + 1, r]\n    //        sum[2] = [l, r - 1]\n    //        sum[3] = [l + 1, r - 1]\n            long[] sum;\n\n            public Node(int a) {\n                sum = new long[4];\n                sum[0] = Math.max(a, 0);\n            }\n\n            public Node() {\n                this(0);\n            }\n\n            @Override\n            public String toString() {\n                return Arrays.toString(sum);\n            }\n        }\n\n        Node merge(Node a, Node b) {\n            Node c = new Node();\n            c.sum[0] = Math.max(a.sum[0] + b.sum[1], a.sum[2] + b.sum[0]);\n            c.sum[1] = Math.max(a.sum[1] + b.sum[1], a.sum[3] + b.sum[0]);\n            c.sum[2] = Math.max(a.sum[0] + b.sum[3], a.sum[2] + b.sum[2]);\n            c.sum[3] = Math.max(a.sum[1] + b.sum[3], a.sum[3] + b.sum[2]);\n\n            return c;\n        }\n\n        int[] a;\n        Node[] node;\n        int count, n;\n\n        public SegmentTree(int[] a) {\n            this.a = a;\n            count = a.length;\n            n = powerOf2(count);\n            node = new Node[2 * n];\n           Arrays.setAll(node, i -> new Node());\n            for (int i = 0; i < count; i++)\n                node[n + i] = new Node(a[i]);\n            build(1, 0, n - 1);\n        }\n\n        void build(int v, int l, int r) {\n            if (l == r)\n                return;\n            int mid = (l + r) >> 1;\n            build(2 * v, l, mid);\n            build(2 * v + 1, mid + 1, r);\n            node[v] = merge(node[2 * v], node[2 * v + 1]);\n        }\n\n        int size() {\n            return n;\n        }\n\n        static int powerOf2(int n) {\n            if ((n & (n - 1)) == 0)\n                return n;\n            n |= n >> 1;\n            n |= n >> 2;\n            n |= n >> 4;\n            n |= n >> 8;\n            n |= n >> 16;\n            return n + 1;\n        }\n\n        Node query(int v, int l, int r, int ql, int qr) {\n            if (qr < l || ql > r)\n                return new Node();\n            if (l >= ql && qr >= r)\n                return node[v];\n            int mid = (l + r) >> 1;\n            Node left = query(2 * v, l, mid, ql, qr);\n            Node right = query(2 * v + 1, mid + 1, r, ql, qr);\n            return merge(left, right);\n        }\n\n        void update(int v, int l, int r, int i, int x) {\n            if (i < l || i > r)\n                return;\n\n            if (l == r) {\n                a[i] = x;\n                node[v] = new Node(a[i]);\n                return;\n            }\n\n            int mid = (l + r) >> 1;\n            update(2 * v, l, mid, i, x);\n            update(2 * v + 1, mid + 1, r, i, x);\n            node[v] = merge(node[2 * v], node[2 * v + 1]);\n        }\n    }",
    "submit_ts": "1716693785",
    "subm_id": "1268096970"
}