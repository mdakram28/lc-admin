{
    "username": "devvrat_07",
    "submission": "import java.util.*;\n\npublic class temp {\n    public static void main(String[] args) {\n        // Example usage:\n        Solution solution = new Solution();\n        // Example function calls can go here\n    }\n\n    // Utility functions\n    public static long gcd(long a, long b) {\n        if (b > a) {\n            return gcd(b, a);\n        }\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static long expo(long a, long b, long mod) {\n        long res = 1;\n        while (b > 0) {\n            if ((b & 1) != 0) res = (res * a) % mod;\n            a = (a * a) % mod;\n            b >>= 1;\n        }\n        return res;\n    }\n\n    public static void extendGCD(long a, long b, long[] v) {\n        if (b == 0) {\n            v[0] = 1;\n            v[1] = 0;\n            v[2] = a;\n            return;\n        }\n        extendGCD(b, a % b, v);\n        long x = v[1];\n        v[1] = v[0] - v[1] * (a / b);\n        v[0] = x;\n    }\n\n    public static long modInverse(long a, long b) {\n        long[] arr = new long[3];\n        extendGCD(a, b, arr);\n        return arr[0];\n    }\n\n    public static long modInversePrime(long a, long b) {\n        return expo(a, b - 2, b);\n    }\n\n    public static boolean revSort(long a, long b) {\n        return a > b;\n    }\n\n    public static long modAdd(long a, long b, long m) {\n        a %= m;\n        b %= m;\n        return (((a + b) % m) + m) % m;\n    }\n\n    public static long modMul(long a, long b, long m) {\n        a %= m;\n        b %= m;\n        return (((a * b) % m) + m) % m;\n    }\n\n    public static long modSub(long a, long b, long m) {\n        a %= m;\n        b %= m;\n        return (((a - b) % m) + m) % m;\n    }\n\n    public static long modDiv(long a, long b, long m) {\n        a %= m;\n        b %= m;\n        return (modMul(a, modInversePrime(b, m), m) + m) % m;\n    }\n\n    public static int power(long a, long b, long m) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b % 2 == 0) {\n            long t = power(a, b / 2, m);\n            return (int)((1L * t * t) % m);\n        } else {\n            long t = power(a, (b - 1) / 2, m);\n            t = (1L * t * t) % m;\n            return (int)((1L * a * t) % m);\n        }\n    }\n\n    // Constants and arrays for combinatorial calculations\n    static final int N = 500000;\n    static final long MOD = 1000000007;\n    static long[] fact = new long[N];\n    static long[] invfact = new long[N];\n\n    public static void init() {\n        fact[0] = 1;\n        for (int i = 1; i < N; i++) {\n            fact[i] = (i * fact[i - 1]) % MOD;\n        }\n        invfact[N - 1] = power(fact[N - 1], MOD - 2, MOD);\n        for (int i = N - 2; i >= 0; i--) {\n            invfact[i] = (invfact[i + 1] * (i + 1)) % MOD;\n        }\n    }\n\n    public static int nCr(int n, int r) {\n        if (r > n) return 0;\n        return (int)((((fact[n] * invfact[r]) % MOD) * invfact[n - r]) % MOD);\n    }\n\n    public static List<Integer> sieveOfEratosthenes(int n) {\n        List<Integer> primes = new ArrayList<>();\n        boolean[] isPrime = new boolean[n + 1];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        for (int p = 2; p * p <= n; p++) {\n            if (isPrime[p]) {\n                for (int i = p * p; i <= n; i += p) {\n                    isPrime[i] = false;\n                }\n            }\n        }\n        for (int i = 2; i <= n; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n}\n\n\n\nclass Solution {\n    class TrieNode {\n        TrieNode[] children;\n        int index;\n\n        TrieNode() {\n            children = new TrieNode[26];\n            index = -1;\n        }\n    }\n\n    class Trie_Use {\n        TrieNode root;\n\n        Trie_Use() {\n            root = new TrieNode();\n        }\n\n        void insert(String word, int index) {\n            TrieNode node = root;\n            for (char c : word.toCharArray()) {\n                int idx = c - 'a';\n                if (node.children[idx] == null) {\n                    node.children[idx] = new TrieNode();\n                }\n                node = node.children[idx];\n            }\n            node.index = index;\n        }\n\n        List<Integer> search(String target, int start) {\n            TrieNode node = root;\n            List<Integer> result = new ArrayList<>();\n            for (int i = start; i < target.length(); ++i) {\n                int idx = target.charAt(i) - 'a';\n                if (node.children[idx] == null) break;\n                node = node.children[idx];\n                if (node.index != -1) {\n                    result.add(node.index);\n                }\n            }\n            return result;\n        }\n    }\n\n    public int minCostToFormTarget(String target, String[] words, int[] costs) {\n        int n = target.length();\n\n        Trie_Use trie = new Trie_Use();\n        for (int i = 0; i < words.length; ++i) {\n            trie.insert(words[i], i);\n        }\n\n        int[] ans = new int[n + 1];\n        Arrays.fill(ans, Integer.MAX_VALUE);\n        ans[0] = 0;\n\n        for (int i = 0; i < n; ++i) {\n            if (ans[i] == Integer.MAX_VALUE) continue;\n\n            List<Integer> indices = trie.search(target, i);\n            for (int index : indices) {\n                int len = words[index].length();\n                if (i + len <= n) {\n                    ans[i + len] = Math.min(ans[i + len], ans[i] + costs[index]);\n                }\n            }\n        }\n\n        return ans[n] == Integer.MAX_VALUE ? -1 : ans[n];\n    }\n\n    public int minimumCost(String target, String[] words, int[] costs) {\n        Map<String, Integer> mp = new HashMap<>();\n        for (int i = 0; i < words.length; i++) {\n            mp.put(words[i], Math.min(mp.getOrDefault(words[i], Integer.MAX_VALUE), costs[i]));\n        }\n        List<String> uniqueWords = new ArrayList<>(mp.keySet());\n        List<Integer> uniqueCosts = new ArrayList<>();\n        for (String word : uniqueWords) {\n            uniqueCosts.add(mp.get(word));\n        }\n\n        String[] uniqueWordsArray = uniqueWords.toArray(new String[0]);\n        int[] uniqueCostsArray = uniqueCosts.stream().mapToInt(i -> i).toArray();\n\n        return minCostToFormTarget(target, uniqueWordsArray, uniqueCostsArray);\n    }\n\n}",
    "submit_ts": "1720323056",
    "subm_id": "1312366207"
}