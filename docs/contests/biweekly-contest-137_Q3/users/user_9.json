{
    "username": "Paul Chen",
    "submission": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\ntemplate <class T>\nusing vec = vector<T>;\n\n#define FOR(i, s, e) for (ll i = (ll)s; i < (ll)e; i++)\n#define CFOR(i, s, e) for (ll i = (ll)s; i <= (ll)e; i++)\n#define TRAV(a, c) for (const auto &a : c)\n#define dbg(x) cerr << \"ln\" << __LINE__ << \": \" << #x << \" = \" << x << endl\n\n\ntemplate <class K, class V>\nostream &operator<<(ostream &out, const pair<K, V> &obj) {\n    return out << \"(\" << obj.first << \", \" << obj.second << \")\";\n}\n\ntemplate <class T, class = decay_t<decltype(*begin(declval<T>()))>,\n          class = enable_if_t<!is_same<T, string>::value>>\nostream &operator<<(ostream &out, const T &obj) {\n    out << '[';\n    for (auto it = obj.begin(); it != obj.end(); it++)\n        out << &\", \"[2 * (it == obj.begin())] << *it;\n    return out << ']';\n}\n\nstruct Edge\n{\n    ll from, to, capacity, cost;\n};\n\nvector<vector<ll>> adj, cost, capacity;\n\nconst ll INF = 1e18;\n\nvoid shortest_paths(ll n, ll v0, vector<ll>& d, vector<ll>& p) {\n    d.assign(n, INF);\n    d[v0] = 0;\n    vector<bool> inq(n, false);\n    queue<ll> q;\n    q.push(v0);\n    p.assign(n, -1);\n\n    while (!q.empty()) {\n        ll u = q.front();\n        q.pop();\n        inq[u] = false;\n        for (ll v : adj[u]) {\n            if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\n                d[v] = d[u] + cost[u][v];\n                p[v] = u;\n                if (!inq[v]) {\n                    inq[v] = true;\n                    q.push(v);\n                }\n            }\n        }\n    }\n}\n\nll min_cost_flow(ll N, vector<Edge> edges, ll K, ll s, ll t) {\n    adj.assign(N, vector<ll>());\n    cost.assign(N, vector<ll>(N, 0));\n    capacity.assign(N, vector<ll>(N, 0));\n    for (Edge e : edges) {\n        adj[e.from].push_back(e.to);\n        adj[e.to].push_back(e.from);\n        cost[e.from][e.to] = e.cost;\n        cost[e.to][e.from] = -e.cost;\n        capacity[e.from][e.to] = e.capacity;\n    }\n\n    ll flow = 0;\n    ll cost = 0;\n    vector<ll> d, p;\n    while (flow < K) {\n        shortest_paths(N, s, d, p);\n        if (d[t] == INF)\n            break;\n\n        // find max flow on that path\n        ll f = K - flow;\n        ll cur = t;\n        while (cur != s) {\n            f = min(f, capacity[p[cur]][cur]);\n            cur = p[cur];\n        }\n\n        // apply flow\n        flow += f;\n        cost += f * d[t];\n        cur = t;\n        while (cur != s) {\n            capacity[p[cur]][cur] -= f;\n            capacity[cur][p[cur]] += f;\n            cur = p[cur];\n        }\n    }\n\n    if (flow < K)\n        return -1;\n    else\n        return cost;\n}\n\nclass Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& board) {\n        ll n = board.size();\n        ll m = board[0].size();\n        vec<Edge> a;\n        FOR(i, 0, n) {\n            FOR(j, 0, m) {\n                a.push_back({i, n + j, 1, -board[i][j]});\n            }\n        }\n        FOR(i, 0, n) {\n            a.push_back({n + m, i, 1, 0});\n        }\n        FOR(j, 0, m) {\n            a.push_back({n + j, n + m + 1, 1, 0});\n        }\n        return -min_cost_flow(n + m + 2, a, 3, n + m, n + m + 1);\n    }\n};",
    "submit_ts": "1723906045",
    "subm_id": "1359032476"
}