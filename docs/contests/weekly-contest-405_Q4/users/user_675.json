{
    "username": "KonDrago",
    "submission": "class Solution:\n    def minimumCost(self, s: str, words: List[str], costs: List[int]) -> int:\n        \n        #make a dictionary of the ith letter each word begins with\n        #then do a dynamic programming try to attach words connecting smart\n        #index by first letter\n        #accumulate left -> right number of X's\n        #then accumulate these row wise stacking\n        M = len(s)\n        N = len(words)\n\n        print(s,M)\n\n        wordCost = defaultdict(lambda:inf)\n        for i in range(N):\n            w = words[i]\n            c = costs[i]\n            wordCost[w] = min(wordCost[w], c)\n            #D[w[0]].append((w,c))\n\n        #print(wordCost)\n\n        D = defaultdict(list)\n        for w in wordCost.keys():\n            D[w[0]].append((w,wordCost[w]))\n\n        #print(D)\n\n        \n\n        @cache\n        def wordBuild(i):       #maybe put curent cost into parameter? cumString\n            if i == M:\n                return 0\n\n            #print(i,cumString)\n\n            ch = s[i]\n            extensions = D[ch]    #next pieces to consider\n            minCost = inf\n            for n in extensions:\n                nW,nC = n\n                #print(i,nW, nC, i + len(nW), s[i:i+len(nW)] == nW)\n                #check viability\n                if i + len(nW) <= M and s[i:i+len(nW)] == nW:\n                    c = nC + wordBuild(i+len(nW))\n                    minCost = min(minCost,c)\n\n            return minCost\n\n        out = wordBuild(0)\n        return out if isfinite(out) else -1\n\n       ",
    "submit_ts": "1720322667",
    "subm_id": "1312355977"
}