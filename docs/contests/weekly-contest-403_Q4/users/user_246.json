{
    "username": "wixton",
    "submission": "class Solution {\npublic:\n// summation\nstruct segmentTree {\n    int n;\n    vector<int> st, lazy;\n\n    segmentTree(int _n) {\n        this->n = _n;\n        st.resize(4 * n, 0);\n        lazy.resize(4 * n, 0);\n    }\n\n    void build(int start, int ending, int node, vector<int> &v) {\n        // leaf node base case\n        if (start == ending) {\n            st[node] = v[start];\n            return;\n        }\n\n        int mid = (start + ending) / 2;\n\n        // left subtree is (start,mid)\n        build(start, mid, 2 * node + 1, v);\n\n        // right subtree is (mid+1,ending)\n        build(mid + 1, ending, 2 * node + 2, v);\n\n        st[node] = st[node * 2 + 1] + st[node * 2 + 2];\n    }\n\n    int query(int start, int ending, int l, int r, int node) {\n        // non overlapping case\n        if (start > r || ending < l) {\n            return 0;\n        }\n\n        // lazy propagation / clear the lazy update\n        if (lazy[node] != 0) {\n            // pending updates\n            // update the segment tree node\n            st[node] += lazy[node] * (ending - start + 1);\n            if (start != ending) {\n                // propagate the updated value\n                lazy[2 * node + 1] += lazy[node];\n                lazy[2 * node + 2] += lazy[node];\n            }\n            lazy[node] = 0;\n        }\n\n        // complete overlap\n        if (start >= l && ending <= r) {\n            return st[node];\n        }\n\n        // partial case\n        int mid = (start + ending) / 2;\n\n        int q1 = query(start, mid, l, r, 2 * node + 1);\n        int q2 = query(mid + 1, ending, l, r, 2 * node + 2);\n\n        return q1 + q2;\n    }\n\n    void update(int start, int ending, int node, int l, int r, int value) {\n        // non overlapping case\n        if (start > r || ending < l) {\n            return ;\n        }\n\n        // lazy propagation / clear the lazy update\n        if (lazy[node] != 0) {\n            // pending updates\n            // update the segment tree node\n            st[node] += lazy[node] * (ending - start + 1);\n            if (start != ending) {\n                // propagate the updated value\n                lazy[2 * node + 1] += lazy[node];\n                lazy[2 * node + 2] += lazy[node];\n            }\n            lazy[node] = 0;\n        }\n\n        // complete overlap\n        if (start >= l && ending <= r) {\n            st[node] += value * (ending - start + 1);\n            if (start != ending) {\n                lazy[2 * node + 1] += value;\n                lazy[2 * node + 2] += value;\n            }\n            return;\n        }\n\n        // partial case\n        int mid = (start + ending) / 2;\n\n        update(start, mid, 2 * node + 1, l, r, value);\n\n        update(mid + 1, ending, 2 * node + 2, l, r, value);\n\n        st[node] = st[node * 2 + 1] + st[node * 2 + 2];\n\n        return;\n    }\n\n    void build(vector<int> &v) {\n        build(0, n - 1, 0, v);\n    }\n\n    int query(int l, int r) {\n        return query(0, n - 1, l, r, 0);\n    }\n\n    void update(int l, int r, int x) {\n        update(0, n - 1, 0, l, r, x);\n    }\n};\n    struct DSU\n{\n    vector<int> par, rnk, sz;\n    int c;\n    DSU(int n) : par(n + 1), rnk(n + 1, 0), sz(n + 1, 1), c(n) {\n        for (int i = 1; i <= n; ++i)\n            par[i] = i;\n    }\n    int find(int i) {\n        return (par[i] == i ? i : (par[i] = find(par[i])));\n    }\n    bool same(int i, int j) {\n        return find(i) == find(j);\n    }\n    int get_size(int i) {\n        return sz[find(i)];\n    }\n    int count() {\n        return c; // connected components\n    }\n    int merge(int i, int j) {\n        if ((i = find(i)) == (j = find(j)))\n            return -1;\n        else\n            --c;\n        if (rnk[i] > rnk[j])\n            swap(i, j);\n        par[i] = j;\n        sz[j] += sz[i];\n        if (rnk[i] == rnk[j])\n            rnk[j]++;\n        return j;\n    }\n};\n    #define ll long long int\n    ll help(int a,int b,int c,int d,vector<vector<int>> &ar) {\n        ll l1=5000,l2=0,r1=5000,r2=0;\n        for(ll i=a;i<=b;i++)\n        {\n            for(ll j=c;j<=d;j++)\n            {\n                if(ar[i-1][j-1]==1)\n                {\n                    l1=min(l1,j+1);\n                    l2=max(l2,j+1);\n                    r1=min(r1,i+1);\n                    r2=i+1;\n                }\n            }\n        }\n        if(l1==5000) return 1e9;\n        return (l2-l1+1)*(r2-r1+1);\n    }\n    void help1(ll &ans, ll a, ll b, ll c) {\n        ans = min(ans, a + b + c);\n    }\n    int minimumSum(vector<vector<int>>& ar) {\n        int n = ar.size();\n        int m = ar[0].size();\n        DSU ds(n);\n        segmentTree se(n);\n        ll res = 1e9;\n        for(int i=1;i<n-1;i++) {        \n            for(int k=i+1;k<n;k++) {\n                ll x1 = help(1,i,1,m,ar);\n                ll x2 = help(i+1,k,1,m,ar);\n                ll x3 = help(k+1,n,1,m,ar);\n                help1(res, x1, x2, x3);\n            }\n        }\n        for(int i=1;i<m-1;i++) {\n            for(int k=i+1;k<m;k++) {\n                ll x1 = help(1,n,1,i,ar);\n                ll x2 = help(1,n,i+1,k,ar);\n                ll x3 = help(1,n,k+1,m,ar);\n                help1(res, x1, x2, x3);\n            }\n        }\n        for(int i=1;i<m;i++) {\n            for(int j=1;j<n;j++) {\n                ll x1 = help(1,n,1,i,ar);\n                ll x2 = help(1,j,i+1,m,ar);\n                ll x3 = help(j+1,n,i+1,m,ar);\n                help1(res, x1, x2, x3);\n            }\n        }\n        for(int i=1;i<m;i++) {\n            for(int j=1;j<n;j++) {\n                ll x1=help(1,j,1,i,ar);\n                ll x2=help(j+1,n,1,i,ar);\n                ll x3=help(1,n,i+1,m,ar);\n                help1(res, x1, x2, x3);\n            }\n        }\n        for(int i=1;i<n;i++) {\n            for(int j=1;j<m;j++) {\n                ll x1=help(1,i,1,m,ar);\n                ll x2=help(i+1,n,1,j,ar);\n                ll x3=help(i+1,n,j+1,m,ar);\n                help1(res, x1, x2, x3);\n            }\n        }\n        for(int i=1;i<n;i++) {\n            for(int j=1;j<m;j++) {\n                ll x1=help(1,i,1,j,ar);\n                ll x2=help(1,i,j+1,m,ar);\n                ll x3=help(i+1,n,1,m,ar);\n                help1(res, x1, x2, x3);\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1719113556.0
}