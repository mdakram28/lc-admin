{
    "username": "endlesscheng",
    "submission": "package main\n\nimport (\n\t\"math/bits\"\n\t\"time\"\n)\n\n// https://space.bilibili.com/206214\ntype seg []struct {\n\tl, r int\n\tval  int\n}\n\nfunc mergeInfo(a, b int) int {\n\treturn max(a, b)\n}\n\nfunc (t seg) build(a []int, o, l, r int) {\n\tt[o].l, t[o].r = l, r\n\tif l == r {\n\t\tt[o].val = a[l]\n\t\treturn\n\t}\n\tm := (l + r) >> 1\n\tt.build(a, o<<1, l, m)\n\tt.build(a, o<<1|1, m+1, r)\n\tt.maintain(o)\n}\n\nfunc (t seg) update(o, i int, val int) {\n\tif t[o].l == t[o].r {\n\t\tt[o].val = val\n\t\treturn\n\t}\n\tm := (t[o].l + t[o].r) >> 1\n\tif i <= m {\n\t\tt.update(o<<1, i, val)\n\t} else {\n\t\tt.update(o<<1|1, i, val)\n\t}\n\tt.maintain(o)\n}\n\nfunc (t seg) maintain(o int) {\n\tt[o].val = mergeInfo(t[o<<1].val, t[o<<1|1].val)\n}\n\nfunc (t seg) query(o, l, r int) (res int) {\n\tif l <= t[o].l && t[o].r <= r {\n\t\treturn t[o].val\n\t}\n\tm := (t[o].l + t[o].r) >> 1\n\tif r <= m {\n\t\treturn t.query(o<<1, l, r)\n\t}\n\tif m < l {\n\t\treturn t.query(o<<1|1, l, r)\n\t}\n\tlv := t.query(o<<1, l, r)\n\trv := t.query(o<<1|1, l, r)\n\treturn mergeInfo(lv, rv)\n}\n\nfunc (t seg) queryAll() int { return t[1].val }\n\nfunc newSegmentTree(a []int) seg {\n\tn := len(a)\n\tt := make(seg, 2<<bits.Len(uint(n-1)))\n\tt.build(a, 1, 0, n-1)\n\treturn t\n}\n\ntype node struct {\n\tlr       [2]*node\n\tpriority uint\n\tkey      int\n\tsubCnt   int\n}\n\nfunc (o *node) size() int {\n\tif o != nil {\n\t\treturn o.subCnt // \u6c47\u603b\n\t}\n\treturn 0\n}\n\nfunc (o *node) maintain() { o.subCnt = 1 + o.lr[0].size() + o.lr[1].size() }\n\nfunc (o *node) rotate(d int) *node {\n\tx := o.lr[d^1]\n\to.lr[d^1] = x.lr[d]\n\tx.lr[d] = o\n\to.maintain()\n\tx.maintain()\n\treturn x\n}\n\ntype treap struct {\n\trd   uint\n\troot *node\n}\n\nfunc (t *treap) fastRand() uint {\n\tt.rd ^= t.rd << 13\n\tt.rd ^= t.rd >> 17\n\tt.rd ^= t.rd << 5\n\treturn t.rd\n}\n\nfunc (t *treap) size() int { return t.root.size() }\n\nfunc (t *treap) _put(o *node, key int) *node {\n\tif o == nil {\n\t\treturn &node{priority: t.fastRand(), key: key, subCnt: 1}\n\t}\n\tif d := o.cmp(key); d >= 0 {\n\t\to.lr[d] = t._put(o.lr[d], key)\n\t\tif o.lr[d].priority > o.priority {\n\t\t\to = o.rotate(d ^ 1)\n\t\t}\n\t} else {\n\t\t// \u76f8\u7b49\n\t}\n\to.maintain()\n\treturn o\n}\n\nfunc (t *treap) put(key int) { t.root = t._put(t.root, key) }\n\nfunc (t *treap) _delete(o *node, key int) *node {\n\tif o == nil {\n\t\treturn nil\n\t}\n\tif d := o.cmp(key); d >= 0 {\n\t\to.lr[d] = t._delete(o.lr[d], key)\n\t} else {\n\t\tif o.lr[1] == nil {\n\t\t\treturn o.lr[0]\n\t\t}\n\t\tif o.lr[0] == nil {\n\t\t\treturn o.lr[1]\n\t\t}\n\t\td = 0\n\t\tif o.lr[0].priority > o.lr[1].priority {\n\t\t\td = 1\n\t\t}\n\t\to = o.rotate(d)\n\t\to.lr[d] = t._delete(o.lr[d], key)\n\t}\n\to.maintain()\n\treturn o\n}\n\nfunc (t *treap) delete(key int) { t.root = t._delete(t.root, key) }\n\nfunc newTreap() *treap { return &treap{rd: uint(time.Now().UnixNano())/2 + 1} }\n\nfunc (o *node) cmp(a int) int {\n\tb := o.key\n\tif a == b {\n\t\treturn -1\n\t}\n\tif a < b {\n\t\treturn 0\n\t}\n\treturn 1\n}\n\nfunc (t *treap) get(key int) *node {\n\tfor o := t.root; o != nil; {\n\t\tif c := o.cmp(key); c >= 0 {\n\t\t\to = o.lr[c]\n\t\t} else {\n\t\t\treturn o\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (t *treap) min() (min *node) {\n\tfor o := t.root; o != nil; o = o.lr[0] {\n\t\tmin = o\n\t}\n\treturn\n}\n\nfunc (t *treap) max() (max *node) {\n\tfor o := t.root; o != nil; o = o.lr[1] {\n\t\tmax = o\n\t}\n\treturn\n}\n\nfunc (t *treap) lowerBound(key int) (lb *node) {\n\tfor o := t.root; o != nil; {\n\t\tswitch c := o.cmp(key); {\n\t\tcase c == 0:\n\t\t\tlb = o\n\t\t\to = o.lr[0]\n\t\tcase c > 0:\n\t\t\to = o.lr[1]\n\t\tdefault:\n\t\t\treturn o\n\t\t}\n\t}\n\treturn // NOTE: check nil\n}\n\nfunc (t *treap) prev(key int) (prev *node) {\n\tfor o := t.root; o != nil; {\n\t\tif o.cmp(key) <= 0 {\n\t\t\to = o.lr[0]\n\t\t} else {\n\t\t\tprev = o\n\t\t\to = o.lr[1]\n\t\t}\n\t}\n\treturn // NOTE: check nil\n}\n\nfunc (t *treap) next(key int) (next *node) {\n\tfor o := t.root; o != nil; {\n\t\tif o.cmp(key) == 0 {\n\t\t\tnext = o\n\t\t\to = o.lr[0]\n\t\t} else {\n\t\t\to = o.lr[1]\n\t\t}\n\t}\n\treturn // NOTE: check nil\n}\n\nfunc getResults(qs [][]int) (ans []bool) {\n\tset := newTreap()\n\tmx := 0\n\tfor _, q := range qs {\n\t\tmx = max(mx, q[1])\n\t}\n\tt := newSegmentTree(make([]int, mx+2))\n\tset.put(0)\n\tset.put(mx+1)\n\tadd := func(x int) {\n\t\tif x == 0 {\n\t\t\treturn\n\t\t}\n\t\tset.put(x)\n\t\tnx := set.next(x)\n\t\tpr := set.prev(x)\n\t\tt.update(1, nx.key, nx.key - x)\n\t\tt.update(1, x, x - pr.key)\n\t}\n\tadd(mx)\n\tfor _, q := range qs {\n\t\tx := q[1]\n\t\tif q[0] == 1 {\n\t\t\tadd(x)\n\t\t} else {\n\t\t\tsz := q[2]\n\t\t\tm := t.query(1, 0, x)\n\t\t\tpr := set.prev(x)\n\t\t\tm = max(m, x - pr.key)\n\t\t\tans = append(ans, m >= sz)\n\t\t}\n\t}\n\n\treturn\n}\n",
    "submit_ts": "1716648561",
    "subm_id": "534762215"
}