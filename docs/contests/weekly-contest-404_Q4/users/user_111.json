{
    "username": "cmgabriellucas",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        vector<int> dist;\n        function<void(int,int,vector<vector<int>>&)> dfs = [&] (int u, int p, vector<vector<int>>& g) {\n              for (auto v : g[u]) {\n                  if (v == p) continue;\n                  dist[v] = dist[u] + 1;\n                  dfs(v, u, g);\n              }\n        };\n        int ans = 0;\n        auto findCenter = [&] (int k, vector<vector<int>> edg) {\n            vector<vector<int>> graph(k);\n            for (auto x : edg) graph[x[0]].push_back(x[1]), graph[x[1]].push_back(x[0]);\n            dist.resize(k+1);\n            for (int i = 0; i < k; ++i) dist[i] = 0;\n            dfs(0, 0, graph);\n            int ponta = 0, mx = 0;\n            for (int i = 1; i < k; ++i) {\n                if (mx < dist[i]) mx = dist[i], ponta = i;\n            }\n            for (int i = 0; i < k; ++i) dist[i] = 0;\n            dfs(ponta, ponta, graph);\n            for (int i = 0; i < k; ++i) mx = max(mx, dist[i]);\n            ans = max(ans, mx);\n            return (mx+1)/2;\n            \n        };\n        int n = edges1.size()+1, m = edges2.size()+1;\n        return max(ans, findCenter(n, edges1)+findCenter(m, edges2)+1);\n        \n    }\n};",
    "submit_ts": "1719716604",
    "subm_id": "1304369039"
}