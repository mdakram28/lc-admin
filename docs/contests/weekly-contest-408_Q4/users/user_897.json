{
    "username": "ayush_gupta4",
    "submission": "class Solution {\npublic:\n    bool solve(int width, int height, vector<vector<int>>& circles) {\n        int numCircles = circles.size();\n        vector<vector<bool>> graph(numCircles + 4, vector<bool>(numCircles + 4, false));\n\n        for (int i = 0; i < numCircles; i++) {\n            int x = circles[i][0];\n            int y = circles[i][1];\n            int radius = circles[i][2];\n\n            if (x <= radius) {\n                graph[numCircles][i] = true;\n                graph[i][numCircles] = true;\n            }\n            if (width - x <= radius) {\n                graph[numCircles + 2][i] = true;\n                graph[i][numCircles + 2] = true;\n            }\n            if (y <= radius) {\n                graph[numCircles + 1][i] = true;\n                graph[i][numCircles + 1] = true;\n            }\n            if (height - y <= radius) {\n                graph[numCircles + 3][i] = true;\n                graph[i][numCircles + 3] = true;\n            }\n\n            for (int j = i + 1; j < numCircles; j++) {\n                int otherX = circles[j][0];\n                int otherY = circles[j][1];\n                int otherRadius = circles[j][2];\n\n                double distance = sqrt(pow(x - otherX, 2) + pow(y - otherY, 2));\n                int radiusSum = radius + otherRadius;\n\n                if (radiusSum >= distance) {\n                    graph[i][j] = true;\n                    graph[j][i] = true;\n                }\n            }\n        }\n\n        bool isBlocked = false;\n\n        isBlocked |= bfs(graph, numCircles, numCircles + 1, numCircles + 2, numCircles + 4);\n        isBlocked |= bfs(graph, numCircles + 3, numCircles + 2, numCircles + 1, numCircles + 4);\n\n        return !isBlocked;\n    }\n\n    bool bfs(vector<vector<bool>>& graph, int start, int target1, int target2, int numNodes) {\n        queue<int> q;\n        vector<bool> visited(numNodes + 4, false);\n\n        q.push(start);\n        visited[start] = true;\n\n        while (!q.empty()) {\n            int current = q.front();\n            q.pop();\n            for (int neighbor = 0; neighbor < graph.size(); neighbor++) {\n                if (graph[current][neighbor] && !visited[neighbor]) {\n                    q.push(neighbor);\n                    visited[neighbor] = true;\n                }\n            }\n        }\n\n        return visited[target1] || visited[target2];\n    }\n\n    bool canReachCorner(int width, int height, vector<vector<int>>& circles) {\n        return solve(width, height, circles);\n    }\n};\n\n",
    "submit_ts": "1722138896",
    "subm_id": "1335802494"
}