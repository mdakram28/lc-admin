{
    "username": "glump1",
    "submission": "#SEG TREE (Implicit Prop)\nclass SegmentTree:\n    def __init__(self, input_arr):\n        n = 1<<(len(input_arr).bit_length()-1)\n        if n < len(input_arr): n<<=1\n        self.n = n\n        self.arr = [0]*n + input_arr + [0]*(n-len(input_arr))\n        self.pend = [0]*(n*2)\n        for i in range(n-1,0,-1):\n            self.arr[i] = self.arr[i*2]+self.arr[i*2+1]\n            \n    def flush_pending(self):\n        n = self.n\n        for i in range(n):\n            self.pend[i*2]+=self.pend[i]\n            self.pend[i*2+1]+=self.pend[i]\n        for i in range(n, n*2):\n            self.arr[i]+=self.pend[i]\n        self.pend = [0]*(n*2)\n        for i in range(n-1, 0, -1):\n            self.arr[i] = self.arr[i*2]+self.arr[i*2+1]\n            \n    __list__ = lambda self: self.flush_pending() or self.arr[-self.n:]\n    __str__ = lambda self: str(self.__list__())\n    \n    def update(self, l, r, x):\n        st = [(1, l, r, self.n)]\n        while st:\n            u, l, r, n = st.pop()\n            l = max(0, l)\n            r = min(n, r)\n            if r-l==n:\n                self.pend[u]+=x\n                continue\n            else:\n                self.arr[u]+=(x*(r-l))\n            n//=2\n            if l<n:\n                st.append((u*2, l, r, n))\n            if r>n:\n                st.append((u*2+1, l-n, r-n, n))\n            \n        \n    def query(self, l, r):\n        res = 0\n        st = [(1, l, r, self.n)]\n        while st:\n            u, l, r, n = st.pop()\n            self.arr[u]+=self.pend[u]*n\n            if n != 1:\n                self.pend[u*2]+=self.pend[u]\n                self.pend[u*2+1]+=self.pend[u]\n            self.pend[u]=0\n            l = max(0, l)\n            r = min(n, r)\n            if r-l==n:\n                res+=self.arr[u]\n                continue\n            n//=2\n            if l<n:\n                st.append((u*2, l, r, n))\n            if r>n:\n                st.append((u*2+1, l-n, r-n, n))\n        return res\n\n\nclass Solution:\n    def minChanges(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        #If all are already equal\n        if len({abs(nums[i]-nums[n-1-i]) for i in range(n//2)}) == 1: return 0\n        #Cost to create differences\n        cost = SegmentTree([n]*(k+1))\n        def add(x1, x2):\n            y = abs(x2-x1)\n            if x1>x2:\n                x1, x2 = x2, x1\n            pivot = max(x2, k-x1)\n            cost.update(0, pivot+1, -1)\n            #Take out y\n            cost.update(y, y+1, -1)\n            # print(cost.__list__()[:k]+1)\n        for i in range(n//2):\n            x1, x2 = nums[i], nums[n-1-i]\n            add(x1, x2)\n        return min(cost.__list__()[:k+1])",
    "submit_ts": "1721488863",
    "subm_id": "1327435523"
}