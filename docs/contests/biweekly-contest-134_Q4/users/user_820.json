{
    "username": "codacian",
    "submission": "class Solution {\npublic:\n    // Function to build the segment tree\n    void buildSegmentTree(vector<long long>& segmentTree, const vector<int>& arr, int start, int end, int node) {\n        if (start == end) {\n            segmentTree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            buildSegmentTree(segmentTree, arr, start, mid, 2 * node + 1);\n            buildSegmentTree(segmentTree, arr, mid + 1, end, 2 * node + 2);\n            segmentTree[node] = segmentTree[2 * node + 1] & segmentTree[2 * node + 2];\n        }\n    }\n\n    // Function to query the segment tree for the range AND\n    long long rangeAND(const vector<long long>& segmentTree, int start, int end, int L, int R, int node) {\n        if (R < start || L > end) {\n            return ~0LL; // Return all bits set (neutral value for AND)\n        }\n        if (L <= start && R >= end) {\n            return segmentTree[node];\n        }\n        int mid = (start + end) / 2;\n        long long leftAND = rangeAND(segmentTree, start, mid, L, R, 2 * node + 1);\n        long long rightAND = rangeAND(segmentTree, mid + 1, end, L, R, 2 * node + 2);\n        return leftAND & rightAND;\n    }\n\n    // Binary search for the first index where the AND equals k\n    int findFirstIndex(const vector<long long>& segmentTree, int n, int start, long long k) {\n        int L = start, R = n - 1, result = -1;\n        while (L <= R) {\n            int mid = L + (R - L) / 2;\n            int res =rangeAND(segmentTree, 0, n - 1, start, mid, 0);\n            if (res <= k) {\n                if(res == k)\n                result = mid;\n                R = mid - 1;\n            } else {\n                L = mid + 1;\n            }\n        }\n        return result;\n    }\n\n    // Binary search for the last index where the AND equals k\n    int findLastIndex(const vector<long long>& segmentTree, int n, int start, long long k) {\n        int L = start, R = n - 1, result = -1;\n        while (L <= R) {\n            int mid = L + (R - L) / 2;\n            int res = rangeAND(segmentTree, 0, n - 1, start, mid, 0);\n            if (res >= k) {\n                if(res == k)\n                result = mid;\n                L = mid + 1;\n            } else {\n                R = mid - 1;\n            }\n        }\n        return result;\n    }\n\n    long long countSubarrays(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<long long> segmentTree(4 * n);\n        buildSegmentTree(segmentTree, nums, 0, n - 1, 0);\n\n        long long count = 0;\n        for (int i = 0; i < n; ++i) {\n            int firstIndex = findFirstIndex(segmentTree, n, i, k);\n            // cout<<firstIndex<<\" \";\n            if (firstIndex != -1) {\n                int lastIndex = findLastIndex(segmentTree, n, i, k);\n                count += (lastIndex - firstIndex + 1);\n                // cout<<lastIndex<<\"\\n\";\n            }\n            else\n                cout<<\"\\n\";\n        }\n        // cout<<rangeAND(segmentTree, 0, n - 1, 1, 1, 0)<<\"\\n\";\n        return count;\n    }\n};\n",
    "submit_ts": "1720279168",
    "subm_id": "1311740322"
}