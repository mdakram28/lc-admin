{
    "username": "baegopayo",
    "submission": "\n/////////////////////////////// Preface ///////////////////////////////\n// utility functions\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\n\n// typedef\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef tuple<int, int, int> ti3;\ntypedef tuple<int, int, int, int> ti4;\ntypedef tuple<int, int, int, int, int> ti5;\ntypedef tuple<ll, ll, ll> tll3;\ntypedef tuple<ll, ll, ll, ll> tll4;\ntypedef tuple<ll, ll, ll, ll, ll> tll5;\ntypedef vector<pll> vpll;\ntypedef array<int, 3> ai3;\ntypedef array<ll, 3> all3;\ntypedef array<ll, 4> all4;\ntypedef array<ll, 5> all5;\ntypedef vector<all3> vall3;\ntypedef vector<all4> vall4;\ntypedef vector<all5> vall5;\ntypedef pair<ld, ld> pld;\ntypedef vector<pld> vpld;\ntypedef vector<ld> vld;\ntypedef vector<ll> vll;\ntypedef vector<ull> vull;\ntypedef vector<vll> vvll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<bool> vb;\ntypedef deque<ll> dqll;\ntypedef deque<pll> dqpll;\ntypedef pair<string, string> pss;\ntypedef vector<pss> vpss;\ntypedef vector<string> vs;\ntypedef vector<vs> vvs;\ntypedef unordered_set<ll> usll;\n// typedef unordered_set<pll, PairHash> uspll;\ntypedef unordered_map<ll, ll> umll;\n// typedef unordered_map<pll, ll, PairHash> umpll;\n\n// macros\n#define X first\n#define Y second\n\nvoid _p(int x) { cout << x; }\nvoid _p(long x) { cout << x; }\nvoid _p(long long x) { cout << x; }\nvoid _p(unsigned x) { cout << x; }\nvoid _p(unsigned long x) { cout << x; }\nvoid _p(unsigned long long x) { cout << x; }\nvoid _p(float x) { cout << x; }\nvoid _p(double x) { cout << x; }\nvoid _p(long double x) { cout << x; }\nvoid _p(char x) { cout << '\\'' << x << '\\''; }\nvoid _p(const char *x) { cout << '\\\"' << x << '\\\"'; }\nvoid _p(const string &x) { cout << '\\\"' << x << '\\\"'; }\nvoid _p(bool x) { cout << (x ? \"true\" : \"false\"); }\ntemplate <typename A> void _p(const A &x) {\n  bool first = true;\n  cout << '{';\n  for (const auto &i : x) {\n    cout << (first ? \"\" : \",\"), _p(i);\n    first = false;\n  }\n  cout << '}';\n}\ntemplate <typename A, typename B> void _p(const pair<A, B> &p) {\n  cout << '(';\n  _p(p.first);\n  cout << ',';\n  _p(p.second);\n  cout << ')';\n}\ntemplate <typename... A> void _p(const tuple<A...> &t) {\n  bool first = true;\n  cout << '(';\n  apply(\n      [&first](const auto &...args) {\n        ((cout << (first ? \"\" : \",\"), _p(args), first = false), ...);\n      },\n      t);\n  cout << ')';\n}\nvoid _pt(const initializer_list<ll> &t) { _p(tuple(t)); }\ntemplate <typename T> void _p(stack<T> s) {\n  vector<T> debugVector;\n  while (!s.empty()) {\n    T t = s.top();\n    debugVector.push_back(t);\n    s.pop();\n  }\n  reverse(debugVector.begin(), debugVector.end());\n  _p(debugVector);\n}\ntemplate <typename T> void _p(queue<T> q) {\n  vector<T> debugVector;\n  while (!q.empty()) {\n    T t = q.front();\n    debugVector.push_back(t);\n    q.pop();\n  }\n  _p(debugVector);\n}\ntemplate <typename T, typename... U> void _p(priority_queue<T, U...> q) {\n  vector<T> debugVector;\n  while (!q.empty()) {\n    T t = q.top();\n    debugVector.push_back(t);\n    q.pop();\n  }\n  _p(debugVector);\n}\nvoid __p() { cout << \"]\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid __p(const Head &H, const Tail &...T) {\n  _p(H);\n  if (sizeof...(T))\n    cout << \", \";\n  __p(T...);\n}\n#ifndef ONLINE_JUDGE\n#define debug(...)                                                             \\\n  cout << \"Line:\" << __LINE__ << \" [\" << #__VA_ARGS__ << \"] = [\";              \\\n  __p(__VA_ARGS__);\n#else\n#define debug(...)\n#endif\n\n#define rep(i, m, n) for (ll i = m; i < n; i++)\n\ntemplate <typename T> void _pn(T &&t) { cout << t << \"\\n\"; }\ntemplate <typename T> void _pv(vector<T> v) {\n  ll n = v.size();\n  rep(i, 0, n) {\n    _p(v[i]);\n    if (i + 1 != n)\n      cout << ' ';\n  }\n  cout << endl;\n}\ntemplate <typename T> void _pvv(vector<vector<T>> v) {\n  ll n = v.size();\n  rep(i, 0, n) _pv(v[i]);\n}\ntemplate <typename T> void _pvln(vector<T> v) {\n  ll n = v.size();\n  rep(i, 0, n) cout << v[i] << endl;\n}\n/////////////////////////////// Preface ///////////////////////////////\n\n/*\n1.  ex\n2.  req\n3.  bf\nall subarr\n4.  obs\n5.  opt\n?   subp?\n?   slide?\nbit->zeros, has one.\n6.  impl\n7.  ts\n*/\n\nclass Solution {\npublic:\n  int minimumDifference(vector<int> &nums, int k) {\n    int n = nums.size();\n    array<int, 32> zeros{}, ones{};\n    int r = 0, ans = INT_MAX, val = -1;\n    for (int l = 0; l < n; ++l) {        \n      // add r, while >k\n      for (; r < n && (val == -1 || val > k); ++r) {\n        int rnum = nums[r];\n        val &= rnum;\n        for (int b = 0; b < 32; ++b)\n          if ((rnum >> b) & 1)\n            ++ones[b];\n          else\n            ++zeros[b];\n        ans = min(ans, abs(k - val));\n      // _p(tuple{l,r,val});\n      }\n      // rm l\n      if (l + 1 == r) {\n        zeros = array<int, 32>();\n        ones = array<int, 32>();\n        val = -1;\n        continue;\n      }\n      auto lnum = nums[l];\n      for (int b = 0; b < 32; ++b) {\n        if ((lnum >> b) & 1)\n          --ones[b];\n        else\n          --zeros[b];\n        if (!zeros[b] && ones[b])\n          val |= 1 << b;\n      }\n        // _p(tuple{l,r,val});\n      ans = min(ans, abs(k - val));\n    }\n    return ans;\n  }\n};",
    "submit_ts": "1717299701",
    "subm_id": "1274821123"
}