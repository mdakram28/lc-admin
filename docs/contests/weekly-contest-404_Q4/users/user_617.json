{
    "username": "nevergiveup",
    "submission": "class Solution {\n\n    private int[] maxDist1 , maxDist2;\n    private int[] dist1 , dist2;\n    private static List<Integer>[] graph = new ArrayList[100010];\n\n    static {\n        for (int i = 0;i < 100010;i ++) {\n            graph[i] = new ArrayList<>();\n        }\n    }\n\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        // handle graph1\n        maxDist1 = new int[edges1.length + 1];\n        dist1 = new int[edges1.length + 1];\n        for (int i = 0;i < graph.length;i ++) {\n            graph[i].clear();\n        }\n        for (int[] edge : edges1) {\n            int u = edge[0] , v = edge[1];\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n        buildDist(0 , - 1 , dist1);\n        build(0 , - 1 , 0 , dist1 , maxDist1);\n        // handle graph2\n        maxDist2 = new int[edges2.length + 1];\n        dist2 = new int[edges2.length + 1];\n        for (int i = 0;i < graph.length;i ++) {\n            graph[i].clear();\n        }\n        for (int[] edge : edges2) {\n            int u = edge[0] , v = edge[1];\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n        buildDist(0 , - 1 , dist2);\n        build(0 , - 1 , 0 , dist2 , maxDist2);\n        // get result\n        int ans = 0 , min1 = Integer.MAX_VALUE , min2 = Integer.MAX_VALUE;\n        for (int i = 0;i < maxDist1.length;i ++) {\n            ans = Math.max(ans , maxDist1[i]);\n            min1 = Math.min(min1 , maxDist1[i]);\n        }\n        for (int i = 0;i < maxDist2.length;i ++) {\n            ans = Math.max(ans , maxDist2[i]);\n            min2 = Math.min(min2 , maxDist2[i]);\n        }\n        ans = Math.max(ans , min1 + min2 + 1);\n        return ans;\n    }\n\n    private void build(int cur , int parent , int otherMaxDist , int[] dist , int[] maxDist) {\n        maxDist[cur] = Math.max(dist[cur] , otherMaxDist);\n        List<Integer> nextList = new ArrayList<>();\n        for (int next : graph[cur]) {\n            if (next != parent) {\n                nextList.add(next);\n            }\n        }\n        int[] prefix = new int[nextList.size()] , suffix = new int[nextList.size()];\n        // build prefix and suffix\n        for (int i = 0;i < nextList.size();i ++) {\n            prefix[i] = dist[nextList.get(i)];\n            if (i > 0) {\n                prefix[i] = Math.max(prefix[i - 1] , prefix[i]);\n            }\n        }\n        for (int i = nextList.size() - 1;i >= 0;i --) {\n            suffix[i] = dist[nextList.get(i)];\n            if (i + 1 < nextList.size()) {\n                suffix[i] = Math.max(suffix[i] , suffix[i + 1]);\n            }\n        }\n        // check next\n        for (int i = 0;i < nextList.size();i ++) {\n            int next = nextList.get(i);\n            int tmp = otherMaxDist + 1;\n            if (i - 1 >= 0) {\n                tmp = Math.max(tmp , prefix[i - 1] + 2);\n            }\n            if (i + 1 < nextList.size()) {\n                tmp = Math.max(tmp , suffix[i + 1] + 2);\n            }\n            build(next , cur , tmp , dist , maxDist);\n        }\n    }\n\n    private void buildDist(int cur , int parent , int[] dist) {\n        for (int next : graph[cur]) {\n            if (next != parent) {\n                buildDist(next , cur , dist);\n                dist[cur] = Math.max(dist[cur] , dist[next] + 1);\n            }\n        }\n    }\n\n\n}",
    "submit_ts": "1719719303",
    "subm_id": "1304438642"
}