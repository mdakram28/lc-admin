{
    "username": "PyIsTheBestLang",
    "submission": "def max(a, b):\n    return a if a > b else b\n\n\ndef min(a, b):\n    return a if a < b else b\n\n\nclass UnionFind:\n    def __init__(self, n: int) -> None:\n        self.root_or_size = [-1] * n\n        self.part = n\n        self.n = n\n        return\n\n    def initialize(self):\n        for i in range(self.n):\n            self.root_or_size[i] = -1\n        self.part = self.n\n        return\n\n    def find(self, x):\n        y = x\n        while self.root_or_size[x] >= 0:\n            # range_merge_to_disjoint to the direct root node after query\n            x = self.root_or_size[x]\n        while y != x:\n            self.root_or_size[y], y = x, self.root_or_size[y]\n        return x\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        if self.root_or_size[root_x] < self.root_or_size[root_y]:\n            root_x, root_y = root_y, root_x\n        self.root_or_size[root_y] += self.root_or_size[root_x]\n        self.root_or_size[root_x] = root_y\n        self.part -= 1\n        return True\n\n    def union_left(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        self.root_or_size[root_x] += self.root_or_size[root_y]\n        self.root_or_size[root_y] = root_x\n        self.part -= 1\n        return True\n\n    def union_right(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        self.root_or_size[root_y] += self.root_or_size[root_x]\n        self.root_or_size[root_x] = root_y\n        self.part -= 1\n        return True\n\n    def union_max(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        if root_x > root_y:\n            root_x, root_y = root_y, root_x\n        self.root_or_size[root_y] += self.root_or_size[root_x]\n        self.root_or_size[root_x] = root_y\n        self.part -= 1\n        return\n\n    def union_min(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        if root_x < root_y:\n            root_x, root_y = root_y, root_x\n        self.root_or_size[root_y] += self.root_or_size[root_x]\n        self.root_or_size[root_x] = root_y\n        self.part -= 1\n        return\n\n    def is_connected(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return -self.root_or_size[self.find(x)]\n\n    def get_root_part(self):\n        # get the nodes list of every root\n        part = defaultdict(list)\n        n = len(self.root_or_size)\n        for i in range(n):\n            part[self.find(i)].append(i)\n        return part\n\n    def get_root_size(self):\n        # get the size of every root\n        size = defaultdict(int)\n        n = len(self.root_or_size)\n        for i in range(n):\n            if self.find(i) == i:\n                size[i] = -self.root_or_size[i]\n        return size\n\n\nclass Solution:\n    def minFlips(self, grid: List[List[int]]) -> int:\n\n        m, n = len(grid), len(grid[0])\n        uf = UnionFind(m * n)\n        for i in range(m):\n            for j in range(n // 2 + 1):\n                uf.union(i * n + j, i * n + n - 1 - j)\n\n        for j in range(n):\n            for i in range(m // 2 + 1):\n                uf.union(i * n + j, (m - 1 - i) * n + j)\n        \n        group = uf.get_root_part()\n        pre = [[0], [0, inf, inf, inf]]\n        lst = [(0, 0), (1, 0), (1, 1), (1, 2), (1, 3)]\n        for g in group:\n            cnt = [0, 0]\n            for x in group[g]:\n                cnt[grid[x//n][x%n]] += 1\n            \n            tmp = [(0, 0, cnt[1]), (1, sum(cnt)%4, cnt[0])]\n            cur = [[inf], [inf, inf, inf, inf]]\n            for x, y in lst:\n                for a, b, cost in tmp:\n                    if x == a == 0:\n                        cur[x][y] = min(cur[x][y], cost+pre[x][y])\n                    else:\n                        cur[1][(y+b)%4] = min(cur[1][(y+b)%4], cost+pre[x][y])\n            pre = [ls[:] for ls in cur]\n            \n        ans = min(pre[0][0], pre[1][0])\n        return ans",
    "submit_ts": "1722696440",
    "subm_id": "552260957"
}