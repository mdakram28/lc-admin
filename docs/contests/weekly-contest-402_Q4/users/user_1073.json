{
    "username": "alt69",
    "submission": "\n\nclass Solution {\npublic:\n\n    class SegmentTree {\n    public:\n        SegmentTree(const vector<int>& pk) {\n            int n = pk.size();\n            data.resize(4 * n);\n            build(pk, 0, 0, n - 1);\n        }\n\n        void build(const vector<int>& pk, int node, int start, int end) {\n            if (start == end) {\n                data[node] = pk[start];\n            } else {\n                int mid = (start + end) / 2;\n                build(pk, 2 * node + 1, start, mid);\n                build(pk, 2 * node + 2, mid + 1, end);\n                data[node] = data[2 * node + 1] + data[2 * node + 2];\n            }\n        }\n\n        void update(int idx, int val, int node, int start, int end) {\n            if (start == end) {\n                data[node] = val;\n            } else {\n                int mid = (start + end) / 2;\n                if (idx <= mid) {\n                    update(idx, val, 2 * node + 1, start, mid);\n                } else {\n                    update(idx, val, 2 * node + 2, mid + 1, end);\n                }\n                data[node] = data[2 * node + 1] + data[2 * node + 2];\n            }\n        }\n\n        int query(int l, int r, int node, int start, int end) {\n            if (r < start || l > end) {\n                return 0;\n            }\n            if (l <= start && r >= end) {\n                return data[node];\n            }\n            int mid = (start + end) / 2;\n            return query(l, r, 2 * node + 1, start, mid) + query(l, r, 2 * node + 2, mid + 1, end);\n        }\n\n        int query(int l, int r) {\n            if (l > r) return 0;\n            return query(l, r, 0, 0, data.size() / 4 - 1);\n        }\n\n        void update(int idx, int val) {\n            update(idx, val, 0, 0, data.size() / 4 - 1);\n        }\n\n    public:\n        vector<int> data;\n    };\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> pk(n, 0), ans;\n        for (int i = 1; i < n - 1; ++i) { \n            if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) { \n            pk[i] = 1;\n            }\n        }\n\n        SegmentTree segTree(pk);\n\n        for (const auto& q : queries) {\n            if (q[0] == 1) {\n                ans.push_back(segTree.query(q[1] + 1, q[2] - 1));\n            } else if (q[0] == 2) {\n                nums[q[1]] = q[2];\n                segUpdate(nums, pk, segTree, q[1]);\n            }\n        }\n        return ans;\n    }\n\n\n    void segUpdate(vector<int>& nums, vector<int>& pk, SegmentTree& segTree, int idx) {\n        int n = nums.size();\n        for (int i = max(1, idx - 1); i <= min(n - 2, idx + 1); ++i) {\n            int f = (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) ? 1 : 0;\n            if (pk[i] != f) {\n                pk[i] = f;\n                segTree.update(i, f);\n            }\n        }\n    }\n};\n\n\n",
    "submit_ts": 1718508795.0
}