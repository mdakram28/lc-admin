{
    "username": "JeffreyLC",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int diameter1 = GetTreeDiameter(edges1);\n        int diameter2 = GetTreeDiameter(edges2);\n        return max({diameter1, diameter2, (diameter1 + 1) / 2 + 1 + (diameter2 + 1) / 2});\n    }\nprivate:\n    vector<vector<int>> BuildAdjacencyList(int n, const vector<vector<int>>& edges) {\n        vector<vector<int>> adj(n);\n        for (const vector<int>& edge : edges) {\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n        return adj;\n    }\n\n    pair<int, int> FindFurthestNode(int n, int root, const vector<vector<int>>& edges) {\n        vector<vector<int>> adj = BuildAdjacencyList(n, edges);\n        vector<int> dist(n, -1);\n\n        function<void(int, int)> dfs = [&](int x, int p) {\n            for (int y : adj[x]) {\n                if (y == p || dist[y] != -1) continue;\n                dist[y] = dist[x] + 1;\n                dfs(y, x);\n            }\n        };\n\n        dist[root] = 0;\n        dfs(root, -1);\n        \n        int node = 0, max_dist = dist[0];\n        for (int i = 1; i < n; ++i) {\n            if (max_dist < dist[i]) {\n                node = i;\n                max_dist = dist[i];\n            }\n        }\n        return {node, max_dist};\n    }\n    \n    int GetTreeDiameter(const vector<vector<int>>& edges) {\n        pair<int, int> p = FindFurthestNode(edges.size() + 1, 0, edges);\n        return FindFurthestNode(edges.size() + 1, p.first, edges).second;\n    }\n};",
    "submit_ts": 1719717876.0
}