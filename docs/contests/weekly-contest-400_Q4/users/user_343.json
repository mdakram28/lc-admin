{
    "username": "The_2nd_Derivative",
    "submission": "\n#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)\n// trace std::pair\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){\n    return os<<\"{\"<<P.first<<\":\"<<P.second<<\"}\";\n}\n// trace std::vector\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){\n    os<<\"[ \";for(auto v:V)os<<v<<\" \";return os<<\"]\";\n}\n// trace std::map;\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {\n    os<<\"[ \";for(auto& P : MP) os<<P<<\" \";return os<<\"]\";\n}\n// trace unordred_std::map\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {\n    os<<\"[ \";for(auto& P : MP) os<<P<<\" \";return os<<\"]\";\n}\n// trace std::set\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){\n    os<<\"[ \";for(auto s:S)os<<s<<\" \";return os<<\"]\";\n}\n// trace std::unordered_set\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){\n    os<<\"[ \";for(auto s:S)os<<s<<\" \";return os<<\"]\";\n}\n// std::stack FUN\ntemplate<class T> void F_Stack(std::stack<T> st, std::string& cont) { \n    if(st.empty()) return;\n    T mem=st.top();st.pop();F_Stack(st,cont);cont+=\" \"+to_string(mem);  \n}\n// trace std::stack                                                  \ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {\n    os<<\"[\";std::string cont=\"\";F_Stack(st,cont);return os<<cont<<\" ]\";\n}\n// track std::queue\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {\n    os<<\"[ \";while(!q.empty()) os<<q.front()<<\" \",q.pop();return os<<\"]\";\n}\n\n// for last arg.\ntemplate<typename Arg1>\nvoid __f(const char* name,Arg1&& arg1){\n    std::cout<<name<<\" : \"<<arg1<<std::endl;\n}\n// for variable arg\ntemplate <typename Arg1,typename... Args>\nvoid __f(const char* names,Arg1&& arg1,Args&&... args){\n    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<\" : \"<<arg1<<\" | \";__f(comma+1,args...);\n}\n\n// dbg std::array\ntemplate<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){\n    os<<\"[ \";for(auto v:V)os<<v<<\" \";return os<<\"]\";\n}\n\n// X.find_by_order(k) return iterator to kth element. 0 indexed.\n// X.order_of_key(k) returns count of elements strictly less than k.\n\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// template <class T>\n// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define sz(x) ((ll)(x).size())\n#define nl '\\n'\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n \nusing ll = long long int;\nusing pii = pair<ll,ll>;\nusing mii = map<ll,ll>;\nusing umii = unordered_map<ll,ll>;\nusing vi = vector<int>;\nusing vii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvii = vector<vii>;\n\ntemplate<class T> bool chmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool chmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nconst ll INF = 1e18;\nconst ll N = 1e5+5;\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        ll n = sz(nums);\n        ll ans = INF;\n        \n        vvi cnt(n, vi(32,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<31;j++){\n                cnt[i][j]=(nums[i]>>j&1);\n                if(i>0)\n                    cnt[i][j]+=cnt[i-1][j];\n            }\n        }\n        \n        auto get = [&](int low, int high){\n            ll res=0;\n            for(int j=0;j<31;j++){\n                ll x=cnt[high][j];\n                if(low>0)\n                    x-=cnt[low-1][j];\n                if(x==high-low+1)\n                    res|=(1<<j);\n            }\n            return res;\n        };\n            \n        for(int i=0;i<n;i++){\n            if(nums[i]<=k){\n                chmin(ans, 1ll*k-nums[i]);\n                continue;\n            }\n            else{\n                ll low=0, high=i;\n                while(low<=high){\n                    ll mi = (low+high)/2;\n                    ll val=get(mi,i);\n                    if(val>=k){\n                        chmin(ans, val-k);\n                        high = mi-1;\n                    }\n                    else{\n                        low = mi+1;\n                    }\n                }\n                \n                low=0, high=i;\n                while(low<=high){\n                    ll mi = (low+high)/2;\n                    ll val=get(mi,i);\n                    if(val<=k){\n                        chmin(ans,1ll*k-val);\n                        low = mi+1;\n                    }\n                    else{\n                        high = mi-1;\n                    }\n                }\n            }\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": "1717298130",
    "subm_id": "1274768403"
}