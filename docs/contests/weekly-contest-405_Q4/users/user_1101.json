{
    "username": "TheCleanser",
    "submission": "#define N 200009\n\ntypedef long long int ll;\n\nconstexpr uint64_t mod = (1ULL << 61) - 1;\n \nconst uint64_t seed = chrono::system_clock::now().time_since_epoch().count();\nconst uint64_t base = mt19937_64(seed)() % (mod / 3) + (mod / 3);\n\nuint64_t base_pow[N];\n \nint64_t modmul(uint64_t a, uint64_t b){\n    uint64_t l1 = (uint32_t)a, h1 = a >> 32, l2 = (uint32_t)b, h2 = b >> 32;\n    uint64_t l = l1 * l2, m = l1 * h2 + l2 * h1, h = h1 * h2;\n    uint64_t ret = (l & mod) + (l >> 61) + (h << 3) + (m >> 29) + (m << 35 >> 3) + 1;\n    ret = (ret & mod) + (ret >> 61);\n    ret = (ret & mod) + (ret >> 61);\n    return ret - 1;\n}\n \nvoid init(){\n    base_pow[0] = 1;\n    for (int i = 1; i < N; i++){\n        base_pow[i] = modmul(base_pow[i - 1], base);\n    }\n}\n \nstruct PolyHash{\n    /// Remove suff vector and usage if reverse hash is not required for more speed\n    vector<int64_t> pref, suff;\n \n    PolyHash() {}\n \n    template <typename T>\n    PolyHash(const vector<T>& ar){\n        if (!base_pow[0]) init();\n \n        int n = ar.size();\n        assert(n < N);\n        pref.resize(n + 3, 0), suff.resize(n + 3, 0);\n \n        for (int i = 1; i <= n; i++){\n            pref[i] = modmul(pref[i - 1], base) + ar[i - 1] + 997;\n            if (pref[i] >= mod) pref[i] -= mod;\n        }\n \n        for (int i = n; i >= 1; i--){\n            suff[i] = modmul(suff[i + 1], base) + ar[i - 1] + 997;\n            if (suff[i] >= mod) suff[i] -= mod;\n        }\n    }\n \n    PolyHash(const char* str)\n            : PolyHash(vector<char> (str, str + strlen(str))) {}\n \n    uint64_t get_hash(int l, int r){\n        int64_t h = pref[r + 1] - modmul(base_pow[r - l + 1], pref[l]);\n        return h < 0 ? h + mod : h;\n    }\n \n    uint64_t rev_hash(int l, int r){\n        int64_t h = suff[l + 1] - modmul(base_pow[r - l + 1], suff[r + 2]);\n        return h < 0 ? h + mod : h;\n    }\n};\n\n\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int n = target.length(); int m = words.size();\n        map<string, ll> mp; struct PolyHash t_hash(vector<char>(target.begin(), target.end()));\n        \n        vector<string> w; vector<ll> c;\n        for(int i = 0; i < m; i++){\n            if(mp.count(words[i])){\n                mp[words[i]] = min(mp[words[i]], (ll) costs[i]);\n            }\n            else{\n                mp[words[i]] = costs[i];\n            }\n        }\n        \n        ll NN = mp.size();\n        \n        for(auto it: mp){\n            w.push_back(it.first);\n            c.push_back(it.second);\n        }\n\n        ll dp[n]; \n        struct PolyHash hashes[NN];\n        for(int i = 0; i < NN; i++){\n            vector<char> v(w[i].begin(), w[i].end());\n            struct PolyHash hash(v);\n            hashes[i] = hash;\n        }\n        \n        for(int i = 0; i < n; i++){\n            ll best = INT_MAX;\n            for(int j = 0; j < NN; j++){\n                if(w[j].length() <= i + 1){\n                    int f = i - w[j].length() + 1;\n                    if(t_hash.get_hash(f, i) == hashes[j].get_hash(0, w[j].length() - 1) && (f == 0 || dp[f - 1] != -1)){\n                        best = min(best, c[j] + (f == 0 ? 0LL : dp[f - 1]));\n                    }\n                }\n            }\n            dp[i] = best == INT_MAX ? -1 : best;\n        }\n        \n        return dp[n - 1];\n    }\n};",
    "submit_ts": "1720323740",
    "subm_id": "1312382892"
}