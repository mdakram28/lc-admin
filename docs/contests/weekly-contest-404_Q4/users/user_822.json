{
    "username": "parag776",
    "submission": "const auto exclusive = [](const auto& a, const auto& base, const auto& merge_into, int vertex) {\n    int n = (int)a.size();\n    using Aggregate = std::decay_t<decltype(base)>;\n    std::vector<Aggregate> b(n, base);\n    for (int bit = (int)std::__lg(n); bit >= 0; --bit) {\n        for (int i = n - 1; i >= 0; --i) b[i] = b[i >> 1];\n        int sz = n - (n & !bit);\n        for (int i = 0; i < sz; ++i) {\n            int index = (i >> bit) ^ 1;\n            b[index] = merge_into(b[index], a[i], vertex, i);\n        }\n    }\n    return b;\n};\n// MergeInto : Aggregate * Value * Vertex(int) * EdgeIndex(int) -> Aggregate\n// Base : Vertex(int) -> Aggregate\n// FinalizeMerge : Aggregate * Vertex(int) * EdgeIndex(int) -> Value\nconst auto rerooter = [](const auto& g, const auto& base, const auto& merge_into, const auto& finalize_merge) {\n    int n = (int)g.size();\n    using Aggregate = std::decay_t<decltype(base(0))>;\n    using Value = std::decay_t<decltype(finalize_merge(base(0), 0, 0))>;\n    std::vector<Value> root_dp(n), dp(n);\n    std::vector<std::vector<Value>> edge_dp(n), redge_dp(n);\n    \n    std::vector<int> bfs, parent(n);\n    bfs.reserve(n);\n    bfs.push_back(0);\n    for (int i = 0; i < n; ++i) {\n        int u = bfs[i];\n        for (auto v : g[u]) {\n            if (parent[u] == v) continue;\n            parent[v] = u;\n            bfs.push_back(v);\n        }\n    }\n    \n    for (int i = n - 1; i >= 0; --i) {\n        int u = bfs[i];\n        int p_edge_index = -1;\n        Aggregate aggregate = base(u);\n        for (int edge_index = 0; edge_index < (int)g[u].size(); ++edge_index) {\n            int v = g[u][edge_index];\n            if (parent[u] == v) {\n                p_edge_index = edge_index;\n                continue;\n            }\n            aggregate = merge_into(aggregate, dp[v], u, edge_index);\n        }\n        dp[u] = finalize_merge(aggregate, u, p_edge_index);\n    }\n    \n    for (auto u : bfs) {\n        dp[parent[u]] = dp[u];\n        edge_dp[u].reserve(g[u].size());\n        for (auto v : g[u]) edge_dp[u].push_back(dp[v]);\n        auto dp_exclusive = exclusive(edge_dp[u], base(u), merge_into, u);\n        redge_dp[u].reserve(g[u].size());\n        for (int i = 0; i < (int)dp_exclusive.size(); ++i) redge_dp[u].push_back(finalize_merge(dp_exclusive[i], u, i));\n        root_dp[u] = finalize_merge(n > 1 ? merge_into(dp_exclusive[0], edge_dp[u][0], u, 0) : base(u), u, -1);\n        for (int i = 0; i < (int)g[u].size(); ++i) {\n            dp[g[u][i]] = redge_dp[u][i];\n        }\n    }\n\n    return std::make_tuple(std::move(root_dp), std::move(edge_dp), std::move(redge_dp));\n};\n\n\n\nint combine(int nodeDP, int neiDP, int node, int eind){\n    return max(neiDP, nodeDP);\n}\n\nint finalize_merge(int nodeDP, int node, int eind){\n    return nodeDP+1;\n}\n\nint deff(int node){\n    return 0;\n}\n\nclass Solution {\npublic:\n\n\n\n    pair<int,int> dfs(vector<vector<int>> &tree, int pos, int par){\n        pair<int,int> ans(0, pos);\n        for(auto c: tree[pos]){\n            if(c==par) continue;\n            auto x = dfs(tree, c, pos);\n            if(x.first>ans.first){\n                ans = x;\n            }\n        }\n        ans.first++;\n        return ans;\n    }\n\n    int dfs2(vector<vector<int>> &tree, int pos, int par, int prev, int &ans){\n        int cur = 0;\n        for(auto c: tree[pos]){\n            if(c==par) continue;\n            int x = dfs2(tree, c, pos, prev+1, ans);\n            cur = max(x, cur);\n        }\n        cur++;\n        if(max(prev+1, cur)==3){\n            cout<<pos<<endl;\n        }\n        ans = min(ans, max(prev+1, cur));\n        return cur;\n    }\n\n    int getDiameter(vector<vector<int>> &tree){\n        auto x = dfs(tree, 0, -1);\n        x = dfs(tree, x.second, -1);\n        return x.first;\n    }\n    int getMin(vector<vector<int>> &tree){\n        int n = tree.size();\n        if(n==1) return 1;\n        auto [x, a, b] = rerooter(tree, deff, combine, finalize_merge);\n        int ans = INT_MAX;\n        for(int i=0;i<n;i++){\n            ans = min(ans, x[i]);\n        }\n        return ans;\n    }\n\n    vector<vector<int>> create_tree(vector<vector<int>>& edges){\n        int n = edges.size()+1;\n        vector<vector<int>> tree(n);\n        for(int i=0;i<n-1;i++){\n            int a, b;\n            a = edges[i][0];\n            b = edges[i][1];\n            tree[a].push_back(b);\n            tree[b].push_back(a);\n        }\n        return tree;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        auto tree1 = create_tree(edges1);\n        auto tree2 = create_tree(edges2);\n\n        int d1 = getDiameter(tree1);\n        int d2 = getDiameter(tree2);\n        int x1 = getMin(tree1);\n        int x2 = getMin(tree2);\n\n        return max(max(d1, d2), x1+x2)-1;\n\n\n    }\n};",
    "submit_ts": "1719719615",
    "subm_id": "1304446314"
}