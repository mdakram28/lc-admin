{
    "username": "vilmos_prokaj",
    "submission": "def get_diam(edges):\n    n = len(edges)+1\n    # if n < 3:\n    #     return n-1\n    graph = [set() for _ in range(n)]\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n    parent = [-1]*n\n    order = [a for a, out in enumerate(graph) if len(out) == 1]\n    diam = 1\n    i = 0\n    while i < len(order):\n        a = order[i]\n        i += 1\n        if graph[a]:\n            b = graph[a].pop()\n            parent[a] = b\n            graph[b].discard(a)\n            if len(graph[b]) == 1:\n                order.append(b)\n        # print(f\"{order=}\")        \n\n    dist = [[0, 0] for _ in range(n)]\n    # for a in reversed(order):\n    #     if parent[a]!=-1:\n    #         dist[a] = 1+dist[parent[a]]\n    #         radius = max(dist[a], radius)\n    diam = radius = 0 \n    for a in order:\n        b = parent[a]\n        diam0 = dist[a][0]+dist[a][1]\n        if diam0 > diam:\n            diam = diam0\n\n        if b != -1:\n            if dist[a][1]+1 > dist[b][0]:\n                heapq.heapreplace(dist[b], dist[a][1]+1)\n        else:\n            radius = dist[a][1]\n            \n\n    # print(f\"{dist=}, {parent=}, {order=}\")\n    \n    return radius, diam\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        r0, d0 = get_diam(edges1)\n        r1, d1 = get_diam(edges2)\n        return max(r0+r1+1, d0, d1)       ",
    "submit_ts": "1719718645",
    "subm_id": "1304422493"
}