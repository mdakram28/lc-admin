{
    "username": "KarryJodd",
    "submission": "// class Solution {\n//     public long countSubarrays(int[] nums, int k) {\n//         int n = nums.length;\n//         SegmentTree st = new SegmentTree(nums);\n//         long count = 0;\n        \n//         for (int i = 0; i < n; i++) {\n//             int l = i - 1;\n//             int r = n - 1;\n//             int mid;\n            \n//             while (r - l > 1) {\n//                 mid = (l + r) / 2;\n//                 if (st.query(i, mid) >= k) {\n//                     l = mid;\n//                 } else {\n//                     r = mid;\n//                 }\n//             }\n            \n//             if (l != i - 1 && st.query(i, l) == k) {\n//                 count++;\n//             }\n            \n//             if (st.query(i, r) == k) {\n//                 count++;\n//             }\n//         }\n        \n//         return count;\n//     }\n// }\n\n// class SegmentTree {\n//     int[] tree;\n//     int n;\n\n//     public SegmentTree(int[] arr) {\n//         n = arr.length;\n//         tree = new int[4 * n];\n//         build(arr, 0, 0, n - 1);\n//     }\n\n//     public void build(int[] arr, int node, int start, int end) {\n//         if (start == end) {\n//             tree[node] = arr[start];\n//         } else {\n//             int mid = (start + end) / 2;\n//             build(arr, 2 * node + 1, start, mid);\n//             build(arr, 2 * node + 2, mid + 1, end);\n//             tree[node] = tree[2 * node + 1] & tree[2 * node + 2];\n//         }\n//     }\n\n//     public int query(int l, int r) {\n//         return query(0, 0, n - 1, l, r);\n//     }\n\n//     public int query(int node, int start, int end, int l, int r) {\n//         if (r < start || end < l) {\n//             return Integer.MAX_VALUE;\n//         }\n//         if (l <= start && end <= r) {\n//             return tree[node];\n//         }\n//         int mid = (start + end) / 2;\n//         int p1 = query(2 * node + 1, start, mid, l, r);\n//         int p2 = query(2 * node + 2, mid + 1, end, l, r);\n//         return p1 & p2;\n//     }\n// }\n\nclass Solution {\n    public long countSubarrays(int[] nums, int k) {\n        long res = 0;\n        \n        Map<Long, Long> main = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == k) res++;\n\n            Map<Long, Long> hm = new HashMap<>();\n            hm.put((long) nums[i], (long) 1);\n\n            for (Map.Entry<Long, Long> e : main.entrySet()) {\n                long key = e.getKey(), freq = e.getValue();\n                long curr = key & nums[i];\n\n                if (curr == k) res += freq;\n\n                hm.put(curr, hm.getOrDefault(curr, (long) 0) + freq);\n            }\n\n            main = hm;\n        }\n        \n        return res;\n    }\n}\n\nclass Trie {\n    // About trie Data Structure -\n    // This data structure is used to implement the following operations -\n    // 1. insert(word) - to insert a string in trie.\n    // 2. search(word) - to check if word is present in Trie or not.\n    // 3. startsWith(word) - to check if there is any string in the trie that starts with the given prefix string word.\n\n    // Initialise the data structure.\n    // Very similar to generic tree. Just like, we had an array in generic tree in every node, in trie also, we have\n    // an array of 26 length. (Reason - too obvious)\n\n    static class Node{\n        Node[] children;\n        boolean eow;\n\n        public Node() {\n            children = new Node[26];\n            for (int i = 0; i < 26; i++) children[i] = null;\n            eow = false;\n        }\n    }\n\n    static Node root = new Node();\n\n    public static void insert(String word) {\n        Node treeRoot = root;\n        for (int i = 0; i < word.length(); i++) {\n            int idx = word.charAt(i) - 'a';\n\n            if (treeRoot.children[idx] == null) {\n                treeRoot.children[idx] = new Node();\n            }\n\n            if (i == word.length() - 1) {\n                treeRoot.children[idx].eow = true;\n            }\n            treeRoot = treeRoot.children[idx];\n        }\n    }\n\n    public static boolean search(String word) {\n        Node treeRoot = root;\n        for (int i = 0; i < word.length(); i++) {\n            int idx = word.charAt(i) - 'a';\n            if (treeRoot.children[idx] == null) return false;\n            if (i == word.length() - 1) {\n                return treeRoot.children[idx].eow;\n            }\n            treeRoot = treeRoot.children[idx];\n        }\n        return false;\n    }\n\n    public static boolean prefixSearch(String word) {\n        Node treeRoot = root;\n\n        for (int i = 0; i < word.length(); i++) {\n            int idx = word.charAt(i) - 'a';\n            if (treeRoot.children[idx] == null) return false;\n            treeRoot = treeRoot.children[idx];\n        }\n\n        return true;\n    }\n\n    public static int countUniqueSubStrings(String word) {\n        // So, basically in this question, we need to find all the unique substrings of a\n        // given string. This can be done easily because all the unique substrings are just -\n        // \"All Prefix of all Suffix.\"\n\n        // STEPS -\n        // 1. Find all the suffixes of the word.\n        // 2. Make a trie out of these suffixes list.\n        // 3. Find all unique prefixes which is equal to the total number of nodes in trie.\n\n        // Step 1 & 2:\n        String[] suffixes = new String[word.length()];\n        for (int i = 0; i < word.length(); i++) {\n            suffixes[i] = word.substring(i);\n            insert(suffixes[i]);\n        }\n\n        Node treeRoot = root;\n\n        return countNodes(treeRoot);\n    }\n\n    public static int countNodes(Node treeRoot) {\n        if (treeRoot == null) return 0;\n\n        int cnt = 0;\n        for (int i = 0; i < 26; i++) {\n            if (treeRoot.children[i] != null) {\n                cnt += countNodes(treeRoot.children[i]);\n            }\n        }\n        return cnt + 1;\n    }\n}",
    "submit_ts": "1720279097",
    "subm_id": "1311737244"
}