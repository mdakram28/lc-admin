{
    "username": "silvernarcissus",
    "submission": "class Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        DynamicSegmentSumTree tree = new DynamicSegmentSumTree();\n        int n = nums.length;\n        \n        for(int i = 0; i < n; i++){\n            tree.modify(i, i, judge(nums, i));\n            \n            //System.out.println(i + \": \" +  judge(nums, i));\n        }\n        \n        List<Integer> res = new ArrayList<>();\n        for(int[] query : queries){\n            if(query[0] == 1){\n                if(query[1] > query[2] - 2){\n                    res.add(0);\n                }\n                else{\n                    res.add(tree.query(query[1] + 1, query[2] - 1));\n                }\n            }\n            else{\n                nums[query[1]] = query[2];\n                \n                if(query[1] != 0){\n                    tree.modify(query[1] - 1, query[1] - 1, judge(nums, query[1] - 1));\n                }\n               \n                tree.modify(query[1], query[1], judge(nums, query[1]));\n                \n                if(query[1] != n - 1){\n                    tree.modify(query[1] + 1, query[1] + 1, judge(nums, query[1] + 1));\n                }\n            }\n        }\n        \n        \n        return res;\n    }\n    \n    private int judge(int[] nums, int loc){\n        if(loc == 0 || loc == nums.length - 1){\n            return 0;\n        }\n        \n        return nums[loc - 1] < nums[loc] && nums[loc + 1] < nums[loc] ? 1 : 0;\n    }\n}\n\nclass DynamicSegmentSumTree {\n  private Node root = new Node(0, (int) 1e5);\n\n  public void modify(int l, int r, int v) {\n    modify(l, r, v, root);\n  }\n\n  public void modify(int l, int r, int v, Node node) {\n    if (l > r) {\n      return;\n    }\n    if (node.l >= l && node.r <= r) {\n      node.v = (node.r - node.l + 1) * v;\n      node.add = v;\n      return;\n    }\n    pushdown(node);\n    if (l <= node.mid) {\n      modify(l, r, v, node.left);\n    }\n    if (r > node.mid) {\n      modify(l, r, v, node.right);\n    }\n    pushup(node);\n  }\n\n  public int query(int l, int r) {\n    return query(l, r, root);\n  }\n\n  public int query(int l, int r, Node node) {\n    if (l > r) {\n      return 0;\n    }\n    if (node.l >= l && node.r <= r) {\n      return node.v;\n    }\n    pushdown(node);\n    int v = 0;\n    if (l <= node.mid) {\n      v += query(l, r, node.left);\n    }\n    if (r > node.mid) {\n      v += query(l, r, node.right);\n    }\n    return v;\n  }\n\n  public void pushup(Node node) {\n    node.v = node.left.v + node.right.v;\n  }\n\n  public void pushdown(Node node) {\n    if (node.left == null) {\n      node.left = new Node(node.l, node.mid);\n    }\n    if (node.right == null) {\n      node.right = new Node(node.mid + 1, node.r);\n    }\n    if (node.add != 0) {\n      Node left = node.left, right = node.right;\n      left.add = node.add;\n      right.add = node.add;\n      left.v = (left.r - left.l + 1) * node.add;\n      right.v = (right.r - right.l + 1) * node.add;\n      node.add = 0;\n    }\n  }\n\n  class Node {\n\n    Node left;\n    Node right;\n    int l;\n    int r;\n    int mid;\n    int v;\n    int add;\n\n    public Node(int l, int r) {\n      this.l = l;\n      this.r = r;\n      this.mid = (l + r) >> 1;\n    }\n  }\n}",
    "submit_ts": "1718506451",
    "subm_id": "539775040"
}