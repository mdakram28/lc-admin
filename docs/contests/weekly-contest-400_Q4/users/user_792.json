{
    "username": "jack81306",
    "submission": "class Solution {\n\nclass SegmentTree {\nprivate:\n    vector<int> tree;\n    vector<int> arr;\n    int n;\n\n    void build(int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(2 * node, start, mid);\n            build(2 * node + 1, mid + 1, end);\n            tree[node] = tree[2 * node] & tree[2 * node + 1];\n        }\n    }\n\n    void update(int node, int start, int end, int idx, int val) {\n        if (start == end) {\n            arr[idx] = val;\n            tree[node] = val;\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid) {\n                update(2 * node, start, mid, idx, val);\n            } else {\n                update(2 * node + 1, mid + 1, end, idx, val);\n            }\n            tree[node] = tree[2 * node] & tree[2 * node + 1];\n        }\n    }\n\n    int query(int node, int start, int end, int l, int r) {\n        if (r < start || end < l) {\n            return INT_MAX;\n        }\n        if (l <= start && end <= r) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int leftAnd = query(2 * node, start, mid, l, r);\n        int rightAnd = query(2 * node + 1, mid + 1, end, l, r);\n        return leftAnd & rightAnd;\n    }\n\npublic:\n    SegmentTree(vector<int>& input) {\n        arr = input;\n        n = arr.size();\n        tree.resize(4 * n);\n        build(1, 0, n - 1);\n    }\n\n    void update(int idx, int val) {\n        update(1, 0, n - 1, idx, val);\n    }\n\n    int query(int l, int r) {\n        return query(1, 0, n - 1, l, r);\n    }\n};\n    \n\n    \npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        SegmentTree s(nums);\n        int ans = INT_MAX;\n        for (int i = 0; i < nums.size(); ++i) {\n            int l = i, r = nums.size() - 1;\n            while(l < r) {\n                int mid = (l + r) / 2;\n                int res = s.query(i, mid);\n                if (res < k) {\n                    r = mid;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            \n            int a = s.query(i, l);\n            int b = l > i ? s.query(i, l - 1) : INT_MAX;\n            \n            // cout << l << \" \" << a <<\" \"<< b <<endl;\n            \n            ans = min({ans, abs(a - k), abs(b - k)});\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1717299367.0
}