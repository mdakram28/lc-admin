{
    "username": "megaspazz",
    "submission": "class Solution {\n    private static final int MOD = 1_000_000_007;\n    \n    public int countOfPairs(int[] nums) {\n        long[] dp = new long[1001];\n        for (int x = 0; x <= 1000; ++x) {\n            int y = nums[0] - x;\n            if (!valid(y)) {\n                continue;\n            }\n            dp[x] = 1;\n        }\n        \n        // System.out.println(Arrays.toString(dp));\n        \n        for (int i = 1; i < nums.length; ++i) {\n            long[] dpSum = makeSum(dp);\n            long[] next = new long[1001];\n            for (int xf = 0; xf <= 1000; ++xf) {\n                int yf = nums[i] - xf;\n                if (!valid(yf)) {\n                    continue;\n                }\n                int x0max = Math.min(xf, nums[i - 1] - yf);\n                if (x0max < 0) {\n                    continue;\n                }\n                next[xf] = add(next[xf], dpSum[x0max + 1]);\n            }\n            dp = next;\n            // System.out.format(\"i = %d, dp = %s%n\", i, Arrays.toString(dp));\n        }\n        \n        long ans = 0;\n        for (long x : dp) {\n            ans = add(ans, x);\n        }\n        return (int) ans;\n    }\n    \n    private static long[] makeSum(long[] A) {\n        final int N = A.length;\n        \n        long[] S = new long[N + 1];\n        for (int i = 0; i < N; ++i) {\n            S[i + 1] = add(S[i], A[i]);\n        }\n        return S;\n    }\n    \n    private static boolean valid(int x) {\n        return x >= 0 && x <= 1000;\n    }\n    \n    private static final long RAW_MULTIPLY_MAX = 3037000499L;\n\n    private static final int CHUNK_SIZE = Long.SIZE - Long.numberOfLeadingZeros(Long.MAX_VALUE / MOD) - 1;\n    private static final long CHUNK_MASK = (1L << CHUNK_SIZE) - 1;\n\n    @SuppressWarnings(\"unused\")\n    public static long multiply(long a, long b) {\n        if (MOD <= RAW_MULTIPLY_MAX) {\n            return a * b % MOD;\n        }\n        return multiplyInternal(a, b);\n    }\n\n    public static long multiply(long... arr) {\n        long ans = 1;\n        for (long x : arr) {\n            ans = multiply(ans, x);\n        }\n        return ans;\n    }\n\n    public static long add(long a, long b) {\n        long ans = a + b;\n        if (ans >= MOD) {\n            ans -= MOD;\n        }\n        return ans;\n    }\n\n    public static long add(long... arr) {\n        long ans = 0;\n        for (long x : arr) {\n            ans = add(ans, x);\n        }\n        return ans;\n    }\n\n    public static long subtract(long a, long b) {\n        return add(a, MOD - b);\n    }\n\n    private static long normalize(long x) {\n        if (x <= -MOD || x >= MOD) {\n            x %= MOD;\n        }\n        if (x < 0) {\n            x += MOD;\n        }\n        return x;\n    }\n\n    /**\n     * Computes the value of (b ^ e) % MOD.\n     */\n    public static long modPow(long b, long e) {\n        long p = b;\n        long ans = 1;\n        while (e > 0) {\n            if ((e & 1) == 1) {\n                ans = multiply(ans, p);\n            }\n            p = multiply(p, p);\n            e >>= 1;\n        }\n        return ans;\n    }\n\n    /**\n     * Computes the modular inverse, such that: ak % MOD = 1, for some k.\n     * See this page for details:  http://rosettacode.org/wiki/Modular_inverse\n     */\n    public static long modInverse(long a) {\n        long b = MOD;\n        long x0 = 0, x1 = 1;\n        long t, q;\n\n        while (a > 1) {\n            q = a / b;\n\n            t = b;\n            b = a % b;\n            a = t;\n\n            t = x0;\n            x0 = x1 - q * x0;\n            x1 = t;\n        }\n\n        if (x1 < 0) {\n            x1 += MOD;\n        }\n        return x1;\n    }\n\n    private static long multiplyInternal(long a, long b) {\n        if (a > b) {\n            return multiplyInternal(b, a);\n        }\n        if (a == 0) {\n            return 0;\n        }\n\n        long ans = 0;\n        while (a > 0) {\n            long mask = a & CHUNK_MASK;\n            if (mask > 0) {\n                ans = add(ans, (mask * b) % MOD);\n            }\n            b = (b << CHUNK_SIZE) % MOD;\n            a >>= CHUNK_SIZE;\n        }\n        return ans;\n    }\n}",
    "submit_ts": "1723345065",
    "subm_id": "1351547871"
}