{
    "username": "DarkestSky",
    "submission": "class Solution {\npublic:\nstatic bool compareBoardValue(const pair<int, pair<int, int>> &a,\n                       const pair<int, pair<int, int>> &b) {\n    return a.first < b.first;\n}\n\nvoid tryFind(vector<pair<int, pair<int, int>>> &boardValues, int index,\n             int remainNum, unordered_set<int> &bannedRow,\n             unordered_set<int> &bannedCol, long long &maxValueNum,\n             long long &currentAccumulateNum, int &lastIndexToTry) {\n    if (index < 0) {\n        return;\n    }\n    if (remainNum < 1) {\n        return;\n    }\n    if (remainNum > 1 && index <= lastIndexToTry) {\n        return;\n    }\n    if (remainNum == 2 && currentAccumulateNum < maxValueNum / 3) {\n        return;\n    }\n    int positionValue = boardValues.at(index).first;\n    int positionRow = boardValues.at(index).second.first;\n    int positionCol = boardValues.at(index).second.second;\n    if (bannedRow.find(positionRow) == bannedRow.end() &&\n        bannedCol.find(positionCol) == bannedCol.end()) {\n        bannedRow.insert(positionRow);\n        bannedCol.insert(positionCol);\n        currentAccumulateNum += positionValue;\n        if (remainNum > 1) {\n            tryFind(boardValues, index - 1, remainNum - 1, bannedRow, bannedCol,\n                    maxValueNum, currentAccumulateNum, lastIndexToTry);\n        } else {\n            if (lastIndexToTry < index) {\n                lastIndexToTry = index;\n            }\n            if (currentAccumulateNum > maxValueNum) {\n                maxValueNum = currentAccumulateNum;\n            }\n        }\n        currentAccumulateNum -= positionValue;\n        bannedCol.erase(positionCol);\n        bannedRow.erase(positionRow);\n    }\n    tryFind(boardValues, index - 1, remainNum, bannedRow, bannedCol,\n            maxValueNum, currentAccumulateNum, lastIndexToTry);\n    return;\n}\n\nlong long maximumValueSum(vector<vector<int>> &board) {\n    vector<pair<int, pair<int, int>>> boardValues;\n    for (int i = 0; i < board.size(); i++) {\n        for (int j = 0; j < board.front().size(); j++) {\n            boardValues.push_back(pair<int, pair<int, int>>(\n                board.at(i).at(j), pair<int, int>(i, j)));\n        }\n    }\n    std::sort(boardValues.begin(), boardValues.end(), compareBoardValue);\n    unordered_set<int> bannedRow;\n    unordered_set<int> bannedCol;\n    long long result = LONG_LONG_MIN / 2;\n    int lastIndexToTry = -1;\n    long long currentAccumulateValue = 0;\n    tryFind(boardValues, boardValues.size() - 1, 3, bannedRow, bannedCol,\n            result, currentAccumulateValue, lastIndexToTry);\n    return result;\n}\n};",
    "submit_ts": "1723908309",
    "subm_id": "556330286"
}