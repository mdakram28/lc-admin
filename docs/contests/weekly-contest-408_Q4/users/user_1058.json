{
    "username": "pyaracetamol",
    "submission": "class Solution {\npublic:\nbool SOLVE(int X, int Y, vector<vector<int>> &c)\n{\n\n    int numC = c.size();\n    vector<vector<int>> g(numC + 4);\n\n    for (int i = 0; i < numC; i++)\n    {\n\n        if (c[i][0] <= c[i][2])\n        {\n            g[numC].push_back(i);\n            g[i].push_back(numC);\n        }\n        if (X - c[i][0] <= c[i][2])\n        {\n            g[numC + 2].push_back(i);\n            g[i].push_back(numC + 2);\n        }\n        if (c[i][1] <= c[i][2])\n        {\n            g[numC + 1].push_back(i);\n            g[i].push_back(numC + 1);\n        }\n        if (Y - c[i][1] <= c[i][2])\n        {\n            g[numC + 3].push_back(i);\n            g[i].push_back(numC + 3);\n        }\n        for (int j = i + 1; j < numC; ++j)\n        {\n            double distance = sqrt(pow(c[i][0] - c[j][0], 2) + pow(c[i][1] - c[j][1], 2));\n            int radSum = c[i][2] + c[j][2];\n            if (radSum >= distance)\n            {\n                g[i].push_back(j);\n                g[j].push_back(i);\n            }\n        }\n    }\n\n    int isBlck = 0;\n    isBlck = max(isBlck, BFS(g, numC, numC + 1, numC + 2, numC + 4));\n    isBlck = max(isBlck, BFS(g, numC + 3, numC + 2, numC + 1, numC + 4));\n    return isBlck == 0;\n}\n\nint BFS(vector<vector<int>> &g, int s, int t1, int t2, int n)\n{\n    queue<int> q;\n    vector<bool> visited(n + 4, false);\n    q.push(s);\n    visited[s] = true;\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n\n        for (int v : g[u])\n        {\n\n            if (!visited[v])\n            {\n                q.push(v);\n                visited[v] = true;\n            }\n        }\n    }\n\n    return (visited[t1] || visited[t2] ? 1 : 0);\n}\n    \n    bool canReachCorner(int X, int Y, vector<vector<int>>& cs) {\n        return SOLVE(X, Y, cs);\n    }\n};",
    "submit_ts": "1722138962",
    "subm_id": "1335804233"
}