{
    "username": "shubhamvarshney2000",
    "submission": "#include <bits/stdc++.h>\n\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// using namespace __gnu_pbds;\n// typedef tree<int, null_type, greater_equal<int>, rb_tree_tag,\n//              tree_order_statistics_node_update>\n//     oset;\n\nusing namespace std;\n\n#define ar array\n#define ll long long\n#define ld long double\n#define sza(x) ((int)x.size())\n#define all(a) (a).begin(), (a).end()\n\nconst int MAX_N = 1e5 + 5;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e9;\nconst ld EPS = 1e-9;\n\nlong long pow_m(long long base, long long exp, long long mod) {\n    long long result = 1LL;\n    base = (base % mod);\n        \n    while (exp > 0) {\n        if ((exp & 1LL) == 1LL) result = (result * base) % mod;\n        exp >>= 1LL;\n        base = (base * base) % mod;\n    }\n    return result;\n\n}\n// Trie implementation \nclass Node{\n    public:\n    \n    Node* links[26];\n    bool flag = false;\n\n    bool containskey(char ch){\n        return links[ch-'a'] != nullptr;\n    }\n\n    Node* get(char ch){\n        return links[ch-'a'];\n    }\n\n    void put(char ch,Node* node){\n        links[ch-'a'] = node;\n    }\n\n    void setEnd(){\n        flag = true;\n    }\n\n    bool isEnd(){\n        return flag == true;\n    }\n};\nclass Trie {\npublic:\n    Node* root;\n    Trie() {\n        root = new Node();\n    }\n    \n    void insert(string word) {\n        Node* node = root;\n        for(int i=0;i<word.size();i++){\n            if(!node->containskey(word[i])){\n                node->put(word[i],new Node());\n            }\n            node = node->get(word[i]);\n        }\n        node->setEnd();\n    }\n    \n    bool search(string word) {\n        Node* node = root;\n        for(int i=0;i<word.size();i++){\n            if(!node->containskey(word[i])){\n                return false;\n            }\n            node = node->get(word[i]);\n        }\n        return node->isEnd();\n    }\n    \n    bool startsWith(string prefix) {\n        Node* node = root;\n        for(int i=0;i<prefix.size();i++){\n            if(!node->containskey(prefix[i])){\n                return false;\n            }\n            node = node->get(prefix[i]);\n        }\n        return true;\n    }\n};\n\nclass DSU {\n    private:\n    int sz;\n    vector<int> root, rank;\n    public:\n    DSU(int sz){\n        this->sz = sz;\n        root.resize(sz);\n        rank.resize(sz);\n        for(int i = 0; i < sz; i++){\n            root[i] = i;\n            rank[i] = 1;\n        }\n    }\n    \n    int find(int x){\n        if(root[x] == x) return x;\n        return root[x] = find(root[x]);\n    }\n    \n    bool unionSet(int x, int y){\n        cout<<x<<\" \"<<y<<endl;\n        int rootX = find(x);\n        int rootY = find(y);\n        cout<<rootX<<\" \"<<rootY<<endl;\n        if(rootX == rootY)\n            return false;\n        \n        if(rank[rootX] > rank[rootY])\n            root[rootY] = rootX;\n        else if(rank[rootX] < rank[rootY])\n            root[rootX] = rootY;\n        else{\n            root[rootY] = rootX;\n            rank[rootX]++;\n        }\n        return true;\n    }\n\n    int solve() {\n        map<ll,ll> m;\n        for(int i = 0; i < sz; i++){\n            if(m.find(root[i]) == m.end()){\n                cout<<root[i];\n                m[root[i]]++;\n            }\n        }\n        return (int)m.size();\n    }\n};\n\n\nclass TreeAncestor {\n    public:\n    vector<vector<int>> vec;\n    vector<int> depth;\n    int h = 18;\n    int n;\n    TreeAncestor(int _n, vector<int>& parent) {\n        n = _n;\n        depth.resize(n,0);\n        vec.resize(h,vector<int>(n+1,-1));\n        for(int i=0;i<n;i++){\n            vec[0][i] = parent[i];\n        }\n        for(int i=1;i<h;i++){\n            for(int j=0;j<n;j++){\n                if(vec[i-1][j] != -1)\n                    vec[i][j] = vec[i-1][vec[i-1][j]];\n            }\n        }\n    }\n    \n    int getKthAncestor(int node, int k) {\n        for(int i=0;i<h;i++){\n            if(k&(1<<i)){\n                node = vec[i][node];\n                if(node == -1){\n                    return -1;\n                }\n            }\n        }\n        return node;\n    }\n    int lca(int a, int b)\n    {\n        if(depth[a] < depth[b])\n            swap(a, b);\n        \n        int diff = depth[a] - depth[b];\n        for(int i = 0; i < 16; i++)\n            if(diff & (1 << i))\n                a = vec[a][i];\n\n        if(a == b)\n            return a;\n        \n        for(int i = 15; i >= 0; i--)\n        {\n            if(vec[a][i] != vec[b][i])\n            {\n                a = vec[a][i];\n                b = vec[b][i];\n            }\n        }\n\n        return vec[a][0];\n    }\n    void dfs(int src, int paren,vector<vector<int>> &g)\n    {\n        for(auto x : g[src])\n        {\n            if(x == paren)\n                continue;\n            depth[x] = depth[src] + 1;\n            dfs(x, src,g);\n        }\n    }\n};\n\nbool help(ll x,ll y,ll sum){\n    ll s = 0;\n    while(x>0 && y>0){\n        if(s>=sum){\n            s= s-2;\n            y--;\n        }\n        else{\n            s += 1;\n            x--;\n        }\n    }\n    if(x<=sum){\n        return 1;\n    }\n    else{\n        return 0;\n    }\n}\n \n bool subArrayExists(ll arr[], int N)\n{\n    unordered_set<int> sumSet;\n \n    // Traverse through array\n    // and store prefix sums\n    ll sum = 0;\n    for (int i = 0; i < N; i++) {\n        sum += arr[i];\n \n        // If prefix sum is 0 or\n        // it is already present\n        if (sum == 0 || sumSet.find(sum) != sumSet.end())\n            return true;\n \n        sumSet.insert(sum);\n    }\n    return false;\n}\n\nll myCountX(ll N, ll X)\n{\n    ll x, a, r;\n    ll e;\n \n    // The loop is executed for every digit of N\n    e = (ll)(log10(N));\n    r = 0;\n    while (e >= 0) {\n        // Calculation of next digit in decrescent order of\n        // power of 10\n        x = N / (ll)pow(10, e);\n        x %= 10;\n        // Modularity based on power of 10\n        a = x * e * (ll)pow(10, e - 1);\n        r += a;\n        // If the digit is the searched one then the\n        // remainder of division by the current power of 10\n        // is added to result because a number of occurances\n        // equal to this remainder is when the digit is\n        // present with this position\n        if (x == X) {\n            a = (N % (ll)pow(10, e)) + 1;\n            // But if the searched digit is equal to 0 then\n            // there aren't number with the most significant\n            // digit equal to 0\n            if (X == 0)\n                a -= (ll)pow(10, e);\n            r += a;\n        }\n        // If the digit is greater than the searched one and\n        // the searched digit isn't 0 then the number of all\n        // number with the most significat digit equal to\n        // the searched one must be added to result\n        if (x > X && X != 0) {\n            a = (ll)pow(10, e);\n            r += a;\n        }\n        e--;\n    }\n    return r;\n}\nll count(vector<int> &cnt,int l,int r){\n    if(l == 0){\n        return cnt[r];\n    }\n    else{\n        return cnt[r]-cnt[l-1];\n    }\n}\nll a[1000001][20];\n\nvoid build(int arr[],int n){\n    for(int i=0;i<n;i++){\n        a[i][0] = arr[i];\n    }\n    for(int j=1;j<=20;j++){\n        for(int i=0;i+(1<<j)<=n;i++){\n            a[i][j] = a[i][j-1] + a[i+(1<<(j-1))][j-1];\n        }\n    }\n}\n\nvoid solve()\n{  \n   string s;\n   cin>>s;\n   string a = s;\n   sort(a.begin(),a.end());\n   if(s == a){\n    cout<<1<<endl;\n    return;\n   }\n   int cnt = 0;\n   for(int i=0;i<s.size()-1;i++){\n    if(s[i]!= s[i+1]){\n        cnt++;\n    }\n   }\n   cout<<cnt<<endl;\n   \n}\n\nclass Solution {\npublic:\n    unordered_map<long long, int> dp;\n\n    int solve(long long i, long long k, int last, int j) {\n        if (i < 0) {\n            return 0;\n        }\n\n        long long ss = (i << 20) | (j << 10) | last;\n        if (dp.find(ss) != dp.end()) {\n            return dp[ss];\n        }\n\n        int cnt = 0;\n        if (i == k) {\n            cnt++;\n        }\n        if (k >= 1e9) {\n            return 0;\n        }\n        if (j >= 32) {\n            return 0;\n        }\n        if (last == 1) {\n            long long next = 1LL << j;\n            cnt += solve(i + next, k, 1, j + 1);\n            cnt += solve(i - 1, k, 0, j);\n        } else {\n            long long next = 1LL << j;\n            cnt += solve(i + next, k, 1, j + 1);\n        }\n\n        dp[ss] = cnt;\n        return cnt;\n    }\n    int waysToReachStair(int k) {\n        return solve(1,k,1,0);\n    }\n};",
    "submit_ts": 1716089229.0
}