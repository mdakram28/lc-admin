{
    "username": "AlthafHussain",
    "submission": "class Solution {\n    int depth(ArrayList<ArrayList<Integer>> adj, int d[]){\n       Queue<Integer> q = new ArrayDeque<>();\n        int n = d.length;\n        for(int i = 0; i < n; i++){\n            if(d[i] == 1) q.add(i);\n        }\n        int cnt = 0;\n        while(q.size() > 0){\n            int size = q.size();\n            for(int i = 0; i < size; i++){\n            int node = q.poll();\n            for(Integer it : adj.get(node)){\n                d[it]--;\n                if(d[it] == 1) q.add(it);\n            }\n            }\n            Queue<Integer> p = new ArrayDeque<>();\n            while(q.size() > 0){\n                if(d[q.peek()] == 1){\n                    p.add(q.peek());\n                }\n                q.poll();\n            }\n            q = p;\n            cnt++;\n        }\n        return cnt;\n    }\n    int max1 = 0;\n    int max2 = 0;\n    int diameter(int node, int par, ArrayList<ArrayList<Integer>> adj){\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for(Integer it : adj.get(node)){\n            if(it != par){\n                int val = diameter(it, node, adj);\n                 pq.add(val);\n            }\n            if(pq.size() > 2){\n                pq.poll();\n            }\n        }\n        if(pq.size() == 1){\n            max1 = Math.max(max1, pq.peek());\n            return 1+pq.peek();\n        }\n        if(pq.size() == 0) return 1;\n        int val1 = pq.poll();\n        int val2 = pq.poll();\n        max1 = Math.max(max1, val1+val2);\n        return 1+val2;\n    }\n    int diameter2(int node, int par, ArrayList<ArrayList<Integer>> adj){\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for(Integer it : adj.get(node)){\n            if(it != par){\n                int val = diameter(it, node, adj);\n                 pq.add(val);\n            }\n           \n            if(pq.size() > 2){\n                pq.poll();\n            }\n        }\n        if(pq.size() == 1){\n            max2 = Math.max(max2, pq.peek());\n            return 1+pq.peek();\n        }\n        if(pq.size() == 0) return 1;\n        int val1 = pq.poll();\n        int val2 = pq.poll();\n        max2 = Math.max(max2, val1+val2);\n        return 1+val2;\n    }\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int n = edges1.length+1;\n        int m = edges2.length+1;\n        ArrayList<ArrayList<Integer>> adj1 = new ArrayList<>();\n        ArrayList<ArrayList<Integer>> adj2 = new ArrayList<>();\n        int d1[] = new int[n];\n        int d2[] = new int[m];\n        for(int i = 0; i < n; i++){\n            adj1.add(new ArrayList<>());\n        }\n        for(int i = 0; i < m; i++){\n            adj2.add(new ArrayList<>());\n        }\n        for(int it[] : edges1){\n            adj1.get(it[0]).add(it[1]);\n            adj1.get(it[1]).add(it[0]);\n            d1[it[0]]++;\n            d1[it[1]]++;\n        }\n        for(int it[] : edges2){\n            adj2.get(it[0]).add(it[1]);\n            adj2.get(it[1]).add(it[0]);\n            d2[it[0]]++;\n            d2[it[1]]++;\n        }\n        int dep1 = depth(adj1, d1);\n        int dep2 = depth(adj2, d2);\n        int dia1 = diameter(0, -1, adj1);\n        int dia2 = diameter2(0, -1, adj2);\n        // System.out.println(dep1+\" \"+dep2+\" \"+max1+\" \"+max2);\n        return Math.max(dep1+dep2+1, Math.max(max1, max2));\n    }\n}",
    "submit_ts": 1719718998.0
}