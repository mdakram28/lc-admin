{
    "username": "KevinFederline",
    "submission": "class RootedTreeNode:\n    def __init__(self, val, children=None):\n        self.val = val\n        self.children = children or []\n        \n        \ndef depthAndDiameter(root: RootedTreeNode):\n    if root is None:\n        return 0, 0\n    if root.children == []:\n        return 1, 1\n    c = [depthAndDiameter(child) for child in root.children]\n    if len(root.children) == 1:\n        return 1 + c[0][0], max(1 + c[0][0], c[0][1])\n    c.sort(key=lambda l: l[0])\n    depth = c[-1][0] + 1\n    diameter = max(max([l[1] for l in c]), 1 + c[-1][0] + c[-2][0])\n    return depth, diameter\n\n\ndef edgesToRootedTree(edges):\n    n = len(edges) + 1\n    neighbors = {i: set() for i in range(n)}\n    for a, b in edges:\n        neighbors[a].add(b)\n        neighbors[b].add(a)\n    def build(node, parent=None):\n        res = RootedTreeNode(node)\n        for neighbor in neighbors[node]:\n            if parent is not None and neighbor == parent:\n                continue\n            res.children.append(build(neighbor, node))\n        return res\n    return build(0)\n\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        t1 = edgesToRootedTree(edges1)\n        d1 = depthAndDiameter(t1)[1]\n        t2 = edgesToRootedTree(edges2)\n        d2 = depthAndDiameter(t2)[1]\n        return max(d1-1, d2-1, 1 + (d1) // 2 + (d2) // 2)",
    "submit_ts": 1719716251.0
}