{
    "username": "nandikeshsingh",
    "submission": "class Solution {\npublic:\n    struct segtree\n{\n  struct data\n  {\n\t//Use required attributes\n\tint mn;\n  \n\t//Default Values\n\tdata() : mn(0) {};\n  };\n\tint N;\n\tvector<data> st;\n\tvector<bool> cLazy;//stores if this values needs to be pushed down or not.\n\tvector<int> lazy;//stores the value that needs to be pushed down.\n\n\tvoid init(int n)\n\t{\n\t\tN = n;\n\t\tst.resize(4 * N + 5);\n\t\tcLazy.assign(4 * N + 5, false);\n\t\tlazy.assign(4 * N + 5, 0);\n\t}\n\n\t//Write reqd merge functions\n\t//also consider what if data l or r has default values then what to return;\n\tvoid merge(data &cur, data &l, data &r) \n\t{\n\t\tcur.mn = max(l.mn, r.mn);\n\t}\n\t\n\t//Handle lazy propagation appriopriately and carefully\n\t//might need to do cLazy[node*2] = 1-cLazy[node] if updates cancels(like flip operation);\n\tvoid propagate(int node, int L, int R)\n\t{\n\t\tif(L != R)//push the changes \n\t\t{\n\t\t\tcLazy[node*2] = 1;\n\t\t\tcLazy[node*2 + 1] = 1;\n\t\t\tlazy[node*2] = lazy[node];\n\t\t\tlazy[node*2 + 1] = lazy[node]; \n\t\t}\n\t\tst[node].mn = lazy[node];//then change the current node\n\t\tcLazy[node] = 0;\n    \t\tlazy[node] = 0;\n\t}\n\n\tvoid build(int node, int L, int R)\n\t{\n\t\tif(L==R)\n\t\t{\n\t\t\tst[node].mn = 0;//change the value as per the question.\n\t\t\treturn;\n\t\t}\n\t\tint M=(L + R)/2;\n\t\tbuild(node*2, L, M);\n\t\tbuild(node*2 + 1, M + 1, R);\n\t\tmerge(st[node], st[node*2], st[node*2+1]);\n\t}\n\n\tdata Query(int node, int L, int R, int i, int j)\n\t{\n\t\tif(cLazy[node])\n\t\t\tpropagate(node, L, R);\n\t\tif(j<L || i>R)\n\t\t\treturn data();\n\t\tif(i<=L && R<=j)\n\t\t\treturn st[node];\n\t\tint M = (L + R)/2;\n\t\tdata left=Query(node*2, L, M, i, j);\n\t\tdata right=Query(node*2 + 1, M + 1, R, i, j);\n\t\tdata cur;\n\t\tmerge(cur, left, right);\n\t\treturn cur;\n\t}\n\n\tdata pQuery(int node, int L, int R, int pos)\n\t{\n\t\tif(cLazy[node])\n\t\t\tpropagate(node, L, R);\n\t\tif(L == R)\n\t\t\treturn st[node];\n\t\tint M = (L + R)/2;\n\t\tif(pos <= M)\n\t\t\treturn pQuery(node*2, L, M, pos);\n\t\telse\n\t\t\treturn pQuery(node*2 + 1, M + 1, R, pos);\n\t}\t\n\n\tvoid Update(int node, int L, int R, int i, int j, int val)\n\t{\n\t\tif(cLazy[node])\n\t\t\tpropagate(node, L, R);\n\t\tif(j<L || i>R)\n\t\t\treturn;\n\t\tif(i<=L && R<=j)\n\t\t{\n\t\t\tcLazy[node] = 1;\n\t\t\tlazy[node] = val;\n\t\t\tpropagate(node, L, R);\n\t\t\treturn;\n\t\t}\n\t\tint M = (L + R)/2;\n\t\tUpdate(node*2, L, M, i, j, val);\n\t\tUpdate(node*2 + 1, M + 1, R, i, j, val);\n\t\tmerge(st[node], st[node*2], st[node*2 + 1]);\n\t}\n\n\tvoid pUpdate(int node, int L, int R, int pos, int val)\n\t{\n\t\tif(cLazy[node])\n\t\t\tpropagate(node, L, R);\n\t\tif(L == R)\n\t\t{\n\t\t\tcLazy[node] = 1;\n\t\t\tlazy[node] = val;\n\t\t\tpropagate(node, L, R);\n\t\t\treturn;\n\t\t}\n\t\tint M = (L + R)/2;\n\t\tif(pos <= M)\n\t\t\tpUpdate(node*2, L, M, pos, val);\n\t\telse\n\t\t\tpUpdate(node*2 + 1, M + 1, R, pos, val);\n\t\tmerge(st[node], st[node*2], st[node*2 + 1]);\n\t}\n\n\tdata query(int pos)\n\t{\n\t\treturn pQuery(1, 0, N-1, pos);\n\t}\n\n\tdata query(int l, int r)\n\t{\n\t\treturn Query(1, 0, N-1, l, r);\n\t}\n\n\tvoid update(int pos, int val)\n\t{\n\t\tpUpdate(1, 0, N-1, pos, val);\n\t}\n\n\tvoid update(int l, int r, int val)\n\t{\n\t\tUpdate(1, 0, N-1, l, r, val);\n\t}\n};\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        set<int>st;\n        st.insert(50000);\n        st.insert(0);\n        segtree ss;\n        ss.init(50001);\n        ss.update(50000,50000);\n        vector<bool>ans;\n        for(auto& u : queries)\n        {\n            if((int)u.size()==2)//update set and segtree\n            {\n                int pos=u[1];\n                auto itr=st.upper_bound(pos);\n                auto back=prev(itr);\n                ss.update(pos,pos-*back);\n                ss.update(*itr,*itr-pos);\n                st.insert(pos);\n            }\n            else //query\n            {   \n                int pos=u[1];\n                int sz=u[2];\n                auto itr=st.upper_bound(pos);\n                auto back=prev(itr);\n                int best=ss.query(0,*back).mn;\n                best=max(best,pos-*back);\n                if(best>=sz)ans.push_back(1);\n                else ans.push_back(0);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716649824.0
}