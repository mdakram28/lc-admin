{
    "username": "thakurAbhishek",
    "submission": "#include <unordered_map>\n#include <utility>\n\nclass Solution {\npublic:\n    struct hash_triple {\n        template <class T1, class T2, class T3>\n        std::size_t operator() (const std::tuple<T1, T2, T3> &triple) const {\n            return std::hash<T1>()(std::get<0>(triple)) ^ std::hash<T2>()(std::get<1>(triple)) ^ std::hash<T3>()(std::get<2>(triple));\n        }\n    };\n\n    std::unordered_map<std::tuple<int, int, bool>, long long, hash_triple> memo;\n\n    long long waysToReach(int k, int i, int jump, bool reversed) {\n        // Base case: if `i` is greater than `k` and cannot reach `k` with `2^jump - 1`\n        if (i > k+20 && (1< (1LL << jump))) {\n            return 0;\n        }\n\n        auto key = std::make_tuple(i, jump, reversed);\n        if (memo.find(key) != memo.end()) {\n            return memo[key];\n        }\n\n        long long count = 0;\n        if (i == k) {\n            count += 1; // Reached stair k, count this path\n        }\n\n        if (!reversed && i > 0) {\n            count += waysToReach(k, i - 1, jump, true); // Move down one stair and reverse direction\n        }\n        count += waysToReach(k, i + (1 << jump), jump + 1, false); // Move up 2^jump stairs\n\n        memo[key] = count;\n        return count;\n    }\n\n    long long waysToReachStair(int k) {\n        memo.clear();\n        return waysToReach(k, 1, 0, false);\n    }\n};\n",
    "submit_ts": 1716088598.0
}