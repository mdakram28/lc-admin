{
    "username": "wjli",
    "submission": "\n// COPY ALL MACROS BELOW\n\ntypedef long long LL;\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define LB lower_bound\n#define UB upper_bound\n#define SZ(x) ((int)x.size())\n#define LEN(x) ((int)x.length())\n#define ALL(x) begin(x), end(x)\n#define RSZ resize\n#define ASS assign\n#define REV(x) reverse(x.begin(), x.end());\n#define trav(a, x) for (auto& a : x)\ntypedef pair<LL, LL> PL;\ntypedef vector<LL> VL;\ntypedef vector<PL> VPL;\ntypedef vector<VL> VVL;\ntypedef vector<VVL> VVVL;\ntypedef vector<VVVL> VVVVL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PI;\ntypedef vector<int> VI;\ntypedef vector<PI> VPI;\ntypedef vector<vector<int>> VVI;\ntypedef vector<vector<PI>> VVPI;\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\n#define FOR(i, n) for (int i = 0; i < n; i++) \n#define FOR1(i, n) for (int i = 1; i <= n; i++) \n#define SORT(x) sort(x.begin(), x.end())\n#define RSORT(x) sort(x.rbegin(), x.rend())\n#define SUM(x) accumulate(x.begin(), x.end(), 0LL)\n\n\n\n\n\n\n\nclass tree {\t\t// implementation of recurvie programming\n    int ct;\npublic:\n    int nn, root;\t\t\t\t// # of nodes, id of root\n    vector<int> parent;\t\t\t// parent of each node; -1 if unassigned\n    vector<int> depth;\t\t\t// depth of each node\n    vector<int> sz;\t\t\t\t// subtree size of each node \n    vector<vector<int>> adj;\t// adjacency list from each node\n    vector<vector<int>> sons;\t// sons list from each node\n\n    // for cartesian_decomposition\n    vector<int> in, out;\t\t// starting and ending position of a subtree\n    vector<int> pos;\t\t\t// inorder of DFS\n\n    // for LCA sparse table\n    vector<vector<int>> pred;\n    int MAXLEVEL;\n\n    bool called_LCA = false;\n\n    tree(int n) {\n        nn = n;\n        adj.clear();\n        adj.resize(n);\n    }\n\n    void add_path(int a, int b) {\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    void add_directed_path(int a, int b) {\n        adj[a].push_back(b);\n    }\n\n    void dfs_set_root(int id, bool cartesian_decomposition = false) {\t// internal\n        if (cartesian_decomposition) {\n            in[id] = ct;\n            pos[ct] = id;\n            ct++;\n        }\n\n        sz[id]++;\n\n        for (auto p : adj[id]) {\n            if (parent[p] == -1) {\n                parent[p] = id;\n                depth[p] = depth[id] + 1;\n                dfs_set_root(p, cartesian_decomposition);\n                sz[id] += sz[p];\n\n                sons[id].push_back(p);\n            }\n        }\n\n        if (cartesian_decomposition) out[id] = ct - 1;\n    }\n\n    void set_root(int id, bool cartesian_decomposition = true) {\t\t// set root of the tree and calculate necessary info\n        if (cartesian_decomposition) {\n            in.resize(nn);\n            out.resize(nn);\n            pos.resize(nn);\n            ct = 0;\n        }\n\n        parent.assign(nn, -1);\n        depth.assign(nn, -1);\n        sz.assign(nn, 0);\n        sons.clear();\n        sons.resize(nn);\n\n        // dfs_set_root(id, cartesian_decomposition);\n\n\n        // set root using stack\n        stack<pair<int, int>> st;\t\t// id, # of sons processes\n        st.push({ id, 0 });\n        parent[id] = 0;\n        depth[id] = 0;\n\n        int ct = 0;\n\n        while (!st.empty()) {\n            int id = st.top().first, x = st.top().second;\n\n            if (x == 0) {\n                in[id] = ct;\n                pos[ct] = id;\n                sz[id] = 1;\n                ct++;\n            }\n\n            if (x >= adj[id].size()) {\n                out[id] = ct - 1;\n                if (parent[id] != -1) {\n                    sz[parent[id]] += sz[id];\n                }\n                st.pop();\n            }\n            else {\n\n                st.top().second++;\n\n                int p = adj[id][x];\n                if (parent[p] == -1) {\n                    parent[p] = id;\n                    depth[p] = depth[id] + 1;\n                    sons[id].push_back(p);\n                    st.push({ p, 0 });\n                }\n            }\n        }\n\n        int i = 0;\n    }\n\n    void eulerian_tour_dfs(int root, vector<int>& ans) {\n        ans.push_back(root);\n        for (auto p : sons[root]) {\n            eulerian_tour_dfs(p, ans);\n            ans.push_back(root);\n        }\n    }\n\n    vector<int> eulerian_tour(int root) {\n        vector<int> ans;\n\n        eulerian_tour_dfs(root, ans);\n\n        return ans;\n    }\n\n\n    void prep_LCA() {\t\t// prepare the sparse table for LCA calculation\n        MAXLEVEL = 1;\n        while ((1 << MAXLEVEL) < nn) MAXLEVEL++;\n        MAXLEVEL++;\n\n        pred.assign(MAXLEVEL, vector<int>(nn, 0));\n        pred[0] = parent;\n\n        int i, j, k;\n        for (i = 1; i < MAXLEVEL; i++) {\n            for (j = 0; j < nn; j++) {\n                if (pred[i - 1][j] != -1) pred[i][j] = pred[i - 1][pred[i - 1][j]];\n            }\n        }\n\n        called_LCA = true;\n    }\n\n    int get_p_ancestor(int a, int p) {\t\t// get p-ancestor of node a;  need to call set_root() and prep_LCA() first\n        if (!called_LCA) prep_LCA();\n\n        int i;\n        for (i = MAXLEVEL - 1; (i >= 0) && (p > 0) && (a != -1); i--) {\n            if ((1 << i) & p) {\n                p -= (1 << i);\n                a = pred[i][a];\n            }\n        }\n        return a;\n    }\n\n    int LCA(int a, int b) {\t\t// get the LCA of a and b, need to call set_root() and prep_LCA() first\n        if (!called_LCA) prep_LCA();\n        int da = depth[a], db = depth[b];\n\n        if (da > db) {\n            swap(da, db);\n            swap(a, b);\n        }\n\n        int i, j, k;\n        for (i = MAXLEVEL - 1; i >= 0; i--) {\n            if (db - (1 << i) >= da) {\n                db -= (1 << i);\n                b = pred[i][b];\n            }\n        }\n\n        if (a == b) return a;\n\n        for (i = MAXLEVEL - 1; i >= 0; i--) {\n            if (pred[i][a] != pred[i][b]) {\n                a = pred[i][a];\n                b = pred[i][b];\n            }\n        }\n\n        return parent[a];\n    }\n\n    int get_distance(int a, int b) {\t// get distance between a and b, need to call set_root() and prep_LCA() first\n        if (!called_LCA) prep_LCA();\n\n        int c = LCA(a, b);\n        int ans = depth[a] + depth[b] - 2 * depth[c];\n        return ans;\n    }\n\n    int get_diameter(VI& path) {\n        int a, b, c, i, j, k, id, INF = nn + 100, ans;\n        vector<int> dist(nn), last(nn);\n        queue<int> q;\n\n        if (nn == 1) return 0;\n\n        // first pass, start with 1 -- any node\n        a = 1;\n        dist.assign(nn, INF);\n        dist[a] = 0;\n        q.push(a);\n\n        while (!q.empty()) {\n            id = q.front();\n            q.pop();\n\n            for (auto p : adj[id]) {\n                if (dist[p] == INF) {\n                    dist[p] = dist[id] + 1;\n                    q.push(p);\n                }\n            }\n        }\n\n        // second pass, start from the most remote node id, collect last to get ID\n        a = id;\n        dist.assign(nn, INF);\n        last.assign(nn, -1);\n        dist[a] = 0;\n        q.push(a);\n\n        while (!q.empty()) {\n            id = q.front();\n            q.pop();\n\n            for (auto p : adj[id]) {\n                if (dist[p] == INF) {\n                    dist[p] = dist[id] + 1;\n                    last[p] = id;\n                    q.push(p);\n                }\n            }\n        }\n\n        // a and id forms the diameter\n        ans = dist[id];\n\n        //return ans;\n\n        // construct the path of diamter in path\n        path.clear();\n        b = id;\n        c = id;\n        do {\n            path.push_back(b);\n            b = last[b];\n        } while (b != -1);\n\n        return ans;\n    }\n};\n\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n1 = edges1.size() + 1, n2 = edges2.size() + 1;\n        tree tr1(n1), tr2(n2);\n        for (auto p : edges1) tr1.add_path(p[0], p[1]);\n        for (auto p : edges2) tr2.add_path(p[0], p[1]);\n        tr1.set_root(0);\n        tr2.set_root(0);\n        tr1.prep_LCA();\n        tr2.prep_LCA();\n\n        VI path;\n        int d1 = tr1.get_diameter(path);\n        int d2 = tr2.get_diameter(path);\n\n        int ans = (d1 + 1) / 2 + 1 + (d2 + 1) / 2;\n        ans = max(ans, max(d1, d2));\n        return ans;\n    }\n};\n",
    "submit_ts": "1719716057",
    "subm_id": "1304353806"
}