{
    "username": "Xenoid",
    "submission": "class Solution {\npublic:\n    void bfs(const vector<vector<int>>& neighbors, int start, int& end, std::vector<int>& path) {\n        std::queue<int> q;\n        std::vector<bool> visited;\n        std::vector<int> parent;\n        for(int i = 0; i < neighbors.size(); ++i) {\n            visited.push_back(false);\n            parent.push_back(-1);\n        }\n        q.push(start);\n        parent[start] = -1;\n        visited[start] = true;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            end = cur;\n            for(int neighbor : neighbors[cur]) {\n                if (!visited[neighbor]) {\n                    q.push(neighbor);\n                    visited[neighbor] = true;\n                    parent[neighbor] = cur;\n                }\n            }\n        }\n        path = {};\n        int cur = end;\n        while (parent[cur] != -1) {\n            path.push_back(cur);\n            cur = parent[cur];\n        }\n        path.push_back(cur);\n    }\n    int height(const vector<vector<int>>& neighbors, int node) {\n        int last;\n        std::vector<int> path;\n        bfs(neighbors, node, last, path);\n        return path.size() - 1;\n    }\n    int minTreeHeight(const vector<vector<int>>& neighbors) {\n        std::vector<int> path;\n        std::vector<int> path2;\n        int last;\n        int last2;\n        bfs(neighbors, 0, last, path);\n        bfs(neighbors, last, last2, path2);\n        return height(neighbors, path2[path2.size() / 2]);\n    }\n    int diameter(const vector<vector<int>>& neighbors) {\n        std::vector<int> path;\n        std::vector<int> path2;\n        int last;\n        int last2;\n        bfs(neighbors, 0, last, path);\n        bfs(neighbors, last, last2, path2);\n        return height(neighbors, path2[0]);\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        vector<vector<int>> neighbors1;\n        for(int i = 0; i <= edges1.size(); ++i) {\n            neighbors1.push_back({});\n        }\n        for(const vector<int>& edge: edges1) {\n            neighbors1[edge[0]].push_back(edge[1]);\n            neighbors1[edge[1]].push_back(edge[0]);\n        }\n\n        vector<vector<int>> neighbors2;\n        for(int i = 0; i <= edges2.size(); ++i) {\n            neighbors2.push_back({});\n        }\n        for(const vector<int>& edge: edges2) {\n            neighbors2[edge[0]].push_back(edge[1]);\n            neighbors2[edge[1]].push_back(edge[0]);\n        }\n        \n        int a = minTreeHeight(neighbors1);\n        int b = minTreeHeight(neighbors2);\n        int x = a + b + 1; // diameter crossing both trees\n        int y = diameter(neighbors1);\n        int z = diameter(neighbors2);        \n        return std::max(x, std::max(y, z));\n    }\n};",
    "submit_ts": 1719717595.0
}