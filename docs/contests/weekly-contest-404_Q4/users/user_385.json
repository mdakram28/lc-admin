{
    "username": "ceetcode",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, tree1: List[List[int]], tree2: List[List[int]]) -> int:\n        def calculate_diameter(tree, nodes):\n            def traverse(start_node):\n                distances = [-1] * nodes\n                distances[start_node] = 0\n                node_queue = deque([start_node])\n                furthest_node = start_node\n                while node_queue:\n                    current_node = node_queue.popleft()\n                    for adj_node in graph[current_node]:\n                        if distances[adj_node] == -1:\n                            distances[adj_node] = distances[current_node] + 1\n                            node_queue.append(adj_node)\n                            furthest_node = adj_node\n                return furthest_node, distances\n            \n            graph = [[] for _ in range(nodes)]\n            for node1, node2 in tree:\n                graph[node1].append(node2)\n                graph[node2].append(node1)\n                \n            far_node1, _ = traverse(0)\n            far_node2, dist2 = traverse(far_node1)\n            dia = dist2[far_node2]\n            return dia\n        \n        len1 = len(tree1) + 1\n        len2 = len(tree2) + 1\n        dia1 = calculate_diameter(tree1, len1)\n        dia2 = calculate_diameter(tree2, len2)\n        \n        merged_dia = ceil(dia1 / 2) + 1 + ceil(dia2 / 2)\n        #print(dia1, dia2)\n        return max(dia1, dia2, merged_dia)\n    ",
    "submit_ts": 1719718443.0
}