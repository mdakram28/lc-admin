{
    "username": "raararaara",
    "submission": "using lint = long long;\nusing ii = pair<int, int>;\nusing il = pair<int, lint>;\nusing li = pair<lint, int>;\nusing ll = pair<lint, lint>;\n\nconst int mxn = 1000100, mxp = 1000001;\nconst int MOD = 998244353, inf = -1e9 - 7, INF = 1e9 + 1;\nconst lint lnf = -4e18, LNF = 5e18;\nconst double eps = 1e-10;\nconst int sqrtN = 200;\n\n#define sz(x) int(size(x))\n#define all(x) (x).begin(),(x).end()\n#define compress(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())\n#define lb(x, v) (lower_bound(all(x), v) - (x).begin())\n#define ub(x, v) (upper_bound(all(x), v) - (x).begin())\n#define eb emplace_back\n#define pb push_back\n#define getName(var)  #var\nvector<lint> xl, yl;\n\n#define Yes \"Yes\\n\"\n#define No \"No\\n\"\n\nconst int dr[] = {-1, 0, 1, 0};\nconst int dc[] = {0, -1, 0, 1};\n\ninline int inRange(int r, int c, int R, int C) {\n    return 0 <= r && r < R && 0 <= c && c < C;\n}\n\nlint N, M, Q, R, C, H, K, T;\n\nvoid init() {\n\n}\n\ntemplate<typename T_Node, typename F>\nstruct SegTree {\n    int N{}, base{};\n    vector<T_Node> tree;\n    const F f{};\n    const T_Node I;\n\n    SegTree(int n, F _f, const T_Node &I) : N(n), f(_f), I(I) {\n        for (base = 1; base < N; base <<= 1);\n        tree = vector<T_Node>(base<<1|1, I);\n    }\n\n    SegTree(vector<T_Node> &v, F _f, const T_Node &I) : N(int(size(v))), f(_f), I(I) {\n        for (base = 1; base < N; base <<= 1);\n        tree = vector<T_Node>(base<<1|1, I);\n        copy(all(v), tree.begin() + base);\n        for(int i = base-1; ~i; --i) adjust(i);\n    }\n\n    T_Node get(int i) { return tree[i + base]; }\n\n    T_Node top() { return tree[1]; }\n\n    void upd(int i, T_Node v) {\n        tree[i += base] = v;\n        while (i >>= 1) adjust(i);\n    }\n\n    void adjust(int i) { tree[i] = f(tree[i << 1], tree[i << 1 | 1]); }\n\n    T_Node qry(int l, int r) {\n        T_Node retL = I, retR = I;\n        for (l += base, r += base; l <= r; l >>= 1, r >>= 1) {\n            if (l & 1) retL = f(retL, tree[l++]);\n            if (~r & 1) retR = f(tree[r--], retR);\n        }\n        return f(retL, retR);\n    }\n};\n\n\n// d[n][k] := n\uc73c\ub85c \ub05d\ub098\ub294 \ubd80\ubd84\uc218\uc5f4 \uc911 b[i] != b[i+1]\uc744 \ub9cc\uc871\ud558\ub294 \ucf00\uc774\uc2a4\uac00 k\uac1c\uc778 \uacbd\uc6b0\uc758 \ucd5c\uc7a5\uae38\uc774\nclass Solution {\npublic:\n    int maximumLength(vector<int>& a, int k) {\n        int n = sz(a);\n        for(auto &x: a) xl.eb(x);\n        compress(xl);\n        for(auto &x: a) x = lb(xl, x);\n        auto f = [](auto u, auto v) {\n            return max(u,v);\n        };\n        vector<SegTree<int, decltype(f)>> segV(k+1, SegTree<int, decltype(f)>(sz(xl), f, inf));\n        for(int i = 0; i < sz(xl); i++) {\n            for(int j = 0; j<= k; j++)\n                segV[j].upd(i, inf);\n        }\n        segV[0].upd(a[0], 1);\n\n        int ret = 1;\n        for(int i = 1; i < n; i++) {\n//            auto p = segV[0].get(a[i]);\n//            if(p < 1) segV[0].upd(a[i], 1);\n            for(int j = 0; j <= k; j++) {\n                auto prv = segV[j].get(a[i]);\n                segV[j].upd(a[i], max(1, prv+1));\n                if(j-1 >= 0) {\n                    auto lv = segV[j-1].qry(0, a[i]-1), rv = segV[j-1].qry(a[i]+1, sz(xl)-1);\n                    if(max(lv, rv) == inf) continue;\n                    prv = segV[j].get(a[i]);\n                    auto toUpd = max(lv, rv)+1;\n                    if(prv < toUpd) segV[j].upd(a[i], toUpd);\n                }\n\n            }\n        }\n        for(int i = 0; i <= k; i++) {\n            ret = max(ret, segV[i].qry(0, sz(xl)-1));\n        }\n        return ret;\n    }\n};",
    "submit_ts": 1717859635.0
}