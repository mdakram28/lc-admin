{
    "username": "badriisurmi",
    "submission": "/*\n\tJAI JAGANNATH!\n*/\n//@Author : zanj0\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ff              first\n#define ss              second\n#define pb              push_back\n#define MOD             1000000007\n#define inf             1e18\n\ntypedef long long int lli;\n\nclass UnionFind {\npublic:\n\tint* rank;\n\tint* parent;\n\tint n;\n\tUnionFind(int n) {\n\t\tthis->n = n;\n\t\tparent = new int[n];\n\t\trank = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 1;\n\t\t}\n\t}\n\tint getParent(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = getParent(parent[x]);\n\t}\n\tbool unite(int a, int b) {\n\t\tint parA = getParent(a);\n\t\tint parB = getParent(b);\n\t\tif (parA == parB) return false;\n\t\tif (rank[parA] >= rank[parB]) {\n\t\t\trank[parA] += rank[parB];\n\t\t\tparent[parB] = parA;\n\t\t} else {\n\t\t\trank[parB] += rank[parA];\n\t\t\tparent[parA] = parB;\n\t\t}\n\t\treturn true;\n\t}\n};\nclass Solution {\npublic:\n\tlli IsIntersect(lli x1, lli y1, lli x2, lli y2, lli r1, lli r2)\n\t{\n\t\tlong double d = sqrtl((x1 - x2) * (x1 - x2)\n\t\t                      + (y1 - y2) * (y1 - y2));\n\n\t\tif (d <= r1 - r2) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (d <= r2 - r1) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (d < r1 + r2) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (d == r1 + r2) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\tbool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n\t\tint n = circles.size();\n\n\t\tUnionFind uf = UnionFind(n);\n\n\t\tvector<string> circle_configuration(n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (circles[i][0] + circles[i].back() >= X) {\n\t\t\t\tcircle_configuration[i] += 'R';\n\t\t\t}\n\t\t\tif (circles[i][0] - circles[i].back() <= 0) {\n\t\t\t\tcircle_configuration[i] += 'L';\n\t\t\t}\n\n\t\t\tif (circles[i][1] + circles[i].back() >= Y) {\n\t\t\t\tcircle_configuration[i] += 'U';\n\t\t\t}\n\t\t\tif (circles[i][1] - circles[i].back() <= 0) {\n\t\t\t\tcircle_configuration[i] += 'D';\n\t\t\t}\n\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (IsIntersect(circles[i][0], circles[i][1], circles[j][0], circles[j][1], circles[i].back(), circles[j].back())) {\n\t\t\t\t\tuf.unite(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmap<int, set<char>> component_configuration;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (auto& it : circle_configuration[i]) {\n\t\t\t\tcomponent_configuration[uf.getParent(i)].insert(it);\n\t\t\t}\n\t\t}\n    cout << circle_configuration[0] << endl;\n\t\tfor (auto& it : component_configuration) {\n\t\t\tbool R = false, L = false, U = false, D = false;\n\t\t\tfor (auto& it2 : it.ss) {\n\t\t\t\tL = L || 'L' == it2;\n\t\t\t\tR = R || 'R' == it2;\n\t\t\t\tU = U || 'U' == it2;\n\t\t\t\tD = D || 'D' == it2;\n        cout << it.ff << \" \" << L << \" \" << R << \" \" << U << \" \" << D << endl;\n\t\t\t\tif ((L && R) || (U && D) || (R && U) || (L && D)) return false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\n\t}\n};\n\n#ifdef LOCAL\nint main() {\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tcout << \"Compiled!\" << endl;\n}\n#endif",
    "submit_ts": "1722136159",
    "subm_id": "1335725545"
}