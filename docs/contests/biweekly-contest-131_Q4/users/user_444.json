{
    "username": "sujal_prakash15",
    "submission": "class Solution {\npublic:\n    class SegmentTree {\n        public:\n            SegmentTree(int size) {\n                n = size;\n                tree.resize(4 * n);\n                lazy.resize(4 * n);\n            }\n\n            // Build the segment tree\n            void build(const std::vector<int>& data) {\n                build(0, 0, n - 1, data);\n            }\n\n            // Range update: set all elements in range [l, r] to 'value'\n            void rangeUpdate(int l, int r, int value) {\n                rangeUpdate(0, 0, n - 1, l, r, value);\n            }\n\n            // Query the maximum value in range [l, r]\n            int rangeQuery(int l, int r) {\n                return rangeQuery(0, 0, n - 1, l, r);\n            }\n\n        private:\n            int n;\n            std::vector<int> tree, lazy;\n\n            void build(int node, int start, int end, const std::vector<int>& data) {\n                if (start == end) {\n                    tree[node] = data[start];\n                } else {\n                    int mid = (start + end) / 2;\n                    build(2 * node + 1, start, mid, data);\n                    build(2 * node + 2, mid + 1, end, data);\n                    tree[node] = std::max(tree[2 * node + 1], tree[2 * node + 2]);\n                }\n            }\n\n            void propagate(int node, int start, int end) {\n                if (lazy[node] != 0) {\n                    tree[node] = lazy[node];\n                    if (start != end) {\n                        lazy[2 * node + 1] = lazy[node];\n                        lazy[2 * node + 2] = lazy[node];\n                    }\n                    lazy[node] = 0;\n                }\n            }\n\n            void rangeUpdate(int node, int start, int end, int l, int r, int value) {\n                propagate(node, start, end);\n                if (start > end || start > r || end < l) {\n                    return;\n                }\n                if (start >= l && end <= r) {\n                    tree[node] = value;\n                    if (start != end) {\n                        lazy[2 * node + 1] = value;\n                        lazy[2 * node + 2] = value;\n                    }\n                    return;\n                }\n                int mid = (start + end) / 2;\n                rangeUpdate(2 * node + 1, start, mid, l, r, value);\n                rangeUpdate(2 * node + 2, mid + 1, end, l, r, value);\n                tree[node] = std::max(tree[2 * node + 1], tree[2 * node + 2]);\n            }\n\n            int rangeQuery(int node, int start, int end, int l, int r) {\n                propagate(node, start, end);\n                if (start > end || start > r || end < l) {\n                    return INT_MIN;\n                }\n                if (start >= l && end <= r) {\n                    return tree[node];\n                }\n                int mid = (start + end) / 2;\n                return std::max(rangeQuery(2 * node + 1, start, mid, l, r),\n                                rangeQuery(2 * node + 2, mid + 1, end, l, r));\n            }\n        };\n    vector<bool> getResults(vector<vector<int>>& q) {\n        int n=q.size();\n        SegmentTree st(50002);\n        st.rangeUpdate(0,50001,0);\n        set<int> st1;\n        st1.insert(0);\n        vector<bool> ans;\n        for(int i=0;i<n;i++)\n        {\n            int t=q[i][0];\n            if(t==1)\n            {\n                int x=q[i][1];\n                auto it=st1.upper_bound(x);\n                if(it==st1.end())\n                {\n                    it--;\n                    int l=*it;\n                    st.rangeUpdate(l+1,x,(x-l));\n                }\n                else\n                {\n                    int r=*it;\n                    it--;\n                    int l=*it;\n                    st.rangeUpdate(l+1,r,-1*(r-l));\n                    st.rangeUpdate(l+1,x,(x-l));\n                    st.rangeUpdate(x+1,r,(r-x));\n                }\n                st1.insert(x);\n            }\n            else\n            {\n                int x=q[i][1];\n                int sz=q[i][2];\n                auto it=st1.upper_bound(x);\n                it--;\n                int r=*it;\n                int val=st.rangeQuery(0,r);\n                int mx=max(val,(x-r));\n                if(mx>=sz){ans.push_back(true);}\n                else{ans.push_back(false);}\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716652733.0
}