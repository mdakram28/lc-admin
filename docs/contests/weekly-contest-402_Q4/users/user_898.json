{
    "username": "flowing",
    "submission": "class Solution {\n\n    static class SegmentTree {\n        static class Node {\n            int left, right, value;\n            Node leftChild, rightChild;\n\n            Node(int left, int right) {\n                this.left = left;\n                this.right = right;\n                this.value = 0;\n            }\n        }\n\n        private Node root;\n        private int[] nums;\n\n        public SegmentTree(int[] nums) {\n            this.nums = nums;\n            this.root = buildTree(0, nums.length - 1);\n        }\n\n        private Node buildTree(int left, int right) {\n            Node node = new Node(left, right);\n            if (left == right) {\n                node.value = midCheck(nums, nums[left], left) ? 1 : 0;\n                return node;\n            }\n\n            int mid = left + (right - left) / 2;\n            node.leftChild = buildTree(left, mid);\n            node.rightChild = buildTree(mid + 1, right);\n            node.value = node.leftChild.value + node.rightChild.value;\n\n            return node;\n        }\n\n        public void update(int index, int newValue) {\n            update(root, index, newValue);\n        }\n\n        private void update(Node node, int index, int newValue) {\n            if (node.left == node.right) {\n                nums[index] = newValue;\n                node.value = midCheck(nums, newValue, node.left) ? 1 : 0;\n                return;\n            }\n\n            int mid = (node.right + node.left) / 2;\n            if (index <= mid) {\n                update(node.leftChild, index, newValue);\n            } else {\n                update(node.rightChild, index, newValue);\n            }\n            node.value = node.leftChild.value + node.rightChild.value;\n        }\n\n        public int query(int left, int right) {\n            return query(root, left, right);\n        }\n\n        private int query(Node node, int left, int right) {\n            // System.out.println(\"val:\" + node.value + \" left:\" + left + \" right:\" + right);\n            if (node.left == left && node.right == right) {\n                return node.value;\n            }\n\n            int mid = node.left + (node.right - node.left) / 2;\n            if (right <= mid) {\n                return query(node.leftChild, left, right);\n            } else if (left > mid) {\n                return query(node.rightChild, left, right);\n            } else {\n                return query(node.leftChild, left, mid) + query(node.rightChild, mid + 1, right);\n            }\n        }\n    }\n\n    public static boolean midCheck(int[] nums, int num, int curIdx) {\n        if (curIdx == 0 || curIdx == nums.length - 1) {\n            return false;\n        }\n        return num > nums[curIdx - 1] && num > nums[curIdx + 1];\n    }\n    public static List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        SegmentTree segmentTree = new SegmentTree(nums);\n        List<Integer> ans = new ArrayList<>();\n        for (int[] query : queries) {\n            if (query[0] == 1) {\n                int res = segmentTree.query(query[1], query[2]);\n                if (midCheck(nums, nums[query[1]], query[1])) {\n                    res--;\n                }\n                if (query[1] != query[2] && midCheck(nums, nums[query[2]], query[2])) {\n                    res--;\n                }\n                ans.add(res);\n            } else {\n                segmentTree.update(query[1], query[2]);\n                if (query[1] - 1 >= 0) {\n                    segmentTree.update(query[1] - 1, segmentTree.nums[query[1] - 1]);\n                }\n                if (query[1] + 1 < nums.length) {\n                    segmentTree.update(query[1] + 1, segmentTree.nums[query[1] + 1]);\n                }\n            }/*\n            for (int i = 0; i < nums.length; i++) {\n                System.out.print(segmentTree.query(i, i));\n            }\n            System.out.println(\"\");*/\n        }\n        return ans;\n    }\n}",
    "submit_ts": 1718508448.0
}