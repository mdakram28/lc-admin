{
    "username": "birenamanta",
    "submission": "import java.util.*;\n\npublic class Solution {\n\n    public boolean solve(int X, int Y, int[][] circles) {\n        int numCircles = circles.length;\n        boolean[][] graph = new boolean[numCircles + 4][numCircles + 4];\n\n        for (int i = 0; i < numCircles; i++) {\n            int x = circles[i][0];\n            int y = circles[i][1];\n            int r = circles[i][2];\n\n            if (x <= r) {\n                graph[numCircles][i] = true;\n                graph[i][numCircles] = true;\n            }\n            if (X - x <= r) {\n                graph[numCircles + 2][i] = true;\n                graph[i][numCircles + 2] = true;\n            }\n            if (y <= r) {\n                graph[numCircles + 1][i] = true;\n                graph[i][numCircles + 1] = true;\n            }\n            if (Y - y <= r) {\n                graph[numCircles + 3][i] = true;\n                graph[i][numCircles + 3] = true;\n            }\n            for (int j = i + 1; j < numCircles; j++) {\n                int otherX = circles[j][0];\n                int otherY = circles[j][1];\n                int otherR = circles[j][2];\n\n                double dist = Math.sqrt(Math.pow(x - otherX, 2) + Math.pow(y - otherY, 2));\n                int radSum = r + otherR;\n\n                if (radSum >= dist) {\n                    graph[i][j] = true;\n                    graph[j][i] = true;\n                }\n            }\n        }\n\n        boolean isBlocked = false;\n\n        isBlocked |= bfs(graph, numCircles, numCircles + 1, numCircles + 2, numCircles + 4);\n        isBlocked |= bfs(graph, numCircles + 3, numCircles + 2, numCircles + 1, numCircles + 4);\n\n        return !isBlocked;\n    }\n\n    public boolean bfs(boolean[][] graph, int start, int target1, int target2, int n) {\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] visited = new boolean[n + 4];\n\n        queue.add(start);\n        visited[start] = true;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (int v = 0; v < graph.length; v++) {\n                if (graph[u][v] && !visited[v]) {\n                    queue.add(v);\n                    visited[v] = true;\n                }\n            }\n        }\n\n        return visited[target1] || visited[target2];\n    }\n\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        return solve(X, Y, circles);\n    }\n}\n",
    "submit_ts": "1722138452",
    "subm_id": "1335791130"
}