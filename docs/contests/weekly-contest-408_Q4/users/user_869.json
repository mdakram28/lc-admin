{
    "username": "Kevinc00",
    "submission": "\n#define ll long long \ntypedef struct Circle {\n    ll x, y, r;\n    Circle(ll _x, ll _y, ll _r) : x(_x), y(_y), r(_r) {}\n} Circle;\n\ntypedef struct BoundingBox {\n    ll minX, minY, maxX, maxY;\n    BoundingBox(ll min_x, ll min_y, ll max_x, ll max_y) : minX(min_x), minY(min_y), maxX(max_x), maxY(max_y) {}\n} BoundingBox;\n\nbool circlesllersect(const Circle& c1, const Circle& c2) {\n    ll dx = c2.x - c1.x;\n    ll dy = c2.y - c1.y;\n    ll distanceSquared = dx * dx + dy * dy;\n    ll radiusSum = c1.r + c2.r;\n    ll radiusDiff = abs(c1.r - c2.r);\n    return (distanceSquared <= radiusSum * radiusSum) && (distanceSquared >= radiusDiff * radiusDiff);\n}\n\nvoid dfs(ll node, const vector<vector<ll>>& graph, vector<bool>& visited, vector<ll>& component) {\n    visited[node] = true;\n    component.push_back(node);\n    for (ll neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, graph, visited, component);\n        }\n    }\n}\n\nBoundingBox computeBoundingBox(const vector<Circle>& circles, const vector<ll>& component) {\n    ll minX = numeric_limits<ll>::max();\n    ll minY = numeric_limits<ll>::max();\n    ll maxX = numeric_limits<ll>::min();\n    ll maxY = numeric_limits<ll>::min();\n    \n    for (ll idx : component) {\n        const Circle& c = circles[idx];\n        minX = min(minX, c.x - c.r);\n        minY = min(minY, c.y - c.r);\n        maxX = max(maxX, c.x + c.r);\n        maxY = max(maxY, c.y + c.r);\n    }\n    \n    return BoundingBox(minX, minY, maxX, maxY);\n}\n\nvector<BoundingBox> getBoundingBoxes(const vector<Circle>& circles) {\n    ll n = circles.size();\n    vector<vector<ll>> graph(n);\n    \n    // Construct the graph\n    for (ll i = 0; i < n; ++i) {\n        for (ll j = i + 1; j < n; ++j) {\n            if (circlesllersect(circles[i], circles[j])) {\n                graph[i].push_back(j);\n                graph[j].push_back(i);\n            }\n        }\n    }\n    \n    vector<bool> visited(n, false);\n    vector<BoundingBox> boundingBoxes;\n    \n    // Find all connected components\n    for (ll i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            vector<ll> component;\n            dfs(i, graph, visited, component);\n            BoundingBox bbox = computeBoundingBox(circles, component);\n            boundingBoxes.push_back(bbox);\n        }\n    }\n    \n    return boundingBoxes;\n}\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        vector<Circle> c;\n        for(auto& v:circles){\n            c.push_back(Circle(v[0],v[1],v[2]));\n        }\n        vector<BoundingBox> boundingBoxes = getBoundingBoxes(c);\n        \n        for(auto& v: boundingBoxes){\n            if(v.minX <= 0){\n                if(v.maxX >= X || v.minY <= 0)return false;\n            }\n            if(v.maxX >= X){\n                if(v.maxY >= Y) return false;\n            }\n            if(v.maxY >= Y){\n                if(v.minY <=0) return false;\n            }\n        }\n        return true;\n    }\n};",
    "submit_ts": "1722138253",
    "subm_id": "1335786042"
}