{
    "username": "Deepanshu_Jindal",
    "submission": "import java.util.*;\n\npublic class Solution {\n\n    public int minFlips(int[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        int flips = 0;\n        \n        // Check if the grid has odd rows and columns\n        flips += (rows % 2 == 1 && cols % 2 == 1) ? (grid[rows / 2][cols / 2] == 1 ? 1 : 0) : 0;\n\n        int[] count = new int[3];\n        Arrays.fill(count, 0);\n        \n        flips += calculateRowFlips(grid, rows, cols, count);\n        flips += calculateColFlips(grid, rows, cols, count);\n        \n        flips += adjustFlips(count);\n        flips += calculateCornerFlips(grid, rows, cols);\n        \n        return flips;\n    }\n    \n    private int calculateRowFlips(int[][] grid, int rows, int cols, int[] count) {\n        int start = 0;\n        int end = cols - 1;\n        int rowFlips = 0;\n\n        // Handle the case where rows are odd\n        rowFlips += (rows % 2 == 1) ? processRowFlips(grid, rows, cols, count, start, end) : 0;\n\n        return rowFlips;\n    }\n\n    private int processRowFlips(int[][] grid, int rows, int cols, int[] count, int start, int end) {\n        int rowFlips = 0;\n        while (start < end) {\n            int sum = grid[rows / 2][start] + grid[rows / 2][end];\n            count[sum] += 1;\n            start += 1;\n            end -= 1;\n        }\n        return rowFlips;\n    }\n\n    private int calculateColFlips(int[][] grid, int rows, int cols, int[] count) {\n        int start = 0;\n        int end = rows - 1;\n        int colFlips = 0;\n\n        // Handle the case where columns are odd\n        colFlips += (cols % 2 == 1) ? processColFlips(grid, rows, cols, count, start, end) : 0;\n\n        return colFlips;\n    }\n\n    private int processColFlips(int[][] grid, int rows, int cols, int[] count, int start, int end) {\n        int colFlips = 0;\n        while (start < end) {\n            int sum = grid[start][cols / 2] + grid[end][cols / 2];\n            count[sum] += 1;\n            start += 1;\n            end -= 1;\n        }\n        return colFlips;\n    }\n\n    private int adjustFlips(int[] count) {\n        // Use ternary operators to adjust flips\n        return (count[2] % 2 == 1) ? ((count[1] > 0) ? count[1] : 2) : count[1];\n    }\n\n    private int calculateCornerFlips(int[][] grid, int rows, int cols) {\n        int flips = 0;\n\n        for (int i = 0; i < rows / 2; ++i) {\n            for (int j = 0; j < cols / 2; ++j) {\n                int apple = grid[i][j];\n                int banana = grid[rows - 1 - i][j];\n                int cherry = grid[i][cols - 1 - j];\n                int date = grid[rows - 1 - i][cols - 1 - j];\n\n                int sum = apple + banana + cherry + date;\n\n                // Use ternary operator to calculate minimum flips\n                flips += (sum != 0 && sum != 4) ? Math.min(sum, 4 - sum) : 0;\n            }\n        }\n\n        return flips;\n    }\n}\n\n\n",
    "submit_ts": "1722699692",
    "subm_id": "1343219406"
}