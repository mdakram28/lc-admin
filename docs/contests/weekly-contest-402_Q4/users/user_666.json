{
    "username": "trying_n_trying",
    "submission": "\n/*\n \n File   : Leetcode.cpp\n -------------------\n |   Hello         |\n |   DSA !         |\n -------------------\n \n */\n\n#define mii map<int,int>\n#define vi vector<int>\n#define vs vector<string>\n#define vb vector<bool>\n#define pii pair<int,int>\n#define endl \"\\n\"\n#define intmax INT_MAX\n#define intmin INT_MIN\n#define need_for_speed ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define ff(i,a,b) for(int i=a;i<b;i++)\n#define rfor(i,a,b) for(int i=a;i>=b;i--)\n#define all(x) x.begin(),x.end()\n#define pt(x) { cout<<x<<\"\\n\"; }\n#define fs first.second\n#define ss second.second\n#define countofSet(x) __builtin_popcount(x)\n#define pb push_back\n#define fir first\n#define sec second\n#define sqrt(x) sqrtl(x)\n\nclass STNode\n{\n    \npublic:\n    int sm;\n    STNode(){\n        \n    }\n    \n    STNode(int x) {\n        sm = x;\n    }\n};\n\nclass ST\n{\n    \npublic:\n    int size;\n    vi arr;\n    vector< STNode > tree;\n    \n    STNode mop(STNode &a,STNode &b)\n    {\n        STNode ans(0);\n        ans.sm = a.sm + b.sm;\n        return ans;\n    }\n    \n    ST(int sz,vi nums)\n    {\n        size = sz;\n        tree.resize(4*sz);\n        arr = nums;\n    };\n    \n    void STBuildFunc(int cur,int l,int r)\n    {\n        int md = (l+r)/2;\n        \n        if(l==r)\n        {\n            tree[cur] = STNode(arr[l]);\n            return;\n        }\n        STBuildFunc(2*cur,    l     , md);\n        STBuildFunc(2*cur+1 , md+1 , r  );\n        tree[cur] = mop( tree[2*cur] , tree[2*cur+1] );\n    }\n    \n    STNode STQueryFunction(int cur,int l,int r,int lq,int rq)\n    {\n        if( rq<l || lq > r ) {\n            return STNode(0);\n        }\n        \n        int md = (l+r)/2;\n        if( lq<=l && r<=rq ) return tree[cur];\n        \n        STNode lft = STQueryFunction(2*cur, l, md, lq, rq);\n        STNode rgt = STQueryFunction(2*cur+1, md+1, r, lq, rq);\n        STNode ans = mop( lft,rgt);\n        return ans;\n        \n    }\n    \n    void STUpdatefunc(int cur,int l,int r,int idx,int val)\n    {\n        if( idx<l || idx>r ) return;\n        \n        if( l==idx && r==idx )\n        {\n            tree[cur].sm = val;\n            return;\n        }\n        int md = (l+r)/2;\n        STUpdatefunc(2*cur,l,md,idx , val);\n        STUpdatefunc(2*cur+1,md+1,r ,idx,val);\n        tree[cur] = mop(tree[2*cur],tree[2*cur+1] );\n    }\n    \n};\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries)\n    {\n        int n = (int)nums.size();\n        vi arr(n,0),ret;\n        \n        ff(i,1,n-1)\n        {\n            if( nums[i] > nums[i-1] && nums[i] > nums[i+1] ) arr[i] = 1;\n        }\n        \n        ff(i,0,n)\n        {\n            if( arr[i] != 1 )\n            {\n                arr[i] = 0;\n            }\n        }\n        \n        \n        ST st(n, arr);\n        st.STBuildFunc(1,0,n-1);\n        \n        for(auto it:queries)\n        {\n            int opop = it[0], l=it[1],r= it[2];\n            if(opop == 2)\n            {\n                vi proc;\n                proc.pb(l-1);\n                proc.pb(l);\n                proc.pb(l+1);\n                \n                nums[l] = r;\n                for(auto i:proc)\n                {\n                    if( i-1 >= 0  && i +1 < n )\n                    {\n                        if( nums[i] > nums[i-1] && nums[i] > nums[i+1] ) st.STUpdatefunc(1,0,n-1,i,1);\n                        else st.STUpdatefunc(1,0,n-1,i,0);\n                    }\n                }\n                \n            }else\n            {\n                ret.pb(st.STQueryFunction(1,0,n-1, l+1, r-1).sm);\n            }\n        }\n        \n        return ret;\n    }\n};\n\n",
    "submit_ts": 1718508479.0
}