{
    "username": "timothyleong97",
    "submission": "class Solution {\npublic:\n    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n        vector<long long> memo;\n        memo.reserve(s.length());\n\n        for (int left {}, right {}, zeros {}, ones {}; right < s.length(); ++right) {\n            char curr = s[right];\n            if (curr == '0') {\n                ++zeros;\n            } else {\n                ++ones;\n            }\n\n            while (zeros > k && ones > k) {\n                curr = s[left];\n                if (curr == '0') {\n                    --zeros;\n                } else {\n                    --ones;\n                }\n                ++left;\n            }\n            memo.push_back(right - left + 1);\n        }\n\n        // for (auto i : memo) cout << i << \" \";\n        // cout << endl;\n\n        vector<long long> memo_prefix;\n        memo_prefix.reserve(memo.size());\n        memo_prefix[0] = memo[0];\n        for (int i {1}; i < memo.size(); ++i) {\n            memo_prefix[i] = memo[i] + memo_prefix[i - 1];\n        }\n\n        vector<long long> answer;\n        answer.reserve(queries.size());\n\n        for (auto& query : queries) {\n            const int start = query[0];\n            const int end = query[1];\n\n            // In [start..end], some memo[i]'s will include characters to the left of start.\n            // Once your left most position is >= start, the subsequent memo[i]'s will have the same property.\n            // Thus you can use binary search to find this cutoff - everything from this cutoff utilises\n            // prefix sum, and everything to the left of this cutoff utilises the arithmetic series.\n            int left = start, right = end;\n            while (left <= right) {\n                const int candidate = (left + right) >> 1;\n                // cout << \"Binary search \" << left << \" \" << right << \" \" << candidate << endl;\n                const int num_subs = memo[candidate];\n                const int left_for_candidate = candidate - memo[candidate] + 1;\n                // cout << \"Left most \" << left_for_candidate << endl;\n                if (left_for_candidate >= start) {\n                    // All others after this candidate will have this property\n                    right = candidate;\n                    if (left == right) break;\n                } else {\n                    left = candidate + 1;\n                }\n            }\n            // From start to left - 1, use arithmetic series\n            // From left to end, use prefix sum\n            long long result = 0;\n            if (start < left) {\n                long long length = left - start;\n                result += (1 + length) * length / 2;\n            }\n\n            // cout << start << \" \" << end << \" \" << left << \" \" << right << \" \" << memo_prefix[end] - (left > 0 ? memo_prefix[left - 1] : 0) << endl;\n\n            if (left <= end) {\n                result += memo_prefix[end] - (left > 0 ? memo_prefix[left - 1] : 0);\n            }\n\n            answer.push_back(result);\n        }\n\n        return answer;\n    }\n};\n",
    "submit_ts": "1723951593",
    "subm_id": "1359775334"
}