{
    "username": "lu-chen-chen",
    "submission": "class Solution {\n    public long minimumOperations(int[] nums, int[] target) {\n        int n = nums.length;\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = nums[i] - target[i];\n        }\n        long ans = 0;\n        List<Long> list = new ArrayList<>();\n        long p = 0;\n        for (int i = 0; i < n; i++) {\n            if (arr[i] == 0) {\n                ans += calc(list);\n                list.clear();\n                p = 0;\n                continue;\n            }\n            long v = arr[i] / Math.abs(arr[i]);\n            if (p == 0) {\n                list.add(arr[i]);\n                p = v;\n                continue;\n            }\n            if (p == v) {\n                list.add(arr[i]);\n                continue;\n            }\n            ans += calc(list);\n            list.clear();\n            list.add(arr[i]);\n            p = v;\n        }\n        ans += calc(list);\n        return ans;\n    }\n\n    ST st;\n    long[] arr;\n    Map<Long, List<Integer>> map;\n\n    private long calc(List<Long> list) {\n        if (list.isEmpty()) {\n            return 0;\n        }\n        int n = list.size();\n        arr = new long[n];\n        map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            arr[i] = Math.abs(list.get(i));\n            List<Integer> list1 = map.computeIfAbsent(arr[i], k -> new ArrayList<>());\n            list1.add(i);\n        }\n        for (List<Integer> value : map.values()) {\n            value.sort(Comparator.comparingInt(o -> o));\n        }\n        st = new ST(arr);\n        return dfs(0, n - 1, 0);\n    }\n\n    private long dfs(int l, int r, long d) {\n        if (l == r) {\n            return arr[l] - d;\n        }\n        if (l + 1 == r) {\n            return Math.max(arr[l], arr[r]) - d;\n        }\n        long query = st.query(l, r);\n        List<Integer> list = map.get(query);\n        int mid = binarySearch(list, l);\n        long a = 0;\n        long b = 0;\n        if (mid - 1 >= l) {\n            a = dfs(l, mid - 1, query);\n        }\n        if (mid + 1 <= r) {\n            b = dfs(mid + 1, r, query);\n        }\n        return query - d + a + b;\n    }\n\n    private int binarySearch(List<Integer> list, int x) {\n        int l = 0;\n        int r = list.size() - 1;\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (list.get(mid) >= x) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return list.get(l);\n    }\n}\n\nclass ST {\n    long[][] f;\n    int[] log2;\n\n    public ST(long[] a) {\n        int n = a.length;\n        log2 = new int[n + 1];\n        int k = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i >= (1 << (k + 1))) {\n                k++;\n            }\n            log2[i] = k;\n        }\n        int t = log2[n] + 1;\n        f = new long[n][t];\n        for (int i = 0; i < n; i++) {\n            f[i][0] = a[i];\n        }\n        for (int j = 1; j < t; j++) {\n            for (int i = 0; i < n - (1 << j) + 1; i++) {\n                f[i][j] = Math.min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);\n            }\n        }\n    }\n\n    public long query(int l, int r) {\n        // \u4e0b\u6807\u4ece0\u5f00\u59cb\uff0c\u5de6\u95ed\u53f3\u95ed\n        int k = log2[r - l + 1];\n        return Math.min(f[l][k], f[r - (1 << k) + 1][k]);\n    }\n}\n",
    "submit_ts": "1721531734",
    "subm_id": "548388229"
}