{
    "username": "lickcock",
    "submission": "#include <bits/stdc++.h> \n\n#define DEBUG_ON\n#define TERRORIST\n\n#ifdef TERRORIST\nusing namespace std;\n#define int64_t wadwafesfesfes21321300242142104210321\nusing int64_t = long long;\nusing pii = pair<int,int>;\nusing pil = pair<int,int64_t>;\nusing pli = pair<int64_t,int>;\nusing pll = pair<int64_t,int64_t>;\n#define PI 3.14159265358979323846\n#define umap unordered_map\n#define uset unordered_set\n#define all(x) x.begin(), x.end()\n#define allr(x) x.rbegin(), x.rend()\n#define emp_back emplace_back\n#define bitcount(x) __builtin_popcount((x))\n#define mbin(val, cap) bitset<64>(val).to_string().substr(64 - cap)\n#ifdef DEBUG_ON\n    #define debug(x) cout << \"[ \" << #x << \" ]: \" << x << \"\\n\";\n    #define e_ cout << \"\\n\";\n#else\n    #define debug(x)\n    #define e_\n#endif\n\ntemplate<typename F, typename S> ostream& operator<<(ostream &cout, pair<F, S> const &p) { return cout << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate<typename T> ostream& operator<<(ostream &cout, vector<T> const &v) {\n    cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\";\n}\ntemplate <typename K, typename V> ostream& operator<<(ostream& cout, const map<K, V>& omp) {\n    for(auto& [k, v] : omp){ cout << \"(\" << k << \": \" << v << \")\"; if(&v != &omp.rbegin()->second) cout << \", \";} return cout;\n}\ntemplate<typename T> ostream& operator << (ostream& cout, const set<T>& ost) {\n    cout << \"{\";  for(auto& v : ost){ cout << v; if(v != *ost.rbegin()) cout << \", \"; } return cout << \"}\";\n}\ntemplate<typename T, typename Cmp = less<T>>\noptional<vector<T>> get_unique(vector<T>& who, bool in_place = true, Cmp compare = Cmp()){\n    if(in_place){ sort(all(who), compare); who.erase(unique(all(who)), who.end()); return nullopt;}\n    vector<T> ret = who; sort(all(ret), compare); ret.erase(unique(all(ret)), ret.end()); return ret;\n}\nmt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate <typename T>\nT mrand(T begin, T end) {\n    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } \n    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }\n}\nint fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();\n//down, right, up, left, upleft, downright, upright, downleft, stay\nconstexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};\nconstexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};\n#endif\n\ntemplate <typename T>\nstruct SparseTable {\n    vector<vector<T>> table;\n    function<T(T&, T&)> Compare;\n\n    SparseTable(){}\n    SparseTable(const vector<T>& nums, function<T(T&, T&)> comp) { build(nums, comp); }\n\n    void build(const vector<T>& nums, function<T(T&, T&)> comp) {\n        Compare = comp;\n        int n = nums.size();\n        int logN = log2(n) + 1;\n\n        table.resize(n, vector<T>(logN));\n\n        // Fill the base cases\n        for(int i = 0; i < n; ++i)\n            table[i][0] = nums[i];\n\n        // Fill the rest of the table\n        for(int j = 1; (1 << j) <= n; ++j)\n            for(int i = 0; i + (1 << j) - 1 < n; ++i)\n                table[i][j] = Compare(table[i][j - 1], table[i + (1 << (j - 1))][j - 1]);\n    }\n\n    T find(int left, int right) {\n        int k = log2(right - left + 1);\n        return Compare(table[left][k], table[right - (1 << k) + 1][k]);\n    }\n};\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        const int n = nums.size();\n        SparseTable<int> table(nums, [](auto& A, auto& B){\n            return A & B;\n        });\n\n        auto calc = [&](int begin) -> int {\n            if(table.find(begin, begin) < k) return -1;\n\n            int left = begin;\n            int right = n - 1;\n            int whr = n - 1;\n            while(left <= right){\n                int mid = left + (right - left) / 2;\n                if(table.find(begin, mid) <= k)\n                    whr = mid, right = mid - 1;\n                else\n                    left = mid + 1; \n            }\n\n            return whr;\n        };\n\n        // for(int i = 0; i < n; i++){\n        //     int got = nums[i];\n        //     for(int j = i; j < n; j++){\n        //         got &= nums[j];\n        //         if(got != k) continue;\n        //         debug(i) debug(j) e_\n        //     }\n        // }\n\n        int64_t ans = 0;\n        for(int i = 0; i < n; i++){\n            int begin = calc(i);\n            if(begin == -1) continue;\n            if(table.find(i, begin) != k) continue;\n\n            int left = begin;\n            int right = n - 1;\n            int end = begin;\n            while(left <= right){\n                int mid = left + (right - left) / 2;\n                if(table.find(i, mid) >= k)\n                    end = mid, left = mid + 1;\n                else\n                    right = mid - 1;\n            }\n\n            // debug(i)\n            // debug(begin)\n            // debug(end)\n            // debug(table.find(i, end)) e_\n            ans += end - begin + 1;\n        }\n\n        return ans;\n    }\n};\n\n// #define MAIN_ACTIVE\n#ifdef MAIN_ACTIVE\nvoid solve() {}\nint main() {\n    int test_case;\n    cin >> test_case;\n    while(test_case--)\n        solve();\n\n    return EXIT_SUCCESS;\n}\n#endif",
    "submit_ts": "1720280928",
    "subm_id": "1311807026"
}