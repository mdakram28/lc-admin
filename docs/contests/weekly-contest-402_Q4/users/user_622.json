{
    "username": "humbl_pi",
    "submission": "#Segment tree node\nclass Node(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        self.total = 0\n        self.left = None\n        self.right = None\n\nclass NumArray(object):\n    def __init__(self, nums):\n        #helper function to create the tree from input array\n        def createTree(peaks, l, r):\n            #base case\n            if l > r:\n                return None\n            #leaf node\n            if l == r:\n                n = Node(l, r)\n                n.total = peaks[l]\n                return n\n\n            mid = (l + r) // 2\n            root = Node(l, r)\n\n            #recursively build the Segment tree\n            root.left = createTree(peaks, l, mid)\n            root.right = createTree(peaks, mid+1, r)\n\n            #Total stores the sum of all leaves under root\n            #i.e. those elements lying between (start, end)\n            root.total = root.left.total + root.right.total\n\n            return root\n        \n        self.nums = nums\n        self.n = len(self.nums)\n        self.peaks = [0] + [int((num2>num1) and (num2>num3)) for (num1,num2,num3) in zip(nums,nums[1:],nums[2:])] + [0]\n        self.root = createTree(self.peaks, 0, self.n-1)\n\n    def update(self, i, val):\n        \"\"\"\n        :type i: int\n        :type val: int\n        :rtype: int\n        \"\"\"\n        #Helper function to update a value\n        def updateVal(root, i, val):\n\n            #Base case. The actual value will be updated in a leaf.\n            #The total is then propogated upwards\n            if root.start == root.end:\n                root.total = val\n                return val\n\n            mid = (root.start + root.end) // 2\n\n            #If the index is less than the mid, that leaf must be in the left subtree\n            if i <= mid:\n                updateVal(root.left, i, val)\n            #Otherwise, the right subtree\n            else:\n                updateVal(root.right, i, val)\n\n            #Propogate the changes after recursive call returns\n            root.total = root.left.total + root.right.total\n\n            # return root.total\n        \n        self.nums[i] = val ## update value\n        ## self peak?\n        for j in [i-1,i,i+1]:\n            ## should it be a peak?\n            if (1<=j<=self.n-2) and (self.nums[j]>self.nums[j-1]) and (self.nums[j]>self.nums[j+1]):\n                if self.peaks[j] != 1:\n                    self.peaks[j] = 1\n                    updateVal(self.root, j, 1)\n            elif (0<=j<=self.n-1) and (self.peaks[j]!=0):\n                self.peaks[j] = 0\n                updateVal(self.root, j, 0)\n            \n        # return updateVal(self.root, i, val)\n\n    def sumRange(self, i, j):\n        \"\"\"\n        sum of elements nums[i..j], inclusive.\n        :type i: int\n        :type j: int\n        :rtype: int\n        \"\"\"\n        #Helper function to calculate range sum\n        def rangeSum(root, i, j):\n\n            #If the range exactly matches the root, we already have the sum\n            if root.start == i and root.end == j:\n                return root.total\n\n            mid = (root.start + root.end) // 2\n\n            #If end of the range is less than the mid, the entire interval lies\n            #in the left subtree\n            if j <= mid:\n                return rangeSum(root.left, i, j)\n\n            #If start of the interval is greater than mid, the entire inteval lies\n            #in the right subtree\n            elif i >= mid + 1:\n                return rangeSum(root.right, i, j)\n\n            #Otherwise, the interval is split. So we calculate the sum recursively,\n            #by splitting the interval\n            else:\n                return rangeSum(root.left, i, mid) + rangeSum(root.right, mid+1, j)\n        \n        cutoff = self.peaks[i]\n        if i!=j: cutoff += self.peaks[j]\n        return rangeSum(self.root, i, j) - cutoff\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        \n        segtree = NumArray(nums)\n        ans = []\n        \n        ## process queries\n        for (qtype, inp1, inp2) in queries:\n            ## queries[i] = [1, li, ri], determine the count of peak elements in the subarray nums[li..ri].\n            if qtype==1:\n                # print(segtree.peaks)\n                ans.append(segtree.sumRange(inp1, inp2))\n            ## queries[i] = [2, indexi, vali], change nums[indexi] to vali.\n            else:\n                segtree.update(inp1, inp2)\n        \n        return ans\n        \n",
    "submit_ts": 1718507758.0
}