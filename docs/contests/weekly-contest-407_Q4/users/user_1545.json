{
    "username": "st019",
    "submission": "class SegmentTree {\npublic:\n    SegmentTree(const std::vector<int>& array) {\n        n = array.size();\n        arr = array;\n        tree.resize(4 * n);\n        build(0, 0, n - 1);\n    }\n\n    int rangeMinIndex(int L, int R) {\n        return query(0, 0, n - 1, L, R);\n    }\n\n    void pointUpdate(int idx, int value) {\n        update(0, 0, n - 1, idx, value);\n    }\n\nprivate:\n    std::vector<int> arr;\n    std::vector<int> tree;\n    int n;\n\n    void build(int node, int start, int end) {\n        if (start == end) {\n            tree[node] = start;\n        } else {\n            int mid = (start + end) / 2;\n            int leftChild = 2 * node + 1;\n            int rightChild = 2 * node + 2;\n            build(leftChild, start, mid);\n            build(rightChild, mid + 1, end);\n            int leftIndex = tree[leftChild];\n            int rightIndex = tree[rightChild];\n            tree[node] = (arr[leftIndex] < arr[rightIndex]) ? leftIndex : rightIndex;\n        }\n    }\n\n    int query(int node, int start, int end, int L, int R) {\n        if (R < start || L > end) {\n            return -1;\n        }\n        if (L <= start && end <= R) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int leftChild = 2 * node + 1;\n        int rightChild = 2 * node + 2;\n        int leftIndex = query(leftChild, start, mid, L, R);\n        int rightIndex = query(rightChild, mid + 1, end, L, R);\n        if (leftIndex == -1) return rightIndex;\n        if (rightIndex == -1) return leftIndex;\n        return (arr[leftIndex] < arr[rightIndex]) ? leftIndex : rightIndex;\n    }\n\n    void update(int node, int start, int end, int idx, int value) {\n        if (start == end) {\n            arr[idx] = value;\n        } else {\n            int mid = (start + end) / 2;\n            int leftChild = 2 * node + 1;\n            int rightChild = 2 * node + 2;\n            if (start <= idx && idx <= mid) {\n                update(leftChild, start, mid, idx, value);\n            } else {\n                update(rightChild, mid + 1, end, idx, value);\n            }\n            int leftIndex = tree[leftChild];\n            int rightIndex = tree[rightChild];\n            tree[node] = (arr[leftIndex] < arr[rightIndex]) ? leftIndex : rightIndex;\n        }\n    }\n};\n\n\nclass Solution {\npublic:\n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n        long long total_sum = 0;\n        vector<int> diff;\n        for(int i = 0; i < nums.size(); ++i)\n        {\n            diff.push_back(target[i] - nums[i]);\n        }\n        \n        int start = 0;\n        vector<pair<int,int>> queries;\n        for(int i = 1; i < diff.size(); ++i)\n        {\n            if(diff[start] > 0 && diff[i] <= 0)\n            {\n                queries.push_back({start, i-1});\n                start = i;\n            } else if(diff[start] == 0 && (diff[i] > 0 || diff[i] < 0))\n            {\n                queries.push_back({start, i-1});\n                start = i;\n            } else if(diff[start] < 0 && diff[i] >= 0)\n            {\n                queries.push_back({start, i-1});\n                start = i;\n            }\n        }\n        \n        // for(int i = 0; i < diff.size(); ++i)\n        // {\n        //     cout << diff[i] << \" \";\n        // }\n        \n        \n\n        \n        queries.push_back({start, diff.size() - 1});\n        \n        \n        for(auto& el : diff) {\n            el = abs(el);\n        }\n        SegmentTree t(diff);\n\n        for(auto& query : queries)\n        {\n            // cout << query.first << \" \" << query.second << \"\\n\";\n            total_sum += recurse(query.first, query.second, t, 0, diff);\n        }\n        return total_sum;\n    }\nprivate:\n    long long recurse(int start, int end, SegmentTree& t, int offset, vector<int>& diff)\n    {\n        if(start > end) return 0;\n        int min_index = t.rangeMinIndex(start, end);\n        int res = diff[min_index] - offset;\n        if(res == 0)\n        {\n            return recurse(start, min_index - 1, t, offset, diff) + recurse(min_index + 1, end, t, offset, diff);\n        }\n        long long curr = res;\n        return curr + recurse(start, min_index - 1, t, diff[min_index], diff) \n                + recurse(min_index + 1, end, t, diff[min_index], diff);\n    }\n};",
    "submit_ts": "1721532701",
    "subm_id": "1327992001"
}