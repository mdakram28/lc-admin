{
    "username": "hongyili",
    "submission": "from sortedcontainers import SortedList\n\n\nclass SegmentTree:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.data = [None] * self.n + nums\n        for _i in range(1, self.n):\n            i = self.n - _i\n            self.data[i] = self.agg(i)\n    \n    def update(self, i, value):\n        i += self.n\n        self.data[i] = value\n        while i > 1:\n            i >>= 1\n            self.data[i] = self.agg(i)\n    \n    def agg(self, i):\n        left = 2 * i\n        right = 2 * i + 1\n        return max(self.data[left], self.data[right])\n    \n    # interval [l, r) \n    def query_lclose_ropen(self, l, r):\n        l += self.n\n        r += self.n        \n        rst = -float('inf')\n        while l < r:\n            if r & 1:\n                r -= 1\n                \n                rst = max(rst, self.data[r])\n            \n            if l & 1:\n                rst = max(rst, self.data[l])\n                \n                l += 1\n            \n            l >>= 1\n            r >>= 1\n        return rst\n\n\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        myxs = {0}\n        for q in queries:\n            if q[0] == 1:\n                x = q[1]\n                myxs.add(x)\n        myxs = list(myxs)\n        myxs.sort()\n        x_to_i = {x: i for i, x in enumerate(myxs)}\n        bsz = [-float('inf')] * len(myxs)\n        bsz[0] = 0\n        mytree = SegmentTree(bsz)\n        myl = SortedList([0])\n        \n        rst = []\n        for q in queries:\n            if q[0] == 1:\n                x = q[1]\n                loc = myl.bisect_left(x)\n                left = myl[loc-1]\n                assert left < x\n                \n                right = None\n                if loc < len(myl):\n                    right = myl[loc]\n                    assert right > x\n                myl.add(x)\n                #print(x, left, right)\n                \n                i = x_to_i[x]\n                mytree.update(i, x-left)\n                \n                if right is not None:\n                    j = x_to_i[right]\n                    mytree.update(j, right-x)\n                continue\n            \n            _, x, sz = q\n            loc = myl.bisect_left(x)\n            left = myl[loc-1]\n            assert left < x\n            if x-left >= sz:\n                rst.append(True)\n                continue\n            \n            i = x_to_i[left]\n            rst.append(mytree.query_lclose_ropen(0, i+1) >= sz)\n        return rst\n                \n                \n        \n        \n        \n        \n        \n        \n        ",
    "submit_ts": "1716650814",
    "subm_id": "1267625123"
}