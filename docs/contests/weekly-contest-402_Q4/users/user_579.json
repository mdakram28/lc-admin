{
    "username": "ericlege98",
    "submission": "import math\n#Merging function\nmerge = lambda a, b:a+b\n#Seg Tree Functions\ndef _build_util(arr, seg, low, high, pos):\n\tif low == high:\n\t\tseg[pos] = arr[low]\n\t\treturn arr[low]\n\tmid = (low+high)//2\n\tseg[pos] = merge(_build_util(arr, seg, low, mid, pos*2+1), _build_util(arr, seg, mid+1, high, pos*2+2))\n\treturn seg[pos]\n\ndef build(arr):\n    h = math.ceil(math.log(len(arr))/math.log(2))\n    seg = [0]*int(2**(h+1))\n    seg[-1] = len(arr) #stores n at the back of seg\n    _build_util(arr, seg, 0, len(arr)-1, 0)\n    return seg\n\ndef _query_util(seg, ss, se, qs, qe, pos):\n\tif qs <= ss and qe >= se:\n\t\treturn seg[pos]\n\tmid = (ss+se)//2\n\tif mid+1 > qe:\n\t\treturn _query_util(seg, ss, mid, qs, qe, 2*pos+1)\n\tif mid < qs:\t\n\t\treturn _query_util(seg, mid+1, se, qs, qe, 2*pos+2)\n\treturn merge(_query_util(seg, ss, mid, qs, qe, 2*pos+1), _query_util(seg, mid+1, se, qs, qe, 2*pos+2))\n\ndef query(seg, qs, qe):\n\treturn _query_util(seg, 0, seg[-1]-1, qs, qe, 0)\n\ndef _put_util(seg, index, value, low, high, pos):\n\tif index < low or index > high:\n\t\treturn\n\tif low == high:\n\t\tif low == index:\n\t\t\tseg[pos] = value\n\telse:\n\t\tmid = (low+high)//2\n\t\t_put_util(seg, index, value, low, mid, 2*pos+1)\n\t\t_put_util(seg, index, value, mid+1, high, 2*pos+2)\n\t\tseg[pos] = merge(seg[2*pos+1], seg[2*pos+2])\n\ndef put(seg, index, value):\n\t_put_util(seg, index, value, 0, seg[-1]-1, 0)\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        counts = []\n        ret = []\n        for i in range(1, len(nums)-1):\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:\n                counts.append(1)\n            else:\n                counts.append(0)\n        counts = [0]+counts+[0]\n        tree = build(counts)\n        for q in queries:\n            if q[0] == 1:\n                _, l, r = q\n                if r - l <= 1:\n                    ret.append(0)\n                else:\n                    ret.append(query(tree, l, r) - counts[l] - counts[r])\n            else:\n                _, index, val = q\n                nums[index] = val\n                if index > 0 and index < len(nums)-1:\n                    newv = int(val > nums[index-1] and val > nums[index+1])\n                    if newv != counts[index]:\n                        put(tree, index, newv)\n                        counts[index] = newv\n                if index > 1:\n                    val = nums[index-1]\n                    newv = int(val > nums[index-2] and val > nums[index])\n                    if newv != counts[index-1]:\n                        put(tree, index-1, newv)\n                        counts[index-1] = newv\n                if index < len(nums) - 2:\n                    val = nums[index+1]\n                    newv = int(val > nums[index] and val > nums[index+2])\n                    if newv != counts[index+1]:\n                        put(tree, index+1, newv)\n                        counts[index+1] = newv\n        return ret\n        ",
    "submit_ts": "1718507348",
    "subm_id": "1289648745"
}