{
    "username": "Pal_J",
    "submission": "class Solution {\npublic:\n    class SegTree {\n        vector<int> seg;\n\n    public:\n        SegTree(int n) { seg.resize(4 * n + 1, INT_MAX); }\n        void build(int ind, int low, int high, vector<int>& arr) {\n            if (low == high) {\n                seg[ind] = arr[low];\n                return;\n            }\n            int mid = (low + high) / 2;\n            build(2 * ind + 1, low, mid, arr);\n            build(2 * ind + 2, mid + 1, high, arr);\n            seg[ind] = seg[2 * ind + 1] & seg[2 * ind + 2];\n        }\n        int query(int ind, int low, int high, int l, int r) {\n            // no overlap\n            // l r low high || low high l r\n            if (l > high || r < low) {\n                return INT_MAX;\n            }\n            // complete overlap\n            // l low high r\n            if (l <= low && r >= high) {\n                return seg[ind];\n            }\n            // partial overlap\n            int mid = (low + high) / 2;\n            int left = query(2 * ind + 1, low, mid, l, r);\n            int right = query(2 * ind + 2, mid + 1, high, l, r);\n            return left & right;\n        }\n        void update(int ind, int low, int high, int i, int val,\n                    vector<int>& arr) {\n            if (low == high) {\n                seg[ind] = val;\n                arr[i] = val;\n                return;\n            }\n            int mid = (low + high) / 2;\n            if (i <= mid) {\n                update(2 * ind + 1, low, mid, i, val, arr);\n            } else {\n                update(2 * ind + 2, mid + 1, high, i, val, arr);\n            }\n            seg[ind] = seg[2 * ind + 1] & seg[2 * ind + 2];\n        }\n    };\n    long long countSubarrays(vector<int>& nums, int k) {\n        SegTree st(nums.size());\n        st.build(0, 0, nums.size() - 1, nums);\n        int n = nums.size();\n        long long ans = 0;\n        for (int i = 0; i < n; i++) {\n            int lo = i - 1, hi = n - 1;\n            while (hi - lo > 1) {\n                int mid = (lo + hi) / 2;\n                int val = st.query(0, 0, n - 1, i, mid);\n                if (val > k) {\n                    lo = mid;\n                } else {\n                    hi = mid;\n                }\n            }\n            if (st.query(0, 0, n - 1, i, hi) == k) {\n                int lo1 = hi - 1, hi1 = n;\n                while (hi1 - lo1 > 1) {\n                    int mid = (lo1 + hi1) / 2;\n                    int val = st.query(0, 0, n - 1, i, mid);\n                    if (val >= k) {\n                        lo1 = mid;\n                    } else {\n                        hi1 = mid;\n                    }\n                }\n                //cout << hi1 << \" \" << lo1 << \" \" << hi << endl;\n                if (st.query(0, 0, n - 1, i, lo1) == k) {\n                    ans += max(0, min(n - 1, lo1) - max(0,hi) + 1);\n                } else {\n                    ans += 1;\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720280780",
    "subm_id": "1311801821"
}