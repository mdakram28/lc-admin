{
    "username": "colecantcode",
    "submission": "typedef vector<int> vi;\n\nstruct segtree {\n\tint merge(int a, int b) {\n\t\treturn a & b;\n\t}\n \n\tint NEUTRAL = INT_MAX;\n\tint size;\n\tvi seg;\n\tsegtree(int n) {\n\t\tsize = 1;\n\t\twhile (size < n) size *= 2;\n\t\tseg.resize(2 * size, NEUTRAL);\n\t}\n    \n\tvoid build(vector<int>& a, int x, int lx, int rx) {\n\t\tif (rx - lx == 1) {\n\t\t\tif (lx < (int)a.size())\n\t\t\t\tseg[x] = (int)a[lx];\n\t\t\treturn;\n\t\t}\n\t\tint m = (lx + rx) / 2;\n\t\tbuild(a, 2 * x + 1, lx, m);\n\t\tbuild(a, 2 * x + 2, m, rx);\n\t\tseg[x] = merge(seg[2 * x + 1], seg[2 * x + 2]);\n\t}\n\tvoid build(vector<int>& a) {\n\t\tbuild(a, 0, 0, size);\n\t}\n\tvoid update(int i, int v, int x, int lx, int rx) {\n\t\tif (rx - lx == 1) {\n\t\t\tseg[x] = merge(seg[x], v); // change this based on needed functionality\n\t\t\treturn;\n\t\t}\n\t\tint m = (lx + rx) / 2;\n\t\tif (i < m) update(i, v, 2 * x + 1, lx, m);\n\t\telse update(i, v, 2 * x + 2, m, rx);\n\t\tseg[x] = merge(seg[2 * x + 1], seg[2 * x + 2]);\n\t}\n\tvoid update(int i, int v) {\n\t\tupdate(i, v, 0, 0, size);\n\t}\n\tint query(int l, int r, int x, int lx, int rx) {\n\t\tif (lx >= r || rx <= l) return NEUTRAL;\n\t\tif (lx >= l && rx <= r) return seg[x];\n\t\tint m = (lx + rx) / 2;\n\t\treturn merge(query(l, r, 2 * x + 1, lx, m), query(l, r, 2 * x + 2, m, rx));\n\t}\n\tint query(int l, int r) {\n\t\treturn query(l, r + 1, 0, 0, size);\n\t}\n \n\tint first_greater(int v, int l, int x, int lx, int rx) {\n\t\tif (seg[x] <= v || rx <= l) return -1;\n\t\tif (rx - lx == 1) return lx;\n\t\tint m = (lx + rx) / 2;\n\t\tint left = first_greater(v, l, x * 2 + 1, lx, m);\n\t\tif (left != -1) return left;\n\t\treturn first_greater(v, l, x * 2 + 2, m, rx);\n\t}\n\tint first_greater(int v, int l) {\n\t\treturn first_greater(v, l, 0, 0, size);\n\t}\n};\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        int n = size(nums);\n        int ans = INT_MAX;\n        segtree st(n);\n        st.build(nums);\n        for (int i = 0; i < n; i++) {\n            int l = i, r = n - 1;\n            while (l < r) {\n                int m = (l + r + 1) / 2;\n                //cout << i << ' ' << m << \"     \" << st.query(i, m) << endl;\n                if (st.query(i, m) >= k) l = m;\n                else r = m - 1;\n            }\n            ans = min(ans, abs(st.query(i, l) - k));\n            if (l + 1 < n)\n                ans = min(ans, abs(st.query(i, l + 1) - k));\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1717298197.0
}