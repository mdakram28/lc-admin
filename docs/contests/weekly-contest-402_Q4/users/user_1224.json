{
    "username": "spdwork2003",
    "submission": "class SegmentTree\n{\n    vector<int> segtree;\n    public:\n    SegmentTree(int n)\n    {\n        segtree.resize(4*n + 1);\n    }\n\n    void build(int node, int start, int end, vector<int> &arr)\n    {\n        if(start == end)\n        {\n            segtree[node] = arr[start];\n        }\n        else\n        {\n            int mid = (start + end) / 2;\n            build(2*node + 1, start, mid, arr);\n            build(2*node+2, mid+1, end, arr);\n            segtree[node] = segtree[2*node + 1] + segtree[2*node+2];\n        }\n\n    }\n\n    int query(int node, int start, int end, int l, int r)\n    {\n        if(r < start or end < l)\n        {\n            return 0;\n        }\n        if(l <= start and end <= r)\n        {\n            return segtree[node];\n        }\n        int mid = (start + end) / 2;\n        int p1 = query(2*node+1, start, mid, l, r);\n        int p2 = query(2*node+2, mid+1, end, l, r);\n        return (p1 + p2);\n    }\n    \n\n    void update(int node, int start, int end, int ind, int val)\n    {\n        if(start == end)\n        {\n            segtree[node] = val;\n        }\n        else\n        {\n            int mid = (start + end) / 2;\n            if(start <= ind and ind <= mid)\n            {\n                update(2*node+1, start, mid, ind, val);\n            }\n            else\n            {\n                update(2*node+2, mid+1, end, ind, val);\n            }\n            segtree[node] = segtree[2*node + 1] + segtree[2*node+2];\n        }\n    }\n};\n\n\nclass Solution {\npublic:\n    \n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        SegmentTree *tree = new SegmentTree(n);\n        vector<int> arr(n, 0);\n        for(int i = 1;i < n - 1; i++) {\n            if(nums[i] > nums[i-1] && nums[i] > nums[i+1]) {\n                arr[i] = 1;\n            }\n        }\n        \n        tree->build(0,0,n-1, arr);\n        vector<int> res;\n        for(int i = 0; i < queries.size(); i++) {\n            if(queries[i][0] == 2) {\n                int idx = queries[i][1];\n                int val = queries[i][2];\n                nums[idx] = val;\n                for(int j = idx - 1; j <= idx + 1; j++) {\n                    if(j >= 0 && j < n) {\n                        if(j == 0 || j == n-1) {\n                            tree->update(0, 0,n-1, j, 0);\n                        }\n                        else {\n                            if(nums[j] > nums[j+1] && nums[j] > nums[j-1]) {\n                                if(!arr[j]) {\n                                    arr[j] = 1;\n                                    tree->update(0,0,n-1,j,1);\n                                }\n                            }\n                            else {\n                                if(arr[j]) {\n                                    arr[j] = 0;\n                                    tree->update(0,0,n-1,j,0);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                int l = queries[i][1];\n                int r = queries[i][2];\n                int ans = tree->query(0,0,n-1, l, r);\n                if(l != r) \n                    res.push_back(ans - (arr[l] ? 1 : 0) - (arr[r] ? 1 : 0));\n                else\n                    res.push_back(ans - (arr[l] ? 1 : 0));\n            }\n        }\n        return res;\n        \n    }\n};",
    "submit_ts": 1718509236.0
}