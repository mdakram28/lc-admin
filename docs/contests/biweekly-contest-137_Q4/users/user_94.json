{
    "username": "Abhishek",
    "submission": "#define lld long long\n#define rep(i,a,n) for(lld i = (a); i <= (n); ++i)\n#define repI(i,a,n) for(int i = (a); i <= (n); ++i)\n#define repD(i,a,n) for(lld i = (a); i >= (n); --i)\n#define repDI(i,a,n) for(int i = (a); i >= (n); --i)\n#define all(c) (c).begin(), (c).end()\n#define sz(a) ((int)a.size())\n\n#define Error(x...) { cout << \"(\" << #x << \")\" << \" = ( \"; printIt(x); }\ntemplate <typename T1> void printIt(T1 t1) { cout << t1 << \" )\" << endl; }\ntemplate <typename T1, typename... T2>\nvoid printIt(T1 t1, T2... t2) { cout << t1 << \" , \"; printIt(t2...); }\n#define errorpair(a) cout<<#a<<\" = ( \"<<((a).first)<<\" , \"<<((a).second)<<\" )\\n\";\n\ntypedef int fType;\ntypedef lld cType;\ntypedef int L;\n \nconst fType INF = 0x3f3f3f3f;\n \nstruct edge {\n    int u, v;\n    fType flow;\n    cType cost;\n    edge() {}\n    edge(int u, int v, fType f, cType c) : u(u), v(v), flow(f), cost(c) {}\n};\n \nstruct MinCostMaxFlow {\n    int N;\n    vector < vector <int> > G;\n    vector <edge> E;\n    int numEdges;\n    vector <int> found, dad;\n    vector <cType> dist;\n \n    MinCostMaxFlow(int N): \n     N(N), G(N), found(N), dist(N), dad(N), numEdges(0) {}\n  \n    void AddEdge(int from, int to, fType capacity, cType cost) {\n        G[from].push_back(numEdges++);\n        E.push_back(edge(from, to, capacity, cost));\n        G[to].push_back(numEdges++);\n        E.push_back(edge(to, from, 0, cType(-1) * cost));\n    }\n  \n    bool spfa(int s, int t) {\n        fill(dad.begin(), dad.end(), -1);\n        fill(dist.begin(), dist.end(), INF);\n        fill(found.begin(), found.end(), 0);\n        queue <int> Q;\n        dist[s] = 0;\n        Q.push(s);\n        found[s] = true;\n        \n        while(!Q.empty()) {\n            int u = Q.front(); Q.pop();\n            if(u == t) continue;\n            for (int i = 0; i < G[u].size(); ++i) {\n                edge &pres = E[G[u][i]];\n                int v = pres.v;\n                if(pres.flow <= 0) continue;\n                if(dist[u] + pres.cost < dist[v]) {\n                    dad[v] = G[u][i];\n                    dist[v] = dist[u] + pres.cost;\n                    if(!found[v]) Q.push(v), found[v] = true;\n                }\n            }\n            found[u] = false;\n        }\n        return (dad[t] != -1);\n    }\n \n    fType dfs(int s,int t) {\n        fType flow = INF;\n        for(int i = dad[t]; i != -1; i = dad[E[i].u]) {\n            if(E[i].flow < flow) flow = E[i].flow;\n        }\n        for(int i = dad[t]; i != -1; i = dad[E[i].u]) {\n            E[i].flow -= flow;\n            E[i ^ 1].flow += flow;\n        }\n        return flow;\n    }\n \n    pair <fType, cType> GetMaxFlow(int s, int t) {\n        fType totflow = 0;\n        cType totcost = 0;\n        while(spfa(s,t)) {\n            fType amt = dfs(s,t);\n            totflow += amt;\n            totcost += dist[t] * (cType)amt;\n        }\n        return make_pair(totflow, totcost);\n    }\n};\n\n\nclass Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& board) {\n        int n = board.size();\n        int m = board[0].size();\n        int source = 0;\n        int sink = n + m + 1;\n        int source2 = sink + 1;\n        int sink2 = source2 + 1;\n        int total = sink2 + 1;\n        MinCostMaxFlow df(total);\n        df.AddEdge(source, source2, 3, 0);\n        repI(i, 1, n) {\n            df.AddEdge(source2, i, 1, 0);\n        }\n        repI(i, 1, n) {\n            repI(j, 1, m) {\n                df.AddEdge(i, n + j, 1, -board[i - 1][j - 1]);\n            }\n        }\n        repI(j, 1, m) {\n            df.AddEdge(n + j, sink2, 1, 0);\n        }\n        df.AddEdge(sink2, sink, 3, 0);\n        pair <int, lld> ans = df.GetMaxFlow(source, sink);\n        return -ans.second;\n    }\n};",
    "submit_ts": "1723906863",
    "subm_id": "1359076814"
}