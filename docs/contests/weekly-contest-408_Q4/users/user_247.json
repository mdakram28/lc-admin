{
    "username": "sangam2ishra",
    "submission": "class Solution {\n    struct Circle {\n        long long x, y, r;\n    };\n\n    bool bfs(const vector<vector<long long>>& g,\n             const vector<long long>& sources,\n             const unordered_set<long long>& targets) {\n        queue<long long> q;\n        vector<bool> visited(g.size(), false);\n\n        for (long long src : sources) {\n            q.push(src);\n            visited[src] = true;\n        }\n\n        while (!q.empty()) {\n            long long node = q.front();\n            q.pop();\n\n            if (targets.count(node)) {\n                return true;\n            }\n\n            for (long long neighbor : g[node]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    q.push(neighbor);\n                }\n            }\n        }\n\n        return false;\n    }\n\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n        vector<Circle> Circles(n);\n        for (int i = 0; i < n; i++) {\n            Circles[i].x = circles[i][0];\n            Circles[i].y = circles[i][1];\n            Circles[i].r = circles[i][2];\n        }\n\n        vector<vector<long long>> g(n + 4);\n        for (long long i = 0; i < n; i++) {\n            for (long long j = i + 1; j < n; j++) {\n                long long dx = Circles[i].x - Circles[j].x;\n                long long dy = Circles[i].y - Circles[j].y;\n                long long distanceSquared = dx * dx + dy * dy;\n                long long radiusSumSquared = (Circles[i].r + Circles[j].r) * (Circles[i].r + Circles[j].r);\n                if (distanceSquared <= radiusSumSquared) {\n                    g[i].push_back(j);\n                    g[j].push_back(i);\n                }\n            }\n        }\n\n        for (long long i = 0; i < n; i++) {\n            Circle& c = Circles[i];\n            // Left side (x = 0)\n            if (c.x - c.r <= 0) {\n                g[i].push_back(n + 0);\n                g[n + 0].push_back(i);\n            }\n            // Right side (x = X)\n            if (c.x + c.r >= X) {\n                g[i].push_back(n + 1);\n                g[n + 1].push_back(i);\n            }\n            // Bottom side (y = 0)\n            if (c.y - c.r <= 0) {\n                g[i].push_back(n + 2);\n                g[n + 2].push_back(i);\n            }\n            // Top side (y = Y)\n            if (c.y + c.r >= Y) {\n                g[i].push_back(n + 3);\n                g[n + 3].push_back(i);\n            }\n        }\n\n        // Sources and targets for BFS\n        vector<long long> sources = {n + 0, n + 3};        // x = 0, y = Y\n        unordered_set<long long> targets = {n + 2, n + 1}; // y = 0, x = X\n\n        bool pathExists = bfs(g, sources, targets);\n\n        return !pathExists;\n    }\n};\n",
    "submit_ts": "1722136568",
    "subm_id": "1335738465"
}