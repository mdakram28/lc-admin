{
    "username": "Shravan_kumar_04",
    "submission": "import math\nfrom collections import deque\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        bounds=(X,Y)\n        num_circles = len(circles)\n        edges = [[] for _ in range(num_circles + 4)]\n\n        for i, (x, y, r) in enumerate(circles):\n            if x <= r:\n                edges[-4].append(i)\n                edges[i].append(-4)\n            if bounds[0] - x <= r:\n                edges[-2].append(i)\n                edges[i].append(-2)\n            if y <= r:\n                edges[-3].append(i)\n                edges[i].append(-3)\n            if bounds[1] - y <= r:\n                edges[-1].append(i)\n                edges[i].append(-1)\n            for j, (xj, yj, rj) in enumerate(circles[i+1:], i+1):\n                distance = math.hypot(x - xj, y - yj)\n                if r + rj >= distance:\n                    edges[i].append(j)\n                    edges[j].append(i)\n\n        def trav(start, targets):\n            queue = deque([start])\n            visited = [0] * (num_circles + 4)\n            visited[start] = 1\n\n            while queue:\n                node = queue.popleft()\n                for neighbor in edges[node]:\n                    if not visited[neighbor]:\n                        queue.append(neighbor)\n                        visited[neighbor] = 1\n            return any(visited[target] for target in targets)\n\n        return not (trav(-4, [-3, -2]) or trav(-1, [-2, -3]))",
    "submit_ts": "1722138961",
    "subm_id": "1335804200"
}