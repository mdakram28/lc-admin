{
    "username": "Aditya Bharti",
    "submission": "#include <iostream>\nusing namespace std;\n#include <bits/stdc++.h>\n#include <immintrin.h>\n \n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cfenv>\n#include <cfloat>\n#include <chrono>\n#include <cinttypes>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <initializer_list>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <streambuf>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <typeinfo>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing ll=long long;\nusing ld=long double;\nconst ll ILL=2167167167167167167;\nconst int INF=2100000000;\nconst int mod=998244353;\n#define rep(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define all(p) p.begin(),p.end()\ntemplate<class T> using _pq = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> ll LB(vector<T> &v,T a){return lower_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> ll UB(vector<T> &v,T a){return upper_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> bool chmin(T &a,T b){if(a>b){a=b;return 1;}else return 0;}\ntemplate<class T> bool chmax(T &a,T b){if(a<b){a=b;return 1;}else return 0;}\ntemplate<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}\ntemplate<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}\nbool yneos(bool a,bool upp=0){if(a){cout<<(upp?\"YES\\n\":\"Yes\\n\");}else{cout<<(upp?\"NO\\n\":\"No\\n\");}return a;}\ntemplate<class T> void vec_out(vector<T> &p,int ty=0){\nif(ty==2){cout<<'{';for(int i=0;i<(int)p.size();i++){if(i){cout<<\",\";}cout<<'\"'<<p[i]<<'\"';}cout<<\"}\\n\";}\nelse{if(ty==1){cout<<p.size()<<\"\\n\";}for(int i=0;i<(int)(p.size());i++){if(i) cout<<\" \";cout<<p[i];}cout<<\"\\n\";}}\ntemplate<class T> T vec_min(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmin(ans,x);return ans;}\ntemplate<class T> T vec_max(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmax(ans,x);return ans;}\ntemplate<class T> T vec_sum(vector<T> &a){T ans=T(0);for(auto &x:a) ans+=x;return ans;}\nint pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}\ntemplate<class T> bool inside(T l,T x,T r){return l<=x&&x<r;}\n\nusing namespace std;\nclass DisjointSet {\n    vector<int> rank, parent, size;\npublic:\n    DisjointSet(int n) {\n        rank.resize(n + 1, 0);\n        parent.resize(n + 1);\n        size.resize(n + 1);\n        for (int i = 0; i <= n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    int findUPar(int node) {\n        if (node == parent[node])\n            return node;\n        return parent[node] = findUPar(parent[node]);\n    }\n\n    void unionByRank(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (rank[ulp_u] < rank[ulp_v]) {\n            parent[ulp_u] = ulp_v;\n        }\n        else if (rank[ulp_v] < rank[ulp_u]) {\n            parent[ulp_v] = ulp_u;\n        }\n        else {\n            parent[ulp_v] = ulp_u;\n            rank[ulp_u]++;\n        }\n    }\n\n    void unionBySize(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (size[ulp_u] < size[ulp_v]) {\n            parent[ulp_u] = ulp_v;\n            size[ulp_v] += size[ulp_u];\n        }\n        else {\n            parent[ulp_v] = ulp_u;\n            size[ulp_u] += size[ulp_v];\n        }\n    }\n};\n#define rd(x) \\\n    int x;    \\\n    cin >> x;\n#define rs(s) \\\n    string s; \\\n    cin >> s;\n#define INF 1e9 + 10;\n\n#define setbitsll(x) __builtin_popcountll(x)\n#define setbits(x) __builtin_popcount(x)\n#define rt return 0\n\nint lcm(int a, int b)\n{\n    return (a * b) / (__gcd(a, b));\n}\n\nint min(int a, int b)\n{\n    return (a < b) ? a : b;\n}\n\nint max(int a, int b)\n{\n    return (a > b) ? a : b;\n}\n\nint BinExpItr(int a, int b)\n{\n    int ans = 1;\n    while (b)\n    {\n        if (b & 1)\n        {\n            ans = (ans * 1ll * a) % mod;\n        }\n        a = (a * 1ll * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n// int dx[] = { -1 , 1 ,  0  , 0 , -1  , -1  ,  1  , 1  };\n// int dy[] = { 0  , 0 , -1  , 1 , -1  ,  1  , -1  , 1  };\n//            { U  , D ,  L  , R , UL  , UR  , DL  , DR }\nclass Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& chessboard) {\n                int numberOfRowsInChessboard = chessboard.size();\n        int numberOfColumnsInChessboard = chessboard[0].size();\n        \n        vector<vector<pair<int, int>>> topValuesPerRow(numberOfRowsInChessboard);\n        vector<vector<pair<int, int>>> topValuesPerColumn(numberOfColumnsInChessboard);\n        \n        computeTopValuesPerRow(chessboard, topValuesPerRow);\n        computeTopValuesPerColumn(chessboard, topValuesPerColumn);\n        \n        long long maximumSumOfCellValues = LLONG_MIN;\n        \n        maximumSumOfCellValues = computeMaximumSumOfThreeNonAttackingRooks(\n            numberOfRowsInChessboard, numberOfColumnsInChessboard,\n            topValuesPerRow, topValuesPerColumn\n        );\n        \n        return maximumSumOfCellValues;\n    }\n    private:\n    void computeTopValuesPerRow(const vector<vector<int>>& chessboard, vector<vector<pair<int, int>>>& topValuesPerRow) {\n        int numberOfRowsInChessboard = chessboard.size();\n        int numberOfColumnsInChessboard = chessboard[0].size();\n        \n        for (int rowIndex = 0; rowIndex < numberOfRowsInChessboard; ++rowIndex) {\n            vector<pair<int, int>> rowValueColumnPairs;\n            for (int columnIndex = 0; columnIndex < numberOfColumnsInChessboard; ++columnIndex) {\n                rowValueColumnPairs.push_back({chessboard[rowIndex][columnIndex], columnIndex});\n            }\n            sort(rowValueColumnPairs.rbegin(), rowValueColumnPairs.rend());\n            if (rowValueColumnPairs.size() > 3) rowValueColumnPairs.resize(3);\n            topValuesPerRow[rowIndex] = rowValueColumnPairs;\n        }\n    }\n\n    void computeTopValuesPerColumn(const vector<vector<int>>& chessboard, vector<vector<pair<int, int>>>& topValuesPerColumn) {\n        int numberOfRowsInChessboard = chessboard.size();\n        int numberOfColumnsInChessboard = chessboard[0].size();\n        \n        for (int columnIndex = 0; columnIndex < numberOfColumnsInChessboard; ++columnIndex) {\n            vector<pair<int, int>> columnValueRowPairs;\n            for (int rowIndex = 0; rowIndex < numberOfRowsInChessboard; ++rowIndex) {\n                columnValueRowPairs.push_back({chessboard[rowIndex][columnIndex], rowIndex});\n            }\n            sort(columnValueRowPairs.rbegin(), columnValueRowPairs.rend());\n            if (columnValueRowPairs.size() > 3) columnValueRowPairs.resize(3);\n            topValuesPerColumn[columnIndex] = columnValueRowPairs;\n        }\n    }\n\n    long long computeMaximumSumOfThreeNonAttackingRooks(\n        int numberOfRowsInChessboard,\n        int numberOfColumnsInChessboard,\n        const vector<vector<pair<int, int>>>& topValuesPerRow,\n        const vector<vector<pair<int, int>>>& topValuesPerColumn\n    ) {\n        long long maximumSum = LLONG_MIN;\n        \n        for (int firstRowIndex = 0; firstRowIndex < numberOfRowsInChessboard; ++firstRowIndex) {\n            for (const auto& [firstValue, firstColumnIndex] : topValuesPerRow[firstRowIndex]) {\n                for (int secondRowIndex = firstRowIndex + 1; secondRowIndex < numberOfRowsInChessboard; ++secondRowIndex) {\n                    for (const auto& [secondValue, secondColumnIndex] : topValuesPerRow[secondRowIndex]) {\n                        if (firstColumnIndex == secondColumnIndex) continue;\n                        for (int thirdRowIndex = secondRowIndex + 1; thirdRowIndex < numberOfRowsInChessboard; ++thirdRowIndex) {\n                            for (const auto& [thirdValue, thirdColumnIndex] : topValuesPerRow[thirdRowIndex]) {\n                                if (firstColumnIndex == thirdColumnIndex || secondColumnIndex == thirdColumnIndex) continue;\n                                long long currentSum = static_cast<long long>(firstValue) + secondValue + thirdValue;\n                                maximumSum = max(maximumSum, currentSum);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return maximumSum;\n    }\n};",
    "submit_ts": "1723907378",
    "subm_id": "1359104590"
}