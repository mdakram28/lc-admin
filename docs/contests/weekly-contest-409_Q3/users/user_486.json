{
    "username": "josh7611",
    "submission": "class Solution {\n    class SegTreeNode\n{\n    SegTreeNode left;\n    SegTreeNode right;\n    int start, end;\n    long info;  // the sum value over the range\n    boolean lazy_tag = false;  \n    long lazy_val = 0;\n        \n    SegTreeNode(int a, int b, int val)  // init for range [a,b] with val\n    {                 \n        lazy_tag = false;\n        lazy_val = 0;\n        start = a; end = b;\n        if (a==b)\n        {\n            info = val;\n            return;\n        }        \n        int mid = (a+b)/2;\n        if (left==null)\n        {\n            left = new SegTreeNode(a, mid, val);\n            right = new SegTreeNode(mid+1, b, val);            \n            info = left.info + right.info;  // check with your own logic\n        }        \n    }    \n    \n    SegTreeNode(int a, int b, int[] val)  // init for range [a,b] with the same-size array val\n    {                 \n        lazy_tag = false;\n        lazy_val = 0;\n        start = a; end = b;\n        if (a==b)\n        {\n            info = val[a];\n            return;\n        }        \n        int mid = (a+b)/2;\n        if (left==null)\n        {\n            left = new SegTreeNode(a, mid, val);\n            right = new SegTreeNode(mid+1, b, val);            \n            info = left.info + right.info;  // check with your own logic\n        }        \n    }    \n    \n    void pushDown()\n    {\n        if (lazy_tag && left != null)\n        {\n            left.info = lazy_val * (left.end - left.start + 1);\n            right.info = lazy_val * (right.end - right.start + 1);\n            left.lazy_tag = true; left.lazy_val = lazy_val;\n            right.lazy_tag = true; right.lazy_val = lazy_val;\n            lazy_tag = false;  lazy_val = 0;\n        }        \n    } \n    \n    void updateRange(int a, int b, int val)     // set range [a,b] with val\n    {        \n        if (b < start || a > end ) // not covered by [a,b] at all\n            return;        \n        if (a <= start && end <=b)  // completely covered within [a,b]\n        {\n            info = val * (end-start+1);\n            lazy_tag = true;\n            lazy_val = val;\n            return;\n        }\n\n        if (left != null)\n        {\n            pushDown();        \n            left.updateRange(a, b, val);\n            right.updateRange(a, b, val);\n            info = left.info + right.info;  // write your own logic            \n        }        \n    }\n    \n    long queryRange(int a, int b)     // query the sum over range [a,b]\n    {\n        if (b < start || a > end )\n        {\n            return 0;  // check with your own logic\n        }\n        if (a <= start && end <=b)\n        {\n            return info;  // check with your own logic\n        }          \n        \n        if (left != null)\n        {\n            pushDown();     \n            long ret = left.queryRange(a, b) + right.queryRange(a, b);        \n            info = left.info + right.info;    // check with your own logic\n            return ret;\n        }\n        \n        return info;   // should not reach here\n    }  \n};\n\n    public int[] shortestDistanceAfterQueries(int n, int[][] queries) {\n        int[] res = new int[queries.length];\n        SegTreeNode root = new SegTreeNode(0, n - 1, new int[n]);\n        root.updateRange(1, n - 1, 1);\n        for (int i = 0; i < queries.length; ++i) {\n            int start = queries[i][0];\n            int end = queries[i][1];\n            if (start < end) {\n                if (start + 1 <= end - 1) {\n                    // System.out.println(\"update \" + (start + 1) + \" => \" + (end - 1));\n                    root.updateRange(start + 1, end - 1, 0);\n                    \n                }\n            }\n            res[i] = (int)root.queryRange(0, n - 1);\n        }\n        return res;\n    }\n}",
    "submit_ts": "1722741386",
    "subm_id": "1343743742"
}