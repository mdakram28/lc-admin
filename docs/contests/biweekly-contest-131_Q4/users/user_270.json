{
    "username": "sveng101",
    "submission": "from sortedcontainers import SortedDict\n\nclass FenwickTree:\n    \"\"\"\n    Creates a Fenwick tree for a sequence of elements of a commutative\n    monoid. When first initialised, the every element of the sequence\n    is set as the identity of the monoid.\n    Also note that the sequence is zero-indexed\n    \n    Args:\n        Required positional:\n        n (int): the length of the sequence\n        op (2-tuple of a function and an element of the monoid):\n                the associative, commutative binary operation of the\n                commutative monoid and its identity element\n            Example: Addition of integers (lambda x, y: x + y, 0)\n    \n    Attributes:\n        n (int): the length of the sequence\n        arr (list of monoid elements): the Fenwick tree array\n        op (2-tuple of a function and an element of the monoid):\n                the associative, commutative binary operation of the\n                commutative monoid and its identity element\n             Example: Addition of integers (lambda x, y: x + y, 0)\n            \n    \"\"\"\n    def __init__(self, n: int, op: tuple):\n        self.n = n\n        self.arr = [op[1]] * (n + 1)\n        self.op = op\n\n    def query(self, i: int) -> int:\n        \"\"\"\n        Returns the cumulative application of the commutative,\n        associative binary operation of the monoid on all elements\n        of the sequence with index no greater than i. This is\n        referred to as the generalised summation up to the\n        ith index\n        \n        Args:\n            Required positional:\n            i (int): the index at which the generalised summation\n                    stops\n        \"\"\"\n        if i < 0: return self.op[1]\n        elif i >= self.n: i = self.n\n        else: i += 1\n        res = self.op[1]\n        while i > 0:\n            res = self.op[0](res, self.arr[i])\n            i -= i & -i\n        return res\n    \n    def update(self, i: int, v) -> None:\n        \"\"\"\n        Increments the ith element of the sequence (recall the sequence\n        is zero-indexed)- i.e. the ith element will be replaced by\n        the operation self.op performed between the current ith\n        element and v.\n        \n        Args:\n            Required positional:\n            i (int): the index of the sequence to be updated\n            v (element of the monoid): the value to which the ith index\n                    of the sequence is to be incremented.\n        \"\"\"\n        i += 1\n        while i <= self.n:\n            self.arr[i] = self.op[0](self.arr[i], v)\n            i += i & -i\n        return\n\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        \n\n        blocks = SortedDict({0: [1, 0]})\n        for q in queries:\n            if len(q) == 3: continue\n            if q[1] not in blocks.keys():\n                blocks[q[1]] = [1, 0]\n            else:\n                blocks[q[1]][0] += 1\n\n        \n        bit = FenwickTree(len(blocks), (max, -float(\"inf\")))\n        block_inds = {}\n        block_lst = sorted(blocks.keys())\n        prev_arr = [i - 1 for i in range(len(blocks))]\n        nxt_arr = [i + 1 for i in range(len(blocks))]\n        nxt_arr[-1] = float(\"inf\")\n        #curr_mx = 0\n        prev_num = 0\n        for i, num in enumerate(blocks.keys()):\n            block_inds[num] = i\n            gap = num - prev_num\n            #gaps.append(gap)\n            bit.update(i, gap)\n            #curr_mx = max(curr_mx, num - prev_num)\n            blocks[num][1] = i\n            prev_num = num\n        #print(blocks)\n        #print(block_inds)\n        #print(bit.arr)\n\n        res = []\n        for q in reversed(queries):\n            #print(q)\n            if len(q) == 3:\n                idx = blocks.bisect_right(q[1]) - 1\n                #print(q)\n\n                #print(f\"idx = {idx}\")\n                num, (cnt, j) = blocks.peekitem(idx)\n                #print(q[1] - num, j, bit.query(block_lst[idx]))\n                #print(block_lst)\n                #print(bit.arr)\n                res.append(max(q[1] - num, bit.query(j)) >= q[2])\n                continue\n            cnt, idx = blocks[q[1]]\n            if cnt > 1:\n                blocks[q[1]][0] -= 1\n                continue\n            #idx = blocks[q[1]][1]\n            #print(f\"removing block at {q[1]}\")\n            idx = blocks.pop(q[1])[1]\n            idx2 = nxt_arr[idx]\n            if not isinstance(idx2, int):\n                continue\n            idx0 = prev_arr[idx]\n            prev_arr[idx2] = idx0\n            nxt_arr[idx0] = idx2\n            bit.update(idx2, block_lst[idx2] - block_lst[idx0])\n            #print(bit.arr)\n            \n            #idx = blocks.bisect_left(q[1])\n            #if idx == len(blocks) - 1:\n            #    blocks.pop(q[1])\n            #    continue\n            #k0, v0 = blocks.peekitem(idx - 1)\n            #k, v = blocks.peekitem(idx + 1)\n            #blocks[k2]\n            \n            \n                \n        return res[::-1]",
    "submit_ts": 1716651727.0
}