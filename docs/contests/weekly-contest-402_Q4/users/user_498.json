{
    "username": "saikat93ify",
    "submission": "class Solution {\npublic:\n    \n    #define LEFT(n) (2*n)\n    #define RIGHT(n) (2*n + 1)\n    \n    void update(vector <int> &sum_tree, int n, int left, int right, int index, int value)\n    {\n        if(index < left || right < index)\n        {\n            return;\n        }\n        \n        if(left == right)\n        {\n            sum_tree[n] = value;\n            return;\n        }\n        \n        int mid = (left + right)/2;\n        update(sum_tree, LEFT(n), left, mid, index, value);\n        update(sum_tree, RIGHT(n), mid + 1, right, index, value);\n        \n        sum_tree[n] = sum_tree[LEFT(n)] + sum_tree[RIGHT(n)];\n    }\n    \n    int get_sum(vector <int> &sum_tree, int n, int left, int right, int query_left, int query_right)\n    {\n        if(query_right < left || right < query_left || query_right < query_left)\n        {\n            return 0;\n        }\n        \n        if(query_left <= left && right <= query_right)\n        {\n            return sum_tree[n];\n        }\n        \n        int mid = (left + right)/2;\n        int left_sum = get_sum(sum_tree, LEFT(n), left, mid, query_left, query_right);\n        int right_sum = get_sum(sum_tree, RIGHT(n), mid + 1, right, query_left, query_right);\n        \n        return (left_sum + right_sum);\n    }\n    \n    void update_peak(int index, vector <int> &is_peak, vector <int> &nums, vector <int> &sum_tree)\n    {\n        if(index <= 0 || nums.size() - 1 <= index)\n        {\n            return;\n        }\n        \n        //cout << \"Checking index = \" << index << \" Val = \" << nums[index] << \" Previous = \" << nums[index - 1] << \" Next = \" << nums[index + 1] << \"\\n\";\n        if(nums[index - 1] < nums[index] && nums[index] > nums[index + 1])\n        {//cout << \"Peak !\\n\";\n            is_peak[index] = true; \n            update(sum_tree, 1, 0, nums.size() - 1, index, 1);\n        }\n        else \n        {\n            is_peak[index] = false;\n            update(sum_tree, 1, 0, nums.size() - 1, index, 0);\n        }\n    }\n    \n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) \n    {\n        vector <int> sum_tree(4*nums.size());\n        vector <int> is_peak(nums.size(), false);\n        for(int i = 1; i + 1 < nums.size(); i++)\n        {\n            update_peak(i, is_peak, nums, sum_tree);\n        }\n        \n        vector <int> answer;\n        const int COUNT = 1, UPDATE = 2;\n        for(int i = 0; i < queries.size(); i++)\n        {\n            int query_type = queries[i][0];\n            switch(query_type)\n            {\n                case COUNT : \n                {\n                    int left = queries[i][1] + 1, right = queries[i][2] - 1;\n                    int no_of_peaks = get_sum(sum_tree, 1, 0, nums.size() - 1, left, right);\n                    answer.push_back(no_of_peaks);\n                    break;\n                }\n                    \n                case UPDATE : \n                {\n                    int index = queries[i][1], value = queries[i][2];\n                    nums[index] = value; \n                    \n                    update_peak(index - 1, is_peak, nums, sum_tree);\n                    update_peak(index, is_peak, nums, sum_tree);\n                    update_peak(index + 1, is_peak, nums, sum_tree);\n                }\n            }\n        }\n        \n        return answer;\n    }\n};",
    "submit_ts": 1718506430.0
}