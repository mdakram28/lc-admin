{
    "username": "dengyun",
    "submission": "#ifndef ONLINE_JUDGE\n#define ONLINE_JUDGE\n#endif\n#ifdef ONLINE_JUDGE\n#define NO_STD_INCLUDES\n#endif\n#ifndef NO_STD_INCLUDES\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <stack>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <memory>\n#include <math.h>\n#include <assert.h>\n#include <string.h>\n#include <array>\n#include <queue>\n#include <iomanip>\n#include <complex>\n#include <stdint.h>\n#include <type_traits>\n#include <numeric>\nusing namespace std;\n#endif\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define REP(i,f,t) for (int i = (f); i < (t); i++)\ninline void YesNo(bool flag) {\n    if (flag) cout << \"Yes\" << endl;\n    else  cout << \"No\" << endl;\n}\ntemplate <typename T1, typename T2>\nistream& operator >>(istream& in, pair<T1, T2>& vec) {\n    return in >> vec.first >> vec.second;\n}\ntemplate <typename T>\nistream& operator >>(istream& in, vector<T>& vec) {\n    for (auto& v : vec) {\n        in >> v;\n    }\n    return in;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& vec) {\n    bool flag = false;\n    for (auto& v : vec) {\n        if (flag) {\n            out << ' ';\n        }\n        else {\n            flag = true;\n        }\n        out << v;\n    }\n    return out;\n}\ntemplate <typename T1, typename T2>\nostream& operator <<(ostream& out, const pair<T1, T2>& vec) {\n    return out << vec.first << ' ' << vec.second;\n}\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#ifndef ONLINE_JUDGE\nvoid io_redirect() {\n    freopen(\"in.txt\", \"rt\", stdin);\n}\n#else\nvoid io_redirect() {}\n#endif\ntemplate<typename T, typename F>\nT bsmax(T min, T max, F test) {\n    min--;\n    while (min < max) {\n        auto mid = (max + min + 1) / 2;\n        if (test(mid)) {\n            min = mid;\n        }\n        else {\n            max = mid - 1;\n        }\n    }\n    return min;\n}\ntemplate<typename T, typename F>\nT bsmin(T min, T max, F test) {\n    min--;\n    while (min < max) {\n        auto mid = (max + min + 1) / 2;\n        if (!test(mid)) {\n            min = mid;\n        }\n        else {\n            max = mid - 1;\n        }\n    }\n    return min + 1;\n}\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\nint ceil_pow2(long long n) {\n    int x = 0;\n    while ((1ULL << x) < (unsigned long long)(n)) x++;\n    return x;\n}\nconstexpr int lower_bit_constexpr(unsigned int n) {\n    int x = 0;\n    while (!(n & (1 << x))) x++;\n    return x;\n}\nint lower_bit(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\ntemplate <class S, S(*op)(S, S), S(*e)()> struct segtree {\npublic:\n    explicit segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    explicit segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) const {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n    S prod(int l, int r) const {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() const { return d[1]; }\n    template <bool (*f)(S)> int max_right(int l) const {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) const {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*f)(S)> int min_left(int r) const {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) const {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\nprivate:\n    int _n, size, log;\n    std::vector<S> d;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\nint op(int a, int b) {\n    return a & b;\n}\nint e() {\n    return ~0;\n}\ntypedef segtree<int, op, e> st;\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        int n = nums.size();\n        st s(nums);\n        long long ret = 0;\n        for (int i = 0; i < n; i++) {\n            int l = bsmin(i + 1, n, [&](int v) {\n                return s.prod(i, v) <= k;\n                });\n            int r = bsmin(i + 1, n, [&](int v) {\n                return s.prod(i, v) < k;\n                });\n            ret += r - l;\n        }\n        return ret;\n    }\n};\n#ifndef ONLINE_JUDGE\nint main() {\n    vector<int> nums = { 1, 1, 1 };\n    cout <<Solution().countSubarrays(nums, 1)<<endl;\n    return 0;\n}\n#endif\n",
    "submit_ts": "1720276831",
    "subm_id": "544552644"
}