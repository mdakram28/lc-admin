{
    "username": "plyusnovdmitrii",
    "submission": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <unordered_set>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <fstream>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bitset>\n#include <sstream>\n#include <ext/rope>\n#include <ctime>\n#include <random>\n#include <cstdlib>\n#include <complex>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\n/* clang-format off */\n\n/* TYPES  */\n#define ll long long\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vi vector<int>\n#define vll vector<long long>\n#define vpii vector<pair<int, int>>\n#define vpii vector<pair<int, int>>\n#define vvpii vector<vector<pair<int, int>>>\n#define vpll vector<pair<long long, long long>>\n#define vvpll vector<vector<pair<long long, long long>>>\n#define vvi vector<vector<int>>\n#define vvll vector<vector<long long>>\n#define mii map<int, int>\n#define si set<int>\n#define sc set<char>\n\n\n\n/* FUNCTIONS */\n#define feach(el, v) for(auto &el: v)\n#define rep(i, n) for(int i=0;i<n;i++)\n#define reprv(i, n) for(int i=n-1;i>=0;i--)\n#define reps(i, s, e) for(int i=s;i<e;i++)\n#define reprve(i, e, s) for(int i=e;i>=s;i--)\n#define repe(x, y) for (auto &x: y)\n#define repe2(x, a, y) for (auto &[x,a]: y)\n\ntypedef tree<int, null_type, less<>, rb_tree_tag, tree_order_statistics_node_update> oSet;\n\nstd::random_device dev;\nstd::mt19937 rng(dev());\nstd::uniform_int_distribution<std::mt19937::result_type> dist(1, INT_MAX - 1);\n\n\nstruct treap {\n    struct item {\n        int prior, value, cnt, sum, max;\n        item *l, *r;\n    };\n\n    item *root{nullptr};\n\n    auto getRng() -> int { return (rand() << 16) ^ rand(); }\n\n    auto cnt(item *it) -> int {\n        return it ? it->cnt : 0;\n    }\n\n    int sumV(item *it) {\n        return it ? it->sum : 0;\n    }\n    int maxV(item *it) { return it ? it -> max : 0; }\n\n    auto updAll(item *it) -> void {\n        if (it) {\n            it->cnt = cnt(it->l) + cnt(it->r) + 1;\n            it-> max = max(maxV(it->l), maxV(it->r));\n            it->max=max(it->max, it->value);\n            it-> sum = sumV(it->l) + sumV(it->r) + it->value;\n        }\n    }\n\n    auto merge(item *&t, item *l, item *r) -> void {\n        if (!l) t = r;\n        else if (!r) t = l;\n        else if (l->prior > r->prior) merge(l->r, l->r, r), t = l;\n        else merge(r->l, l, r->l), t = r;\n\n        updAll(t);\n    }\n\n    auto split(item *t, item *&l, item *&r, int key, int add = 0) -> void {\n        if (!t) return void(l = r = nullptr);\n\n        int cur_key = add + cnt(t->l);\n\n        if (key <= cur_key) split(t->l, l, t->l, key, add), r = t;\n        else split(t->r, t->r, r, key, add + 1 + cnt(t->l)), l = t;\n\n        updAll(t);\n    }\n\n    auto getValue(item *t, int pos) -> int {\n        int lCnt = cnt(t->l);\n\n        if (pos < lCnt) return getValue(t->l, pos);\n        else if (pos == lCnt) return t->value;\n        else return getValue(t->r, pos - lCnt - 1);\n    }\n\n    auto newItem(int val) -> item * { return new item{getRng(), val, 1, val, val}; }\n\n    void replace(int pos, int l, int r) {\n        item *t1, *t2, *t3, *t4;\n        split(root, t1, t2, pos);\n        split(t2, t3, t4, 1);\n        item *lI = newItem(l), *rI = newItem(r);\n        merge(root, t1, lI);\n        merge(root, root, rI);\n        merge(root, root, t4);\n    }\n\n    auto operator += (int val) -> void { merge(root, root, newItem(val)); }\n\n    auto operator -= (int pos) -> void {\n        item *t1, *t2, *t3, *t4;\n\n        split(root, t1, t2, pos);\n        split(t2, t3, t4, 1);\n        merge(root, t1, t4);\n    }\n\n    auto operator[](int pos) -> int { return getValue(root, pos); }\n\n    int findMaxRange(int rpos) {\n        item *t1, *t2;\n        split(root, t1, t2, rpos + 1);\n        int ans = maxV(t1);\n        merge(root, t1, t2);\n        return ans;\n    }\n\n    int findSumRange(int rpos) {\n        item *t1, *t2;\n        split(root, t1, t2, rpos + 1);\n        int ans = sumV(t1);\n        merge(root, t1, t2);\n        return ans;\n    }\n\n    int binSearchPos(item* x, int sum, int skip = 0) {\n        int lSum = sumV(x->l), lCnt = cnt(x->l);\n        if (lSum <= sum && lSum + x->value > sum) {\n            return skip + lCnt;\n        }\n        if (lSum > sum) return binSearchPos(x->l, sum, skip);\n        else {\n            return binSearchPos(x->r, sum - lSum - x->value, skip + lCnt + 1);\n        }\n    }\n\n    int query(int right) {\n        int bs = binSearchPos(root, right);\n        int left = bs - 1;\n        int maxLeft = (left >= 0 ? findMaxRange(left) : 0);\n        int leftVal = (left >= 0 ? findSumRange(left) : 0);\n        return max(maxLeft, right - leftVal);\n    }\n\n    void insert(int pos) {\n        int bs = binSearchPos(root, pos);\n        int left = bs - 1;\n        int sumLeft = (left >= 0 ? findSumRange(left) : 0);\n        int sumRight = sumLeft + getValue(root, bs);\n        int newL = pos - sumLeft, newR = sumRight - pos;\n        replace(bs, newL, newR);\n    }\n};\n\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        srand((unsigned)time(0));\n        treap t;\n        t += 1e9;\n\n        vector<bool> ans;\n        int n = queries.size();\n        rep(i, n) {\n            int type = queries[i][0];\n            if (type == 1) {\n                t.insert(queries[i][1]);\n            } else {\n                int r = queries[i][1], len = queries[i][2];\n                int currAns = t.query(r);\n                bool check = currAns >= len;\n                ans.push_back(check);\n            }\n        }\n        return ans;\n    }\n};\n",
    "submit_ts": "1716651303",
    "subm_id": "1267637127"
}