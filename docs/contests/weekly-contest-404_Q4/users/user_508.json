{
    "username": "shreyas_28_swain",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1, m = edges2.size() + 1;\n \n        vector<vector<int>> adj1(n), adj2(m);\n \n        for (const auto & x : edges1) {\n            adj1[x[0]].push_back(x[1]);\n            adj1[x[1]].push_back(x[0]);\n        }\n        for (const auto & x : edges2) {\n            adj2[x[0]].push_back(x[1]);\n            adj2[x[1]].push_back(x[0]);\n        }\n\n        auto dfs = [](const vector<vector<int>>& adj, int begin, int& farNode) {\n            int n = adj.size();\n            vector<int> dist(n, -1);\n\n            function<void(int, int)> dfsVisit = [&](int node, int d) {\n                dist[node] = d;\n                if (d > dist[farNode]) {\n                    farNode = node;\n                }\n                for (int neighbor : adj[node]) {\n                    if (dist[neighbor] == -1) {\n                        dfsVisit(neighbor, d + 1);\n                    }\n                }\n            };\n\n            farNode  = begin;\n            dfsVisit(begin, 0);\n            return dist[farNode];\n        };\n\n        int farNode1 = 0;\n        dfs(adj1, 0, farNode1);\n        int d1 = dfs(adj1, farNode1, farNode1), farNode2 = 0;\n        dfs(adj2, 0, farNode2);\n        int d2 = dfs(adj2, farNode2, farNode2);\n            \n        int minDia = max(d1, d2), half1 = (d1 + 1) / 2, half2 = (d2 + 1) / 2;\n        minDia = max(minDia, half1 + half2 + 1);\n            \n        return minDia;\n    }\n};",
    "submit_ts": 1719716485.0
}