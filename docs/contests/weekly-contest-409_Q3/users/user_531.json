{
    "username": "Niloy_Das_19",
    "submission": "class Solution {\npublic:\n    vector<int> g[100005];\n    int dp[100005];\n    void bfs(int u, int v){\n        if(dp[u] + 1 < dp[v]){\n            dp[v] = dp[u] + 1;\n        }\n        else return;\n        queue<int> q;\n        q.push(v);\n        while(!q.empty()){\n            int node = q.front();\n            q.pop();\n            for(auto &it : g[node]){\n                if(dp[node] + 1 < dp[it]){\n                    dp[it] = dp[node] + 1;\n                    q.push(it);\n                }\n            }\n        }\n        return;\n    }\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        set<int> s;\n        for(int i = 0; i < n; i++) s.insert(i);\n        int ans = n - 1;\n        vector<int> re;\n        for(auto &querie : queries){\n            int u = querie[0];\n            int v = querie[1];\n            if(u < v){\n                auto start = s.upper_bound(u);\n                auto end = s.lower_bound(v);\n                vector<int> rem;\n                while(start != end && start != s.end()){\n                    ans--;\n                    rem.push_back(*start);\n                    start++;\n                }\n                for(auto &num : rem){\n                    auto it = s.find(num);\n                    s.erase(it);\n                }\n                re.push_back(ans);\n            }\n            else re.push_back(ans);\n        }\n        return re;\n    }\n};",
    "submit_ts": "1722741881",
    "subm_id": "1343755721"
}