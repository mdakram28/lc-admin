{
    "username": "prabhxs",
    "submission": "class Solution {\nprivate:\n\n    // logic From :https://www.geeksforgeeks.org/check-two-given-circles-touch-intersect/\n    bool touching(int x1, int y1, int x2, int y2, int r1, int r2)\n    {\n        long long dx = x1 - x2;\n        long long dy = y1 - y2;\n        long long distanceSquared = (dx *1ll * dx) + (dy * 1ll * dy);\n\n        long long radiusSum = r1 + r2;\n        long long radiusDiff = abs(r1 - r2);\n        long long radiusSumSquared = radiusSum * 1ll * radiusSum;\n        long long radiusDiffSquared = radiusDiff * 1ll * radiusDiff;\n\n        if (distanceSquared > radiusSumSquared || distanceSquared < radiusDiffSquared) {\n            return false;\n        }\n        return true;\n    }\n\n    class DSU{\n    public:\n        vector<int> par;\n        DSU(int n){\n            par.resize(n + 1);\n            for(int i = 0; i <= n; i++) par[i] = i;\n        }\n        int findPar(int n){\n            if( n == par[n] ) return n;\n            return par[n] = findPar(par[n]);\n        }\n        void merge(int a, int b){\n            a = findPar(a); b = findPar(b);\n            if( a != b ) par[b] = a;\n        }\n    };\n\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        map<int, pair<pair<int, int>, pair<int, int>>> connectedComponents; // par, {minX, maxX}, {minY, maxY}\n        int n = circles.size();\n        DSU st(n + 1);\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                if( touching(circles[i][0], circles[i][1], circles[j][0], circles[j][1], circles[i][2], circles[j][2]) )\n                    st.merge(i, j);\n            }\n        }\n        for(int i = 0; i < n; i++){\n            int parent = st.findPar(i);\n            pair<pair<int, int>, pair<int, int>> curr;\n            int x = circles[i][0], y = circles[i][1], r = circles[i][2];\n            if( connectedComponents.count(parent) ){\n                curr = connectedComponents[parent];\n\n                curr.first.first = min(curr.first.first, x - r);\n                curr.first.second = max(curr.first.second, x + r);\n\n                curr.second.first = min(curr.second.first, y - r);\n                curr.second.second = max(curr.second.second, y + r);\n            }else{\n                curr = {{x - r, x + r}, {y - r, y + r}};\n            }\n            connectedComponents[parent] = curr;\n        }\n        for(auto &a : connectedComponents){\n            pair<int, int> xCase = a.second.first;\n            pair<int, int> yCase = a.second.second;\n\n            if( xCase.first <= 0 && xCase.second >= X ) return 0;\n            if( yCase.first <= 0 && yCase.second >= Y ) return 0;\n            if( xCase.second >= X && yCase.second >= Y ) return 0;\n            if( xCase.first <= 0 && yCase.first <= 0 ) return 0;\n\n        }\n        return 1;\n    }\n};",
    "submit_ts": "1722138695",
    "subm_id": "1335797314"
}