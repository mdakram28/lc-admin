{
    "username": "EchoJoy",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int selfD1, selfD2;\n        int d1 = findRoot(edges1, selfD1);\n        int d2 = findRoot(edges2, selfD2);\n        // cout << d1 << \" \" << d2 << \" \" << selfD1 << \" \" << selfD2 << endl;\n        return max(d1 + d2 + 1, max(selfD1, selfD2));\n    }\n\n    int findRoot(vector<vector<int>>& edges, int& self) {\n        if (edges.empty()) {\n            self = 0;\n            return 0;\n        }\n        self = 0;\n        int size = edges.size() + 1;\n        vector<vector<int>> tree(size, vector<int>());\n        unordered_map<int, int> m;\n        for (auto edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            tree[u].push_back(v);\n            tree[v].push_back(u);\n            m[u]++;\n            m[v]++;\n        }\n        unordered_set<int> visited;\n        queue<int> q;\n        for (int i = 0; i < size; i++) {\n            if (m[i] == 1) {\n                visited.insert(i);\n                m[i]--;\n                q.push(i);\n            }\n        }\n        int d = 1;\n        while (!q.empty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int u = q.front();\n                q.pop();\n                for (int num : tree[u]) {\n                    m[num]--;\n                    if (!visited.contains(num) && m[num] == 1) {\n                        visited.insert(num);\n                        m[num]--;\n                        q.push(num);\n                    }\n                }\n            }\n            if (q.size() > 1) {\n                d++;\n                self += 2;\n            } else {\n                self += 1;\n            }\n        }\n        return d;\n    }\n};",
    "submit_ts": "1719718803",
    "subm_id": "1304426482"
}