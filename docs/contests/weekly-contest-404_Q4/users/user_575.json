{
    "username": "av_03",
    "submission": "class Solution {\npublic:\n    \n    \n    map<int,int>mp;\n    set<int>s;\n    \n    vector<int> getValue (int n) {\n        vector<int>v;\n        for(int i=0; i<=n; i++) {\n            s.insert(i);\n            v.push_back(i);\n        }\n        return v;\n    }\n    \n    vector<int> bfs(const vector<vector<int>>& graph, int start) {\n        if(graph.empty()) return {0,1};\n        int n = graph.size();\n        vector<int> dist(n, -1);\n        queue<int> q;\n        q.push(start);\n        dist[start] = 0;\n\n        int far = start;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            for (auto j: graph[node]) {\n                if (dist[j] == -1) {\n                    dist[j] = dist[node] + 1;\n                    q.push(j);\n                    if (dist[j] > dist[far]) {\n                        far = j;\n                    }\n                }\n            }\n        }\n        return {far, dist[far]};\n    }\n\n    vector<int> find (const vector<vector<int>>& graph) {\n        int n = graph.size();\n        vector<int> deg(n, 0);\n        queue<int>q;\n\n        for (int i = 0; i < n; ++i) {\n            deg[i] = graph[i].size();\n            if (deg[i] == 1) {\n                q.push(i);\n            }\n        }\n\n        int rem = n;\n        while (rem > 2) {\n            int count = q.size();\n            rem -= count;\n            for (int i = 0; i < count; ++i) {\n                int leaf = q.front();\n                q.pop();\n                for (auto j: graph[leaf]) {\n                    deg[j]--;\n                    if (deg[j] == 1) {\n                        q.push(j);\n                    }\n                }\n            }\n        }\n\n        vector<int> centers;\n        while (!q.empty()) {\n            centers.push_back(q.front());\n            q.pop();\n        }\n\n        return centers;\n    }\n    \n    int Calc(vector<vector<int>>& graph) {\n        vector<int>far = bfs(graph, 0);\n        vector<int>far2 = bfs(graph, far[0]);\n        return far2[1];\n    }\n\n    int minDiameterAfterConnectingTrees(vector<vector<int>>& tree1, vector<vector<int>>& tree2) {\n        int d1 = Calc(tree1);\n        int d2 = Calc(tree2);\n        \n\n        // cout<<d1<<\" \"<<d2<<endl;\n        \n        vector<int> c1 = find(tree1);\n        vector<int> c2 = find(tree2);\n        \n        // cout<<c1.size()<<\" \"<<c2.size()<<endl;\n        \n        if (tree1.size() == 1) return d2;\n        if (tree2.size() == 1) return d1;\n        \n//         if(tree1.size() == 2) {\n//             c1.push_back(0);\n//             c1.push_back(1);\n//         }\n        \n//         if(tree2.size() == 2) {\n//             c2.push_back(0);\n//             c2.push_back(1);\n//         }\n        \n//         cout<<c1.size()<<\" \"<<c2.size()<<endl;\n        \n        \n        int n = tree1.size();\n        int m = tree2.size();\n        \n        vector<int>val1 = getValue(n);\n        vector<int>val2 = getValue(m);\n        \n        int mini = INT_MAX;\n        for (auto i: c1) {\n            for (auto j: c2) {\n                int temp = max({d1, d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1});\n                mini = min(mini, temp);\n            }\n        }\n\n        return mini;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size();\n        int m = edges2.size();\n        if(n==0 && m==0) return 1;\n        if(n==1 && m==0) return 2;\n        if(m==1 && n==0) return 2;\n        if(n==1 && m==1) return 3;\n        vector<vector<int>> tree1(n+1);\n        vector<vector<int>> tree2(m+1);\n        \n        for (auto edge : edges1) {\n            int u = edge[0];\n            int v = edge[1];\n            tree1[u].push_back(v);\n            tree1[v].push_back(u);\n        }\n\n        for (auto edge : edges2) {\n            int u = edge[0];\n            int v = edge[1];\n            tree2[u].push_back(v);\n            tree2[v].push_back(u);\n        }\n        \n        int ans =  minDiameterAfterConnectingTrees(tree1, tree2);\n        // cout<<endl;\n        return ans;\n    }\n};",
    "submit_ts": 1719718565.0
}