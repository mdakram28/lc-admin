{
    "username": "trigerrr",
    "submission": "class Solution {\npublic:\n    using ll = long long;\n    using ull = unsigned long long;\n    using lld = long double;\n    using pii = pair<int, int>;\n    using pll = pair<ll, ll>;\n    using vi = vector<int>;\n    using vl = vector<ll>;\n    using vii = vector<pii>;\n    using vll = vector<pll>;\n    using vvi = vector<vi>;\n    using vs = vector<string>;\n    using vb = vector<bool>;\n    using mii = map<int,int>;\n    using mll = map<ll,ll>;\n    using si = set<int>;\n    using sl = set<ll>;\n    #define f(i,x,n) for(ll i = x; i < n; i++)\n    #define rf(i,x,n) for(int i = x; i >= n; i--)\n    #define sz(a) int((a).size())\n    #define re return\n    #define pb push_back\n    #define mp make_pair\n    #define all(a) a.begin(), a.end()\n    #define rall(a) a.rbegin(), a.rend()\n    #define fi first\n    #define se second\n    #define CeilDiv(a,b) ((a+b-1)/b)\n    #define p_q priority_queue\n    #define pqmax priority_queue<ll>\n    #define pqmin priority_queue<ll,vector<ll>,greater<ll>>\n    #define tr(c, i) for (typeof (c).begin() i = c.begin(); i != c.end(); i++)\n    #define present(c, x) (c.find(x) != c.end())\n    #define cpresent(c, x) (find(all(c), x) != c.end())\n    const ll mod = 1e9+7;\n    #define MSB(mask) 63-__builtin_clzll(mask)  /// 0 -> -1\n    #define LSB(mask) __builtin_ctzll(mask)  /// 0 -> 64\n    #define SETBIT(mask) __builtin_popcountll(mask)\n    #define CHECKBIT(mask,bit) (mask&(1LL<<bit))\n    #define ONBIT(mask,bit) (mask|(1LL<<bit))\n    #define OFFBIT(mask,bit) (mask&~(1LL<<bit))\n    #define CHANGEBIT(mask,bit) (mask^(1LL<<bit))\n    vi getDis(int n, vvi &g, int s){\n        vi dis(n);\n        vi vis(n);\n        function<void(int, int)> dfs = [&](int u, int d){\n            vis[u] = 1;\n            dis[u] = d;\n            for(auto v : g[u]){\n                if(!vis[v])\n                    dfs(v,d+1);\n            }\n        };\n        dfs(s,0);\n        return dis;\n    }\n    int diameter(vvi &e){\n        int n = sz(e) + 1;\n        vvi g(n);\n        for(auto x : e){\n            g[x[0]].pb(x[1]);\n            g[x[1]].pb(x[0]);\n        }\n        vi dis1 = getDis(n,g,0);\n        int x = max_element(all(dis1)) - dis1.begin();\n        vi dis2 = getDis(n,g,x);\n        return *max_element(all(dis2));\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int d1 = diameter(edges1);\n        int d2 = diameter(edges2);\n        return max({d1,d2,1 + (d1+1)/2 + (d2+1)/2});\n    }\n};",
    "submit_ts": "1719717271",
    "subm_id": "1304387121"
}