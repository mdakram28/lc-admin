{
    "username": "webmonster",
    "submission": "class Solution {\npublic:\n\tstruct TNode {\n\t\tint needpush, push, mx;\n\t};\n\tvector<TNode> tree;\n\tvoid push(int u, int tl, int tr) {\n\t\tif (tl != tr && tree[u].needpush) {\n\t\t\tint& p = tree[u].push;\n\t\t\n\t\t\tfor (int v : {2 * u, 2 * u + 1}) {\n\t\t\t\ttree[v].mx = max(tree[v].mx, p);\n\t\t\t\tif (tree[v].needpush) tree[v].push = max(tree[v].push, p);\n\t\t\t\telse tree[v].needpush = 1, tree[v].push = p;\n\t\t\t}\n\t\t\n\t\t\tp = tree[u].needpush = 0;\n\t\t}\n\t}\n\n\tconst int inf = 2'000'000'000;\n\tvoid make_tree(int v, int tl, int tr) {\n\t\ttree[v].mx = -inf;\n\t\ttree[v].push = tree[v].needpush = 0;\n\n\t\tif (tl == tr) {\n\t\t\treturn;\n\t\t}\n\n\t\tint tm = (tl + tr) / 2;\n\t\tmake_tree(2 * v, tl, tm);\n\t\tmake_tree(2 * v + 1, tm + 1, tr);\n\t}\n\n\tint upd_val;\n\tvoid update(int v, int tl, int tr, int l, int r) {\n\t\tpush(v, tl, tr);\n\t\tif (l > r) return;\n\t\tif (tl == l && tr == r) {\n\t\t\ttree[v].mx = max(tree[v].mx, upd_val);\n\t\t\ttree[v].push = upd_val;\n\t\t\ttree[v].needpush = 1;\n\t\t\treturn;\n\t\t}\n\n\t\tint tm = (tl + tr) / 2;\n\t\tupdate(2 * v, tl, tm, l, min(r, tm));\n\t\tupdate(2 * v + 1, tm + 1, tr, max(l, tm + 1), r);\n\t\ttree[v].mx = max(tree[2 * v].mx, tree[2 * v + 1].mx);\n\t}\n\n\tlong long ret_val;\n\tvoid get(int v, int tl, int tr, int l, int r) {\n\t\tpush(v, tl, tr);\n\t\tif (l > r) return;\n\t\tif (tl == l && tr == r) {\n\t\t\tret_val = max(ret_val, (long long) tree[v].mx);\n\t\t\treturn;\n\t\t}\n\n\t\tint tm = (tl + tr) / 2;\n\t\tget(2 * v, tl, tm, l, min(r, tm));\n\t\tget(2 * v + 1, tm + 1, tr, max(tm + 1, l), r);\n\t}\n\n\tvoid get_pos(int v, int tl, int tr, int pos) {\n\t\tpush(v, tl, tr);\n\t\t\n\t\tif (tl == tr) {\n\t\t\tret_val = tree[v].mx;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint tm = (tl + tr) / 2;\n\t\tif (pos <= tm) get_pos(2 * v, tl, tm, pos);\n\t\telse get_pos(2 * v + 1, tm + 1, tr, pos);\n\t}\n\n\tlong long maximumValueSum(vector<vector<int>>& board) {\n\t\tvector<array<int, 3>> cand;\n\n\t\tint n = board.size(), m = board[0].size();\n\t\ttree.resize(4 * m);\n\t\tmake_tree(1, 0, m - 1);\n\n\t\tvector<int> best_prev_layer(m, -1'000'000'000);\n\t\tint sz = min(4, m);\n\n\t\tlong long ans = -3'000'000'000;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvector<pair<int, int>> best;\n\t\t\tfor (int j = 0; j < m; j++) best.emplace_back(board[i][j], j);\n\t\t\tsort(best.begin(), best.end());\n\t\t\treverse(best.begin(), best.end());\n\n\t\t\n\t\t\tfor (int js = 0; js < sz; js++) {\n\t\t\t\tauto [val, pos] = best[js];\n\n\t\t\t\tret_val = 0;\n\t\t\t\tget_pos(1, 0, m - 1, pos);\n\t\t\t\tans = max(ans, ret_val + val);\n\t\t\t}\n\n\t\t\tfor (int js = 0; js < sz; js++) {\n\t\t\t\tauto [val, pos] = best[js];\n\n\t\t\t\tfor (int prev = 0; prev < m; prev++) {\n\t\t\t\t\tif (prev < pos) {\n\t\t\t\t\t\tupd_val = val + best_prev_layer[prev];\n\t\t\t\t\t\tupdate(1, 0, m - 1, 0, prev - 1);\n\t\t\t\t\t\tupdate(1, 0, m - 1, prev + 1, pos - 1);\n\t\t\t\t\t\tupdate(1, 0, m - 1, pos + 1, m - 1);\n\t\t\t\t\t}\n\t\t\t\t\telse if (prev > pos) {\n\t\t\t\t\t\tupd_val = val + best_prev_layer[prev];\n\t\t\t\t\t\tupdate(1, 0, m - 1, 0, pos - 1);\n\t\t\t\t\t\tupdate(1, 0, m - 1, pos + 1, prev - 1);\n\t\t\t\t\t\tupdate(1, 0, m - 1, prev + 1, m - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int js = 0; js < sz; js++) {\n\t\t\t\tauto [val, pos] = best[js];\n\t\t\t\tbest_prev_layer[pos] = max(best_prev_layer[pos], val);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};",
    "submit_ts": "1723907987",
    "subm_id": "1359133320"
}