{
    "username": "pritishtomar_1",
    "submission": " #define ll long long \nstruct Node {\n    Node* links[26];\n    bool f = false;\n\n    bool conKey(char c) {\n        return links[c - 'a'] != nullptr;\n    }\n\n    void put(char c, Node* node) {\n        links[c - 'a'] = node;\n    }\n\n    Node* get(char c) {\n        return links[c - 'a'];\n    }\n\n    void setEnd() {\n        f = true;\n    }\n\n    bool isEnd() {\n        return f == true;\n    }\n};\n\nclass Trie {\nprivate:\n    Node* root;\n\npublic:\n    Trie() {\n        root = new Node();\n    }\n\n    void insert(std::string word) {\n        Node* node = root;\n        for (int i = 0; i < word.size(); i++) {\n            if (!node->conKey(word[i]))\n                node->put(word[i], new Node());\n            node = node->get(word[i]);\n        }\n        node->setEnd();\n    }\n\n    bool search(std::string word) {\n        Node* node = root;\n        for (int i = 0; i < word.size(); i++) {\n            if (!node->conKey(word[i]))\n                return false;\n            node = node->get(word[i]);\n        }\n        return node->isEnd();\n    }\n\n    bool startsWith(std::string word) {\n        Node* node = root;\n        for (int i = 0; i < word.size(); i++) {\n            if (!node->conKey(word[i]))\n                return false;\n            node = node->get(word[i]);\n        }\n        return true;\n    }\n};\n\n\n\n\n//.............................................................................................\n// Disjoint Set ...\nclass disjointSet {\n\n    vector<int> rank;\n    vector<int> parent;\n    vector<int> size;\n\npublic:\n\n    disjointSet(int n) {\n        rank.resize(n + 1, 0);\n        parent.resize(n + 1, 0);\n        size.resize(n + 1, 1);\n\n        for (int i = 0; i <= n; i++)\n            parent[i] = i;\n    }\n\n    int find(int node) {\n        if (parent[node] == node) return node;\n        return parent[node] = find(parent[node]);\n    }\n\n    void unionR(int u, int v) {\n        int pu = find(u), pv = find(v);\n\n        if (pu == pv) return; \n        if (rank[pu] > rank[pv])\n            parent[pv] = pu;\n        else if (rank[pu] < rank[pv])\n            parent[pu] = pv;\n        else {\n            parent[pv] = pu;\n            rank[pu]++;    \n        }\n    }\n\n    void unionS(int u, int v) {\n        int pu = find(u), pv = find(v);\n\n        if (pu == pv) return;\n\n        if (size[pu] < size[pv]) {\n            parent[pu] = pv;\n            size[pv] += size[pu];\n        }\n        else {\n            parent[pv] = pu;\n            size[pu] += size[pv];\n        }\n    }\n};\n//.............................................................................................\n\n int mod1 = 1e9 + 7;\n\n\nint small_exp(int a, int b) {\n    if (b == 0)\n        return 1;\n\n    int res = small_exp(a, b / 2);\n\n    if (b & 1)\n        return (a * ((res * res) % mod1)) % mod1;\n    else\n        return ((res * res) % mod1) % mod1;\n}\n\n\n\n// Exponentiation for large a and mod...\n// a <= 1e18 + 7 || mod <= 1e18 + 7\nint mod2 = 1e18 + 7;\nll Binary_Multiply ( ll a, ll b ) {\n    ll mod = 1e18 + 7;\n    ll ans = 0;\n\n    while (b > 0) {\n        if (b & 1) ans = (ans + a) % mod;\n        a = (a + a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\n\n\nll large_exp( ll a, ll b) {\n    ll ans = 1;\n\n    while (b > 0) {\n        if (b & 1) ans = Binary_Multiply(a, b);\n        a = Binary_Multiply(a, a);\n        b >>= 1;\n    }\n    return ans;\n} \nclass Solution \n {\n public:\n    \n  const int MOD = 1e9 + 7;\n    const int maxiii = 400;\n    \n    int numberOfPermutations(int n, vector<vector<int>>& requirements) {\n                         ll ans = 0;\n                    unordered_map<ll, ll> mp;\n                         vector<vector<ll>> vv(n + 1, vector<ll>(maxiii + 1, 0));\n                             vv[0][0] = 1; \n                    for (int i=0; i<requirements.size(); i++) \n                        mp[ 1 + requirements[i][0] ] = requirements[i][1];\n\n\n        \n       \n        for (ll sz = 1; sz <= n; ++sz) {\n            for (ll inv = 0; inv <= maxiii; ++inv) {\n                for (ll ptr = 0; ptr < sz; ++ptr) {\n                    ll x = inv - ptr;\n                    if (x >= 0) {\n                        vv[sz][inv] = (vv[sz][inv] + vv[sz - 1][x]) % MOD;\n                    }\n                }\n            }\n\n            if (mp.count(sz)) {\n               \n                for (ll inv = 0; inv <= maxiii; ++inv) {\n                    if (inv != mp[sz]) {\n                        vv[sz][inv] = 0;\n                    }\n                }\n            }\n        }\n       \n        for (ll inv = 0; inv <= maxiii; ++inv) {\n            ans = (ans + vv[n][inv]) % MOD;\n        }\n\n        return static_cast<int>(ans);\n    }\n};",
    "submit_ts": 1719071032.0
}