{
    "username": "mohitkanodia",
    "submission": "class Solution {\n      HashMap<Integer, List<Integer>> map;\n\n      public int[] timeTaken(int[][] edges) {\n        int m = edges.length;\n        map = new HashMap<>();\n        int n = m + 1;\n\n        for (int i = 0; i < m; i++) {\n          int u = edges[i][0];\n          int v = edges[i][1];\n          map.putIfAbsent(u, new ArrayList<>());\n          map.get(u).add(v);\n\n          map.putIfAbsent(v, new ArrayList<>());\n          map.get(v).add(u);\n        }\n        // u.prln(map);\n\n        int[] dp = new int[n];\n        dfs(0, -1, dp);\n        // u.pa(dp);\n\n        int[] ans = new int[n];\n        dfsreroot(0, n, dp, ans);\n        return ans;\n      }\n\n      void dfs(int c, int p, int[] dp) {\n        for (int e : map.getOrDefault(c, new ArrayList<>())) {\n          if (e == p) {\n            continue;\n          }\n          dfs(e, c, dp);\n          int curr = dp[e] + ((e % 2 == 0) ? 2 : 1);\n          dp[c] = Math.max(dp[c], curr);\n        }\n      }\n\n      // reroot now\n      void dfsreroot(int c, int p, int[] dp, int[] ans) {\n        // u.prln(\"c: \" + c);\n        ans[c] = dp[c];\n\n        // edge, dp[e]\n        // max at end of set\n        TreeSet<int[]> set = new TreeSet<>((x, y) -> {\n          if (x[1] == y[1]) {\n            return x[0] - y[0];\n          }\n          return x[1] - y[1];\n        });\n\n        for (int e : map.getOrDefault(c, new ArrayList<>())) {\n          // if (e == p) {\n          // continue;\n          // }\n          int curr = dp[e] + ((e % 2 == 0) ? 2 : 1);\n          set.add(new int[] { e, curr });\n          // u.prln(\"set c: \" + c + \" \" + e + \" \" + curr);\n        }\n\n        for (int e : map.getOrDefault(c, new ArrayList<>())) {\n          if (e == p) {\n            continue;\n          }\n          // u.prln(\"starting c: \"+c+\" \"+e);\n          int oldc = dp[c];\n          int olde = dp[e];\n          // u.prln(\"before rerooting: \" + c + \" \" + e + \" \" + dp[c] + \" \" + dp[e]);\n\n          // reroot now\n          // c -> e\n          // remove e contribution\n          int curre = dp[e] + ((e % 2 == 0) ? 2 : 1);\n          set.remove(new int[] { e, curre });\n\n          if (set.isEmpty()) {\n            dp[c] = 0;\n          } else {\n            dp[c] = set.last()[1];\n          }\n\n          // add c contribution to e\n          int currc = dp[c] + ((c % 2 == 0) ? 2 : 1);\n          dp[e] = Math.max(dp[e], currc);\n\n          // u.prln(\"after rerooting: \" + c + \" \" + e + \" \" + dp[c] + \" \" + dp[e]);\n          dfsreroot(e, c, dp, ans);\n\n          // revert\n          set.add(new int[] { e, curre });\n          dp[c] = oldc;\n          dp[e] = olde;\n          // u.prln(\"done rerooting: \" + c + \" \" + e + \" \" + dp[c] + \" \" + dp[e]);\n        }\n      }\n\n    }",
    "submit_ts": "1722699938",
    "subm_id": "1343226812"
}