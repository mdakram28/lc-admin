{
    "username": "cjycleaner",
    "submission": "using namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vll> vvll;\ntypedef vector<vvll> vvvll;\ntypedef vector<pii> vpii;\ntypedef vector<vpii> vvpii;\ntypedef vector<pll> vpll;\ntypedef vector<vpll> vvpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<vd> vvd;\n#define yn(ans) printf(\"%s\\n\", (ans)?\"Yes\":\"No\");\n#define YN(ans) printf(\"%s\\n\", (ans)?\"YES\":\"NO\");\ntemplate<class T> bool chmax(T &a, T b) {\n\tif (a >= b) return false;\n\ta = b; return true;\n}\ntemplate<class T> bool chmin(T &a, T b) {\n\tif (a <= b) return false;\n\ta = b; return true;\n}\n#define FOR(i, s, e, t) for ((i) = (s); (i) < (e); (i) += (t)) \n#define REP(i, e) for (int i = 0; i < (e); ++i) \n#define REP1(i, s, e) for (int i = (s); i < (e); ++i)\n#define RREP(i, e) for (int i = (e); i >= 0; --i)\n#define RREP1(i, e, s) for (int i = (e); i >= (s); --i)\n#define all(v) v.begin(), v.end()\n#define pb push_back\n#define qb pop_back\n#define pf push_front\n#define qf pop_front\n#define maxe max_element\n#define mine min_element\nll inf = 1e18;\n#define DEBUG printf(\"%d\\n\", __LINE__); fflush(stdout);\ntemplate<class T> void print(vector<T> &v, bool withSize = false) {\n\tif (withSize) cout << v.size() << endl;\n\tREP(i, v.size()) cout << v[i] << \" \"; \n\tcout << endl;\n}\n\nclass Fenw {\npublic:\n\tFenw(ll _n): n(_n), v(n, 0) {}\n\tint lowbit(int x) {return x & -x;}\n\tll query(int x) {\n\t\tll ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += v[i];\n\t\treturn ans;\n\t}\n\tvoid update(int x, ll val) {\n\t\tfor (int i = x; i < n; i += lowbit(i)) {\n\t\t\tv[i] += val;\n\t\t}\n\t}\nprivate:\n\tint n;\n\tvector<ll> v;\n};\n\nmt19937_64 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& q) {\n        int N = nums.size();\n        Fenw f(N + 1);\n        \n        auto upd = [&](int x, int d) {\n            if (nums[x] > nums[x - 1] && nums[x] > nums[x + 1]) f.update(x + 1, d);\n        };\n        \n        REP1(i, 1, N - 1) {\n            upd(i, 1);\n        }\n        \n        int Q = q.size();\n        vi ans;\n        REP(i, Q) {\n            if (q[i][0] == 1) {\n                int l = q[i][1], r = q[i][2];\n                if (r - l + 1 <= 2) ans.pb(0);\n                else {\n                    int cnt = f.query(r) - f.query(l + 1);\n                    ans.pb(cnt);\n                }\n            } else {\n                int x = q[i][1], v = q[i][2];\n                if (x > 0 && x < N - 1) upd(x, -1);\n                if (x > 1) upd(x - 1, -1);\n                if (x < N - 2) upd(x + 1, -1);\n                nums[x] = v;\n                if (x > 0 && x < N - 1) upd(x, 1);\n                if (x > 1) upd(x - 1, 1);\n                if (x < N - 2) upd(x + 1, 1);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718505723.0
}