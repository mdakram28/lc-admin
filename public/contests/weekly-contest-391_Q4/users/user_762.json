{
    "username": "coderchamp07",
    "submission": "class Solution {\npublic:\n    int manhattan(vector<int>& a, vector<int>& b) {\n        return abs(a[0] - b[0]) + abs(a[1] - b[1]);\n    }\n    int minimumDistance(vector<vector<int>>& points) {\n        int n = points.size();\n        int mnX = points[0][0], mxX = points[0][0];\n        int mnY = points[0][1], mxY = points[0][1];\n        \n        for(int i = 0; i < n; i++) {\n            mnX = min(mnX, points[i][0]);\n            mxX = max(mxX, points[i][0]);\n            mnY = min(mnY, points[i][1]);\n            mxY = max(mxY, points[i][1]);\n        }\n        \n        vector<vector<int>> corners = {{mnX, mnY}, {mxX, mnY}, {mnX, mxY}, {mxX, mxY}};\n        \n        set<int> closests;\n        for(auto c : corners) {\n            int mnDist = INT_MAX;\n            for(auto p : points)\n                mnDist = min(mnDist, manhattan(p, c));\n            for(int i = 0; i < n; i++) {\n                if(manhattan(c, points[i]) == mnDist)\n                    closests.insert(i);\n            }\n        }\n        \n        set<int> pointsWithMxDist;\n        int mxDist = 0;\n        for(auto parentIdx : closests) {\n            for(auto p : points)\n                mxDist = max(mxDist, manhattan(p, points[parentIdx]));\n        }\n        for(auto parentIdx : closests) {\n            for(int i = 0; i < n; i++) {\n                if(manhattan(points[i], points[parentIdx]) == mxDist) {\n                    pointsWithMxDist.insert(parentIdx);\n                    pointsWithMxDist.insert(i);\n                }\n            }\n        }\n        \n        // remove corner\n        vector<vector<int>> saved = points;\n        int ans = INT_MAX;\n        for(int remove : pointsWithMxDist) {\n            points = saved;\n            points.erase(points.begin() + remove);\n            n = points.size();\n            mnX = points[0][0], mxX = points[0][0];\n            mnY = points[0][1], mxY = points[0][1];\n\n            for(int i = 0; i < n; i++) {\n                mnX = min(mnX, points[i][0]);\n                mxX = max(mxX, points[i][0]);\n                mnY = min(mnY, points[i][1]);\n                mxY = max(mxY, points[i][1]);\n            }\n\n            corners = {{mnX, mnY}, {mxX, mnY}, {mnX, mxY}, {mxX, mxY}};\n\n            closests.clear();\n            for(auto c : corners) {\n                int mnDist = INT_MAX;\n                for(auto p : points)\n                    mnDist = min(mnDist, manhattan(p, c));\n                for(int i = 0; i < n; i++) {\n                    if(manhattan(c, points[i]) == mnDist)\n                        closests.insert(i);\n                }\n            }\n\n            mxDist = 0;\n            for(auto parentIdx : closests) {\n                for(auto p : points)\n                    mxDist = max(mxDist, manhattan(p, points[parentIdx]));\n            }\n            ans = min(ans, mxDist);\n        }\n        return ans;\n    }\n};"
}