{
    "username": "amaca235",
    "submission": "class Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        // need to figure out if its even possible to break up target into words\n        \n        // what if we for each index i, we are able to calculate if we can reach that using available words\n        // similar to coin change problem\n        \n        // for first index, see which words can match directly with beginning of target\n        // then iterate through indices, and if we were able to reach that index previously from preivous match, do same process as above\n\n        // keep track of cost to get there...\n        // by the time we get to current index, is it valid to assume that is minimum cost to get there?\n\n        // maybe need to do some sort of kmp algorithm\n        // dont know it though...\n        unordered_map<string, int> lowestCosts;\n        for(int i = 0; i < words.size(); i++) {\n            if(lowestCosts[words[i]] == 0) {\n                lowestCosts[words[i]] = costs[i];\n            } else {\n                lowestCosts[words[i]] = min(lowestCosts[words[i]], costs[i]);\n            }\n        }\n        words.clear();\n        costs.clear();\n        for(const auto & [key, value] : lowestCosts) {\n            words.push_back(key);\n            costs.push_back(value);\n        }\n        \n        vector<int> memo(target.size(), -1);\n        for(int i = 0; i < target.size(); i++) {\n            if(i != 0 && memo[i - 1] == -1) continue;\n            int prevCost = i == 0 ? 0 : memo[i - 1];\n            for(int j = 0; j < words.size(); j++) {\n                bool matched = true;\n                int newIndex = i + words[j].size() - 1;\n                if(newIndex >= target.size()) continue;\n                if(memo[newIndex] != -1 && memo[newIndex] <= prevCost + costs[j]) continue;\n                for(int k = 0; k < words[j].size(); k++) {\n                    if (target[i + k] != words[j][k]) {\n                        matched = false;\n                        break;\n                    }\n                }\n                if(matched) {\n                    memo[newIndex] = prevCost + costs[j];\n                }\n            }\n        }\n        return memo.back();\n    }\n};",
    "submit_ts": "1720323419",
    "subm_id": "1312375077"
}