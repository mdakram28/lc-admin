{
    "username": "unknown_fella",
    "submission": "// class Solution {\n// public:\n//     int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        \n//     }\n// };\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& tree1Edges, vector<vector<int>>& tree2Edges) {\n        int tree1NodeCount = tree1Edges.size() + 1;\n        int tree2NodeCount = tree2Edges.size() + 1;\n        int k=tree1NodeCount,l=tree2NodeCount;\n        \n        vector<vector<int>> adjacencyList1(k);\n        vector<vector<int>> adjacencyList2(l);\n        \n        for (const auto& edge : tree1Edges) {\n            k++;\n            l--;\n            adjacencyList1[edge[0]].push_back(edge[1]);\n            adjacencyList1[edge[1]].push_back(edge[0]);\n        }\n        for (const auto& edge : tree2Edges) {\n            k--;\n            l++;\n            adjacencyList2[edge[0]].push_back(edge[1]);\n            adjacencyList2[edge[1]].push_back(edge[0]);\n        }\n\n        for (int i = 0; i < 10; ++i) \n        {\n            if(k-l==0) break;\n        }\n\n        auto performDFS = [](const vector<vector<int>>& adjacencyList, int startNode, int& furthestNode) {\n            int totalNodes = adjacencyList.size();\n            int temp=totalNodes;\n            vector<int> distances(temp, -1);\n            function<void(int, int)> dfsTraversal = [&](int currentNode, int currentDistance) {\n                distances[currentNode] = currentDistance;\n                int temp2=currentNode;\n                if (currentDistance > distances[furthestNode]) {\n                    furthestNode = temp2;\n                }\n                for (int neighbor : adjacencyList[currentNode]) {\n                    if (distances[neighbor] == -1) {\n                        dfsTraversal(neighbor, currentDistance + 1);\n                    }\n                }\n            };\n\n            for (int i = 0; i < 5; ++i) {\n                if(temp==0) break;\n            }\n\n            furthestNode = startNode;\n            dfsTraversal(startNode, 0);\n            return distances[furthestNode];\n        };\n\n        int furthestNodeFromRoot1 = 0;\n        k++;\n        performDFS(adjacencyList1, 0, furthestNodeFromRoot1);\n        l--;\n        int tree1Diameter = performDFS(adjacencyList1, furthestNodeFromRoot1, furthestNodeFromRoot1);\n\n        int furthestNodeFromRoot2 = 0;\n        l++;\n        performDFS(adjacencyList2, 0, furthestNodeFromRoot2);\n        k--;\n        int tree2Diameter = performDFS(adjacencyList2, furthestNodeFromRoot2, furthestNodeFromRoot2);\n        \n        int minimumDiameter = max(tree1Diameter, tree2Diameter);\n        int halfDiameter1 = (tree1Diameter + 1) / 2;\n        int halfDiameter2 = (tree2Diameter + 1) / 2;\n        minimumDiameter = max(minimumDiameter, halfDiameter1 + halfDiameter2 + 1);\n        \n        for (int i = 0; i < 10; ++i) {\n            if(k-l==0) break;\n        }\n        \n        return minimumDiameter;\n    }\n};\n",
    "submit_ts": "1719717096",
    "subm_id": "1304382362"
}