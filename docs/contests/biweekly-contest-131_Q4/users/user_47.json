{
    "username": "subrat0018",
    "submission": "#define ll long long\nconst ll INF = 1e18;\ntemplate<class T>\nclass SegTree\n{\npublic:\n    vector<int> lo;\n    vector<int> hi;\n    vector<T> tree;\n    SegTree(int n)\n    {\n        lo.resize(4 * n + 1);\n        hi.resize(4 * n + 1);\n        tree.resize(4 * n + 1);\n        init(1,0,n-1);\n    }\n    void init(int i,int a,int b)\n    {\n        lo[i] = a;\n        hi[i] = b;\n        if(a == b)\n            return ;\n        int mid = (a + b)/2;\n        init(2 * i , a, mid);\n        init(2 * i + 1,mid+1,b);\n    }\n    void modify(int a,int b,T val,int i=1)\n    {\n        if(b < lo[i] || a > hi[i])\n            return ;\n        else if(a <= lo[i] && hi[i] <= b)\n        {\n            tree[i] = val;\n            return;\n        }\n        prop(i);\n        \n        modify(a, b, val, 2 * i);\n        modify(a, b, val, 2 * i + 1);\n        \n        update(i);\n    }\n    T query(int a, int b, int i=1)\n    {\n        if(b < lo[i] || a > hi[i])\n        {\n            return -INF;\n        }\n        else if(a <= lo[i] && hi[i] <= b)\n        {\n            return tree[i];\n        }\n        prop(i);\n        \n        T left = query(a, b, 2 * i);\n        T right = query(a, b, 2 * i + 1);\n        \n        update(i);\n        return apply(left,right);\n    }\n    void prop(int i)\n    {\n        // lazy[2 * i] += lazy[i];\n        // lazy[2 * i + 1] += lazy[i];\n        // lazy[i] = 0;\n    }\n    void update(int i)\n    {\n        tree[i] = apply(tree[2 * i] , tree[2 * i + 1]);\n    }\n    T apply(T x1, T x2)\n    {\n        return max(x1, x2);\n    }\n};\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        map<ll,ll> mp;\n        mp[0] = INF;\n        SegTree<ll> tt(3 * 1LL * queries.size() + 5);\n        vector<bool> ans;\n        for(auto &val:queries){\n            int t = val[0];\n            if(t == 1){\n                ll x = val[1];\n                auto it = mp.upper_bound(x);\n                ll val = INF;\n                if(it != mp.end())\n                {\n                    val = it->first - x;\n                }\n                it--;\n                it->second = (x - it->first);\n                tt.modify(it->first, it->first, it->second);\n                mp[x] = val;\n                tt.modify(x, x, val);\n            }else{\n                ll x = val[1];\n                ll sz = val[2];\n                if(x < sz){\n                    ans.push_back(false);\n                    continue;\n                }\n                auto it = mp.upper_bound(x);\n                it--;\n                ll lastsz = x - it->first;\n                // cout<<\"lastsz \"<<lastsz<<endl;\n                if(lastsz >= sz){\n                    ans.push_back(true);\n                    continue;\n                }\n                ll maxi = tt.query(0, it->first - 1);\n                // cout<<\"maxi \"<<maxi<<endl;\n                // for(auto &val:mp){\n                //     cout<<val.first<<\" \"<<val.second<<endl;\n                // }\n                if(maxi >= sz){\n                    ans.push_back(true);\n                    continue;\n                }\n                ans.push_back(false);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716649672.0
}