{
    "username": "tiankonguse",
    "submission": "\ntypedef long long ll;\n\n// 1.bulid(); 2.query(a,b) 3.update(a,b)\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\nconst int maxn = 1e5 + 10;\nconst int kMaxVal = 10e8;\n\nint maxNM;\n\ntypedef long long ll;\nstruct SegTree {\n  vector<ll> sign;\n  vector<ll> sumVal;\n  // vector<ll> nums;\n  // vector<pair<ll, ll>> LR;\n  vector<ll> str;\n\n  void Init(int n, vector<int>& nums_) {\n    n += 5;\n    maxNM = n;\n    sumVal.resize(maxNM << 2, 0);\n    // nums.resize(maxNM << 2, 0);\n    // LR.resize(maxNM << 2);\n    str.clear();\n    str.resize(maxNM + 1, INT_MAX);\n    for (int i = 0; i < nums_.size(); i++) {\n      str[i + 2] = nums_[i];\n    }\n  }\n\n  bool Check(int l, int r, int m) {  // [l,m] [m+1, r]\n    if (l < m && str[m] > str[m - 1] && str[m] > str[m + 1]) return true;\n    if (m + 1 < r && str[m + 1] > str[m + 2] && str[m + 1] > str[m])\n      return true;\n    return false;\n  }\n\n  void PushUp(int rt, int l, int r) {  //\n    sumVal[rt] = sumVal[rt << 1] + sumVal[rt << 1 | 1];\n    if (Check(l, r, (l + r) >> 1)) {\n      sumVal[rt]++;\n    }\n  }\n\n  void Bulid(int l = 1, int r = maxNM, int rt = 1) {\n    // LR[rt] = {l, r};\n    if (l == r) {\n      sumVal[rt] = 0;\n      return;\n    }\n    int m = (l + r) >> 1;\n    Bulid(lson);\n    Bulid(rson);\n    PushUp(rt, l, r);\n  }\n  void Update(int L, int R, int add, int l = 1, int r = maxNM, int rt = 1) {\n    if (L <= l && r <= R) {\n      sumVal[rt] = 0;\n      str[l] = add;\n      // sumVal[rt] += add * nums[rt];\n      return;\n    }\n    int m = (l + r) >> 1;\n    if (L <= m) Update(L, R, add, lson);\n    if (R > m) Update(L, R, add, rson);\n    PushUp(rt, l, r);\n  }\n  ll QuerySum(int L, int R, int l = 1, int r = maxNM, int rt = 1) {\n    if (L <= l && r <= R) {\n      return sumVal[rt];\n    }\n    int m = (l + r) >> 1;\n    ll ret = 0;\n    if (L <= m) {\n      ret += QuerySum(L, R, lson);\n    }\n    if (m < R) {\n      ret += QuerySum(L, R, rson);\n    }\n    if (L <= m && m < R && Check(max(l, L), min(r, R), m)) {\n      ret++;\n    }\n    return ret;\n  }\n};\n\nSegTree segTree;\n\nclass Solution {\n public:\n  vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n    int n = nums.size();\n    segTree.Init(n, nums);\n    segTree.Bulid();\n\n    vector<int> ans;\n    ans.reserve(queries.size());\n    for (auto& v : queries) {\n      int op = v[0];\n      if (op == 1) {\n        int l = v[1] + 2, r = v[2] + 2;\n        ans.push_back(segTree.QuerySum(l, r));\n      } else {\n        int index = v[1] + 2;\n        ll val = v[2];\n        segTree.Update(index, index, val);\n      }\n    }\n    return ans;\n  }\n};",
    "submit_ts": "1718508771",
    "subm_id": "539789227"
}