{
    "username": "pkIFW7iAJl",
    "submission": "class Solution {\n    class Pair {\n        int node;\n        int distance;\n        public Pair(int node, int distance) {\n            this.node = node;\n            this.distance = distance;\n        }\n    }\n    public int[] bfs(Map<Integer, List<Integer> > graph, int root) {\n        Set<Integer> visited = new HashSet<>();\n        ArrayDeque<Pair> q = new ArrayDeque<>();\n        q.add(new Pair(root, 0));\n        int farthestNode = 0, maxDistance = 0;\n        while(q.size() > 0) {\n            // r m* w a*\n            Pair rem = q.removeFirst();\n            \n            if(visited.contains(rem.node)) {\n                continue;\n            }\n            visited.add(rem.node);\n            \n            if(rem.distance > maxDistance) {\n                farthestNode = rem.node; // \n                maxDistance = rem.distance; //\n            }\n            \n            for(int i = 0 ; i < graph.getOrDefault(rem.node, new ArrayList<>()).size() ; ++i) {\n                if(!visited.contains(graph.get(rem.node).get(i))) {\n                    q.add(new Pair(graph.get(rem.node).get(i), 1 + rem.distance));\n                }\n            }\n        }\n        // System.out.println(\"fn: \" + farthestNode + \" md: \" + maxDistance);\n        return new int[]{farthestNode, maxDistance};\n    }\n    public int getDiameter(int[][] edges) {\n        Map<Integer, List<Integer> > graph = new HashMap<>();\n        for(int[] edge : edges) {\n            List<Integer> list1 = graph.getOrDefault(edge[0], new ArrayList<>());\n            list1.add(edge[1]);\n            graph.put(edge[0], list1);\n            \n            List<Integer> list2 = graph.getOrDefault(edge[1], new ArrayList<>());\n            list2.add(edge[0]);\n            graph.put(edge[1], list2);\n        }\n        int[] arr = bfs(graph, 0);\n        return bfs(graph, arr[0])[1];\n    }\n    public int solve(int[][] edges) {\n        int dm = getDiameter(edges);\n        // System.out.println(dm);\n        return (int)Math.ceil((double)dm / 2.0);\n    }\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        return Math.max(1 + solve(edges1) + solve(edges2), Math.max(getDiameter(edges1), getDiameter(edges2)));\n    }\n}",
    "submit_ts": 1719719950.0
}