{
    "username": "user2237El",
    "submission": "#define endl \"\\n\";\n#define nline cout<<\"\\n\";\n#define mem1(a)           memset(a,-1,sizeof(a))\n#define mem0(a)           memset(a,0,sizeof(a))\n#define all(x)            (x).begin(),(x).end()\n#define all1(v) (v).begin()+1,(v).end()\n#define pb push_back\n#define INF 1e18\n#define ppb pop_back\n#define pf push_front\n#define ppf pop_front\n#define mp make_pair\n#define I insert\n#define F first\n#define S second\n#define B begin()\n//#define L length()\n#define E end():tabnew \n#define lb lower_bound\n#define ub upper_bound\n#define umap unordered_map\n#define uset unordered_set\n#define rep(i,a,b)   for(ll i=a;i<b;i++)\n#define per(i,n,b)   for(ll i=n;i>=b;i--)\n#define pii pair<ll,ll>\n#define NO           cout<<\"NO\"<<endl;\n#define YES          cout<<\"YES\"<<endl;\n#define pprt(v,n) for(ll i=0;i<n;i++) cout<<v[i].F<<\" \"<<v[i].S<<endl;\n#define dbg(var) cerr<<#var<<\"=\"<<var<<\" \"\n#define sz(x) (ll)x.size()\n#define mxe(v)  *max_element(v.begin(),v.end())     // find max element in vector\n#define mne(v)  *min_element(v.begin(),v.end())     // find min element in vector\n#define max3(a,b,c) max(max((a),(b)),(c))\n#define max4(a,b,c,d) max(max((a),(b)),max((c),(d)))\n#define min3(a,b,c) min(min((a),(b)),(c))\n#define min4(a,b,c,d) min(min((a),(b)),min((c),(d)))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lld;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<vector<bool> > VVB;\ntypedef priority_queue<ll> PQ;\ntypedef priority_queue<ll,VL,greater<ll> > MPQ;\ntypedef vector<bool> VB;\ntypedef queue<ll> QU;\ntypedef stack<ll> ST;\ntypedef set<ll> SL;\ntypedef set<pair<ll,ll> > SPL;\ntypedef vector<char> VCH;\ntypedef vector<vector<ll> > VVL;\ntypedef vector<vector<char> > VVCH;\ntypedef vector<vector<pair<ll,ll> > > VVPL;\ntypedef vector<pair<ll,ll> > VPL;\n/*\nKEYNOTES:\n------------------------------------------\nmerge(X,identity_element) = X\n------------------------------------------\n------------------------------------------\nidentity_transformation.combine(X) = X\n------------------------------------------\n------------------------------------------\nALWAYS: older_update.combine(newer_update)\n------------------------------------------\n*/\n \n \n \n// example: addition: identity element is 0\n \n// a + 0 = a or 0 + a = a\n \n// min(x,INF) = x\n \nstruct my_node\n{\n    ll mn = 0;\n\n    // use more variables if you want more information\n    // these default values should be identity_element\n    my_node(){}\n    my_node(int val){\n        mn = val;\n    }\n    void merge(const my_node &l,const my_node &r){ // store the thing you wanna query\n    \n        mn=l.mn+r.mn;   \n        // if we wanted the maximum, then we would do\n        // like v = max(l.v,r.v)\n    }\n\n};\n \n// example: add on a range: identity transformation = 0\n// old += new\n \n// if old is identity which is 0, then 0 + new which new\n \nstruct my_update\n{\n    ll v = 0; // 4\n    // use more variables if you want more information\n    // these default values should be identity_transformation\n    my_update(){}\n    my_update(ll val){\n        v = val; // 5\n    }\n    // combine the current my_update with the other my_update (see keynotes)\n    void combine(my_update &other,const ll &tl,const ll &tr){\n        v += other.v;\n        // you can be sure that the \"other\" is newer than current\n \n    }\n    // store the correct information in the my_node x\n    void apply(my_node &x,const ll &tl,const ll &tr){\n \n        // no change in freq\n        x.mn +=((tr-tl+1)*v);\n    }\n};\n \ntemplate<typename node,typename update>\nstruct segtree\n{\n    ll len;\n    vector<node> t;\n    vector<update> u;\n    vector<bool> lazy;\n    node identity_element;\n    update identity_transformation;\n    segtree(ll l){\n        len = l;\n        t.resize(4 * len);\n        u.resize(4 * len);\n        lazy.resize(4 * len);\n        identity_element = node();\n        identity_transformation = update();\n    }\n \n    void pushdown(const ll &v, const ll &tl, const ll &tr){\n        if(!lazy[v]) return;\n        ll tm = (tl + tr) >> 1;\n        apply(v<<1,tl,tm,u[v]);\n        apply(v<<1|1,tm+1,tr,u[v]);\n        u[v] = identity_transformation;\n        lazy[v] = 0;\n    }\n \n    void apply(const ll &v, const ll &tl, const ll &tr, update upd){\n        if(tl != tr){\n            lazy[v] = 1;\n            u[v].combine(upd,tl,tr);\n        }\n        upd.apply(t[v],tl,tr);\n    }\n \n    template<typename T>\n    void build(const T &arr,const ll &v, const ll &tl, const ll &tr){\n        if(tl == tr){\n            t[v] = arr[tl];\n            return;\n        }\n        ll tm = (tl + tr) >> 1;\n        build(arr,v<<1,tl,tm);\n        build(arr,v<<1|1,tm+1,tr);\n        t[v].merge(t[v<<1],t[v<<1|1]);\n    }\n \n    node query(const ll &v,const ll &tl,const ll &tr,const ll &l,const ll &r){\n        if(l > tr || r < tl){\n            return identity_element;\n        }\n        if(tl >= l && tr <= r){\n            return t[v];\n        }\n        pushdown(v,tl,tr);\n        ll tm = (tl + tr) >> 1;\n        node a = query(v<<1,tl,tm,l,r),b = query(v<<1|1,tm+1,tr,l,r),ans;\n        ans.merge(a,b);\n        return ans;\n    }\n \n    // rupd = range update\n    void rupd(const ll &v,const ll &tl,const ll &tr,const ll &l,const ll &r,const update &upd){\n        if(l > tr || r < tl){\n            return;\n        }\n        if(tl >= l && tr <= r){\n            apply(v,tl,tr,upd);\n            return;\n        }\n        pushdown(v,tl,tr);\n        ll tm = (tl + tr) >> 1;\n        rupd(v<<1,tl,tm,l,r,upd);\n        rupd(v<<1|1,tm+1,tr,l,r,upd);\n        t[v].merge(t[v<<1],t[v<<1|1]);\n    }\n \n    public:\n\n    template<typename T>\n    void build(const T &arr){\n        build(arr,1,0,len-1);\n    }\n    node query(const ll &l,const ll &r){\n        return query(1,0,len-1,l,r);\n    }\n    void rupd(const ll &l,const ll &r,const update &upd){\n        rupd(1,0,len-1,l,r,upd);\n    }\n};\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& v, vector<vector<int>>& t) {\n        int n=v.size();\n        int m=t.size();\n        \n        VL pre(n),peak(n);;\n    pre[0]=0;\n    rep(i,1,n){\n        if(i+1<n){\n            pre[i]=pre[i-1]+(v[i]>v[i-1] && v[i]>v[i+1]);\n            if(pre[i]==pre[i-1]+1){\n                peak[i]=1;\n            }\n        }\n        else{\n            pre[i]=pre[i-1];\n        }\n    }\n\n    segtree<my_node,my_update> s(n);\n    s.build(pre);\n\n    auto cal=[&](ll id)->ll{\n        if(id==0 || id==n-1){\n            return 0;\n        }\n        return (v[id]>v[id-1] && v[id]>v[id+1]);\n    };\n\n    vector<int>  ans;\n    rep(i,0,m){\n\n        if(t[i][0]==1){\n            ll l=t[i][1];\n            ll r=t[i][2];\n            r--;\n            if(r>l){\n                ll uu=s.query(r,r).mn;\n                ll pp=s.query(l,l).mn;\n                ans.push_back(uu-pp);\n            }\n            else{\n                ans.push_back(0);\n            }\n        }\n        else{\n            ll id=t[i][1];\n            ll val=t[i][2];\n            \n            v[id]=val;\n            if(id-1>=0){\n               // s+=peak[id-1];\n                ll se=peak[id-1];\n                ll ne=cal(id-1);\n                if(se!=ne){\n                    s.rupd(id-1,n-1,ne-se);\n                }\n                peak[id-1]=ne;\n            }\n            if(id>=0){\n                // s+=peak[id];\n                ll se=peak[id];\n                ll ne=cal(id);\n                 if(se!=ne){\n                    s.rupd(id,n-1,ne-se);\n                }\n                peak[id]=ne;\n            }\n            if(id+1<n){\n                // s+=peak[id+1];\n                ll se=peak[id+1];\n                ll ne=cal(id+1);\n                if(se!=ne){\n                    s.rupd(id+1,n-1,ne-se);\n                }\n                peak[id+1]=ne;\n            }\n        }\n    }\n\n    return ans;\n    }\n};",
    "submit_ts": 1718508183.0
}