{
    "username": "uwu",
    "submission": "#[cfg(debug_assertions)]\nuse crate::*;\n\nimpl Solution {\n    pub fn maximum_sum_subsequence(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> i32 {\n        let mut a = vec![];\n        for x in nums {\n            a.push(Node {\n                ad: x.max(0) as i64,\n                ..Default::default()\n            });\n        }\n        let mut st = SegmentTree::from_slice(&a, Node::default(), |x, y| Node {\n            ac: (x.ad + y.bc).max(x.ac + y.ac).max(x.ac + y.bc),\n            ad: (x.ad + y.bd).max(x.ac + y.ad).max(x.ac + y.bd),\n            bc: (x.bd + y.bc).max(x.bc + y.ac).max(x.bc + y.bc),\n            bd: (x.bd + y.bd).max(x.bc + y.ad).max(x.bc + y.bd),\n        });\n        let mut ans = 0;\n        for q in queries {\n            let (pos, x) = (q[0] as usize, q[1]);\n            st.set(\n                pos,\n                Node {\n                    ad: x.max(0) as i64,\n                    ..Default::default()\n                },\n            );\n            let node = st.root();\n            ans += node.ac.max(node.ad).max(node.bc).max(node.bd);\n            ans %= 1_000_000_007;\n        }\n        ans as i32\n    }\n}\n\n#[derive(Clone, Default)]\nstruct Node {\n    // abcd\n    ac: i64,\n    ad: i64,\n    bc: i64,\n    bd: i64,\n}\n\npub struct SegmentTree<T, F> {\n    n: usize,\n    p: usize,\n    a: Vec<T>,\n    t: T,\n    op: F,\n}\n\nimpl<T, F> SegmentTree<T, F>\nwhere\n    T: Clone,\n    F: Fn(&T, &T) -> T,\n{\n    pub fn new(n: usize, t: T, op: F) -> Self {\n        assert!(n > 0);\n        let p = n.next_power_of_two();\n        let a = vec![t.clone(); 2 * p];\n        SegmentTree { n, p, a, t, op }\n    }\n\n    pub fn from_slice(src: &[T], t: T, op: F) -> Self {\n        let n = src.len();\n        let p = n.next_power_of_two();\n        let mut a = vec![t.clone(); 2 * p];\n        a[p..p + n].clone_from_slice(src);\n        for i in (1..p).rev() {\n            a[i] = op(&a[2 * i], &a[2 * i + 1]);\n        }\n        SegmentTree { n, p, a, t, op }\n    }\n\n    pub fn root(&self) -> T {\n        self.a[1].clone()\n    }\n\n    pub fn get(&self, index: usize) -> T {\n        assert!(index < self.n);\n        self.a[index + self.p].clone()\n    }\n\n    pub fn set(&mut self, index: usize, value: T) {\n        assert!(index < self.n);\n        let mut i = index + self.p;\n        self.a[i] = value;\n        i >>= 1;\n        while i > 0 {\n            self.a[i] = (self.op)(&self.a[2 * i], &self.a[2 * i + 1]);\n            i >>= 1;\n        }\n    }\n\n    pub fn query(&self, l: usize, r: usize) -> T {\n        assert!(l <= r);\n        assert!(r <= self.n);\n        let mut l = l + self.p;\n        let mut r = r + self.p;\n        let mut x = self.t.clone();\n        let mut y = self.t.clone();\n        while l < r {\n            if l % 2 != 0 {\n                x = (self.op)(&x, &self.a[l]);\n                l += 1;\n            }\n            if r % 2 != 0 {\n                r -= 1;\n                y = (self.op)(&self.a[r], &y);\n            }\n            l >>= 1;\n            r >>= 1;\n        }\n        (self.op)(&x, &y)\n    }\n\n    // maximum r s.t. f(a[l..r]) = true\n    pub fn search_right(&self, l: usize, mut f: impl FnMut(&T) -> bool) -> usize {\n        assert!(l <= self.n);\n        assert!(f(&self.t));\n        if l == self.n {\n            return self.n;\n        }\n        let mut index = l + self.p;\n        let mut cur = self.t.clone();\n        loop {\n            while index % 2 == 0 {\n                index >>= 1;\n            }\n            let next = (self.op)(&cur, &self.a[index]);\n            if f(&next) {\n                cur = next;\n                index += 1;\n                if index.is_power_of_two() {\n                    return self.n;\n                }\n            } else {\n                while index < self.p {\n                    index <<= 1;\n                    let next = (self.op)(&cur, &self.a[index]);\n                    if f(&next) {\n                        cur = next;\n                        index += 1;\n                    }\n                }\n                return index - self.p;\n            }\n        }\n    }\n\n    // minimum l s.t. f(a[l..r]) = true\n    pub fn search_left(&self, r: usize, mut f: impl FnMut(&T) -> bool) -> usize {\n        assert!(r <= self.n);\n        assert!(f(&self.t));\n        if r == 0 {\n            return 0;\n        }\n        let mut index = r + self.p;\n        let mut cur = self.t.clone();\n        loop {\n            index -= 1;\n            while index > 1 && index % 2 == 1 {\n                index >>= 1;\n            }\n            let next = (self.op)(&self.a[index], &cur);\n            if f(&next) {\n                cur = next;\n                if index.is_power_of_two() {\n                    return 0;\n                }\n            } else {\n                while index < self.p {\n                    index <<= 1;\n                    index += 1;\n                    let next = (self.op)(&self.a[index], &cur);\n                    if f(&cur) {\n                        cur = next;\n                        index -= 1;\n                    }\n                }\n                return index + 1 - self.p;\n            }\n        }\n    }\n}\n",
    "submit_ts": 1716693345.0
}