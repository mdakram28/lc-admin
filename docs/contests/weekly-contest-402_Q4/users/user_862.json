{
    "username": "fizhim",
    "submission": "impl Solution {\n    pub fn count_of_peaks(mut nums: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut t = SegTree::new(nums.len());\n        \n        fn peak(nums: &[i32], i: usize) -> i64 {\n            if i > 0 && i + 1 < nums.len() && nums[i - 1] < nums[i] && nums [i] > nums[i + 1] { 1 } else { 0 }\n        }\n\n        for i in 1..nums.len() - 1 {\n            //println!(\"{i} {}\", peak(&nums, i));\n            t.update(i, peak(&nums, i));\n        }\n        \n        let mut ans = vec![];\n        \n        for q in &queries {\n            if q[0] == 1 {\n                ans.push(t.get(q[1] as usize + 1, q[2] as usize).unwrap_or(0) as _);\n                continue;\n            }\n            \n            let i = q[1] as usize;\n            \n            nums[i] = q[2];\n            t.update(i, peak(&nums, i));\n            \n            if (i > 0) {\n                t.update(i - 1, peak(&nums, i - 1));\n            }\n\n            if i + 1 < nums.len() {\n                t.update(i + 1, peak(&nums, i + 1));\n            }\n        }\n        \n        ans\n    }\n}\n\nstruct SegTree {\n    a: Vec<Option<i64>>,\n    len2: usize,\n}\n\nimpl SegTree {\n    pub fn new(len: usize) -> SegTree {\n        let mut len2 = 1;\n        while len2 < len {\n            len2 *= 2;\n        }\n        SegTree {\n            a: vec![None; len2 + len + 1],\n            len2\n        }\n    }\n\n    pub fn update(&mut self, i: usize, val: i64) {\n        let mut j = self.len2 + i;\n        self.a[j] = Some(val);\n        while j > 1 {\n            j /= 2;\n            self.a[j] = Self::f_opt(self.a[j * 2], self.a[j * 2 + 1]);\n        }\n    }\n\n    pub fn get(&self, b: usize, e: usize) -> Option<i64> {\n        let mut ans = None;\n        let mut st = vec![];\n        st.push((b, e, 0, self.len2, 1));\n        while let Some((b, e, l, r, i)) = st.pop() {\n            if b >= e {\n                continue;\n            }\n            if b == l && e == r {\n                ans = Self::f_opt(ans, self.a[i]);\n                continue;\n            }\n            let m = l + (r - l) / 2;\n            st.push((b, e.min(m), l, m, i * 2));\n            st.push((b.max(m), e, m, r, i * 2 + 1));\n        }\n        ans\n    }\n\n    fn f_opt(a: Option<i64>, b: Option<i64>) -> Option<i64> {\n        match (a, b) {\n            (None, None) => None,\n            (Some(a), None) => Some(a),\n            (None, Some(b)) => Some(b),\n            (Some(a), Some(b)) => Some(Self::f(a, b)),\n        }\n    }\n\n    fn f(a: i64, b: i64) -> i64 {\n        a + b\n    }\n}\n",
    "submit_ts": 1718508946.0
}