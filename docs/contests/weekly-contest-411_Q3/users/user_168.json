{
    "username": "Andwerp",
    "submission": "typedef pair<int, int> pii;\nclass Solution {\npublic:\n    string largestPalindrome(int n, int k) {\n        vector<int> kmod(n);\n        kmod[0] = 1;\n        for(int i = 1; i < n; i++){\n            kmod[i] = (kmod[i - 1] * 10) % k;\n        }\n        //dp[i][j] = maximum val where\n        //i = number of palindrome digits\n        //j = current remainder mod k. \n        int _n = n;\n        n = (n + 1) / 2;\n        vector<vector<pair<int, pii>>> dp(n + 1, vector<pair<int, pii>>(k, {-1, {-1, -1}}));  //actually keeps track of prev digit\n        dp[0][0] = {0, {-2, -2}};\n        //{prev dig, prev remainder}\n        for(int i = 0; i < n; i++){\n            // cout << \"I : \" << i << \"\\n\";\n            //consider the states in descending order\n            map<int, int> m;\n            for(int j = 0; j < k; j++){\n                if(dp[i][j].first == -1){\n                    continue;\n                }\n                m[dp[i][j].first] = j;\n            }\n            int lexptr = 0;\n            for(auto j = m.begin(); j != m.end(); j++){\n                int crem = j->second;\n                // cout << \"CREM : \" << crem << \"\\n\";\n                for(int dig = 9; dig >= 0; dig--){\n                    int l = i;\n                    int r = _n - 1 - i;\n                    int nrem = crem + dig * kmod[l];\n                    if(l != r){\n                        nrem += dig * kmod[r];\n                    }\n                    nrem %= k;\n                    if(dp[i + 1][nrem].first == -1) {\n                        // cout << \"TRANSITION : \" << crem << \" \" << nrem << \"\\n\";\n                        dp[i + 1][nrem] = {lexptr ++, {dig, crem}};\n                    }\n                }\n            }\n        }\n\n\n        string ans(_n, ' ');\n        int ptr = 0;\n        int indptr = (_n - 1) / 2;\n        for(int i = n; i > 0; i--){\n            // cout << \"PTR : \" << ptr << \" \" << dp[i][ptr].second.first << \" \" << dp[i][ptr].second.second << endl;\n            int dig = dp[i][ptr].second.first;\n            ans[indptr] = dig + '0';\n            ans[_n - 1 - indptr] = dig + '0';\n            indptr --;\n            ptr = dp[i][ptr].second.second;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1723950905",
    "subm_id": "1359758143"
}