{
    "username": "genuine_code",
    "submission": "class Solution {\npublic:\n    int binary_first_search(vector<vector<int>> &v2, int start, int t1, int t2, int modules) {\n    queue<int> que;\n    vector<int> visit_hai(modules + 4, 0);\n    que.push(start);\n    visit_hai[start] = 1;\n    \n    while (!que.empty()) {\n        int temp1 = que.front();\n        que.pop();\n        for (int temp2 : v2[temp1]) {\n            if (!visit_hai[temp2]) {\n                que.push(temp2);\n                visit_hai[temp2] = 1;\n            }\n        }\n    }\n    return visit_hai[t1] || visit_hai[t2];\n}\n    bool solution(int X, int Y, vector<vector<int>>& beamer,vector<pair<pair<int, int>, int>> v1,vector<vector<int>> v2){\n         int first=beamer.size();\n        \n        for (int i = 0; i < first; ++i) {\n            v1[i].first.first=beamer[i][0];\n            v1[i].first.second=beamer[i][1];\n            v1[i].second=beamer[i][2];\n        }\n        \n        \n        \n         for (int i = 0; i < first; ++i) {\n             \n            if (v1[i].first.first <= v1[i].second) {\n                v2[first].push_back(i);\n                v2[i].push_back(first);\n            }\n            if (X - v1[i].first.first <= v1[i].second) {\n                v2[first + 2].push_back(i);\n                v2[i].push_back(first + 2);\n            }\n            if (v1[i].first.second <= v1[i].second) {\n                v2[first + 1].push_back(i);\n                v2[i].push_back(first + 1);\n            }\n            if (Y - v1[i].first.second <= v1[i].second) {\n                v2[first + 3].push_back(i);\n                v2[i].push_back(first + 3);\n            }\n            for (int j = i + 1; j < first; ++j) {\n                double dist = sqrt(pow(v1[i].first.first - v1[j].first.first, 2) +\n                                       pow(v1[i].first.second - v1[j].first.second, 2));\n                int radii = v1[i].second + v1[j].second;\n                if (radii >= dist) {\n                    v2[i].push_back(j);\n                    v2[j].push_back(i);\n                }\n            }\n        }\n        \n        int block_or_not = 0;\n    block_or_not = max(block_or_not, binary_first_search(v2, first, first + 1, first + 2, first + 4)); \n    block_or_not = max(block_or_not, binary_first_search(v2, first + 3, first + 2, first + 1, first + 4)); \n        if (block_or_not){return false;}\n        return true;\n       \n    }\n    bool print(bool ans){\n        return ans;\n    }\n    int find_ans(int X, int Y, vector<vector<int>>& beamer){\n        int temp = X;\n        int temp2 = Y;\n        int x=temp2;\n        int y=temp;\n        bool ans = true;\n        print(ans);\n        return 0;\n    }\n    bool canReachCorner(int X, int Y, vector<vector<int>>& beamer) {\n        vector<pair<pair<int, int>, int>> v1(beamer.size());\n        vector<vector<int>> v2(beamer.size() + 4);\n        bool ans = solution(X,Y,beamer,v1,v2);\n        find_ans(X,Y,beamer);\n        return print(ans);\n    }\n};",
    "submit_ts": "1722139049",
    "subm_id": "1335806466"
}