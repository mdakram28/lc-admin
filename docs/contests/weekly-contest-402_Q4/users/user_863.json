{
    "username": "bladechen",
    "submission": "struct Node {\n//    int lval, rval;\n    int cnt;\n    void clear() {\n        //lval = rval = -1;\n        cnt = 0;\n    }\n    \n}node_list[100001 * 4];\n\nstruct SegTree {\n    void build(int idx, int left, int right, vector<int>& nums) {\n        node_list[idx].clear();\n        if (left == right) {\n //           node_list[idx].lval = node_list[idx].rval = nums[left];\n            if (left > 0 && left < nums.size() - 1) {\n                node_list[idx].cnt = (nums[left] > nums[left - 1] ) && (nums[left] > nums[left + 1]);\n            }\n            \n            return;\n        }\n        int mid = (left + right) >> 1;\n        build(idx * 2 + 1, left, mid, nums);\n        build(idx * 2 + 2, mid + 1, right, nums);\n        node_list[idx].cnt = node_list[idx * 2 + 1].cnt + node_list[idx * 2 + 2].cnt;\n        \n        //push_up(idx, left, right);\n        \n    }\n    SegTree(vector<int>& nums) {\n        build(0, 0, nums.size() - 1, nums);\n        \n    }\n    \n    int query(int idx, int left, int right, int L, int R) {\n        if (L <= left && R >= right) {\n            return node_list[idx].cnt;\n        }\n        int mid = (left + right) >> 1;\n        int res = 0;\n        if (L <= mid) {\n            res += query(idx * 2 + 1, left, mid, L, R);\n            \n        } \n        if (R > mid){\n            res += query(idx * 2 + 2, mid + 1, right, L, R);\n                \n        }\n        return res ;\n    }\n    \n    void update(int idx, int left, int right, int X, vector<int>& nums) {\n        if (left == X && right == X) {\n            if (left == 0 || left == nums.size() -1 ) node_list[idx].cnt = 0;\n            else {\n                node_list[idx].cnt = (nums[left] > nums[left - 1] ) && (nums[left] > nums[left + 1]);\n            }\n            return ;\n        }\n        int mid = (left + right ) >> 1;\n        if (X <= mid) {\n            update(idx * 2 + 1, left, mid, X, nums);\n        } \n        if (X > mid){\n            update(idx * 2 + 2, mid + 1, right, X, nums);\n        }\n        node_list[idx].cnt = node_list[idx * 2 + 1].cnt + node_list[idx * 2 + 2].cnt;\n    }\n    \n};\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        SegTree st(nums);\n        vector<int> res;\n        for (auto& x: queries) {\n            if (x[0] == 1) {\n                if (x[1] == x[2]) res.push_back(0);\n                else if (x[1] + 1 == x[2]) res.push_back(0);\n                else res.push_back(st.query(0, 0, nums.size() - 1, x[1] + 1, x[2] - 1));\n                \n            } else if (x[0] == 2) {\n                nums[x[1]] = x[2];\n                st.update(0, 0, nums.size() - 1, x[1], nums);\n                if (x[1] > 0 ) st.update(0, 0, nums.size() - 1, x[1] - 1, nums);\n                if (x[1] < nums.size() - 1 ) st.update(0, 0, nums.size() - 1, x[1] + 1, nums);\n                \n                \n            }\n        }\n        return res;\n        \n    }\n};",
    "submit_ts": "1718508358",
    "subm_id": "539786870"
}