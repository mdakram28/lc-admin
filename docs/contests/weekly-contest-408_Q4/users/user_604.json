{
    "username": "disandrewed",
    "submission": "class Solution {\npublic:\n    struct Uf {\n        vector<int> grp, sz;\n\n        Uf(int n) {\n            grp = vector<int>(n);\n            sz = vector<int>(n, 1);\n            for (int i = 0; i < n; i++) grp[i] = i;\n        }\n\n        int Find(int a) {\n            return a == grp[a] ? a : grp[a] = Find(grp[a]);\n        }\n\n        void Union(int a, int b) {\n            a = Find(a);\n            b = Find(b);\n            if (a != b) {\n                if (sz[a] < sz[b]) {\n                    swap(a, b);\n                }\n                grp[b] = a;\n                sz[a] += sz[b];\n            }\n        }\n    };\n\n    bool intersect(vector<int>& c1, vector<int>& c2) {\n        long long x1 = c1[0], y1 = c1[1], r1 = c1[2];\n        long long x2 = c2[0], y2 = c2[1], r2 = c2[2];\n        long long distSq = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n        long long radSumSq = (r1 + r2) * (r1 + r2);\n        long long radDiffSq = (r1 - r2) * (r1 - r2);\n        return radDiffSq <= distSq && distSq <= radSumSq;\n    }\n\n    bool touches(const vector<int>& circle, int X, int Y) {\n        int x = circle[0], y = circle[1], r = circle[2];\n        return (x - r <= 0 || x + r >= X || y - r <= 0 || y + r >= Y);\n    }\n\n    bool check(const vector<vector<int>>& group, int X, int Y) {\n        unordered_set<string> edgeContacts;\n        for (const auto& circle : group) {\n            if (touches(circle, X, Y)) {\n                if (circle[0] - circle[2] <= 0) edgeContacts.insert(\"left\");\n                if (circle[0] + circle[2] >= X) edgeContacts.insert(\"right\");\n                if (circle[1] - circle[2] <= 0) edgeContacts.insert(\"bottom\");\n                if (circle[1] + circle[2] >= Y) edgeContacts.insert(\"top\");\n            }\n        }\n        \n        int cnt = 0;\n        if (edgeContacts.find(\"left\") != edgeContacts.end() || edgeContacts.find(\"top\") != edgeContacts.end()) {\n            cnt++;\n        }\n        if (edgeContacts.find(\"bottom\") != edgeContacts.end() || edgeContacts.find(\"right\") != edgeContacts.end()) {\n            cnt++;\n        }\n        \n        return cnt >= 2;\n    }\n\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n        Uf uf(n);\n\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (intersect(circles[i], circles[j])) {\n                   uf.Union(i, j);\n                }\n            }\n        }\n\n        unordered_map<int, vector<vector<int>>> groups;\n\n\n        for (int i = 0; i < n; i++) {\n            int root = uf.Find(i);\n            groups[root].push_back(circles[i]);\n        }\n\n\n        for (const auto& [root, group] : groups) {\n            if (check(group, X, Y)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n};\n",
    "submit_ts": "1722137717",
    "subm_id": "1335771666"
}