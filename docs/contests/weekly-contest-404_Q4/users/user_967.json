{
    "username": "AbhishekP01",
    "submission": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int n = edges1.length + 1;\n        int m = edges2.length + 1;\n        \n        int diameter1 = getTreeDiameter(edges1, n);\n        int diameter2 = getTreeDiameter(edges2, m);\n        \n        int radius1 = (diameter1 + 1) / 2;\n        int radius2 = (diameter2 + 1) / 2;\n        \n        return Math.max(diameter1, Math.max(diameter2, radius1 + radius2 + 1));\n    }\n    \n    private int getTreeDiameter(int[][] edges, int n) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n        \n        int[] dist = bfs(0, graph, n);\n        int farthestNode = 0;\n        for (int i = 0; i < n; i++) {\n            if (dist[i] > dist[farthestNode]) {\n                farthestNode = i;\n            }\n        }\n        \n        dist = bfs(farthestNode, graph, n);\n        int diameter = 0;\n        for (int d : dist) {\n            diameter = Math.max(diameter, d);\n        }\n        \n        return diameter;\n    }\n    \n    private int[] bfs(int start, List<List<Integer>> graph, int n) {\n        int[] dist = new int[n];\n        Arrays.fill(dist, -1);\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        dist[start] = 0;\n        \n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            for (int neighbor : graph.get(node)) {\n                if (dist[neighbor] == -1) {\n                    dist[neighbor] = dist[node] + 1;\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        \n        return dist;\n    }\n}\n",
    "submit_ts": 1719716596.0
}