{
    "username": "ks27",
    "submission": "from collections import deque\nimport math\n\nclass Solution:\n    \n    \n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        n = len(circles)\n        graph = defaultdict(list)\n        left, right, top, bottom = n, n + 2, n + 3, n + 1\n        \n        for i, (cx, cy, r) in enumerate(circles):\n            if cx - 0 <= r:\n                graph[left].append(i)\n                graph[i].append(left)\n            if X - cx <= r:\n                graph[right].append(i)\n                graph[i].append(right)\n            if cy - 0 <= r:\n                graph[bottom].append(i)\n                graph[i].append(bottom)\n            if Y - cy <= r:\n                graph[top].append(i)\n                graph[i].append(top)\n                \n            for j in range(i + 1, n):\n                cx2, cy2, r2 = circles[j]\n                distance = math.sqrt((cx - cx2) ** 2 + (cy - cy2) ** 2)\n                if r + r2 >= distance:\n                    graph[i].append(j)\n                    graph[j].append(i)\n        def bfs(start_boundary, boundary1, boundary2):\n          queue = [start_boundary]\n          visited =set()\n          visited.add(start_boundary)\n          \n          while queue:\n              root = queue.pop(0)\n              for nei in graph[root]:\n                  if nei not  in visited:\n                      queue.append(nei)\n                      visited.add(nei)\n          \n          return boundary1 in visited or boundary2 in visited\n        \n        return not (bfs(n, n + 1, n + 2) or bfs(n + 3, n + 2, n + 1))\n        ",
    "submit_ts": "1722138827",
    "subm_id": "1335800706"
}