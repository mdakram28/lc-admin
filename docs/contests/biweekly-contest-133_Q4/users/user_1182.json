{
    "username": "nimit_sharma",
    "submission": "class Solution {\npublic:\n    int mod = 1e9 + 7;\n    int numberOfPermutations(int n, vector<vector<int>>& requirements) {\n        int maxi = 406;\n        // Convert requirements into a map for easy access\n        map<int, int> m;\n        for (auto i : requirements) {\n            m[i[0] + 1] = i[1]; // Convert to 1-based index, store inversion count\n        }\n        // Initialize the DP table\n        long long dp[n + 1][maxi + 1];\n        memset(dp, 0, sizeof(dp)); // Clear the DP table\n        // Base case: one way to have 0 elements with 0 inversions\n        dp[0][0] = 1;\n        // Fill the DP table\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= maxi; j++) {\n                for (int newPos = 0; newPos < i; ++newPos) {\n                    int k = j - newPos;\n                    if (k >= 0) {\n                        dp[i][j] = (dp[i- 1][k]+dp[i][j])%mod;\n                    }\n                }\n            }\n            // Adjust DP table based on requirements\n            if (m.find(i) == m.end()){} \n            else{\n                int t = m[i];\n                for (int j = 0; j <= maxi; j++) {\n                    if (j != t) {\n                        dp[i][j] = 0;\n                        //clear the value.\n                    }\n                }\n            }\n        }\n        // Calculate the result\n        long long result = 0;\n        for (int i = 0; i <= maxi; i++) {\n            result = (dp[n][i]+result) % mod;\n        }\n        return result;\n    }\n};\n",
    "submit_ts": "1719071968",
    "subm_id": "1296858232"
}