{
    "username": "siraj_786",
    "submission": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        int length = nums.length;\n        \n        class SegmentTree {\n            private int size;\n            private int[] tree;\n\n            public SegmentTree(int size) {\n                this.size = size;\n                this.tree = new int[4 * size];\n                build(0, 0, size - 1);\n            }\n\n            private void build(int node, int start, int end) {\n                if (start == end) {\n                    tree[node] = isPeak(start, nums) ? 1 : 0;\n                } else {\n                    int mid = (start + end) / 2;\n                    int leftChild = 2 * node + 1;\n                    int rightChild = 2 * node + 2;\n                    build(leftChild, start, mid);\n                    build(rightChild, mid + 1, end);\n                    tree[node] = tree[leftChild] + tree[rightChild];\n                }\n            }\n\n            private void update(int idx, int value, int node, int start, int end) {\n                if (start == end) {\n                    tree[node] = isPeak(start, nums) ? 1 : 0;\n                } else {\n                    int mid = (start + end) / 2;\n                    int leftChild = 2 * node + 1;\n                    int rightChild = 2 * node + 2;\n                    if (start <= idx && idx <= mid) {\n                        update(idx, value, leftChild, start, mid);\n                    } else {\n                        update(idx, value, rightChild, mid + 1, end);\n                    }\n                    tree[node] = tree[leftChild] + tree[rightChild];\n                }\n            }\n\n            private int query(int left, int right, int node, int start, int end) {\n                if (right < start || left > end) {\n                    return 0;\n                }\n                if (left <= start && end <= right) {\n                    return tree[node];\n                }\n                int mid = (start + end) / 2;\n                int leftChild = 2 * node + 1;\n                int rightChild = 2 * node + 2;\n                int leftSum = query(left, right, leftChild, start, mid);\n                int rightSum = query(left, right, rightChild, mid + 1, end);\n                return leftSum + rightSum;\n            }\n        }\n        \n        SegmentTree segmentTree = new SegmentTree(length);\n\n        List<Integer> result = new ArrayList<>();\n        \n        for (int[] query : queries) {\n            if (query[0] == 1) {\n                int li = query[1];\n                int ri = query[2];\n                int peakCount = segmentTree.query(li + 1, ri - 1, 0, 0, length - 1);\n                result.add(peakCount);\n            } else if (query[0] == 2) {\n                int index = query[1];\n                int value = query[2];\n                nums[index] = value;\n                for (int i = Math.max(1, index - 1); i <= Math.min(length - 1, index + 2); i++) {\n                    segmentTree.update(i, nums[i], 0, 0, length - 1);\n                }\n            }\n        }\n        \n        return result;\n    }\n\n    private boolean isPeak(int i, int[] nums) {\n        int n = nums.length;\n        return 0 < i && i < n - 1 && nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    }\n}\n",
    "submit_ts": 1718506614.0
}