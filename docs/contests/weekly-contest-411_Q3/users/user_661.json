{
    "username": "vwv",
    "submission": "// clang-format off\nstatic const auto io_sync_off = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\n#define tT template<typename T>\n#define DA decltype(auto)\n#define FD(v) std::forward<decltype(v)>(v)\n#define DD(v) decay_t<decltype(v)>\n#define DDv(v) typename DD(v)::value_type\n#define DDm(m) typename DD(m)::mapped_type\n#define DDp(m) pair<typename DD(m)::key_type, DDm(m)>\nusing ll = long long; using S = string;\nusing pii = pair<int, int>; using pis = pair<int, S>; using psi = pair<S, int>;\ntT using V = vector<T>; tT using VV = V<V<T>>; tT using VVV = VV<V<T>>;\nusing vi = V<int>; using vvi = VV<int>; using vvvi = VVV<int>; using vb = V<bool>; using vvb = VV<bool>; using vs = V<S>; using vd = V<double>; using vli = V<list<int>>;\ntT using US = unordered_set<T>; template<typename A, typename B> using UM = unordered_map<A, B>;\nusing si = set<int>; using usi = US<int>; using uss = US<S>;\nusing mii = map<int, int>; using umii = UM<int, int>; using umib = UM<int, bool>; using umsi = UM<S, int>;\nusing pqi = priority_queue<int, vi, greater<int>>; using pqri = priority_queue<int, vi>;\nconstexpr int BIG = 1e9; constexpr int MOD = 1e9 + 7; constexpr int MAX_INT = INT_MAX; constexpr ll MAX_LL = LONG_MAX; constexpr bool fasle = false; constexpr bool ture = true;\n#define fi first\n#define se second\n#define pb push_back\n#define F(i, a, b) for(int(i) = (a); (i) < (b); ++(i))\n#define Fs(i, a, b, s) for(int(i) = (a); (i) < (b); (i) += (s))\n#define Fe(i, a, b) for(int(i) = (a); (i) <= (b); ++(i))\n#define FR(i, a, b) for(int(i) = (a); (i) >= (b); --(i))\n#define FRn(i, a, b) for(int(i) = (a); (i) > (b); --(i))\n#define FE(a, v) for(auto &&(a): (v)) // For each element in a container... Use `&&` due to `vb`.\n#define FEv(v, m) for(auto &[k, v]: (m)) // For each element in a map or unordered_map...\n#define FEt(t, s) stringstream ss(s); for(S (t); ss >> (t);) // For each token in a S...\n#define W(n) while((n)--)\n#define ALL(v) (v).begin(), (v).end()\n#define ALLR(v) (v).rbegin(), (v).rend()\ntT concept FS = requires(T t) { t.fi, t.se; }; tT concept BE = requires(T t) { ALL(t); }; tT concept FP = requires(T t) { t.front(), t.pop(); }; tT concept TP = requires(T t) { t.top(), t.pop(); };\nDA sz(const auto &v) { return v.size(); }\n#define szXY(vv) int X = sz(vv), Y = X ? sz((vv)[0]) : 0\nDA R(auto &&v) { reverse(ALL(v)); return FD(v); }\nDA SORT(auto &&v) { sort(ALL(v)); return FD(v); } DA SORTR(auto &&v) { sort(ALL(v), greater()); return FD(v); }\n#define SORTfab(v, fab) (sort(ALL(v), [&](const auto &a, const auto &b) { return (fab); }), v) // Sort elements based on a function of any 2 elements `a` and `b`.\nDA UE(auto &&v) { v.erase(unique(ALL(v)), v.end()); return FD(v); } DA SUE(auto &&v) { return UE(SORT(v)); }\nDA COUNT(const auto &v, const auto &k) { return count(ALL(v), k); }\n#define COUNTifa(v, ifa) count_if(ALL(v), [&](const auto &a) { return (ifa); }) // Count elements based on an if-condition of any elemnent `a`.\nDA findi(auto &v, const auto &k) { return find(ALL(v), k) - v.begin(); }\nDA maxe(auto &v) { return max_element(ALL(v)); } DA mine(auto &v) { return min_element(ALL(v)); } DA maxer(auto &v) { return max_element(ALLR(v)).base() - 1; } DA miner(auto &v) { return min_element(ALLR(v)).base() - 1; } DA maxv(const auto &v) { return *maxe(v); } DA minv(const auto &v) { return *mine(v); } DA maxvi(const auto &v) { return maxe(v) - v.begin(); } DA minvi(const auto &v) { return mine(v) - v.begin(); } DA maxvir(const auto &v) { return maxer(v) - v.begin(); } DA minvir(const auto &v) { return miner(v) - v.begin(); }\nDA lb(auto &v, const auto &k) { return lower_bound(ALL(v), k); } DA ub(auto &v, const auto &k) { return upper_bound(ALL(v), k); } DA lub(auto &v, const auto &k) { return pair{lb(v, k), ub(v, k)}; } DA lbi(auto &v, const auto &k) { return lower_bound(ALL(v), k) - v.begin(); } DA ubi(auto &v, const auto &k) { return upper_bound(ALL(v), k) - v.begin(); } DA lubi(auto &v, const auto &k) { return pair{lbi(v, k), ubi(v, k)}; }\nnamespace std { DA operator+(const FS auto &a, const auto &b) { return DD(a){a.fi + b.fi, a.se + b.se}; } DA operator+=(FS auto &&a, const auto &b) { a.fi += b.fi; a.se += b.se; return FD(a); } DA operator-(const FS auto &a, const auto &b) { return DD(a){a.fi - b.fi, a.se - b.se}; } DA operator-=(FS auto &&a, const auto &b) { a.fi -= b.fi; a.se -= b.se; return FD(a); } }\nnamespace std { DA operator+(const BE auto &a, const auto &b) { DD(a) c; int n = max(sz(a), sz(b)); c.reserve(n); F(i, 0, n) c.pb((i < sz(a) ? a[i] : DDv(c){}) + (i < sz(b) ? b[i] : DDv(c){})); return c; } DA operator+=(auto &&a, const auto &b) { F(i, 0, sz(a)) a[i] += i < sz(b) ? b[i] : DDv(a){}; a.reserve(sz(b)); F(i, sz(a), sz(b)) a.pb(b[i]); return FD(a); } DA operator-(const BE auto &a, const auto &b) { DD(a) c; int n = max(sz(a), sz(b)); c.reserve(n); F(i, 0, n) c.pb((i < sz(a) ? a[i] : DDv(c){}) - (i < sz(b) ? b[i] : DDv(c){})); return c; } DA operator-=(auto &&a, const auto &b) { F(i, 0, sz(a)) a[i] -= i < sz(b) ? b[i] : DDv(a){}; a.reserve(sz(b)); F(i, sz(a), sz(b)) a.pb(b[i]); return FD(a); } }\nDA SUM(const auto &v) { return accumulate(ALL(v), DDv(v){}); }\n#define SUMifa(v, ifa) accumulate(ALL(v), DDv(v){}, [&](const auto &s, const auto &a) { return s + ((ifa) ? a : DDv(v){}); }) // Sum elements based on an if-condition of any element `a`.\n#define SUMfa(v, fa) accumulate(ALL(v), DDv(v){}, [&](const auto &s, const auto &a) { return s + (fa); }) // Sum elements with a function of any element `a`.\nDA PSUM(const auto &v) { auto r = v; F(i, 1, sz(r)) r[i] += r[i - 1]; return r; } DA PSUM0(const auto &v) { DD(v) r; r.reserve(sz(r) + 1); r.pb(DDv(v){}); r.insert(r.end(), v.begin(), v.end()); F(i, 2, sz(r)) r[i] += r[i - 1]; return r; }\nDA HISTV(const auto &v, int n, int b = 0, const function<bool(int)> &if_ = [](int) { return true; }) { vi hist(n); FE(a, v) if(if_(a)) hist[a - b]++; return hist; }\n#define HISTVifa(v, n, b, ifa) HISTV((v), (n), (b), [](int a) { return (ifa); })\nDA HISTM(const auto &v) { UM<DDv(v), int> um; FE(a, v) um[a]++; return um; } DA HISTMif(const auto &v, const function<bool(const DDv(v) &)> &if_) { UM<DDv(v), int> um; FE(a, v) if(if_(a)) um[a]++; return um; }\n#define HISTMifa(v, ifa) HISTMif((v), [](const auto &a) { return (ifa); })\nDA V2S(const auto &v) { return US<DDv(v)>(ALL(v)); }\nDA Mp2V(const auto &m) { V<DDp(m)> v(sz(m)); int i = 0; FE(p, m) v[i++] = p; return v; } DA Mv2V(const auto &m) { V<DDm(m)> v(sz(m)); int i = 0; FEv(a, m) v[i++] = a; return v; }\nDA IOTA(int n, int b = 0) { vi v(n); iota(ALL(v), b); return v; } // Create a `vector<int>` with b+0, b+1, b+2, ..., b+n-1. `b` means base.\nDA BS(int a, int b, const function<bool(int)> &FirstTrue) { while(a <= b) { int m = a + (b - a) / 2; if(FirstTrue(m)) b = m - 1; else a = m + 1; } return a; }\n#define BSfm(a, b, fm) BS((a), (b), [&](int m) { return (fm); })\nDA TOKEN(const S &s) { vs v; FEt(t, s) v.pb(t); return v; }\nDA POP(FP auto &v) { auto r = v.front(); v.pop(); return r; } DA POP(TP auto &v) { auto r = v.top(); v.pop(); return r; } DA POP(BE auto &v) { auto r = *v.begin(); v.erase(r); return r; }\nDA _T(const auto &vv) { szXY(vv); DD(vv) r(X, DDv(vv)(Y)); F(y, 0, Y) F(x, 0, X) r[y][x] = vv[x][y]; return r; }\nDA _P(const auto &k) { cout << \" \" << k ; } DA _P(const S &s) { cout << \" \" << s << endl; } DA _P(const FS auto &p) { cout << \" (\"; _P(p.fi); _P(p.se); cout << \")\"; } DA _P(const BE auto &v) { cout << endl; FE(k, v) _P(k); }\nDA P(const auto &...k) { (_P(k), ...); cout << endl; }\n// clang-format on\n\n/*\nint r = 0, n = sz(v);\nreturn r;\n*/\n\n//****************************************************************************************************\n\nclass Solution {\npublic:\n    bool test(ll k) {\n        ll r = 0, b = k;\n        while(k) {\n            r = r * 10 + k % 10;\n            k /= 10;\n        }\n        return b == r;\n    }\n    string test2(int n) {\n        if(n == 1)\n            return \"8\";\n        return string(\"8\") + string(n - 2, '9') + string(\"8\");\n    }\n    string test4(int n) {\n        if(n <= 3)\n            return string(n, '8');\n        return string(\"88\") + string(n - 4, '9') + string(\"88\");\n    }\n    string test5(int n) {\n        if(n == 1)\n            return \"5\";\n        return string(\"5\") + string(n - 2, '9') + string(\"5\");\n    }\n    string test6(int n) {\n        if(n <= 2)\n            return string(n, '6');\n        if(n % 2)\n            return string(\"8\") + string(n / 2 - 1, '9') + string(\"8\") + string(n / 2 - 1, '9') + string(\"8\");\n        return string(\"8\") + string(n / 2 - 2, '9') + string(\"77\") + string(n / 2 - 2, '9') + string(\"8\");\n    }\n    bool test7(string &s) {\n        int n = sz(s), r = 0;\n        F(i, 0, n) r = (s[i] - '0' + r * 10) % 7;\n        return r == 0;\n    }\n    string test7(int n) {\n        if(n <= 2)\n            return string(n, '7');\n        string s;\n        FR(i, 9, 0) {\n            if(n % 2)\n                s = string(n / 2, '9') + string(1, '0' + i) + string(n / 2, '9');\n            else\n                s = string(n / 2 - 1, '9') + string(2, '0' + i) + string(n / 2 - 1, '9');\n            if(test7(s))\n                break;\n        }\n        test7(s);\n        return s;\n    }\n    string test8(int n) {\n        if(n <= 5)\n            return string(n, '8');\n        return string(\"888\") + string(n - 6, '9') + string(\"888\");\n    }\n    string largestPalindrome(int n, int k) {\n        // V<ll> v = {0};\n        // for(ll i = 0; i < 100000000; i++) {\n        //     ll p = i * 8;\n        //     if(test(p)) {\n        //         // P(p);\n        //         if(to_string(p).size() == to_string(v.back()).size()) {\n        //             v.back() = p;\n        //         } else {\n        //             v.pb(p);\n        //         }\n        //     }\n        // }\n        // P(v);\n        switch(k) {\n            case 1:\n                return string(n, '9');\n            case 2:\n                return test2(n);\n            case 3:\n                return string(n, '9');\n            case 4:\n                return test4(n);\n            case 5:\n                return test5(n);\n            case 6:\n                return test6(n);\n            case 7:\n                return test7(n);\n            case 8:\n                return test8(n);\n            case 9:\n                return string(n, '9');\n        }\n        return \"\";\n    }\n};\n",
    "submit_ts": "1723952746",
    "subm_id": "1359803669"
}