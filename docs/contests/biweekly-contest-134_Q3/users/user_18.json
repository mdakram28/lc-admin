{
    "username": "424479543",
    "submission": "#include <bits/stdc++.h>\n#include <unistd.h>\n#ifdef _LOCAL_\n#define debug(args...) print(\"[line:\", __LINE__, \":\" #args \"]\", ##args)\n#else\n#define debug(...) void(0)\n#endif\n#define all(a) a.begin(), a.end()\nusing namespace std;using llong = long long;\n#define to(container, a) [](auto &&A) { return container(all(A)); }(a)\nstruct range { struct Iterator { using iterator_category = std::random_access_iterator_tag; using value_type = llong; using difference_type = ptrdiff_t; using pointer = llong; using reference = llong &; llong val, d; Iterator(){}; Iterator(llong val, llong d) : val(val), d(d){}; value_type operator*() const { return val; } Iterator &operator++() { return val += d, *this; } difference_type operator-(const Iterator &other) const { return (val - other.val) / d; } bool operator==(const Iterator &other) const { return val == other.val; } }; Iterator Begin, End; range(llong n) : Begin(0, 1), End(max(n, llong{0}), 1){}; range(llong a, llong b, llong d = llong(1)) : Begin(a, d), End(b, d) { llong cnt = b == a or (b - a > 0) != (d > 0) ? 0 : (b - a) / d + bool((b - a) % d); End.val = a + max(cnt, llong(0)) * d; }; Iterator begin() const { return Begin; } Iterator end() const { return End; }; operator vector<Iterator::value_type>() { return vector(begin(), end()); }}; //\ninline bool cmax(auto &x, auto &&y) { if (x < y) { x = y; return true; } return false;}inline bool cmin(auto &x, auto &&y) { if (x > y) { x = y; return true; } return false;}template <typename... Args>llong pow(llong x, auto b, auto MOD) { if (b < 0) x = pow(x, MOD - 2, MOD), b = -b; if (not x) return x; llong res = 1; for (; b; (x *= x) %= MOD, b >>= 1) if (b & 1) (res *= x) %= MOD; return res;} //\ntemplate <typename T>T sum(auto &&a, T res) { for (auto x : a) res += x; return res;} //\ntemplate <typename T>llong sum(T &&a) { return sum(forward<T>(a), 0ll); } //\ntemplate <typename T>T reversed(T a) { ranges::reverse(a); return a;} //\ntemplate <typename T>T uniqued(T a) { ranges::sort(a); a.resize(unique(begin(a), end(a)) - begin(a)); return a;} //\ntemplate <typename... Args>auto sorted(auto a, Args &&...args) { sort(begin(a), end(a), args...); return a;} //\ntemplate <typename T>T transposed(T a) { if (a.empty()) return a; int m = a.size(), n = a[0].size(); T b(n); for (int j : range(n)) { b[j].resize(m); for (int i : range(m)) b[j][i] = a[i][j]; } return b;} //\ntemplate <typename T>vector<T> &operator+=(vector<T> &a, const vector<T> &b) { a.insert(end(a), begin(b), end(b)); return a;};template <typename T>vector<T> operator+(vector<T> a, const vector<T> &b) { return a += b; }; //\ntemplate <typename T>vector<T> &operator*=(vector<T> &a, int k) { if (k <= 0) a.clear(); else { assert(a.size() * k < INT_MAX); int N = a.size() * k; a.reserve(N); while (a.size() * 2 <= N) a += a; a.insert(end(a), begin(a), begin(a) + (N - a.size())); } return a;};template <typename T>vector<T> operator*(vector<T> a, int k) { return a *= k; }; //\ntemplate <typename RET>auto make_vector(RET x) { return x; }template <typename T1, typename T2, typename... Args>auto make_vector(T1 m, T2 n, Args... arg) { return vector(m, make_vector(n, arg...)); }//\n/* io */ template <typename T> concept INT = sizeof(T) >= 2 and is_integral_v<T>; template <INT T = llong> T _rd(){ T a=1,b=0;char c=getchar(); while(c<'0'||c>'9'){if(c=='-') a=-1;c=getchar();} while(c>='0'&&c<='9'){b=(b<<1)+(b<<3)+c-'0';c=getchar();} return a*b; }  void _print(INT auto x,char ch = '\\n'){ if(x < 0) putchar('-'),x=-x; if(x>9) _print(x/10,0); putchar(x%10+'0'); if(ch) putchar(ch); } \n/* print */ template <typename Tuple, typename F, size_t... N>void TupleCall(Tuple &t, F &&f, std::index_sequence<N...>) { (f(get<N>(t)), ...); }template <typename... Args>std::ostream &operator<<(std::ostream &out, const std::tuple<Args...> &t) { TupleCall(t, [&](auto &&a) { out << a << ' '; }, make_index_sequence<sizeof...(Args)>{}); return out;}template <typename T1, typename T2>std::ostream &operator<<(std::ostream &out, const std::pair<T1, T2> &t) { return out << t.first << ' ' << t.second; }template <typename T>std::ostream &operator<<(std::ostream &out, const std::vector<T> &v) { for (size_t i = 0, n = v.size(); i < n; ++i) out << v[i] << ' '; return out;}template <typename T, typename... Args>void print(const T &t, const Args &...args) { cout << t; if constexpr (sizeof...(args)) { cout << ' '; print(args...); } else { cout << endl; }} //\nauto io = [](){return cin.tie(nullptr) -> sync_with_stdio(false);}();\n// ##########################################################################################\nclass Solution {\npublic:\n    int numberOfAlternatingGroups(vector<int>& nums, int k) {\n        int n = nums.size();\n        nums += nums;\n        vector<int> s(2*n);\n        for(int i :  range(1,2*n)) s[i] = (nums[i] != nums[i-1]) + s[i-1];\n        int res = 0;\n        debug(s);\n        for(int i : range(n)){\n            res += s[i+k-1] - s[i] == k - 1;\n        }\n        return res;\n        \n    }\n};\n\n\n// ##########################################################################################\n#ifdef OY_LOCAL\n#include \"./other/FastIO.h\"\n#include \"./other/LeetcodeIO.h\"\nint main() {\n    REGISTER_CONSTRUCTOR_SOLUTION;                             // \u672c\u884c\u586b\u5199\u7c7b\u540d\u3001\u6784\u9020\u51fd\u6570\u7684\u6240\u6709\u53c2\u6570\u7c7b\n    REGISTER_MEMBERFUNCTION_SOLUTION(numberOfAlternatingGroups); // \u672c\u884c\u586b\u5199\u7c7b\u540d\u3001\u8981\u8c03\u7528\u7684\u6210\u5458\u65b9\u6cd5\u540d\n    while (true) {\n        executor.constructSolution();\n        executor.executeSolution();\n    }\n}\n#endif ",
    "submit_ts": "1720276540",
    "subm_id": "544550784"
}