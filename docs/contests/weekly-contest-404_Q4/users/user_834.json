{
    "username": "haochenkang",
    "submission": "class Solution {\npublic:\n    void dfs(int u, unordered_map<int, vector<int>> &edges, unordered_set<int> &visited, unordered_map<int, int> &dist){\n        visited.insert(u);\n        for(auto v : edges[u]){\n            if(!visited.count(v)){\n                dist[v] = dist[u] + 1;\n                dfs(v, edges, visited, dist);\n            }\n        }\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        // res is at least max of diameter of tree 1 and diameter of tree 2\n        // res is at least the minimum of all possible ways to connect \n        unordered_map<int, vector<int>> mp1, mp2;\n        for(int i = 0; i < edges1.size(); i++){\n            mp1[edges1[i][0]].push_back(edges1[i][1]);\n            mp1[edges1[i][1]].push_back(edges1[i][0]);\n        }\n        for(int i = 0; i < edges2.size(); i++){\n            mp2[edges2[i][0]].push_back(edges2[i][1]);\n            mp2[edges2[i][1]].push_back(edges2[i][0]);\n        }\n        unordered_set<int> visited1, visited2;\n        unordered_map<int, int> dist1, dist2;\n        dist1[0] = 0;\n        dfs(0, mp1, visited1, dist1);\n        int best = 0, farthest_node = 0;\n        for(auto i : dist1){\n            if(i.second > best){\n                best = i.second;\n                farthest_node = i.first;\n            }\n        }\n        unordered_map<int, int> dist1_second;\n        unordered_set<int> visited1_second;\n        dist1_second[farthest_node] = 0;\n        dfs(farthest_node, mp1, visited1_second, dist1_second);\n        best = 0;\n        for(auto i : dist1_second){\n            if(i.second > best){\n                best = i.second;\n            }\n        }\n        int diameter1 = best;\n        \n        \n        dist2[0] = 0;\n        dfs(0, mp2, visited2, dist2);\n        best = 0, farthest_node = 0;\n        for(auto i : dist2){\n            if(i.second > best){\n                best = i.second;\n                farthest_node = i.first;\n            }\n        }\n        unordered_map<int, int> dist2_second;\n        unordered_set<int> visited2_second;\n        dist2[farthest_node] = 0;\n        dfs(farthest_node, mp2, visited2_second, dist2_second);\n        best = 0;\n        for(auto i : dist2_second){\n            if(i.second > best){\n                best = i.second;\n            }\n        }\n        int diameter2 = best;\n        \n        int res = (diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1;\n        res = max({res, diameter1, diameter2});\n        return res;\n        \n    }\n};",
    "submit_ts": 1719719362.0
}