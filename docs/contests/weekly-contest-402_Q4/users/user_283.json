{
    "username": "dirigibility",
    "submission": "class SegmentTree:\n\tdef __init__(self, op, data):\n\t\tself.op = op\n\t\tself.size = len(data)\n\t\tself.tree = [None]*(2*self.size-1)\n\t\tself.build(0, 0, self.size-1, data)\n\n\tdef build(self, node, i, j, data):\n\t\tif i == j:\n\t\t\tself.tree[node] = data[i]\n\t\telse:\n\t\t\tmid = (i+j)//2\n\t\t\tlnode = node+1\n\t\t\trnode = node+2*(mid+1-i)\n\t\t\tl = self.build(lnode, i, mid, data)\n\t\t\tr = self.build(rnode, mid+1, j, data)\n\t\t\tself.tree[node] = self.op(l, r)\n\t\treturn self.tree[node]\n\n\t# st[i:j] = data[i] op ... op data[j-1]\n\t# st[i] = data[i]\n\tdef __getitem__(self, key):\n\t\tif isinstance(key, slice):\n\t\t\tqi = 0 if key.start is None else key.start\n\t\t\tqj = self.size-1 if key.stop is None else key.stop-1\n\t\telse:\n\t\t\tqi = qj = key\n\t\treturn self.reduce(qi, qj)\n\n\t# data[max(i,qi)] op ... op data[min(j,qj)]\n\t# assuming that node is correctly computed for the given i,j\n\tdef reduce(self, qi=0, qj=None, node=0, i=0, j=None):\n\t\tif qj is None:\n\t\t\tqj = self.size-1\n\t\tif j is None:\n\t\t\tj = self.size-1\n\t\tif qi <= i and qj >= j:\n\t\t\treturn self.tree[node]\n\t\tmid = (i+j)//2\n\t\tlnode = node+1\n\t\trnode = node+2*(mid+1-i)\n\t\tif qj <= mid:\n\t\t\treturn self.reduce(qi, qj, lnode, i, mid)\n\t\tif qi >= mid+1:\n\t\t\treturn self.reduce(qi, qj, rnode, mid+1, j)\n\t\tl = self.reduce(qi, qj, lnode, i, mid)\n\t\tr = self.reduce(qi, qj, rnode, mid+1, j)\n\t\treturn self.op(l, r)\n\n\t# sets data[k] = v (does not support slices)\n\tdef __setitem__(self, k, v):\n\t\tself.set(k, v, 0, 0, self.size-1)\n\t\t\n\tdef set(self, k, v, node, i, j):\n\t\tif i == j:\n\t\t\tself.tree[node] = v\n\t\telse:\n\t\t\tmid = (i+j)//2\n\t\t\tlnode = node+1\n\t\t\trnode = node+2*(mid+1-i)\n\t\t\tif k <= mid:\n\t\t\t\tl = self.set(k, v, lnode, i, mid)\n\t\t\t\tr = self.tree[rnode]\n\t\t\telse:\n\t\t\t\tl = self.tree[lnode]\n\t\t\t\tr = self.set(k, v, rnode, mid+1, j)\n\t\t\tself.tree[node] = self.op(l, r)\n\t\treturn self.tree[node]\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        def peak(i):\n            return int(0 < i < len(nums)-1 and nums[i] > nums[i-1] and nums[i] > nums[i+1])\n        st = SegmentTree(add,[peak(i) for i,n in enumerate(nums)])\n        answer = []\n        for q in queries:\n            if q[0] == 1:\n                l,r = q[1:]\n                if r-l > 1:\n                    answer.append(st.reduce(l,r)-st[l]-st[r])\n                else:\n                    answer.append(0)\n            else:\n                i,v = q[1:]\n                nums[i] = v\n                for j in range(max(0,i-1),min(len(nums),i+2)):\n                    st[j] = peak(j)\n        return answer\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ",
    "submit_ts": "1718506742",
    "subm_id": "1289629502"
}