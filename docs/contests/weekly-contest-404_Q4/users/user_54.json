{
    "username": "2499370956",
    "submission": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int d1 = diameter(edges1.length + 1, edges1);\n        int d2 = diameter(edges2.length + 1, edges2);\n        return Arrays.asList(\n                Math.ceilDiv(d1, 2) + Math.ceilDiv(d2, 2) + 1,\n                d1,\n                d2\n        ).stream().max(Comparator.naturalOrder()).get();\n    }\n\n    private int diameter(int n, int[][] g) {\n        Map<Integer, List<Integer>> edges = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            edges.put(i, new ArrayList<>());\n        }\n        for (int[] e : g) {\n            edges.get(e[0]).add(e[1]);\n            edges.get(e[1]).add(e[0]);\n        }\n        int[] d0 = bfs(n, 0, edges);\n        int maxIndex = 0;\n        int maxDistance = 0;\n        for (int i = 1; i < n; i++) {\n            if (d0[i] > maxDistance) {\n                maxDistance = d0[i];\n                maxIndex = i;\n            }\n        }\n        int[] dmax = bfs(n, maxIndex, edges);\n        return Arrays.stream(dmax).max().getAsInt();\n    }\n\n    private int[] bfs(int n, int start, Map<Integer, List<Integer>> E) {\n        int[] distance = new int[n];\n        Arrays.fill(distance, -1);\n        distance[start] = 0;\n        Queue<Integer> q = new LinkedList<>();\n        q.add(start);\n        while (!q.isEmpty()) {\n            int v = q.remove();\n            int d = distance[v];\n            for (int v2 : E.get(v)) {\n                if (distance[v2] == -1) {\n                    distance[v2] = d + 1;\n                    q.add(v2);\n                }\n            }\n        }\n        return distance;\n    }\n}",
    "submit_ts": 1719716522.0
}