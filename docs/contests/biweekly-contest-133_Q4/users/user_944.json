{
    "username": "gameboey",
    "submission": "// Macros for loop indices\n#define REP(i, a, b) for (int i = (a); i <= (b); ++i)\n#define REPN(i, a, b) for (int i = (a); i < (b); ++i)\n#define REPR(i, a, b) for (int i = (a); i >= (b); --i)\n\n// Macros for minimum and maximum\n#define INF 0x3f3f3f3f\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\n// Macro to iterate over elements of a container with index\n#define FOR_INDEX(i, container) for (int i = 0; i < container.size(); ++i)\n#define FOR_INDEX_R(i, container) for (int i = container.size() - 1; i >= 0; --i)\n\n#define ll long long\n#define vvi vector<vector<int>>\n#define vvl vector<vector<ll>>\n#define vi vector<int>\n#define umi unordered_map<int, int>\n#define ll long long\n#define vvi vector<vector<int>>\n#define vvl vector<vector<ll>>\n#define vi vector<int>\n#define umi unordered_map<int, int>\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define FORR2(x,y,arr) for(auto& [x,y]:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n\n\n\n// Macro to check if a number is even or odd\n#define IS_EVEN(x) ((x) % 2 == 0)\n#define IS_ODD(x) ((x) % 2 != 0)\n\n// Macro for debugging output\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\n\n\nconst int MOD = 1e9 + 7, inv = 400;\nclass Solution {\npublic:\n    int numberOfPermutations(int n, vvi& requirements) {\n        vvl dp(n + 1, vector<ll>(inv + 1, 0));\n        dp[0][0] = 1;\n        umi mp;\n        for (auto& req : requirements) {\n            mp[req[0]] = req[1];\n        }\n        \n        helper(dp, n, mp);\n        ll res = 0;\n        for (int i = 0; i <= inv; ++i) {\n            res += dp[n][i];\n            res %= MOD;\n        }\n        \n        return static_cast<int>(res);\n    }\n\nprivate:\n    void helper(vvl& dp, int n, umi& mp) {\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j <= inv; ++j) {\n                for (int k = 0; k < i; ++k) {\n                    int prev = j - k;\n                    if (prev >= 0) {\n                        dp[i][j] = (dp[i][j] + dp[i - 1][prev]) % MOD;\n                    }\n                }\n            }\n\n            reqq(dp, i, mp);\n        }\n    }\n\n    void reqq(vvl& dp, int i, umi& mp) {\n        if (mp.count(i - 1)) {\n            int target = mp[i - 1];\n            for (int j = 0; j <= inv; ++j) {\n                if (j != target) {\n                    dp[i][j] = 0;\n                }\n            }\n        }\n    }\n};\n",
    "submit_ts": 1719071615.0
}