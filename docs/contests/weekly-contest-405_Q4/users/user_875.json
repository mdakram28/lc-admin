{
    "username": "Naman_21112001",
    "submission": "class TrieNode {\npublic:\n    vector<pair<int, int>> possibles;\n    map<char, TrieNode*> childs;\n    \n};\n\nclass Trie {\npublic:\n    TrieNode* root;\n    // root to other sub shilds\n    Trie() {\n        root = new TrieNode();\n    }\n\n    bool cmp(int &a , int &b){\n        return a>b;\n    }\n    bool cmpstrings(string &a , string &b){\n        return a>b;\n    }\n\n    void insert(string word, int i, int cst) {\n        TrieNode* node = root;\n        for (char ch : word) {\n\n            if (!node->childs.count(ch))node->childs[ch] = new TrieNode();\n            \n            node=node->childs[ch];\n        }\n        node->possibles.push_back({i, cst});\n        return ;\n    }\n};\n\nclass Solution {\npublic:\n    // int mincost = INT_MAX;\n    // void solve(string &target , map<string,int> &mp , int i ,int cost ){\n    //     int n = target.length();\n    //     if(i == n){\n    //         mincost = min(mincost , cost);\n    //         return;\n    //     }\n\n    //     for(int j = i ; j<n ; j++){\n    //         string sub = target.substr(i,j-i+1);\n    //         if(mp.find(sub) != mp.end()){\n    //             cost += mp[sub];\n    //             solve(target,mp, i+1,cost);\n    //         }\n    //     }\n\n    // }\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        \n        \n        vector<int> dp(target.size() + 1, INT_MAX);\n        dp[0] = 0;\n        int n = target.size();\n        \n        Trie trie;\n        bool flag = true;\n        for (int i = 0; i < words.size(); ++i) trie.insert(words[i], i, costs[i]);\n        bool always = true;\n\n        //  cmp(trie nodea , child nodeb)\n\n        // if(always){\n        //             flag = true;\n        //         }\n\n        for (int i = 0; i < n; ++i) {\n            if (dp[i] == INT_MAX)continue;\n\n            TrieNode* Node = trie.root;\n            flag = false;\n            for (int j = i ; j < n; j++) \n            {\n                if (!Node->childs.count(target[j])) {\n                    break;\n                }\n                if(always){\n                    flag = true;\n                }\n                Node = Node->childs[target[j]];\n                for (auto &child : Node->possibles) {\n                    int l = words[child.first].size();\n                    if (n >= i+ l && always) {\n                        flag = false;\n                        dp[i+l] = min(dp[i+l] , child.second + dp[i]);\n                    }\n                }\n            }\n        }\n\n        // if(i == n){\n    //         mincost = min(mincost , cost);\n    //         return mincost;\n    //     }\n\n        int mincost = dp[n];\n        return mincost == INT_MAX? -1 : dp[n];\n    }\n};",
    "submit_ts": "1720323009",
    "subm_id": "1312364984"
}