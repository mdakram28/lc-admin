{
    "username": "neon772",
    "submission": "class Solution {\nprivate:\n    struct Graph {\n        vector<vector<int>> edges;\n        int circleCount;\n\n        Graph(int count) : circleCount(count), edges(count + 4) {}\n\n        void addEdge(int u, int v) {\n            edges[u].push_back(v);\n            edges[v].push_back(u);\n        }\n\n        bool isPathBlocked() {\n            return checkConnectivity(circleCount, circleCount + 1, circleCount + 2) ||\n                   checkConnectivity(circleCount + 3, circleCount + 2, circleCount + 1);\n        }\n\n    private:\n        bool checkConnectivity(int start, int end1, int end2) {\n            vector<bool> visited(edges.size());\n            queue<int> q;\n            q.push(start);\n            visited[start] = true;\n\n            while (!q.empty()) {\n                int current = q.front();\n                q.pop();\n\n                for (int neighbor : edges[current]) {\n                    if (!visited[neighbor]) {\n                        if (neighbor == end1 || neighbor == end2) return true;\n                        visited[neighbor] = true;\n                        q.push(neighbor);\n                    }\n                }\n            }\n            return false;\n        }\n    };\n\n    bool doCirclesOverlap(const vector<int>& c1, const vector<int>& c2) {\n        long long dx = c1[0] - c2[0], dy = c1[1] - c2[1];\n        long long distanceSquared = dx * dx + dy * dy;\n        long long radiusSum = c1[2] + c2[2];\n        return distanceSquared <= (long long)radiusSum * radiusSum;\n    }\n\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n        Graph graph(n);\n        for (int i = 0; i < n; ++i) {\n            if (circles[i][0] <= circles[i][2]) graph.addEdge(i, n);\n            if (X - circles[i][0] <= circles[i][2]) graph.addEdge(i, n + 2);\n            if (circles[i][1] <= circles[i][2]) graph.addEdge(i, n + 1);\n            if (Y - circles[i][1] <= circles[i][2]) graph.addEdge(i, n + 3);\n\n            for (int j = i + 1; j < n; ++j) {\n                if (doCirclesOverlap(circles[i], circles[j])) {\n                    graph.addEdge(i, j);\n                }\n            }\n        }\n        return !graph.isPathBlocked();\n    }\n};",
    "submit_ts": "1722138417",
    "subm_id": "1335790215"
}