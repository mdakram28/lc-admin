{
    "username": "STARs_56789",
    "submission": "#ifndef LOCAL\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\n\nnamespace mitsuha{\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &A) {\n    os << A.first << \" \" << A.second;\n    return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &A) {\n    for (size_t i = 0; i < A.size(); i++) {\n        if (i) os << \" \";\n        os << A[i];\n    }\n    return os;\n}\n\nvoid print() {\n    std::cout << \"\\n\";\n    std::cout.flush();\n}\n\ntemplate <class Head, class... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n    std::cout << head;\n    if (sizeof...(Tail)) std::cout << \" \";\n    print(std::forward<Tail>(tail)...);\n}\n}\n\nnamespace mitsuha {\ntemplate <class T> bool chmin(T& x, const T& y) { \n    return y >= x ? false : (x = y, true); \n}\ntemplate <class T> bool chmax(T& x, const T& y) { \n    return y <= x ? false : (x = y, true); \n}\ntemplate <class T> constexpr T fld(const T x, const T y) { \n    T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); \n}\ntemplate <class T> constexpr T cld(const T x, const T y) { \n    T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); \n}\ntemplate <class T> constexpr T rem(const T x, const T y) { \n    return x - y * fld(x, y); \n}\ntemplate <class Iterable> void settify(Iterable& a) { \n    std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); \n}\ntemplate <size_t D> struct Dim : std::array<int, D> {\n    template <typename ...Ints> Dim(const Ints& ...ns) : \n        std::array<int, D>::array{ static_cast<int>(ns)... } {}\n};\ntemplate <typename ...Ints> Dim(const Ints& ...) -> Dim<sizeof...(Ints)>;\ntemplate <class T, size_t D, size_t I = 0>\nauto ndvec(const Dim<D> &ns, const T& value = {}) {\n    if constexpr (I + 1 < D) {\n        return std::vector(ns[I], ndvec<T, D, I + 1>(ns, value));\n    } else {\n        return std::vector<T>(ns[I], value);\n    }\n}\n}\n\nnamespace mitsuha {\nusing str = std::string;\nusing int128 = __int128;\nusing uint128 = unsigned __int128;\ntemplate <class T> using min_priority_queue \n                            = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T> using max_priority_queue \n                            = std::priority_queue<T, std::vector<T>, std::less<T>>;\n}\nnamespace mitsuha { \n    const std::vector<std::string> Yes = {\"No\", \"Yes\"};\n    const std::vector<std::string> YES = {\"NO\", \"YES\"};\n}\n \n#ifndef __COUNTER__\n#define __COUNTER__ __LINE__\n#endif\n\n#define TL (long long)\n \n#define OVERLOAD5(a, b, c, d, e, ...) e\n#define REP1_0(b, c) REP1_1(b, c)\n#define REP1_1(b, c) for (long long REP_COUNTER_##c = 0; REP_COUNTER_##c < TL(b); ++REP_COUNTER_##c)\n#define REP1(b) REP1_0(b, __COUNTER__)\n#define REP2(i, b) for (long long i = 0; i < TL(b); ++i)\n#define REP3(i, a, b) for (long long i = TL(a); i < TL(b); ++i)\n#define REP4(i, a, b, c) for (long long i = TL(a); i < TL(b); i += TL(c))\n#define For(...) OVERLOAD5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)\n#define RREP2(i, a) for (long long i = TL(a)-1; i >= 0; --i)\n#define RREP3(i, a, b) for (long long i = TL(b)-1; i >= TL(a); --i)\n#define RREP4(i, a, b, c) for (long long i = TL(b)-1; i >= TL(a); i -= TL(c))\n#define Frr(...) OVERLOAD5(__VA_ARGS__, RREP4, RREP3, RREP2)(__VA_ARGS__)\n\n#define All(iterable) std::begin(iterable), std::end(iterable)\n#define len(iterable) TL iterable.size()\n#define elif else if\n\n#define KBIT(a, k) (a & (1ULL << k))\n\n#define Assert(x) void(0);\n\nusing namespace mitsuha;\nusing namespace std;\n \nconstexpr int iinf = std::numeric_limits<int>::max() / 2;\nconstexpr long long linf = std::numeric_limits<long long>::max() / 2;\n\nnamespace mitsuha{\nunsigned long long RNG_64() {\n    static uint64_t x_\n            = uint64_t(chrono::duration_cast<chrono::nanoseconds>(\n                    chrono::high_resolution_clock::now().time_since_epoch())\n                               .count())\n              * 10150724397891781847ULL;\n    x_ ^= x_ << 7;\n    return x_ ^= x_ >> 9;\n}\n\nunsigned long long RNG(unsigned long long lim) { return RNG_64() % lim; }\n\nlong long RNG(long long l, long long r) { return l + RNG_64() % (r - l); }\n} // namespace mitsuha\n\nnamespace mitsuha{\nstruct modint61 {\n    static constexpr unsigned long long mod = (1ULL << 61) - 1;\n    unsigned long long val;\n    constexpr modint61() : val(0ULL) {}\n    constexpr modint61(unsigned int x) : val(x) {}\n    constexpr modint61(unsigned long long x) : val(x % mod) {}\n    constexpr modint61(int x) : val((x < 0) ? (x + static_cast<long long>(mod)) : x) {}\n    constexpr modint61(long long x) : val(((x %= static_cast<long long>(mod)) < 0) ? (x + static_cast<long long>(mod)): x) {}\n    static constexpr unsigned long long get_mod() { return mod; }\n    modint61 &operator+=(const modint61 &a) {\n        val = ((val += a.val) >= mod) ? (val - mod) : val;\n        return *this;\n    }\n    modint61 &operator-=(const modint61 &a) {\n        val = ((val -= a.val) >= mod) ? (val + mod) : val;\n        return *this;\n    }\n    modint61 &operator*=(const modint61 &a) {\n        const unsigned __int128 y = static_cast<unsigned __int128>(val) * a.val;\n        val = (y >> 61) + (y & mod);\n        val = (val >= mod) ? (val - mod) : val;\n        return *this;\n    }\n    modint61 operator-() const { return modint61(val ? mod - val : 0ULL); }\n    modint61 &operator/=(const modint61 &a) { return (*this *= a.inverse()); }\n    modint61 operator+(const modint61 &p) const { return modint61(*this) += p; }\n    modint61 operator-(const modint61 &p) const { return modint61(*this) -= p; }\n    modint61 operator*(const modint61 &p) const { return modint61(*this) *= p; }\n    bool operator<(const modint61 &p) const { return val < p.val; }\n    modint61 operator/(const modint61 &p) const { return modint61(*this) /= p; }\n    bool operator==(const modint61 &p) const { return val == p.val; }\n    bool operator!=(const modint61 &p) const { return val != p.val; }\n    modint61 inverse() const {\n        long long a = val, b = mod, u = 1, v = 0, t;\n        while (b > 0) {\n            t = a / b;\n            swap(a -= t * b, b), swap(u -= t * v, v);\n        }\n        return modint61(u);\n    }\n    modint61 pow(long long n) const {\n        assert(n >= 0);\n        modint61 ret(1), mul(val);\n        while (n > 0) {\n            if (n & 1) ret *= mul;\n            mul *= mul, n >>= 1;\n        }\n        return ret;\n    }\n};\n\n#ifdef FASTIO\nvoid rd(modint61 &number){\n    io::rd(number.val);\n}\nvoid wt(const modint61 &number){\n    io::wt(number.val);\n}\n#endif\nostream &operator<<(ostream &out, const modint61 &number){ return out << number.val; }\n} // namespace mitsuha\n\nnamespace mitsuha{\nstruct RollingHash {\n    using mint = modint61;\n    static constexpr unsigned long long mod = mint::get_mod();\n    const mint base;\n    vector<mint> power;\n\n    static inline mint generate_base() { return RNG(mod); }\n\n    inline void expand(size_t sz) {\n        if (power.size() < sz + 1) {\n            int pre_sz = (int)power.size();\n            power.resize(sz + 1);\n            for(int i = pre_sz - 1; i < sz; ++i) power[i + 1] = power[i] * base;\n        }\n    }\n\n    explicit RollingHash(mint base = generate_base()) : base(base), power{1} {}\n\n    template <typename STRING>\n    vector<mint> build(const STRING& s) const {\n        int sz = s.size();\n        vector<mint> hashed(sz + 1, mint(0));\n        for (int i = 0; i < sz; i++) { hashed[i + 1] = hashed[i] * base + s[i]; }\n        return hashed;\n    }\n\n    template <typename STRING>\n    mint eval(STRING& s) {\n        mint x = 0;\n        for (auto& ch: s) x = base * x + ch;\n        return x;\n    }\n\n    mint query(const vector<mint>& s, int l, int r) {\n        expand(r - l);\n        return (s[r] - s[l] * power[r - l]);\n    }\n\n    mint combine(mint h1, mint h2, int h2len) {\n        expand(h2len);\n        return h1 * power[h2len] + h2;\n    }\n\n    mint add_char(mint h, int x) { return h * base + mint(x); }\n\n    int lcp(const vector<mint>& a, int l1, int r1, const vector<mint>& b, int l2, int r2) {\n        int len = min(r1 - l1, r2 - l2);\n        int low = 0, high = len + 1;\n        while (high - low > 1) {\n            int mid = (low + high) / 2;\n            if (query(a, l1, l1 + mid) == query(b, l2, l2 + mid))\n                low = mid;\n            else\n                high = mid;\n        }\n        return low;\n    }\n};\n} // namespace mitsuha\n\nnamespace mitsuha{\n    template <typename ...Constraints> using constraints_t = std::enable_if_t<std::conjunction_v<Constraints...>, std::nullptr_t>;\n    template <typename ReturnType, typename Callable, typename ...Args>\n    using is_same_as_invoke_result = std::is_same<std::invoke_result_t<Callable, Args...>, ReturnType>;\n}\n\nnamespace mitsuha{\ntemplate <typename T, typename UpdateFunc, constraints_t<std::is_invocable<UpdateFunc>> = nullptr>\nstruct UpdateProxyObject {\npublic:\n    UpdateProxyObject(T &v, UpdateFunc update) : v(v), update(update) {}\n    operator T() const { return v; }\n    auto& operator++() && { ++v, update(); return *this; }\n    auto& operator--() && { --v, update(); return *this; }\n    auto& operator+=(const T &val) && { v += val, update(); return *this; }\n    auto& operator-=(const T &val) && { v -= val, update(); return *this; }\n    auto& operator*=(const T &val) && { v *= val, update(); return *this; }\n    auto& operator/=(const T &val) && { v /= val, update(); return *this; }\n    auto& operator%=(const T &val) && { v %= val, update(); return *this; }\n    auto& operator =(const T &val) && { v  = val, update(); return *this; }\n    auto& operator<<=(const T &val) && { v <<= val, update(); return *this; }\n    auto& operator>>=(const T &val) && { v >>= val, update(); return *this; }\n    template <typename F, constraints_t<is_same_as_invoke_result<T, F, T>> = nullptr>\n    auto& apply(F f) && { v = f(v), update(); return *this; }\nprivate:\n    T &v;       \n    UpdateFunc update;\n};\n} // namespace mitsuha\n\nnamespace mitsuha{\ntemplate <class Monoid>\nstruct SegTree {\n    using MX = Monoid;\n    using T = typename MX::value_type;\n    int n, m;\n    \n    SegTree() : SegTree(0) {}\n    SegTree(int n) { build(n, [](int){ return MX::unit(); }); }\n    template<class F> SegTree(int n, const F &f) { build(n, f); }\n    SegTree(const std::vector<T> &a) {\n        build(a.size(), [&](int i){ return a[i]; });\n    }\n\n    void build(int n) {\n        build(n, [](int) -> T { return MX::unit(); });\n    }\n    void build(const vector<T>& v) {\n        build(v.size(), [&](int i) -> T { return v[i]; });\n    }\n    template<class F>\n    void build(int _n, const F &f) {\n        n = _n, m = ceil_pow2(_n);\n        data.assign(m << 1, MX::unit());\n        for (int i = 0; i < n; ++i) data[i + m] = f(i);\n        for (int k = m - 1; k > 0; --k) update(k);\n    }\n    const T& get(int i) const {\n        assert(0 <= i and i < n);\n        return data[i + m];\n    }\n    T operator()(int l, int r) const {\n        assert(0 <= l && l <= r && r <= n);\n        T res_l = MX::unit(), res_r = MX::unit();\n        for (l += m, r += m; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) res_l = MX::op(res_l, data[l++]);\n            if (r & 1) res_r = MX::op(data[--r], res_r);\n        }\n        return MX::op(res_l, res_r);\n    }\n    T prod(int l, int r) const { return (*this)(l, r); }\n    T prod_left(int r) const { return (*this)(0, r); }\n    T prod_right(int l) const { return (*this)(l, m); }\n    T prod_all() const { return data[1]; }\n\n    void multiply(int i, const T &x) {\n        assert(i < n);\n        i += m;\n        data[i] = MX::op(data[i], x);\n        while (i >>= 1) update(i);\n    }\n    void set(int i, const T &val) {\n        (*this)[i] = val;\n    }\n    auto operator[](int i) {\n        assert(0 <= i and i < n);\n        int k = i + m;\n        return UpdateProxyObject { data[k], [this, k]{ update_from(k); } };\n    }\n    vector<T> get_all() {\n        vector<T> ret(n);\n        for (int i = 0; i < n; ++i){\n            ret[i] = (*this)[i];\n        }\n        return ret;\n    }\n\n    // prod{l <= i < r} A[i xor x]\n    T xor_prod(int l, int r, int xor_val) {\n        static_assert(MX::commute);\n        T x = MX::unit();\n        for (int k = 0; k < m + 1; ++k) {\n            if (l >= r) break;\n            if (l & 1) { x = MX::op(x, data[((1 << m) >> k) + ((l++) ^ xor_val)]); }\n            if (r & 1) { x = MX::op(x, data[((1 << m) >> k) + ((--r) ^ xor_val)]); }\n            l /= 2, r /= 2, xor_val /= 2;\n        }\n        return x;\n    }\n\n    template <typename F>\n    int max_right(int l, const F &f) const {\n        assert(0 <= l and l <= n);\n        assert(f(MX::unit()));\n        if (l == n) return n;\n        l += m;\n        T sum_l = MX::unit();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (not f(MX::op(sum_l, data[l]))) {\n                while (l < m) {\n                    l = 2 * l;\n                    if (f(MX::op(sum_l, data[l]))) sum_l = MX::op(sum_l, data[l++]);\n                }\n                return l - m;\n            }\n            sum_l = MX::op(sum_l, data[l]);\n            l++;\n        } while ((l & -l) != l);\n        return n;\n    }\n\n    template <class F>\n    int min_left(int r, const F &f) const {\n        assert(0 <= r && r <= n);\n        assert(f(MX::unit()));\n        if (r == 0) return 0;\n        r += m;\n        T sum_r = MX::unit();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (not f(MX::op(data[r], sum_r))) {\n                while (r < m) {\n                    r = 2 * r + 1;\n                    if (f(MX::op(data[r], sum_r))) sum_r = MX::op(data[r--], sum_r);\n                }\n                return r + 1 - m;\n            }\n            sum_r = MX::op(data[r], sum_r);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\nprivate:\n    std::vector<T> data;\n\n    static constexpr int ceil_pow2(int n) {\n        int m = 1;\n        while (m < n) m <<= 1;\n        return m;\n    }\n    void update_from(int k) {\n        for (k >>= 1; k; k >>= 1) update(k);\n    }\n    void update(int k) {\n        data[k] = MX::op(data[k * 2], data[k * 2 + 1]);\n    }\n};\n\ntemplate<class Monoid>\nstd::ostream &operator<<(std::ostream &out, const SegTree<Monoid> &_seg){\n    auto seg = _seg;\n    out << \"[\";\n    for(auto i = 0; i < seg.n; ++ i){\n        out << seg[i];\n        if(i != seg.n - 1) out << \", \";\n    }\n    return out << ']';\n}\n} // namespace mitsuha\n\nnamespace mitsuha{\nstruct Monoid_Rolling_Hash {\n    using value_type = pair<modint61, modint61>;\n    using X = value_type;\n\n    static unsigned long long &get_param() {\n        static unsigned long long base = 0;\n        return base;\n    }\n    static void set_param(unsigned long long base) { get_param() = base; }\n\n    static X from_element(unsigned long long x) {\n        while (get_param() == 0) set_param(RNG_64());\n        return {get_param(), x};\n    }\n    static X op(X x, X y) { return {x.first * y.first, x.second * y.first + y.second}; }\n    static constexpr X unit() { return {1, 0}; }\n    static constexpr bool commute = false;\n};\n} // namespace mitsuha\n\nnamespace mitsuha{\ntemplate <typename X>\nstruct Monoid_Add {\n    using value_type = X;\n    static constexpr X op(const X &x, const X &y) noexcept { return x + y; }\n    static constexpr X inverse(const X &x) noexcept { return -x; }\n    static constexpr X power(const X &x, long long n) noexcept { return X(n) * x; }\n    static constexpr X unit() { return X(0); }\n    static constexpr bool commute = true;\n};\n} // namespace mitsuha\n\nnamespace mitsuha{\ntemplate <typename Monoid>\nstruct FenwickTree {\n    using G = Monoid;\n    using MX = Monoid;\n    using E = typename G::value_type;\n    int n;\n\n    FenwickTree() {}\n    FenwickTree(int n) { build(n); }\n    template <typename F>\n    FenwickTree(int n, F f) {\n        build(n, f);\n    }\n    FenwickTree(const vector<E>& v) { build(v); }\n\n    E prod_all() const { return total; }\n    E sum_all() const { return total; }\n    E sum(int k) { return prod(k); }\n    E prod(int k) const { return prefix_prod(k); }\n    E prefix_prod(int k) const {\n        chmin(k, n);\n        E ret = G::unit();\n        for (; k > 0; k -= k & -k) ret = G::op(ret, dat[k - 1]);\n        return ret;\n    }\n    E sum(int L, int R) { return prod(L, R); }\n    E prod(int L, int R) const {\n        chmax(L, 0), chmin(R, n);\n        if (R <= L) return G::unit();\n        if (L == 0) return prefix_prod(R);\n        assert(0 <= L && L <= R && R <= n);\n        E pos = G::unit(), neg = G::unit();\n        while (L < R) { pos = G::op(pos, dat[R - 1]), R -= R & -R; }\n        while (R < L) { neg = G::op(neg, dat[L - 1]), L -= L & -L; }\n        return G::op(pos, G::inverse(neg));\n    }\n\n    void add(int k, E x) { multiply(k, x); }\n    void multiply(int k, E x) {\n        static_assert(G::commute);\n        total = G::op(total, x);\n        for (++k; k <= n; k += k & -k) dat[k - 1] = G::op(dat[k - 1], x);\n    }\n\n    auto operator[](int i) {\n        assert(i >= 0 and i < n);\n        struct {\n            int i;\n            FenwickTree<Monoid>& ft;\n            operator E() const { return ft.prod(i, i + 1); }\n            auto& operator++() { return *this += 1; }\n            auto& operator--() { return *this -= 1; }\n            auto& operator+=(E val) { ft.multiply(i, val); return *this; }\n            auto& operator-=(E val) { ft.multiply(i, -val); return *this; }\n            auto& operator*=(E val) { E cur = ft.prod(i, i + 1); ft.multiply(i, cur * val - cur); return *this; }\n            auto& operator/=(E val) { E cur = ft.prod(i, i + 1); ft.multiply(i, cur / val - cur); return *this; }\n            auto& operator%=(E val) { E cur = ft.prod(i, i + 1); ft.multiply(i, cur % val - cur); return *this; }\n            auto& operator =(E val) { E cur = ft.prod(i, i + 1); ft.multiply(i, val - cur); return *this; }\n        } obj{ i, *this };\n        return obj;\n    }\n    E operator()(int l, int r) const { return prod(l, r); }\n\n    vector<E> get_all() {\n        vector<E> res(n);\n        For(i, n) res[i] = prod(i, i + 1);\n        return res;\n    }\n\n    // use only when check is monotonic,\n    // i.e using monoid_add all vals >= 0\n    template <class F>\n    int max_right(int L, const F& check) {\n        assert(check(G::unit()));\n        E s = G::unit();\n        int i = L;\n        int k = [&]() {\n            while (1) {\n                if (i % 2 == 1) { s = G::op(s, G::inverse(dat[i - 1])), i -= 1; }\n                if (i == 0) { return (n == 0 ? -1 : 31 - __builtin_clz(n)) + 1; }\n                int k = (i == 0 ? -1 : __builtin_ctz(i)) - 1;\n                if (i + (1 << k) > n) return k;\n                E t = G::op(s, dat[i + (1 << k) - 1]);\n                if (!check(t)) { return k; }\n                s = G::op(s, G::inverse(dat[i - 1])), i -= i & -i;\n            }\n        }();\n        while (k) {\n            --k;\n            if (i + (1 << k) - 1 < len(dat)) {\n                E t = G::op(s, dat[i + (1 << k) - 1]);\n                if (check(t)) { i += (1 << k), s = t; }\n            }\n        }\n        return i;\n    }\n\n    // check(i, x)\n    // use only when check is monotonic,\n    // i.e using monoid_add all vals >= 0\n    template <class F>\n    int max_right_with_index(int L, const F& check) {\n        assert(check(L, G::unit()));\n        E s = G::unit();\n        int i = L;\n        int k = [&]() {\n            while (1) {\n                if (i % 2 == 1) { s = G::op(s, G::inverse(dat[i - 1])), i -= 1; }\n                if (i == 0) { return (n == 0 ? -1 : 31 - __builtin_clz(n)) + 1; }\n                int k = (i == 0 ? -1 : __builtin_ctz(i)) - 1;\n                if (i + (1 << k) > n) return k;\n                E t = G::op(s, dat[i + (1 << k) - 1]);\n                if (!check(i + (1 << k), t)) { return k; }\n                s = G::op(s, G::inverse(dat[i - 1])), i -= i & -i;\n            }\n        }();\n        while (k) {\n            --k;\n            if (i + (1 << k) - 1 < len(dat)) {\n                E t = G::op(s, dat[i + (1 << k) - 1]);\n                if (check(i + (1 << k), t)) { i += (1 << k), s = t; }\n            }\n        }\n        return i;\n    }\n\n    // use only when check is monotonic,\n    // i.e using monoid_add all vals >= 0\n    template <class F>\n    int min_left(int R, const F& check) {\n        assert(check(G::unit()));\n        E s = G::unit();\n        int i = R;\n        int k = 0;\n        while (i > 0 && check(s)) {\n            s = G::op(s, dat[i - 1]);\n            k = (i == 0 ? -1 : __builtin_ctz(i));\n            i -= i & -i;\n        }\n        if (check(s)) {\n            assert(i == 0);\n            return 0;\n        }\n        while (k) {\n            --k;\n            E t = G::op(s, G::inverse(dat[i + (1 << k) - 1]));\n            if (!check(t)) { i += (1 << k), s = t; }\n        }\n        return i + 1;\n    }\n\n    // access by index k in fenwick set\n    int kth(E k, int L = 0) {\n        return max_right(L, [&k](E x) -> bool { return x <= k; });\n    }\n\nprivate:\n    vector<E> dat;\n    E total;\n    \npublic:\n    void build(int m) {\n        n = m;\n        dat.assign(m, G::unit());\n        total = G::unit();\n    }\n    void build(const vector<E>& v) {\n        build(len(v), [&](int i) -> E { return v[i]; });\n    }\n    template <typename F>\n    void build(int m, F f) {\n        n = m;\n        dat.clear();\n        dat.reserve(n);\n        total = G::unit();\n        for(int i = 0; i < n; ++i) { dat.emplace_back(f(i)); }\n        for (int i = 1; i <= n; ++i) {\n            int j = i + (i & -i);\n            if (j <= n) dat[j - 1] = G::op(dat[i - 1], dat[j - 1]);\n        }\n        total = prefix_prod(m);\n    }\n};\n\ntemplate<class Monoid>\nstd::ostream &operator<<(std::ostream &out, const FenwickTree<Monoid> &_ft){\n    auto ft = _ft;\n    out << \"[\";\n    for(auto i = 0; i < ft.n; ++ i){\n        out << ft[i];\n        if(i != ft.n - 1) out << \", \";\n    }\n    return out << ']';\n}\n} // namespace mitsuha\n\nnamespace mitsuha{\ntemplate <typename Monoid>\nstruct Range_Add_Range_Sum {\n    using MX = Monoid;\n    using E = typename MX::value_type;\n\n    struct Mono {\n        using value_type = pair<E, E>;\n        using X = value_type;\n        static X op(X x, X y) { return {MX::op(x.first, y.first), MX::op(x.second, y.second)}; }\n        static constexpr X unit() { return {MX::unit(), MX::unit()}; }\n        static constexpr bool commute = 1;\n    };\n    FenwickTree<Mono> bit;\n\n    Range_Add_Range_Sum() {}\n    Range_Add_Range_Sum(int n) { build(n); }\n    template <typename F>\n    Range_Add_Range_Sum(int n, F f) {\n        build(n, f);\n    }\n    Range_Add_Range_Sum(const vector<E>& v) { build(v); }\n\n    void build(int m) {\n        build(m, [](int i) -> E { return MX::unit(); });\n    }\n    void build(const vector<E>& v) {\n        build(len(v), [&](int i) -> E { return v[i]; });\n    }\n    template <typename F>\n    void build(int m, F f) {\n        bit.build(m, [&](int i) -> pair<E, E> { return {f(i), MX::unit()}; });\n    }\n\n    void add(int L, int R, E a) {\n        E b = MX::inverse(a);\n        bit.add(L, {MX::power(b, L), a});\n        bit.add(R, {MX::power(a, R), b});\n    }\n\n    E prod(int L, int R) {\n        auto [x0, x1] = bit.sum(L);\n        auto [y0, y1] = bit.sum(R);\n        E x = MX::op(MX::power(x1, L), x0);\n        E y = MX::op(MX::power(y1, R), y0);\n        return MX::op(MX::inverse(x), y);\n    }\n\n    E sum(int L, int R){\n        return prod(L, R);\n    }\n\n    E get(int i){\n        assert(i >= 0 and i < bit.n);\n        return prod(i, i + 1);\n    }\n\n    vector<E> get_all(){\n        vector<E> ret(bit.n);\n        For(i, bit.n) ret[i] = get(i);\n        return ret;\n    }\n};\n\ntemplate<typename Monoid>\nostream &operator<<(ostream &out, const Range_Add_Range_Sum<Monoid> &_ft){\n    auto ft = _ft;\n    out << \"[\";\n    for(auto i = 0; i < ft.bit.n; ++ i){\n        out << ft.prod(i, i + 1);\n        if(i != ft.bit.n - 1) out << \", \";\n    }\n    return out << ']';\n}\n} // namespace mitsuha\n\nclass Solution {\npublic:\n    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {\n        \n        int n = len(colors);\n\n        vector<int> p1(n + 1);\n        For(x, n + 1){\n            p1[x] = x & 1;\n        }\n\n        SegTree<Monoid_Rolling_Hash> P1(n + 1, [&](int i){\n            return Monoid_Rolling_Hash::from_element(p1[i]);\n        });\n\n        SegTree<Monoid_Rolling_Hash> Seg(2 * n, [&](int i){\n            return Monoid_Rolling_Hash::from_element(colors[i % n]);\n        });\n\n        Range_Add_Range_Sum<Monoid_Add<long long>> Fen(n + 1);\n\n        set<Monoid_Rolling_Hash::X> hash;\n        hash.insert(Monoid_Rolling_Hash::unit());\n        For(x, n){\n            hash.insert(P1(0, x + 1));\n            hash.insert(P1(1, x + 2));\n        }\n\n        For(x, n){\n            int r = Seg.max_right(x, [&](auto y){\n                return hash.contains(y);\n            }) - x;\n      \n            Fen.add(r, r + 1, 1);\n        }\n\n        int q = len(queries);\n        vector<int> ret;\n        For(x, q){\n            if (queries[x][0] == 1){\n                ret.push_back(Fen.sum(queries[x][1], n + 1));\n            }\n            else{\n                int idx = queries[x][1];\n                int col = queries[x][2];\n                if (col == colors[idx]) continue;\n                colors[idx] = col;\n                if (idx == 0){\n                    int prv = Seg.max_right(idx - 1 + n, [&](auto y){\n                                return hash.contains(y);\n                    }) - (idx - 1 + n);\n                    int r = Seg.max_right(idx, [&](auto y){\n                            return hash.contains(y);\n                    }) - idx;\n                    Fen.add(r, r + 1, -1);\n                    \n                    auto L = (idx + n) - Seg.min_left(idx + n, [&](auto y){\n                                return hash.contains(y);\n                    });\n                    \n                    Seg[idx] = Monoid_Rolling_Hash::from_element(colors[idx]);\n                    Seg[idx + n] = Monoid_Rolling_Hash::from_element(colors[idx]);\n                    \n                    int nxt = Seg.max_right(idx - 1 + n, [&](auto y){\n                                return hash.contains(y);\n                    }) - (idx - 1 + n);\n                    r = Seg.max_right(idx, [&](auto y){\n                            return hash.contains(y);\n                    }) - idx;\n                    Fen.add(r, r + 1, 1);\n                    \n\n                    \n                    int ext = max(0, nxt + L - n - 1);\n                    Fen.add(n, n + 1, ext);\n                    Fen.add(n, n + 1, -max(0, prv + L - n - 1));\n                    Fen.add(prv, prv + L, -1);\n                    Fen.add(nxt, nxt + L, 1);\n                } else{\n                    int prv = Seg.max_right(idx - 1, [&](auto y){\n                                return hash.contains(y);\n                    }) - (idx - 1);\n                    int r = Seg.max_right(idx, [&](auto y){\n                            return hash.contains(y);\n                    }) - idx;\n                    Fen.add(r, r + 1, -1);\n                    \n                    \n                    \n                    Seg[idx] = Monoid_Rolling_Hash::from_element(colors[idx]);\n                    Seg[idx + n] = Monoid_Rolling_Hash::from_element(colors[idx]);\n                    \n                    int nxt = Seg.max_right(idx - 1, [&](auto y){\n                                return hash.contains(y);\n                    }) - (idx - 1);\n                    r = Seg.max_right(idx, [&](auto y){\n                            return hash.contains(y);\n                    }) - idx;\n                    auto L = (idx + n) - Seg.min_left(idx + n, [&](auto y){\n                                return hash.contains(y);\n                    });\n                    Fen.add(r, r + 1, 1);\n                    \n\n                    int ext = max(0, nxt + L - n - 1);\n                    Fen.add(n, n + 1, ext);\n                    Fen.add(n, n + 1, -max(0, prv + L - n - 1));\n                    Fen.add(prv, prv + L, -1);\n                    Fen.add(nxt, nxt + L, 1);\n                }\n            }\n        }\n        return ret;\n\n    }\n};\n\n",
    "submit_ts": "1722743432",
    "subm_id": "1343791807"
}