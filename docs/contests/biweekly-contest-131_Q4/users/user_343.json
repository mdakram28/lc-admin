{
    "username": "pranshujain0111",
    "submission": "import java.io.*;\nimport java.util.*;\npublic class Template\n{\n    static PrintWriter out=new PrintWriter((System.out));\n    public static void main(String args[])throws IOException\n    {\n        Reader sc=new Reader();\n        int t=sc.nextInt();\n        while(t-->0)\n        {\n            solve();\n        }\n\tout.close();\n    }\n\n    public static void solve()\n    {\n    }\n    \n    static class Reader \n    { \n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        public String next()\n        {\n            while(!st.hasMoreTokens())\n            {\n                try\n                {\n                    st=new StringTokenizer(br.readLine());\n                }\n                catch(Exception e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n        public String nextLine()\n        {\n            try\n            {\n                return br.readLine();\n            }\n            catch(Exception e)\n            {\n                e.printStackTrace();\n            }\n            return null;\n        }\n        public boolean hasNext()\n        {\n            String next=null;\n            try\n            {\n                next=br.readLine();\n            }\n            catch(Exception e)\n            {\n            }\n            if(next==null)\n            {\n                return false;\n            }\n            st=new StringTokenizer(next);\n            return true;\n        }\n    } \n}\n\nclass Solution {\n    static long segmentTree[];\n\n \n    static void buildTree(int start, int end, int index, long values[]) {\n        if (start == end) {\n            segmentTree[index] = values[start];\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        buildTree(start, mid, 2 * index + 1, values);\n        buildTree(mid + 1, end, 2 * index + 2, values);\n        segmentTree[index] = Math.max(segmentTree[2 * index + 1], segmentTree[2 * index + 2]);\n    }\n\n  \n    static void updateTree(int start, int end, int index, int queryIndex, long value) {\n        if (start == end) {\n            segmentTree[index] = value;\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        if (queryIndex <= mid) {\n            updateTree(start, mid, 2 * index + 1, queryIndex, value);\n        } else {\n            updateTree(mid + 1, end, 2 * index + 2, queryIndex, value);\n        }\n        segmentTree[index] = Math.max(segmentTree[2 * index + 1], segmentTree[2 * index + 2]);\n    }\n\n \n    static long rangeMax(int start, int end, int index, int queryStart, int queryEnd) {\n        if (queryStart <= start && queryEnd >= end) {\n            return segmentTree[index];\n        }\n        if (queryStart > end || queryEnd < start) {\n            return Long.MIN_VALUE;\n        }\n        int mid = start + (end - start) / 2;\n        long leftMax = rangeMax(start, mid, 2 * index + 1, queryStart, queryEnd);\n        long rightMax = rangeMax(mid + 1, end, 2 * index + 2, queryStart, queryEnd);\n        return Math.max(leftMax, rightMax);\n    }\n\n\n    static void addObstacle(TreeSet<Integer> obstaclePositions, HashMap<Integer, Integer> gapMap, int position) {\n        obstaclePositions.add(position);\n        int previousPosition = obstaclePositions.lower(position);\n        int nextPosition = obstaclePositions.higher(position);\n        gapMap.put(nextPosition, nextPosition - position);\n        gapMap.put(position, position - previousPosition);\n        updateTree(0, 100000, 0, position, gapMap.get(position));\n        updateTree(0, 100000, 0, nextPosition, gapMap.get(nextPosition));\n    }\n\n   \n    static boolean canPlaceBlock(TreeSet<Integer> obstaclePositions, int position, int size) {\n        int previousPosition = obstaclePositions.lower(position);\n        if (position - previousPosition >= size) {\n            return true;\n        } else if (rangeMax(0, 100000, 0, 0, position) >= size) {\n            return true;\n        }\n        return false;\n    }\n\n   \n    public List<Boolean> getResults(int[][] queries) {\n        List<Boolean> results = new ArrayList<>();\n        TreeSet<Integer> obstaclePositions = new TreeSet<>();\n        HashMap<Integer, Integer> gapMap = new HashMap<>();\n\n        obstaclePositions.add(0);\n        obstaclePositions.add(100000);\n        gapMap.put(0, 0);\n        gapMap.put(100000, 100000);\n\n        segmentTree = new long[5 * (int) (1e5)];\n\n        for (int[] query : queries) {\n            int queryType = query[0];\n            int position = query[1];\n\n            if (queryType == 1) {\n                addObstacle(obstaclePositions, gapMap, position);\n            } else if (queryType == 2) { \n                int size = query[2];\n                results.add(canPlaceBlock(obstaclePositions, position, size));\n            }\n        }\n        return results;\n    }\n}\n",
    "submit_ts": "1716652571",
    "subm_id": "1267666604"
}