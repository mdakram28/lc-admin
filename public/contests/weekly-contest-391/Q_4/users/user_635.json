{
    "username": "nemokwy",
    "submission": "from math import atan2, pi\n\ndef rotate(points, angle):\n    \"\"\"\u7ed5\u539f\u70b9\u65cb\u8f6c\u70b9\u96c6\u5408\"\"\"\n    cos_theta = cos(angle)\n    sin_theta = sin(angle)\n    return [(x * cos_theta - y * sin_theta, x * sin_theta + y * cos_theta) for x, y in points]\n\ndef area_of_cross_trian(p, q, r):\n    \"\"\"\u8ba1\u7b97\u4e09\u89d2\u5f62\u9762\u79ef\u7684\u4e24\u500d\"\"\"\n    return (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n\ndef graham_scan(points):\n    \"\"\"Graham\u626b\u63cf\u6cd5\u6c42\u51f8\u5305\"\"\"\n    points.sort()  # \u6309\u6781\u89d2\u6392\u5e8f\n    lup = []  # \u51f8\u5305\u7684\u4e0a\u534a\u90e8\u5206\n    for p in points:\n        while len(lup) >= 2 and area_of_cross_trian(lup[-2], lup[-1], p) <= 0:\n            lup.pop()\n        lup.append(p)\n\n    ldn = []  # \u51f8\u5305\u7684\u4e0b\u534a\u90e8\u5206\n    for p in points[::-1]:\n        while len(ldn) >= 2 and area_of_cross_trian(ldn[-2], ldn[-1], p) <= 0:\n            ldn.pop()\n        ldn.append(p)\n\n    ldn.pop()  # \u5220\u9664\u6700\u540e\u4e00\u4e2a\u70b9(\u91cd\u590d\u7684\u8d77\u70b9)\n    return lup + ldn\n\ndef minimal_enclosing_circle(points):\n    \"\"\"\u6c42\u591a\u4e2a\u70b9\u7684\u6700\u5c0f\u5916\u63a5\u5706\"\"\"\n    if len(points) == 0:\n        return 0, (0, 0)\n\n    # \u5148\u6c42\u51f8\u5305\n    hull = graham_scan(points)\n    n = len(hull)\n\n    # \u5c06\u51f8\u5305\u7ed5\u65cb\u8f6c\u4e2d\u5fc3\u65cb\u8f6c\uff0c\u627e\u5230\u8fb9\u754c\u4e0a\u8ddd\u79bb\u6700\u5927\u7684\u4e24\u4e2a\u70b9\n    j = 0\n    for i in range(n):\n        if hull[i] > hull[j]:\n            j = i\n    enclosed_area = area_of_cross_trian(hull[j], hull[(j + 1) % n], hull[(j - 1) % n])\n\n    # \u4e8c\u5206\u67e5\u627e\u89d2\u5ea6\uff0c\u6700\u5c0f\u5316\u5916\u63a5\u5706\u7684\u76f4\u5f84\n    l, r = 0, pi\n    for _ in range(50):\n        m1 = l + (r - l) / 3\n        m2 = r - (r - l) / 3\n        hulls = [rotate(hull, m1), rotate(hull, m2)]\n        areas = [sum(area_of_cross_trian(p, q, r) for p, q, r in\n                     zip(hulls[0], hulls[0][1:] + hulls[0][:1], hulls[0][2:] + hulls[0][:2])),\n                 sum(area_of_cross_trian(p, q, r) for p, q, r in\n                     zip(hulls[1], hulls[1][1:] + hulls[1][:1], hulls[1][2:] + hulls[1][:2]))]\n        if areas[0] >= areas[1] and abs(areas[0] - enclosed_area) < 1e-9:\n            l = m1\n        elif areas[0] < areas[1] and abs(areas[1] - enclosed_area) < 1e-9:\n            r = m2\n\n    # \u8ba1\u7b97\u6700\u5c0f\u5916\u63a5\u5706\u76f4\u5f84\n    hull = rotate(hull, l)\n    diam = 0\n    diami,diamj = hull[0],hull[1]\n    for i in range(n):\n        for j in range(i + 1, n):\n            # dist = ((hull[i][0] - hull[j][0]) ** 2 + (hull[i][1] - hull[j][1]) ** 2) ** 0.5\n            dist = abs(hull[i][0] - hull[j][0]) + abs(hull[i][1] - hull[j][1])\n            # diam = max(diam, dist)\n            if dist > diam:\n                diam = dist\n                diami,diamj = hull[i],hull[j]\n                \n    diami = [int(round(diami[0])),int(round(diami[1]))]\n    diamj = [int(round(diamj[0])),int(round(diamj[1]))]\n    if diami[0] < 0:\n        diami = [-diami[0],-diami[1]]\n    if diamj[0] < 0:\n        diamj = [-diamj[0],-diamj[1]]\n        \n    \n    return diam, (sum(p[0] for p in hull) / n, sum(p[1] for p in hull) / n), diami,diamj\n\n# \u793a\u4f8b\u7528\u6cd5\npoints = [(0, 0), (1, 1), (-1, 1), (2, 2), (-2, 2)]\n\n\nclass Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        diameter, center,a,b = minimal_enclosing_circle(points)\n        # print(\"\u6700\u5c0f\u5916\u63a5\u5706\u76f4\u5f84:\", diameter)\n        # print(\"\u5706\u5fc3:\", center)\n        # print(a,b)\n        r = []\n        ret = float('inf')\n        f = 1\n        for i in points:\n            if i == a and f:\n                f = 0\n                continue\n            r.append(i.copy())\n        # print(r)\n        diameter, center,x,y = minimal_enclosing_circle(r)\n        ret = min(ret,diameter)\n        r = []\n        f = 1\n        for i in points:\n            if i == b and f:\n                f = 0\n                continue\n            r.append(i.copy())\n        # print(r)\n        diameter, center,x,y = minimal_enclosing_circle(r)\n        ret = min(ret,diameter)\n        return int(round(ret))"
}