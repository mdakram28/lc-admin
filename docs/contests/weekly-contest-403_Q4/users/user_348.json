{
    "username": "azhan0222",
    "submission": "class Solution:\n    def minimumSum(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        ones = set()\n        rows, cols = defaultdict(set), defaultdict(set)\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    ones.add((i, j))\n                    rows[i].add((i, j))\n                    cols[j].add((i, j))\n        ans = m * n\n        \n        # given subset of ones, return best way to split into k rectangles\n        # by recursively splitting into 2\n        @cache\n        def dfs(s, k):\n            # print(s, k)\n            if len(s) < k:\n                return float('inf')\n            minr, maxr = min(s)[0], max(s)[0]\n            minc, maxc = min(s, key=lambda x: x[1])[1], max(s, key=lambda x: x[1])[1]\n            if k == 1:\n                return (maxr - minr + 1) * (maxc - minc + 1)\n            ret = m * n\n            s1, s2 = set(), set(s)\n            for r in range(minr, maxr):\n                s1 |= rows[r] & s\n                s2 -= rows[r] & s\n                for p in range(1, k):\n                    ret = min(ret, dfs(frozenset(s1), p) + dfs(frozenset(s2), k - p))\n            s1, s2 = set(), s\n            for c in range(minc, maxc):\n                s1 |= cols[c] & s\n                s2 -= cols[c] & s\n                for p in range(1, k):\n                    ret = min(ret, dfs(frozenset(s1), p) + dfs(frozenset(s2), k - p))\n            return ret\n        \n        return dfs(frozenset(ones), 3)",
    "submit_ts": 1719113941.0
}