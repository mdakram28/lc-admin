{
    "username": "anandpatel9998",
    "submission": "class Solution {\n  public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        ArrayList<Integer>[] tree1 = toGraph(edges1);\n        ArrayList<Integer>[] tree2 = toGraph(edges2);\n\n        int d1 = diameter(tree1);\n        int d2 = diameter(tree2);\n        return Math.max(Math.max(d1, d2), ((d1 + 1) / 2 + (d2 + 1) / 2 + 1));\n    }\n\n    private ArrayList<Integer>[] toGraph(int[][] edges) {\n        int n = edges.length + 1;\n        ArrayList<Integer>[] graph = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        for (int[] e: edges) {\n            graph[e[0]].add(e[1]);\n            graph[e[1]].add(e[0]);\n        }\n        return graph;\n    }\n\n    private int diameter(ArrayList<Integer>[] tree1) {\n        int[] temp = bfs(tree1, 0);\n        return bfs(tree1, temp[1])[0];\n    }\n\n    // 0th : distance\n    // 1st : element\n    private int[] bfs(ArrayList<Integer>[] tree, int idx) {\n        int n = tree.length;\n        boolean[] visited = new boolean[n];\n        ArrayList<Integer> visiting = new ArrayList<>();\n        visiting.add(idx);\n        visited[idx] = true;\n\n        int iteration = 0;\n        int lastNode = 0;\n        while (!visiting.isEmpty()) {\n            ArrayList<Integer> newList = new ArrayList<>();\n            for (int nodes: visiting) {\n                for (int neighbour: tree[nodes]) {\n                    if (!visited[neighbour]) {\n                        visited[neighbour] = true;\n                        newList.add(neighbour);\n                        lastNode = neighbour;\n                    }\n                }\n            }\n            if (!newList.isEmpty()) {\n                iteration++;\n            }\n            visiting = newList;\n        }\n\n        return new int[]{iteration, lastNode};\n    }\n}",
    "submit_ts": "1719719269",
    "subm_id": "1304437823"
}