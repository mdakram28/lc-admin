{
    "username": "Manan04",
    "submission": "# class SegmentTree:\n#     def __init__(self, array, func=max):\n#         self.n = len(array)\n#         self.size = 2**(int(log2(self.n-1))+1) if self.n != 1 else 1\n#         self.func = func\n#         self.default = 0 if self.func != min else inf\n#         self.data = [self.default] * (2 * self.size)\n#         self.process(array)\n#     def process(self, array):\n#         self.data[self.size : self.size+self.n] = array\n#         for i in range(self.size-1, -1, -1):\n#             self.data[i] = self.func(self.data[2*i], self.data[2*i+1])\n#     def query(self, alpha, omega):\n#         if alpha == omega:\n#             return self.data[alpha + self.size]\n#         res = self.default\n#         alpha += self.size\n#         omega += self.size + 1\n#         while alpha < omega:\n#             if alpha & 1:\n#                 res = self.func(res, self.data[alpha])\n#                 alpha += 1\n#             if omega & 1:\n#                 omega -= 1\n#                 res = self.func(res, self.data[omega])\n#             alpha >>= 1\n#             omega >>= 1\n#         return res\n#     def update(self, index, value):\n#         index += self.size\n#         self.data[index] = value\n#         index >>= 1\n#         while index:\n#             self.data[index] = self.func(self.data[2*index], self.data[2*index+1])\n#             index >>= 1\nclass Solution:\n    def maximumLength(self, a: List[int], k: int) -> int:\n        # co-ordinate compression yay!\n        n = len(a)\n        na = [0] * n\n        l = []\n        for i in range(n):\n            val = a[i]\n            l.append([val, i])\n        l.sort()\n        putt = 0\n        for i in range(n):\n            val, idx = l[i]\n            if(i == 0):\n                na[idx] = putt\n                putt += 1\n            else:\n                if(l[i - 1][0] == val):\n                    na[idx] = putt - 1\n                else:\n                    na[idx] = putt\n                    putt += 1\n        helper = [0] * n\n        # s = SegmentTree(helper, max)\n        dp = [[0 for i in range(k + 1)] for i in range(n)]\n        prev = [0] * n\n        ans = 0\n        for i in range(k + 1):\n            for j in range(n):\n                val = na[j]\n                if(i == 0):\n                    dp[j][i] = 1\n                    mx = prev[val]\n                    dp[j][i] = max(dp[j][i], mx + 1)\n                else:\n                    mx = prev[val]\n                    dp[j][i] = max(dp[j][i], mx + 1)\n                    l = 0\n                    r = j - 1\n                    if(l <= r):\n                        # qu = s.query(l, r)\n                        qu = helper[r]\n                        dp[j][i] = max(dp[j][i], qu + 1)\n                ans = max(ans, dp[j][i])\n                prev[val] = max(prev[val], dp[j][i])\n            for j in range(n):\n                prev[j] = 0\n                # val = na[j]\n                # qu = -1\n                # s.update(j, max(qu, dp[j][i]))\n                helper[j] = dp[j][i]\n                if(j):\n                    helper[j] = max(helper[j], helper[j - 1])\n        return ans",
    "submit_ts": 1717859150.0
}