{
    "username": "satyam1712",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\", \"inline\", \"unroll-loops\", \"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\", \"f16c\")\n#define ll long long\n#define deb(x) cout << #x << \"=\" << x << endl\nstatic void fast_read()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n}\nstruct custom_hash\n{\n    static uint64_t splitmix64(uint64_t x)\n    {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\nclass Solution\n{\nprivate:\n    /*\nYou are given an array of positive integers nums of length n.\n\nWe call a pair of non-negative integer arrays (arr1, arr2) monotonic if:\n\n    The lengths of both arrays are n.\n    arr1 is monotonically non-decreasing, in other words, arr1[0] <= arr1[1] <= ... <= arr1[n - 1].\n    arr2 is monotonically non-increasing, in other words, arr2[0] >= arr2[1] >= ... >= arr2[n - 1].\n    arr1[i] + arr2[i] == nums[i] for all 0 <= i <= n - 1.\n\nReturn the count of monotonic pairs.\n\nSince the answer may be very large, return it modulo 109 + 7.\n\n\n\nExample 1:\n\nInput: nums = [2,3,2]\n\nOutput: 4\n\nExplanation:\n\nThe good pairs are:\n\n    ([0, 1, 1], [2, 2, 1])\n    ([0, 1, 2], [2, 2, 0])\n    ([0, 2, 2], [2, 1, 0])\n    ([1, 2, 2], [1, 1, 0])\n\nExample 2:\n\nInput: nums = [5,5,5,5]\n\nOutput: 126\n\n     */\npublic:\n    const int MOD = 1e9 + 7;\n    Solution()\n    {\n        fast_read();\n    }\n    ll dp[2002][51][51];\n\n    ll f(int idx, int prevA, int prevB, vector<int> &nums)\n    {\n        if (idx == nums.size())\n            return 1;\n\n        if (dp[idx][prevA][prevB] != -1)\n            return dp[idx][prevA][prevB];\n\n        ll ans = 0;\n        for (ll i = prevA; i <= nums[idx]; i++)\n        {\n            ll j = nums[idx] - i;\n            if (prevB >= j)\n            {\n                ans = (ans + f(idx + 1, i, j, nums)) % MOD;\n            }\n        }\n\n        return dp[idx][prevA][prevB] = ans;\n    }\n\n    int countOfPairs(vector<int> &nums)\n    {\n        memset(dp, -1, sizeof(dp));\n        ll ans = 0;\n        for (int i = 0; i <= nums[0]; i++)\n        {\n            int j = nums[0] - i;\n            ans = (ans + f(1, i, j, nums)) % MOD;\n        }\n\n        return ans;\n    }\n};\n",
    "submit_ts": "1723345707",
    "subm_id": "1351561620"
}