{
    "username": "subcrip",
    "submission": "#pragma GCC diagnostic ignored \"-Wunused-const-variable\"\n#pragma GCC diagnostic ignored \"-Wreorder\"\n#pragma GCC diagnostic ignored \"-Wunknown-pragmas\"\n#pragma GCC diagnostic ignored \"-Wshift-op-parentheses\"\n#pragma GCC diagnostic ignored \"-Wlogical-op-parentheses\"\n#pragma GCC optimize(\"Ofast\")\n/************* This code requires C++17. ***************/\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n/* macro helpers */\n#define __NARGS(...) std::tuple_size<decltype(std::make_tuple(__VA_ARGS__))>::value\n#define __DECOMPOSE_S(a, x) auto x = a;\n#define __DECOMPOSE_N(a, ...) auto [__VA_ARGS__] = a;\nconstexpr void __() {}\n#define __AS_PROCEDURE(...) __(); __VA_ARGS__; __()\n#define __as_typeof(container) remove_reference<decltype(container)>::type\n\n/* type aliases */\n#if LONG_LONG_MAX != INT64_MAX\nusing ll = int64_t;\nusing ull = uint64_t;\n#else\nusing ll = long long;\nusing ull = unsigned long long;\n#endif\nusing int128 = __int128_t;\nusing uint128 = __uint128_t;\nusing ld = long double;\nusing pii = pair<int, int>;           using pil = pair<int, ll>;           using pid = pair<int, ld>;\nusing pli = pair<ll, int>;            using pll = pair<ll, ll>;            using pld = pair<ll, ld>;\nusing pdi = pair<ld, int>;            using pdl = pair<ld, ll>;            using pdd = pair<ld, ld>;\nusing tiii = tuple<int, int, int>;    using tiil = tuple<int, int, ll>;    using tiid = tuple<int, int, ld>;\nusing tili = tuple<int, ll, int>;     using till = tuple<int, ll, ll>;     using tild = tuple<int, ll, ld>;\nusing tidi = tuple<int, ld, int>;     using tidl = tuple<int, ld, ll>;     using tidd = tuple<int, ld, ld>;\nusing tlii = tuple<ll, int, int>;     using tlil = tuple<ll, int, ll>;     using tlid = tuple<ll, int, ld>;\nusing tlli = tuple<ll, ll, int>;      using tlll = tuple<ll, ll, ll>;      using tlld = tuple<ll, ll, ld>;\nusing tldi = tuple<ll, ld, int>;      using tldl = tuple<ll, ld, ll>;      using tldd = tuple<ll, ld, ld>;\nusing tdii = tuple<ld, int, int>;     using tdil = tuple<ld, int, ll>;     using tdid = tuple<ld, int, ld>;\nusing tdli = tuple<ld, ll, int>;      using tdll = tuple<ld, ll, ll>;      using tdld = tuple<ld, ll, ld>;\nusing tddi = tuple<ld, ld, int>;      using tddl = tuple<ld, ld, ll>;      using tddd = tuple<ld, ld, ld>;\ntemplate <typename T> using max_heap = priority_queue<T>;\ntemplate <typename T> using min_heap = priority_queue<T, vector<T>, greater<>>;\ntemplate <typename T> using oi = ostream_iterator<T>;\ntemplate <typename T> using ii = istream_iterator<T>;\n\n/* constants */\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr ll INFLL = 0x3f3f3f3f3f3f3f3fLL;\nconstexpr ll MDL = 1e9 + 7;\nconstexpr ll PRIME = 998'244'353;\nconstexpr ll MDL1 = 8784491;\nconstexpr ll MDL2 = PRIME;\nconstexpr int128 INT128_MAX = numeric_limits<int128>::max();\nconstexpr uint128 UINT128_MAX = numeric_limits<uint128>::max();\nconstexpr int128 INT128_MIN = numeric_limits<int128>::min();\nconstexpr uint128 UINT128_MIN = numeric_limits<uint128>::min();\n\n/* random */\n\nmt19937 rd(chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now().time_since_epoch()).count());\n\n/* bit-wise operations */\n#define lowbit(x) ((x) & -(x))\n#define popcount(x) (__builtin_popcountll(ll(x)))\n#define parity(x) (__builtin_parityll(ll(x)))\n#define msp(x) (63LL - __builtin_clzll(ll(x)))\n#define lsp(x) (__builtin_ctzll(ll(x)))\n\n/* arithmetic operations */\n#define mod(x, y) ((((x) % (y)) + (y)) % (y))\n\n/* fast pairs */\n#define upair ull\n#define umake(x, y) (ull(x) << 32 | (ull(y) & ((1ULL << 32) - 1)))\n#define u1(p) ((p) >> 32)\n#define u2(p) ((p) & ((1ULL << 32) - 1))\n#define ult std::less<upair>\n#define ugt std::greater<upair>\n\n#define ipair ull\n#define imake(x, y) (umake(x, y))\n#define i1(p) (int(u1(ll(p))))\n#define i2(p) (ll(u2(p) << 32) >> 32)\nstruct ilt {\n    bool operator()(const ipair& a, const ipair& b) const {\n        if (i1(a) == i1(b)) return i2(a) < i2(b);\n        else return i1(a) < i1(b);\n    }\n};\nstruct igt {\n    bool operator()(const ipair& a, const ipair& b) const {\n        if (i1(a) == i1(b)) return i2(a) > i2(b);\n        else return i1(a) > i1(b);\n    }\n};\n\n/* conditions */\n#define loop while (1)\n#define if_or(var, val) if (!(var == val)) var = val; else\n#define continue_or(var, val) __AS_PROCEDURE(if (var == val) continue; var = val;)\n#define break_or(var, val) __AS_PROCEDURE(if (var == val) break; var = val;)\n\n/* hash */\nstruct safe_hash {\n    // https://codeforces.com/blog/entry/62393\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\nstruct pair_hash {\n    template <typename T, typename U>\n    size_t operator()(const pair<T, U>& a) const {\n        auto hash1 = safe_hash()(a.first);\n        auto hash2 = safe_hash()(a.second);\n        if (hash1 != hash2) {\n            return hash1 ^ hash2;\n        }\n        return hash1;\n    }\n};\n\nuniform_int_distribution<mt19937::result_type> dist(PRIME);\nconst size_t __array_hash_b = 31, __array_hash_mdl1 = dist(rd), __array_hash_mdl2 = dist(rd);\nstruct array_hash {\n    template <typename Sequence>\n    size_t operator()(const Sequence& arr) const {\n        size_t pw1 = 1, pw2 = 1;\n        size_t res1 = 0, res2 = 0;\n        for (auto&& x : arr) {\n            res1 = (res1 + x * pw1) % __array_hash_mdl1;\n            res2 = (res2 + x * pw2) % __array_hash_mdl2;\n            pw1 = (pw1 * __array_hash_b) % __array_hash_mdl1;\n            pw2 = (pw2 * __array_hash_b) % __array_hash_mdl2;\n        }\n        return res1 + res2;\n    }\n};\n\n/* build data structures */\n#define faster(um) __AS_PROCEDURE((um).reserve(1024); (um).max_load_factor(0.25);)\n#define unordered_counter(from, to) __AS_PROCEDURE(unordered_map<__as_typeof(from), size_t, safe_hash> to; for (auto&& x : from) ++to[x];)\n#define counter(from, to, cmp) __AS_PROCEDURE(map<__as_typeof(from), size_t, cmp> to; for (auto&& x : from) ++to[x];)\n#define pa(a) __AS_PROCEDURE(__typeof(a) pa; pa.push_back({}); for (auto&&x : a) pa.push_back(pa.back() + x);)\n#define sa(a) __AS_PROCEDURE(__typeof(a) sa(a.size() + 1); {int n = a.size(); for (int i = n - 1; i >= 0; --i) sa[i] = sa[i + 1] + a[i];};)\n#define adj(ch, n) __AS_PROCEDURE(vector<vector<int>> ch((n) + 1);)\n#define edge(ch, u, v) __AS_PROCEDURE(ch[u].push_back(v), ch[v].push_back(u);)\n#define edgew(ch, u, v, ...) __AS_PROCEDURE(ch[u].emplace_back(v, __VA_ARGS__), ch[v].emplace_back(u, __VA_ARGS__);)\n#define Edge(ch, u, v) __AS_PROCEDURE(ch[u].push_back(v);)\n#define Edgew(ch, u, v, ...) __AS_PROCEDURE(ch[u].emplace_back(v, __VA_ARGS__);)\ntemplate <typename T, typename Iterator> pair<size_t, map<T, size_t>> discretize(Iterator __first, Iterator __last) {\n    set<T> st(__first, __last);\n    size_t N = 0;\n    map<T, size_t> mp;\n    for (auto&& x : st) mp[x] = ++N;\n    return {N, mp};\n}\ntemplate <typename T, typename Iterator> pair<size_t, unordered_map<T, size_t, safe_hash>> unordered_discretize(Iterator __first, Iterator __last) {\n    set<T> st(__first, __last);\n    size_t N = 0;\n    unordered_map<T, size_t, safe_hash> mp;\n    for (auto&& x : st) mp[x] = ++N;\n    return {N, mp};\n}\n\n/* io */\n#define untie __AS_PROCEDURE(ios_base::sync_with_stdio(0), cin.tie(NULL))\ntemplate<typename T, typename U> istream& operator>>(istream& in, pair<T, U>& p) {\n    return in >> p.first >> p.second;\n}\ntemplate<typename T, typename U> ostream& operator<<(ostream& out, const pair<T, U>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\ntemplate<typename Char, typename Traits, typename Tuple, std::size_t... Index>\nvoid print_tuple_impl(std::basic_ostream<Char, Traits>& os, const Tuple& t, std::index_sequence<Index...>) {\n    using swallow = int[]; // guaranties left to right order\n    (void)swallow { 0, (void(os << (Index == 0 ? \"\" : \", \") << std::get<Index>(t)), 0)... };\n}\ntemplate<typename Char, typename Traits, typename... Args>\ndecltype(auto) operator<<(std::basic_ostream<Char, Traits>& os, const std::tuple<Args...>& t) {\n    os << \"{\";\n    print_tuple_impl(os, t, std::index_sequence_for<Args...>{});\n    return os << \"}\";\n}\ntemplate<typename T> ostream& operator<<(ostream& out, const vector<T>& vec) {\n    for (auto&& i : vec) out << i << ' ';\n    return out;\n}\nstd::ostream& operator<<(std::ostream& dest, const int128& value) {\n    // https://stackoverflow.com/a/25115163/23881100\n    std::ostream::sentry s( dest );\n    if ( s ) {\n        uint128 tmp = value < 0 ? -value : value;\n        char buffer[ 128 ];\n        char* d = std::end( buffer );\n        do {\n            -- d;\n            *d = \"0123456789\"[ tmp % 10 ];\n            tmp /= 10;\n        } while ( tmp != 0 );\n        if ( value < 0 ) {\n            -- d;\n            *d = '-';\n        }\n        int len = std::end( buffer ) - d;\n        if ( dest.rdbuf()->sputn( d, len ) != len ) {\n            dest.setstate( std::ios_base::badbit );\n        }\n    }\n    return dest;\n}\ntemplate<typename T> void __read(T& x) { cin >> x; }\ntemplate<typename T, typename... U> void __read(T& x, U&... args) { cin >> x; __read(args...); }\n#define read(type, ...) __AS_PROCEDURE(type __VA_ARGS__; __read(__VA_ARGS__);)\n#define readvec(type, a, n) __AS_PROCEDURE(vector<type> a(n); for (auto& x : a) cin >> x;)\n#define readvec1(type, a, n) __AS_PROCEDURE(vector<type> a((n) + 1); copy_n(ii<type>(cin), (n), a.begin() + 1);)\n#define putvec(a) __AS_PROCEDURE(copy(a.begin(), a.end(), oi<__as_typeof(a)::value_type>(cout, \" \")); cout << endl;)\n#define putvec1(a) __AS_PROCEDURE(copy(a.begin() + 1, a.end(), oi<__as_typeof(a)::value_type>(cout, \" \")); cout << endl;)\n#define putvec_eol(a) __AS_PROCEDURE(copy(a.begin(), a.end(), oi<__as_typeof(a)::value_type>(cout, \"\\n\"));)\n#define putvec1_eol(a) __AS_PROCEDURE(copy(a.begin() + 1, a.end(), oi<__as_typeof(a)::value_type>(cout, \"\\n\"));)\n#define debug(x) __AS_PROCEDURE(cerr << #x\" = \" << (x) << endl;)\n#define debugvec(a) __AS_PROCEDURE(cerr << #a\" = \"; for (auto&& x : a) cerr << x << ' '; cerr << endl;)\n#define deb(...) debug(make_tuple(__VA_ARGS__))\n\n/* pops */\n#define poptop(q, ...) __AS_PROCEDURE(auto [__VA_ARGS__] = q.top(); q.pop();)\n#define popback(q, ...) __AS_PROCEDURE(auto [__VA_ARGS__] = q.back(); q.pop_back();)\n#define popfront(q, ...) __AS_PROCEDURE(auto [__VA_ARGS__] = q.front();q.pop_front();)\n\n/* math */\ntemplate <typename return_t>\nreturn_t qpow(ll b, ll p) {\n    if (b == 0 and p != 0) return 0;\n    if (p == 0) return 1;\n    return_t half = qpow<return_t>(b, p / 2);\n    if (p % 2 == 1) return half * half * b;\n    else return half * half;\n}\n\n#define comb(n, k) ((n) < 0 or (k) < 0 or (n) < (k) ? 0 : fact[n] / fact[k] / fact[(n) - (k)])\n\nconstexpr inline int lg2(ll x) { return x == 0 ? -1 : sizeof(ll) * 8 - 1 - __builtin_clzll(x); }\n\nvoid __exgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1, y = 0;\n    return;\n  }\n  __exgcd(b, a % b, y, x);\n  y -= a / b * x;\n}\n\nll inverse(ll a, ll b) {\n    ll x, y;\n    __exgcd(a, b, x, y);\n    return mod(x, b);\n}\n\nvector<tuple<int, int, ll>> decompose(ll x) {\n    // return (factor, count, factor ** count)\n    vector<tuple<int, int, ll>> res;\n    for (int i = 2; i * i <= x; i++) {\n        if (x % i == 0) {\n            int cnt = 0;\n            ll pw = 1;\n            while (x % i == 0) ++cnt, x /= i, pw *= i;\n            res.emplace_back(i, cnt, pw);\n        }\n    }\n    if (x != 1) {\n        res.emplace_back(x, 1, x);\n    }\n    return res;\n}\n\nvector<pii> decompose_prime(int N) {\n    // return (factor, count)\n    vector<pii> result;\n    for (int i = 2; i * i <= N; i++) {\n        if (N % i == 0) {\n            int cnt = 0;\n            while (N % i == 0) N /= i, ++cnt;\n            result.emplace_back(i, cnt);\n        }\n    }\n    if (N != 1) {\n        result.emplace_back(N, 1);\n    }\n    return result;\n}\n\n/* string algorithms */\nvector<int> calc_next(string t) {  // pi function of t\n  int n = (int)t.length();\n  vector<int> pi(n);\n  for (int i = 1; i < n; i++) {\n    int j = pi[i - 1];\n    while (j > 0 && t[i] != t[j]) j = pi[j - 1];\n    if (t[i] == t[j]) j++;\n    pi[i] = j;\n  }\n  return pi;\n}\nvector<int> calc_z(string t) {  // z function of t\n    int m = t.length();\n    vector<int> z;\n    z.push_back(m);\n    pair<int, int> prev = {1, -1};\n    for (int i = 1; i < m; ++i) {\n        if (z[i - prev.first] + i <= prev.second) {\n            z.push_back(z[i - prev.first]);\n        } else {\n            int j = max(i, prev.second + 1);\n            while (j < m && t[j] == t[j - i]) ++j;\n            z.push_back(j - i);\n            prev = {i, j - 1};\n        }\n    }\n    return z;\n}\nvector<int> kmp(string s, string t) {  // find all t in s\n  string cur = t + '#' + s;\n  int sz1 = s.size(), sz2 = t.size();\n  vector<int> v;\n  vector<int> lps = calc_next(cur);\n  for (int i = sz2 + 1; i <= sz1 + sz2; i++) {\n    if (lps[i] == sz2) v.push_back(i - 2 * sz2);\n  }\n  return v;\n}\nint period(string s) {  // find the length of shortest recurring period\n    int n = s.length();\n    auto z = calc_z(s);\n    for (int i = 1; i <= n / 2; ++i) {\n        if (n % i == 0 && z[i] == n - i) {\n            return i;\n        }\n    }\n    return n;\n}\n\n/* modular arithmetic */\ntemplate <ll mdl> struct MLL {\n    ll val;\n    MLL(ll v = 0) : val(mod(v, mdl)) {}\n    MLL(const MLL<mdl>& other) : val(other.val) {}\n    friend MLL operator+(const MLL& lhs, const MLL& rhs) { return mod(lhs.val + rhs.val, mdl); }\n    friend MLL operator-(const MLL& lhs, const MLL& rhs) { return mod(lhs.val - rhs.val, mdl); }\n    friend MLL operator*(const MLL& lhs, const MLL& rhs) { return mod(lhs.val * rhs.val, mdl); }\n    friend MLL operator/(const MLL& lhs, const MLL& rhs) { return mod(lhs.val * mod(inverse(rhs.val, mdl), mdl), mdl); }\n    friend MLL operator%(const MLL& lhs, const MLL& rhs) { return mod(lhs.val - (lhs / rhs).val, mdl); }\n    friend bool operator==(const MLL& lhs, const MLL& rhs) { return lhs.val == rhs.val; }\n    friend bool operator!=(const MLL& lhs, const MLL& rhs) { return lhs.val != rhs.val; }\n    void operator+=(const MLL& rhs) { val = (*this + rhs).val; }\n    void operator-=(const MLL& rhs) { val = (*this - rhs).val; }\n    void operator*=(const MLL& rhs) { val = (*this * rhs).val; }\n    void operator/=(const MLL& rhs) { val = (*this / rhs).val; }\n    void operator%=(const MLL& rhs) { val = (*this % rhs).val; }\n};\n\ntemplate <ll mdl>\nostream& operator<<(ostream& out, const MLL<mdl>& num) {\n    return out << num.val;\n}\n\ntemplate <ll mdl>\nistream& operator>>(istream& in, MLL<mdl>& num) {\n    return in >> num.val;\n}\n\n// miscancellous\ntemplate <typename T, typename U>\nbool chmax(T& lhs, const U& rhs) {\n    bool ret = lhs < rhs;\n    if (ret) {\n        lhs = rhs;\n    }\n    return ret;\n}\ntemplate <typename T, typename U>\nbool chmin(T& lhs, const U& rhs) {\n    bool ret = lhs > rhs;\n    if (ret) {\n        lhs = rhs;\n    }\n    return ret;\n}\n\n#define functor(func) [&](auto&&... val) \\\nnoexcept(noexcept(func(std::forward<decltype(val)>(val)...))) -> decltype(auto) \\\n{return func(std::forward<decltype(val)>(val)...);}\ntemplate <typename Func, typename RandomIt> void sort_by_key(RandomIt first, RandomIt last, Func extractor) {\n    std::sort(first, last, [&] (auto&& a, auto&& b) { return std::less<>()(extractor(a), extractor(b)); });\n}\ntemplate <typename Func, typename RandomIt, typename Compare> void sort_by_key(RandomIt first, RandomIt last, Func extractor, Compare comp) {\n    std::sort(first, last, [&] (auto&& a, auto&& b) { return comp(extractor(a), extractor(b)); });\n}\ntemplate <typename T, typename U, typename Iterator_T, typename Iterator_U>\nvector<pair<T, U>> zip(Iterator_T a_first, Iterator_T a_last, Iterator_U b_first, Iterator_U b_last) {\n    vector<pair<T, U>> res;\n    auto a_it = a_first;\n    auto b_it = b_first;\n    for (; not (a_it == a_last) and not (b_it == b_last); ++a_it, ++b_it) {\n        res.emplace_back(*a_it, *b_it);\n    }\n    return res;\n}\ntemplate <typename T, typename U, typename Iterator_T, typename Iterator_U>\nvector<pair<T, U>> zip_n(Iterator_T a_first, Iterator_U b_first, size_t n) {\n    vector<pair<T, U>> res;\n    if (n > 0) {\n        res.emplace_back(*a_first, *b_first);\n        for (size_t i = 1; i != n; ++i) {\n            res.emplace_back(*++a_first, *++b_first);\n        }\n    }\n    return res;\n}\ntemplate <typename T>\nclass ArithmeticIterator : bidirectional_iterator_tag {\npublic:\n    using difference_type = ptrdiff_t;\n    using value_type = T;\nprivate:\n    value_type value;\npublic:\n    ArithmeticIterator(const T& value) : value(value) {}\n    value_type operator*() const { return value; }\n    ArithmeticIterator<T>& operator++() { ++value; return *this; }\n    ArithmeticIterator<T>& operator--() { --value; return *this; }\n    bool operator==(const ArithmeticIterator<T>& rhs) const { return value == rhs.value; }\n};\ntemplate <typename T> vector<pair<int, T>> enumerate(const vector<T>& container) {\n    return zip<int, T>(ArithmeticIterator<int>(0), ArithmeticIterator<int>(INT_MAX), container.begin(), container.end());\n}\n#define initarray(init, N) (__initarray<decay<decltype(init)>::type, (N)>(init))\ntemplate <typename T, size_t N>\narray<T, N> __initarray(const T& init) {\n    array<T, N> res;\n    for (size_t i = 0; i < N; ++i) {\n        res[i] = init;\n    }\n    return res;\n}\n/*******************************************************/\n\n\n\n\nstatic vector<MLL<MDL1>> power1;\nstatic vector<MLL<MDL2>> power2;\nstatic const ll b = rd();\ntemplate <typename _Tp>\nstruct hash_vec {\n    using hash_type = pll;\n    MLL<MDL1> hash1;\n    MLL<MDL2> hash2;\n    deque<_Tp> seq;\n    size_t size() {\n        return seq.size();\n    }\n    void push_back(const _Tp& x) {\n        hash1 = hash1 * b + x;\n        hash2 = hash2 * b + x;\n        seq.push_back(x);\n    }\n    void push_front(const _Tp& x) {\n        size_t length = size();\n        hash1 += x * power1[length];\n        hash2 += x * power2[length];\n        seq.push_front(x);\n    }\n    void pop_back() {\n        _Tp e = seq.back(); seq.pop_back();\n        hash1 = (hash1 - e) / b;\n        hash2 = (hash2 - e) / b;\n    }\n    void pop_front() {\n        _Tp e = seq.front(); seq.pop_front();\n        int length = seq.size();\n        hash1 -= e * power1[length];\n        hash2 -= e * power2[length];\n    }\n    void set(size_t pos, const _Tp& value) {\n        int length = seq.size();\n        int old_value = seq[pos];\n        hash1 += (value - old_value) * power1[length - 1 - pos];\n        hash2 += (value - old_value) * power2[length - 1 - pos];\n        seq[pos] = value;\n    }\n    const _Tp& operator[](size_t pos) {\n        return seq[pos];\n    }\n    hash_type hash() {\n        return {hash1.val, hash2.val};\n    }\n    void clear() {\n        hash1 = 0;\n        hash2 = 0;\n        seq.clear();\n    }\n    hash_vec(size_t maxn) {\n        clear();\n        MLL<MDL1> c1 = power1.size() ? power1.back() * b : 1;\n        MLL<MDL2> c2 = power2.size() ? power2.back() * b : 1;\n        for (int i = power1.size(); i < maxn; ++i) {\n            power1.push_back(c1);\n            power2.push_back(c2);\n            c1 *= b;\n            c2 *= b;\n        }\n    }\n    hash_vec(size_t maxn, const _Tp& init_value) : hash_vec(maxn) {\n        for (size_t i = 0; i != maxn; ++i) {\n            push_back(init_value);\n        }\n    }\n};\n\nstruct range_hash {\n    vector<pair<MLL<MDL1>, MLL<MDL2>>> hp;\n    template <typename T>\n    range_hash(const T& vec) {\n        hp.emplace_back();\n        hash_vec<ll> hs(vec.size());\n        for (auto&& x : vec) {\n            hs.push_back(x);\n            hp.emplace_back(hs.hash());\n        }\n    }\n\n    /// query hash of subarray [l, r]. Index starts from 0.\n    pair<MLL<MDL1>, MLL<MDL2>> range_query(size_t l, size_t r) {\n        return {\n            (hp[r + 1].first - hp[l].first * power1[r + 1 - l]),\n            (hp[r + 1].second - hp[l].second * power2[r + 1 - l]),\n        };\n    }\n};\n\n\nclass Solution {\npublic:\n    int numberOfAlternatingGroups(vector<int>& colors, int k) {\n        int n = colors.size();\n\n        hash_vec<int> a(n);\n        hash_vec<int>::hash_type hash1, hash2;\n        for (int i = 0; i < k; ++i) {\n            a.push_back(i % 2);\n        }\n        hash1 = a.hash();\n        a.clear();\n        for (int i = 0; i < k; ++i) {\n            a.push_back((i % 2) ^ 1);\n        }\n        hash2 = a.hash();\n\n        a.clear();\n        int res = 0;\n        for (int i = 0; i < n + k - 1; ++i) {\n            a.push_back(colors[i % n]);\n            if (i >= k - 1) {\n                if (a.hash() == hash1 or a.hash() == hash2) {\n                    ++res;\n                }\n                a.pop_front();\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": "1720277924",
    "subm_id": "544559629"
}