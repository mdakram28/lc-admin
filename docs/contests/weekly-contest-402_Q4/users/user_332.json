{
    "username": "viraj_vrj",
    "submission": "class SegmentTree {\nprivate:\n    vector<int> tree;\n    int n;\n\n    void build(const vector<int>& data, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = data[start];\n        } else {\n            int mid = (start + end) / 2;\n            int left_child = 2 * node + 1;\n            int right_child = 2 * node + 2;\n            build(data, left_child, start, mid);\n            build(data, right_child, mid + 1, end);\n            tree[node] = tree[left_child] + tree[right_child];\n        }\n    }\n\n    void update(int idx, int value, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = value;\n        } else {\n            int mid = (start + end) / 2;\n            int left_child = 2 * node + 1;\n            int right_child = 2 * node + 2;\n            if (start <= idx && idx <= mid) {\n                update(idx, value, left_child, start, mid);\n            } else {\n                update(idx, value, right_child, mid + 1, end);\n            }\n            tree[node] = tree[left_child] + tree[right_child];\n        }\n    }\n\n    int query(int L, int R, int node, int start, int end) {\n        if (R < start || L > end) {\n            return 0;\n        }\n        if (L <= start && end <= R) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int left_child = 2 * node + 1;\n        int right_child = 2 * node + 2;\n        int left_query = query(L, R, left_child, start, mid);\n        int right_query = query(L, R, right_child, mid + 1, end);\n        return left_query + right_query;\n    }\n\npublic:\n    SegmentTree(const vector<int>& data) {\n        n = data.size();\n        tree.resize(4 * n);\n        build(data, 0, 0, n - 1);\n    }\n\n    void updateValue(int idx, int value) {\n        if(idx<0 || idx>=n) return;\n        update(idx, value, 0, 0, n - 1);\n    }\n\n    int queryRange(int L, int R) {\n        if(L>R) return 0;\n        return query(L, R, 0, 0, n - 1);\n    }\n};\n\n// int main() {\n//     vector<int> data = {1, 0, 1, 1, 0, 1};\n//     SegmentTree segTree(data);\n\n//     // Example usage\n//     cout << \"Number of 1's in range [1, 4]: \" << segTree.queryRange(1, 4) << endl;\n\n//     segTree.updateValue(2, 0); // Update index 2 to 0\n//     cout << \"Number of 1's in range [1, 4] after update: \" << segTree.queryRange(1, 4) << endl;\n\n//     return 0;\n// }\n\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> ans;\n        int n=nums.size();\n        vector<int> biti(n,0);\n        for(int i=1;i<n-1;i++){\n            if(nums[i]>nums[i-1] && nums[i]>nums[i+1]) biti[i]=1;\n        }\n        SegmentTree mytree(biti);\n        for(auto it: queries){\n            if(it[0]==1){\n                ans.push_back(mytree.queryRange(it[1]+1,it[2]-1));\n            }\n            else{\n                int idx=it[1];\n                int val=it[2];\n                nums[idx]=val;\n                mytree.updateValue(idx,checkpeak(idx,nums));\n                mytree.updateValue(idx+1,checkpeak(idx+1,nums));\n                mytree.updateValue(idx-1,checkpeak(idx-1,nums));\n            }\n        }\n        return ans;\n    }\n    \n    int checkpeak(int i, vector<int> &nums){\n        int n=nums.size();\n        if(i<=0 || i>=n-1) return 0;\n        if(nums[i]>nums[i-1] && nums[i]>nums[i+1]) return 1;\n        return 0;\n    }\n};",
    "submit_ts": 1718507209.0
}