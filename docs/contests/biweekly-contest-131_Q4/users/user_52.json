{
    "username": "donbasta",
    "submission": "struct Segtree {\n    int n;\n    vector<int> tree, lz;\n    Segtree(int n) : n(n), tree(4 * n + 5), lz(4 * n + 5) {}\n    void build(int v, int s, int e, vector<int>& A) {\n        if (s == e) {\n            tree[v] = A[s];\n            return;\n        }\n        int mid = (s + e) >> 1;\n        build(v << 1, s, mid, A);\n        build(v << 1 | 1, mid + 1, e, A);\n        tree[v] = max(tree[v << 1], tree[v << 1 | 1]);\n    }\n    void push(int v) {\n        if (!lz[v]) return;\n        lz[v] = 0;\n        lz[v << 1] = lz[v << 1 | 1] = 1;\n        tree[v << 1] = tree[v << 1 | 1] = tree[v];\n    }\n    void upd(int v, int s, int e, int l, int r, int val) {\n        if (s == l && e == r) {\n            tree[v] = val;\n            lz[v] = 1;\n            return;\n        }\n        push(v);\n        int mid = (s + e) >> 1;\n        if (r <= mid) upd(v << 1, s, mid, l, r, val);\n        else if (l >= mid + 1) upd(v << 1 | 1, mid + 1, e, l, r, val);\n        else {\n            upd(v << 1, s, mid, l, mid, val);\n            upd(v << 1 | 1, mid + 1, e, mid + 1, r, val);\n        }\n        tree[v] = max(tree[v << 1], tree[v << 1 | 1]);\n    }\n    void upd(int l, int r, int val) {\n        if (l > r) return;\n        upd(1, 0, n - 1, l, r, val);\n    }\n    int get(int v, int s, int e, int l, int r) {\n        if (s == l && e == r) {\n            return tree[v];\n        }\n        push(v);\n        int mid = (s + e) >> 1;\n        if (r <= mid) return get(v << 1, s, mid, l, r);\n        else if (l >= mid + 1) return get(v << 1 | 1, mid + 1, e, l, r);\n        else {\n            return max(get(v << 1, s, mid, l, mid), get(v << 1 | 1, mid + 1, e, mid + 1, r));\n        }\n    }\n    int get(int l, int r) {\n        if (l > r) return -1;\n        return get(1, 0, n - 1, l, r);\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector<bool> ret;\n\n        const int INF = 1e9;\n        vector<int> bat;\n        set<int> se;\n        int qlen = (int)queries.size();\n\n        se.insert(0);\n        se.insert(INF);\n        bat.push_back(0);\n        bat.push_back(INF);\n        for (auto q : queries) {\n            if (q[0] == 1) {\n                se.insert(q[1]);\n                bat.push_back(q[1]);\n            }\n        }\n        sort(bat.begin(), bat.end());\n        int sz = bat.size();\n        vector<int> itv(sz - 1);\n        for (int i = 1; i < sz; i++) itv[i - 1] = bat[i] - bat[i - 1];\n\n        Segtree sgt(sz - 1);\n        sgt.build(1, 0, sz - 2, itv);\n\n        for (int i = qlen - 1; i >= 0; i--) {\n            if (queries[i][0] == 1) {\n                auto ptr = se.find(queries[i][1]);\n                int y = *(++ptr);\n                --ptr;\n                int x = *(--ptr);\n                int i1 = lower_bound(bat.begin(), bat.end(), queries[i][1]) - bat.begin();\n                int i2 = lower_bound(bat.begin(), bat.end(), x) - bat.begin();\n                int i3 = lower_bound(bat.begin(), bat.end(), y) - bat.begin();\n                int ki = sgt.get(i1 - 1, i1 - 1);\n                int ka = sgt.get(i1, i1);\n                sgt.upd(i2, i3 - 1, ki + ka);\n                se.erase(queries[i][1]);\n            } else {\n                int x = queries[i][1], sz = queries[i][2];\n                auto ptr = se.upper_bound(x);\n                --ptr;\n                int i1 = lower_bound(bat.begin(), bat.end(), *ptr) - bat.begin();\n                int mx = sgt.get(0, i1 - 1);\n                mx = max(mx, x - *ptr);\n                ret.push_back((mx >= sz));\n            }\n        }\n\n        reverse(ret.begin(), ret.end());\n        return ret;\n    }\n};",
    "submit_ts": 1716649687.0
}