{
    "username": "Ja1zenn",
    "submission": "import java.util.ArrayDeque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Queue;\n\npublic class Solution {\n    public int waysToReachStair(int target) {\n        if (target == 0) {\n            return 2; // Special case: two ways to stay at stair 0\n        }\n\n        // Define a helper function to generate a unique key for each state\n        class State {\n            int position;\n            int leap;\n            boolean wentDown;\n\n            State(int position, int leap, boolean wentDown) {\n                this.position = position;\n                this.leap = leap;\n                this.wentDown = wentDown;\n            }\n\n            @Override\n            public int hashCode() {\n                return Objects.hash(position, leap, wentDown);\n            }\n\n            @Override\n            public boolean equals(Object obj) {\n                if (this == obj) return true;\n                if (obj == null || getClass() != obj.getClass()) return false;\n                State state = (State) obj;\n                return position == state.position && leap == state.leap && wentDown == state.wentDown;\n            }\n        }\n\n        // Use a queue for BFS and a map for memoization\n        Queue<State> queue = new ArrayDeque<>();\n        Map<State, Integer> memo = new HashMap<>();\n        Set<State> visited = new HashSet<>();\n\n        // Initial state: starting at stair 1, jump 0, not went down last time\n        State initialState = new State(1, 0, false);\n        queue.offer(initialState);\n        memo.put(initialState, 1);\n        visited.add(initialState);\n\n        int totalWays = 0;\n\n        while (!queue.isEmpty()) {\n            State currentState = queue.poll();\n            int currentPos = currentState.position;\n            int currentJump = currentState.leap;\n            boolean wentDownLastTime = currentState.wentDown;\n\n            // Move up to stair + 2^currentJump if within bounds\n            if (currentPos <= target) {\n                int upPos = currentPos + (1 << currentJump);\n                if (upPos <= target + 1) {\n                    State upState = new State(upPos, currentJump + 1, false);\n                    if (!visited.contains(upState)) {\n                        queue.offer(upState);\n                        visited.add(upState);\n                    }\n                    memo.put(upState, memo.getOrDefault(upState, 0) + memo.get(currentState));\n                }\n            }\n\n            // Move down to stair - 1 if not consecutive and not at stair 0\n            if (currentPos > 0 && !wentDownLastTime) {\n                int downPos = currentPos - 1;\n                State downState = new State(downPos, currentJump, true);\n                if (!visited.contains(downState)) {\n                    queue.offer(downState);\n                    visited.add(downState);\n                }\n                memo.put(downState, memo.getOrDefault(downState, 0) + memo.get(currentState));\n            }\n        }\n\n        // Sum up the results for reaching target stair\n        for (int jump = 0; jump < 31; jump++) {\n            totalWays += memo.getOrDefault(new State(target, jump, false), 0);\n            totalWays += memo.getOrDefault(new State(target, jump, true), 0);\n        }\n\n        return totalWays;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        // Test case 1: k = 0\n        System.out.println(sol.waysToReachStair(0)); // Output: 2\n\n        // Test case 2: k = 1\n        System.out.println(sol.waysToReachStair(1)); // Output: 4\n    }\n};\n",
    "submit_ts": 1716088724.0
}