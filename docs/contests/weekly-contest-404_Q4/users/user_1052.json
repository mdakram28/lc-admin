{
    "username": "gabbar9081",
    "submission": "class Solution {\npublic:\n    Solution(){\n        ios_base::sync_with_stdio(false);\n        cin.tie(NULL);\n        cout.tie(0);\n    }\n    vector<int> bfs(int start, vector<vector<int>>& adj) {\n        int n = adj.size();\n        vector<int> dist(n, -1);\n        queue<int> q;\n        q.push(start);\n        dist[start] = 0;\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n\n            for (int nei : adj[node]) {\n                if (dist[nei] == -1) {\n                    dist[nei] = dist[node] + 1;\n                    q.push(nei);\n                }\n            }\n        }\n\n        return dist;\n    }\n\n    int findNode(const vector<int>& dist) {\n        int maxDist = -1;\n        int node = -1;\n\n        for (int i = 0; i < dist.size(); ++i) {\n            if (dist[i] > maxDist) {\n                maxDist = dist[i];\n                node = i;\n            }\n        }\n\n        return node;\n    }\n\n    \n    int fun(vector<vector<int>>& edges){\n        \n        int n = 1;\n        for (auto edge: edges) {\n            n = max(n, max(edge[0], edge[1])+1);\n        }\n        vector<vector<int>> adj(n);\n        for (auto edge: edges) {\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n        vector<int> dist = bfs(0, adj);\n        int node = findNode(dist);\n        vector<int> distF = bfs(node, adj);\n        int nodeF = findNode(distF);\n        \n        int dia = distF[nodeF];\n        int path = 0;\n        int curr = nodeF;\n        // cout<<\"dia\"<<dia<<' '<<nodeF<<' '<<node<<'\\n';\n        while (curr != node) {\n            path++;\n            for (int nei : adj[curr]) {\n                if (distF[nei] == distF[curr] - 1) {\n                    curr = nei;\n                    break;\n                }\n            }\n        }\n        // cout<<path<<'\\n';\n        return path;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int x = fun(edges1);\n        int p = ceil(x*1.0/2);\n        int y = fun(edges2);\n        int q = ceil(y*1.0/2);\n        // cout<<x<<'\\n'<<y<<'\\n';\n        return max(max(x, y), p+q+1);\n    }\n};\n/*\n[[0,1],[0,2],[0,3]]\n[[0,1]]\n[[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]\n[[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]\n[[0,1],[2,0],[3,2],[3,6],[8,7],[4,8],[5,4],[3,5],[3,9]]\n[[0,1],[0,2],[0,3]]\n[[0,1],[2,0],[2,3]]\n[[5,1],[5,2],[0,3],[0,4],[0,5]]\n*/",
    "submit_ts": "1719718207",
    "subm_id": "1304411440"
}