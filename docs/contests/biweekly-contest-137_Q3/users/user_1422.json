{
    "username": "Alex Chaloner",
    "submission": "def get_three_largest(numbers):\n    if len(numbers) < 3:\n        return sorted(numbers, reverse=True)\n    \n    top_three = [(0, float('-inf')) for i in range(2)]\n    \n    for i, num in enumerate(numbers):\n        if num > top_three[0][1]:\n            top_three = [(i, num), top_three[0], top_three[1]]\n        elif num > top_three[1][1]:\n            top_three = [top_three[0], (i, num), top_three[1]]\n        elif num > top_three[2][1]:\n            top_three[2] = (i, num)\n    \n    return top_three\n\ndef transpose(matrix):\n    return list(map(list, zip(*matrix)))\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        # When a rook is placed in a column and row, we basically reduce the board\n        # We only have to reduce the board three times\n        # 100 * 100 * 100 = 10^6, this is doable by brute force\n        # but 500^3 is too big at 125^6 =ish 10^8\n        \n        # Store the three biggest per row and column. Store the indices.\n        # Then cleverly search.\n        \n        rows = []\n        for i, row in enumerate(board):\n            rows.extend([(i, j, n) for j, n in get_three_largest(row)])\n            \n        # There are now only a few possibilities. We can search them all.\n        m = float('-inf')\n        for i, rs1 in enumerate(rows):\n            i1, j1, n1 = rs1 \n            for j, rs2 in enumerate(rows[i+1:]):\n                i2, j2, n2 = rs2\n                for rs3 in rows[j+1:]:\n                    i3, j3, n3 = rs3\n                    if i1 != i2 and i2 != i3 and i1 != i3 and j1 != j2 and j2 != j3 and j3 != j1:\n                        m = max(m, n1 + n2 + n3)\n\n        return m\n                ",
    "submit_ts": "1723910297",
    "subm_id": "1359224812"
}