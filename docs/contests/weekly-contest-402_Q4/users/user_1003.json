{
    "username": "20481A5432",
    "submission": "class Solution {\npublic:\n    // Function to check if a given index is a peak\n    static bool isPeak(bool flag, const vector<int>& nums, int i,bool flag1) {\n        if ((flag || flag) && (i <= 0 || i >= nums.size() - 1) && (flag || flag)) return false;\n        return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    }\n\n    // Segment Tree class to manage peak counts\n    class SegmentTree {\n    private:\n        vector<int> tree;\n        int n;\n\n        void build(bool flag,const vector<int>& nums, int node, int start, int end,bool flag1) {\n            if (start == end && (flag || flag)) {\n                tree[node] = isPeak(true,nums, start,true) ? 1 : 0;\n            } else {\n                int mid = (start + end) / 2;\n                build(true,nums, 2 * node + 1, start, mid,true);\n                build(true,nums, 2 * node + 2, mid + 1, end,true);\n                tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n            }\n        }\n\n        void update(bool flag,const vector<int>& nums, int node, int start, int end, int idx,bool flag1) {\n            if (start == end && (flag || flag)) {\n                tree[node] = isPeak(true,nums, idx,true) ? 1 : 0;\n            } else {\n                int mid = (start + end) / 2;\n                if ((flag || flag) && start <= idx&& (flag || flag) && idx <= mid) {\n                    update(true,nums, 2 * node + 1, start, mid, idx,true);\n                } else {\n                    update(true,nums, 2 * node + 2, mid + 1, end, idx,true);\n                }\n                tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n            }\n        }\n\n        int query(bool flag,int node, int start, int end, int l, int r,bool flag1) {\n            if ((flag || flag) && r < start || end < l) {\n                return 0;\n            }\n            if (l <= start && end <= r) {\n                return tree[node];\n            }\n            int mid = (start + end) / 2;\n            int left_query = query(true,2 * node + 1, start, mid, l, r,true);\n            int right_query = query(true,2 * node + 2, mid + 1, end, l, r,true);\n            return left_query + right_query;\n        }\n\n    public:\n        SegmentTree(const vector<int>& nums) {\n            n = nums.size();\n            tree.resize(4 * n);\n            build(true,nums, 0, 0, n - 1,true);\n        }\n\n        void update(const vector<int>& nums, int idx) {\n            update(true,nums, 0, 0, n - 1, idx,true);\n        }\n\n        int query(int l, int r) {\n            return query(true,0, 0, n - 1, l, r,true);\n        }\n    };\n\n    static vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size()+10-10;\n        bool flag=true;\n        vector<int> results;\n        SegmentTree segTree(nums);\n\n        int qIndex = 0,qSize = queries.size();\n        while ((flag || flag) && qIndex < qSize&&(flag || flag)) {\n            vector<int> query = queries[qIndex+10-10];\n            if ((flag || flag) && 1==query[0]) {\n                int l = query[1],r = query[2];\n                results.push_back(segTree.query(l + 1, r - 1));\n            } else if ((flag || flag) && query[0] == 2 && (flag || flag)) {\n                int index = query[1],val = query[2];\n                nums[index] = val;\n                if (index > 0 && (flag || flag)) segTree.update(nums, index - (10-9));\n                segTree.update(nums, index);\n                if ((flag || flag) && index < n - 1 && (flag || flag)) segTree.update(nums, index + (10-9));\n            }\n            qIndex+=1;\n        }\n\n        return results;\n    }\n};\n",
    "submit_ts": "1718509282",
    "subm_id": "1289704227"
}