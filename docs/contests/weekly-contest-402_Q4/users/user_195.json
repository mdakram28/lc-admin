{
    "username": "none-31",
    "submission": "func countOfPeaks(nums []int, queries [][]int) []int {\n\tn := len(nums)\n\tsgt := newSegmentTree(0, n-1, 0)\n\tfor i := 1; i < n-1; i++ {\n\t\tif nums[i] > nums[i-1] && nums[i] > nums[i+1] {\n\t\t\tsgt.update(i, 1)\n\t\t\t//fmt.Println(\"i: \", i)\n\t\t}\n\t}\n\tgetLCR := func(c int) []int {\n\t\tvar ans []int\n\t\tfor j := c - 1; j <= c+1; j++ {\n\t\t\tif j >= 1 && j < n-1 && nums[j] > nums[j-1] && nums[j] > nums[j+1] {\n\t\t\t\tans = append(ans, 1)\n\t\t\t} else {\n\t\t\t\tans = append(ans, 0)\n\t\t\t}\n\t\t}\n\t\treturn ans\n\t}\n\tvar ans []int\n\tfor _, q := range queries {\n\t\tif q[0] == 1 {\n\t\t\tl, r := q[1]+1, q[2]-1\n\t\t\tt := 0\n\t\t\t//fmt.Println(\"l, r: \", l, r)\n\t\t\tif l <= r {\n\t\t\t\tt = sgt.query(l, r)\n\t\t\t}\n\t\t\tans = append(ans, t)\n\t\t\tcontinue\n\t\t}\n\t\tbc := getLCR(q[1])\n\t\tnums[q[1]] = q[2]\n\t\tac := getLCR(q[1])\n\t\tl := ac[0] - bc[0]\n\t\tif l != 0 {\n\t\t\tsgt.update(q[1]-1, l)\n\t\t}\n\t\tc := ac[1] - bc[1]\n\t\tif c != 0 {\n\t\t\tsgt.update(q[1], c)\n\t\t}\n\t\tr := ac[2] - bc[2]\n\t\tif r != 0 {\n\t\t\tsgt.update(q[1]+1, r)\n\t\t}\n\t}\n\treturn ans\n}\n\nfunc init() {\n\tdebug.SetGCPercent(-1)\n}\n\ntype segTree struct {\n\tleft, right    int\n\tval            int\n\tlChild, rChild *segTree\n}\n\nvar defaultSegValue int\n\nfunc (this *segTree) merge(a, b int) int {\n\treturn a + b\n}\n\n// \u66f4\u65b0\u53f6\u5b50\u8282\u70b9\u7684\u503c\nfunc (this *segTree) set(val int) {\n\tthis.val = this.merge(this.val, val)\n}\n\nfunc (this *segTree) maintain() {\n\tif this.lChild == nil {\n\t\tthis.val = this.rChild.val\n\t\treturn\n\t}\n\tif this.rChild == nil {\n\t\tthis.val = this.lChild.val\n\t\treturn\n\t}\n\tthis.val = this.merge(this.lChild.val, this.rChild.val)\n}\n\nfunc newSegmentTree(l, r int, defaultVal int) *segTree {\n\tdefaultSegValue = defaultVal\n\treturn &segTree{left: l, right: r, val: defaultSegValue}\n}\n\nfunc newSegmentTreeNode(l, r int) *segTree {\n\treturn &segTree{left: l, right: r, val: defaultSegValue}\n}\n\nfunc (this *segTree) update(pos int, val int) {\n\tif this.left == this.right {\n\t\tthis.set(val)\n\t\treturn\n\t}\n\tmid := (this.left + this.right) / 2\n\tif pos <= mid {\n\t\tif this.lChild == nil {\n\t\t\tthis.lChild = newSegmentTreeNode(this.left, mid)\n\t\t}\n\t\tthis.lChild.update(pos, val)\n\t} else {\n\t\tif this.rChild == nil {\n\t\t\tthis.rChild = newSegmentTreeNode(mid+1, this.right)\n\t\t}\n\t\tthis.rChild.update(pos, val)\n\t}\n\tthis.maintain()\n}\n\n// \u6ce8\u610f\u81ea\u884c\u5904\u7406l>r\u7684\u60c5\u51b5\uff0c\u5426\u5219query\u51fd\u6570\u4f1a\u8fd4\u56de\u9519\u8bef\u7684\u503c\nfunc (this *segTree) query(l, r int) int {\n\tif this == nil {\n\t\treturn defaultSegValue\n\t}\n\tif l <= this.left && r >= this.right {\n\t\treturn this.val\n\t}\n\tmid := (this.left + this.right) / 2\n\tif l > mid {\n\t\treturn this.rChild.query(l, r)\n\t}\n\tif r <= mid {\n\t\treturn this.lChild.query(l, r)\n\t}\n\treturn this.merge(this.lChild.query(l, r), this.rChild.query(l, r))\n}\n\n// \u7ebf\u6bb5\u6811\u4e8c\u5206\uff1a\u627e\u51fa[l,r]\u8303\u56f4\u5185\u7b2c\u4e00\u4e2a\u6ee1\u8db3f\u6761\u4ef6\u7684\u4e0b\u6807\nfunc (this *segTree) findFirst(l, r int, f func(int) bool) (int, bool) {\n\tif this.left > r || this.right < l || !f(this.val) {\n\t\treturn 0, false\n\t}\n\tif this.left == this.right {\n\t\treturn this.left, true\n\t}\n\tif this.lChild != nil {\n\t\tlv, lok := this.lChild.findFirst(l, r, f)\n\t\tif lok {\n\t\t\treturn lv, lok\n\t\t}\n\t}\n\tif this.rChild != nil {\n\t\trv, rok := this.rChild.findFirst(l, r, f)\n\t\treturn rv, rok\n\t}\n\treturn 0, false\n}\n\n// \u7ebf\u6bb5\u6811\u4e8c\u5206\uff1a\u627e\u51fa[l,r]\u8303\u56f4\u5185\u6700\u540e\u4e00\u4e2a\u6ee1\u8db3f\u6761\u4ef6\u7684\u4e0b\u6807\nfunc (this *segTree) findLast(l, r int, f func(int) bool) (int, bool) {\n\tif this.left > r || this.right < l || !f(this.val) {\n\t\treturn 0, false\n\t}\n\tif this.left == this.right {\n\t\treturn this.left, true\n\t}\n\tif this.rChild != nil {\n\t\trv, rok := this.rChild.findLast(l, r, f)\n\t\treturn rv, rok\n\t}\n\tif this.lChild != nil {\n\t\tlv, lok := this.lChild.findLast(l, r, f)\n\t\tif lok {\n\t\t\treturn lv, lok\n\t\t}\n\t}\n\treturn 0, false\n}",
    "submit_ts": 1718506452.0
}