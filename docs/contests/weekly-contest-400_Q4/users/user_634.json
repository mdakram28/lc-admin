{
    "username": "XRancher_1232",
    "submission": "class SegmentTree {\npublic:\n    vector<int> tree;\n    int n;\n    SegmentTree(vector<int>& arr)\n    {\n        n = arr.size();\n        tree.resize(4 * n);\n        build(arr, 0, 0, n - 1);\n    }\n\n    void build(vector<int>& arr, int node, int start,\n               int end)\n    {\n        if (start == end) {\n            tree[node] = arr[start];\n        }\n        else {\n            int mid = (start + end) / 2;\n            build(arr, 2 * node + 1, start, mid);\n            build(arr, 2 * node + 2, mid + 1, end);\n\n            tree[node]\n                = tree[2 * node + 1] & tree[2 * node + 2];\n        }\n    }\n    int query(int l, int r)\n    {\n        return query(0, 0, n - 1, l, r);\n    }\n\n    int query(int node, int start, int end, int l, int r)\n    {\n        if (r < start || end < l) {\n            return 1e9;\n        }\n        if (l <= start && end <= r) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int p1 = query(2 * node + 1, start, mid, l, r);\n        int p2 = query(2 * node + 2, mid + 1, end, l, r);\n\n        return p1 & p2;\n    }\n};\n\n\n\nclass Solution {\nprivate:\n    vector<int> get_set_bits(int x) {\n        vector<int> set_bits;\n        for (int i = 0; x > 0; ++i, x >>= 1) {\n            if (x & 1) {\n                set_bits.push_back(i);\n            }\n        }\n        return set_bits;\n    }\n\n    int counts_to_bitwise_and(int window_length, unordered_map<int, int>& bit_counts) {\n        int result = 0;\n        for (const auto& [key, count] : bit_counts) {\n            if (count == window_length) {\n                result |= (1 << key);\n            }\n        }\n        return result;\n    }\npublic:\n    int minimumDifference(vector<int>& nums, int target) {\n//         int n = nums.size();\n//         SegmentTree st(nums);\n//         int ans = 1e9;\n//         for (int i = 0; i < n; i++) {\n//             int l = i - 1, r = n - 1, mid;\n\n\n//             while (r - l > 1) {\n//                 mid = (l + r) / 2;\n//                 if (st.query(i, mid) >= k)\n//                     l = mid;\n//                 else\n//                     r = mid;\n//             }\n//             if (l != i - 1)\n//                 ans = min(ans, abs(st.query(i, l) - k));\n//             ans = min(ans, abs(k - st.query(i, r)));\n//         }\n//         return ans;\n        \n        int n = nums.size();\n        int current_AND_value = nums[0];\n        int best_diff = abs(current_AND_value - target);\n\n        unordered_map<int, int> window_bit_counts;\n        vector<int> bits = get_set_bits(nums[0]);\n        for (int bit : bits) {\n            window_bit_counts[bit]++;\n        }\n\n        int left_idx = 0, right_idx = 0;\n        while (right_idx < n) {\n            if (current_AND_value > target || left_idx > right_idx) {\n                right_idx++;\n                if (right_idx >= n) break;\n                bits = get_set_bits(nums[right_idx]);\n                for (int bit : bits) {\n                    window_bit_counts[bit]++;\n                }\n            } else {\n                bits = get_set_bits(nums[left_idx]);\n                for (int bit : bits) {\n                    window_bit_counts[bit]--;\n                    if (window_bit_counts[bit] == 0) {\n                        window_bit_counts.erase(bit);\n                    }\n                }\n                left_idx++;\n            }\n\n            current_AND_value = counts_to_bitwise_and(right_idx - left_idx + 1, window_bit_counts);\n            if (left_idx <= right_idx) {\n                best_diff = min(best_diff, abs(current_AND_value - target));\n            }\n        }\n\n        return best_diff;\n    }\n};",
    "submit_ts": "1717299133",
    "subm_id": "1274802767"
}