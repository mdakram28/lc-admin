{
    "username": "megaspazz",
    "submission": "class Solution {\n    public int minimumDistance(int[][] points) {\n        CountMapLong<Integer> forward = new CountMapLong<>();\n        CountMapLong<Integer> backward = new CountMapLong<>();\n        \n        for (int[] p : points) {\n            int x = p[0];\n            int y = p[1];\n            \n            int f = x + y;\n            int b = x - y;\n            \n            forward.increment(f, 1);\n            backward.increment(b, 1);\n        }\n        \n        int ans = Integer.MAX_VALUE;\n        for (int[] p : points) {\n            int x = p[0];\n            int y = p[1];\n            \n            int f = x + y;\n            int b = x - y;\n            \n            forward.increment(f, -1);\n            backward.increment(b, -1);\n            \n            int curr = Math.max(forward.lastKey() - forward.firstKey(), backward.lastKey() - backward.firstKey());\n            ans = Math.min(ans, curr);\n            \n            forward.increment(f, 1);\n            backward.increment(b, 1);\n        }\n        return ans;\n    }\n\n\t/**\n\t * Counts the frequency of objects.\n\t * Change to extend TreeMap instead, if ordering of objects is required.\n\t * \n\t * NOTE:  If `total` is needed, only use `increment(...)` for updates.\n\t */\n\tpublic static class CountMapLong<T> extends TreeMap<T, Long> {\n\t\tprivate static final long serialVersionUID = -9079906779955923767L;\n\n\t\tpublic long total;\n\n\t\tpublic long getCount(T k) {\n\t\t\treturn getOrDefault(k, 0L);\n\t\t}\n\n\t\tpublic void increment(T k, long v) {\n\t\t\ttotal += v;\n\t\t\tlong next = getCount(k) + v;\n\t\t\tif (next == 0) {\n\t\t\t\tremove(k);\n\t\t\t} else {\n\t\t\t\tput(k, next);\n\t\t\t}\n\t\t}\n\n\t\tpublic static <T> CountMapLong<T> fromArray(T[] A) {\n\t\t\tCountMapLong<T> cm = new CountMapLong<>();\n\t\t\tfor (T x : A) {\n\t\t\t\tcm.increment(x, 1);\n\t\t\t}\n\t\t\treturn cm;\n\t\t}\n\t}\n}"
}