{
    "username": "hellimmortal",
    "submission": "class Solution {\npublic:\n    int cnt(int ringIndex, int i, int n){\n        int u=abs(i-ringIndex);\n        int v=n-u;\n        return min(u,v);\n    }\n\n    int f(int ringIndex,int keyIndex, string ring, string key, vector<vector<int>>&dp){\n        int n=ring.size();\n        int m=key.size();\n        if(keyIndex>=m){\n            return 0;\n        }\n\n        if(dp[ringIndex][keyIndex]!=-1){\n            return dp[ringIndex][keyIndex];\n        }\n\n        int res=INT_MAX;\n        for(int i=0; i<n; i++){\n            if(ring[i]==key[keyIndex]){\n                int total=1+cnt(ringIndex,i,n)+f(i,keyIndex+1,ring,key,dp);\n                res=min(res,total);\n            }\n        }\n        return dp[ringIndex][keyIndex]=res;\n    }\n    int findRotateSteps(string ring, string key) {\n        int n=ring.size(),m=key.size();\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\n        return f(0,0,ring,key,dp);\n    }\n\n    string calculateResult() {\n    int n;\n    cin >> n;\n    vector<int> s(n);\n    for (int i = 0; i < n; i++) {\n        cin >> s[i];\n    }\n    int p = 0;\n    int c = (s[0] > 120) + (s[0] > 239);\n    for (int x = 1; x < n; x++) {\n        if (s[x] - s[x - 1] > 119) {\n            if (s[x] - s[x - 1] > 239) {\n                c++;\n            }\n            c++;\n            if (c > 1) {\n                return \"YES\";\n            }\n        }\n    }\n    if (1440 - s[n - 1] > 119) {\n        if (1440 - s[n - 1] > 239) {\n            c += 2;\n        } else {\n            c++;\n        }\n    }\n    if (c > 1) {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n    bool bfs(int i, vector<int> adj[], vector<int>& col) {\n    queue<int> q;\n    q.push(i);\n    col[i] = 0;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n\n        for (auto neighbor : adj[node]) {\n            if (col[neighbor] == -1) {\n                col[neighbor] = !col[node];\n                q.push(neighbor);\n            } else if (col[neighbor] == col[node]) {\n                return false;\n            }\n        }\n    }\n    return true; \n}\n\nbool isBipartite(int n, vector<int> adj[]) {\n    vector<int> col(n, -1);\n\n    for (int i = 0; i < n; i++) {\n        if (col[i] == -1) {\n            if (!bfs(i, adj, col)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n    int minimumAddedInteger(vector<int>& p, vector<int>& q) {\n        unordered_map<int, int> mpp;\n    int mnn = INT_MAX;\n    sort(p.begin(), p.end());\n    sort(q.begin(), q.end());\n\n    for (int i = 0; i < p.size(); i++) {\n        for (int j = 0; j < q.size(); j++) {\n            int x = q[j] - p[i];\n            mpp[x]++;\n        }\n    }\n\n    for (auto& [x, count] : mpp) {\n        vector<int> ptr(p.size());\n        for (int i = 0; i < p.size(); i++) {\n            ptr[i] = p[i] + x;\n        }\n        sort(ptr.begin(), ptr.end());\n\n        if (f(ptr, q)) {\n            mnn = min(mnn, x);\n        }\n    }\n    return mnn;\n}\n\nbool f(vector<int>& ptr, vector<int>& q) {\n    int i = 0, j = 0, hj = 2;\n    while (i < ptr.size() && j < q.size()) {\n        if (ptr[i] == q[j]) {\n            i++;\n            j++;\n        } else {\n            i++;\n            hj--;\n            if (hj < 0) {\n                return false;\n            }\n        }\n    }\n    return j == q.size() && (i - j) <= 2;\n}\n    vector<int> kmp(const string& word) {\n    int n = word.length();\n    vector<int> lps(n, 0);\n    int length = 0;\n    int i = 1;\n    while (i < n) {\n        if (word[i] == word[length]) {\n            length++;\n            lps[i] = length;\n            i++;\n        } else {\n            if (length != 0) {\n                length = lps[length - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    return lps;\n}\n\n    int minimumOperationsToMakeKPeriodic(string word, int k) {\n        string vl = \"\";\n        int res = 0;\n        std::unordered_map<std::string, int> mpp;\n        \n        for (int i = 0; i < word.size(); ++i) {\n            if (i % k == 0) {\n                vl = \"\";\n            }\n            vl += word[i];\n            if (vl.size() == k) {\n                mpp[vl]++;\n            }\n        }\n        \n        int n = word.size();\n        res = n;\n        for (auto& pair : mpp) {\n            res = std::min(res, n / k - pair.second);\n        }\n        \n        return res;\n    }\n    vector<int> dp;\n\n    int wet(int ind, string &ty) {\n        if(ind < 0) return 0;\n        if(dp[ind] != -1) return dp[ind];\n\n        vector<int> mpp(26, 0);\n        int res = 5005;\n\n        for(int jj = ind; jj >= 0; jj--) {\n            mpp[ty[jj] - 'a']+=1;\n            int mn = 1005, mx = 0;\n\n            for(int kk = 0; kk < 26; kk++) {\n                if(mpp[kk]) {\n                    mn = min(mn, mpp[kk]);\n                    mx = max(mx, mpp[kk]);\n                }\n            }\n            if(mn == mx) {\n                res = min(res, 1 + wet(jj - 1, ty));\n            }\n        }\n\n        return dp[ind] = res;\n    }\n\n    int minimumSubstringsInPartition(string ty) {\n        dp.assign(ty.size(), -1);\n        return wet(ty.size() - 1, ty);\n    }\n    int maxScore(vector<vector<int>>& p) {\n        int n = p.size();\n        int m = p[0].size();\n        \n        vector<vector<int>> yeti(n, vector<int>(m, INT_MIN + 1));\n        yeti[n - 1][m - 1] = p[n - 1][m - 1];\n        \n        for (int ii = n - 1; ii >= 0; --ii) {\n            for (int jj = m - 1; jj >= 0; --jj) {\n                if (ii < n - 1)\n                    yeti[ii][jj] = max(yeti[ii][jj], yeti[ii + 1][jj]);\n                if (jj < m - 1)\n                    yeti[ii][jj] = max(yeti[ii][jj], yeti[ii][jj + 1]);\n                yeti[ii][jj] = max(yeti[ii][jj], p[ii][jj]);\n            }\n        }\n        \n        int mxx = INT_MIN + 1;\n        for (int ii = 0; ii < n; ++ii) {\n            for (int jj = 0; jj < m; ++jj) {\n                if (ii < n - 1)\n                    mxx = max(mxx, yeti[ii + 1][jj] - p[ii][jj]);\n                if (jj < m - 1)\n                    mxx = max(mxx, yeti[ii][jj + 1] - p[ii][jj]);\n            }\n        }\n        \n        return mxx;\n }\n    long long sumDigitDifferences(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 0) return 0;\n\n        const int mxx = 10,bs = 10;\n\n        int temp[mxx][bs] = {0};\n\n        for (int it : nums) {\n            for (int j = 0; j < mxx; ++j) {\n                int dig = it % 10;\n                temp[j][dig]++;\n                it /= 10;\n                if (it == 0) break;\n            }\n        }\n\n        long long sum = 0;\n        for (int j = 0; j < mxx; ++j) {\n            for (int k = 0; k < bs; ++k) {\n                int mpp = temp[j][k];\n                sum += mpp * (n - mpp);\n            }\n        }\n\n        return sum / 2;\n    }\n        \n    vector<int> queryResults(int limit, vector<vector<int>>& queries) {\n    unordered_map<int, int> mpp;\n    unordered_set<int> cl;\n    vector<int> res;\n\n    for (const auto& q : queries) {\n        int x1 = q[0];\n        int x2 = q[1];\n\n        if (mpp.count(x1)) {\n            int x3 = mpp[x1];\n            mpp.erase(x1);\n\n            bool x4 = false;\n            for (const auto& x5 : mpp) {\n                if (x5.second == x3) {\n                    x4 = true;\n                    break;\n                }\n            }\n            if (!x4) {\n                cl.erase(x3);\n            }\n        }\n\n        mpp[x1] = x2;\n        cl.insert(x2);\n\n        res.push_back(cl.size());\n    }\n\n    return res;\n    }\nstring f2(long long x, const vector<bool>& vis) {\n    string key = to_string(x) + \":\";\n    for (bool v : vis) {\n        key += (v ? \"1\" : \"0\");\n    }\n    return key;\n}\n\n    int minimumCost(int m, int n, vector<int>& h, vector<int>& v){\n        int pt = 0, mt = 0,r = 1, s = 1,ct = 0;\n      sort(h.rbegin(), h.rend());\n    sort(v.rbegin(), v.rend());\n    \n    \n    while (pt < h.size() && mt < v.size()) {\n        if (h[pt] > v[mt]) {\n            ct += h[pt] * s;\n            r++;\n            pt++;\n        } else {\n            ct += v[mt] * r;\n            s++;\n            mt++;\n        }\n    }\n    \n    while (pt < h.size()) {\n        ct += h[pt] * s;\n        pt++;\n    }\n    \n    while (mt < v.size()) {\n        ct += v[mt] * r;\n        mt++;\n    }\n    \n    return ct;\n    }\n    \n   class st {\nprivate:\n    vector<int> mn;\n    vector<vector<vector<long long>>> dp;\n    long long md = 1e9 + 7;\n\n    long long f(int i, int pt, int qt) {\n        if (i >= mn.size()) return 1;\n        if (dp[i][pt][qt] != -1) return dp[i][pt][qt];\n        \n        long long rr = 0;\n        for (int x = pt; x <= mn[i]; x++) {\n            for (int y = qt; y >= 0; y--) {\n                if (x + y == mn[i]) {\n                    rr += f(i + 1, x, y);\n                    rr %= md;\n                }\n            }\n        }\n        return dp[i][pt][qt] = rr;\n    }\n\npublic:\n    st(vector<int>& mn) : mn(mn) {\n        int size = mn.size();\n        dp = vector<vector<vector<long long>>>(size, vector<vector<long long>>(51, vector<long long>(51, -1)));\n    }\n\n    long long s() {\n        return f(0, 0, mn[0]);\n    }\n};\n\n    int f(int i, vector<int>& r, int x, vector<vector<int>>& dp) {\n        int n=r.size();\n        if (i >= n) return 0;\n        if (dp[i][x] != -1) return dp[i][x];\n        \n        int nt = f(i + 1, r, x, dp);\n        int t = 0;\n        if (x < r[i]) {\n            t = r[i] + f(i + 1, r, x + r[i], dp);\n        }\n        \n        return dp[i][x] = max(t, nt);\n    }\n    \n    int numberOfSubmatrices(vector<vector<char>>& grid) {\n        int cnt = 0, n = grid.size(), m = grid[0].size();\n        vector<vector<int>> yt(n + 1, vector<int>(m + 1, 0)), xt(n + 1, vector<int>(m + 1, 0));\n        \n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                yt[i+1][j+1] = yt[i][j+1] + yt[i+1][j] - yt[i][j] + (grid[i][j] == 'X' ? 1 : 0);\n                xt[i+1][j+1] = xt[i][j+1] + xt[i+1][j] - xt[i][j] + (grid[i][j] == 'Y' ? 1 : 0);\n            }\n        }\n        \n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if(i==0 && j==0){\n                    for (int ii = i; ii < n; ++ii) {\n                        for (int jj = j; jj < m; ++jj) {\n                            int y1 = yt[ii+1][jj+1], y2 = yt[i][jj+1], y3 = yt[ii+1][j], y4 = yt[i][j];\n                            int my = y1 - y2 - y3 + y4;\n\n                            int x1 = xt[ii+1][jj+1], x2 = xt[i][jj+1], x3 = xt[ii+1][j], x4 = xt[i][j];\n                            int mh = x1 - x2 - x3 + x4;\n\n                            if (my == mh && my > 0) {\n                                cnt++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return cnt;\n    }\n    struct stt {\n    map<int, vector<int>> mpp;\n    vector<int> v;\n    int k;\n    int n;\n\n    stt(vector<int>& nums, int k) : k(k), n(nums.size()) {\n        processPairs(nums);\n    }\n\n    void processPairs(vector<int>& nums) {\n        for (int i = 0; i < n / 2; i++) {\n            int ptr = nums[i], qtr = nums[n - i - 1],d = abs(ptr - qtr),mn = max({ptr, qtr, k - ptr, k - qtr});\n            mpp[d].push_back(mn);\n            v.push_back(mn);\n        }\n        sort(v.begin(), v.end());\n    }\n\n    int minChanges() {\n        int nt = n;\n        for (auto& val : mpp) {\n            int d = val.first;\n            int kk = lower_bound(v.begin(), v.end(), d) - v.begin();\n            kk = kk * 2 + (n / 2 - kk);\n\n            for (auto& mn : val.second) {\n                if (mn < d) {\n                    kk -= 2;\n                } else {\n                    kk -= 1;\n                }\n            }\n\n            nt = min(nt, kk);\n        }\n\n        return nt;\n    }\n};\n    \n    int maxTotalReward(vector<int>& r) {\n        sort(r.begin(), r.end());\n        vector<vector<int>> dp(r.size(), vector<int>(4005, -1));\n        return f(0, r, 0, dp);\n    }\n\n    int minOperations(vector<int>& x2) {\n        int x3 = x2.size(),x4 = 0;\n        bool x5 = false;\n\n        for (int i = 0; i < x3; ++i) {\n            if ((x2[i] == 0 && !x5) || (x2[i] == 1 && x5)) {\n                x4++;\n                x5 = !x5;\n            }\n        }\n        return x4;\n    }\n    int maximumLength(vector<int>& mn) {\n        int res = INT_MIN;\n        int fl = 0;\n        int n = mn.size();\n        int ct = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (mn[i] % 2 == fl) {\n                ct++;\n                fl = !fl;\n            }\n        }\n        res = max(res, ct);\n        \n        fl = 1,ct = 0;\n        for (int i = 0; i < n; i++) {\n            if (mn[i] % 2 == fl) {\n                ct++;\n                fl = !fl;\n            }\n        }\n        res = max(res, ct);\n        \n        fl = 0,ct = 0;\n        for (int i = 0; i < n; i++) {\n            if (mn[i] % 2 == fl) {\n                ct++;\n            }\n        }\n        res = max(res, ct);\n        \n        fl = 1,ct = 0;\n        for (int i = 0; i < n; i++) {\n            if (mn[i] % 2 == fl) {\n                ct++;\n            }\n        }\n        res = max(res, ct);\n        \n        return res;\n    }\n    int minChanges(vector<int>& nums, int k) {\n       stt sol(nums, k);\n    return sol.minChanges();\n    }\n    int minFlips(vector<vector<int>>& grid) {\n        int m = grid.size(),n = grid[0].size();\n    \n        auto f = [](vector<int>& arr) {\n            int a = 0;\n            int l = arr.size();\n            for (int i = 0; i < l / 2; ++i) {\n                if (arr[i] != arr[l - i - 1]) {\n                    a++;\n                }\n            }\n            return a;\n        };\n    \n    int r = 0;\n    for (int i = 0; i < m; ++i) {\n        r += f(grid[i]);\n    }\n    \n    int c = 0;\n    for (int j = 0; j < n; ++j) {\n        vector<int> col;\n        for (int i = 0; i < m; ++i) {\n            col.push_back(grid[i][j]);\n        }\n        c += f(col);\n    }\n    \n    return min(r, c);\n    }\n\n    int countOfPairs(vector<int>& mn) {\n        st o1(mn);\n        return o1.s();\n    }\n};",
    "submit_ts": "1723345796",
    "subm_id": "1351563520"
}