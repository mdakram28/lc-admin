{
    "username": "Viggyz",
    "submission": "# def __init__(self, n: int, m: int):\n#         self.n, self.m = n, m\n#         self.tree = [[m, m]] * (4*n)\n        \n#         self._build_tree(0, 0, n-1)\n\n#     def _build_tree(self, i, s, e):\n#         if s == e:\n#             self.tree[i] = [self.m, self.m]\n#             return\n#         m = (s + e) // 2\n#         self.tree[i] = [self.m, (e-s+1) * self.m]\n#         self._build_tree(2 * m + 1, s, m)\n#         self._build_tree(2 * m + 2, m+1, e)\n\n#     def query_max(self, i, s, e, qs, qe, k):\n#         if s>qe:\n#             return []\n#         if self.tree[i][0] < k:\n#             return []\n#         if s == e:\n#             return [s, self.m - self.tree[i][0]]\n#         m = (s+e)//2\n#         ret = self.query_max(2*i+1, s, m, qs, qe, k)\n#         if len(ret) > 0:\n#             return ret\n#         return self.query_max(2*i+2, m+1, e, qs, qe, k)\n    \n#     def update_max(self, i, s, e, pos, val):\n#         if s > pos or e < pos:\n#             return\n#         if s == e:\n#             self.tree[i][0] -= val\n#             self.tree[i][1] -= val\n#             return \n        \n#         m = (s+e) // 2\n#         self.tree[i][1] -= val\n#         self.update_max(2*i+1, s, m, pos, val)\n#         self.update_max(2*i+2, m +1, e, pos, val)\n#         self.tree[i][0] = max(self.tree[2*i+1][0], self.tree[2*i+2][0])\nfrom sortedcontainers import SortedSet\n\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        MAX_VAL = (5 * 10 ** 4) + 1\n#         seg_tree = SegTree(MAX_VAL)\n        \n#         res = []\n#         posts = []\n#         for query in queries:\n#             if query[0] == 1:\n#                 _, x = query\n                \n#                 seg_tree.update(x)\n#             else:\n#                 _, x, sz = query\n#                 max_size = seg_tree.query(0, x)\n#                 res.append(max_size >= sz)\n#         return res\n        \n        posts = SortedSet([0, MAX_VAL])\n        sizes_sort = SortedSet()\n        \n        sizes_index = defaultdict(SortedSet)\n        # sizes_sort = SortedDict()\n        sizes_sort.add(MAX_VAL)\n        sizes_index[MAX_VAL].add(MAX_VAL)\n        \n        res = []\n        for query in queries:\n            if query[0] == 1:\n                _, x = query\n                after = posts.bisect_right(x)\n                prev = after - 1\n                \n                assert 0 <= prev < len(posts), 0<=after < len(posts)\n                \n                left_dist, right_dist = x - posts[prev], posts[after] - x\n                old_dist = left_dist + right_dist\n                sizes_index[old_dist].remove(posts[after])\n                if len(sizes_index[old_dist]) == 0:\n                    sizes_sort.remove(old_dist)\n                \n                sizes_sort.add(left_dist)\n                sizes_sort.add(right_dist)\n                sizes_index[left_dist].add(x)\n                sizes_index[right_dist].add(posts[after])\n                posts.add(x)\n            else:\n                _, x, sz = query\n                is_valid = False\n                if x - posts[posts.bisect_right(x)- 1] >= sz:\n                    res.append(True)\n                    continue\n                for i in range(len(sizes_sort)-1, -1, -1):\n                    if sizes_sort[i] < sz:\n                        break\n                    idx = sizes_index[sizes_sort[i]].bisect_right(x) - 1\n                    # assert idx < 0 or sizes_index[sizes_sort[i]][idx] <= x\n                    if idx >= 0 and idx < len(sizes_index[sizes_sort[i]]):\n                        is_valid = True\n                        break\n                res.append(is_valid)\n        return res",
    "submit_ts": 1716652443.0
}