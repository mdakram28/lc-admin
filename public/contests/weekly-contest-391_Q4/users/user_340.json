{
    "username": "oxkexrzjz",
    "submission": "fn solve(ps: Vec<(i32, i32)>) -> i32 {\n    let mut add = ps.iter().map(|&(x, y)| (x + y, x, y)).collect::<Vec<_>>();\n    let mut sub = ps.iter().map(|&(x, y)| (x - y, x, y)).collect::<Vec<_>>();\n    add.sort_unstable();\n    sub.sort_unstable();\n    let mut candidates = vec![\n        (add[0].1, add[0].2),\n        (add[add.len() - 1].1, add[add.len() - 1].2),\n        (sub[0].1, sub[0].2),\n        (sub[sub.len() - 1].1, sub[sub.len() - 1].2),\n    ];\n    let mut ans = i32::MIN;\n    for i in 0..4 {\n        for j in (i + 1)..4 {\n            ans = ans.max((candidates[i].0 - candidates[j].0).abs() + (candidates[i].1 - candidates[j].1).abs());\n        }\n    }\n    //println!(\"{:?} {:?} {}\", add, sub, ans);\n    //println!(\"{:?}\", add.len());\n    ans\n}\n\nfn remove(ps: &Vec<(i32, i32)>, target: (i32, i32, i32)) -> Vec<(i32, i32)> {\n    let mut ret = vec![];\n    let mut found = false;\n    for &(x, y) in ps {\n        if !found && x == target.1 && y == target.2 {\n            found = true;\n            continue;\n        }\n        ret.push((x, y));\n    }\n    ret\n}\n\nimpl Solution {\n    pub fn minimum_distance(points: Vec<Vec<i32>>) -> i32 {\n        let ps = points.into_iter().map(|v| (v[0], v[1])).collect::<Vec<_>>();\n        let mut add = ps.iter().map(|&(x, y)| (x + y, x, y)).collect::<Vec<_>>();\n        let mut sub = ps.iter().map(|&(x, y)| (x - y, x, y)).collect::<Vec<_>>();\n        add.sort_unstable();\n        sub.sort_unstable();\n        let mut ans = i32::MAX;\n        let ps1 = remove(&ps, add[0]);\n        let ps2 = remove(&ps, add[add.len() - 1]);\n        let ps3 = remove(&ps, sub[0]);\n        let ps4 = remove(&ps, sub[sub.len() - 1]);\n        ans = ans.min(solve(ps1));\n        ans = ans.min(solve(ps2));\n        ans = ans.min(solve(ps3));\n        ans = ans.min(solve(ps4));\n        ans\n    }\n}"
}