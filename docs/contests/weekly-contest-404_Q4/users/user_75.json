{
    "username": "plus2047",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int m = edges1.size() + 1, n = edges2.size() + 1;\n        vector<vector<int>> g1(m), g2(n);\n        build(edges1, g1);\n        build(edges2, g2);\n        int diam1 = diam_dfs(g1, 0, -1).second, diam2 = diam_dfs(g2, 0, -1).second;\n        return max({diam1, diam2, (diam1 + 1) / 2 + (diam2 + 1) / 2 + 1});\n    }\n    pair<int, int> diam_dfs(vector<vector<int>>& g, int curr, int last) {\n        int depth1 = -1, depth2 = -1, diam = 0;\n        for(auto& child: g[curr]) {\n            if(child != last) {\n                auto p = diam_dfs(g, child, curr);\n                diam = max(diam, p.second);\n                if(p.first > depth1) {\n                    depth2 = depth1;\n                    depth1 = p.first;\n                } else if (p.first > depth2) {\n                    depth2 = p.first;\n                }\n            }\n        }\n        if(depth1 == -1 and depth2 == -1) {\n            return {0, 0};\n        } else if(depth2 == -1) {\n            return {depth1 + 1, max(diam, depth1 + 1)};\n        } else {\n            return {depth1 + 1, max(diam, depth1 + depth2 + 2)};\n        }\n    }\n    void build(vector<vector<int>>& edges, vector<vector<int>>& g) {\n        for(auto& e: edges) {\n            g[e[0]].push_back(e[1]);\n            g[e[1]].push_back(e[0]);\n        }\n    }\n};",
    "submit_ts": 1719717021.0
}