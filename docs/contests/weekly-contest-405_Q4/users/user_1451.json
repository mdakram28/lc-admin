{
    "username": "angeredgecko",
    "submission": "#pragma GCC optimize(\"O3\",\"unroll-loop\")\nauto init =[]()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 'c';\n}();\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntypedef uint64_t ull;\nstruct H {\n\tull x; H(ull x=0) : x(x) {}\n\tH operator+(H o) { return x + o.x + (x + o.x < x); }\n\tH operator-(H o) { return *this + ~o.x; }\n\tH operator*(H o) { auto m = (__uint128_t)x * o.x;\n\t\treturn H((ull)m) + (ull)(m >> 64); }\n\tull get() const { return x + !~x; }\n\tbool operator==(H o) const { return get() == o.get(); }\n\tbool operator<(H o) const { return get() < o.get(); }\n};\nstatic const H C = (ll)1e11+3; // (order ~ 3e9; random also ok)\n\nstruct HashInterval {\n\tvector<H> ha, pw;\n\tHashInterval(string& str) : ha(sz(str)+1), pw(ha) {\n\t\tpw[0] = 1;\n\t\trep(i,0,sz(str))\n\t\t\tha[i+1] = ha[i] * C + str[i],\n\t\t\tpw[i+1] = pw[i] * C;\n\t}\n\tH hashInterval(int a, int b) { // hash [a, b)\n\t\treturn ha[b] - ha[a] * pw[b - a];\n\t}\n};\n\nH hashString(string& s){H h{}; for(char c:s) h=h*C+c;return h;}\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        // sort(words.begin(), words.end(), [](const auto &a, const auto &b) {return a.size() > b.size();});\n        unordered_map<string, int> mp;\n        for (int i = 0; i < words.size(); i++) {\n            if (mp.count(words[i])) mp[words[i]] = min(mp[words[i]], costs[i]);\n            else mp[words[i]] = costs[i];\n        }\n        // len, word_idxes\n        map<int, vector<int>> words_by_len_mp;\n        vector<string> words2;\n        vector<int> costs2;\n        for (auto [k, v] : mp) {\n            words_by_len_mp[k.size()].push_back(words2.size());\n            words2.push_back(k);\n            costs2.push_back(v);\n        }\n        words = words2;\n        costs = costs2;\n        vector<H> hashes(words.size());\n        for (int i = 0; i < words.size(); i++) {\n            hashes[i] = hashString(words[i]);\n        }\n        vector<pair<int, unordered_map<ull, int>>> words_by_len;\n        for (auto &[k, v] : words_by_len_mp) {\n            unordered_map<ull, int> hashes_set;\n            for (auto idx : v) {\n                hashes_set.insert({hashes[idx].get(), costs[idx]});\n            }\n            words_by_len.push_back(make_pair(k, hashes_set));\n        }\n        HashInterval interval(target);\n        ll INF = (ll)INT_MAX * 100;\n        vector<ll> dp(target.size() + 1, INF);\n        dp[0] = 0;\n        // for (int i = 1; i <= target.size(); i++) {\n        //     for (int j = 0; j < words.size(); j++) {\n        //         if (i-(int)words[j].size() < 0) continue;\n        //         if (dp[i - (int)words[j].size()] + costs[j] >= dp[i]) continue;\n        //         if (interval.hashInterval(i-1+1-(int)words[j].size(), i) == hashes[j]) dp[i] = dp[i - (int)words[j].size()] + costs[j];\n        //         // if (words[j] == target.substr(i-1+1-(int)words[j].size(), words[j].size())) dp[i] = dp[i - (int)words[j].size()] + costs[j];\n        //     }\n        // }\n        for (int i = 1; i <= target.size(); i++) {\n            for (const auto &[len, word_idxes] : words_by_len) {\n                if (i - len < 0) continue;\n                H hash = interval.hashInterval(i-1+1-len, i);\n                if (word_idxes.count(hash.get())) {\n                    dp[i] = min(dp[i], dp[i - len] + word_idxes.at(hash.get()));\n                }\n            }\n        }\n        if (dp.back() == INF) return -1;\n        return dp.back();\n    }\n};",
    "submit_ts": "1720323324",
    "subm_id": "1312372800"
}