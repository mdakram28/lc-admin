{
    "username": "lost-temple-2",
    "submission": "public class Solution {\n    public int[] ShortestDistanceAfterQueries(int n, int[][] queries) {\n        int q = queries.Length;\n        Treap<int> treap = new Treap<int>((a,b) => {\n           return a-b; \n        });\n        for (int i=0;i<n;i++) {\n            treap.Insert(i);\n        }\n        int[] ans = new int[q];\n        for (int i=0;i<q;i++) {\n            int a = queries[i][0],b = queries[i][1];\n            int lower = -1,upper = -1;\n            bool res = treap.LowerBound(a+1,ref lower);\n            if (res) {\n                res = treap.UpperBound(b-1,ref upper);\n                if (res && lower <= upper) {\n                    int r0 = treap.Rank(lower);\n                    int r1 = treap.Rank(upper);\n                    for (int j=r0;j<=r1;j++) {\n                        treap.Delete(treap.GetValueByRank(r0));\n                    }\n                }\n            }\n            ans[i] = treap.Count-1;\n        }\n        return ans;\n    }\n    \n    class Treap<T> : IEnumerable<T>\n    {\n        private class TreapNode\n        {\n            public T val;\n            public long seed;\n            public int size;\n            public int count;\n            public TreapNode left;\n            public TreapNode right;\n\n            public TreapNode(T v, long seed)\n            {\n                this.val = v;\n                this.seed = seed;\n                this.count = 1;\n                this.size = 1;\n            }\n\n            public TreapNode LeftRotate()\n            {\n                int preSize = size;\n                int curSize = count + (left == null ? 0 : left.size) + (right.left == null ? 0 : right.left.size);\n                TreapNode newRoot = this.right;\n                this.right = newRoot.left;\n                newRoot.left = this;\n                newRoot.size = preSize;\n                size = curSize;\n                return newRoot;\n            }\n\n            public TreapNode RightRotate()\n            {\n                int preSize = size;\n                int curSize = count + (left.right == null ? 0 : left.right.size) + (right == null ? 0 : right.size);\n                TreapNode newRoot = this.left;\n                this.left = newRoot.right;\n                newRoot.right = this;\n                newRoot.size = preSize;\n                size = curSize;\n                return newRoot;\n            }\n\n            /// <summary>\n            /// recalculate size for current node\n            /// </summary>\n            public void RecalSize()\n            {\n                size = count + (left != null ? left.size : 0) + (right != null ? right.size : 0);\n            }\n        }\n\n        internal sealed class TreapRandom\n        {\n            private const int MOD = int.MaxValue;\n            private int _seed;\n\n            public TreapRandom(int seed = 703)\n            {\n                _seed = seed;\n            }\n\n            public int NextInt()\n            {\n                _seed = (int)((_seed * 48271L) % MOD);\n                return _seed;\n            }\n        }\n\n        internal sealed class MyComparer<W> : IComparer<W>\n        {\n            private Comparison<W> _comparision;\n\n            public MyComparer(Comparison<W> comparision)\n            {\n                _comparision = comparision;\n            }\n\n            public int Compare(W x, W y)\n            {\n                return _comparision(x, y);\n            }\n        }\n\n        private TreapNode _root;\n        private int _size;\n        private TreapRandom rand;\n        private IComparer<T> _comparer;\n\n        public Treap()\n            : this(Comparer<T>.Default)\n        {\n\n        }\n\n        public Treap(Comparison<T> comparison)\n            : this(new MyComparer<T>(comparison))\n        {\n\n        }\n\n        public Treap(IComparer<T> comparer)\n        {\n            _root = null;\n            _size = 0;\n            rand = new TreapRandom(1849);\n            _comparer = comparer == null ? Comparer<T>.Default : comparer;\n        }\n\n        public int Count\n        {\n            get { return _size; }\n        }\n\n        public bool LowerBound(T val, ref T lowerKey)\n        {\n            bool res = false;\n            TreapNode current = _root;\n            while (current != null)\n            {\n                int cmpRes = _comparer.Compare(val, current.val);\n                if (cmpRes > 0)\n                {\n                    current = current.right;\n                }\n                else if (cmpRes < 0)\n                {\n                    res = true;\n                    lowerKey = current.val;\n                    current = current.left;\n                }\n                else\n                {\n                    res = true;\n                    lowerKey = current.val;\n                    break;\n                }\n            }\n            return res;\n        }\n\n        public bool UpperBound(T val, ref T upperKey)\n        {\n            bool res = false;\n            TreapNode current = _root;\n            while (current != null)\n            {\n                int cmpRes = _comparer.Compare(val, current.val);\n                if (cmpRes < 0)\n                {\n                    current = current.left;\n                }\n                else if (cmpRes > 0)\n                {\n                    res = true;\n                    upperKey = current.val;\n                    current = current.right;\n                }\n                else\n                {\n                    res = true;\n                    upperKey = current.val;\n                    break;\n                }\n            }\n            return res;\n        }\n\n        public T GetValueByRank(int rank)\n        {\n            if (rank <= 0 || rank > _size)\n            {\n                throw new Exception(\"Rank can not be lower than 0 or higher than treap size\");\n            }\n            TreapNode current = _root;\n            int leftRank = current.left == null ? 0 : current.left.size;\n            int rightRank = leftRank + current.count;\n            while (rank <= leftRank || rank > rightRank)\n            {\n                if (rank <= leftRank)\n                {\n                    current = current.left;\n                }\n                else\n                {\n                    rank -= rightRank;\n                    current = current.right;\n                }\n                leftRank = current.left == null ? 0 : current.left.size;\n                rightRank = leftRank + current.count;\n            }\n            return current.val;\n        }\n\n        /// <summary>\n        /// \n        /// </summary>\n        /// <param name=\"val\"></param>\n        /// <param name=\"equal\"></param>\n        /// <returns></returns>\n        public int Rank(T val, bool isEqual = false)\n        {\n            int ans = 0;\n            TreapNode current = _root;\n            while (current != null)\n            {\n                int cmpRes = _comparer.Compare(current.val, val);\n                if (cmpRes > 0)\n                {\n                    current = current.left;\n                }\n                else\n                {\n                    ans += (current.left != null ? current.left.size : 0);\n                    if (cmpRes == 0)\n                    {\n                        return ans + (isEqual ? current.count : 1);\n                    }\n                    ans += current.count;\n                    current = current.right;\n                }\n            }\n            return ans;\n        }\n\n        public void Insert(T val)\n        {\n            _root = Insert(_root, val);\n            _size = _root.size;\n        }\n\n        public bool Contains(T key)\n        {\n            TreapNode current = _root;\n            while (current != null)\n            {\n                int cmpRes = _comparer.Compare(key, current.val);\n                if (cmpRes == 0)\n                {\n                    return true;\n                }\n                else if (cmpRes < 0)\n                {\n                    current = current.left;\n                }\n                else\n                {\n                    current = current.right;\n                }\n            }\n            return false;\n        }\n\n        public void Delete(T key)\n        {\n            _root = Delete(_root, key);\n            _size = _root == null ? 0 : _root.size;\n        }\n\n        private TreapNode Delete(TreapNode node, T key)\n        {\n            if (node == null)\n            {\n                return null;\n            }\n            int cmpRes = _comparer.Compare(node.val, key);\n            if (cmpRes < 0)\n            {\n                node.right = Delete(node.right, key);\n                node.RecalSize();\n            }\n            else if (cmpRes > 0)\n            {\n                node.left = Delete(node.left, key);\n                node.RecalSize();\n            }\n            else\n            {\n                if (node.count > 1)\n                {\n                    node.count--;\n                    node.RecalSize();\n                    return node;\n                }\n                if (node.left == null)\n                {\n                    return node.right;\n                }\n                if (node.right == null)\n                {\n                    return node.left;\n                }\n                if (node.left.seed < node.right.seed)\n                {\n                    node = node.RightRotate();\n                    node.right = Delete(node.right, key);\n                    node.RecalSize();\n                }\n                else\n                {\n                    node = node.LeftRotate();\n                    node.left = Delete(node.left, key);\n                    node.RecalSize();\n                }\n            }\n            return node;\n        }\n\n        private TreapNode Insert(TreapNode node, T key)\n        {\n            if (node == null)\n            {\n                return new TreapNode(key, rand.NextInt());\n            }\n            int res = _comparer.Compare(node.val, key);\n            if (res == 0)\n            {\n                node.count++;\n                node.RecalSize();\n            }\n            else if (res < 0)\n            {\n                node.right = Insert(node.right, key);\n                node.RecalSize();\n                if (node.right.seed < node.seed)\n                {\n                    node = node.LeftRotate();\n                }\n            }\n            else\n            {\n                node.left = Insert(node.left, key);\n                node.RecalSize();\n                if (node.left.seed < node.seed)\n                {\n                    node = node.RightRotate();\n                }\n            }\n            return node;\n        }\n\n        public T this[int idx]\n        {\n            get\n            {\n                return GetValueByRank(idx + 1);\n            }\n        }\n\n        IEnumerator IEnumerable.GetEnumerator()\n        {\n            if (_root == null)\n            {\n                yield break;\n            }\n            Stack<TreapNode> stack = new Stack<TreapNode>();\n            stack.Push(_root);\n            while (stack.Count > 0)\n            {\n                TreapNode current = stack.Pop();\n                if (current == null)\n                {\n                    current = stack.Pop();\n                    yield return current.val;\n                }\n                else\n                {\n                    if (current.right != null)\n                    {\n                        stack.Push(current.right);\n                    }\n                    stack.Push(current);\n                    stack.Push(null);\n                    if (current.left != null)\n                    {\n                        stack.Push(current.left);\n                    }\n                }\n            }\n        }\n\n        public IEnumerator<T> GetEnumerator()\n        {\n            if (_root == null)\n            {\n                yield break;\n            }\n            Stack<TreapNode> stack = new Stack<TreapNode>();\n            stack.Push(_root);\n            while (stack.Count > 0)\n            {\n                TreapNode current = stack.Pop();\n                if (current == null)\n                {\n                    current = stack.Pop();\n                    yield return current.val;\n                }\n                else\n                {\n                    if (current.right != null)\n                    {\n                        stack.Push(current.right);\n                    }\n                    stack.Push(current);\n                    stack.Push(null);\n                    if (current.left != null)\n                    {\n                        stack.Push(current.left);\n                    }\n                }\n            }\n        }\n    }\n}",
    "submit_ts": "1722740002",
    "subm_id": "552328596"
}