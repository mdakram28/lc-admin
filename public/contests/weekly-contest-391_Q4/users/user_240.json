{
    "username": "prayoffer",
    "submission": "class Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        def max_manhattan_distance(points):\n            transformed = [[], [], [], []]\n            for index in range(len(points)):\n                x, y = points[index]\n                transformed[0].append([x + y, index])\n                transformed[1].append([x - y, index])\n                transformed[2].append([-x + y, index])\n                transformed[3].append([-x - y, index])\n\n            max_distance = float('-inf')\n            max_points = None\n            for form in transformed:\n                form.sort(key=lambda x:x[0])\n                if  form[-1][0] - form[0][0] > max_distance:\n                    max_distance = form[-1][0] - form[0][0]\n                    max_points = [points[form[-1][1]], points[form[0][1]]]\n\n            return max_distance, max_points\n        \n        max_distance, max_points = max_manhattan_distance(points)\n        #print(max_points)\n        temp = [i for i in points]\n        for i in range(len(temp)):\n            if temp[i] == max_points[0]:\n                temp.pop(i)\n                break\n        m1, _ = max_manhattan_distance(temp)\n        temp = [i for i in points]\n        for i in range(len(temp)):\n            if temp[i] == max_points[1]:\n                temp.pop(i)\n                break\n        m2, _ = max_manhattan_distance(temp)\n        return min(m1, m2)"
}