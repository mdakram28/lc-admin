{
    "username": "424479543",
    "submission": "#include <bits/stdc++.h>\n#include <unistd.h>\n#ifdef _LOCAL_\n#define debug(args...) print(\"[line:\", __LINE__, \":\" #args \"]\", ##args)\n#else\n#define debug(...) 666\n#endif\n#define all(a) a.begin(), a.end()\nusing namespace std;using llong = long long;\n#define to(container, a) [](auto &&A) { return container(all(A)); }(a)\ntemplate <typename... Args>llong pow(llong x, auto b, auto MOD) { if (b < 0) x = pow(x, MOD - 2, MOD), b = -b; if (not x) return x; llong res = 1; for (; b; (x *= x) %= MOD, b >>= 1) if (b & 1) (res *= x) %= MOD; return res;} //\ntemplate <typename T> T sum(auto &&a, T res) { for (auto x : a) res += x; return res;}//\ntemplate <typename T> llong sum(T &&a) { return sum(forward<T>(a), 0ll); }    //\ntemplate <typename T> T reversed(T a) { ranges::reverse(a); return a;} //\ntemplate <typename T> T uniqued(T a) { ranges::sort(a); a.resize(unique(begin(a), end(a)) - begin(a)); return a;} //\ntemplate <typename... Args>auto sorted(auto a, Args &&...args) { sort(begin(a), end(a), args...); return a;} //\ntemplate <typename T>vector<T> &operator+=(vector<T> &a, const vector<T> &b) { a.insert(end(a), begin(b), end(b)); return a;};template <typename T>vector<T> operator+(vector<T> a, const vector<T> &b) { return a += b; }; //\ntemplate <typename T>vector<T> &operator*=(vector<T> &a, int k) { if (k <= 0) a.clear(); else { assert(a.size() * k < INT_MAX); int N = a.size() * k; a.reserve(N); while (a.size() * 2 <= N) a += a; a.insert(end(a), begin(a), begin(a) + (N - a.size())); } return a;};template <typename T>vector<T> operator*(vector<T> a, int k) { return a *= k; }; //\nstruct range { struct Iterator { using iterator_category = std::random_access_iterator_tag; using value_type = int64_t; using difference_type = ptrdiff_t; using pointer = int64_t; using reference = int64_t &; int64_t val, d; Iterator(){}; Iterator(int64_t val, int64_t d) : val(val), d(d){}; value_type operator*() const { return val; } Iterator &operator++() { return val += d, *this; } difference_type operator-(const Iterator &other) const { return (val - other.val) / d; } bool operator==(const Iterator &other) const { return val == other.val; } }; Iterator Begin, End; range(int64_t n) : Begin(0, 1), End(max(n, int64_t{0}), 1){}; range(int64_t a, int64_t b, int64_t d = int64_t(1)) : Begin(a, d), End(b, d) { int64_t cnt = (b - a) / d + bool((b - a) % d); End.val = a + max(cnt, int64_t(0)) * d; }; Iterator begin() const { return Begin; } Iterator end() const { return End; }}; //\ntemplate <typename RET>auto make_vector(RET x) { return x; }template <typename T1, typename T2, typename... Args>auto make_vector(T1 m, T2 n, Args... arg) { return vector(m, make_vector(n, arg...)); }\n/* print */ template <typename Tuple, typename F, size_t... N> void TupleCall(Tuple &t, F &&f, std::index_sequence<N...>) { (f(get<N>(t)), ...); }template <typename... Args>std::ostream &operator<<(std::ostream &out, const std::tuple<Args...> &t) { TupleCall(t, [&](auto &&a) { out << a << ' '; }, make_index_sequence<sizeof...(Args)>{}); return out;}template <typename T1, typename T2>std::ostream &operator<<(std::ostream &out, const std::pair<T1, T2> &t) { return out << t.first << ' ' << t.second; }template <typename T>std::ostream &operator<<(std::ostream &out, const std::vector<T> &v) { for (size_t i = 0, n = v.size(); i < n; ++i) out << v[i] << ' '; return out;}template <typename T, typename... Args>void print(const T &t, const Args &...args) { cout << t; if constexpr (sizeof...(args)) { cout << ' '; print(args...); } else { cout << endl; }} //\nauto io = [](){return cin.tie(nullptr) -> sync_with_stdio(false);}();\n// ##########################################################################################\nint g(vector<vector<int>>& grid , int i0 , int i1, int j0 ,int j1){\n    int u = i1 , d = i0 , l = j1 , r = j0;\n    for(int i : range(i0,i1+1))\n        for(int j : range(j0,j1+1))\n            if(grid[i][j]){\n                u = min(i,u); l = min(j,l);\n                d = max(i,d); r = max(j,r);\n            }\n    if(d - u + 1 <= 0 or r - l + 1 <= 0) return 1;\n    return (d - u + 1) * (r - l + 1);\n}\nint f(vector<vector<int>>& grid){\n    int m = grid.size() , n = grid[0].size();\n    int res = INT_MAX;\n    for(int i : range(0,m-1)){\n        int s1 = g(grid, 0, i , 0 , n - 1);\n        for(int j : range(0,n-1)){\n            int s2 = g(grid, i + 1, m - 1, 0 , j);\n            int s3 = g(grid, i + 1, m - 1, j+1, n-1);\n            res = min(res, s1 + s2 + s3);\n        }\n    }\n    for(int i : range(0,m-2)){\n        int s1 = g(grid, 0, i , 0 , n - 1);\n        for(int i2 : range(i+1,m-1)){\n            int s2 = g(grid, i+1, i2 , 0 , n - 1);\n            int s3 = g(grid, i2+1, m - 1 , 0 , n - 1);\n            res = min(res, s1 + s2 + s3);\n        }\n    }\n    return res;\n}\nclass Solution {\npublic:\n    int minimumSum(vector<vector<int>>& grid) {\n        auto g0 = grid;\n        int m = grid.size() , n = grid[0].size();\n        auto g1 = make_vector(n,m,0);\n        for(int i : range(m)) for(int j : range(n)) g1[j][i] = g0[i][j]; \n        int r1 = min(f(g0),f(g1));\n        ranges::reverse(g0);\n        ranges::reverse(g1);\n        int r2 = min(f(g0),f(g1));\n        return min(r1,r2);\n    }\n};\n\n// ##########################################################################################\n#ifdef OY_LOCAL\n#include \"./other/FastIO.h\"\n#include \"./other/LeetcodeIO.h\"\nint main() {\n    REGISTER_CONSTRUCTOR_SOLUTION;                             // \u672c\u884c\u586b\u5199\u7c7b\u540d\u3001\u6784\u9020\u51fd\u6570\u7684\u6240\u6709\u53c2\u6570\u7c7b\n    REGISTER_MEMBERFUNCTION_SOLUTION(minimumSum); // \u672c\u884c\u586b\u5199\u7c7b\u540d\u3001\u8981\u8c03\u7528\u7684\u6210\u5458\u65b9\u6cd5\u540d\n    while (true) {\n        executor.constructSolution();\n        executor.executeSolution();\n    }\n}\n#endif",
    "submit_ts": 1719111575.0
}