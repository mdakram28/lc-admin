{
    "username": "C9CQEmG9jl",
    "submission": "class Solution {\npublic:\n    struct Node {\n        vector<pair<int, int>> wordEnds; \n        unordered_map<char, Node*> children;\n        \n    };\n\n    class Trie {\n    public:\n        Node* rootNode;\n        Trie() { rootNode = new Node(); }\n\n        void insertWord(string& word, int index, int cost) {\n            Node* currentNode = rootNode;\n            for (char ch : word) {\n                if (!currentNode->children.count(ch))\n                    currentNode->children[ch] = new Node();\n                currentNode = currentNode->children[ch];\n            }\n            currentNode->wordEnds.push_back({index, cost});\n        }\n\n        Node* getRootNode() {\n            return rootNode;\n        }\n    };\n\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int sizeOfTarget = target.size();\n        vector<int> dp(sizeOfTarget + 1, INT_MAX);\n        dp[0] = 0;\n        \n        Trie wordTrie;\n        buildTrie(wordTrie, words, costs);\n        \n        \n\n        for (int i = 0; i < sizeOfTarget; ++i) {\n            if (dp[i] == INT_MAX) continue;\n\n            Node* currentNode = wordTrie.getRootNode();\n            traverseTarget(target, i, sizeOfTarget, currentNode, dp, words);\n        }\n\n        return dp[sizeOfTarget] == INT_MAX ? -1 : dp[sizeOfTarget];\n    }\n\n    \nprivate:\n    void buildTrie(Trie& trie, vector<string>& words, vector<int>& costs) {\n        for (int i = 0; i < words.size(); ++i) {\n            trie.insertWord(words[i], i, costs[i]);\n        }\n    }\n\n    void traverseTarget(string& target, int startIndex, int sizeOfTarget, Node* currentNode, vector<int>& dp, vector<string>& words) {\n        for (int j = startIndex; j < sizeOfTarget; ++j) {\n            if (!currentNode->children.count(target[j])) break;\n            currentNode = currentNode->children[target[j]];\n            for (auto& pair : currentNode->wordEnds) {\n                int wordIndex = pair.first;\n                int wordLength = words[wordIndex].size();\n                int wordCost = pair.second;\n                \n                \n                if (startIndex + wordLength <= sizeOfTarget) {\n                    dp[startIndex + wordLength] = min(dp[startIndex + wordLength], dp[startIndex] + wordCost);\n                }\n            }\n        }\n    }\n};",
    "submit_ts": "1720324316",
    "subm_id": "1312396564"
}