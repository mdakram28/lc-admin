{
    "username": "LQnVRuiNVr",
    "submission": "class Solution:\n    def bfs(self, graph, start, targets, nodes):\n        q = deque([start])\n        visited = [0] * (nodes + 4)\n        visited[start] = 1\n        \n        while q:\n            u = q.popleft()\n            for v in graph[u]:\n                if not visited[v]:\n                    q.append(v)\n                    visited[v] = 1\n\n        return any(visited[target] for target in targets)\n\n    def build_graph(self, X, Y, circles):\n        n = len(circles)\n        graph = [[] for _ in range(n + 4)]\n        \n        for i, (x, y, r) in enumerate(circles):\n            if x <= r:\n                graph[n].append(i)\n                graph[i].append(n)\n            if X - x <= r:\n                graph[n + 2].append(i)\n                graph[i].append(n + 2)\n            if y <= r:\n                graph[n + 1].append(i)\n                graph[i].append(n + 1)\n            if Y - y <= r:\n                graph[n + 3].append(i)\n                graph[i].append(n + 3)\n            \n            for k in range(i + 1, n):\n                x2, y2, r2 = circles[k]\n                distance = sqrt((x - x2) ** 2 + (y - y2) ** 2)\n                radius_sum = r + r2\n                if radius_sum >= distance:\n                    graph[i].append(k)\n                    graph[k].append(i)\n        \n        return graph\n\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        n = len(circles)\n        graph = self.build_graph(X, Y, circles)\n\n        if self.bfs(graph, n, [n + 1, n + 2], n + 4) or self.bfs(graph, n + 3, [n + 2, n + 1], n + 4):\n            return False\n        return True\n",
    "submit_ts": "1722136829",
    "subm_id": "1335746179"
}