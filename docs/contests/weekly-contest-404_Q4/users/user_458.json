{
    "username": "user3355Kb",
    "submission": "int find_center(vector<vector<int>>& edges){\n    int n = edges.size() + 1;\n    vector<vector<int>> graph(n);\n    for(auto edge: edges){\n        graph[edge[0]].push_back(edge[1]);\n        graph[edge[1]].push_back(edge[0]);\n    }    \n    unordered_map<int, int> cnt;\n    vector<int> leaves;\n    for(int i=0; i<graph.size(); i++){\n        cnt[i] = graph[i].size();\n        if(cnt[i] == 1){\n            leaves.push_back(i);\n        }\n    }\n    unordered_set<int> center;\n    for(int i=0; i<n; i++){\n        center.insert(i);\n    }\n    while(center.size() > 2){\n        vector<int> n_leaves;\n        for(auto leave: leaves){\n            center.erase(leave);\n            for(auto &v: graph[leave]){\n                cnt[v] -= 1;\n                if(cnt[v] == 1){\n                    n_leaves.push_back(v);\n                }\n            }\n        }\n        leaves = n_leaves;\n    }\n    return *center.begin();\n}\n\n\nint dfs(int current, int prev, vector<vector<int>> &graph, int &res){\n    int l = 1;\n    int second_largest = -1;\n    int first_largest = -1;\n\n\n    for(auto &u: graph[current]){\n        if(u != prev){\n            l = 0;\n            int r = dfs(u, current,  graph, res) + 1;\n            \n            \n            if(first_largest == -1){\n                first_largest = r;\n            }\n            else if(first_largest < r){\n                second_largest = first_largest;\n\n                first_largest = r;\n            }\n            else{\n                second_largest = max(second_largest, r);\n            }\n        }\n    }\n    if(l){\n        return 0;\n    }\n    if(second_largest == -1){\n        res = max(first_largest, res);\n    }\n    else{\n        res = max(second_largest + first_largest, res);\n    }\n    \n    return first_largest;\n}\n\nint dia(vector<vector<int>>& edges){\n    int n = edges.size() + 1;\n    vector<vector<int>> graph(n);\n    for(auto edge: edges){\n        graph[edge[0]].push_back(edge[1]);\n        graph[edge[1]].push_back(edge[0]);\n    }    \n\n    \n    int res = 0;\n    dfs(0, 0, graph, res);\n    \n    return res;\n}\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        vector<vector<int>> edges;\n        for(auto edge: edges1){\n            edges.push_back(edge);\n        }\n        for(auto edge: edges2){\n            edge[0] += n;\n            edge[1] += n;\n            edges.push_back(edge);\n        }\n        cout << find_center(edges1) << \" \" << find_center(edges2)<<endl;\n        edges.push_back({find_center(edges1), find_center(edges2) + n});\n        \n        return dia(edges);\n\n        // unordered_set<int> leaves;\n\n\n    }\n};",
    "submit_ts": "1719718399",
    "subm_id": "1304416264"
}