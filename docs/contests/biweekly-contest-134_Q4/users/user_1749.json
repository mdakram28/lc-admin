{
    "username": "rshashank9959",
    "submission": "class Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        unordered_map<int, int> count; // To store the count of previous results\n        int currentAnd = 0;\n        long long result = 0;\n        \n        for (int num : nums) {\n            unordered_map<int, int> newCount; // To store current results\n            \n            // Check if the current element itself equals k\n            if (num == k) {\n                ++result; // Single element subarray\n            }\n            \n            // Iterate through previous results\n            for (auto& p : count) {\n                int newAnd = p.first & num;\n                \n                // If the new AND result equals k, update the result count\n                if (newAnd == k) {\n                    result += p.second;\n                }\n                \n                // Update current results map\n                newCount[newAnd] += p.second;\n            }\n            \n            // Update current results map for the current element\n            ++newCount[num];\n            \n            // Replace count with newCount for the next iteration\n            count = move(newCount);\n        }\n        \n        return result;\n    }\n};\n",
    "submit_ts": "1720278648",
    "subm_id": "1311718274"
}