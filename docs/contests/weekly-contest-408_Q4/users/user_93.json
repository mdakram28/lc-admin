{
    "username": "plevande",
    "submission": "class Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        #(x1)^2+(y-y1)^2 <=r1^2\n        n = len(circles)\n        g = [[] for i in range(n+4)]\n        for i in range(n):\n            #x in [0, X]\n            #y in [0, Y]\n            #n = x=0\n            #n+1 = x=X\n            #n+2 = y=0\n            #n+3 = y=Y\n            #all bad except\n            #n to n+3\n            #and\n            #n+1 to n+2\n            x1, y1, r1 = circles[i]\n        \n            #if x1*x1 <= r1*r1:\n            #    if 0 <= y1+(r1*r1-x1*x1)**0.5 <= Y or 0 <= y1-(r1*r1-x1*x1)**0.5 <= Y:\n            #x=0, y=y1\n            #say you are trying to minimize\n            #(x-x1)**2+(y-y1)**2\n            #on the line \n            #x=0\n            #\n            if 0 <= y1 <= Y and (0-x1)*(0-x1) <= r1*r1:\n                g[n].append(i)\n                g[i].append(n)\n            if 0 <= y1 <= Y and (X-x1)*(X-x1) <= r1*r1:\n                g[n+1].append(i)\n                g[i].append(n+1)\n            if 0 <= x1 <= X and (0-y1)*(0-y1) <= r1*r1:\n                g[n+2].append(i)\n                g[i].append(n+2)\n            if 0 <= x1 <= X and (Y-y1)*(Y-y1) <= r1*r1:\n                g[n+3].append(i)\n                g[i].append(n+3)\n            if (0-x1)*(0-x1)+(0-y1)*(0-y1) <= r1*r1:\n                g[n].append(i)\n                g[i].append(n)\n                g[i].append(n+2)\n                g[n+2].append(i)\n            if (0-x1)*(0-x1)+(Y-y1)+(Y-y1) <= r1*r1:\n                g[n].append(i)\n                g[i].append(n)\n                g[n+3].append(i)\n                g[i].append(n+3)\n            if (X-x1)*(X-x1)+(0-y1)*(0-y1) <= r1*r1:\n                g[n+1].append(i)\n                g[i].append(n+1)\n                g[n+2].append(i)\n                g[i].append(n+2)\n            if (X-x1)*(X-x1)+(Y-y1)*(Y-y1) <= r1*r1:\n                g[n+1].append(i)\n                g[i].append(n+1)\n                g[n+3].append(i)\n                g[i].append(n+3)\n            for j in range(i+1, n):\n                x2, y2, r2 = circles[j]\n                connected = False\n                if (x1-x2)**2+(y1-y2)**2 <= min(r1,r2)**2:\n                    connected = True\n                else:\n                    if (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2:\n                        connected = True\n                if connected:\n                    g[i].append(j)\n                    g[j].append(i)\n        def find_root(root_dict, x):\n            L = []\n            while x != root_dict[x]:\n                L.append(x)\n                x = root_dict[x]\n            for y in L:\n                root_dict[y] = x\n            return x \n        root_dict = [i for i in range(n+4)]\n        for i in range(n+4):\n            for j in g[i]:\n                i1 = find_root(root_dict, i)\n                j1 = find_root(root_dict, j)\n                root_dict[j1]= i1\n       # print(g)\n        r1 = find_root(root_dict, n)\n        r2 = find_root(root_dict, n+1)\n        r3 = find_root(root_dict, n+2)\n        r4 = find_root(root_dict, n+3)\n        print(r1, r2,r3,r4)\n        #r1=r3 ok, r2=r4 ok\n        if r1==r2 or r1==r3 or r2==r4 or r3==r4:\n            return False\n        return True",
    "submit_ts": "1722137835",
    "subm_id": "1335775036"
}