{
    "username": "Mikaalm",
    "submission": "class Trie {\npublic:\n    int isEnd;\n    vector<Trie*> childs;\n    Trie() : childs(26), isEnd(0) {}\n    \n    /** Inserts a word into the trie. */\n    void insert(string word, int c) {\n        Trie* p = this;\n        for (auto &ch : word) {\n            int idx = ch - 'a';\n            if (!p->childs[idx]) p->childs[idx] = new Trie();\n            p = p->childs[idx]; \n        }\n        p->isEnd = c;\n    }\n    \n    /** Returns if the word is in the trie. */\n    bool search(string &target, int i) {\n        Trie *p = this;\n        for (; i < target.size(); ++i) {\n            int idx = target[i] - 'a';\n            if (!p->childs[idx]) return false;\n            p = p->childs[idx];\n        }\n        return p->isEnd;\n    }\n    \n    /** Returns if there is any word in the trie that starts with the given prefix. */\n    bool startsWith(string prefix) {\n        Trie *p = this;\n        for (auto &ch : prefix) {\n            int idx = ch - 'a';\n            if (!p->childs[idx]) return false;\n            p = p->childs[idx];\n        }\n        return true;\n    }\n};\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int n = target.size();\n        vector<int> dp(n, -1);\n        unordered_map<string, int> w_cnt;\n        for (int i = 0; i < words.size(); ++i) {\n            if (w_cnt.count(words[i]))\n                w_cnt[words[i]] = min(w_cnt[words[i]], costs[i]);\n            else\n                w_cnt[words[i]] = costs[i];\n        }\n        auto check = [&] (auto const &i, auto const &n, auto const &w) {\n            for (int j = 0; j < n; ++j) {\n                if (target[i + j] != w[j]) return true;\n            }  \n            return false;\n        };\n        auto t = Trie();\n        for (auto &[w, c] : w_cnt) {\n            t.insert(w, c);\n        }\n        for (int i = -1; i < n - 1; ++i) {\n            if (i != -1 && dp[i] == -1) continue;\n            Trie *p = &t;\n            int j = i + 1;\n            for (; j < target.size(); ++j) {\n                int idx = target[j] - 'a';\n                if (!p->childs[idx]) break;\n                p = p->childs[idx];\n                \n                if (p->isEnd != 0) {\n                    if (dp[j] == -1) \n                        dp[j] = (i < 0 ? 0 : dp[i]) + p->isEnd;\n                    else \n                        dp[j] = min(dp[j], (i < 0 ? 0 : dp[i]) + p->isEnd);\n                }\n            }\n            // for (auto &[w, c] : w_cnt) {\n            //     int ws = w.size();\n            //     if (i + ws >= n) continue;\n            //     if (check(i + 1, ws, w)) continue;\n            //     if (dp[i + ws] == -1) \n            //         dp[i + ws] = (i < 0 ? 0 : dp[i]) + c;\n            //     else \n            //         dp[i + ws] = min(dp[i + ws], (i < 0 ? 0 : dp[i]) + c);\n            // }\n        }\n        return dp[n - 1];\n    }\n};",
    "submit_ts": "1720323839",
    "subm_id": "1312385273"
}