{
    "username": "\u65cc\u5e74",
    "submission": "struct segment_tree {\n#define MAXN 3000007\n#define int long long\n    int t[MAXN] = { 0 }, tag[MAXN] = { 0 };\n    int ln(int p) {\n        return p << 1;\n    }\n    int rn(int p) {\n        return p << 1 | 1;\n    }\n    void pushup(int p) {\n        t[p] = t[ln(p)] + t[rn(p)];\n    }\n    void f(int l, int r, int p, int c) {\n        t[p] += (r - l + 1) * c;\n        tag[p] += c;\n    }\n    void pushdown(int l, int r, int p) {\n        int mid = l + (r - l) / 2;\n        f(l, mid, ln(p), tag[p]);\n        f(mid + 1, r, rn(p), tag[p]);\n        tag[p] = 0;\n    }\n    void build(int l, int r, int p) {\n        if(l == r) {\n            t[p] = 0;\n            return;\n        }\n        int mid = l + (r - l) / 2;\n        build(l, mid, ln(p));\n        build(mid + 1, r, rn(p));\n        pushup(p);\n    }\n    void clear(int n) {\n        memset(t, 0, sizeof(int) * (n + 10) * 4);\n        memset(tag, 0, sizeof(int) * (n + 10) * 4);\n    }\n    void update(int cl, int cr, int l, int r, int p, int c) {\n        if(cl <= l && cr >= r) {\n            f(l, r, p, c);\n            return;\n        }\n        int mid = l + (r - l) / 2;\n        if(tag[p]) pushdown(l, r, p);\n        if(cl <= mid) update(cl, cr, l, mid, ln(p), c);\n        if(cr > mid) update(cl, cr, mid + 1, r, rn(p), c);\n        pushup(p);\n    }\n    int qry(int ql, int qr, int l, int r, int p) {\n        if(ql <= l && qr >= r) {\n            return t[p];\n        }\n        int mid = l + (r - l) / 2, ans = 0;\n        if(tag[p]) pushdown(l, r, p);\n        if(ql <= mid) ans += qry(ql, qr, l, mid, ln(p));\n        if(qr > mid) ans += qry(ql, qr, mid + 1, r, rn(p));\n        return ans;\n    }\n#undef MAXN\n#undef int\n};\n\nsegment_tree sgt;\n\nclass Solution {\npublic:\n    int get_r(int i, string& s, vector<pair<int, int>>& pre, int k) {\n        int l = i, r = s.size() - 1;\n        while(l < r) {\n            int m = (l + r + 1) >> 1;\n            int zem = pre[m].first - pre[i].first + (s[i] == '0');\n            int odm = pre[m].second - pre[i].second + (s[i] == '1');\n            if(zem <= k || odm <= k) {\n                l = m;\n            }else {\n                r = m - 1;\n            }\n        }\n        return l;\n    }\n    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n        int n = s.size(), q = queries.size();\n        sgt.clear(n + 2);\n        sgt.build(0, n - 1, 1);\n        map<int, vector<pair<int, int>>> mp;\n        vector<long long> ans(q);\n        vector<pair<int, int>> pre(n); // 0, 1\n        for(int i = 0; i < n; i ++ ) {\n            if(s[i] == '0') pre[i].first += 1;\n            else pre[i].second += 1;\n            if(i) {\n                pre[i].first += pre[i - 1].first;\n                pre[i].second += pre[i - 1].second;\n            }\n        }\n        for(int i = 0; i < q; i ++ ) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            mp[l].push_back({r, i});\n        }\n        vector<int> R;\n        for(int i = 0; i < n; i ++ ) {\n            int r = get_r(i, s, pre, k);\n            R.push_back(r);\n            sgt.update(i, r, 0, n - 1, 1, 1);\n        }\n        for(int i = 0; i < n; i ++ ) {\n            for(auto [r, j] : mp[i]) {\n                long long t = sgt.qry(i, r, 0, n - 1, 1);\n                ans[j] = t;\n            }\n            sgt.update(i, R[i], 0, n - 1, 1, -1);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1723952029",
    "subm_id": "556409187"
}