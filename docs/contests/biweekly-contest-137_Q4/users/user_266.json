{
    "username": "grainmad",
    "submission": "template<class t,class u> ostream& operator<<(ostream& os,const pair<t,u>& p) {\n    return os<<'['<<p.first<<\", \"<<p.second<<']';\n}\ntemplate<class t> ostream& operator<<(ostream& os,const vector<t>& v) {\n    os<<'['; int s = 1;\n    for(auto e:v) { if (s) s = 0; else os << \", \"; os << e; }\n    return os<<']';\n}\ntemplate<class t,class u> ostream& operator<<(ostream& os,const map<t,u>& mp){\n    os<<'{'; int s = 1;\n    for(auto [x,y]:mp) { if (s) s = 0; else os << \", \"; os<<x<<\": \"<<y; }\n    return os<<'}';\n}\nclass Solution {\npublic:\n    using ll = long long;\n    struct Node {\n        int x, y, z;\n        ll val;\n        Node(int x, int y, int z, ll val): x(x), y(y), z(z), val(val) {}\n        bool operator<(const Node& o) const {\n            return val < o.val;\n        }\n    };\n    long long maximumValueSum(vector<vector<int>>& board) {\n        int n = board.size(), m = board[0].size();\n        ll B = n*m;\n        vector<pair<int,int>> idx;\n        for (int i=0; i<n; i++) {\n            for (int j=0; j<m; j++) {\n                idx.emplace_back(i,j);\n            }\n        }\n        sort(idx.begin(), idx.end(), [&](auto x, auto y) {\n            return board[x.first][x.second] > board[y.first][y.second];\n        });\n        set<string> st;\n        auto enc = [&](ll x, ll y) {\n            return x*m+y;\n        };\n        auto encode = [&](int x, int y, int z) {\n            ll a = enc(idx[x].first, idx[x].second);\n            ll b = enc(idx[y].first, idx[y].second);\n            ll c = enc(idx[z].first, idx[z].second);\n            // cout << a << \" \" << b << \" \" << c << \" \" << (a*B*B+b*B+c) << endl;\n            return to_string(a) + \" \" +to_string(b) + \" \" + to_string(c);\n            // return a*B*B+b*B+c;\n        };\n        auto prt = [&](int x, int y, int z) {\n            cout << idx[x].first << \" \" <<  idx[x].second << endl;\n            cout << idx[y].first << \" \" <<  idx[y].second << endl;\n            cout << idx[z].first << \" \" <<  idx[z].second << endl;\n            cout << \" ----- \" << endl;\n        };\n        auto getval = [&](int x, int y, int z) {\n            return 0LL+board[idx[x].first][idx[x].second] + board[idx[y].first][idx[y].second] + board[idx[z].first][idx[z].second];\n        };\n        auto check = [&](int x, int y, int z) {\n            if (idx[x].first == idx[y].first || idx[x].first == idx[z].first || idx[y].first == idx[z].first) return false;\n            if (idx[x].second == idx[y].second || idx[x].second == idx[z].second || idx[y].second == idx[z].second) return false;\n            return true;\n        };\n        // cout << idx << endl;\n        priority_queue<Node> pq;\n        pq.emplace(0, 1, 2, getval(0, 1, 2));\n        st.insert(encode(0, 1, 2));\n        while (pq.size()) {\n            auto [x, y, z, val] = pq.top();\n            // cout << x << \" \" << y << \" \" << z << \" \" << val << endl;\n            // auto t = pq;\n            // cout << \"in queue\" << endl;\n            // while (t.size()) {\n            //     auto[ p1, p2, p3, p4] = t.top();\n            //     t.pop();\n            //     cout << p1<<\" \" << p2 << \" \" << p3 << \" \" << p4 << endl;\n            // }\n            // prt(x, y, z);\n            pq.pop();\n            if (check(x, y, z)) return val;\n            if (z+1<B && st.count(encode(x, y, z+1)) == 0) {\n                st.insert(encode(x, y, z+1));\n                pq.emplace(x, y, z+1, getval(x, y, z+1));\n            }\n            if (y+1<z && st.count(encode(x, y+1, z)) == 0) {\n                st.insert(encode(x, y+1, z));\n                pq.emplace(x, y+1, z, getval(x, y+1, z));\n            }\n            if (x+1<y && st.count(encode(x+1, y, z)) == 0) {\n                st.insert(encode(x+1, y, z));\n                pq.emplace(x+1, y, z, getval(x+1, y, z));\n            }\n            // cout << pq.size() << endl;\n        }\n        return -8;\n    }\n};",
    "submit_ts": "1723909185",
    "subm_id": "556334926"
}