{
    "username": "realSaddy",
    "submission": "#define ll long long\nclass Solution {\npublic:\n    ll countSubarrays(vector<int>& nums, int k) {\n\n\n        /**\n          good # = has at least the bits of k\n          bad # = does not have at least the bits of k\n          we encounter bad # -> pivot of subarray\n          need to restrict to k, so somehow keep track of bits going to k\n          \n\n          considering dp...\n          dp[i] = # subarrays at ith pos\n          if bad then dp[i] = dp[i-1]\n          otherwise we have the current length of the subdomain left\n          still no way of tracking the intermediates\n\n           b/c AND is destructive, i think we must track the ands\n           for every element, we can add it with prev element chains\n           if one of the chains ANDed with the element is the value, we succeed\n           multiple chains = need to keep track of #\n        */\n        int n = nums.size();\n        ll ret = 0;\n        unordered_map<int, ll> mp;\n\n        for(int i = 0; i < n; i++) {\n            // we consider adding nums[i] to each chain value\n            // will keep a sep map for caching\n            int ele = nums[i];\n            unordered_map<int, ll> new_m;\n            \n            // special case: just the ele\n            if(ele == k) ret++;\n            new_m[ele] = 1;\n\n\n            for(auto& it : mp) {\n                if((it.first & ele) == k) ret += it.second;\n                new_m[it.first & ele] += it.second;\n            }\n\n            \n\n            // swp\n            mp = new_m;\n\n\n\n        }\n\n        // time complex may be too high\n\n\n\n\n\n\n        return ret;\n    }\n};",
    "submit_ts": "1720280037",
    "subm_id": "1311774598"
}