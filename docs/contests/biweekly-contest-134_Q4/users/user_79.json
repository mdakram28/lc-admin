{
    "username": "vrangr",
    "submission": "template <typename type> inline void print(const type &var) {\n    cout << var;\n}\ntemplate <typename type> inline void print(const vector<type> &vec) {\n    for (auto &it : vec) {\n        print(it); cout << \" \";\n    }\n}\n#define debug(x) if(false){cout << #x << \": \";print(x);cout<<endl;}\ntypedef long long int ll;\nconst int mx = (1<<30)-1;\nclass segtree{\npublic:\n    int n;\n    vector<int> tree;\n    segtree(const vector<int> &vals) {\n        n = vals.size();\n        int gn = (n<<1);\n        if (__builtin_popcount(gn) != 1)\n            gn = (1<<(32-__builtin_clz(gn)));\n        tree.assign(gn,mx);\n        for (int i = 0; i < n; ++i)\n            tree[i+n] = vals[i];\n        for (int i = n-1; i > 0; --i)\n            tree[i] = tree[i<<1]&tree[i<<1|1];\n    }\n    \n    ll query(int l, int r) {\n        int res = mx;\n        for (l+=n,r+=n;l<r;l>>=1,r>>=1) {\n            if (l&1) res &= tree[l++];\n            if (r&1) res &= tree[--r];\n        }\n        return res;\n    }\n};\n\nclass Solution {\npublic:\n    ll countSubarrays(vector<int>& vals, ll k) {\n        segtree st(vals);\n        int n = vals.size();\n        auto lbd = [&](auto &&self, ll low, ll high, const ll ind) -> ll {\n            assert(low <= high);\n            assert(ind <= low);\n            if (low == high) {\n                if (st.query(ind,low+1) != k) return -1ll;\n                return low-ind+1ll;\n            }\n            ll mid = (low+high)/2ll;\n            if (st.query(ind,mid+1ll) > k) return self(self, mid+1ll, high, ind);\n            return self(self, low, mid, ind);\n        };\n        auto ubd = [&](auto &&self, ll low, ll high, const ll ind) -> ll {\n            assert(low <= high);\n            assert(ind <= low);\n            if (low == high) {\n                if (st.query(ind,high+1ll) != k) return -1;\n                return high-ind+1ll;\n            }\n            ll mid = (low+high+1ll)/2ll;\n            if (st.query(ind,mid+1ll) < k) return self(self, low, mid-1ll, ind);\n            return self(self, mid, high, ind);\n        };\n        ll sol = 0ll;\n        for (ll i = 0; i < n; ++i) {\n            if (vals[i] < k) continue;\n            debug('\\n');\n            ll low, high;\n            if (vals[i] == k) low = 1;\n            else low = lbd(lbd,i,n-1,i);\n            if (low != -1ll && st.query(i,n) == k) high = n-1ll-i+1ll;\n            else if (low != -1ll) high = ubd(ubd,i,n-1ll,i);\n            else high = -1ll;\n            debug(i);\n            debug(low);\n            debug(high);\n            if (low == -1ll) continue;\n            assert(low != -1ll && high != -1ll);\n            assert(low <= high);\n            sol += high-low+1ll;\n        }\n        return sol;\n    }\n};",
    "submit_ts": "1720278229",
    "subm_id": "1311700054"
}