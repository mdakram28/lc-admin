{
    "username": "cjycleaner",
    "submission": "using namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vll> vvll;\ntypedef vector<vvll> vvvll;\ntypedef vector<pii> vpii;\ntypedef vector<vpii> vvpii;\ntypedef vector<pll> vpll;\ntypedef vector<vpll> vvpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<vd> vvd;\n#define yn(ans) printf(\"%s\\n\", (ans)?\"Yes\":\"No\");\n#define YN(ans) printf(\"%s\\n\", (ans)?\"YES\":\"NO\");\ntemplate<class T> bool chmax(T &a, T b) {\n\tif (a >= b) return false;\n\ta = b; return true;\n}\ntemplate<class T> bool chmin(T &a, T b) {\n\tif (a <= b) return false;\n\ta = b; return true;\n}\n#define FOR(i, s, e, t) for ((i) = (s); (i) < (e); (i) += (t)) \n#define REP(i, e) for (int i = 0; i < (e); ++i) \n#define REP1(i, s, e) for (int i = (s); i < (e); ++i)\n#define RREP(i, e) for (int i = (e); i >= 0; --i)\n#define RREP1(i, e, s) for (int i = (e); i >= (s); --i)\n#define all(v) v.begin(), v.end()\n#define pb push_back\n#define qb pop_back\n#define pf push_front\n#define qf pop_front\n#define maxe max_element\n#define mine min_element\nll inf = 1e18;\n#define DEBUG printf(\"%d\\n\", __LINE__); fflush(stdout);\ntemplate<class T> void print(vector<T> &v, bool withSize = false) {\n\tif (withSize) cout << v.size() << endl;\n\tREP(i, v.size()) cout << v[i] << \" \"; \n\tcout << endl;\n}\n\nclass Fenw {\npublic:\n\tFenw(ll _n): n(_n), v(n, 0) {}\n\tint lowbit(int x) {return x & -x;}\n\tll query(int x) {\n\t\tll ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += v[i];\n\t\treturn ans;\n\t}\n\tvoid update(int x, ll val) {\n\t\tfor (int i = x; i < n; i += lowbit(i)) {\n\t\t\tv[i] += val;\n\t\t}\n\t}\nprivate:\n\tint n;\n\tvector<ll> v;\n};\n\nmt19937_64 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\nclass Solution {\npublic:\n    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {\n        int N = colors.size(), Q = queries.size();\n        vpii q;\n        REP(i, N) {\n            if (q.empty() || colors[q.back().second] == colors[i]) q.pb({i, i});\n            else q.back().second = i;\n        }\n        //for (auto &e: q) printf(\"(%d %d) \", e.first, e.second); printf(\"\\n\");\n        if (q.size() > 1 && colors[q[0].first] != colors[q.back().second]) q[0].first = q.back().first, q.qb();\n       // for (auto &e: q) printf(\"(%d %d) \", e.first, e.second); printf(\"\\n\");\n        set<pii> s;\n        \n        Fenw f(N + 1), f2(N + 1);\n        \n        auto upd = [&](int len, int d) {\n            if (len <= 0) return;\n           // printf(\"upd %d %d\\n\", len, d); fflush(stdout);\n            f.update(len, (len + 1) * d);\n            f2.update(len, d);\n        };\n        \n        auto query = [&](int sz) {\n            if (s.size() == 1) {\n                if (N % 2 == 0) return (ll)(sz <= N ? N : 0);\n                else return (ll)(N - sz + 1);\n            }\n            return f.query(N) - f.query(sz - 1) - (f2.query(N) - f2.query(sz - 1)) * sz;\n        };\n        \n        REP(i, q.size()) {\n            s.insert(q[i]);\n            int len = (q[i].second - q[i].first + N) % N + 1;\n            upd(len, 1);\n        }        \n        \n        vi ans;\n        REP(i, Q) {\n            //for (auto &e: s) printf(\"(%d %d) \", e.first, e.second); printf(\"\\n\"); fflush(stdout);\n            int op = queries[i][0];\n            if (op == 1) {\n                int sz = queries[i][1];\n                ans.pb(query(sz));\n            } else {\n                int pos = queries[i][1], c = queries[i][2];\n                if (colors[pos] == c) continue;\n                colors[pos] = c;\n                \n                if (s.size() == 1) {\n                    if (N % 2 == 0) {\n                        upd(N, -1);\n                        upd(1, 1);\n                        upd(N - 1, 1);\n                        s.clear();\n                        s.insert({pos, pos});\n                        s.insert({(pos + 1) % N, (pos + N - 1) % N});\n                    } else {\n                        int l = s.begin()->first, r = s.begin()->second;\n                        if (pos == l) {\n                            s = {{(pos + 1) % N, pos}};\n                        } else if (pos == r) {\n                            s = {{pos, (pos + N - 1) % N}};   \n                        } else {\n                            upd(N, -1);\n                            upd(1, 1);\n                            upd((pos - l + N) % N, 1);\n                            upd((r - pos + N) % N, 1);\n                            s.clear();\n                            s.insert({pos, pos});\n                            s.insert({l, (pos + N - 1) % N});\n                            s.insert({(pos + 1) % N, r});\n                        }\n                    }\n                    continue;\n                }\n                \n                auto it = s.lower_bound({pos, -1});\n                if (it != s.end() && it->first == pos) {\n                    int len1 = (it->second - it->first + N) % N + 1;\n                    if (it->first == it->second) {\n                        if (s.size() == 2) {\n                            upd(1, -1);\n                            upd(N - 1, -1);\n                            upd(N, 1);\n                            s = {{pos, (pos + N - 1) % N}};\n                        } else {\n                            auto it1 = it == s.begin() ? prev(s.end()) : prev(it);\n                            auto it2 = next(it) == s.end() ? s.begin() : next(it);\n                            \n                            int l1 = it1->first, r1 = it1->second, l2 = it2->first, r2 = it2->second;\n                            int len2 = (r1 - l1 + N) % N + 1, len3 = (r2 - l2 + N) % N + 1;\n                            upd(1, -1);\n                            upd(len2, -1);\n                            upd(len3, -1);\n                            upd(len2 + len3 + 1, 1);\n                            s.erase({pos, pos}), s.erase({l1, r1}), s.erase({l2, r2});\n                            s.insert({l1, r2});\n                        }\n                        continue;\n                    }\n                    \n                    upd(len1, -1);\n                    upd(len1 - 1, 1);\n                    auto it2 = it != s.begin() ? prev(it) : prev(s.end());\n                    int len2 = (it2->second - it2->first + N) % N + 1;\n                    upd(len2, -1);\n                    upd(len2 + 1, 1);\n                    pii a = *it, b = *it2;\n                    s.erase(a), s.erase(b);\n                    a.first = (a.first + 1) % N;\n                    b.second = (b.second + 1) % N;                    \n                    if (len1 > 1) s.insert(a);\n                    s.insert(b);\n                } else {\n                    if (it == s.begin()) it = prev(s.end()); else it = prev(it);\n                    \n                    if (pos == it->second) {\n                        int len1 = (it->second - it->first + N) % N + 1;\n                        upd(len1, -1);\n                        upd(len1 - 1, 1);\n                        auto it2 = next(it) != s.end() ? next(it) : s.begin();\n                        int len2 = (it2->second - it2->first + N) % N + 1;\n                        upd(len2, -1);\n                        upd(len2 + 1, 1);\n                        pii a = *it, b = *it2;\n                        s.erase(a), s.erase(b);\n                        a.second = (a.second + N - 1) % N;\n                        b.first = (b.first + N - 1) % N;                        \n                        if (len1 > 1) s.insert(a);\n                        s.insert(b);\n                    } else {\n                        int l = it->first, r = it->second;\n                        int len1 = (r - l + N) % N + 1;\n                        upd(len1, -1);\n                        s.erase(it);\n                        if (l != pos) {\n                            int len2 = (pos - l + N) % N;\n                            upd(len2, 1);\n                            s.insert({l, (pos + N - 1) % N});\n                        } \n                        s.insert({pos, pos});\n                        upd(1, 1);\n                        if (pos != r) {\n                            int len3 = (r - pos + N) % N;\n                            upd(len3, 1);\n                            s.insert({(pos + 1) % N, r});\n                        }\n                    }\n                }\n            }\n         }\n        \n        return ans;\n    }\n};",
    "submit_ts": "1722743261",
    "subm_id": "552349750"
}