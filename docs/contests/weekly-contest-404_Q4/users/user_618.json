{
    "username": "kshui",
    "submission": "class Solution {\npublic:\n    int bfs(int start, vector<vector<int>>& adj, vector<int>& dist) {\n        fill(dist.begin(), dist.end(), -1);\n        queue<int> q;\n        q.push(start);\n        dist[start] = 0;\n        int fn = start;\n        \n        while (!q.empty()) \n        {\n            int node = q.front();\n            q.pop();\n            for (int nbr : adj[node]) {\n                if (dist[nbr] == -1) {\n                    dist[nbr] = dist[node] + 1;\n                    q.push(nbr);\n                    if (dist[nbr] > dist[fn]) {\n                        fn = nbr;\n                    }\n                }\n            }\n        }\n        return fn;\n    }\n\n    int getDiameter(vector<vector<int>>& edges, int n) {\n        vector<vector<int>> adj(n);\n        for (vector<int> e : edges) {\n            adj[e[0]].push_back(e[1]);\n            adj[e[1]].push_back(e[0]);\n        }\n        \n        vector<int> dist(n);\n        int fn = bfs(0, adj, dist);\n        fn = bfs(fn, adj, dist);\n        return dist[fn];\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int d1 = getDiameter(edges1, edges1.size() + 1);\n        int d2 = getDiameter(edges2, edges2.size() + 1);\n        return max(d1,max(d2,(d1+1)/2+(d2+1)/2+1));\n    }\n};\n",
    "submit_ts": 1719718397.0
}