{
    "username": "Ritik Chaurasia",
    "submission": "class Solution {\npublic:\n \n\n\n\nstruct Element {\n    long long value;\n    int index;\n};\n\nlong long check(const vector<vector<Element>>& rowMax, vector<int>& colUsed, int row, int remainingRooks) {\n    if (remainingRooks == 0) return 0;\n    if (row >= rowMax.size()) return   -1e9-1e9-1e9;\n\n   \n   \n    long long maxSum = check(rowMax, colUsed, row + 1, remainingRooks);\n\n    for (const Element& e : rowMax[row]) {\n        if (!colUsed[e.index]) {\n            colUsed[e.index] = 1;\n            long long sum = e.value + check(rowMax, colUsed, row + 1, remainingRooks - 1);\n\n            // Handle potential overflow by checking for LLONG_MIN and only updating if valid\n            if (sum != LLONG_MIN) {\n                maxSum = max(maxSum, sum);\n            }\n\n            colUsed[e.index] = 0;\n        }\n    }\n\n    return maxSum;\n}\n\nlong long maximumValueSum(vector<vector<int>>& board) {\n    int m = board.size();\n    int n = board[0].size();\n    \n    vector<vector<Element>> rowMax(m, vector<Element>(3, {LLONG_MIN, -1}));\n    \n    for (int i = 0; i < m; ++i) {\n        vector<Element> rowElements(n);\n        for (int j = 0; j < n; ++j) {\n            rowElements[j] = {board[i][j], j};\n        }\n        sort(rowElements.begin(), rowElements.end(), [](const Element& a, const Element& b) {\n            return a.value > b.value;\n        });\n        for (int k = 0; k < 3 && k < n; ++k) {\n            rowMax[i][k] = rowElements[k];\n        }\n    }\n\n    vector<int> colUsed(n, 0);\n    long long result = check(rowMax, colUsed, 0, 3);\n    \n    return result == LLONG_MIN ? 0 : result;\n}\n\n};",
    "submit_ts": "1723909518",
    "subm_id": "1359195584"
}