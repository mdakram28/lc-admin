{
    "username": "CodeRover",
    "submission": "#include <vector>\n#include <algorithm>\n\n#define ll long long \n\nconst int M = 1e9+7;\n\nclass Solution {\npublic:\n    int countOfPairs(std::vector<int>& v) {\n        int n = v.size();\n        int max_val = *max_element(v.begin(), v.end());\n        \n        // Create DP table with (n+1) rows and (max_val + 1) columns\n        std::vector<std::vector<ll>> dp(n + 1, std::vector<ll>(max_val + 1, 0));\n        std::vector<std::vector<ll>> prefix_sum(n + 1, std::vector<ll>(max_val + 1, 0));\n        \n        // Base case: At the end of the array, there's exactly one way to be valid\n        for (int j = 0; j <= max_val; ++j) {\n            dp[n][j] = 1;\n        }\n        \n        // Compute prefix sums for the last row\n        for (int j = 0; j <= max_val; ++j) {\n            prefix_sum[n][j] = dp[n][j];\n            if (j > 0) {\n                prefix_sum[n][j] = (prefix_sum[n][j] + prefix_sum[n][j - 1]) % M;\n            }\n        }\n        \n        // Fill DP table from the end towards the start\n        for (int idx = n - 1; idx >= 0; --idx) {\n            for (int mxUsed = 0; mxUsed <= max_val; ++mxUsed) {\n                ll ans = 0;\n                if (idx == 0) {\n                    // Use prefix sums to get the range sum quickly\n                    if (mxUsed <= v[idx]) {\n                        ans = prefix_sum[idx + 1][v[idx]];\n                        if (mxUsed > 0) {\n                            ans = (ans - prefix_sum[idx + 1][mxUsed - 1] + M) % M;\n                        }\n                    }\n                } else {\n                    int min_k = max(0,v[idx] - v[idx - 1]) + mxUsed;\n                    if (min_k <= v[idx]) {\n                        // Use prefix sums to avoid the inner loop\n                        int left = std::max(min_k, 0);\n                        int right = v[idx];\n                        if (left <= right) {\n                            ans = (prefix_sum[idx + 1][right] - (left > 0 ? prefix_sum[idx + 1][left - 1] : 0) + M) % M;\n                        }\n                    }\n                }\n                dp[idx][mxUsed] = ans;\n            }\n            // Update prefix sums for the current row\n            for (int j = 0; j <= max_val; ++j) {\n                prefix_sum[idx][j] = dp[idx][j];\n                if (j > 0) {\n                    prefix_sum[idx][j] = (prefix_sum[idx][j] + prefix_sum[idx][j - 1]) % M;\n                }\n            }\n        }\n\n        return dp[0][0];\n    }\n};\n",
    "submit_ts": "1723347215",
    "subm_id": "1351594337"
}