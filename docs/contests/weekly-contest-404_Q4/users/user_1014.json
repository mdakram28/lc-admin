{
    "username": "O3O",
    "submission": "class Solution(object):\n    def minimumDiameterAfterMerge(self, edges1, edges2):\n        \"\"\"\n        :type edges1: List[List[int]]\n        :type edges2: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def bfs_diameter(tree, n):\n            def bfs(start):\n                dist = [-1] * n\n                dist[start] = 0\n                queue = deque([start])\n                farthest_node = start\n                while queue:\n                    node = queue.popleft()\n                    for neighbor in tree[node]:\n                        if dist[neighbor] == -1:\n                            dist[neighbor] = dist[node] + 1\n                            queue.append(neighbor)\n                            if dist[neighbor] > dist[farthest_node]:\n                                farthest_node = neighbor\n                return farthest_node, dist[farthest_node]\n\n            farthest, _ = bfs(0)\n            _, diameter = bfs(farthest)\n            return diameter\n\n        n = len(edges1) + 1\n        m = len(edges2) + 1\n\n        tree1 = defaultdict(list)\n        tree2 = defaultdict(list)\n\n        for a, b in edges1:\n            tree1[a].append(b)\n            tree1[b].append(a)\n\n        for u, v in edges2:\n            tree2[u].append(v)\n            tree2[v].append(u)\n\n        diameter1 = bfs_diameter(tree1, n)\n        diameter2 = bfs_diameter(tree2, m)\n\n        return max(diameter1, diameter2, (diameter1 + 1) // 2 + (diameter2 + 1) // 2 + 1)\n\n        ",
    "submit_ts": "1719718259",
    "subm_id": "1304412762"
}