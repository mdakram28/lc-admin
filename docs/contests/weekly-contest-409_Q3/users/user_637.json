{
    "username": "devvrat_07",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n \n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<class T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define ff first\n#define ss second\n#define ld long double\n#define ll long long\n#define pb push_back\n#define INF 1e18\n#define ppb pop_back\n#define fl(i,n,m) for(int i=n;i<m;i++)\n#define pii pair<int,int>\n#define vi vector<int>\n#define vll vector<ll>\n#define print(a) for(auto &it:a) cout<<it<<\" \"; cout<<endl\n#define mii map<int,int>\n#define setbits(x) __builtin_popcountll(x)\n#define sz(x) ((int)(x).size())\n#define all(a) a.begin(),a.end()\n#define yes cout<<\"YES\"<<endl\n#define no cout<<\"NO\"<<endl\n \nll gcd(ll a, ll b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}\nll expo(ll a, ll b, ll mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}\nvoid extendgcd(ll a, ll b, ll*v) {if (b == 0) {v[0] = 1; v[1] = 0; v[2] = a; return ;} extendgcd(b, a % b, v); ll x = v[1]; v[1] = v[0] - v[1] * (a / b); v[0] = x; return;} //pass an arry of size1 3\nll mminv(ll a, ll b) {ll arr[3]; extendgcd(a, b, arr); return arr[0];} //for non prime b\nll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}\nbool revsort(ll a, ll b) {return a > b;}\n \nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\nll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;} //only for prime m\n \nint pw(ll int a, ll int b, ll int m) {\n    if(b==0) {\n        return 1;\n    }\n \n    if(b%2 == 0) {\n        ll int t = pw(a, (b/2), m);\n        return (1ll*t*t)%m;\n    }\n    else {\n        ll int t = pw(a, (b-1)/2, m);\n        t = (1ll*t*t)%m;\n        return (1ll*a*t)%m;\n    }\n}\n \nconst int N=500000;\nconst ll int mod = 1e9 + 7;\n \nll int fact[N], invfact[N];\nvoid init() {\n    ll int p = mod;\n    fact[0]=1;\n    int i;\n    for(i=1; i<N; i++) {\n        fact[i] = (i*fact[i-1])%p;\n    }\n    i--;\n    invfact[i] = pw(fact[i], p-2, p);\n    for(i--; i>=0; i--) {\n        invfact[i] = (invfact[i+1]*(i+1))%p;\n    }\n}\n \nint ncr(int n, int r) {\n    return (((fact[n]*invfact[r])%mod)*invfact[n-r])%mod;\n}\n \nvector<int> sieve_of_eratosthenes(int n) {\n    vector<int> prm;\n    bool is_prime[n + 1];\n    memset(is_prime, true, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = false;\n    for(int p = 2; p * p <= n; p++) {\n        if(is_prime[p]) {\n            for(int i = p * p; i <= n; i += p) {\n                is_prime[i] = false;\n            }\n        }\n    }\n    for(int i = 2; i <= n; i++) {\n        if(is_prime[i]) {\n            prm.pb(i);\n        }\n    }\n    return prm;\n}\n\nclass Solution {\npublic:\n   vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& que) {\n        int sz = que.size();\n        map<int,int> mapper_like_rapper;\n        vector<int> final_ans(sz);\n        int fl= 0;\n        if(fl){\n            return {};\n        }\n        int result = n - 1;\n        for (int i=0;i<sz;i++) {\n            int flags = 0;\n            int l = que[i][0],r=que[i][1];\n            while(true){\n                auto it = mapper_like_rapper.lower_bound(l);\n                if(it==mapper_like_rapper.end()){\n                    if(mapper_like_rapper.size()==0) break;\n                    --it;\n                    if((*it).ss<=l){\n                        break;\n                    }\n                }\n                if(it!=mapper_like_rapper.begin()){\n                    --it;\n                    if((*it).ss<=l){\n                        ++it;\n                    }\n                }\n                if(l>=(*it).ff && (r<=((*it).ss))){\n                    flags = 1;\n                    break;\n                }\n                int t1 = (*it).ff,t2 = (*it).ss;\n                if((l<=t1 && r<=t1) || (l>=t2 && r>=t2)){\n                    break;\n                }\n                result += (t2-t1)-1;\n                mapper_like_rapper.erase(it);\n            }\n            if(flags){\n                final_ans[i] = result;\n                continue;\n            }\n            mapper_like_rapper[l] =r;\n            result -= (r-l);\n            result++;\n            final_ans[i] = result;\n        }\n        return final_ans;\n    }\n};",
    "submit_ts": "1722742519",
    "subm_id": "1343770854"
}