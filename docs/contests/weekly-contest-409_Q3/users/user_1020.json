{
    "username": "Devansh_Sengar",
    "submission": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\n#define MAX 400040\n\n\n\nclass Solution {\npublic:\n    int tree[MAX] = {0};\n    int lazy[MAX] = {0};\n    bool lazySet[MAX] = {false};\n\n    void propagate(int si, int ss, int se) {\n        if (lazySet[si]) {\n            tree[si] = (se - ss + 1) * lazy[si];\n            if (ss != se) {\n                lazy[si * 2 + 1] = lazy[si];\n                lazy[si * 2 + 2] = lazy[si];\n                lazySet[si * 2 + 1] = true;\n                lazySet[si * 2 + 2] = true;\n            }\n            lazy[si] = 0;\n            lazySet[si] = false;\n        }\n    }\n\n    void updateRangeUtil(int si, int ss, int se, int us, int ue, int value) {\n        propagate(si, ss, se);\n\n        if (ss > se || ss > ue || se < us)\n            return;\n\n        if (ss >= us && se <= ue) {\n            tree[si] = (se - ss + 1) * value;\n            if (ss != se) {\n                lazy[si * 2 + 1] = value;\n                lazy[si * 2 + 2] = value;\n                lazySet[si * 2 + 1] = true;\n                lazySet[si * 2 + 2] = true;\n            }\n            return;\n        }\n\n        int mid = (ss + se) / 2;\n        updateRangeUtil(si * 2 + 1, ss, mid, us, ue, value);\n        updateRangeUtil(si * 2 + 2, mid + 1, se, us, ue, value);\n\n        tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];\n    }\n\n    void updateRange(int n, int us, int ue, int value) {\n        updateRangeUtil(0, 0, n - 1, us, ue, value);\n    }\n\n    int getSumUtil(int ss, int se, int qs, int qe, int si) {\n        propagate(si, ss, se);\n\n        if (ss > se || ss > qe || se < qs)\n            return 0;\n\n        if (ss >= qs && se <= qe)\n            return tree[si];\n\n        int mid = (ss + se) / 2;\n        return getSumUtil(ss, mid, qs, qe, si * 2 + 1) +\n               getSumUtil(mid + 1, se, qs, qe, si * 2 + 2);\n    }\n\n    int getSum(int n, int qs, int qe) {\n        return getSumUtil(0, n - 1, qs, qe, 0);\n    }\n\n    void constructSTUtil(int arr[], int ss, int se, int si) {\n        if (ss > se)\n            return;\n\n        if (ss == se) {\n            tree[si] = arr[ss];\n            return;\n        }\n\n        int mid = (ss + se) / 2;\n        constructSTUtil(arr, ss, mid, si * 2 + 1);\n        constructSTUtil(arr, mid + 1, se, si * 2 + 2);\n\n        tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];\n    }\n\n    void constructST(int arr[], int n) {\n        constructSTUtil(arr, 0, n - 1, 0);\n    }\n    \n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& q) {\n        vector<int> ans;\n\n        int arr[n];\n        for(int i = 0; i < n; i++) {\n            arr[i] = 1;\n        }\n        arr[n-1] = 0;\n        \n        constructST(arr, n);\n        \n        for(int i = 0; i < q.size(); i++) {\n            int u = q[i][0], v = q[i][1];\n            u++;\n            v--;\n            \n            updateRange(n, u, v, 0);\n            int sum = getSum(n, 0, n-1);\n            ans.push_back(sum);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722743517",
    "subm_id": "1343793712"
}