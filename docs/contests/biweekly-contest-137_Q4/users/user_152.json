{
    "username": "Wittgenstein",
    "submission": "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0])\n\n        sorted_board = [(board[i][j], i, j) for j in range(n) for i in range(m)]\n        sorted_board.sort(reverse = True)\n        \n        maxSum = -math.inf\n\n        def backtrack(currIndex, currSum, remain, visited_rows, visited_cols):\n            if remain > m*n - currIndex:\n                return\n\n            nonlocal maxSum\n            if remain == 0:\n                maxSum = max(maxSum, currSum)\n                return\n\n            possible = 0\n            for j in range(currIndex, currIndex + remain):\n                possible += sorted_board[j][0]\n                \n            if currSum + possible < maxSum:\n                return\n\n            curr_p = currIndex\n            while curr_p <= m*n-1 and ((sorted_board[curr_p][1] in visited_rows) or (sorted_board[curr_p][2] in visited_cols)):\n                curr_p += 1\n\n            if curr_p == m*n:\n                return\n\n            visited_rows.add(sorted_board[curr_p][1])\n            visited_cols.add(sorted_board[curr_p][2])\n\n            backtrack(curr_p+1, currSum + sorted_board[curr_p][0], remain - 1, visited_rows, visited_cols)\n\n            visited_rows.remove(sorted_board[curr_p][1])\n            visited_cols.remove(sorted_board[curr_p][2])\n\n\n            backtrack(curr_p+1, currSum, remain, visited_rows, visited_cols)\n\n        backtrack(0, 0, 3, set(), set())\n\n        return maxSum",
    "submit_ts": "1723907906",
    "subm_id": "1359129592"
}