{
    "username": "Ivan_len",
    "submission": "template <typename T>\nclass segtree {\npublic:\n    T unite(T, T);\n\n    int size=1;\n    T initial;\n    vector<T> tree;\n\n    T create_default() {\n        T res;\n        res=initial;\n        return res;\n    }\n\n    void build(vector<T> &a, int x, int lx, int rx) {\n        if (rx-lx==1) {\n            if (lx<int(a.size())) tree[x]=a[lx];\n            else tree[x]=initial;\n            return;\n        }\n        int mid=lx+(rx-lx)/2;\n        build(a, x * 2 + 1, lx, mid);\n        build(a, x * 2 + 2, mid, rx);\n        tree[x]=unite(tree[x * 2 +1], tree[x * 2 + 2]);\n    }\n\n    void build(vector<T> &a) {\n        build(a,0,0,size);\n    }\n\n    segtree(int N, T ini) {\n        size=1;\n        T res{};\n        initial=ini;\n        res=initial;\n        while (size<N) size*=2;\n        tree.assign(2*size, res);\n    }\n\n    void modify(int i, T v, int x, int lx, int rx) {\n        if (rx-lx==1) {\n            tree[x] = v;\n            return;\n        }\n        int mid=lx+(rx-lx)/2;\n        if (i<mid) {\n            modify(i,v,2*x+1,lx,mid);\n        }\n        else {\n            modify(i, v, 2*x+2, mid, rx);\n        }\n        tree[x] = unite(tree[x*2+1], tree[x*2+2]);\n    }\n\n    void modify(int i, T v) {\n        modify(i,v,0,0,size);\n    }\n\n    T get(int l, int r, int x, int lx, int rx) {\n        T res=create_default();\n        if (lx >= r || l >= rx) {\n            return res;\n        }\n        if (lx >= l && rx <= r) return tree[x];\n        int mid=lx+(rx-lx)/2;\n        T a=get(l,r,2*x+1,lx,mid);\n        T b=get(l,r,2*x+2,mid,rx);\n        if (mid <= l) return b;\n        if (mid >= r) return a;\n        return unite(a,b);\n    }\n\n    T get(int l, int r) {\n        return get(l,r,0,0,size);\n    }\n};\n\ntemplate<typename T>\nT segtree<T>::unite(T a, T b) {\n    T res{};\n    res = a & b;\n    return res;\n}\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        nums.push_back(0);\n        int n = nums.size();\n        segtree<int> T(n, 0);\n        T.build(nums);\n        int ans = 1 << 30;\n        for (int i = 0; i < n - 1; i++) {\n            if (nums[i] <= k) {\n                ans = min(ans, k - nums[i]);\n                continue;\n            }\n            int l = i, r = n - 1;\n            while (l + 1 < r) {\n                int mid = l + (r - l) / 2;\n                auto ok = [&](int mid) {\n                    int s = T.get(i, mid + 1);\n                    return s <= k;\n                };\n                if (ok(mid)) r = mid;\n                else l = mid;\n            }\n            int pre = T.get(i, r);\n            ans = min(ans, abs(pre - k));\n            // cout << ans << ' ' << i << ' ' << l << ' ' << r << ' ' << n << '\\n';\n            if (r < n - 1) {\n                pre &= nums[r];\n                ans = min(ans, abs(pre - k));\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1717297722",
    "subm_id": "1274753441"
}