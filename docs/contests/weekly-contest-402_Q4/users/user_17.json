{
    "username": "felicenguyen2001",
    "submission": "from typing import List\n\nclass SegmentTree:\n    def __init__(self, data, func, default):\n        self.n = len(data)\n        self.func = func\n        self.default = default\n        self.tree = [default] * (2 * self.n)\n        # build the tree\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1])\n    \n    def update(self, idx, value):\n        idx += self.n\n        self.tree[idx] = value\n        while idx > 1:\n            idx //= 2\n            self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n    \n    def query(self, left, right):\n        result = self.default\n        left += self.n\n        right += self.n\n        while left < right:\n            if left % 2:\n                result = self.func(result, self.tree[left])\n                left += 1\n            if right % 2:\n                right -= 1\n                result = self.func(result, self.tree[right])\n            left //= 2\n            right //= 2\n        return result\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        \n        def is_peak(i):\n            if i == 0 or i == n - 1:\n                return False\n            return nums[i] > nums[i - 1] and nums[i] > nums[i + 1]\n        \n        # Initialize the peak array and segment tree\n        peak_data = [1 if is_peak(i) else 0 for i in range(n)]\n        peak_tree = SegmentTree(peak_data, lambda x, y: x + y, 0)\n        \n        results = []\n        \n        for query in queries:\n            if query[0] == 1:\n                li, ri = query[1], query[2]\n                if ri - li < 2:\n                    results.append(0)\n                else:\n                    results.append(peak_tree.query(li + 1, ri))\n            elif query[0] == 2:\n                index, val = query[1], query[2]\n                nums[index] = val\n                \n                # Update the peak status of index and its neighbors\n                for i in range(max(1, index - 1), min(n - 1, index + 1) + 1):\n                    peak_tree.update(i, 1 if is_peak(i) else 0)\n        \n        return results\n\n# Example usage:\nsolution = Solution()\nprint(solution.countOfPeaks([3, 1, 4, 2, 5], [[2, 3, 4], [1, 0, 4]]))  # Output: [0]\nprint(solution.countOfPeaks([4, 1, 4, 2, 1, 5], [[2, 2, 4], [1, 0, 2], [1, 0, 4]]))  # Output: [0, 1]\n",
    "submit_ts": 1718505273.0
}