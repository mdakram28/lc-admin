{
    "username": "rajpatel23112003",
    "submission": "struct Node {\n     // Array to store\n     // links to child nodes\n    Node* links[26];\n     // Counter for number of\n     // words that end at this node\n    int cntEndWith = 0;\n    // Counter for number of words\n    // that have this node as a prefix\n    int cntPrefix = 0; \n\n    // Function to check if the\n    // node contains a specific key\n    bool containsKey(char ch) {\n        // Check if the link corresponding\n        // to the character exists\n        return (links[ch - 'a'] != NULL); \n    }\n\n    // Function to get the child\n    // node corresponding to a key\n    Node* get(char ch) {\n        // Return the link\n        // corresponding to the character\n        return links[ch - 'a']; \n    }\n\n    // Function to insert a child\n    // node with a specific key\n    void put(char ch, Node* node) {\n         // Set the link corresponding to\n         // the character to the provided node\n        links[ch - 'a'] = node;\n    }\n\n    // Function to increment the\n    // count of words that end at this node\n    void increaseEnd() {\n        // Increment the counter\n        cntEndWith++; \n    }\n\n    // Function to increment the count of\n    // words that have this node as a prefix\n    void increasePrefix() {\n         // Increment the counter\n        cntPrefix++;\n    }\n\n    // Function to decrement the count\n    // of words that end at this node\n    void deleteEnd() {\n        // Decrement the counter\n        cntEndWith--; \n    }\n\n    // Function to decrement the count of\n    // words that have this node as a prefix\n    void reducePrefix() {\n        // Decrement the counter\n        cntPrefix--; \n    }\n};\n\n// Define a class for the\n// trie data structure\nclass Trie {\nprivate:\n    // Pointer to the\n    // root node of the trie\n    Node* root; \n\npublic:\n    // Constructor to initialize\n    // the trie with an empty root node\n    Trie() {\n        // Create a new root node\n        root = new Node(); \n    }\n\n    // Function to insert\n    // a word into the trie\n    void insert(string word) {\n        // Start from the root node\n        Node* node = root; \n        // Iterate over each\n        // character in the word\n        for (int i = 0; i < word.size(); i++) { \n             // If the character is\n             // not already in the trie\n            if (!node->containsKey(word[i])) {\n                // Create a new node\n                // for the character\n                node->put(word[i], new Node()); \n            }\n             // Move to the child node\n             // corresponding to the character\n            node = node->get(word[i]);\n            // Increment the prefix\n            // count for the node\n            node->increasePrefix(); \n        }\n        // Increment the end count\n        // for the last node of the word\n        node->increaseEnd(); \n    }\n\n    // Function to count the number\n    // of words equal to a given word\n    int countWordsEqualTo(string word) {\n         // Start from the root node\n        Node* node = root;\n        // Iterate over each character in the word\n        for (int i = 0; i < word.size(); i++) { \n            // If the character is found in the trie\n            if (node->containsKey(word[i])) { \n                // Move to the child node\n                // corresponding to the character\n                node = node->get(word[i]); \n            } else {\n                 // Return 0 if the\n                 // character is not found\n                return 0;\n            }\n        }\n        // Return the count of\n        // words ending at the node\n        return node->cntEndWith; \n    }\n\n    // Function to count the number of\n    // words starting with a given prefix\n    int countWordsStartingWith(string word) {\n         // Start from the root node\n        Node* node = root;\n        // Iterate over each character in the prefix\n        for (int i = 0; i < word.size(); i++) { \n            // If the character is found in the trie\n            if (node->containsKey(word[i])) { \n                // Move to the child node\n                // corresponding to the character\n                node = node->get(word[i]); \n            } else {\n                // Return 0 if the\n                // character is not found\n                return 0; \n            }\n        }\n        // Return the count of\n        // words with the prefix\n        return node->cntPrefix; \n    }\n\n    // Function to erase a\n    // word from the trie\n    void erase(string word) {\n         // Start from the root node\n        Node* node = root;\n        // Iterate over each\n        // character in the word\n        for (int i = 0; i < word.size(); i++) { \n            // If the character is\n            // found in the trie\n            if (node->containsKey(word[i])) { \n                 // Move to the child node\n                 // corresponding to the character\n                node = node->get(word[i]);\n                // Decrement the prefix\n                // count for the node\n                node->reducePrefix(); \n            } else {\n                // Return if the\n                // character is not found\n                return; \n            }\n        }\n        // Decrement the end count\n        // for the last node of the word\n        node->deleteEnd(); \n    }\n};\n\nclass Solution {\npublic:\n    struct TrieNode {\n        unordered_map<char, TrieNode*> children;\n        vector<pair<int, int>> endIndicesAndCosts;\n    };\n\n    class Trie {\n    public:\n        TrieNode* root;\n        Trie() { root = new TrieNode(); }\n\n        void insertWord(const string& word, int index, int cost) {\n            TrieNode* node = root;\n            for (char ch : word) {\n                if (!node->children.count(ch))\n                    node->children[ch] = new TrieNode();\n                node = node->children[ch];\n            }\n            node->endIndicesAndCosts.push_back({index, cost});\n        }\n    };\n\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int targetLength = target.size();\n        vector<int> dp(targetLength + 1, INT_MAX);\n        dp[0] = 0;\n\n        Trie trie;\n        for (int i = 0; i < words.size(); ++i) {\n            trie.insertWord(words[i], i, costs[i]);\n        }\n\n        for (int i = 0; i < targetLength; ++i) {\n            if (dp[i] == INT_MAX) continue;\n\n            TrieNode* currentNode = trie.root;\n            for (int j = i; j < targetLength; ++j) {\n                if (!currentNode->children.count(target[j])) break;\n                currentNode = currentNode->children[target[j]];\n                for (auto& pair : currentNode->endIndicesAndCosts) {\n                    int wordIndex = pair.first;\n                    int wordCost = pair.second;\n                    int wordLength = words[wordIndex].size();\n                    if (i + wordLength <= targetLength) {\n                        dp[i + wordLength] = min(dp[i + wordLength], dp[i] + wordCost);\n                    }\n                }\n            }\n        }\n\n        return dp[targetLength] == INT_MAX ? -1 : dp[targetLength];\n    }\n};\n",
    "submit_ts": "1720323164",
    "subm_id": "1312368896"
}