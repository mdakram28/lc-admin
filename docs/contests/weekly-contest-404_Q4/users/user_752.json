{
    "username": "user8290n",
    "submission": "class Solution {\npublic:\n    vector<vector<int>> createAdjList(const vector<vector<int>>& edges, int n) {\n        vector<vector<int>> adjList(n);\n        for (const auto& edge : edges) {\n            adjList[edge[0]].push_back(edge[1]);\n            adjList[edge[1]].push_back(edge[0]);\n        }\n        return adjList;\n    }\n\n    // Function to perform BFS and return the farthest node and its distance\n    pair<int, int> bfs(const vector<vector<int>>& adjList, int start) {\n        int n = adjList.size();\n        vector<int> distance(n, -1);\n        queue<int> q;\n        q.push(start);\n        distance[start] = 0;\n        \n        int farthestNode = start;\n        int maxDistance = 0;\n        \n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            for (int neighbor : adjList[node]) {\n                if (distance[neighbor] == -1) { // not visited\n                    distance[neighbor] = distance[node] + 1;\n                    q.push(neighbor);\n                    if (distance[neighbor] > maxDistance) {\n                        maxDistance = distance[neighbor];\n                        farthestNode = neighbor;\n                    }\n                }\n            }\n        }\n        return {farthestNode, maxDistance};\n    }\n\n    // Function to find the diameter of a graph\n    int findDiameter(const vector<vector<int>>& edges, int n) {\n        if (n == 0) return 0;\n        auto adjList = createAdjList(edges, n);\n        auto [farthestNode1, dist1] = bfs(adjList, 0);\n        auto [farthestNode2, diameter] = bfs(adjList, farthestNode1);\n        return diameter;\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        /*\n\n            4 , 4 => 5\n            5 , 5 => 5\n            5,3 => 5\n            4,2\n\n            n/2 + m/2 + 1\n\n               o- o - o\n                  |\n  \n            o -o -o -o - o\n\n\n\n\n\n\n\n        */\n\n\n        int n1 = 0, n2 = 0;\n        for (const auto& edge : edges1) {\n            n1 = max(n1, max(edge[0], edge[1]) + 1);\n        }\n        for (const auto& edge : edges2) {\n            n2 = max(n2, max(edge[0], edge[1]) + 1);\n        }\n\n        int d1 = findDiameter(edges1, n1);\n        int d2 = findDiameter(edges2, n2);\n\n        int res = max(d1,d2);\n        res = max(res,((d1+1)/2 + (d2+1)/2 + 1));\n\n\n        return res;\n    }\n};",
    "submit_ts": 1719719764.0
}