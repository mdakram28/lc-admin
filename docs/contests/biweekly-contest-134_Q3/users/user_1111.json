{
    "username": "adityaraj_19",
    "submission": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b)   for (int i = (a);i < (b); ++i)\n#define RFOR(i, a, b)  for (int i = (a);i > (b); --i)\n#define Traverse(i, a) for(auto& i : a)\n#define all(x)         std::begin(x), std::end(x)\n#define rall(x)        std::end(x), std::begin(x)\n#define nl             \"\\n\"\n#define ff             first\n#define ss             second\n#define eb             emplace_back\n#define sz(x)          ((ll)(x).size())\n#define yes            cout << \"Yes\\n\"\n#define no             cout << \"No\\n\"\n#define set_bits       __builtin_popcountll\nusing ll = long long int;\nusing vi = vector<int>;\nusing vs = vector<string>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\n\nconst auto boostIO = []() {\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    cout << fixed; cout.precision(12);\n    return 0;\n}();\n\nstruct custom_hash { // Credits: https://codeforces.com/blog/entry/62393\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n\n    size_t operator()(pair<int64_t,int64_t> Y) const{\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(Y.first * 31 + Y.second + FIXED_RANDOM);\n    }\n};\ntemplate <typename Key, typename Value> using um = unordered_map<Key, Value, custom_hash>;\ntemplate <typename Key> using ust = unordered_set<Key, custom_hash>;\n\nconst ll N = 1e6 + 7;\nconst ll MOD = 1e9 + 7; // 998244353;\n\n/* Direction Array */\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n// int dx[] = {0, 0, 1, -1, -1, 1, -1, 1};\n// int dy[] = { -1, 1, 0, 0, 1, 1, -1, -1};\n\n#define SEIVE\nint chk_prime[N];\nvector<int> prime;\nvoid seive(){\n    for(int i = 2; i <= N; i++){\n        if(!chk_prime[i]){\n            prime.eb(i);\n            for(int j = i * i; j <= N; j += i) \n                chk_prime[j] = 1;\n        }\n        chk_prime[i] ^= 1;\n    }\n}\n\nint power(int base, int exp, const int M = MOD) {\n    int p = 1;\n    base %= M;\n    while (exp) {\n        if (exp & 1)\n            p = (p * base) % M;\n        base = (base * base) % M;\n        exp >>= 1ll;\n    }\n    return p;\n}\nint modInverse(int x, int m) { return power(x, m - 2);}\n\nint fact[N], invf[N];\nvoid Precompute() {\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) \n        fact[i] = (fact[i - 1] * i) % MOD;\n\n    invf[N - 1] = modInverse(fact[N - 1], MOD);\n    for (int i = N - 2; i >= 0; --i) \n        invf[i] = (invf[i + 1] * (i + 1)) % MOD;\n}\n\nint ncr(int n, int r) {\n    if (r < 0 or n < r) return 0;\n    return (fact[n] * ((invf[r] * invf[n - r]) % MOD)) % MOD;\n}\n\n\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate <class T> \nusing pbds =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<class T> istream& operator >> (istream &is,vector<T> &V){ for(auto &x : V) is >> x; return is; }\ntemplate<class T> istream& operator >> (istream &is,vector<vector<T>> &V){ for(auto &x : V) is >> x; return is; }\ntemplate<typename T, typename S> istream& operator >> (istream &i, pair<T, S> &p) { return (i >> p.ff >> p.ss); }\ntemplate<typename T, typename S> ostream& operator << (ostream& o, const pair<T, S> &p){return o << p.ff << \" \" << p.ss;}\ntemplate<typename T> ostream& operator << (ostream &ostream, const vector<T> &c) { for (const auto &it : c) cout << it << \" \" ; return ostream; }\ntemplate<typename T> void print(T && x) {cout << x << \"\\n\";}\ntemplate<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' '; print(y...);}\ntemplate<typename T> T isqrt(const T &x){T y = sqrtl(x + 2); while(y * y > x) y--; return y;}\ntemplate<class T> bool chmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool chmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ninline int ceil(int a, int b) { return (a + b - 1ll) / b; }\ntemplate <typename T> T gcd(T x, T y) { return x ? gcd(y % x, x) : y; }\ntemplate <typename T> T lcm(T x, T y) { return (x / gcd(x, y)) * y; }\nstatic bool cmp(pii &a, pii &b) { return a.ss > b.ss; }\n\nclass Solution {\npublic:\n    int numberOfAlternatingGroups(vector<int>& a, int k) {\n        a.insert(a.end(), a.begin(), a.begin() + k);\n        int n = a.size(), ans = 0;\n        k--;\n        vi pr(n + 1);\n        FOR(i, 1, n) {\n            int dif = abs(a[i - 1] - a[i]);\n            pr[i] += pr[i - 1] + dif;\n        }\n            \n    \n        FOR(i, k + 1, n) \n            ans += (pr[i] - k == pr[i - k]);\n        return ans;\n    }\n};\n\n// #define LOCAL\n#ifdef LOCAL\nint main()\n{\n    Solution s;\n    // cout<<\"Ans:\"<<s.runSoln(20)<<\":Fn\"<<endl;\n    // cout<<\"Ans:\"<<s.runSoln(100)<<\":Fn\"<<endl;\n    // cout<<\"Ans:\"<<s.runSoln(1000)<<\":Fn\"<<endl;\n    return 0;\n}\n#endif\n\n\n\n\n\n",
    "submit_ts": "1720279774",
    "subm_id": "1311764556"
}