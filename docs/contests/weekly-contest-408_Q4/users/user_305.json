{
    "username": "leetcodejune30",
    "submission": "// class Solution {\n\n// public:\n//     int bfs(vector<vector<int>> &graph, int start, int target1, int target2, int nodes) {\n//     queue<int> q;\n//     vector<int> visited(nodes + 4, 0);\n//     q.push(start);\n//     visited[start] = 1;\n    \n//     while (!q.empty()) {\n//         int u = q.front();\n//         q.pop();\n//         for (int v : graph[u]) {\n//             if (!visited[v]) {\n//                 q.push(v);\n//                 visited[v] = 1;\n//             }\n//         }\n//     }\n//     return visited[target1] || visited[target2];\n// }\n    \n//     bool canReachCorner(int X, int Y, vector<vector<int>>& circles2) {\n//          vector<pair<pair<int, int>, int>> circles(circles2.size());\n//          vector<vector<int>> graph(circles2.size() + 4);\n//         int num_circles=circles2.size();\n        \n//         for (int i = 0; i < num_circles; ++i) {\n//             circles[i].first.first=circles2[i][0];\n//             circles[i].first.second=circles2[i][1];\n//             circles[i].second=circles2[i][2];\n//         }\n        \n        \n        \n//          for (int i = 0; i < num_circles; ++i) {\n             \n//             if (circles[i].first.first <= circles[i].second) {\n//                 graph[num_circles].push_back(i);\n//                 graph[i].push_back(num_circles);\n//             }\n//             if (X - circles[i].first.first <= circles[i].second) {\n//                 graph[num_circles + 2].push_back(i);\n//                 graph[i].push_back(num_circles + 2);\n//             }\n//             if (circles[i].first.second <= circles[i].second) {\n//                 graph[num_circles + 1].push_back(i);\n//                 graph[i].push_back(num_circles + 1);\n//             }\n//             if (Y - circles[i].first.second <= circles[i].second) {\n//                 graph[num_circles + 3].push_back(i);\n//                 graph[i].push_back(num_circles + 3);\n//             }\n//             for (int j = i + 1; j < num_circles; ++j) {\n//                 double distance = sqrt(pow(circles[i].first.first - circles[j].first.first, 2) +\n//                                        pow(circles[i].first.second - circles[j].first.second, 2));\n//                 int radius_sum = circles[i].second + circles[j].second;\n//                 if (radius_sum >= distance) {\n//                     graph[i].push_back(j);\n//                     graph[j].push_back(i);\n//                 }\n//             }\n//         }\n        \n//         int is_blocked = 0;\n// is_blocked = max(is_blocked, bfs(graph, num_circles, num_circles + 1, num_circles + 2, num_circles + 4)); // Check for bottom-left corner\n//     is_blocked = max(is_blocked, bfs(graph, num_circles + 3, num_circles + 2, num_circles + 1, num_circles + 4)); // Check for top-right corner\n//         if (is_blocked){return false;}\n//         return true;\n       \n        \n       \n//     }\n// };\n\nclass Solution {\n\npublic:\n    int breadthFirstSearch(vector<vector<int>> &adjacencyList, int startNode, int targetNode1, int targetNode2, int totalNodes) {\n        queue<int> nodeQueue;\n        vector<int> visitedNodes(totalNodes + 4, 0);\n        nodeQueue.push(startNode);\n        visitedNodes[startNode] = 1;\n        \n        while (!nodeQueue.empty()) {\n            int currentNode = nodeQueue.front();\n            nodeQueue.pop();\n            for (int neighborNode : adjacencyList[currentNode]) {\n                if (!visitedNodes[neighborNode]) {\n                    nodeQueue.push(neighborNode);\n                    visitedNodes[neighborNode] = 1;\n                }\n            }\n        }\n        return visitedNodes[targetNode1] || visitedNodes[targetNode2];\n    }\n    \n    bool canReachCorner(int width, int height, vector<vector<int>>& circleData) {\n        vector<pair<pair<int, int>, int>> circleDetails(circleData.size());\n        vector<vector<int>> adjacencyList(circleData.size() + 4);\n        int circleCount = circleData.size();\n        \n        for (int i = 0; i < circleCount; ++i) {\n            circleDetails[i].first.first = circleData[i][0];\n            circleDetails[i].first.second = circleData[i][1];\n            circleDetails[i].second = circleData[i][2];\n        }\n        \n        for (int i = 0; i < circleCount; ++i) {\n            if (circleDetails[i].first.first <= circleDetails[i].second) {\n                adjacencyList[circleCount].push_back(i);\n                adjacencyList[i].push_back(circleCount);\n            }\n            if (width - circleDetails[i].first.first <= circleDetails[i].second) {\n                adjacencyList[circleCount + 2].push_back(i);\n                adjacencyList[i].push_back(circleCount + 2);\n            }\n            if (circleDetails[i].first.second <= circleDetails[i].second) {\n                adjacencyList[circleCount + 1].push_back(i);\n                adjacencyList[i].push_back(circleCount + 1);\n            }\n            if (height - circleDetails[i].first.second <= circleDetails[i].second) {\n                adjacencyList[circleCount + 3].push_back(i);\n                adjacencyList[i].push_back(circleCount + 3);\n            }\n            for (int j = i + 1; j < circleCount; ++j) {\n                double distance = sqrt(pow(circleDetails[i].first.first - circleDetails[j].first.first, 2) +\n                                       pow(circleDetails[i].first.second - circleDetails[j].first.second, 2));\n                int radiusSum = circleDetails[i].second + circleDetails[j].second;\n                if (radiusSum >= distance) {\n                    adjacencyList[i].push_back(j);\n                    adjacencyList[j].push_back(i);\n                }\n            }\n        }\n        \n        int isBlocked = 0;\n        isBlocked = max(isBlocked, breadthFirstSearch(adjacencyList, circleCount, circleCount + 1, circleCount + 2, circleCount + 4)); // Check for bottom-left corner\n        isBlocked = max(isBlocked, breadthFirstSearch(adjacencyList, circleCount + 3, circleCount + 2, circleCount + 1, circleCount + 4)); // Check for top-right corner\n        \n        return !isBlocked;\n    }\n};",
    "submit_ts": "1722136853",
    "subm_id": "1335746877"
}