{
    "username": "Rajan_dubey",
    "submission": "\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> result;\n        vector<int> segmentTree(4 * n, 0); \n       \n        auto isPeak = [&](int i) {\n            if (i <= 0 || i >= n - 1) return false;\n            return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n        };\n    \n        function<void(int, int, int)> build = [&](int node, int start, int end) {\n            if (start == end) {\n                segmentTree[node] = isPeak(start) ? 1 : 0;\n            } else {\n                int mid = (start + end) / 2;\n                build(2 * node, start, mid);\n                build(2 * node + 1, mid + 1, end);\n                segmentTree[node] = segmentTree[2 * node] + segmentTree[2 * node + 1];\n            }\n        };\n        \n    \n        function<void(int, int, int, int)> update = [&](int node, int start, int end, int idx) {\n            if (start == end) {\n                segmentTree[node] = isPeak(idx) ? 1 : 0;\n            } else {\n                int mid = (start + end) / 2;\n                if (start <= idx && idx <= mid) {\n                    update(2 * node, start, mid, idx);\n                } else {\n                    update(2 * node + 1, mid + 1, end, idx);\n                }\n                segmentTree[node] = segmentTree[2 * node] + segmentTree[2 * node + 1];\n            }\n        };\n        \n      \n        function<int(int, int, int, int, int)> querySegmentTree = [&](int node, int start, int end, int L, int R) {\n            if (R < start || end < L) {\n                return 0; \n            }\n            if (L <= start && end <= R) {\n                return segmentTree[node];\n            }\n            int mid = (start + end) / 2;\n            return querySegmentTree(2 * node, start, mid, L, R) + querySegmentTree(2 * node + 1, mid + 1, end, L, R);\n        };\n        \n        build(1, 0, n - 1);\n        \n        for (const auto& query : queries) {\n            if (query[0] == 1) {\n               \n                int li = query[1], ri = query[2];\n                if (li + 1 >= ri) {\n                    result.push_back(0);\n                } else {\n                    result.push_back(querySegmentTree(1, 0, n - 1, li + 1, ri - 1));\n                }\n            } else if (query[0] == 2) {\n             \n                int index = query[1], val = query[2];\n                nums[index] = val;\n                for (int i = max(1, index - 1); i <= min(n - 2, index + 1); ++i) {\n                    update(1, 0, n - 1, i);\n                }\n            }\n        }\n        \n        return result;\n    }\n};\n",
    "submit_ts": 1718508596.0
}