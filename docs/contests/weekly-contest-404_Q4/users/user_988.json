{
    "username": "tirederit_5",
    "submission": "class Solution {\npublic:\n    pair<int, int> dfs(int node, int parent, vector<vector<int>>& adj) {\n        int diameter = 0;\n        int farthest = node;\n\n        for (int neighbor : adj[node]) {\n            if (neighbor != parent) {\n                auto [child_diameter, child_farthest] = dfs(neighbor, node, adj);\n                diameter = max(diameter, child_diameter);\n                if (child_diameter + 1 > diameter) {\n                    diameter = child_diameter + 1;\n                    farthest = child_farthest;\n                }\n            }\n        }\n\n        return {diameter, farthest};\n    }\n\n    int getDiameter(vector<vector<int>>& edges) {\n        if (edges.empty()) return 0;\n\n        int n = edges.size() + 1;\n        vector<vector<int>> adj(n);\n\n        for (auto& edge : edges) {\n            int u = edge[0], v = edge[1];\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n\n        auto [diameter, farthest1] = dfs(0, -1, adj);\n        auto [final_diameter, farthest2] = dfs(farthest1, -1, adj);\n\n        return final_diameter;\n    }\n\n\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int d1 = getDiameter(edges1);\n        int d2 = getDiameter(edges2);\n\n        int r1 = (d1 + 1) / 2;\n        int r2 = (d2 + 1) / 2;\n\n        return max({d1, d2, r1 + r2 + 1});\n    }\n};\n\n",
    "submit_ts": 1719716234.0
}