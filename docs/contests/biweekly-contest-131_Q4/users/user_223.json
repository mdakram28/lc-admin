{
    "username": "Rohit_Meena",
    "submission": "#define ll long long\ntemplate<class T, class U>\nstruct Lsegtree{\n    ll n; vector<T>st; vector<U>lazy; T identity_element; U identity_update;\n\n    /*\n        Definition of identity_element: the element I such that combine(x,I) = x\n        for all x\n        Definition of identity_update: the element I such that apply(x,I) = x\n        for all x        \n    */\n    Lsegtree() {}\n    Lsegtree(ll n, T identity_element, U identity_update){\n        init(n,identity_element,identity_update);\n    }\n    void init(ll n, T identity_element, U identity_update){ this->n = n; this->identity_element = identity_element; this->identity_update = identity_update; st.assign(4*n,identity_element); lazy.assign(4*n, identity_update);}\n    \n    // Combine two nodes l and r.\n    T combine(T l, T r){\n        // T ans = (l+r);\t       // Sum\n        // T ans = min(l,r);\t   // Min\n        T ans = max(l,r);\t   // Max\n        return ans;\n    }\n    \n    // Apply update upd to node curr which belongs to range [tl,tr].\n    T apply(T curr, U upd, ll tl, ll tr){\n        T ans = upd;\n        // T ans = (tr-tl+1)*upd;             \t // set range to upd\n        // T ans = curr + (tr - tl + 1)*upd;    // increment range by upd\n        return ans;\n    }\n\n    // Combine an old update old_upd with a new update new_upd if the combination is for range [tl,tr].\n    U combineUpdate(U old_upd, U new_upd, ll tl, ll tr){\n        U ans = new_upd;         // Set to a value\n        // U ans = old_upd+new_upd; // Increase by a value\n        return ans;\n    }  \n\n    void buildUtil(ll v, ll tl, ll tr, vector<T>&a){\n        if(tl == tr){\n            st[v] = a[tl];\n            return;\n        }\n        ll tm = (tl + tr)>>1;\n        buildUtil(2*v + 1, tl, tm,a);\n        buildUtil(2*v + 2,tm+1,tr,a);\n        st[v] = combine(st[2*v + 1], st[2*v + 2]);\n    }\n\n    void push_down(ll v, ll tl, ll tr){\n        //for the below line to work, make sure the \"==\" operator is defined for U.\n        if(lazy[v] == identity_update)return;\n        st[v] = apply(st[v], lazy[v], tl, tr);\n        if(2*v + 2 < 4*n){\n            ll tm = (tl + tr)>>1;\n            lazy[2*v + 1] = combineUpdate(lazy[2*v+1], lazy[v], tl, tm);\n            lazy[2*v + 2] = combineUpdate(lazy[2*v+2], lazy[v], tm+1,tr);            \n        }\n        lazy[v] = identity_update;\n    }\n    T queryUtil(ll v, ll tl, ll tr, ll l, ll r){\n        push_down(v,tl,tr);\n        if(l > r)return identity_element;\n        if(tr < l or tl > r){\n            return identity_element;\n        }\n        if(l <= tl and r >= tr){\n            return st[v];\n        }\n        ll tm = (tl + tr)>>1;\n        return combine(queryUtil(2*v+1,tl,tm,l,r), queryUtil(2*v+2,tm+1,tr,l,r));\n    }\n    void updateUtil(ll v, ll tl, ll tr, ll l, ll r, U upd){\n        push_down(v,tl,tr); \n        if(tr < l or tl > r) return;\n        if(tl >=l and tr <=r){\n            lazy[v] = combineUpdate(lazy[v],upd,tl,tr);\n            push_down(v,tl,tr);\n        }\n        else{\n            ll tm = (tl + tr)>>1;\n            updateUtil(2*v+1,tl,tm,l,r,upd);\n            updateUtil(2*v+2,tm+1,tr,l,r,upd);\n            st[v] = combine(st[2*v + 1], st[2*v+2]);\n        }\n    }\n\n    void build(vector<T>a){\n        assert( (ll)a.size() == n);\n        buildUtil(0,0,n-1,a);\n    }\n    T query(ll l, ll r){\n        return queryUtil(0,0,n-1,l,r);\n    }\n    void update(ll l,ll r, U upd){\n        updateUtil(0,0,n-1,l,r,upd);\n    }\n};\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        set<pair<int,int>> st;\n        st.insert({0,1e5});\n        Lsegtree<int,int> lst(1e5+5,-1e9,0);\n        lst.update(0,1e5,1e5);\n\n        vector<bool> ans;\n        for(auto &q:queries){\n            int t = q[0], x = q[1];\n            if(t == 1){\n                auto it = st.upper_bound({x,1e5});\n                if(it == st.begin()) continue;\n                it--;\n                int l = it->first, r = it->second;\n                st.erase({l,r});\n                st.insert({l,x});\n                st.insert({x,r});\n                lst.update(l+1,x,x-l);\n                lst.update(x+1,r,r-x);\n            }\n            else{\n                int sz = q[2];\n                int res;\n                auto it = st.upper_bound({x,1e9});\n                if(it == st.begin()) res = lst.query(1,x);\n                else{\n                    it--;\n                    int l = it->first, r = it->second;\n                    res = lst.query(1,l);\n                    res = max(res,x-l);\n                }\n                if(res >= sz) ans.push_back(true);\n                else ans.push_back(false);\n            }\n\n            // for(int i = 1;i<=8;i++){\n            //     cout<<lst.query(i,i)<<\" \";\n            // }cout<<endl;\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716651211.0
}