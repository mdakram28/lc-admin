{
    "username": "hongyili",
    "submission": "import heapq\n\n\nclass Solution:\n    def combine_intervals(self, itvs):\n        itvs.sort()\n        rst = []\n        left, right = itvs[0]\n        for l, r in itvs[1:]:\n            if l <= right:\n                right = max(right, r)\n            else:\n                rst.append((left, right))\n                left, right = l, r\n        rst.append((left, right))\n        return rst\n    \n    def minus_intervals(self, itvs0, itvs1):\n        rst = []\n        i = 0\n        j = 0\n        while i < len(itvs0):\n            l, r = itvs0[i]\n            while j < len(itvs1) and itvs1[j][0] <= r:\n                bl, br = itvs1[j]\n                if bl-1 >= l:\n                    rst.append((l, min(bl-1, r)))\n                l = br+1\n                j += 1\n            if l <= r:\n                rst.append((l, r))\n            i += 1\n        return rst\n    \n    def helper(self, zeros, ones, twos):\n        tots = [(0, self.m)]\n        r = []\n        used = []\n        for itv in zeros:\n            r.append((itv, 0))\n        used = zeros\n        for itv in self.minus_intervals(ones, used):\n            r.append((itv, 1))\n        used = self.combine_intervals(used+ones)\n        for itv in self.minus_intervals(twos, used):\n            r.append((itv, 2))\n        used = self.combine_intervals(used+twos)\n        for itv in self.minus_intervals(tots, used):\n            r.append((itv, self.large))\n        r.sort()\n        return r\n    \n    def minChanges(self, nums: List[int], k: int) -> int:\n        self.n = len(nums)\n        self.m = max(k, max(nums))\n        self.large = (self.m + self.n) * 2 + 1\n        ops = []\n        for i in range(self.n//2):\n            j = self.n - 1 - i\n            v = nums[i]\n            u = nums[j]\n            if u <= v:\n                u, v = v, u # u >= v\n            # no change\n            zeros = [(u - v, u - v)]\n            # change one\n            \n            ones = []\n            if v <= k:\n                ones.append((0, max(k-v, v)))\n            else:\n                ones.append((v-k, v))\n            if u <= k:\n                ones.append((0, max(k-u, u)))\n            else:\n                ones.append((u-k, u))\n            ones = self.combine_intervals(ones)\n            \n            # change two\n            twos = [(0, k)]\n            #print(zeros, ones, twos)\n            itvs = self.helper(zeros, ones, twos)\n            #print(itvs)\n            ops.extend(itvs)\n        ops.sort()\n        \n        rst = self.large\n        h = []\n        cum = 0\n        j = 0\n        for i in range(self.m+1):\n            while j < len(ops) and ops[j][0][0] <= i:\n                (l, r), c = ops[j]\n                j += 1\n                assert r >= i\n                cum += c\n                heapq.heappush(h, (r, c))\n            while h and h[0][0] < i:\n                _, c = heapq.heappop(h)\n                cum -= c\n            rst = min(rst, cum)\n        return rst\n            \n            \n                \n            ",
    "submit_ts": "1721490281",
    "subm_id": "1327478199"
}