{
    "username": "shu-xi",
    "submission": "# diff\u6570\u7ec4\u6b63\u8d1f\u4ea4\u6362\u7684\u5730\u65b9\u5206\u5f00\u505a\uff0c\u6bcf\u4e2a\u7ec4\u7684\u7edd\u5bf9\u503c\u6700\u5927\u503c\n# \u4ece\u5c0f\u5f80\u5927\uff0c\u6bcf\u4e2a\u53ea\u66f4\u65b0\u5230\u5de6\u53f3\u6700\u8fd1\u6bd4\u81ea\u5df1\u5c0f\u7684\u533a\u95f4\n\n# \u6a21\u677f: \u7ebf\u6bb5\u6811\nclass SegTree:\n    def __init__(self, a):\n        self.a, self.n = [0] + a, len(a)\n        self.d = [0 for i in range(4*self.n)]\n        self.b = [0 for i in range(4*self.n)] # for lazy update\n        self.v = [0 for i in range(4*self.n)] # for update2\n        self.__build(1, self.n, 1)\n    def __build(self, s, t, p): # build [s, t]\n        if s == t:\n            self.d[p] = self.a[s]\n            return\n        m = s + ((t - s) >> 1)\n        self.__build(s, m, p * 2)\n        self.__build(m + 1, t, p * 2 + 1)\n        self.d[p] = self.d[p * 2] + self.d[(p * 2) + 1]\n    def __update(self, l, r, c, s, t, p):\n        if l <= s and t <= r:\n            self.d[p] = self.d[p] + (t - s + 1) * c\n            self.b[p] = self.b[p] + c\n            return\n        m = s + ((t - s) >> 1)\n        if self.b[p] and s != t:\n            self.d[p * 2] = self.d[p * 2] + self.b[p] * (m - s + 1)\n            self.d[p * 2 + 1] = self.d[p * 2 + 1] + self.b[p] * (t - m)\n            self.b[p * 2] = self.b[p * 2] + self.b[p]\n            self.b[p * 2 + 1] = self.b[p * 2 + 1] + self.b[p]\n            self.b[p] = 0\n        if l <= m:\n            self.__update(l, r, c, s, m, p * 2)\n        if r > m:\n            self.__update(l, r, c, m + 1, t, p * 2 + 1)\n        self.d[p] = self.d[p * 2] + self.d[p * 2 + 1]\n    def update(self, l, r, c): # update [l, r] to add c\n        self.__update(l+1, r+1, c, 1, self.n, 1)\n    def __update2(self, l, r, c, s, t, p):\n        if l <= s and t <= r:\n            self.d[p] = (t - s + 1) * c\n            self.b[p] = c\n            self.v[p] = 1\n            return\n        m = s + ((t - s) >> 1)\n        if self.v[p]:\n            self.d[p * 2] = self.b[p] * (m - s + 1)\n            self.d[p * 2 + 1] = self.b[p] * (t - m)\n            self.b[p * 2] = self.b[p * 2 + 1] = self.b[p]\n            self.v[p * 2] = self.v[p * 2 + 1] = 1\n            self.v[p] = 0\n        if l <= m:\n            self.__update2(l, r, c, s, m, p * 2)\n        if r > m:\n            self.__update2(l, r, c, m + 1, t, p * 2 + 1)\n        self.d[p] = self.d[p * 2] + self.d[p * 2 + 1]\n    def update2(self, l, r, c): # update [l, r] to update to c\n        self.__update2(l+1, r+1, c, 1, self.n, 1)\n    def __getsum(self, l, r, s, t, p):\n        if l <= s and t <= r:\n            return self.d[p]\n        m = s + ((t - s) >> 1)\n        if self.b[p]:\n            self.d[p * 2] = self.d[p * 2] + self.b[p] * (m - s + 1)\n            self.d[p * 2 + 1] = self.d[p * 2 + 1] + self.b[p] * (t - m)\n            self.b[p * 2] = self.b[p * 2] + self.b[p]\n            self.b[p * 2 + 1] = self.b[p * 2 + 1] + self.b[p]\n            self.b[p] = 0\n        res = 0\n        if l <= m:\n            res = self.__getsum(l, r, s, m, p * 2)\n        if r > m:\n            res = res + self.__getsum(l, r, m + 1, t, p * 2 + 1)\n        return res\n    def getsum(self, l, r): # getsum [l, r]\n        return self.__getsum(l+1, r+1, 1, self.n, 1)\n\ndef pprint(*x):\n    # print(x)\n    pass\n\ndef f(arr):\n    pprint(\"====\", arr)\n    n = len(arr)\n    si = sorted([i for i in range(n)], key=lambda x: arr[x])\n    leftSmall = [-1 for i in range(n)]\n    s = []\n    for i in range(n):\n        while len(s) > 0 and s[-1][0] >= arr[i]:\n            s.pop()\n        if len(s) > 0:\n            leftSmall[i] = s[-1][1]\n        s.append([arr[i], i])\n    rightSmall = [n for i in range(n)]\n    s = []\n    for i in range(n-1, -1, -1):\n        while len(s) > 0 and s[-1][0] >= arr[i]:\n            s.pop()\n        if len(s) > 0:\n            rightSmall[i] = s[-1][1]\n        s.append([arr[i], i])\n    pprint(leftSmall, rightSmall)\n    \n    h = [0 for i in range(n)]\n    seg = SegTree(h)\n    res = 0\n    for i in si:\n        base = seg.getsum(i, i)\n        cur = arr[i]\n        res += cur - base\n        pprint(i, cur, base, leftSmall[i]+1, rightSmall[i]-1)\n        # pprint([seg.getsum(k, k) for k in range(n)])\n        seg.update(leftSmall[i]+1, rightSmall[i]-1, cur - base)\n        # pprint([seg.getsum(k, k) for k in range(n)])\n    pprint(\"*\", res)\n    return res\n    \nclass Solution:\n    def minimumOperations(self, nums: List[int], target: List[int]) -> int:\n        n = len(nums)\n        res = 0\n        arr = [target[i] - nums[i] for i in range(n)]\n        cur = [abs(arr[0])]\n        lastPos = arr[0] >= 0\n        for i in range(1, n):\n            curPos = arr[i] >= 0\n            if lastPos == curPos:\n                cur.append(abs(arr[i]))\n            else:\n                res += f(cur)\n                cur = [abs(arr[i])]\n            lastPos = curPos\n        res += f(cur)\n        return res",
    "submit_ts": "1721532259",
    "subm_id": "548391297"
}