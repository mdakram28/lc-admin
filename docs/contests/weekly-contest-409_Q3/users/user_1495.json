{
    "username": "Monil712001",
    "submission": "#define ll int \nclass Solution {\npublic:\n\n    vector<int> seg;\n    vector<int> lazy;\n\n    void update_in_range(ll node, ll start, ll end, ll l, ll r, ll val)\n    {\n        // here our idea is that if we encounter a pending lazy update then we first update it \n        // and then do the normal execution\n        // Now we check if the range represented by the current node is completely inside the update range \n        // then we add the update equivalent to val \n        // cout<<\"Range of Current Node \"<< start << \" \" << end <<endl;\n        // cout<<\" Lazy val : \"<<lazy[node]<<endl;\n        // cout<<\" Seg val : \"<<seg[node]<<endl;\n        if(lazy[node] != 0)\n        {\n            seg[node] = 0;\n            if(start != end)\n            {\n                lazy[2 * node+1] = 1;\n                lazy[2 * node + 2] = 1;\n            }\n            lazy[node]=0;\n        }\n        // if completely outside the range \n        if(r < start || end < l || l > r ) return;\n\n        // if the range represented by the current node is completely inside the update range \n        if(l <= start and end <= r)\n        {\n            seg[node] = 0;\n            //cout<<\" Seg val updated:  hiiiiiiiiii \"<<seg[node]<<endl;\n            if(start!=end)\n            {\n                lazy[2*node+1] = 1;\n                lazy[2*node+2] = 1;\n            }\n            return;\n        }\n\n        ll mid = start + (end-start)/2;\n        update_in_range(2*node+1,start,mid,l,r,val);\n        update_in_range(2*node+2,mid+1,end,l,r,val);\n        seg[node] = seg[2*node+1] + seg[2*node+2];\n    }\n\n    ll query_in_range(ll node, ll start, ll end, ll l, ll r)\n    {\n        if(lazy[node]!=0)\n        {\n            seg[node] = 0;\n            if(start != end)\n            {\n                lazy[2 * node+1] = 1;\n                lazy[2 * node + 2] = 1;\n            }\n            lazy[node]=0;\n        }\n\n        // outside range of node then return 0\n        if(r<start or end<l or l>r) return 0;\n        if(l <= start and end <= r) return seg[node];\n\n        ll mid = start + (end-start)/2;\n        ll ans1 = query_in_range(2*node + 1, start, mid, l, r);\n        ll ans2 = query_in_range(2*node+2, mid+1, end, l, r);\n        return ans1+ans2;\n    }\n\n    void build_seg(ll *a, ll node, ll start, ll end)\n    {\n        if (start == end)\n        {\n            // seg[node] = a[start];\n            if(start == 0)\n                seg[node] = 0;\n            else \n                seg[node] = 1;\n            return;\n        }\n        ll mid = start + (end - start) / 2;\n        build_seg(a, 2 * node + 1, start, mid);\n        build_seg(a, 2 * node + 2, mid + 1, end);\n\n        seg[node] = seg[2 * node + 1] + seg[2 * node + 2];\n    }\n\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        seg.assign(1000009, 0);\n        lazy.assign(1000009, 0);\n        ll q = queries.size();\n\n        ll a[n];\n        for(int i=0; i<n; i++)\n            if(i==0)\n                a[i] = 0;\n            else \n                a[i] = 1;\n\n        build_seg(a, 0, 0, n-1);\n\n        vector<int> ans;\n        // for(int i=0; i<4*n; i++)\n        //     cout<<seg[i]<<\" \";\n        \n        for(auto x : queries) {\n            int start = x[0];\n            int end = x[1];\n            start++;\n            end--;\n            update_in_range(0, 0, n-1, start, end, 0);\n            int k = query_in_range(0, 0, n-1, 0, n-1);\n            ans.push_back(k);\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": "1722743004",
    "subm_id": "1343782111"
}