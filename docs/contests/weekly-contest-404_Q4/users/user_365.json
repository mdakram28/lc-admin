{
    "username": "AC_Mikoto",
    "submission": "\nfrom collections import defaultdict\n\nclass Solve:\n    def __init__(self):\n        self.tree = defaultdict(list)\n        self.max_d = 0\n\n    def dfs(self, node, parent):\n        max1 = max2 = 0\n        for neighbor in self.tree[node]:\n            if neighbor != parent:\n                depth = self.dfs(neighbor, node)\n                if depth > max1:\n                    max1, max2 = depth, max1\n                elif depth > max2:\n                    max2 = depth\n        self.max_d = max(self.max_d, max1 + max2)\n        return max1 + 1\n\n    def treeDiameter(self, edges):\n        for u, v in edges:\n            self.tree[u].append(v)\n            self.tree[v].append(u)\n        self.dfs(0, -1)\n        return self.max_d\n    \nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        n, m = len(edges1), len(edges2)\n        a = Solve().treeDiameter(edges1)\n        b = Solve().treeDiameter(edges2)\n        def h(x):\n            return (x + 1) // 2\n        return max(a, b, h(a) + h(b) + 1)\n        ",
    "submit_ts": 1719718068.0
}