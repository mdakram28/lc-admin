{
    "username": "51_KING",
    "submission": "\n\nclass SegmentTree {\npublic:\n    SegmentTree(const vector<int>& nums) : nums(nums) {\n        n = nums.size();\n        tree.resize(4 * n, 0);\n        build(0, 0, n - 1);\n     }\n\n    void update(int index, int value) {\n        update(0, 0, n - 1, index,value);\n    }\n\n    int query(int l, int r) {\n        return query(0, 0, n - 1, l, r);\n    }\n\nprivate:\n    vector<int> nums;\n    vector<int> tree;\n    int n;\n\n    void build(int node, int start, int end) {\n        if (start == end) {\n            tree[node] = 0;\n        } else {\n            int mid = (start + end) / 2;\n            build(2 * node + 1, start, mid);\n            build(2 * node + 2, mid + 1, end);\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n            if(mid+2<=end && nums[mid] < nums[mid+1] && nums[mid+1] > nums[mid+2]) tree[node]+=1;\n            if(mid-1>=start && mid+1 <= end && nums[mid-1]<nums[mid] && nums[mid] > nums[mid+1]) tree[node]+=1;\n        }\n    }\n\n    void update(int node, int start, int end, int idx,int value) {\n        if (start == end) {\n            if(start==idx){\n                nums[idx] = value;\n            }\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid) {\n                update(2 * node + 1, start, mid, idx,value);\n            } else {\n                update(2 * node + 2, mid + 1, end, idx,value);\n            }\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n            if(mid+2<=end && nums[mid] < nums[mid+1] && nums[mid+1] > nums[mid+2]) tree[node]+=1;\n            if(mid-1>=start && mid+1<=end && nums[mid-1]<nums[mid] && nums[mid] > nums[mid+1]) tree[node]+=1;\n        }\n    }\n\n    int query(int node, int start, int end, int l, int r) {\n        if (r < start || end < l) {\n            return 0;\n        }\n        if (l <= start && end <= r) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int left = query(2 * node + 1, start, mid, l, r);\n        int right = query(2 * node + 2, mid + 1, end, l, r);\n        int ans = 0;\n        if(mid+2<=end && mid+2<=r && mid>=l && nums[mid] < nums[mid+1] && nums[mid+1] > nums[mid+2]) ans+=1;\n        \n        if(mid-1>=start && mid+1<=end && mid-1>=l && mid+1<=r && nums[mid-1]<nums[mid] && nums[mid] > nums[mid+1]) ans+=1;\n\n        return left + right + ans;\n    }\n};\nclass Help {\npublic:\n    long long dfs(int curr,int p,long long k,vector <vector<pair<int,long long>>> &dp){\n        if(p==-1) return 0;\n        if(k&(1LL<<p)){\n            return dp[p][curr].second+dfs(dp[p][curr].first,p-1,k,dp);\n        }\n        return dfs(curr,p-1,k,dp);\n    }\n    long long getMaxFunctionValue(vector<int>& arr, long long k) {\n        int n = arr.size();\n        vector <vector<pair<int,long long>>> dp(40,vector<pair<int,long long>>(n));\n        \n        for(int i=0;i<n;i++) dp[0][i] = {arr[i],arr[i]};\n\n        for(int i=1;i<40;i++){\n            for(int j=0;j<n;j++){\n                int x = dp[i-1][j].first;\n                dp[i][j] = {dp[i-1][x].first,dp[i-1][x].second+dp[i-1][j].second};\n            }\n        }\n  \n        long long ans = 0;\n        for(int i=0;i<n;i++){\n            ans = max(ans,dfs(i,39,k,dp)+i);\n        }\n        return ans;\n        \n    }\n};\nclass Solution {\npublic:\n     const int MOD = 1e9 + 7;\n    \n    int findWays(int index, int prevChoice, vector<int>& values, vector<vector<int>>& memo) {\n        if (index == values.size()) return 1;\n        if (memo[index][prevChoice] != -1) return memo[index][prevChoice];\n\n        int result = 0;\n        int secondPrevChoice = values[index - 1] - prevChoice;\n\n        for (int currentChoice = values[index]; currentChoice >= prevChoice; --currentChoice) {\n            int choice1 = currentChoice;\n            int choice2 = values[index] - currentChoice;\n            if (choice2 <= secondPrevChoice) {\n                result = (result + findWays(index + 1, choice1, values, memo)) % MOD;\n            } else {\n                break;\n            }\n        }\n\n        return memo[index][prevChoice] = result;\n    }\n    int countOfPairs(vector<int>& values) {\n         int totalWays = 0;\n        int n = values.size();\n        vector<vector<int>> memo(n + 1, vector<int>(51, -1));\n\n        for (int i = 0; i <= values[0]; ++i) {\n            totalWays = (totalWays + findWays(1, i, values, memo)) % MOD;\n        }\n\n        return totalWays;\n    }\n};",
    "submit_ts": "1723344362",
    "subm_id": "1351532708"
}