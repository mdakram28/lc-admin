{
    "username": "Pisces311",
    "submission": "template <typename T = int, int mn = 0, int mx = 100005>\nclass segmentTree {\n    struct Node {\n        T val, lazy;\n        int ls, rs;\n    };\n\n    int cnt;\n    vector<Node> tr;\n\n    void pushUp(int o, int l, int r) {\n        \n    }\n\n    void pushDown(int o, int l, int r) {\n        if (!tr[o].ls) tr[o].ls = ++cnt, tr.emplace_back();\n        if (!tr[o].rs) tr[o].rs = ++cnt, tr.emplace_back();\n        if (tr[o].lazy != 0) {\n            int mid = (l + r) / 2;\n            tr[tr[o].ls].val += tr[o].lazy * (mid - l + 1);\n            tr[tr[o].rs].val += tr[o].lazy * (r - mid);\n            tr[tr[o].ls].lazy += tr[o].lazy;\n            tr[tr[o].rs].lazy += tr[o].lazy;\n            tr[o].lazy = 0;\n        }\n    }\n\n   public:\n    segmentTree() : tr(1), cnt(0) { tr.reserve(500000); }\n\n    T query(int ql, int qr, int o = 0, int l = mn, int r = mx) {\n        if (r < ql || qr < l) return 0;\n        if (ql <= l && r <= qr) return tr[o].val;\n        pushDown(o, l, r);\n        int mid = (l + r) >> 1;\n        return query(ql, qr, tr[o].ls, l, mid) +\n               query(ql, qr, tr[o].rs, mid + 1, r);\n    }\n\n    void update(int ql, int qr, T k, int o = 0, int l = mn, int r = mx) {\n        if (r < ql || qr < l) return;\n        if (ql <= l && r <= qr) {\n            tr[o].lazy += k;\n            tr[o].val += k * (r - l + 1);\n            return;\n        }\n        pushDown(o, l, r);\n        int mid = (l + r) >> 1;\n        update(ql, qr, k, tr[o].ls, l, mid);\n        update(ql, qr, k, tr[o].rs, mid + 1, r);\n        pushUp(o, l, r);\n    }\n};\n\ntemplate <typename T = int, int mn = 0, int mx = 100005>\nclass segmentTree2 {\n    struct Node {\n        T lval, rval, lazy;\n        int ls, rs;\n    };\n\n    int cnt;\n    vector<Node> tr;\n\n    void pushUp(int o, int l, int r) {\n        \n    }\n\n    void pushDown(int o, int l, int r) {\n        if (!tr[o].ls) tr[o].ls = ++cnt, tr.emplace_back();\n        if (!tr[o].rs) tr[o].rs = ++cnt, tr.emplace_back();\n        if (tr[o].lazy != 0) {\n            int mid = (l + r) / 2;\n            tr[tr[o].ls].lval = tr[tr[o].ls].rval = tr[o].lazy * (mid - l + 1);\n            tr[tr[o].rs].lval = tr[tr[o].rs].rval = tr[o].lazy * (r - mid);\n            tr[tr[o].ls].lazy = tr[o].lazy;\n            tr[tr[o].rs].lazy = tr[o].lazy;\n            tr[o].lazy = 0;\n        }\n    }\n\n   public:\n    segmentTree2() : tr(1), cnt(0) { tr.reserve(500000); }\n\n    T query(int q, bool left, int o = 0, int l = mn, int r = mx) {\n        if (r < q || q < l) return 0;\n        if (q <= l && r <= q) return (left ? tr[o].lval : tr[o].rval);\n        pushDown(o, l, r);\n        int mid = (l + r) >> 1;\n        return query(q, left, tr[o].ls, l, mid) +\n               query(q, left, tr[o].rs, mid + 1, r);\n    }\n\n    void update(int ql, int qr, T k, int o = 0, int l = mn, int r = mx) {\n        if (ql > qr) return;\n        if (r < ql || qr < l) return;\n        if (ql <= l && r <= qr) {\n            tr[o].lazy = k;\n            tr[o].lval = tr[o].rval = k;\n            return;\n        }\n        pushDown(o, l, r);\n        int mid = (l + r) >> 1;\n        update(ql, qr, k, tr[o].ls, l, mid);\n        update(ql, qr, k, tr[o].rs, mid + 1, r);\n        pushUp(o, l, r);\n    }\n    \n    void update_single(int q, T k, bool left, int o = 0, int l = mn, int r = mx) {\n        if (r < q || q < l) return;\n        if (q <= l && r <= q) {\n            tr[o].lazy = k;\n            if (left) {\n                tr[o].lval = k;\n            } else {\n                tr[o].rval = k;\n            }\n            return;\n        }\n        pushDown(o, l, r);\n        int mid = (l + r) >> 1;\n        update_single(q, k, left, tr[o].ls, l, mid);\n        update_single(q, k, left, tr[o].rs, mid + 1, r);\n        pushUp(o, l, r);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        segmentTree<> st;\n        segmentTree2<> cover;\n        for (int i = 1; i < n; i++) {\n            st.update(i, i, i);\n        }\n        vector<int> ret;\n        for (int i = 0; i < queries.size(); i++) {\n            auto& q = queries[i];\n            int u = q[0], v = q[1];\n            int qu = cover.query(u, false);\n            int qv = cover.query(v, true);\n            // cout << qu << ' ' << qv << endl;\n            if (qu == 0 || qu != qv) {\n                int diff = st.query(v, v) - st.query(u, u);\n                st.update(v, n - 1, 1 - diff);\n                cover.update(u + 1, v - 1, i + 1);\n                cover.update_single(u, i + 1, false);\n                cover.update_single(v, i + 1, true);\n            }\n            ret.push_back(st.query(n - 1, n - 1));\n            // for (int i = 0; i < n; i++) {\n            //     cout << cover.query(i, true) << ' ';\n            // }\n            // cout << endl;\n            // for (int i = 0; i < n; i++) {\n            //     cout << cover.query(i, false) << ' ';\n            // }\n            // cout << endl;\n        }\n        return ret;\n    }\n};",
    "submit_ts": "1722743288",
    "subm_id": "1343788584"
}