{
    "username": "Tkiyqe1w8P",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        d1, d2 = tree_diameter(edges1), tree_diameter(edges2)\n        return max([d1, d2, 1 + (d1+1) // 2 + (d2+1) // 2])\n\n# def search_below(root: int, father: int, d1: List[int], d2: List[int], n1: List[int], n2: List[int], E: List[List[int]]) -> None:\n#         for t in E[root]:\n#             if t == father:\n#                 continue\n#             search_below(t, root, d1, d2, n1, n2, E)\n#             if d1[t] + 1 > d1[root]:\n#                 d2[root] = d1[root]\n#                 n2[root] = n1[root]\n#                 d1[root] = d1[t] + 1\n#                 n1[root] = t\n#             elif d1[t] + 1 > d2[root]:\n#                 d2[root] = d1[t] + 1\n#                 n2[root] = t\n\n# def search_above(root: int, father: int, d1: List[int], d2: List[int], n1: List[int], up: List[int], max_lens: List[int], E: List[List[int]]) -> int:\n#     if father != -1:\n#         if n1[father] != root:\n#             up[root] = max(d1[father], up[father]) + 1\n#         else:\n#             up[root] = max(d2[father], up[father]) + 1\n#     min_len = max(d1[root], up[root])\n#     max_lens[root] = min_len\n#     for t in E[root]:\n#         if t == father:\n#             continue\n#         min_len = min(min_len, search_above(t, root, d1, d2, n1, up, max_lens, E))\n#     return min_len\n\n# def findMinHeightTrees(n: int, edges: List[List[int]]) -> List[int]:\n#     E = [[] for _ in range(n)]\n#     for e in edges:\n#         E[e[0]].append(e[1])\n#         E[e[1]].append(e[0])\n\n#     d1 = [0] * n\n#     d2 = [0] * n\n#     up = [0] * n\n#     n1 = [-1] * n\n#     n2 = [-1] * n\n#     max_lens = [0] * n\n\n#     self.search_below(0, -1, d1, d2, n1, n2, E)\n#     min_len = self.search_above(0, -1, d1, d2, n1, up, max_lens, E)\n\n#     ans = []\n#     for i in range(n):\n#         if max_lens[i] == min_len:\n#             ans.append(i)\n#     return ans\n\ndef build_graph(edges):\n    graph = {}\n    for u, v in edges:\n        if u not in graph:\n            graph[u] = []\n        if v not in graph:\n            graph[v] = []\n        graph[u].append(v)\n        graph[v].append(u)\n    return graph\n\ndef bfs(start, graph):\n    visited = set()\n    queue = deque([(start, 0)]) \n    farthest_node = start\n    max_distance = 0\n    \n    while queue:\n        node, distance = queue.popleft()\n        if distance > max_distance:\n            max_distance = distance\n            farthest_node = node\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append((neighbor, distance + 1))\n    \n    return farthest_node, max_distance\n\ndef tree_diameter(edges):\n    if not edges:\n        return 0\n    \n    graph = build_graph(edges)\n    start_node = edges[0][0]  # Start BFS from any node, here we choose the first node of the first edge\n    \n    # First BFS to find one endpoint of the diameter\n    node_a, _ = bfs(start_node, graph)\n    \n    # Second BFS to find the other endpoint and the diameter\n    node_b, diameter = bfs(node_a, graph)\n    \n    return diameter",
    "submit_ts": 1719718252.0
}