{
    "username": "Om_Ashish_Soni",
    "submission": "class Solution {\npublic:\n    #define pb push_back\n    #define ll long long\n    #define vll vector<ll>\n    #define pii pair<ll,ll>\n    \n    int getcost(int a,int b){\n        if(b%2) return 1;\n        return 2;\n    }\n    void push(vector<ll>& pq,int new_cost){\n        if(pq[0]<=new_cost){\n            pq[1]=pq[0];\n            pq[0]=new_cost;\n        }else if(pq[1]<=new_cost){\n            pq[1]=new_cost;\n        }\n    }\n    void dfs1(vector<vector<int>>& graph,vector<int>& parent,vector<ll>& subtree,vector<vector<ll>>& score,int start){\n        \n        for(auto node:graph[start]){\n            if(parent[start] != node){\n                // assign parent\n                parent[node]=start;\n                // call\n                dfs1(graph,parent,subtree,score,node);\n                // calc subtree\n                subtree[start]+=subtree[node];\n                // calc score\n                ll curr_cost=getcost(start,node);\n                \n                push(score[start],curr_cost+score[node][0]);\n                // score[start].push();\n            }\n        }\n    }\n    \n    pii get_top_2(vector<ll> & pq){\n        return {pq[0],pq[1]};\n//         pii pr;\n        \n//         if(pq.size()==0){\n//             cout<<\"something went wrong 1st\"<<endl;\n//             pq.push(0);\n//         }\n        \n//         ll top=pq.top();pq.pop();\n        \n//         pr.first=top;\n        \n//         if(pq.size()==0){\n//             cout<<\"something went wrong 2nd\"<<endl;\n//             pq.push(0);\n//         }\n        \n//         pr.second=pq.top();\n        \n//         pq.push(top);\n//         return pr;\n    }\n    \n    void dfs2(vector<vector<int>>& graph,vector<int>& parent,vector<ll>& subtree,vector<vector<ll>>& score,int start){\n        int par=parent[start];\n        if(par != -1){\n            pii pr=get_top_2(score[par]);\n            \n            ll old_cost=getcost(par,start);\n            \n            ll mine=score[start][0]+old_cost;\n            \n            int major=pr.first;\n            \n            if(mine==pr.first){\n                major=pr.second;\n            }\n            \n            ll curr_cost=getcost(start,par);\n            \n            ll new_cost=major+curr_cost;\n            \n            // cout<<\"on dfs2 for : \"<<start<<endl;\n            // cout<<pr.first<<\" <-> \"<<pr.second<<endl;\n            // cout<<\"major : \"<<major<<\", mine : \"<<mine<<\", curr_cost : \"<<curr_cost<<endl;\n            // cout<<\"new_cost : \"<<new_cost<<endl;\n            push(score[start],new_cost);\n            // score[start].push(new_cost);\n            \n        }        \n        for(auto node:graph[start]){\n            if(parent[start] != node){\n                // call\n                dfs2(graph,parent,subtree,score,node);\n            }\n        }\n    }\n    void print_pq(priority_queue<ll> pq){\n        while(pq.size()>0){\n            cout<<pq.top()<<\" \";pq.pop();\n        }\n        cout<<endl;\n    }\n    \n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        int sz=edges.size();\n        int n=sz+1;\n        vector<vector<int>> graph(n);\n        vector<int> parent(n,-1);\n        vector<ll> subtree(n,1);\n        \n        vector<vector<ll>> score(n);\n        for(int i=0;i<n;i++){\n            // score[i].push(0);\n            score[i]={0,0};\n        }\n        for(auto & edge:edges){\n            int u=edge[0];\n            int v=edge[1];\n            graph[u].pb(v);\n            graph[v].pb(u);\n        }\n        dfs1(graph,parent,subtree,score,0);\n        // for(auto node:subtree) cout<<node<<\" \";cout<<endl;\n        // cout<<\"before : \"<<endl;\n        // for(int i=0;i<n;i++){\n        //     cout<<\"for i : \"<<i<<\" => \";\n        //     auto node=score[i];\n        //     while(node.size()>0){\n        //         cout<<node.top()<<\" \";\n        //         node.pop();\n        //     }\n        //     cout<<endl;\n        // }\n        dfs2(graph,parent,subtree,score,0);\n        \n        // cout<<\"after : \"<<endl;\n        // for(int i=0;i<n;i++){\n        //     cout<<\"for i : \"<<i<<\" => \";\n        //     auto node=score[i];\n        //     while(node.size()>0){\n        //         cout<<node.top()<<\" \";\n        //         node.pop();\n        //     }\n        //     cout<<endl;\n        // }\n        \n        // priority_queue<ll> pq;pq.push(1);pq.push(2);pq.push(3);\n        // cout<<\"before : \";print_pq(pq);\n        // pii pr=get_top_2(pq);\n        // cout<<pr.first<<\"<->\"<<pr.second<<endl;\n        // cout<<\"after : \";print_pq(pq);\n        \n        \n        // cout<<\"==========\"<<endl;\n        vector<int> ans(n,0);\n        for(int i=0;i<n;i++){\n            ans[i]=score[i][0];\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722700663",
    "subm_id": "1343248828"
}