{
    "username": "Ishwarendra",
    "submission": "using i64 = long long;\n\ntemplate<class Info,\n         class Merge = std::plus<Info>>\nstruct SegmentTree\n{\n    const int n;\n    const Merge merge;\n    std::vector<Info> info;\n    SegmentTree(int n = 0) : n(n), merge(Merge()), info(4 << std::__lg(n)) {}\n\n    template <typename T>\n    SegmentTree(const std::vector<T> a) : SegmentTree(std::size(a))\n    {\n        std::function<void(int, int, int)> build;\n        build = [&](int l, int r, int id)\n        {\n            if (l > r)\n                return;\n            if (l == r)\n            {\n                info[id] = Info(a[l], l);\n                return;\n            }\n\n            int m = (l + r) >> 1;\n            build(l, m, id * 2 + 1);\n            build(m + 1, r, id * 2 + 2);\n            pull(id);\n        };\n        build(0, n - 1, 0);\n    }\n    void pull(int id)\n    {\n        info[id] = merge(info[id * 2 + 1], info[id * 2 + 2]);\n    }\n    void update(int id, int l, int r, int x, const Info &v)\n    {\n        if (l > r)\n            return;\n        if (l == r)\n        {\n            info[id] = v;\n            return;\n        }\n\n        int m = (l + r) >> 1;\n        if (x <= m)\n            update(2 * id + 1, l, m, x, v);\n        else\n            update(2 * id + 2, m + 1, r, x, v);\n        pull(id);\n    }\n    void update(int x, const Info &v)\n    {\n        update(0, 0, n - 1, x, v);\n    }\n    Info get(int id, int l, int r, int a, int b)\n    {\n        if (r < a or l > b)\n            return Info();\n        if (l >= a and r <= b)\n            return info[id];\n\n        int m = (l + r) >> 1;\n        return merge(get(2 * id + 1, l, m, a, b), get(2 * id + 2, m + 1, r, a, b));\n    }\n    Info get(int l, int r)\n    {\n        return get(0, 0, n - 1, l, r);\n    };\n\n    template <class F>\n    int findFirst(int id, int l, int r, int a, int b, F pred)\n    {\n        if (r < a or l > b or !pred(info[id]))\n            return -1;\n\n        if (l == r)\n            return l;\n\n        int m = (l + r) >> 1;\n        int res = findFirst(2 * id + 1, l, m, a, b, pred);\n        if (res == -1)\n            res = findFirst(2 * id + 2, m + 1, r, a, b, pred);\n\n        return res;\n    }\n\n    template <class F>\n    int findFirst(int l, int r, F pred) { return findFirst(0, 0, n - 1, l, r, pred); }\n\n    template <class F>\n    int findLast(int id, int l, int r, int a, int b, F pred)\n    {\n        if (r < a or l > b or !pred(info[id]))\n            return -1;\n\n        if (l == r)\n            return l;\n\n        int m = (l + r) >> 1;\n        int res = findLast(2 * id + 2, m + 1, r, a, b, pred);\n\n        if (res == -1)\n            res = findLast(2 * id + 1, l, m, a, b, pred);\n\n        return res;\n    }\n\n    template <class F>\n    int findLast(int l, int r, F pred) { return findLast(0, 0, n - 1, l, r, pred); }\n};\n\nstruct Max\n{\n    int x;\n    Max(int x = -1e9) : x(x) {};\n};\n\nMax operator+(const Max &a, const Max &b)\n{\n    return Max(std::max(a.x, b.x));\n}\n\n\nclass Solution {\n    void chmax(int &a, int b)\n    {\n        if (a < b)\n            a = b;\n    }\npublic:\n    int maximumLength(vector<int>& a, int k) {\n        int n = std::size(a);\n        std::vector dp(n, std::vector(k + 1, -1));\n\n        dp[0][0] = 1;\n        std::vector max(k + 1, SegmentTree<Max>(n));\n        std::map<int, int> maxVal[k + 1];\n        maxVal[0][a[0]] = 1;\n        max[0].update(0, Max(1));\n        \n        for (int i = 1; i < n; i++)\n        {\n            for (int p = 0; p <= k; p++)\n            {\n                chmax(dp[i][p], 1);\n                int max1 = maxVal[p][a[i]];\n                int max2 = -1e9;\n                if (p > 0)\n                    max2 = max[p - 1].get(0, i - 1).x;\n                \n                dp[i][p] = std::max({dp[i][p], max1 + 1, max2 + 1});\n                max[p].update(i, Max(dp[i][p]));\n                chmax(maxVal[p][a[i]], dp[i][p]);\n\n                // for (int j = 0; j < i; j++)\n                // {\n                //     if (a[i] == a[j])\n                //         chmax(dp[i][p], dp[j][p] + 1);\n                //     if (p > 0 and a[i] != a[j])\n                //         chmax(dp[i][p], dp[j][p - 1] + 1);\n                // }\n            }\n        }\n\n        int ans = 0;\n        std::map<int, int> cnt;\n        for (auto x : a)\n        {\n            cnt[x]++;\n            ans = std::max(ans, cnt[x]);\n        }\n        \n        if (k == 0)\n            return ans;\n\n        for (int i = 0; i < n; i++)\n        {\n            for (int p = 0; p < k + 1; p++)\n                ans = std::max(ans, dp[i][p]);\n        }\n\n        return ans;\n    }\n};\n",
    "submit_ts": "1717861439",
    "subm_id": "1281791039"
}