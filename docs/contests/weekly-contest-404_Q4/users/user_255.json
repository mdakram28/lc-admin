{
    "username": "twitch_tv_qiqi_impact",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def diam(edges):\n            n = len(edges)+1\n            adj, visited = [[] for i in range(n + 1)], [0 for i in range(n + 1)]\n            for x, y in edges:\n                adj[x].append(y)\n                adj[y].append(x)\n            maxCount = -10**19\n            x = 0\n            \n            # Sets maxCount as maximum distance from node.\n            def dfsUtil(node, count):\n                nonlocal visited, x, maxCount, adj\n                visited[node] = 1\n                count += 1\n                for i in adj[node]:\n                    if (visited[i] == 0):\n                        if (count >= maxCount):\n                            maxCount = count\n                            x = i\n                        dfsUtil(i, count)\n\n            # The function to do DFS traversal. It uses recursive\n            # dfsUtil()\n            def dfs(node, n):\n                count = 0\n                for i in range(n + 1):\n                    visited[i] = 0\n\n                # Increment count by 1 for visited node\n                dfsUtil(node, count + 1)\n\n            # Returns diameter of binary tree represented\n            # as adjacency list.\n            def diameter(n):\n                nonlocal adj, maxCount\n\n                # DFS from a random node and then see\n                # farthest node X from it*/\n                dfs(1, n)\n\n                # DFS from X and check the farthest node\n                dfs(x, n)\n                return maxCount\n            \n            return diameter(n)-1\n        \n        \n        def prune(edges):\n            n = len(edges)+1\n            g = [set() for _ in range(n)]\n            deg = [0 for _ in range(n)]\n            q = []\n            for x, y in edges:\n                g[x].add(y)\n                g[y].add(x)\n            for i in range(n):\n                if len(g[i]) == 1:\n                    q.append(i)\n            ret = 0\n            for i in range(n):\n                nq = []\n                did = False\n                for t in q:\n                    if len(g[t]) == 1:\n                        for k in g[t]:\n                            g[k].discard(t)\n                            did = True\n                            if len(g[k]) == 1:\n                                nq.append(k)\n                if did:\n                    ret += 1\n                if not nq:\n                    return ret\n                q = nq\n            return ret\n        \n        a = prune(edges1)\n        b = prune(edges2)\n        print(a, b)\n        return max(diam(edges1), diam(edges2), a + b + 1)\n        ",
    "submit_ts": 1719717531.0
}