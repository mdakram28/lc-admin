{
    "username": "kyuukyuusha",
    "submission": "class Solution {\npublic:\n    long long maxOperations(string s) {\n        // always move the leftmost 1, it'll have the most potential for more moves later on\n        // cannot simulate because O(N^2) possible moves -- consider the alternating string\n        // the number of moves a 1 gets is the number of 1's who have a 0 to their right \"mobile 1\"s\n        // minimized by the number of 0's -- spaces to move\n        int n = s.size();\n        int n0 = 0, n1 = 0;\n        long long ans = 0;\n        int opt_max = 0;\n        for (int i = n-1; i >= 0; --i) {\n            if (s[i] == '0') ++n0;\n            else {\n                int opt = std::min(n0, n1);\n                // printf(\"%i %i %i \", n0, n1, opt);\n                if (n0) {\n                    ++n1; // mobile 1?\n                    opt = std::min(n0, n1);\n                    \n                    // ++opt;\n                    // if (s[i+1] == '0') ++opt;\n                    // opt = std::min(n0, n1 + (s[i+1] == '0' ? 1 : 0));\n                    // printf(\"* \");\n                }\n                if (opt > opt_max) {\n                    opt_max = opt = opt_max + (s[i+1] == '0');\n                }\n                ans += opt;\n                // printf(\"%c i=%i +%i\\n\", s[i], i, opt);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1721530574",
    "subm_id": "1327937578"
}