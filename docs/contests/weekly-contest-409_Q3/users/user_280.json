{
    "username": "harttle",
    "submission": "/**\n * @param {number} n\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar shortestDistanceAfterQueries = function(N, queries) {\n    const M = queries.length\n    let ans = []\n    const set = new TreeSet((l, r) => l[0] - r[0])\n    for (let i = 0; i < N - 1; i++) set.add([i, i + 1])\n    l1: for (let i = 0, dist = N - 1; i < M; i++) {\n        const [u, v] = queries[i]\n        while (true) {\n            const left = set.floor([u, Infinity])\n            if (left && left[1] >= v) {\n                ans.push(dist)\n                continue l1\n            }\n            const right = set.ceil([u, Infinity])\n            if (right && right[0] < v) {\n                dist += value(right)\n                set.delete(right)\n            } else break\n        }\n        set.add([u, v])\n        dist -= value([u, v])\n        // outs[u].push(v)\n        // outs[v].push(u)\n        ans.push(dist)\n    }\n    return ans\n    function value([x, y]) {\n        return y - x - 1\n    }\n    function getDist() {\n        const queue = new Map([[0, 0]])\n        for (const [u, d] of queue) {\n            for (const v of outs[u]) {\n                if (queue.has(v)) continue\n                if (v < u) continue\n                queue.set(v, d + 1)\n            }\n        }\n        return queue.get(N - 1)\n    }\n};\n\n/*\n * Template from contest.js\n * Github: https://github.com/harttle/contest.js\n * Website: https://harttle.land/contest.js/\n */\n// src/rbtree.ts\nvar RBTreeNode = class {\n  constructor(data) {\n    this.data = data;\n    this.left = this.right = this.parent = null;\n    this.color = 0;\n    this.count = 1;\n  }\n  sibling() {\n    if (!this.parent)\n      return null;\n    return this.isOnLeft() ? this.parent.right : this.parent.left;\n  }\n  isOnLeft() {\n    return this === this.parent.left;\n  }\n  hasRedChild() {\n    return Boolean(this.left && this.left.color === 0) || Boolean(this.right && this.right.color === 0);\n  }\n};\nvar RBTree = class {\n  constructor(compare = (l, r) => l < r ? -1 : l > r ? 1 : 0) {\n    this.root = null;\n    this.lt = (l, r) => compare(l, r) < 0;\n  }\n  rotateLeft(pt) {\n    const right = pt.right;\n    pt.right = right.left;\n    if (pt.right)\n      pt.right.parent = pt;\n    right.parent = pt.parent;\n    if (!pt.parent)\n      this.root = right;\n    else if (pt === pt.parent.left)\n      pt.parent.left = right;\n    else\n      pt.parent.right = right;\n    right.left = pt;\n    pt.parent = right;\n  }\n  rotateRight(pt) {\n    const left = pt.left;\n    pt.left = left.right;\n    if (pt.left)\n      pt.left.parent = pt;\n    left.parent = pt.parent;\n    if (!pt.parent)\n      this.root = left;\n    else if (pt === pt.parent.left)\n      pt.parent.left = left;\n    else\n      pt.parent.right = left;\n    left.right = pt;\n    pt.parent = left;\n  }\n  swapColor(p1, p2) {\n    const tmp = p1.color;\n    p1.color = p2.color;\n    p2.color = tmp;\n  }\n  swapData(p1, p2) {\n    const tmp = p1.data;\n    p1.data = p2.data;\n    p2.data = tmp;\n  }\n  fixAfterInsert(pt) {\n    var _a;\n    let parent = null;\n    let grandParent = null;\n    while (pt !== this.root && pt.color !== 1 && ((_a = pt.parent) == null ? void 0 : _a.color) === 0) {\n      parent = pt.parent;\n      grandParent = pt.parent.parent;\n      if (parent === (grandParent == null ? void 0 : grandParent.left)) {\n        const uncle = grandParent.right;\n        if (uncle && uncle.color === 0) {\n          grandParent.color = 0;\n          parent.color = 1;\n          uncle.color = 1;\n          pt = grandParent;\n        } else {\n          if (pt === parent.right) {\n            this.rotateLeft(parent);\n            pt = parent;\n            parent = pt.parent;\n          }\n          this.rotateRight(grandParent);\n          this.swapColor(parent, grandParent);\n          pt = parent;\n        }\n      } else {\n        const uncle = grandParent.left;\n        if (uncle != null && uncle.color === 0) {\n          grandParent.color = 0;\n          parent.color = 1;\n          uncle.color = 1;\n          pt = grandParent;\n        } else {\n          if (pt === parent.left) {\n            this.rotateRight(parent);\n            pt = parent;\n            parent = pt.parent;\n          }\n          this.rotateLeft(grandParent);\n          this.swapColor(parent, grandParent);\n          pt = parent;\n        }\n      }\n    }\n    this.root.color = 1;\n  }\n  delete(val) {\n    const node = this.find(val);\n    if (!node)\n      return false;\n    node.count--;\n    if (!node.count)\n      this.deleteNode(node);\n    return true;\n  }\n  deleteAll(val) {\n    const node = this.find(val);\n    if (!node)\n      return false;\n    this.deleteNode(node);\n    return true;\n  }\n  deleteNode(v) {\n    const u = BSTreplace(v);\n    const uvBlack = (u === null || u.color === 1) && v.color === 1;\n    const parent = v.parent;\n    if (!u) {\n      if (v === this.root)\n        this.root = null;\n      else {\n        if (uvBlack) {\n          this.fixDoubleBlack(v);\n        } else {\n          if (v.sibling()) {\n            v.sibling().color = 0;\n          }\n        }\n        if (v.isOnLeft())\n          parent.left = null;\n        else\n          parent.right = null;\n      }\n      return;\n    }\n    if (!v.left || !v.right) {\n      if (v === this.root) {\n        v.data = u.data;\n        v.left = v.right = null;\n      } else {\n        if (v.isOnLeft())\n          parent.left = u;\n        else\n          parent.right = u;\n        u.parent = parent;\n        if (uvBlack)\n          this.fixDoubleBlack(u);\n        else\n          u.color = 1;\n      }\n      return;\n    }\n    this.swapData(u, v);\n    this.deleteNode(u);\n    function BSTreplace(x) {\n      var _a;\n      if (x.left && x.right)\n        return successor(x.right);\n      if (!x.left && !x.right)\n        return null;\n      return (_a = x.left) != null ? _a : x.right;\n    }\n    function successor(x) {\n      let temp = x;\n      while (temp.left)\n        temp = temp.left;\n      return temp;\n    }\n  }\n  fixDoubleBlack(x) {\n    if (x === this.root)\n      return;\n    const sibling = x.sibling();\n    const parent = x.parent;\n    if (!sibling) {\n      this.fixDoubleBlack(parent);\n    } else {\n      if (sibling.color === 0) {\n        parent.color = 0;\n        sibling.color = 1;\n        if (sibling.isOnLeft())\n          this.rotateRight(parent);\n        else\n          this.rotateLeft(parent);\n        this.fixDoubleBlack(x);\n      } else {\n        if (sibling.hasRedChild()) {\n          if (sibling.left && sibling.left.color === 0) {\n            if (sibling.isOnLeft()) {\n              sibling.left.color = sibling.color;\n              sibling.color = parent.color;\n              this.rotateRight(parent);\n            } else {\n              sibling.left.color = parent.color;\n              this.rotateRight(sibling);\n              this.rotateLeft(parent);\n            }\n          } else {\n            if (sibling.isOnLeft()) {\n              sibling.right.color = parent.color;\n              this.rotateLeft(sibling);\n              this.rotateRight(parent);\n            } else {\n              sibling.right.color = sibling.color;\n              sibling.color = parent.color;\n              this.rotateLeft(parent);\n            }\n          }\n          parent.color = 1;\n        } else {\n          sibling.color = 0;\n          if (parent.color === 1)\n            this.fixDoubleBlack(parent);\n          else\n            parent.color = 1;\n        }\n      }\n    }\n  }\n  insert(data) {\n    let parent = this.root;\n    while (parent) {\n      if (this.lt(data, parent.data)) {\n        if (!parent.left)\n          break;\n        else\n          parent = parent.left;\n      } else if (this.lt(parent.data, data)) {\n        if (!parent.right)\n          break;\n        else\n          parent = parent.right;\n      } else\n        break;\n    }\n    const node = new RBTreeNode(data);\n    if (!parent)\n      this.root = node;\n    else if (this.lt(node.data, parent.data))\n      parent.left = node;\n    else if (this.lt(parent.data, node.data))\n      parent.right = node;\n    else {\n      parent.count++;\n      return false;\n    }\n    node.parent = parent;\n    this.fixAfterInsert(node);\n    return true;\n  }\n  search(predicate, direction) {\n    let p = this.root;\n    let result = null;\n    while (p) {\n      if (predicate(p.data)) {\n        result = p;\n        p = p[direction];\n      } else {\n        p = p[direction === \"left\" ? \"right\" : \"left\"];\n      }\n    }\n    return result == null ? void 0 : result.data;\n  }\n  find(data) {\n    let p = this.root;\n    while (p) {\n      if (this.lt(data, p.data)) {\n        p = p.left;\n      } else if (this.lt(p.data, data)) {\n        p = p.right;\n      } else\n        break;\n    }\n    return p != null ? p : null;\n  }\n  count(data) {\n    const node = this.find(data);\n    return node ? node.count : 0;\n  }\n  *inOrder(root = this.root) {\n    if (!root)\n      return;\n    for (const v of this.inOrder(root.left))\n      yield v;\n    yield root.data;\n    for (const v of this.inOrder(root.right))\n      yield v;\n  }\n  *reverseInOrder(root = this.root) {\n    if (!root)\n      return;\n    for (const v of this.reverseInOrder(root.right))\n      yield v;\n    yield root.data;\n    for (const v of this.reverseInOrder(root.left))\n      yield v;\n  }\n};\n\n// src/treeset.ts\nvar TreeSet = class {\n  constructor(collection = [], compare = (l, r) => l < r ? -1 : l > r ? 1 : 0) {\n    if (typeof collection === \"function\") {\n      compare = collection;\n      collection = [];\n    }\n    this._size = 0;\n    this.compare = compare;\n    this.tree = new RBTree(compare);\n    for (const val of collection)\n      this.add(val);\n  }\n  size() {\n    return this._size;\n  }\n  has(val) {\n    return !!this.tree.find(val);\n  }\n  add(val) {\n    const successful = this.tree.insert(val);\n    this._size += successful ? 1 : 0;\n    return successful;\n  }\n  delete(val) {\n    const deleted = this.tree.deleteAll(val);\n    this._size -= deleted ? 1 : 0;\n    return deleted;\n  }\n  ceil(target) {\n    return this.tree.search((val) => this.compare(val, target) >= 0, \"left\");\n  }\n  floor(target) {\n    return this.tree.search((val) => this.compare(val, target) <= 0, \"right\");\n  }\n  higher(target) {\n    return this.tree.search((val) => this.compare(val, target) > 0, \"left\");\n  }\n  lower(target) {\n    return this.tree.search((val) => this.compare(val, target) < 0, \"right\");\n  }\n  first() {\n    return this.tree.inOrder().next().value;\n  }\n  last() {\n    return this.tree.reverseInOrder().next().value;\n  }\n  shift() {\n    const first = this.first();\n    if (first === void 0)\n      return void 0;\n    this.delete(first);\n    return first;\n  }\n  pop() {\n    const last = this.last();\n    if (last === void 0)\n      return void 0;\n    this.delete(last);\n    return last;\n  }\n  *[Symbol.iterator]() {\n    for (const val of this.values())\n      yield val;\n  }\n  *keys() {\n    for (const val of this.values())\n      yield val;\n  }\n  *values() {\n    for (const val of this.tree.inOrder())\n      yield val;\n    return void 0;\n  }\n  *rvalues() {\n    for (const val of this.tree.reverseInOrder())\n      yield val;\n    return void 0;\n  }\n};\nvar TreeMultiSet = class {\n  constructor(collection = [], compare = (l, r) => l < r ? -1 : l > r ? 1 : 0) {\n    if (typeof collection === \"function\") {\n      compare = collection;\n      collection = [];\n    }\n    this._size = 0;\n    this.compare = compare;\n    this.tree = new RBTree(compare);\n    for (const val of collection)\n      this.add(val);\n  }\n  size() {\n    return this._size;\n  }\n  has(val) {\n    return !!this.tree.find(val);\n  }\n  add(val) {\n    const successful = this.tree.insert(val);\n    this._size++;\n    return successful;\n  }\n  delete(val) {\n    const successful = this.tree.delete(val);\n    if (!successful)\n      return false;\n    this._size--;\n    return true;\n  }\n  deleteAll(val) {\n    let successful = false;\n    while (this.tree.delete(val)) {\n      this._size--;\n      successful = true;\n    }\n    return successful;\n  }\n  count(val) {\n    const node = this.tree.find(val);\n    return node ? node.count : 0;\n  }\n  ceil(target) {\n    return this.tree.search((val) => this.compare(val, target) >= 0, \"left\");\n  }\n  floor(target) {\n    return this.tree.search((val) => this.compare(val, target) <= 0, \"right\");\n  }\n  higher(target) {\n    return this.tree.search((val) => this.compare(val, target) > 0, \"left\");\n  }\n  lower(target) {\n    return this.tree.search((val) => this.compare(val, target) < 0, \"right\");\n  }\n  first() {\n    return this.tree.inOrder().next().value;\n  }\n  last() {\n    return this.tree.reverseInOrder().next().value;\n  }\n  shift() {\n    const first = this.first();\n    if (first === void 0)\n      return void 0;\n    this.delete(first);\n    return first;\n  }\n  pop() {\n    const last = this.last();\n    if (last === void 0)\n      return void 0;\n    this.delete(last);\n    return last;\n  }\n  *[Symbol.iterator]() {\n    yield* this.values();\n  }\n  *keys() {\n    for (const val of this.values())\n      yield val;\n  }\n  *values() {\n    for (const val of this.tree.inOrder()) {\n      let count = this.count(val);\n      while (count--)\n        yield val;\n    }\n    return void 0;\n  }\n  *rvalues() {\n    for (const val of this.tree.reverseInOrder()) {\n      let count = this.count(val);\n      while (count--)\n        yield val;\n    }\n    return void 0;\n  }\n};",
    "submit_ts": "1722740764",
    "subm_id": "1343728177"
}