{
    "username": "abhinash_giri",
    "submission": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; }; sim > rge<c> range(c i, c j) { return rge<c> {i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0); sim > char dud(...);\nstruct debug {\n#ifdef ABHI\n    eni( != ) cerr << boolalpha << i; ris;\n    }\n    eni( == ) ris << range(begin(i), end(i));\n    }\n    sim, class b dor(pair < b, c > d) {ris << \"(\" << d.first << \", \" << d.second << \")\";}\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wstring-plus-int\"\n    sim dor(rge<c> d) {*this << \"[\"; for (auto it = d.b; it != d.e; ++it) *this << \", \" + 2 * (it == d.b) << *it; ris << \"]\";}\n#pragma clang diagnostic pop\n#else\n    sim dor(const c&) { ris; }\n#endif\n};\nvector<char*> tokenizer(const char* args) {\n    char *token = new char[111]; strcpy(token, args); token = strtok(token, \", \");\n    vector<char*> v({token});\n    while ((token = strtok(NULL, \", \"))) v.push_back(token);\n    return reverse(v.begin(), v.end()), v;\n}\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-parameter\"\nvoid debugg(vector<char*> args) { cerr << \"\\b\\b \"; }\n#pragma clang diagnostic pop\ntemplate <typename Head, typename... Tail>\nvoid debugg(vector<char*> args, Head H, Tail... T) {\n    debug() << \" [\" << args.back() << \": \" << H << \"] \";\n    args.pop_back(); debugg(args, T...);\n}\n#define harg(...) #__VA_ARGS__\n#ifdef ABHI\n#define deb(...) { debugg(tokenizer(harg(__VA_ARGS__, \\b\\t-->Line)), __VA_ARGS__, __LINE__); cerr << endl;}\n#else\n#define deb(...) { }\n#endif\n/// --------------------------------------------------------------------------------------------------------------------\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define PI (2*acos(0.0))\n#define sz(x)           ( (ll) (x).size())\n#define setbits(x)      __builtin_popcountll(x)\n#define zrobits(x)      __builtin_ctzll(x)\n#define pos_rt_stbt(x)   (__builtin_ffsll(x))   // return position of rightmost set bit ( 1 indexing ) pos_rt_stbt(10) = 2 ( 1010 )\n#define ps(x,y)         fixed<<setprecision(y)<<x\n#define w(test)            int test; cin>>test; while(test--)\n#define nl \"\\n\"\n#define yes cout<<\"YES\\n\"\n#define no cout<<\"NO\\n\"\n#define all(v) (v).begin(),(v).end()\n#define clr(v) memset(v,0,sizeof(v));\n#define sqr(x) ((x) * (x))\ntypedef long long int  ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<string> vs;\ntypedef pair<ll, ll> pll;\ntypedef vector<pair<ll, ll>> vpll;\ntypedef vector<vpll>vvpll;\nconst long long int inf = 1e17;\nconst long long int mod = 1e9 + 7;\nconst long long int MOD =  998244353;\ntypedef long long int  ll;\n\n\ntemplate <class T> struct SegTree{\n    const T ID = 0;\n    int n; vector <T> seg;\n    T comb(T a, T b){\n        return a + b;\n    }\n    SegTree(int _n) { n = _n; seg.assign(2 * n, ID); }\n    void pull(int p) { seg[p] = comb(seg[2 * p], seg[2 * p + 1]); }\n    void update(int idx, T val) {\n        seg[idx += n] = val;\n        for(idx /= 2; idx; idx /= 2) pull(idx);\n    }\n    T query(int l, int r) {\n        T lnode = ID, rnode = ID;\n        for(l += n, r += n + 1; l < r; l /= 2, r /= 2) {\n            if(l & 1) lnode = comb(lnode, seg[l ++]);\n            if(r & 1) rnode = comb(seg[-- r], rnode);\n        }\n        return comb(lnode, rnode);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& queries) {\n        int n = a.size();\n        SegTree<int>seg(n+1);\n        for (int i = 1; i+1 <n ; ++i){\n            if(a[i-1] < a[i] && a[i]>a[i+1]){\n                seg.update(i,1);\n                deb(i,1);\n            }\n        }\n        vector<int>ans;\n        for(auto &i:queries){\n            int typ = i[0];\n            int l = i[1];\n            int r = i[2];\n            if(typ==1){\n\n                int x = 0;\n                if(l+1<=r-1)x = seg.query(l+1,r-1);\n                deb(a,x,l,r);\n                ans.push_back(x);\n            }\n            else{\n                unordered_map<int,int>isOne;\n                unordered_map<int,int>nowOne;\n                for (int j = l-1; j <=l+1 && j<n ; ++j){\n                    if(j<0)continue;\n                    if(j-1>=0 && j+1<n && (a[j-1]<a[j]) && (a[j]>a[j+1])){\n                        isOne[j] = 1;\n                    }\n                    else isOne[j] = 0;\n                }\n                a[l]=r;\n                for (int j = l-1; j <=l+1 && j<n ; ++j){\n                    if(j<0)continue;\n                    if(j-1>=0 && j+1<n && (a[j-1]<a[j]) && (a[j]>a[j+1])){\n                        nowOne[j] = 1;\n                    }\n                    else nowOne[j]=0;\n                }\n                for (int j = l-1; j <=l+1 && j<n ; ++j){\n                    if(j<0)continue;\n                    if(!isOne[j] && nowOne[j]){\n                        seg.update(j,1);\n                    }\n                    else if(isOne[j] && !nowOne[j]){\n                        seg.update(j,0);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n\nstatic const auto speedup = []() {\n    std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return 0;\n}();\n\n\nvoid solve(){\n    vector<int>a={\n            1,5,1,1,1,1\n    };\n    vector<vector<int>>g={\n            {2,2,4},\n            {1,0,2},\n            {1,0,4}\n    };\n\n    Solution x;\n    auto d = x.countOfPeaks(a,g);\n    deb(d);\n}\n\n// int main(){  solve();  }",
    "submit_ts": 1718507714.0
}