{
    "username": "alan8585",
    "submission": "class Solution {\n    \n    int tree[1000000];\n    \n    \n    void fix(int l, int r, int c, int x, int k) {\n        if (l == r) {\n            tree[c] = k;\n            return;\n        }\n        int m = (l + r) >> 1;\n        if (x <= m) fix(l, m, c << 1, x, k);\n        else fix(m + 1, r, c << 1 | 1, x, k);\n        tree[c] = max(tree[c << 1], tree[c << 1 | 1]);\n    }\n    \n    int search(int l, int r, int tl, int tr, int c) {\n        if (l <= tl && tr <= r) return tree[c];\n        \n        int tm = (tl + tr) >> 1;\n        if (l <= tm && tm + 1 <= r) return max(search(l, r, tl, tm, c << 1), search(l, r, tm + 1, tr, c << 1 | 1)); \n        else if (l <= tm) return search(l, r, tl, tm, c << 1);\n        return search(l, r, tm + 1, tr, c << 1 | 1);\n    }\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        set<int> s;\n        vector<bool> ans;\n        \n        int MX = min(50000, 3 * (int)queries.size()) + 10;\n        s.insert(0);\n        s.insert(MX);\n        for (int i = 1; i <= MX; i++) {\n            fix(0, MX, 1, i, 0);\n        }\n        fix(0, MX, 1, 0, 0);\n        for (auto &q : queries) {\n            if (q[0] == 1) {\n                s.insert(q[1]);\n                \n                auto now = s.find(q[1]);\n                int pr = *prev(now);\n                int ne = *next(now);\n                \n                \n                fix(0, MX, 1, q[1], q[1] - pr);\n                fix(0, MX, 1, ne, ne - q[1]);\n            } else {\n                auto p = s.upper_bound(q[1]);\n                p--;\n                if (max(search(0, *p, 0, MX, 1), q[1] - (*p)) >= q[2]) {\n                    ans.push_back(true);\n                } else {\n                    ans.push_back(false);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716649656.0
}