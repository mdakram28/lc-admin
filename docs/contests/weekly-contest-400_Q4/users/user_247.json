{
    "username": "TheZwischenzug",
    "submission": "class SubArrayIdempotentMonoidPrimitiveArrays {\n    int[][] subArrayValsForTwoPowerArrays;\n    IntBinaryOperator idempotentSemiGroup;\n    byte[] highestTwoPowExponent;\n    public SubArrayIdempotentMonoidPrimitiveArrays(int[] arr, IntBinaryOperator idempotentSemiGroup){\n        this.idempotentSemiGroup = idempotentSemiGroup;\n        computeHighestTwoPowerExponent(arr);\n        computeSubArrayValsForTwoPowerArrays(arr);\n    }\n\n    private void computeHighestTwoPowerExponent(int[] arr) {\n        highestTwoPowExponent = new byte[arr.length+1];\n        byte exp = -1;\n        for (int subArrayLen = 1; subArrayLen <= arr.length; subArrayLen++){\n            if ( (subArrayLen&(subArrayLen-1)) == 0){\n                exp++;\n            }\n            highestTwoPowExponent[subArrayLen] = exp;\n        }\n    }\n\n    private void computeSubArrayValsForTwoPowerArrays(int[] arr){\n        int n = arr.length;\n        int log = (int)(Math.log(n)/Math.log(2));\n        subArrayValsForTwoPowerArrays = new int[n][log+1];\n        for (int i = 0; i < n; i++) {\n            // max length of subarray starting at i = n-i.\n            int numOfTwoPowSubArrays = highestTwoPowExponent[n-i] + 1;\n            subArrayValsForTwoPowerArrays[i] = new int[numOfTwoPowSubArrays];\n            subArrayValsForTwoPowerArrays[i][0] = arr[i];\n        }\n\n        for (int len = 2, exponent = 1; len <= n; len *= 2, exponent++){\n            for (int i = 0; i + len-1 < n; i++) {\n                int halfLen = len/2;\n                int leftVal = subArrayValsForTwoPowerArrays[i][exponent-1];\n                int rightVal = subArrayValsForTwoPowerArrays[i+halfLen][exponent-1];\n                subArrayValsForTwoPowerArrays[i][exponent] = idempotentSemiGroup.applyAsInt(leftVal, rightVal);\n            }\n        }\n\n    }\n    public int getSubArrayVal(int left, int right) {\n        int len = right-left+1;\n        int largestTwoPowerExponent = highestTwoPowExponent[len];\n        int largestTwoPower = 1 << largestTwoPowerExponent;\n        int leftVal = subArrayValsForTwoPowerArrays[left][largestTwoPowerExponent];\n        int rightVal = subArrayValsForTwoPowerArrays[right-largestTwoPower+1][largestTwoPowerExponent];\n        return idempotentSemiGroup.applyAsInt(leftVal, rightVal);\n\n    }\n}\nclass Solution {\n    SubArrayIdempotentMonoidPrimitiveArrays ds;\n    int[] nums;\n    private int floorAnd(int start, int k){\n        int left = start;\n        int right = nums.length-1;\n        int floor = -1;\n        while (left <= right){\n            int mid = (left+right)/2;\n            int val = ds.getSubArrayVal(start, mid);\n            if (val > k) left = mid+1;\n            else{\n                floor = val;\n                right = mid-1;\n            }\n        }\n        return floor;\n    }\n    private int ceilAnd(int start, int k){\n        int left = start;\n        int right = nums.length-1;\n        int ceil = -1;\n        while (left <= right){\n            int mid = (left+right)/2;\n            int val = ds.getSubArrayVal(start, mid);\n            if (val < k) right = mid-1;\n            else{\n                ceil = val;\n                left = mid+1;\n            }\n        }\n        return ceil;\n    }\n    public int minimumDifference(int[] nums, int k) {\n        ds = new SubArrayIdempotentMonoidPrimitiveArrays(nums, (a,b)-> a&b);\n        this.nums = nums;\n        int minDiff = Integer.MAX_VALUE;\n        for (int i = 0; i < nums.length; i++){\n            int f = floorAnd(i, k);\n            if (f != -1) minDiff = Math.min(minDiff, k-f);\n            int c = ceilAnd(i, k);\n            if (c != -1) minDiff = Math.min(minDiff, c-k);\n        }\n        return minDiff;\n    }\n}",
    "submit_ts": 1717297442.0
}