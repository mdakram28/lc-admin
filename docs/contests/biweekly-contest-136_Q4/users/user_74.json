{
    "username": "Toptodown_Dp",
    "submission": "#ifndef LOCAL\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\n\nnamespace mitsuha{\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &A) {\n    os << A.first << \" \" << A.second;\n    return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &A) {\n    for (size_t i = 0; i < A.size(); i++) {\n        if (i) os << \" \";\n        os << A[i];\n    }\n    return os;\n}\n\nvoid print() {\n    std::cout << \"\\n\";\n    std::cout.flush();\n}\n\ntemplate <class Head, class... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n    std::cout << head;\n    if (sizeof...(Tail)) std::cout << \" \";\n    print(std::forward<Tail>(tail)...);\n}\n}\n\nnamespace mitsuha {\ntemplate <class T> bool chmin(T& x, const T& y) { \n    return y >= x ? false : (x = y, true); \n}\ntemplate <class T> bool chmax(T& x, const T& y) { \n    return y <= x ? false : (x = y, true); \n}\ntemplate <class T> constexpr T fld(const T x, const T y) { \n    T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); \n}\ntemplate <class T> constexpr T cld(const T x, const T y) { \n    T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); \n}\ntemplate <class T> constexpr T rem(const T x, const T y) { \n    return x - y * fld(x, y); \n}\ntemplate <class Iterable> void settify(Iterable& a) { \n    std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); \n}\ntemplate <size_t D> struct Dim : std::array<int, D> {\n    template <typename ...Ints> Dim(const Ints& ...ns) : \n        std::array<int, D>::array{ static_cast<int>(ns)... } {}\n};\ntemplate <typename ...Ints> Dim(const Ints& ...) -> Dim<sizeof...(Ints)>;\ntemplate <class T, size_t D, size_t I = 0>\nauto ndvec(const Dim<D> &ns, const T& value = {}) {\n    if constexpr (I + 1 < D) {\n        return std::vector(ns[I], ndvec<T, D, I + 1>(ns, value));\n    } else {\n        return std::vector<T>(ns[I], value);\n    }\n}\n}\n\nnamespace mitsuha {\nusing str = std::string;\nusing int128 = __int128;\nusing uint128 = unsigned __int128;\ntemplate <class T> using min_priority_queue \n                            = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T> using max_priority_queue \n                            = std::priority_queue<T, std::vector<T>, std::less<T>>;\n}\nnamespace mitsuha { \n    const std::vector<std::string> Yes = {\"No\", \"Yes\"};\n    const std::vector<std::string> YES = {\"NO\", \"YES\"};\n}\n \n#ifndef __COUNTER__\n#define __COUNTER__ __LINE__\n#endif\n\n#define TL (long long)\n \n#define OVERLOAD5(a, b, c, d, e, ...) e\n#define REP1_0(b, c) REP1_1(b, c)\n#define REP1_1(b, c) for (long long REP_COUNTER_##c = 0; REP_COUNTER_##c < TL(b); ++REP_COUNTER_##c)\n#define REP1(b) REP1_0(b, __COUNTER__)\n#define REP2(i, b) for (long long i = 0; i < TL(b); ++i)\n#define REP3(i, a, b) for (long long i = TL(a); i < TL(b); ++i)\n#define REP4(i, a, b, c) for (long long i = TL(a); i < TL(b); i += TL(c))\n#define For(...) OVERLOAD5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)\n#define RREP2(i, a) for (long long i = TL(a)-1; i >= 0; --i)\n#define RREP3(i, a, b) for (long long i = TL(b)-1; i >= TL(a); --i)\n#define RREP4(i, a, b, c) for (long long i = TL(b)-1; i >= TL(a); i -= TL(c))\n#define Frr(...) OVERLOAD5(__VA_ARGS__, RREP4, RREP3, RREP2)(__VA_ARGS__)\n\n#define All(iterable) std::begin(iterable), std::end(iterable)\n#define len(iterable) TL iterable.size()\n#define elif else if\n\n#define KBIT(a, k) (a & (1ULL << k))\n\n#define Assert(x) void(0);\n\nusing namespace mitsuha;\nusing namespace std;\n \nconstexpr int iinf = std::numeric_limits<int>::max() / 2;\nconstexpr long long linf = std::numeric_limits<long long>::max() / 2;\n\nnamespace mitsuha{\ntemplate <typename T>\nstruct Edge {\n    int frm, to;\n    T cost;\n    int id;\n};\n\ntemplate <typename T = int, bool directed = false>\nstruct Graph {\n    static constexpr bool is_directed = directed;\n    int N, M;\n    using cost_type = T;\n    using edge_type = Edge<T>;\n    vector<edge_type> edges;\n    vector<int> indptr;\n    vector<edge_type> csr_edges;\n    vector<int> vc_deg, vc_indeg, vc_outdeg;\n    bool prepared;\n\n    class OutgoingEdges {\n    public:\n        OutgoingEdges(const Graph* G, int l, int r) : G(G), l(l), r(r) {}\n\n        const edge_type* begin() const {\n            if (l == r) { return 0; }\n            return &G->csr_edges[l];\n        }\n\n        const edge_type* end() const {\n            if (l == r) { return 0; }\n            return &G->csr_edges[r];\n        }\n\n    private:\n        const Graph* G;\n        int l, r;\n    };\n\n    bool is_prepared() { return prepared; }\n\n    Graph() : N(0), M(0), prepared(0) {}\n    Graph(int N) : N(N), M(0), prepared(0) {}\n\n    void build(int n) {\n        N = n, M = 0;\n        prepared = 0;\n        edges.clear();\n        indptr.clear();\n        csr_edges.clear();\n        vc_deg.clear();\n        vc_indeg.clear();\n        vc_outdeg.clear();\n    }\n\n    void add(int frm, int to, T cost = 1, int i = -1) {\n        assert(!prepared);\n        assert(0 <= frm && 0 <= to && to < N);\n        if (i == -1) i = M;\n        auto e = edge_type({frm, to, cost, i});\n        edges.emplace_back(e);\n        ++M;\n    }\n\n#ifdef FASTIO\n    // wt, off\n    void read_tree(bool wt = false, int off = 1) { read_graph(N - 1, wt, off); }\n\n    void read_graph(int M, bool wt = false, int off = 1) {\n        for (int m = 0; m < M; ++m) {\n            int a, b;\n            read(a, b);\n            a -= off, b -= off;\n            if (!wt) {\n                add(a, b);\n            } else {\n                T c;\n                read(c);\n                add(a, b, c);\n            }\n        }\n        build();\n    }\n#endif\n\n    void build() {\n        assert(!prepared);\n        prepared = true;\n        indptr.assign(N + 1, 0);\n        for (auto&& e: edges) {\n            indptr[e.frm + 1]++;\n            if (!directed) indptr[e.to + 1]++;\n        }\n        for (int v = 0; v < N; ++v) { indptr[v + 1] += indptr[v]; }\n        auto counter = indptr;\n        csr_edges.resize(indptr.back() + 1);\n        for (auto&& e: edges) {\n            csr_edges[counter[e.frm]++] = e;\n            if (!directed)\n                csr_edges[counter[e.to]++] = edge_type({e.to, e.frm, e.cost, e.id});\n        }\n    }\n\n    OutgoingEdges operator[](int v) const {\n        assert(prepared);\n        return {this, indptr[v], indptr[v + 1]};\n    }\n\n    vector<int> deg_array() {\n        if (vc_deg.empty()) calc_deg();\n        return vc_deg;\n    }\n\n    pair<vector<int>, vector<int>> deg_array_inout() {\n        if (vc_indeg.empty()) calc_deg_inout();\n        return {vc_indeg, vc_outdeg};\n    }\n\n    int deg(int v) {\n        if (vc_deg.empty()) calc_deg();\n        return vc_deg[v];\n    }\n\n    int in_deg(int v) {\n        if (vc_indeg.empty()) calc_deg_inout();\n        return vc_indeg[v];\n    }\n\n    int out_deg(int v) {\n        if (vc_outdeg.empty()) calc_deg_inout();\n        return vc_outdeg[v];\n    }\n\n    vector<int> new_idx;\n    vector<bool> used_e;\n\n    // vertex V[i] in G become i in the new graph\n    // {G, es}\n    // The amount of calculation is sum(deg(v)),\n    // Be careful as it may be larger than n+m in the new graph\n    Graph<T, directed> rearrange(vector<int> V, bool keep_eid = 0) {\n        if (len(new_idx) != N) new_idx.assign(N, -1);\n        int n = len(V);\n        For(i, n) new_idx[V[i]] = i;\n        Graph<T, directed> G(n);\n        vector<int> history;\n        For(i, n) {\n            for (auto&& e: (*this)[V[i]]) {\n                if (len(used_e) <= e.id) used_e.resize(e.id + 1);\n                if (used_e[e.id]) continue;\n                int a = e.frm, b = e.to;\n                if (new_idx[a] != -1 && new_idx[b] != -1) {\n                    history.emplace_back(e.id);\n                    used_e[e.id] = 1;\n                    int eid = (keep_eid ? e.id : -1);\n                    G.add(new_idx[a], new_idx[b], e.cost, eid);\n                }\n            }\n        }\n        For(i, n) new_idx[V[i]] = -1;\n        for (auto&& eid: history) used_e[eid] = 0;\n        G.build();\n        return G;\n    }\n\n    Graph<T, true> to_directed_tree(int root = -1, bool directed_away_from_root = true) {\n        if (root == -1) root = 0;\n        assert(!is_directed && prepared && M == N - 1);\n        Graph<T, true> G1(N);\n        vector<int> par(N, -1);\n        auto dfs = [&](auto& dfs, int v) -> void {\n            for (auto& e: (*this)[v]) {\n                if (e.to == par[v]) continue;\n                par[e.to] = v, dfs(dfs, e.to);\n            }\n        };\n        dfs(dfs, root);\n        for (auto& e: edges) {\n            int a = e.frm, b = e.to;\n            if (par[a] == b) swap(a, b);\n            assert(par[b] == a);\n            if (directed_away_from_root)\n                G1.add(a, b, e.cost);\n            else\n                G1.add(b, a, e.cost);\n        }\n        G1.build();\n        return G1;\n    }\n\nprivate:\n    void calc_deg() {\n        assert(vc_deg.empty());\n        vc_deg.resize(N);\n        for (auto&& e: edges) vc_deg[e.frm]++, vc_deg[e.to]++;\n    }\n\n    void calc_deg_inout() {\n        assert(vc_indeg.empty());\n        vc_indeg.resize(N);\n        vc_outdeg.resize(N);\n        for (auto&& e: edges) { vc_indeg[e.to]++, vc_outdeg[e.frm]++; }\n    }\n};\n\ntemplate<typename T, bool directed = false>\nstd::ostream &operator<<(std::ostream &out, const Graph<T, directed> &_G){\n    auto G = _G;\n    if (not G.prepared) {\n        out << \"frm to cost id\";\n        for (auto &&e: G.edges) \n            out << \"\\n\" << e.frm << \" \" << e.to << \" \" << e.cost << \" \" << e.id;\n    } else {\n        out << \"indptr \";\n        for(const auto &value : G.indptr) {\n            out << value << \" \";\n        }\n        out << \"\\n\";\n        out << \"frm to cost id\";\n        for(int v = 0; v < G.N; ++v) \n            for (auto &&e: G[v]) \n            out << \"\\n\" << e.frm << \" \" << e.to << \" \" << e.cost << \" \" << e.id;\n    }\n    return out;\n}\n} // namespace mitsuha\n\nnamespace mitsuha{\ntemplate<typename GT>\nstruct Tree {\n    using Graph_type = GT;\n    GT &G;\n    using WT = typename GT::cost_type;\n    int N;\n    vector<int> LID, RID, head, V, parent, VtoE;\n    vector<int> depth;\n    vector<WT> depth_weighted;\n\n    Tree(GT &G, int r = 0, bool hld = 1) : G(G) { build(r, hld); }\n\n    void build(int r = 0, bool hld = 1) {\n        if (r == -1) return;\n        N = G.N;\n        LID.assign(N, -1), RID.assign(N, -1), head.assign(N, r);\n        V.assign(N, -1), parent.assign(N, -1), VtoE.assign(N, -1);\n        depth.assign(N, -1), depth_weighted.assign(N, 0);\n        assert(G.is_prepared());\n        int t1 = 0;\n        dfs_sz(r, -1, hld);\n        dfs_hld(r, t1);\n    }\n\n    void dfs_sz(int v, int p, bool hld) {\n        auto &sz = RID;\n        parent[v] = p;\n        depth[v] = (p == -1 ? 0 : depth[p] + 1);\n        sz[v] = 1;\n        int l = G.indptr[v], r = G.indptr[v + 1];\n        auto &csr = G.csr_edges;\n        for (int i = r - 2; i >= l; --i) {\n            if (hld && depth[csr[i + 1].to] == -1) swap(csr[i], csr[i + 1]);\n        }\n        int hld_sz = 0;\n        for (int i = l; i < r; ++i) {\n            auto e = csr[i];\n            if (depth[e.to] != -1) continue;\n            depth_weighted[e.to] = depth_weighted[v] + e.cost;\n            VtoE[e.to] = e.id;\n            dfs_sz(e.to, v, hld);\n            sz[v] += sz[e.to];\n            if (hld && chmax(hld_sz, sz[e.to]) && l < i) { swap(csr[l], csr[i]); }\n        }\n    }\n\n    void dfs_hld(int v, int &times) {\n        LID[v] = times++;\n        RID[v] += LID[v];\n        V[LID[v]] = v;\n        bool heavy = true;\n        for (auto &&e: G[v]) {\n            if (depth[e.to] <= depth[v]) continue;\n            head[e.to] = (heavy ? head[v] : e.to);\n            heavy = false;\n            dfs_hld(e.to, times);\n        }\n    }\n\n    vector<int> heavy_path_at(int v) {\n        vector<int> P = {v};\n        while (1) {\n            int a = P.back();\n            for (auto &&e: G[a]) {\n                if (e.to != parent[a] && head[e.to] == v) {\n                    P.emplace_back(e.to);\n                    break;\n                }\n            }\n            if (P.back() == a) break;\n        }\n        return P;\n    }\n\n    int heavy_child(int v) {\n        int k = LID[v] + 1;\n        if (k == N) return -1;\n        int w = V[k];\n        return (parent[w] == v ? w : -1);\n    }\n\n    int e_to_v(int eid) {\n        auto e = G.edges[eid];\n        return (parent[e.frm] == e.to ? e.frm : e.to);\n    }\n\n    int v_to_e(int v) { return VtoE[v]; }\n    int get_eid(int u, int v) {\n        if (parent[u] != v) swap(u, v);\n        assert(parent[u] == v);\n        return VtoE[u];\n    }\n    int ELID(int v) { return 2 * LID[v] - depth[v]; }\n    int ERID(int v) { return 2 * RID[v] - depth[v] - 1; }\n\n    /* k: 0-indexed */\n    int la(int v, int k) {\n        assert(k <= depth[v]);\n        while (1) {\n            int u = head[v];\n            if (LID[v] - k >= LID[u]) return V[LID[v] - k];\n            k -= LID[v] - LID[u] + 1;\n            v = parent[u];\n        }\n    }\n\n    int lca(int u, int v) {\n        for (;; v = parent[head[v]]) {\n            if (LID[u] > LID[v]) swap(u, v);\n            if (head[u] == head[v]) return u;\n        }\n    }\n\n    int meet(int a, int b, int c) { return lca(a, b) ^ lca(a, c) ^ lca(b, c); }\n\n    int lca_root(int u, int v, int root) {\n        return lca(u, v) ^ lca(u, root) ^ lca(v, root);\n    }\n\n    int subtree_size(int v, int root = -1) {\n        if (root == -1) return RID[v] - LID[v];\n        if (v == root) return N;\n        int x = jump(v, root, 1);\n        if (in_subtree(v, x)) return RID[v] - LID[v];\n        return N - RID[x] + LID[x];\n    }\n\n    int dist(int a, int b) {\n        int c = lca(a, b);\n        return depth[a] + depth[b] - 2 * depth[c];\n    }\n\n    WT dist_weighted(int a, int b) {\n        int c = lca(a, b);\n        return depth_weighted[a] + depth_weighted[b] - WT(2) * depth_weighted[c];\n    }\n\n    // a is in b\n    bool in_subtree(int a, int b) { return LID[b] <= LID[a] && LID[a] < RID[b]; }\n\n    int jump(int a, int b, long long k) {\n        if (k == 1) {\n            if (a == b) return -1;\n            return (in_subtree(b, a) ? la(b, depth[b] - depth[a] - 1) : parent[a]);\n        }\n        int c = lca(a, b);\n        int d_ac = depth[a] - depth[c];\n        int d_bc = depth[b] - depth[c];\n        if (k > d_ac + d_bc) return -1;\n        if (k <= d_ac) return la(a, k);\n        return la(b, d_ac + d_bc - k);\n    }\n\n    vector<int> collect_child(int v) {\n        vector<int> res;\n        for (auto &&e: G[v]) if (e.to != parent[v]) res.emplace_back(e.to);\n        return res;\n    }\n\n    vector<int> collect_light(int v) {\n        vector<int> res;\n        bool skip = true;\n        for (auto &&e: G[v])\n            if (e.to != parent[v]) {\n                if (!skip) res.emplace_back(e.to);\n                skip = false;\n            }\n        return res;\n    }\n\n    vector<pair<int, int>> get_path_decomposition(int u, int v, bool edge) {\n        vector<pair<int, int>> up, down;\n        while (1) {\n            if (head[u] == head[v]) break;\n            if (LID[u] < LID[v]) {\n                down.emplace_back(LID[head[v]], LID[v]);\n                v = parent[head[v]];\n            } else {\n                up.emplace_back(LID[u], LID[head[u]]);\n                u = parent[head[u]];\n            }\n        }\n        if (LID[u] < LID[v]) down.emplace_back(LID[u] + edge, LID[v]);\n        else if (LID[v] + edge <= LID[u]) up.emplace_back(LID[u], LID[v] + edge);\n        reverse(down.begin(), down.end());\n        up.insert(up.end(), down.begin(), down.end());\n        return up;\n    }\n\n    vector<int> restore_path(int u, int v) {\n        vector<int> P;\n        for (auto &&[a, b]: get_path_decomposition(u, v, 0)) {\n            if (a <= b) for (int i = a; i <= b; i++) P.emplace_back(V[i]);\n            else for (int i = a; i >= b; i--) P.emplace_back(V[i]);\n        }\n        return P;\n    }\n\n    // path intersection of [a, b] x [c, d]\n    // {-1, -1} if there wasn't any intersection\n    // https://codeforces.com/problemset/problem/500/G\n    pair<int, int> path_intersection(int a, int b, int c, int d) {\n        int ab = lca(a, b), ac = lca(a, c), ad = lca(a, d);\n        int bc = lca(b, c), bd = lca(b, d), cd = lca(c, d);\n        int x = ab ^ ac ^ bc, y = ab ^ ad ^ bd; // meet(a,b,c), meet(a,b,d)\n        if (x != y) return {x, y};\n        int z = ac ^ ad ^ cd;\n        if (x != z) x = -1;\n        return {x, x};\n    }\n};\n} // namespace mitsuha\n\nnamespace mitsuha{\ntemplate <typename TREE, typename Data>\nstruct Rerooting_dp {\n    static_assert(!TREE::Graph_type::is_directed);\n    TREE& tree;\n    vector<Data> dp_1; // For edge pv, subtree v\n    vector<Data> dp_2; // For edge pv, subtree p\n    vector<Data> dp;   // full tree\n\n    template <typename RAKE, typename APPLY_VERTEX, \n                                typename APPLY_EDGE>\n    Rerooting_dp(TREE& tree, RAKE rake, APPLY_VERTEX apply_vertex, \n                            APPLY_EDGE apply_edge, const Data unit)\n            : tree(tree) {\n        build(rake, apply_vertex, apply_edge, unit);\n    }\n    \n    Data operator[](int v) { return dp[v]; }\n\n    // Subtree v when root is the root\n    Data get(int v, int root) {\n        if (root == v) return dp[v];\n        if (!tree.in_subtree(root, v)) { return dp_1[v]; }\n        int w = tree.jump(v, root, 1);\n        return dp_2[w];\n    }\n\n    template <typename RAKE, typename APPLY_VERTEX, \n                                typename APPLY_EDGE>\n    void build(RAKE rake, APPLY_VERTEX apply_vertex, \n                    APPLY_EDGE apply_edge, const Data unit) {\n        int N = tree.N;\n        // dp1: subtree\n        dp_1.assign(N, unit);\n        Frr(i, N) {\n            int v = tree.V[i];\n            for (auto&& e: tree.G[v]) {\n                if (e.to == tree.parent[v]) continue;\n                dp_1[v] = rake(dp_1[v], apply_edge(dp_1[e.to], e));\n            }\n            dp_1[v] = apply_vertex(dp_1[v], v);\n        }\n\n        // dp2[v]: subtree of p, rooted at v\n        dp_2.assign(N, unit);\n        // dp[v]: fulltree, rooted at v\n        dp.assign(N, unit);\n        For(i, N) {\n            int p = tree.V[i];\n            vector<int> ch;\n            vector<Data> ch_data;\n            Data x = unit;\n            for (auto&& e: tree.G[p]) {\n                if (e.to == tree.parent[p]) {\n                    x = apply_edge(dp_2[p], e);\n                } else {\n                    ch.emplace_back(e.to);\n                    ch_data.emplace_back(apply_edge(dp_1[e.to], e));\n                }\n            }\n            int n = len(ch);\n            if (!n) {\n                dp[p] = apply_vertex(x, p);\n                continue;\n            }\n            vector<Data> prod_left(n, x);\n            For(i, n - 1) prod_left[i + 1] = rake(prod_left[i], ch_data[i]);\n            Data prod_right = unit;\n            Frr(i, n) {\n                dp_2[ch[i]] = apply_vertex(rake(prod_left[i], prod_right), p);\n                prod_right = rake(prod_right, ch_data[i]);\n            }\n            dp[p] = apply_vertex(rake(x, prod_right), p);\n        }\n    }\n};\n} // namespace mitsuha\n\n/*\nauto rake = [&](Data x, Data y) { return Data{}; };\nauto apply_vertex = [&](Data x, int v) { return x; };\nauto apply_edge = [&](Data x, auto& e) { return x; };\n\nFor each vertex u in reversed dfs order, set dp[u] = unit\nFor each child v of u with edge id, set dp[u] = rake(dp[u], apply_edge(f[v], id))\nFinally, set dp[u] = apply_vertex(u, dp[u])\n*/\n\nclass Solution {\npublic:\n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        int n = len(edges) + 1;\n        Graph<int> G(n);\n\n        For(x, n - 1){\n            G.add(edges[x][0], edges[x][1]);\n        }\n        G.build();\n        Tree<decltype(G)> T(G);\n\n        using Data = int;\n        auto rake = [&](Data x, Data y) { return max(x, y); };\n        auto apply_vertex = [&](Data x, int v) { \n            return x;\n        };\n        auto apply_edge = [&](Data x, auto& e) { \n            return (e.to & 1) ? x + 1: x + 2;\n        };\n        Rerooting_dp<decltype(T), Data> Rdp(T, rake, apply_vertex, apply_edge, 0);\n        return Rdp.dp;\n    }\n};\n\n",
    "submit_ts": "1722697988",
    "subm_id": "1343165920"
}