{
    "username": "woi55",
    "submission": "public class Solution {\n    public int MinimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        return Math.Max(MidDist(edges1) + MidDist(edges2) + 1, Math.Max(Diameter(edges1), Diameter(edges2)));\n    }\n    \n    private int Diameter(int[][] edges) {\n        int diameter = 0;\n        if (edges.Length == 0) {\n            return 0;\n        }\n        Queue<int> q = new Queue<int>();\n        int n = edges.Length + 1;\n        PriorityQueue<int, int>[] dist = new PriorityQueue<int, int>[n];\n        HashSet<int>[] map = MakeMap(n, edges);\n        for (int i = 0; i < n; ++i) {\n            dist[i] = new PriorityQueue<int, int>();\n            if (map[i].Count == 1) {\n                q.Enqueue(i);\n                dist[i].Enqueue(0, 0);\n            }\n        }\n        int node;\n        int tmp;\n        while (n > 0) {\n            --n;\n            node = q.Dequeue();\n            while (dist[node].Count > 2) {\n                dist[node].Dequeue();\n            }\n            if (dist[node].Count == 2) {\n                tmp = dist[node].Dequeue();\n            } else {\n                tmp = 0;\n            }\n            diameter = Math.Max(diameter, tmp + dist[node].Peek());\n            tmp = dist[node].Dequeue() + 1;\n            foreach (int next in map[node]) {\n                dist[next].Enqueue(tmp, tmp);\n                map[next].Remove(node);\n                if (map[next].Count == 1) {\n                    q.Enqueue(next);\n                }\n            }\n        }\n        return diameter;\n    }\n    \n    private int MidDist(int[][] edges) {\n        if (edges.Length == 0) {\n            return 0;\n        }\n        Queue<int> q = new Queue<int>();\n        int n = edges.Length + 1;\n        int[] dist = new int[n];\n        HashSet<int>[] map = MakeMap(n, edges);\n        for (int i = 0; i < n; ++i) {\n            if (map[i].Count == 1) {\n                q.Enqueue(i);\n            }\n        }\n        int node;\n        while (n > 1) {\n            --n;\n            node = q.Dequeue();\n            foreach (int next in map[node]) {\n                dist[next] = Math.Max(dist[next], dist[node] + 1);\n                map[next].Remove(node);\n                if (map[next].Count == 1) {\n                    q.Enqueue(next);\n                }\n            }\n        }\n        node = q.Dequeue();\n        return dist[node];\n    }\n    \n    private HashSet<int>[] MakeMap(int n, int[][] edges) {\n        HashSet<int>[] map = new HashSet<int>[n];\n        for (int i = 0; i < n; ++i) {\n            map[i] = new HashSet<int>();\n        }\n        foreach (int[] edge in edges) {\n            map[edge[0]].Add(edge[1]);\n            map[edge[1]].Add(edge[0]);\n        }\n        return map;\n    }\n}",
    "submit_ts": 1719719964.0
}