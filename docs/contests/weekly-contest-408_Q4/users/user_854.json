{
    "username": "211220058",
    "submission": "auto fastio=[]()  {\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    return nullptr;\n}();\nclass Solution {\npublic:\n    // Function to perform BFS\n    bool bfs(vector<vector<int>>& graph, int startNode, int endNode1, int endNode2, int totalNodes) {\n        queue<int> nodeQueue;\n        vector<int> visitedNodes(totalNodes, 0);\n        nodeQueue.push(startNode);\n        visitedNodes[startNode] = 1;\n\n        while (!nodeQueue.empty()) {\n            int currentNode = nodeQueue.front();\n            nodeQueue.pop();\n            for (int adjacentNode : graph[currentNode]) {\n                if (!visitedNodes[adjacentNode]) {\n                    nodeQueue.push(adjacentNode);\n                    visitedNodes[adjacentNode] = 1;\n                }\n            }\n        }\n        return visitedNodes[endNode1] || visitedNodes[endNode2];\n    }\n\n    // Function to initialize circle centers and radii\n    void initializeCirclesAndRadii(vector<vector<int>>& circleData, vector<pair<int, int>>& circleCenters, vector<int>& circleRadii) {\n        int numberOfCircles = circleData.size();\n        for (int index = 0; index < numberOfCircles; ++index) {\n            circleCenters[index] = {circleData[index][0], circleData[index][1]};\n            circleRadii[index] = circleData[index][2];\n        }\n    }\n\n    // Function to connect circles to left boundary\n    void connectToLeftBoundary(vector<vector<int>>& adjacencyList, vector<pair<int, int>>& circleCenters, vector<int>& circleRadii, int numberOfCircles) {\n        for (int circleIndex = 0; circleIndex < numberOfCircles; ++circleIndex) {\n            if (circleCenters[circleIndex].first <= circleRadii[circleIndex]) {\n                adjacencyList[numberOfCircles].push_back(circleIndex);\n                adjacencyList[circleIndex].push_back(numberOfCircles);\n            }\n        }\n    }\n\n    // Function to connect circles to right boundary\n    void connectToRightBoundary(vector<vector<int>>& adjacencyList, vector<pair<int, int>>& circleCenters, vector<int>& circleRadii, int numberOfCircles, int width) {\n        for (int circleIndex = 0; circleIndex < numberOfCircles; ++circleIndex) {\n            if (width - circleCenters[circleIndex].first <= circleRadii[circleIndex]) {\n                adjacencyList[numberOfCircles + 2].push_back(circleIndex);\n                adjacencyList[circleIndex].push_back(numberOfCircles + 2);\n            }\n        }\n    }\n\n    // Function to connect circles to top boundary\n    void connectToTopBoundary(vector<vector<int>>& adjacencyList, vector<pair<int, int>>& circleCenters, vector<int>& circleRadii, int numberOfCircles) {\n        for (int circleIndex = 0; circleIndex < numberOfCircles; ++circleIndex) {\n            if (circleCenters[circleIndex].second <= circleRadii[circleIndex]) {\n                adjacencyList[numberOfCircles + 1].push_back(circleIndex);\n                adjacencyList[circleIndex].push_back(numberOfCircles + 1);\n            }\n        }\n    }\n\n    // Function to connect circles to bottom boundary\n    void connectToBottomBoundary(vector<vector<int>>& adjacencyList, vector<pair<int, int>>& circleCenters, vector<int>& circleRadii, int numberOfCircles, int height) {\n        for (int circleIndex = 0; circleIndex < numberOfCircles; ++circleIndex) {\n            if (height - circleCenters[circleIndex].second <= circleRadii[circleIndex]) {\n                adjacencyList[numberOfCircles + 3].push_back(circleIndex);\n                adjacencyList[circleIndex].push_back(numberOfCircles + 3);\n            }\n        }\n    }\n\n    // Function to connect circles to each other\n    void connectCircles(vector<vector<int>>& adjacencyList, vector<pair<int, int>>& circleCenters, vector<int>& circleRadii, int numberOfCircles) {\n        for (int circleIndex = 0; circleIndex < numberOfCircles; ++circleIndex) {\n            for (int otherCircleIndex = circleIndex + 1; otherCircleIndex < numberOfCircles; ++otherCircleIndex) {\n                double distance = sqrt(pow(circleCenters[circleIndex].first - circleCenters[otherCircleIndex].first, 2) +\n                                       pow(circleCenters[circleIndex].second - circleCenters[otherCircleIndex].second, 2));\n                if (circleRadii[circleIndex] + circleRadii[otherCircleIndex] >= distance) {\n                    adjacencyList[circleIndex].push_back(otherCircleIndex);\n                    adjacencyList[otherCircleIndex].push_back(circleIndex);\n                }\n            }\n        }\n    }\n\n    // Function to check reachability from left and right corners\n    bool checkReachabilityLeftRight(vector<vector<int>>& adjacencyList, int numberOfCircles) {\n        return bfs(adjacencyList, numberOfCircles, numberOfCircles + 1, numberOfCircles + 2, numberOfCircles + 4);\n    }\n\n    // Function to check reachability from top and bottom corners\n    bool checkReachabilityTopBottom(vector<vector<int>>& adjacencyList, int numberOfCircles) {\n        return bfs(adjacencyList, numberOfCircles + 3, numberOfCircles + 2, numberOfCircles + 1, numberOfCircles + 4);\n    }\n\n    // Main function to check if any corner can be reached\n    bool canReachCorner(int width, int height, vector<vector<int>>& circleData) {\n        int numberOfCircles = circleData.size();\n        vector<pair<int, int>> circleCenters(numberOfCircles);\n        vector<int> circleRadii(numberOfCircles);\n        vector<vector<int>> adjacencyList(numberOfCircles + 4);\n\n        initializeCirclesAndRadii(circleData, circleCenters, circleRadii);\n        connectToLeftBoundary(adjacencyList, circleCenters, circleRadii, numberOfCircles);\n        connectToRightBoundary(adjacencyList, circleCenters, circleRadii, numberOfCircles, width);\n        connectToTopBoundary(adjacencyList, circleCenters, circleRadii, numberOfCircles);\n        connectToBottomBoundary(adjacencyList, circleCenters, circleRadii, numberOfCircles, height);\n        connectCircles(adjacencyList, circleCenters, circleRadii, numberOfCircles);\n\n        return !(checkReachabilityLeftRight(adjacencyList, numberOfCircles) || checkReachabilityTopBottom(adjacencyList, numberOfCircles));\n    }\n};\n",
    "submit_ts": "1722138808",
    "subm_id": "1335800219"
}