{
    "username": "aezara",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def makegraph(edges):\n            d = defaultdict(lambda: set())\n            for u, v in edges:\n                d[u].add(v)\n                d[v].add(u) # bidirectional\n            return d\n        g1 = makegraph(edges1)\n        g2 = makegraph(edges2)\n        \n        def bfs(g, s):\n            visited = [False for _ in range(len(g))]\n\n            queue = [(s, 0)]\n            visited[s] = True\n            \n            maxdist = 0\n            furthestnode = None\n\n            while queue:\n                curr, d = queue.pop(0)\n                if d > maxdist:\n                    maxdist = d\n                    furthestnode = curr\n                maxdist = max(maxdist, d)\n                \n                for i in g[curr]:\n                    if not visited[i]:\n                        queue.append((i, d+1))\n                        visited[i] = True\n            return maxdist, furthestnode\n        \n        # get diameter of each graph\n        def getdiam(g):\n            if len(g) == 0:\n                return 0\n            _, farleaf = bfs(g, 0)\n            diam, otherend = bfs(g, farleaf)\n            return diam\n        \n        d1 = getdiam(g1)\n        d2 = getdiam(g2)\n        \n        across = math.ceil(d1/2) + math.ceil(d2/2) + 1\n        \n        # print(f\"{m1=} {d1=} {m2=} {d2=}\")\n        \n        return max(across, d1, d2)\n    \n#         def makegraph(edges):\n#             d = defaultdict(lambda: set())\n#             for u, v in edges:\n#                 d[u].add(v)\n#                 d[v].add(u) # bidirectional\n#             return d\n#         g1 = makegraph(edges1)\n#         g2 = makegraph(edges2)\n        \n#         # find middle node of each\n#         # repeatedly remove leaf nodes\n#         def findmiddle(g):\n#             if len(g) == 0:\n#                 return None, 0, 0\n            \n#             dist = 0\n#             while len(g) > 2:\n#                 # find leaves\n#                 leaves = []\n#                 for i, edges in g.items():\n#                     if len(edges) == 1:\n#                         leaves.append(i)\n#                 # remove leaves\n#                 for l in leaves:\n#                     g[g[l].pop()].remove(l)\n#                     del g[l]\n#                 dist += 1\n#                 # print(g)\n#             keysleft = list(g.keys())\n#             diam = dist * 2\n#             if len(keysleft) > 1:\n#                 dist += 1\n#                 diam += 1\n#             return keysleft[0], dist, diam\n        \n#         # get mids\n#         m1, d1, di1 = findmiddle(g1)\n#         m2, d2, di2 = findmiddle(g2)\n        \n#         across = d1+d2+1\n        \n#         # print(f\"{m1=} {d1=} {m2=} {d2=}\")\n        \n#         return max(across, di1, di2)",
    "submit_ts": 1719718827.0
}