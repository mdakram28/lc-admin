{
    "username": "xobe19",
    "submission": "class Solution {\n     class SegmentTree \n{\n    int st[]; // The array that stores segment tree nodes\n \n    /* Constructor to construct segment tree from given array. This\n       constructor  allocates memory for segment tree and calls\n       constructSTUtil() to  fill the allocated memory */\n    SegmentTree(int arr[], int n)\n    {\n        // Allocate memory for segment tree\n        //Height of segment tree\n        int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));\n \n        //Maximum size of segment tree\n        int max_size = 2 * (int) Math.pow(2, x) - 1;\n \n        st = new int[max_size]; // Memory allocation\n \n        constructSTUtil(arr, 0, n - 1, 0);\n    }\n \n    // A utility function to get the middle index from corner indexes.\n    int getMid(int s, int e) {\n        return s + (e - s) / 2;\n    }\n \n    /*  A recursive function to get the sum of values in given range\n        of the array.  The following are parameters for this function.\n \n      st    --> Pointer to segment tree\n      si    --> Index of current node in the segment tree. Initially\n                0 is passed as root is always at index 0\n      ss & se  --> Starting and ending indexes of the segment represented\n                    by current node, i.e., st[si]\n      qs & qe  --> Starting and ending indexes of query range */\n    int getSumUtil(int ss, int se, int qs, int qe, int si)\n    {\n        // If segment of this node is a part of given range, then return\n        // the sum of the segment\n        if (qs <= ss && qe >= se)\n            return st[si];\n \n        // If segment of this node is outside the given range\n        if (se < qs || ss > qe)\n            return 0;\n \n        // If a part of this segment overlaps with the given range\n        int mid = getMid(ss, se);\n        return getSumUtil(ss, mid, qs, qe, 2 * si + 1) +\n                getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);\n    }\n \n    /* A recursive function to update the nodes which have the given \n       index in their range. The following are parameters\n        st, si, ss and se are same as getSumUtil()\n        i    --> index of the element to be updated. This index is in\n                 input array.\n       diff --> Value to be added to all nodes which have i in range */\n    void updateValueUtil(int ss, int se, int i, int diff, int si)\n    {\n        // Base Case: If the input index lies outside the range of \n        // this segment\n        if (i < ss || i > se)\n            return;\n \n        // If the input index is in range of this node, then update the\n        // value of the node and its children\n        st[si] = st[si] + diff;\n        if (se != ss) {\n            int mid = getMid(ss, se);\n            updateValueUtil(ss, mid, i, diff, 2 * si + 1);\n            updateValueUtil(mid + 1, se, i, diff, 2 * si + 2);\n        }\n    }\n \n    // The function to update a value in input array and segment tree.\n   // It uses updateValueUtil() to update the value in segment tree\n    void updateValue(int arr[], int n, int i, int new_val)\n    {\n        // Check for erroneous input index\n        if (i < 0 || i > n - 1) {\n            System.out.println(\"Invalid Input\");\n            return;\n        }\n \n        // Get the difference between new value and old value\n        int diff = new_val - arr[i];\n \n        // Update the value in array\n        arr[i] = new_val;\n \n        // Update the values of nodes in segment tree\n        updateValueUtil(0, n - 1, i, diff, 0);\n    }\n \n    // Return sum of elements in range from index qs (query start) to\n   // qe (query end).  It mainly uses getSumUtil()\n    int getSum(int n, int qs, int qe)\n    {\n        // Check for erroneous input values\n        if (qs < 0 || qe > n - 1 || qs > qe) {\n            System.out.println(\"Invalid Input\");\n            return -1;\n        }\n        return getSumUtil(0, n - 1, qs, qe, 0);\n    }\n \n    // A recursive function that constructs Segment Tree for array[ss..se].\n    // si is index of current node in segment tree st\n    int constructSTUtil(int arr[], int ss, int se, int si)\n    {\n        // If there is one element in array, store it in current node of\n        // segment tree and return\n        if (ss == se) {\n            st[si] = arr[ss];\n            return arr[ss];\n        }\n \n        // If there are more than one elements, then recur for left and\n        // right subtrees and store the sum of values in this node\n        int mid = getMid(ss, se);\n        st[si] = constructSTUtil(arr, ss, mid, si * 2 + 1) +\n                 constructSTUtil(arr, mid + 1, se, si * 2 + 2);\n        return st[si];\n    }\n \n    // Driver program to test above functions\n\n}\n      boolean isPeak(int[] arr, int arrIndex) {\n            if(arrIndex == 0 || arrIndex == arr.length - 1) return false;\n            return arr[arrIndex] > arr[arrIndex - 1] && arr[arrIndex] > arr[arrIndex + 1];\n        }\n  \n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int[] peaks = new int[n];\n        for(int i = 0; i < n; i++) {\n           if(isPeak(nums, i))  peaks[i] = 1; \n        }\n        SegmentTree st = new SegmentTree(peaks, n);\n        List<Integer> ans = new ArrayList<>();\n        for(int[] query : queries) {\n            if(query[0] == 1) {\n               int nans = (st.getSum(n, query[1], query[2])); \n                if(peaks[query[2]] == 1) nans -= 1;\n                if( query[2] != query[1] && peaks[query[1]] == 1) nans -= 1;\n                ans.add(nans);\n                \n            }\n            else {\n                int indx = query[1];\n               int val = query[2]; \n                nums[indx] = val;\n                int str = Math.max(indx - 2, 0);\n                int end  =Math.min(indx + 2,n-1);\n                for(int k = str; k <= end; k++) {\n                    int nv = 0;\n                    if(isPeak(nums, k)) {\n                        nv = 1;\n                    }\n                   if(nv != peaks[k]) {\n                       st.updateValue(peaks, n, k, nv);\n                       peaks[k] = nv;\n                   } \n                }\n            }\n        }\n        return ans;\n    }\n}",
    "submit_ts": 1718507822.0
}