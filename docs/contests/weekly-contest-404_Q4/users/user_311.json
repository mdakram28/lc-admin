{
    "username": "lukeiscoding",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def treeDiameter(edges: List[List[int]]) -> int:\n\n            # build the adjacency list representation of the graph.\n            graph = [set() for i in range(len(edges)+1)]\n            for edge in edges:\n                u, v = edge\n                graph[u].add(v)\n                graph[v].add(u)\n\n            # find the outer most nodes, _i.e._ leaf nodes\n            leaves = []\n            for vertex, links in enumerate(graph):\n                if len(links) == 1:\n                    leaves.append(vertex)\n\n            # \"peel\" the graph layer by layer,\n            #   until we have the centroids left.\n            layers = 0\n            vertex_left = len(edges) + 1\n            while vertex_left > 2:\n                vertex_left -= len(leaves)\n                next_leaves = []\n                for leaf in leaves:\n                    # the only neighbor left on the leaf node.\n                    neighbor = graph[leaf].pop()\n                    graph[neighbor].remove(leaf)\n                    if len(graph[neighbor]) == 1:\n                        next_leaves.append(neighbor)\n                layers += 1\n                leaves = next_leaves\n\n            return layers * 2 + (0 if vertex_left == 1 else 1)\n        \n        d1 = treeDiameter(edges1)\n        d2 = treeDiameter(edges2)\n        return max([(d1 + 1) //2 + (d2 + 1) // 2 + 1, d1, d2])",
    "submit_ts": "1719718130",
    "subm_id": "1304409516"
}