{
    "username": "Blackfury7",
    "submission": "class Solution {\npublic:\n    #define ll long long int\n     const int MX = (1LL << 31) - 1;\n\n    struct Node {\n        int mx = (1LL << 31) - 1;\n        ll val;\n        Node(): val(mx) {}\n        Node(ll v): val(v){}\n\n        friend Node merge(Node l, Node r) {return Node(l.val & r.val);} // may change\n        void update(ll v) {val = v;} // may change\n    };\n\n    // Never change this\n    struct SegmentTree {\n        int n;\n        vector<Node> seg;\n        SegmentTree(int _n): n(_n), seg(2 * _n) {}\n        template <typename Type>\n        SegmentTree(vector<Type> a) {\n            n = int(a.size());\n            seg.resize(2 * n);\n            for(int i = 0; i < n; i++) seg[i + n] = Node(a[i]);\n            for(int i = n - 1; i > 0; i--) seg[i] = merge(seg[i<<1], seg[i << 1 | 1]);\n\n        }\n        void update(int i, ll v) {\n            for(seg[i += n].update(v); i >>=1; ) seg[i] = merge(seg[i << 1], seg[i << 1 | 1]);\n        }\n        Node query(int l, int r) {\n            Node resl, resr;\n            for(l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {\n                if(l & 1) resl = merge(resl, seg[l++]);\n                if(r & 1) resr = merge(seg[--r], resr);\n            }\n            return merge(resl, resr);\n        }\n    };\n\n    long long countSubarrays(vector<int>& a, int k) {\n        SegmentTree sg(a);\n        \n        int n = a.size();\n        ll ans = 0;\n        \n        // binary search\n        auto find = [&] (int i) {\n            int start = i, end = n - 1; \n            ll res = n;\n        \n            while(start <= end) {\n                int mid = (start + end) >> 1;\n                if(sg.query(i, mid).val <= k) res = mid, end = mid - 1;\n                else start = mid + 1;\n            }\n            return res;\n        };\n        auto find1 = [&] (int i) {\n            int start1 = i, end1 = n - 1;\n            ll res1 = n;\n        \n            while(start1 <= end1) {\n                int mid = (start1 + end1) >> 1;\n                if(sg.query(i, mid).val >= k) res1 = mid, start1 = mid + 1;\n                else end1 = mid - 1;\n            }\n            return res1;\n        };\n        \n        for(int i = 0 ; i < n; i++) {\n            int a1 = find(i);\n            int b = find1(i);\n            if(a1 < n and b < n){\n                if((sg.query(i,a1).val == k) and (sg.query(i,b).val == k))\n                    ans += b-a1+1;\n            } \n        }\n        \n     \n        return ans;\n    }\n};",
    "submit_ts": "1720279884",
    "subm_id": "1311768910"
}