{
    "username": "piyush_razz",
    "submission": "class Solution {\n\n#define MAX 50005\n// Ideally, we should not use global variables and large\n// constant-sized arrays, we have done it here for simplicity\n\n// To store segment tree\nint tree[4*MAX + 5] = { 0 };\n\n// To store pending updates\nint lazy[4*MAX + 5] = { 0 };\n\n// si -> index of current node in segment tree\n// ss and se -> Starting and ending indexes of\n// elements for which current nodes stores sum\n// us and ue -> starting and ending indexes of update query\n// diff -> which we need to add in the range us to ue\nvoid updateRangeUtil(int si, int ss, int se, int us,\n\t\t\t\t\tint ue, int diff)\n{\n\t// If lazy value is non-zero for current node of segment\n\t// tree, then there are some pending updates. So we need\n\t// to make sure that the pending updates are done before\n\t// making new updates. Because this value may be used by\n\t// parent after recursive calls (See last line of this\n\t// function)\n\tif (lazy[si] != 0) {\n\t\t// Make pending updates using value stored in lazy\n\t\t// nodes\n\t\ttree[si] += lazy[si];\n\n\t\t// Checking if it is not leaf node because if\n\t\t// it is leaf node then we cannot go further\n\t\tif (ss != se) {\n\t\t\t// We can postpone updating children we don't\n\t\t\t// need their new values now.\n\t\t\t// Since we are not yet updating children of si,\n\t\t\t// we need to set lazy flags for the children\n\t\t\tlazy[si * 2 + 1] += lazy[si];\n\t\t\tlazy[si * 2 + 2] += lazy[si];\n\t\t}\n\n\t\t// Set the lazy value for current node as 0 as it\n\t\t// has been updated\n\t\tlazy[si] = 0;\n\t}\n\n\t// Out of range\n\tif (ss > se || ss > ue || se < us)\n\t\treturn;\n\n\t// Current segment is fully in range\n\tif (ss >= us && se <= ue) {\n\t\t// Add the difference to current node\n\t\ttree[si] += diff;\n\n\t\t// Same logic for checking leaf node or not\n\t\tif (ss != se) {\n\t\t\t// This is where we store values in lazy nodes,\n\t\t\t// rather than updating the segment tree itself\n\t\t\t// Since we don't need these updated values now\n\t\t\t// we postpone updates by storing values in lazy[]\n\t\t\tlazy[si * 2 + 1] += diff;\n\t\t\tlazy[si * 2 + 2] += diff;\n\t\t}\n\t\treturn;\n\t}\n\n\t// If not completely in range, but overlaps\n\t// recur for children\n\tint mid = (ss + se) / 2;\n\tupdateRangeUtil(si * 2 + 1, ss, mid, us, ue, diff);\n\tupdateRangeUtil(si * 2 + 2, mid + 1, se, us, ue, diff);\n\n\t// And use the result of children calls\n\t// to update this node\n\ttree[si] = max(tree[si * 2 + 1], tree[si * 2 + 2]);\n}\n\n// Function to update a range of values in segment\n// tree\n// us and eu -> starting and ending indexes of update query\n// ue -> ending index of update query\n// diff -> which we need to add in the range us to ue\nvoid updateRange(int n, int us, int ue, int diff)\n{\n\tupdateRangeUtil(0, 0, n - 1, us, ue, diff);\n}\n\n// A recursive function to get the max of values in given\n// a range of the array. The following are the parameters\n// for this function\n// si --> Index of the current node in the segment tree\n// Initially, 0 is passed as root is always at index 0\n// ss & se --> Starting and ending indexes of the\n// segment represented by current node\n// i.e., tree[si]\n// qs & qe --> Starting and ending indexes of query\n// range\nint getMaxUtil(int ss, int se, int qs, int qe, int si)\n{\n\n\t// If lazy flag is set for current node of segment tree\n\t// then there are some pending updates. So we need to\n\t// make sure that the pending updates are done before\n\t// processing the sub sum query\n\tif (lazy[si] != 0) {\n\n\t\t// Make pending updates to this node. Note that this\n\t\t// node represents sum of elements in arr[ss..se] and\n\t\t// all these elements must be increased by lazy[si]\n\t\ttree[si] += lazy[si];\n\n\t\t// Checking if it is not leaf node because if\n\t\t// it is leaf node then we cannot go further\n\t\tif (ss != se) {\n\t\t\t// Since we are not yet updating children os si,\n\t\t\t// we need to set lazy values for the children\n\t\t\tlazy[si * 2 + 1] += lazy[si];\n\t\t\tlazy[si * 2 + 2] += lazy[si];\n\t\t}\n\n\t\t// Unset the lazy value for current node as it has\n\t\t// been updated\n\t\tlazy[si] = 0;\n\t}\n\n\t// Out of range\n\tif (ss > se || ss > qe || se < qs)\n\t\treturn 0;\n\n\t// At this point, we are sure that pending lazy updates\n\t// are done for current node. So we can return value\n\t// (same as it was for a query in our previous post)\n\n\t// If this segment lies in range\n\tif (ss >= qs && se <= qe)\n\t\treturn tree[si];\n\n\t// If a part of this segment overlaps with the given\n\t// range\n\tint mid = (ss + se) / 2;\n\treturn max(getMaxUtil(ss, mid, qs, qe, 2 * si + 1),\n\t\t\tgetMaxUtil(mid + 1, se, qs, qe, 2 * si + 2));\n}\n\n// Return max of elements in range from index qs (query\n// start) to qe (query end). It mainly uses getSumUtil()\nint getMax(int n, int qs, int qe)\n{\n\t// Check for erroneous input values\n\tif (qs < 0 || qe > n - 1 || qs > qe) {\n\t\tprintf(\"Invalid Input\");\n\t\treturn -1;\n\t}\n\n\treturn getMaxUtil(0, n - 1, qs, qe, 0);\n}\n\n// A recursive function that constructs Segment Tree for\n// array[ss..se]. si is index of current node in segment\n// tree st.\nvoid constructSTUtil(int arr[], int ss, int se, int si)\n{\n\t// out of range as ss can never be greater than se\n\tif (ss > se)\n\t\treturn;\n\n\t// If there is one element in array, store it in\n\t// current node of segment tree and return\n\tif (ss == se) {\n\t\ttree[si] = arr[ss];\n\t\treturn;\n\t}\n\n\t// If there are more than one elements, then recur\n\t// for left and right subtrees and store the sum\n\t// of values in this node\n\tint mid = (ss + se) / 2;\n\tconstructSTUtil(arr, ss, mid, si * 2 + 1);\n\tconstructSTUtil(arr, mid + 1, se, si * 2 + 2);\n\n\ttree[si] = max(tree[si * 2 + 1], tree[si * 2 + 2]);\n}\n\n// Function to construct a segment tree from a given array\n// This function allocates memory for segment tree and\n// calls constructSTUtil() to fill the allocated memory\nvoid constructST(int arr[], int n)\n{\n\t// Fill the allocated memory st\n\tconstructSTUtil(arr, 0, n - 1, 0);\n}\n\n// // Driver code\n// int main()\n// {\n// \tint arr[] = { 1, 2, 3, 4, 5 };\n// \tint n = sizeof(arr) / sizeof(arr[0]);\n\n// \t// Build segment tree from given array\n// \tconstructST(arr, n);\n\n// \t// Add 4 to all nodes in index range [0, 3]\n// \tupdateRange(n, 0, 3, 4);\n\n// \t// Print maximum element in index range [1, 4]\n// \tcout << getMax(n, 1, 4);\n\n// \treturn 0;\n// }\n\npublic:\n    vector<bool> getResults(vector<vector<int>>& q) {\n        int m = q.size();\n        vector<bool>ans;\n        int n = 50005;\n        int arr[n];\n        for(int i=0;i<n; i++){\n            arr[i] =n;\n        }\n        constructST(arr, n);\n        set<int>st;\n        st.insert(0);\n        st.insert(n);\n        for(int i=0;i<m; i++)\n        {\n            int ty = q[i][0];\n            if(ty==1){\n                int x = q[i][1];\n                auto it = st.lower_bound(x);\n                int r = *it;\n                it--;\n                int l = *it;\n                int lr = (x-l);\n                int rr = (r-x);\n                updateRange(n, l, x-1, -rr);\n                updateRange(n, x, r-1, -lr);\n                st.insert(x);\n            }\n            else{\n                int mx = q[i][1];\n                int sz = q[i][2];\n                int len =0;\n                auto it = st.lower_bound(mx);\n                if(it==st.end()){\n                    ans.push_back(1);\n                    continue;\n                }\n                it--;\n                int ind = *it;\n                if(ind>=2){\n                    len = getMax(n, 0, ind-1);\n                }\n                else if(ind==1){\n                    len = 1;\n                }\n                else{\n                    len = 0;\n                }\n                len = max(len, mx-ind);\n                //cout << ind << \" \";\n                // cout << arr[0] << \" \" << arr[1] << \" \" << arr[2] << endl;\n                if(len >= sz){\n                    ans.push_back(1);\n                }\n                else{\n                    ans.push_back(0);\n                }\n            }\n        }\n        //cout << endl;\n        return ans;\n    }\n};",
    "submit_ts": "1716651850",
    "subm_id": "1267649972"
}