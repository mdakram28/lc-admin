{
    "username": "leet-do-it",
    "submission": "from collections import deque\nfrom typing import List\n\nclass Solution:\n\n    def bfs_to_find_all_distances(self, start, adjacency, n):\n        visited = [False] * n\n        distance = [0] * n\n        queue = deque([start])\n        visited[start] = True\n        distance[start] = 0\n\n        while queue:\n            node = queue.popleft()\n            for neighbor in adjacency[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    distance[neighbor] = distance[node] + 1\n\n        return distance\n\n    def build_adjacency_list(self, edges, n):\n        adjacency = [[] for _ in range(n)]\n        for u, v in edges:\n            adjacency[u].append(v)\n            adjacency[v].append(u)\n        return adjacency\n\n    def diameter_and_center(self, edges, n):\n        if n == 0:\n            return 0, []  # No nodes\n\n        adjacency = self.build_adjacency_list(edges, n)\n\n        # Get distances from an arbitrary node (0)\n        distances_from_first = self.bfs_to_find_all_distances(0, adjacency, n)\n        farthest = distances_from_first.index(max(distances_from_first))  # node with max distance from 0\n\n        # Get distances from the farthest node found\n        distances_from_second = self.bfs_to_find_all_distances(farthest, adjacency, n)\n        diameter = max(distances_from_second)\n\n        # Find centers\n        path = []\n        current = distances_from_second.index(diameter)\n        while distances_from_second[current] != 0:  # trace back to start\n            path.append(current)\n            for neighbor in adjacency[current]:\n                if distances_from_second[neighbor] == distances_from_second[current] - 1:\n                    current = neighbor\n                    break\n        path.append(farthest)\n\n        # Determine center(s)\n        path_length = len(path)\n        center = []\n        if path_length % 2 == 0:\n            center.append(path[path_length // 2 - 1])\n        center.append(path[path_length // 2])\n\n        return diameter, center\n\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        n = len(edges1) + 1\n        m = len(edges2) + 1\n        diameter1, centers1 = self.diameter_and_center(edges1, n)\n        diameter2, centers2 = self.diameter_and_center(edges2, m)\n\n        if not centers1 or not centers2:\n            # If either tree has no centers (empty tree)\n            return 0\n\n        adjacency1 = self.build_adjacency_list(edges1, n)\n        adjacency2 = self.build_adjacency_list(edges2, m)\n\n        min_diameter = float('inf')\n        for c1 in centers1:\n            for c2 in centers2:\n                distances1 = self.bfs_to_find_all_distances(c1, adjacency1, n)\n                distances2 = self.bfs_to_find_all_distances(c2, adjacency2, m)\n                max_d1 = max(distances1)\n                max_d2 = max(distances2)\n                # Calculate potential new diameter\n                min_diameter = min(min_diameter, max(diameter1, diameter2, max_d1 + max_d2 + 1))\n\n        return min_diameter",
    "submit_ts": 1719719945.0
}