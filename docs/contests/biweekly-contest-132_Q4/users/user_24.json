{
    "username": "wjli",
    "submission": "\n// COPY ALL MACROS BELOW\n\ntypedef long long LL;\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define LB lower_bound\n#define UB upper_bound\n#define SZ(x) ((int)x.size())\n#define LEN(x) ((int)x.length())\n#define ALL(x) begin(x), end(x)\n#define RSZ resize\n#define ASS assign\n#define REV(x) reverse(x.begin(), x.end());\n#define trav(a, x) for (auto& a : x)\ntypedef pair<LL, LL> PL;\ntypedef vector<LL> VL;\ntypedef vector<PL> VPL;\ntypedef vector<VL> VVL;\ntypedef vector<VVL> VVVL;\ntypedef vector<VVVL> VVVVL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PI;\ntypedef vector<int> VI;\ntypedef vector<PI> VPI;\ntypedef vector<vector<int>> VVI;\ntypedef vector<vector<PI>> VVPI;\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\n#define FOR(i, n) for (int i = 0; i < n; i++) \n#define FOR1(i, n) for (int i = 1; i <= n; i++) \n#define SORT(x) sort(x.begin(), x.end())\n#define RSORT(x) sort(x.rbegin(), x.rend())\n#define SUM(x) accumulate(x.begin(), x.end(), 0LL)\n\n\n\n\ntemplate <typename T>\nclass segment_tree {\n    vector<T> t;\n    T VERYBIG;\n    bool ISMAXRANGE;\n    int size;\npublic:\n    segment_tree(int n, bool range_max = true) {\n        if (is_same<T, int>::value) VERYBIG = (1 << 30);\n        else if (is_same<T, LL>::value) VERYBIG = (1LL << 60);\n        //else if (is_same<T, PII>::value) VERYBIG = PII({ 1E9, 1E9 });\n        //else if (is_same<T, PLL>::value) VERYBIG = { 1LL << 60, 1LL << 60 };\n\n        ISMAXRANGE = range_max;\n\n        if (ISMAXRANGE) t.assign(4 * n + 1, 0);\n        else t.assign(4 * n + 1, VERYBIG);\n        size = n;\n    }\n\n    void initialize_array(vector<T>& v) {\n        initialize_with_array(1, 0, size - 1, v);\n    }\n\n    void initialize_with_array(int startpos, int l, int r, vector<T>& v) {\n        if (l == r) {\n            t[startpos] = v[l];\n        }\n        else {\n            int m = (l + r) / 2;\n            initialize_with_array(2 * startpos, l, m, v);\n            initialize_with_array(2 * startpos + 1, m + 1, r, v);\n\n            if (ISMAXRANGE == 1) t[startpos] = max(t[startpos * 2], t[startpos * 2 + 1]);\n            else  t[startpos] = min(t[startpos * 2], t[startpos * 2 + 1]);\n        }\n    }\n\n    void update(int index, T val) { // insert val into location index\n        update_full(1, 0, size - 1, index, val);\n    }\n\n    void update_full(int startpos, int l, int r, int index, T val) {\n        if (l == r) {\n            t[startpos] = val;\n        }\n        else {\n            int m = (l + r) / 2;\n            if (index <= m) update_full(2 * startpos, l, m, index, val);\n            else update_full(2 * startpos + 1, m + 1, r, index, val);\n\n            if (ISMAXRANGE) t[startpos] = max(t[startpos * 2], t[startpos * 2 + 1]);\n            else t[startpos] = min(t[startpos * 2], t[startpos * 2 + 1]);\n        }\n    }\n\n    T query(int l, int r) {  // get range min/max between l and r\n        if (l > r) {\n            if (ISMAXRANGE) return 0;\n            else return VERYBIG;\n        }\n        return query_full(1, 0, size - 1, l, r);\n    }\n\n    T query_full(int startpos, int left, int right, int l, int r) {\t // left/right = current range, l/r = intended query range\n        if ((left >= l) && (right <= r)) return t[startpos];\n        int m = (left + right) / 2;\n        T ans;\n        if (ISMAXRANGE) ans = -VERYBIG;\n        else ans = VERYBIG;\n        if (m >= l) {\n            if (ISMAXRANGE) ans = max(ans, query_full(startpos * 2, left, m, l, r));\n            else ans = min(ans, query_full(startpos * 2, left, m, l, r));\n        }\n        if (m + 1 <= r) {\n            if (ISMAXRANGE) ans = max(ans, query_full(startpos * 2 + 1, m + 1, right, l, r));\n            else ans = min(ans, query_full(startpos * 2 + 1, m + 1, right, l, r));\n        }\n        return ans;\n    }\n};\n\nclass Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {\n        int n = nums.size(), i, j, ans, INF = 1E9, m = 0;\n        map<int, int> id;\n        FOR(i, n) id[nums[i]] = 0;\n        id[0] = 0;\n        for (auto p : id) id[p.first] = m++; \n        FOR(i, n) nums[i] = id[nums[i]];\n        m += 2;\n\n        // dp[step][k used]\n        ans = 0;\n        VVI dp(n, VI(k + 1, -INF));\n\n        FOR(i, n) dp[i][0] = 1;\n        FOR(kk, k + 1) {\n            segment_tree<int> st(m);\n            VI maxxx(m, 0);\n            VI maxx(m, 0);\n            FOR(i, n) {\n                int x = 0;\n                if (nums[i] > 0) x = max(x, st.query(0, nums[i] - 1));\n                x = max(x, st.query(nums[i] + 1, m - 1));\n                dp[i][kk] = max(maxx[nums[i]] + 1, x + 1);\n\n                if ((kk > 0) && (maxxx[nums[i]] < dp[i][kk - 1])) {\n                    maxxx[nums[i]] = dp[i][kk - 1];\n                    st.update(nums[i], dp[i][kk - 1]);\n                }\n\n                maxx[nums[i]] = max(maxx[nums[i]], dp[i][kk]);\n            }\n\n        }\n\n        ans = 0;\n        FOR(kk, k + 1) {\n            FOR(i, n) ans = max(ans, dp[i][kk]);\n        }\n\n        return ans;\n    }\n};\n\n",
    "submit_ts": 1717858985.0
}