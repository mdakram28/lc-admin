{
    "username": "_priyanshu_101_",
    "submission": "class Solution {\npublic:\n    \n    vector <int> firstMax1, secondMax1, firstMax2, secondMax2, c1, c2;\n    vector <vector<int>> t1, t2;\n    \n    void dfs(int v, int p, vector <int> &firstMax, vector <int> &secondMax, vector <vector<int>> &adj, vector <int> &c) {\n        firstMax[v] = 0;\n        secondMax[v] = 0;\n        for (auto x : adj[v]) {\n            if (x == p) continue;\n            dfs(x, v, firstMax, secondMax, adj, c);\n            if (firstMax[x] + 1 > firstMax[v]) {\n                secondMax[v] = firstMax[v];\n                firstMax[v] = firstMax[x] + 1;\n                c[v] = x;\n            } else if (firstMax[x] + 1 > secondMax[v]) {\n                secondMax[v] = firstMax[x] + 1;\n            }\n        }\n    }\n\n    void dfs2(int v, int p, vector <int> &firstMax, vector <int> &secondMax, vector <vector<int>> &adj, vector <int> &c) {\n        for (auto x : adj[v]) {\n            if (x == p) continue;\n            if (c[v] == x) {\n                if (firstMax[x] < secondMax[v] + 1) {\n                    secondMax[x] = firstMax[x];\n                    firstMax[x] = secondMax[v] + 1;\n                    c[x] = v;\n                } else {\n                    secondMax[x] = max(secondMax[x], secondMax[v] + 1);\n                }\n            } else {\n                secondMax[x] = firstMax[x];\n                firstMax[x] = firstMax[v] + 1;\n                c[x] = v;\n            }\n            dfs2(x, v, firstMax, secondMax, adj, c);\n        }\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        firstMax1 = secondMax1 = c1 = vector <int> (n + 1);\n        firstMax2 = secondMax2 = c2 = vector <int> (m + 1);\n        t1 = vector <vector<int>> (n + 1);\n        t2 = vector <vector<int>> (m + 1);\n        for (auto &x : edges1) {\n            t1[x[0] + 1].push_back(x[1] + 1);\n            t1[x[1] + 1].push_back(x[0] + 1);\n        }\n        for (auto &x : edges2) {\n            t2[x[0] + 1].push_back(x[1] + 1);\n            t2[x[1] + 1].push_back(x[0] + 1);\n        }\n        dfs(1, 0, firstMax1, secondMax1, t1, c1);\n        dfs(1, 0, firstMax2, secondMax2, t2, c2);\n        dfs2(1, 0, firstMax1, secondMax1, t1, c1);\n        dfs2(1, 0, firstMax2, secondMax2, t2, c2);\n        int ans = *max_element(firstMax1.begin(), firstMax1.end());\n        ans = max(ans, *max_element(firstMax2.begin(), firstMax2.end()));\n        int mn = INT_MAX;\n        for (int i = 1; i <= m; i ++) mn = min(mn, firstMax2[i]);\n        int have = INT_MAX;\n        for (int i = 1; i <= n; i ++) {\n            have = min(have, firstMax1[i] + 1 + mn);\n        }\n        ans = max(ans, have);\n        return ans;\n    }\n};",
    "submit_ts": "1719715619",
    "subm_id": "1304341641"
}