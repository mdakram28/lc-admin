{
    "username": "SR3mix",
    "submission": "typedef long long ll;\n// SEG ITERATIVE\ntemplate <typename T> class SegmentTreeIterative {\npublic:\n    T seg[800080],segBase;\n    int n,sz,lsz;\n    function<T(T, T)> compare_operation;\n    SegmentTreeIterative(function<T(T, T)> given_compare_op, T newSegBase) {\n        compare_operation = given_compare_op;\n        segBase = newSegBase;\n    }\n    void reset(int newN) {\n        n = newN;\n        assert(n * 4 <= sizeof(seg)/sizeof(seg[0]));\n        sz = 1; while (sz < n) sz *= 2;\n        lsz = __builtin_ctzll(sz);\n        for (int i= 0; i<(sz*2); i++) {seg[i] = segBase;}\n    }\n    void update(int pos, T x) {doUpdate(pos-1, x);}\n    void doUpdate(int pos0index, T x) {\n        assert(pos0index >= 0 && pos0index < n);\n        int p = pos0index + sz; seg[p] = x;\n        for (int i = 1; i <= lsz; i++) modify(p >> i);\n    }\n    T query(int l, int r) {return doQuery(l-1, r);}\n    T doQuery(int l0index, int r0index) {\n        assert(l0index >= 0 && l0index <= r0index && r0index <= n);\n        int l = l0index + sz, r = r0index + sz;\n        T lans = segBase, rans = segBase;\n        while (l < r) {\n            if (l & 1) lans = compare_operation(lans, seg[l++]);\n            if (r & 1) rans = compare_operation(seg[--r], rans);\n            l = (l >> 1); r = (r >> 1);\n        }\n        return compare_operation(lans, rans);\n    }\n    void modify(int k) {seg[k] = compare_operation(seg[2*k], seg[2*k + 1]);}\n    T trueValue(int index) {assert(index >= 1 && index <= n); return seg[index-1+sz];}\n    T true0indexValue(int index0) {assert(index0 >= 0 && index0 < n); return seg[index0 + sz];}\n};\n// CREDIT TO numb3r5 FOR THIS TEMPLATE -> https://leetcode.com/numb3r5/\n\nll cmin(ll a, ll b) {return min(a,b);}\nll cmax(ll a, ll b) {return max(a,b);}\n\nSegmentTreeIterative<ll> seg(cmin,INT_MAX);\n//SegmentTreeIterative<ll> segmax(cmax,INT_MIN);\nclass Solution {\npublic:\n    vector<ll>d;\n    vector<ll>md;\n    ll compute(ll sl, ll sr, ll ma) {\n        if (sl > sr) return 0;\n        if (sl == sr) return md[sl] - ma;\n        ll tv = seg.query(sl+1,sr+1);\n        ll l = sl+1, r = sr+1;\n        while (l < r) {\n            ll m = l + (r-l)/2;\n            ll q = seg.query(sl+1,m);\n            if (q > tv) l = m+1;\n            else r = m;\n        }\n        return tv - ma + compute(sl,l-2,tv) + compute(l,sr,tv);\n    }\n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n        int n = nums.size();\n        d = vector<ll>(n);\n        md = d;\n        seg.reset(n);\n        for (int i = 0; i < n; i++) {\n            d[i] = target[i]- nums[i];\n            md[i] = abs(d[i]);\n            seg.update(i+1,md[i]);\n        }\n        vector<array<ll, 2>>v;\n        ll la = 0;\n        for (int i = 0; i < n; i++) {\n            if (d[la] < 0 && d[i] < 0) continue;\n            if (d[la] > 0 && d[i] > 0) continue;\n            else {v.push_back({la,i-1}); la = i;}\n        }\n        v.push_back({la,n-1});\n        ll ans = 0;\n        for (auto [sl, sr] : v) {\n            ans += compute(sl, sr, 0);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1721529873",
    "subm_id": "1327915629"
}