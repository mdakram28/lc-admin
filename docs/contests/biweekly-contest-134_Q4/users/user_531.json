{
    "username": "Phoenix-101",
    "submission": "class SegmentTree {\nprivate:\n    vector<int> tree;\n    vector<int> arr;\n    int n;\n\n    void build(int node, int start, int end) {\n        if (start == end) {\n            // Leaf node will have a single element\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            // Recursively build the segment tree\n            build(2 * node + 1, start, mid);\n            build(2 * node + 2, mid + 1, end);\n            // Internal node will have the AND of the two children\n            tree[node] = tree[2 * node + 1] & tree[2 * node + 2];\n        }\n    }\n\n    void update(int node, int start, int end, int idx, int value) {\n        if (start == end) {\n            // Leaf node\n            arr[idx] = value;\n            tree[node] = value;\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid) {\n                // If idx is in the left child, recurse on the left child\n                update(2 * node + 1, start, mid, idx, value);\n            } else {\n                // If idx is in the right child, recurse on the right child\n                update(2 * node + 2, mid + 1, end, idx, value);\n            }\n            // Internal node will have the AND of the two children\n            tree[node] = tree[2 * node + 1] & tree[2 * node + 2];\n        }\n    }\n\n    int query(int node, int start, int end, int L, int R) {\n        if (R < start || end < L) {\n            // range represented by a node is completely outside the given range\n            return INT_MAX; // Identity for AND operation\n        }\n        if (L <= start && end <= R) {\n            // range represented by a node is completely inside the given range\n            return tree[node];\n        }\n        // range represented by a node is partially inside and partially outside the given range\n        int mid = (start + end) / 2;\n        int left = query(2 * node + 1, start, mid, L, R);\n        int right = query(2 * node + 2, mid + 1, end, L, R);\n        return left & right;\n    }\n\npublic:\n    SegmentTree(const vector<int>& inputArr) {\n        arr = inputArr;\n        n = arr.size();\n        int height = (int)(ceil(log2(n)));\n        int maxSize = 2 * (int)pow(2, height) - 1;\n        tree.resize(maxSize, 0);\n        build(0, 0, n - 1);\n    }\n\n    void update(int idx, int value) {\n        update(0, 0, n - 1, idx, value);\n    }\n\n    int query(int L, int R) {\n        return query(0, 0, n - 1, L, R);\n    }\n};\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        SegmentTree sg(nums);\n        int n=nums.size();\n        long long ans=0;\n        for(int i=0;i<n;i++){\n            int l=0,r=i,mid,mxLeft=i,mxRight=i-1;\n            while(l<=r){ // mxLeft\n                mid=(l+r)/2;\n                int op=sg.query(mid,i);\n                if(op<k) l=mid+1;\n                else if(op>k) r=mid-1;\n                else {\n                    mxLeft=mid;\n                    r=mid-1;\n                }\n            }\n            l=0,r=i;\n            while(l<=r){\n                mid=(l+r)/2;\n                int op=sg.query(mid,i);\n                if(op<k) l=mid+1;\n                else if(op>k) r=mid-1;\n                else {\n                    mxRight=mid;\n                    l=mid+1;\n                }\n            }\n\n            ans+=mxRight-mxLeft+1;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720278510",
    "subm_id": "1311712313"
}