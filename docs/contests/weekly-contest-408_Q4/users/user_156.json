{
    "username": "l_returns",
    "submission": "struct Circle {\n    long long x, y, r;\n    bool g1,g2;\n};\n\nstruct Point {\n    long long x, y;\n};\n\nstruct Line {\n    long long A, B, C;\n};\n\n\nbool doCirclesIntersect(const Circle& c1, const Circle& c2) {\n    long long dx = c1.x - c2.x;\n    long long dy = c1.y - c2.y;\n    long long distanceSquared = dx * dx + dy * dy;\n    long long radiusSum = c1.r + c2.r;\n    long long radiusSumSquared = radiusSum * radiusSum;\n    \n    return distanceSquared <= radiusSumSquared;\n}\n\nbool isPointInCircle(const Point& p, const Circle& c) {\n    long long dx = p.x - c.x;\n    long long dy = p.y - c.y;\n    long long distanceSquared = dx * dx + dy * dy;\n    long long radiusSquared = c.r * c.r;\n    \n    return distanceSquared <= radiusSquared;\n}\n\nbool doesCircleIntersectLine(const Circle& c, const Line& l) {\n    long long numerator = std::abs(l.A * c.x + l.B * c.y + l.C);\n    double denominator = std::sqrt(l.A * l.A + l.B * l.B);\n    double distance = numerator / denominator;\n    \n    return distance <= c.r;\n}\n\nclass DSU {\nprivate:\n    std::vector<int> parent, rank;\n\npublic:\n    DSU(int n) {\n        parent.resize(n);\n        rank.resize(n, 1);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    // Find the representative of the set containing x\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n\n    // Union of the sets containing x and y\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        Point origin(0,0), corner(X,Y);\n        Line l1(1,0,0), l2(0,1,-Y);\n        Line l3(1,0,-X), l4(0,1,0);\n        \n        vector<Circle> cir;        \n        int i = 0;\n        for(auto it:circles) {\n            bool g1=false,g2=false;\n            cir.push_back({it[0],it[1],it[2], false, false});\n            if(doesCircleIntersectLine(cir.back(),l1) || doesCircleIntersectLine(cir.back(),l2))\n                g1=true;\n            if(doesCircleIntersectLine(cir.back(),l3) || doesCircleIntersectLine(cir.back(),l4))\n                g2=true;\n            if(g1 && g2)\n                return false;\n            i++;\n            if(isPointInCircle(origin, cir.back()))\n                return false;\n            if(isPointInCircle(corner, cir.back()))\n                return false;\n            cir.back().g1 = g1;\n            cir.back().g2 = g2;\n        }\n        \n        vector<int> adj[cir.size()];\n        DSU dsu(cir.size());        \n        for(int i=0;i<cir.size();i++)\n            for(int j=i+1;j<cir.size();j++) \n                if(doCirclesIntersect(cir[i],cir[j])) {\n                    dsu.unite(i,j);\n                }\n\n\n        for(int i=0;i<cir.size();i++) {\n            if(!cir[dsu.find(i)].g1 && !cir[dsu.find(i)].g2) {\n                cir[dsu.find(i)].g1 = cir[i].g1;\n                cir[dsu.find(i)].g2 = cir[i].g2;\n            }\n            \n            if(cir[dsu.find(i)].g1 && cir[i].g2)\n                return false;\n            if(cir[dsu.find(i)].g2 && cir[i].g1)\n                return false;\n        }\n              \n        return true;    \n    }\n};",
    "submit_ts": "1722137131",
    "subm_id": "1335755066"
}