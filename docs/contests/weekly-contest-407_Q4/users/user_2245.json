{
    "username": "tamuraup",
    "submission": "impl Solution {\n    pub fn minimum_operations(nums: Vec<i32>, target: Vec<i32>) -> i64 {\n        minimum_operations(nums,target)\n    }\n}\n\npub use __cargo_equip::prelude::*;\n\nuse std::{\n    cmp::{max, min},\n    collections::BinaryHeap,\n};\n\nuse acl_dsu::Dsu;\nuse myproconlib_utils::*;\n\nfn fnc(mut a: Vec<i64>) -> i64 {\n    db!(a);\n    let mut que = BinaryHeap::new();\n    let N = a.len();\n    let mut minL = vec![!0; N];\n    let mut maxR = vec![!0; N];\n    // let mut now=vec![];\n    for i in 0..N {\n        que.push((a[i].abs(), i));\n        minL[i] = i;\n        maxR[i] = i + 1;\n    }\n    let mut uf = Dsu::new(N);\n    let mut ans = 0i64;\n    while let Some((h, u)) = que.pop() {\n        let ro = uf.leader(u);\n        if a[ro].abs() != h {\n            continue;\n        }\n        let mut ldiff = 1e18 as i64;\n        let mut rdiff = 1e18 as i64;\n        let mut lroot = !0;\n        let mut rroot = !0;\n        if minL[ro] > 0 {\n            let li = minL[ro] - 1;\n            lroot = uf.leader(li);\n            ldiff = (a[lroot] - a[ro]).abs();\n            // lv = a[lroot];\n        }\n        if maxR[ro] < N {\n            let ri = maxR[ro];\n            rroot = uf.leader(ri);\n            rdiff = (a[rroot] - a[ro]).abs();\n            // rv = a[rroot];\n        }\n        if rroot == !0 && lroot == !0 {\n            ans += a[ro];\n            a[ro] = 0;\n        } else if lroot != !0 && ldiff < rdiff {\n            db!(ldiff, rdiff);\n            ans += (a[ro] - a[lroot]).abs();\n            uf.merge(lroot, ro);\n            let new_r = uf.leader(ro);\n            minL[new_r] = min(minL[ro], minL[lroot]);\n            maxR[new_r] = max(maxR[ro], maxR[lroot]);\n            a[new_r] = a[lroot];\n            que.push((a[new_r].abs(), new_r));\n        } else {\n            db!(lroot, rroot);\n            ans += (a[ro] - a[rroot]).abs();\n            uf.merge(rroot, ro);\n            let new_r = uf.leader(ro);\n            minL[new_r] = min(minL[ro], minL[rroot]);\n            maxR[new_r] = max(maxR[ro], maxR[rroot]);\n            a[new_r] = a[rroot];\n            que.push((a[new_r].abs(), new_r));\n        }\n    }\n    ans\n}\n\npub fn minimum_operations(nums: Vec<i32>, target: Vec<i32>) -> i64 {\n    let mut a = (0..nums.len())\n        .map(|i| (nums[i] - target[i]) as i64)\n        .collect::<Vec<_>>();\n    let N = a.len();\n    let mut a1 = vec![0; a.len()];\n    let mut a2 = vec![0; a.len()];\n    for i in 0..N {\n        if a[i] < 0 {\n            a1[i] = a[i].abs();\n        } else {\n            a2[i] = a[i].abs();\n        }\n    }\n    let res1 = fnc(a1);\n    let res2 = fnc(a2);\n    db!(res1, res2);\n\n    res1 + res2\n}\n\nfn _main() {\n    let nums = vec![3, 5, 1, 2];\n    let target = vec![4, 6, 2, 4];\n    let nums = vec![1, 3, 2];\n    let target = vec![2, 1, 4];\n    let res = minimum_operations(nums, target);\n}\n\n\n#[cfg_attr(any(), rustfmt::skip)]\n#[allow(unused)]\nmod __cargo_equip {\n    pub(crate) mod crates {\n        pub mod acl_dsu {pub use self::dsu::*;mod dsu{pub struct Dsu{n:usize,parent_or_size:Vec<i32>,}impl Dsu{pub fn new(size:usize)->Self{Self{n:size,parent_or_size:vec![-1;size],}}pub fn merge(&mut self,a:usize,b:usize)->usize{assert!(a<self.n);assert!(b<self.n);let(mut x,mut y)=(self.leader(a),self.leader(b));if x==y{return x;}if-self.parent_or_size[x]< -self.parent_or_size[y]{std::mem::swap(&mut x,&mut y);}self.parent_or_size[x]+=self.parent_or_size[y];self.parent_or_size[y]=x as i32;x}pub fn same(&mut self,a:usize,b:usize)->bool{assert!(a<self.n);assert!(b<self.n);self.leader(a)==self.leader(b)}pub fn leader(&mut self,a:usize)->usize{assert!(a<self.n);if self.parent_or_size[a]<0{return a;}self.parent_or_size[a]=self.leader(self.parent_or_size[a]as usize)as i32;self.parent_or_size[a]as usize}pub fn size(&mut self,a:usize)->usize{assert!(a<self.n);let x=self.leader(a);-self.parent_or_size[x]as usize}pub fn groups(&mut self)->Vec<Vec<usize>>{let mut leader_buf=vec![0;self.n];let mut group_size=vec![0;self.n];for i in 0..self.n{leader_buf[i]=self.leader(i);group_size[leader_buf[i]]+=1;}let mut result=vec![Vec::new();self.n];for i in 0..self.n{result[i].reserve(group_size[i]);}for i in 0..self.n{result[leader_buf[i]].push(i);}result.into_iter().filter(|x|!x.is_empty()).collect::<Vec<Vec<usize>>>()}}}}\n        pub mod myproconlib_utils {pub use crate::__cargo_equip::macros::myproconlib_utils::*;use std::ops::{Add,Rem};#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_mat{($($e:expr),*)=>{Vec::from(vec![$($e),*])};($($e:expr,)*)=>{Vec::from(vec![$($e),*])};($e:expr;$d:expr)=>{Vec::from(vec![$e;$d])};($e:expr;$d:expr$(;$ds:expr)+)=>{Vec::from(vec![mat![$e$(;$ds)*];$d])};}macro_rules!mat{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_mat!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_ec{($($num:expr),*)=>{let mut tmp=vec![];$(tmp.push(format!(\"{}\",$num));)*print!(\"{}\n\",tmp.join(\" \"));};}macro_rules!ec{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_ec!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_YesNo{($num:expr)=>{if($num)as i64==0{println!(\"No\");}else{println!(\"Yes\");}};}macro_rules!YesNo{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_YesNo!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_Yes{()=>{println!(\"Yes\");};}macro_rules!Yes{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_Yes!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_No{()=>{println!(\"No\");};}macro_rules!No{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_No!{$($tt)*})}pub trait SetMinMax{fn setmin(&mut self,v:Self)->bool;fn setmax(&mut self,v:Self)->bool;}impl<T>SetMinMax for T where T:PartialOrd,{fn setmin(&mut self,v:T)->bool{*self>v&&{*self=v;true}}fn setmax(&mut self,v:T)->bool{*self<v&&{*self=v;true}}}#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_chmax{($lhs:expr,$rhs:expr)=>{if$lhs<$rhs{let tmp=$rhs;$lhs=tmp;true}else{false}};}macro_rules!chmax{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_chmax!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_chmin{($lhs:expr,$rhs:expr)=>{if$lhs>$rhs{let tmp=$rhs;$lhs=tmp;true}else{false}};}macro_rules!chmin{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_chmin!{$($tt)*})}pub fn print_vec<T>(v:&[T])where T:std::fmt::Display,{for i in 0..v.len(){print!(\"{}{}\",v[i],if i+1==v.len(){\"\"}else{\" \"});}println!();}pub fn pmod<T:Copy+Add<Output=T>+Rem<Output=T>>(x:T,m:T)->T{((x%m)+m)%m}pub fn lower_bound<T>(a:&[T],x:&T)->usize where T:Ord,{if a.len()==0||a[0]>=*x{return 0;}let mut l=0;let mut r=a.len();while l+1<r{let m=(l+r)/2;if a[m]<*x{l=m;}else{r=m;}}r}pub fn upper_bound<T>(a:&[T],x:&T)->usize where T:Ord,{if a.len()==0||a[0]>*x{return 0;}let mut l=0;let mut r=a.len();while l+1<r{let m=(l+r)/2;if a[m]<=*x{l=m;}else{r=m;}}r}#[allow(unused_macros)]#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_db{($($a:expr),*$(,)*)=>{#[cfg(debug_assertions)]eprintln!(concat!($(\"| \",stringify!($a),\"={:?} \"),*),$(&$a),*);};}macro_rules!db{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_db!{$($tt)*})}#[allow(unused_macros)]#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_db2d{($vec:expr)=>{#[cfg(debug_assertions)]{eprintln!(\"> {}=\",stringify!($vec));for a in$vec.iter(){eprintln!(\"> {:?}\",a);}}};}macro_rules!db2d{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_db2d!{$($tt)*})}#[derive(PartialEq,PartialOrd,Clone,Copy)]pub struct OrdF<T>(pub T);impl<T:PartialEq>Eq for OrdF<T>{}impl<T:PartialOrd>Ord for OrdF<T>{fn cmp(&self,other:&OrdF<T>)->std::cmp::Ordering{self.0.partial_cmp(&other.0).unwrap()}}}\n    }\n\n    pub(crate) mod macros {\n        pub mod acl_dsu {}\n        pub mod myproconlib_utils {pub use crate::{__cargo_equip_macro_def_myproconlib_utils_No as No,__cargo_equip_macro_def_myproconlib_utils_Yes as Yes,__cargo_equip_macro_def_myproconlib_utils_YesNo as YesNo,__cargo_equip_macro_def_myproconlib_utils_chmax as chmax,__cargo_equip_macro_def_myproconlib_utils_chmin as chmin,__cargo_equip_macro_def_myproconlib_utils_db as db,__cargo_equip_macro_def_myproconlib_utils_db2d as db2d,__cargo_equip_macro_def_myproconlib_utils_ec as ec,__cargo_equip_macro_def_myproconlib_utils_mat as mat};}\n    }\n\n    pub(crate) mod prelude {pub use crate::__cargo_equip::crates::*;}\n\n    mod preludes {\n        pub mod acl_dsu {}\n        pub mod myproconlib_utils {}\n    }\n}\n",
    "submit_ts": "1721533548",
    "subm_id": "1328011428"
}