{
    "username": "Abeed_shaik",
    "submission": "#define ll long long\n#define pll pair<ll, ll>\n#define pii pair<int,int>\n#define vt vector\n#define pb push_back\n#define ar array\n#define str string\n\n#define F_OR(i, a, b, s) for (int i = (a); (s) > 0 ? i < (b) : i > (b); i += (s))\n#define F_OR1(e) F_OR(i, 0, e, 1)\n#define F_OR2(i, e) F_OR(i, 0, e, 1)\n#define F_OR3(i, b, e) F_OR(i, b, e, 1)\n#define F_OR4(i, b, e, s) F_OR(i, b, e, s)\n#define GET5(a, b, c, d, e, ...) e\n#define F_ORC(...) GET5(__VA_ARGS__, F_OR4, F_OR3, F_OR2, F_OR1)\n#define rep(...) F_ORC(__VA_ARGS__)(__VA_ARGS__)\n\n#define each(x, a) for (auto &x : a)\n#define all(a) a.begin(), a.end()\n#define r_each(x, a) for (auto &x : a | views::reverse)\n#define len(a) (int)a.size()\ntemplate<class T>\nstruct graph{\n\tstruct E{\n\t\tint from, to;\n\t\tT cost;\n\t};\n\tint n;\n\tvector<E> edge;\n\tvector<vector<int>> adj;\n\tfunction<bool(int)> ignore;\n\tgraph(int n = 1): n(n), adj(n){\n\t\tassert(n >= 1);\n\t}\n\tgraph(const vector<vector<int>> &adj, bool undirected = true): n((int)adj.size()), adj(n){\n\t\tassert(n >= 1);\n\t\tif(undirected){\n\t\t\tfor(auto u = 0; u < n; ++ u) for(auto v: adj[u]) if(u < v) link(u, v);\n\t\t}\n\t\telse for(auto u = 0; u < n; ++ u) for(auto v: adj[u]) orient(u, v);\n\t}\n\tgraph(const vector<vector<pair<int, T>>> &adj, bool undirected = true): n((int)adj.size()), adj(n){\n\t\tassert(n >= 1);\n\t\tif(undirected){\n\t\t\tfor(auto u = 0; u < n; ++ u) for(auto [v, w]: adj[u]) if(u < v) link(u, v, w);\n\t\t}\n\t\telse for(auto u = 0; u < n; ++ u) for(auto [v, w]: adj[u]) orient(u, v, w);\n\t}\n\tgraph(int n, vector<array<int, 2>> &edge, bool undirected = true): n(n), adj(n){\n\t\tassert(n >= 1);\n\t\tfor(auto [u, v]: edge) undirected ? link(u, v) : orient(u, v);\n\t}\n\tgraph(int n, vector<tuple<int, int, T>> &edge, bool undirected = true): n(n), adj(n){\n\t\tassert(n >= 1);\n\t\tfor(auto [u, v, w]: edge) undirected ? link(u, v, w) : orient(u, v, w);\n\t}\n\tint operator()(int u, int id) const{\n\t\t#ifdef LOCAL\n\t\tassert(0 <= id && id < (int)edge.size());\n\t\tassert(edge[id].from == u || edge[id].to == u);\n\t\t#endif\n\t\treturn u ^ edge[id].from ^ edge[id].to;\n\t}\n\tint link(int u, int v, T w = {}){ // insert an undirected edge\n\t\tint id = (int)edge.size();\n\t\tadj[u].push_back(id), adj[v].push_back(id), edge.push_back({u, v, w});\n\t\treturn id;\n\t}\n\tint orient(int u, int v, T w = {}){ // insert a directed edge\n\t\tint id = (int)edge.size();\n\t\tadj[u].push_back(id), edge.push_back({u, v, w});\n\t\treturn id;\n\t}\n\tgraph transposed() const{ // the transpose of the directed graph\n\t\tgraph res(n);\n\t\tfor(auto &e: edge) res.orient(e.to, e.from, e.cost);\n\t\tres.ignore = ignore;\n\t\treturn res;\n\t}\n\tint degree(int u) const{ // the degree (outdegree if directed) of u (without the ignoration rule)\n\t\treturn (int)adj[u].size();\n\t}\n\t// The adjacency list is sorted for each vertex.\n\tvector<vector<int>> get_adjacency_list() const{\n\t\tvector<vector<int>> res(n);\n\t\tfor(auto u = 0; u < n; ++ u) for(auto id: adj[u]){\n\t\t\tif(ignore && ignore(id)) continue;\n\t\t\tres[(*this)(u, id)].push_back(u);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid set_ignoration_rule(const function<bool(int)> &f){\n\t\tignore = f;\n\t}\n\tvoid reset_ignoration_rule(){\n\t\tignore = nullptr;\n\t}\n\tfriend ostream &operator<<(ostream &out, const graph &g){\n\t\tfor(auto id = 0; id < (int)g.edge.size(); ++ id){\n\t\t\tif(g.ignore && g.ignore(id)) continue;\n\t\t\tauto &e = g.edge[id];\n\t\t\tout << \"{\" << e.from << \", \" << e.to << \", \" << e.cost << \"}\\n\";\n\t\t}\n\t\treturn out;\n\t}\n};\n\ntemplate<class T>\nstruct dfs_forest{\n\tint n;\n\tvector<T> dist;\n\tvector<int> pv;\n\tvector<int> pe;\n\tvector<int> order;\n\tvector<int> pos;\n\tvector<int> end;\n\tvector<int> size;\n\tvector<int> root;\n\tvector<int> depth;\n\tvector<int> min_depth;\n\tvector<int> min_depth_origin;\n\tvector<int> min_depth_spanning_edge;\n\tvector<int> was;\n\tT T_id;\n\tdfs_forest(int n, T T_id = 0): T_id(T_id){ init(n); }\n\tvoid init(int n){\n\t\tthis->n = n;\n\t\tpv.assign(n, -1);\n\t\tpe.assign(n, -1);\n\t\torder.clear();\n\t\tpos.assign(n, -1);\n\t\tend.assign(n, -1);\n\t\tsize.assign(n, 0);\n\t\troot.assign(n, -1);\n\t\tdepth.assign(n, -1);\n\t\tmin_depth.assign(n, -1);\n\t\tmin_depth_origin.assign(n, -1);\n\t\tmin_depth_spanning_edge.assign(n, -1);\n\t\tdist.assign(n, T_id);\n\t\twas.assign(n, -1);\n\t\tattempt = 0;\n\t}\n\tint attempt;\n\t// O(n + m)\n\t// Requires graph\n\ttemplate<class Graph, class F = plus<>>\n\tvoid dfs(const Graph &g, int u, bool clear_order = true, F UT = plus<>()){\n\t\tassert(n == g.n);\n\t\t++ attempt;\n\t\tdepth[u] = 0;\n\t\tdist[u] = T_id;\n\t\troot[u] = u;\n\t\tpv[u] = pe[u] = -1;\n\t\tif(clear_order) order.clear();\n\t\tauto recurse = [&](auto self, int u)->void{\n\t\t\twas[u] = attempt;\n\t\t\tpos[u] = (int)order.size();\n\t\t\torder.push_back(u);\n\t\t\tsize[u] = 1;\n\t\t\tmin_depth[u] = depth[u];\n\t\t\tmin_depth_origin[u] = u;\n\t\t\tmin_depth_spanning_edge[u] = -1;\n\t\t\tfor(auto id: g.adj[u]){\n\t\t\t\tif(id == pe[u] || g.ignore && g.ignore(id)) continue;\n\t\t\t\tauto &e = g.edge[id];\n\t\t\t\tint v = e.from ^ e.to ^ u;\n\t\t\t\tif(was[v] == attempt){\n\t\t\t\t\tif(min_depth[u] > depth[v]){\n\t\t\t\t\t\tmin_depth[u] = depth[v];\n\t\t\t\t\t\tmin_depth_spanning_edge[u] = id;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdepth[v] = depth[u] + 1;\n\t\t\t\tdist[v] = UT(e.cost, dist[u]);\n\t\t\t\tpv[v] = u;\n\t\t\t\tpe[v] = id;\n\t\t\t\troot[v] = root[u];\n\t\t\t\tself(self, v);\n\t\t\t\tsize[u] += size[v];\n\t\t\t\tif(min_depth[u] > min_depth[v]){\n\t\t\t\t\tmin_depth[u] = min_depth[v];\n\t\t\t\t\tmin_depth_origin[u] = min_depth_origin[v];\n\t\t\t\t\tmin_depth_spanning_edge[u] = min_depth_spanning_edge[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tend[u] = (int)order.size();\n\t\t};\n\t\trecurse(recurse, u);\n\t}\n\t// O(n + m)\n\ttemplate<class Graph, class F = plus<>>\n\tvoid dfs_all(const Graph &g, F UT = plus<>()){\n\t\tfor(auto u = 0; u < n; ++ u) if(!~depth[u]) dfs<Graph, F>(g, u, false, UT);\n\t}\n\t// O(n + m)\n\ttemplate<class F = plus<>>\n\tvoid dfs_implicitly(auto get_deg, auto get_adj, int u, bool clear_order = true, F UT = plus<>()){\n\t\t++ attempt;\n\t\tdepth[u] = 0;\n\t\tdist[u] = T_id;\n\t\troot[u] = u;\n\t\tpv[u] = pe[u] = -1;\n\t\tif(clear_order) order.clear();\n\t\tauto recurse = [&](auto self, int u)->void{\n\t\t\twas[u] = attempt;\n\t\t\tpos[u] = (int)order.size();\n\t\t\torder.push_back(u);\n\t\t\tsize[u] = 1;\n\t\t\tmin_depth[u] = depth[u];\n\t\t\tmin_depth_origin[u] = u;\n\t\t\tmin_depth_spanning_edge[u] = -1;\n\t\t\tfor(auto i = 0, deg = get_deg(u); i < deg; ++ i){\n\t\t\t\tauto [v, w] = get_adj(u, i);\n\t\t\t\tif(!~v) continue;\n\t\t\t\tif(was[v] == attempt){\n\t\t\t\t\tif(min_depth[u] > depth[v]){\n\t\t\t\t\t\tmin_depth[u] = depth[v];\n\t\t\t\t\t\tmin_depth_spanning_edge[u] = i;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdepth[v] = depth[u] + 1;\n\t\t\t\tdist[v] = UT(w, dist[u]);\n\t\t\t\tpv[v] = u;\n\t\t\t\tpe[v] = i;\n\t\t\t\troot[v] = root[u];\n\t\t\t\tself(self, v);\n\t\t\t\tsize[u] += size[v];\n\t\t\t\tif(min_depth[u] > min_depth[v]){\n\t\t\t\t\tmin_depth[u] = min_depth[v];\n\t\t\t\t\tmin_depth_origin[u] = min_depth_origin[v];\n\t\t\t\t\tmin_depth_spanning_edge[u] = min_depth_spanning_edge[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tend[u] = (int)order.size();\n\t\t};\n\t\trecurse(recurse, u);\n\t}\n\t// O(n + m)\n\ttemplate<class F = plus<>>\n\tvoid dfs_all_implicitly(auto get_deg, auto get_adj, F UT = plus<>()){\n\t\tfor(auto u = 0; u < n; ++ u) if(!~depth[u]) dfs<F>(get_deg, get_adj, u, false, UT);\n\t}\n\tbool ancestor_of(int u, int v) const{\n\t\treturn pos[u] <= pos[v] && end[v] <= end[u];\n\t}\n};\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1, m = edges2.size() + 1;\n        graph<int> g1(n), g2(m);\n    rep(n - 1){\n        int u = edges1[i][0], v = edges1[i][1];\n        g1.link(u, v, 1);\n    }\n\n    rep(m - 1){\n         int u = edges2[i][0], v = edges2[i][1];\n        g2.link(u, v, 1);\n    }\n\n    dfs_forest<int> DFS1(n), DFS2(m);\n    DFS1.dfs(g1, 0);\n    auto dist1 = DFS1.dist;\n    int root = max_element(all(dist1)) - dist1.begin();\n    DFS1.dfs(g1, root);\n    auto dist2 = DFS1.dist;\n    int dia1 = *max_element(all(dist2));\n\n    DFS2.dfs(g2, 0);\n    auto dist3 = DFS2.dist;\n    int root_ = max_element(all(dist3)) - dist3.begin();\n    DFS2.dfs(g2, root_);\n    auto dist4 = DFS2.dist;\n    int dia2 = *max_element(all(dist4));\n        int ret = max(dia1, dia2);\n    return max(ret, (dia1 + 1) / 2 + (dia2 + 1) / 2 + 1);\n    }\n};",
    "submit_ts": 1719715868.0
}