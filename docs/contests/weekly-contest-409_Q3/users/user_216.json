{
    "username": "mkawa222",
    "submission": "# Thanks for tatyam\n# https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py\nimport math\nfrom bisect import bisect_left, bisect_right\nfrom typing import Generic, Iterable, Iterator, TypeVar, Optional, List\n\nT = TypeVar('T')\n\nclass SortedSet(Generic[T]):\n    BUCKET_RATIO = 50\n    REBUILD_RATIO = 170\n\n    def _build(self, a=None) -> None:\n        \"Evenly divide `a` into buckets.\"\n        if a is None: a = list(self)\n        size = self.size = len(a)\n        bucket_size = int(math.ceil(math.sqrt(size/self.BUCKET_RATIO)))\n        self.a = [a[size*i//bucket_size: size*(i+1)//bucket_size] for i in range(bucket_size)]\n\n    def __init__(self, a: Iterable[T] = []) -> None:\n        \"Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)\"\n        a = list(a)\n        if not all(a[i] < a[i+1] for i in range(len(a)-1)):\n            a = sorted(set(a))\n        self._build(a)\n\n    def __iter__(self) -> Iterator[T]:\n        for i in self.a:\n            for j in i: yield j\n\n    def __reversed__(self) -> Iterator[T]:\n        for i in reversed(self.a):\n            for j in reversed(i): yield j\n\n    def __len__(self) -> int:\n        return self.size\n\n    def __repr__(self) -> str:\n        return \"SortedSet\"+str(self.a)\n\n    def __str__(self) -> str:\n        s = str(list(self))\n        return \"{\"+s[1: len(s)-1]+\"}\"\n\n    def _find_bucket(self, x: T) -> List[T]:\n        \"Find the bucket which should contain x. self must not be empty.\"\n        for a in self.a:\n            if x <= a[-1]: return a\n        return a\n\n    def __contains__(self, x: T) -> bool:\n        if self.size == 0: return False\n        a = self._find_bucket(x)\n        i = bisect_left(a, x)\n        return i != len(a) and a[i] == x\n\n    def add(self, x: T) -> bool:\n        \"Add an element and return True if added. / O(\u221aN)\"\n        if self.size == 0:\n            self.a = [[x]]\n            self.size = 1\n            return True\n        a = self._find_bucket(x)\n        i = bisect_left(a, x)\n        if i != len(a) and a[i] == x: return False\n        a.insert(i, x)\n        self.size += 1\n        if len(a) > len(self.a)*self.REBUILD_RATIO:\n            self._build()\n        return True\n\n    def discard(self, x: T) -> bool:\n        \"Remove an element and return True if removed. / O(\u221aN)\"\n        if self.size == 0: return False\n        a = self._find_bucket(x)\n        i = bisect_left(a, x)\n        if i == len(a) or a[i] != x: return False\n        a.pop(i)\n        self.size -= 1\n        if len(a) == 0: self._build()\n        return True\n\n    def lt(self, x: T) -> Optional[T]:\n        \"Find the largest element < x, or None if it doesn't exist.\"\n        for a in reversed(self.a):\n            if a[0] < x:\n                return a[bisect_left(a, x)-1]\n\n    def le(self, x: T) -> Optional[T]:\n        \"Find the largest element <= x, or None if it doesn't exist.\"\n        for a in reversed(self.a):\n            if a[0] <= x:\n                return a[bisect_right(a, x)-1]\n\n    def gt(self, x: T) -> Optional[T]:\n        \"Find the smallest element > x, or None if it doesn't exist.\"\n        for a in self.a:\n            if a[-1] > x:\n                return a[bisect_right(a, x)]\n\n    def ge(self, x: T) -> Optional[T]:\n        \"Find the smallest element >= x, or None if it doesn't exist.\"\n        for a in self.a:\n            if a[-1] >= x:\n                return a[bisect_left(a, x)]\n\n    def __getitem__(self, x: int) -> T:\n        \"Return the x-th element, or IndexError if it doesn't exist.\"\n        if x < 0: x += self.size\n        if x < 0: raise IndexError\n        for a in self.a:\n            if x < len(a): return a[x]\n            x -= len(a)\n        raise IndexError\n\n    def index(self, x: T) -> int:\n        \"Count the number of elements < x.\"\n        ans = 0\n        for a in self.a:\n            if a[-1] >= x:\n                return ans+bisect_left(a, x)\n            ans += len(a)\n        return ans\n\n    def index_right(self, x: T) -> int:\n        \"Count the number of elements <= x.\"\n        ans = 0\n        for a in self.a:\n            if a[-1] > x:\n                return ans+bisect_right(a, x)\n            ans += len(a)\n        return ans\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        uu = SortedSet()\n        ans = []\n        s = n-1\n        u2v = [-1]*n\n        for u, v in queries:\n            i = uu.index_right(u)\n            if i:\n                l = uu[i-1]\n                r = u2v[l]\n                if v <= r:\n                    ans.append(s)\n                    continue\n                if l==u:\n                    uu.discard(l)\n                    s += r-l-1\n                    i-=1\n            while i < len(uu):\n                l = uu[i]\n                if l>=v:break\n                r = u2v[l]\n                uu.discard(l)\n                s += r-l-1\n            uu.add(u)\n            s -= v-u-1\n            ans.append(s)\n            u2v[u]=v\n        return ans\n",
    "submit_ts": "1722740745",
    "subm_id": "1343727694"
}