{
    "username": "kashyap_lokesh",
    "submission": "void construct_segment_tree(vector<int>& segtree,\n                            vector<int>& a, int n)\n{\n    // assign values to leaves of the segment tree\n    for (int i = 0; i < n; i++)\n        segtree[n + i] = a[i];\n \n    /* assign values to internal nodes\n    to compute maximum in a given range */\n    for (int i = n - 1; i >= 1; i--)\n        segtree[i] = max(segtree[2 * i],\n                         segtree[2 * i + 1]);\n}\n \nvoid update(vector<int>& segtree, int pos, int value,\n            int n)\n{\n    // change the index to leaf node first\n    pos += n;\n \n    // update the value at the leaf node\n    // at the exact index\n    segtree[pos] = value;\n \n    while (pos > 1) {\n \n        // move up one level at a time in the tree\n        pos >>= 1;\n \n        // update the values in the nodes in\n        // the next higher level\n        segtree[pos] = segtree[2 * pos]&segtree[2 * pos + 1];\n    }\n}\n \nint range_query(vector<int>& segtree, int left, int\n                                                    right,\n                int n)\n{\n    /* Basically the left and right indices will move\n        towards right and left respectively and with\n        every each next higher level and compute the \n        maximum at each height. */\n    // change the index to leaf node first\n    left += n;\n    right += n;\n \n    // initialize maximum to a very low value\n    int ma = INT_MIN;\n \n    while (left < right) {\n \n        // if left index in odd\n        if (left & 1) {\n            ma = max(ma, segtree[left]);\n \n            // make left index even\n            left++;\n        }\n \n        // if right index in odd\n        if (right & 1) {\n \n            // make right index even\n            right--;\n \n            ma = max(ma, segtree[right]);\n        }\n \n        // move to the next higher level\n        left /= 2;\n        right /= 2;\n    }\n    return ma;\n}\n\n#define ll long long\nclass SegmentTree\n{\npublic:\n    vector<ll> segTree;\n    ll size = 0;\n    ll ID = (1LL << 32) - 1;\n\n    SegmentTree(ll sz)\n    {\n        segTree.assign(2 * sz, 0);\n        size = sz;\n    }\n\n    ll join(ll a, ll b)\n    {\n        return a & b;\n    }\n\n    void update(ll idx, ll val)\n    {\n        segTree[idx += size] = val;\n        for (idx >>= 1; idx; idx >>= 1)\n            segTree[idx] = join(segTree[idx << 1], segTree[idx << 1 | 1]);\n    }\n\n    ll query(ll l, ll r)\n    {\n        ll leftAns = ID, RightAns = ID;\n        for (l += size, r += size + 1; l < r; l >>= 1, r >>= 1)\n        {\n            if (l & 1)\n                leftAns = join(leftAns, segTree[l++]);\n            if (r & 1)\n                RightAns = join(segTree[--r], RightAns);\n        }\n        return join(leftAns, RightAns);\n    }\n};\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& a, int k) {\n        long long n = a.size();\n        SegmentTree segtree(n);\n        for (int i = 0; i < n; i++)\n            segtree.update(i,a[i]);\n        \n        long long solution = 0;\n        for (int i = 0; i < n; i++)\n        {\n            long long lower_bnd = -1, upper_bnd = -1,left=i,right=n-1;\n            \n            while (left <= right)\n            {\n                long long mid = (left + right) >> 1;\n                if(segtree.query(i,mid) > k)\n                {\n                    left = mid + 1;\n                }\n                else if(segtree.query(i,mid) == k)\n                {\n                    lower_bnd = mid;\n                    right = mid - 1;\n                }\n                else\n                {\n                    right = mid - 1;\n                }\n            }\n            left = i, right = n - 1;\n            while (left <= right)\n            {\n                long long mid = (left + right) >> 1;\n                if(segtree.query(i,mid) > k)\n                {\n                    left = mid + 1;\n                }\n                else if(segtree.query(i,mid) == k)\n                {\n                    upper_bnd = mid;\n                    left = mid + 1;\n                }\n                else\n                {\n                    right = mid - 1;\n                }\n            }\n            if(lower_bnd != -1)\n                solution += (upper_bnd - lower_bnd + 1);\n        }\n        return solution;\n    }\n};",
    "submit_ts": "1720281172",
    "subm_id": "1311815677"
}