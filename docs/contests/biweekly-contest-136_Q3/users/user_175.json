{
    "username": "plyusnovdmitrii",
    "submission": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <unordered_set>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <fstream>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bitset>\n#include <sstream>\n#include <ext/rope>\n#include <ctime>\n#include <random>\n#include <cstdlib>\n#include <complex>\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\n/* clang-format off */\n\n/* TYPES  */\n#define ll long long\n#define ld long double\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vi vector<int>\n#define vll vector<long long>\n#define vpii vector<pair<int, int>>\n#define vpii vector<pair<int, int>>\n#define vvpii vector<vector<pair<int, int>>>\n#define vpll vector<pair<long long, long long>>\n#define vvpll vector<vector<pair<long long, long long>>>\n#define vvi vector<vector<int>>\n#define vvll vector<vector<long long>>\n#define mii map<int, int>\n#define si set<int>\n#define sc set<char>\n#define vd vector<double>\n#define vvd vector<vector<double>>\n\n\n/* FUNCTIONS */\n#define feach(el, v) for(auto &el: v)\n#define rep(i, n) for(int i=0;i<n;i++)\n#define reprv(i, n) for(int i=n-1;i>=0;i--)\n#define reps(i, s, e) for(int i=s;i<e;i++)\n#define reprve(i, e, s) for(int i=e-1;i>=s;i--)\n#define repe(x, y) for (auto &x: y)\n#define repe2(x, a, y) for (auto &[x,a]: y)\n\n#define pb push_back\n#define eb emplace_back\n\n\nconst ll mod = 1000000007;\n\ntemplate<ll mod = 1000000007>\nstruct ModInt {\n    ll p;\n\n    ModInt() : p(0) {}\n\n    ModInt(ll x) { p = x >= 0 ? x % mod : x + (-x + mod - 1) / mod * mod; }\n\n    ModInt &operator+=(const ModInt &y) {\n        p = p + *y - ((p + *y) >= mod ? mod : 0);\n        return *this;\n    }\n\n    ModInt &operator-=(const ModInt &y) {\n        p = p - *y + (p - *y < 0 ? mod : 0);\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &y) {\n        p = (p * *y) % mod;\n        return *this;\n    }\n\n    ModInt &operator%=(const ModInt &y) {\n        if (y)p %= *y;\n        return *this;\n    }\n\n    ModInt operator+(const ModInt &y) const {\n        ModInt x = *this;\n        return x += y;\n    }\n\n    ModInt operator-(const ModInt &y) const {\n        ModInt x = *this;\n        return x -= y;\n    }\n\n    ModInt operator*(const ModInt &y) const {\n        ModInt x = *this;\n        return x *= y;\n    }\n\n    ModInt operator%(const ModInt &y) const {\n        ModInt x = *this;\n        return x %= y;\n    }\n\n    ModInt binpow(ll pow) const {\n        pow %= mod - 1;\n        ModInt res = 1, a = *this;\n        while (pow) {\n            if (pow & 1) res *= a;\n            a *= a, pow >>= 1;\n        }\n        return res;\n    }\n\n    ModInt binpow1(const ModInt &y, ll pow) const {\n        pow %= mod - 1;\n        ModInt res = 1, a = y;\n        while (pow) {\n            if (pow & 1) res *= a;\n            a *= a, pow >>= 1;\n        }\n        return res;\n    }\n\n    ModInt inv() const { return binpow1(*this, mod - 2); }\n\n    ModInt &operator/=(const ModInt &y) {\n        p = (p * y.inv().p) % mod;\n        return *this;\n    }\n\n    ModInt operator/(const ModInt &y) const {\n        ModInt x = *this;\n        return x /= y;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int v;\n        is >> v;\n        a = ModInt(v);\n        return is;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &a) { return os << a.p; }\n\n    ModInt &operator++() {\n        p = (p + 1) % mod;\n        return *this;\n    }\n\n    ModInt &operator--() {\n        p = (p - 1 + mod) % mod;\n        return *this;\n    }\n\n    bool operator==(const ModInt &y) const { return p == *y; }\n\n    bool operator!=(const ModInt &y) const { return p != *y; }\n\n    const ll &operator*() const { return p; }\n\n    ll &operator*() { return p; }\n\n};\n\nusing Mint = ModInt<>;\n#define vmint vector<Mint>\n#define vvmint vector<vector<Mint>>\ntypedef tree<ll, null_type, less_equal<>, rb_tree_tag, tree_order_statistics_node_update> oSet;\n#define IO ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#pragma GCC target(\"popcnt\")\n#define vct vector\n\nint cntLeq(vll &v, ll x) { return std::upper_bound(v.begin(), v.end(), x) - v.begin(); }\nint cntLess(vll &v, ll x) { return std::lower_bound(v.begin(), v.end(), x) - v.begin(); }\nint cntGreater(vll &v, ll x) { return v.end() - std::upper_bound(v.begin(), v.end(), x); }\nint cntGeq(vll &v, ll x) { return v.end() - std::lower_bound(v.begin(), v.end(), x); }\n\nvll buildPref(vll &v) {\n    int n = v.size(); vll pref(n);\n    rep(i, n) pref[i] = v[i] + (i ? pref[i - 1] : 0);\n    return pref;\n}\nll getPrefSum(vll &pref, int l, int r) { return pref[r] - (l ? pref[l - 1] : 0); }\n\nvi dx = {0,0,-1,1}, dy = {-1,1,0,0};\n\nint popcnt(int i) { return __builtin_popcountll(i); }\nint popcnt(long long i) { return __builtin_popcountll(i); }\n\n//////////////////////////////////////////////////////////////////////////\n\n\nclass Solution {\npublic:\n    int minFlips(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        int first = n / 2 + n % 2, sec = m / 2 + m % 2;\n\n        int cost[first][sec][2], contr[first][sec];\n        rep(i, first) rep(j, sec) rep(k, 2) cost[i][j][k] = contr[i][j] = 0;\n\n        rep(i, first) rep(j, sec) rep(k, 2) {\n            set<pii> allEls;\n                    allEls.insert({i, j}), allEls.insert({n-1-i,j}), allEls.insert({i,m-1-j}),allEls.insert({n-1-i,m-1-j});\n            contr[i][j] = allEls.size();\n\n            for (auto &[x,y]: allEls) if(grid[x][y] != k) ++cost[i][j][k];\n        }\n        int dp[first][sec][4];\n        rep(i, first) rep(j, sec) rep(k, 4) dp[i][j][k] = 1e9;\n\n        dp[0][0][0] = cost[0][0][0], dp[0][0][contr[0][0] % 4] = min(dp[0][0][contr[0][0] % 4], cost[0][0][1]);\n        rep(i, first) rep(j, sec) {\n            if (i == first - 1 && j == sec - 1) break;\n\n            pii next = {i, j + 1};\n            if (next.second >= sec) next.first++, next.second = 0;\n\n            rep(k, 4) {\n                if (dp[i][j][k] == 1e9) continue;\n                dp[next.first][next.second][k] = min(dp[next.first][next.second][k], dp[i][j][k] + cost[next.first][next.second][0]);\n                dp[next.first][next.second][(k + contr[next.first][next.second]) % 4] = min(\n                        dp[next.first][next.second][(k + contr[next.first][next.second]) % 4], dp[i][j][k] + cost[next.first][next.second][1]);\n            }\n        }\n        return dp[first-1][sec-1][0];\n    }\n};",
    "submit_ts": "1722697338",
    "subm_id": "1343142947"
}