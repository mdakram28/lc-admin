{
    "username": "lincl52013",
    "submission": "class Solution {\npublic:\n    using graph_t = unordered_map<int, unordered_map<int, int>>;\n    \n    int traverse(graph_t& g, int node, int src){\n        int used_time = 0;\n        for(auto& [child_node, child_time]:g[node]){\n            if(child_node == src)\n                continue;\n            if(child_time == -1){\n                child_time = traverse(g, child_node, node);\n                child_time += (child_node%2)?1:2;\n            }\n            used_time = max(child_time, used_time);\n        }\n        return used_time;\n    }\n    void change(vector<int>& v, int c){\n        if(c>=v[0]){\n            v[1] = v[0];\n            v[0] = c;\n        }\n        else if(c >= v[1]){\n            v[1] = c;\n        }\n    }\n    \n    void update(graph_t& g, int node, int src, vector<int>& ans){\n        vector<int> value_arr(2, -1);\n        int offset = (node%2)?1:2;\n        for(auto& [child_node, used_time]:g[node])\n            change(value_arr, used_time);\n        for(auto& [child_node, used_time]:g[node]){\n            if(used_time == value_arr[0])\n                g[child_node][node] = max(0, value_arr[1]) + offset;\n            else\n                g[child_node][node] = value_arr[0] + offset;\n        }\n        for(auto& [child_node, used_time]:g[node]){\n            if(child_node != src)\n                update(g, child_node, node, ans);\n            ans[node] = max(ans[node], used_time);\n        }\n    }\n    \n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        graph_t g;\n        for(auto& e:edges){\n            if(g.count(e[0])==0)\n                g[e[0]] = unordered_map<int, int>();\n            g[e[0]][e[1]] = -1;\n            if(g.count(e[1])==0)\n                g[e[1]] = unordered_map<int, int>();\n            g[e[1]][e[0]] = -1;\n        }\n        vector<int> ans(n, 0);\n        ans[0] = traverse(g, 0, -1);\n        update(g, 0, -1, ans);\n        // for(int i=1;i<n;i++){\n        //     unordered_set<int> visited;\n        //     ans[i] = traverse(g, i, -1);\n        // }\n        return ans;\n    }\n};\n\n// class Solution {\n// public:\n//     using graph_t = unordered_map<int, unordered_map<int, int>>;\n    \n//     // int traverse(graph_t& g, int node, unordered_set<int>& visited){\n//     int traverse(graph_t& g, int node, int src){\n//         int used_time = 0;\n//         // visited.insert(node);\n//         for(auto& [child_node, child_time]:g[node]){\n//             if(child_node == src)\n//                 continue;\n//             // if(child_time == -1 && visited.count(child_node) == 0){\n//             if(child_time == -1){\n//                 // cout << \"traverse \" << child_node << endl;\n                \n//                 // child_time = traverse(g, child_node, visited);\n//                 child_time = traverse(g, child_node, node);\n//                 // cout << \"ret: \" << child_time << endl;\n//                 child_time += (child_node%2)?1:2;\n//                 // cout << \"final: \" << child_time << endl;\n//                 used_time = max(child_time, used_time);\n//             }\n//             // if(visited.count(child_node)==0)\n//             used_time = max(child_time, used_time);\n//         }\n//         return used_time;\n//     }\n    \n//     vector<int> timeTaken(vector<vector<int>>& edges) {\n//         int n = edges.size() + 1;\n//         graph_t g;\n//         for(auto& e:edges){\n//             if(g.count(e[0])==0)\n//                 g[e[0]] = unordered_map<int, int>();\n//             g[e[0]][e[1]] = -1;\n//             if(g.count(e[1])==0)\n//                 g[e[1]] = unordered_map<int, int>();\n//             g[e[1]][e[0]] = -1;\n//         }\n//         vector<int> ans(n, 0);\n//         for(int i=0;i<n;i++){\n//             unordered_set<int> visited;\n//             // ans[i] = traverse(g, i, visited);\n//             ans[i] = traverse(g, i, -1);\n//         }\n//         // for(auto& [node, m]:g){\n//         //     cout << node << endl;\n//         //     for(auto& [k, v]:m)\n//         //         cout << \"\\t\" << k << \" \" << v << endl;\n//         // }\n        \n//         return ans;\n//     }\n// };",
    "submit_ts": "1722700070",
    "subm_id": "1343230785"
}