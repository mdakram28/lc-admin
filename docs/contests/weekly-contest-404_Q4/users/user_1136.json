{
    "username": "Himanshusekharsahoo_04",
    "submission": "import java.util.*;\n\nclass Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        // Convert edge list to adjacency list\n        List<Integer>[] tree1 = buildTree(edges1);\n        List<Integer>[] tree2 = buildTree(edges2);\n\n        // Get diameters of both trees\n        int diameter1 = getTreeDiameter(tree1);\n        int diameter2 = getTreeDiameter(tree2);\n\n        // Calculate the minimum possible diameter after merging\n        int minDiameter = Math.max(Math.max(diameter1, diameter2), (diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1);\n        return minDiameter;\n    }\n\n    // Helper function to get the diameter of a tree\n    private int getTreeDiameter(List<Integer>[] tree) {\n        int n = tree.length;\n        int[] dist = new int[n];\n        int farthestNode = bfs(0, tree, dist);\n        int farthestFromFarthest = bfs(farthestNode, tree, dist);\n        return dist[farthestFromFarthest];\n    }\n\n    // Helper function to perform BFS and return the farthest node and update distances\n    private int bfs(int start, List<Integer>[] tree, int[] dist) {\n        Arrays.fill(dist, -1);\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        dist[start] = 0;\n        int farthestNode = start;\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            for (int neighbor : tree[node]) {\n                if (dist[neighbor] == -1) {\n                    dist[neighbor] = dist[node] + 1;\n                    queue.offer(neighbor);\n                    if (dist[neighbor] > dist[farthestNode]) {\n                        farthestNode = neighbor;\n                    }\n                }\n            }\n        }\n        return farthestNode;\n    }\n\n    // Helper function to build an adjacency list from edge list\n    private List<Integer>[] buildTree(int[][] edges) {\n        int n = edges.length + 1;\n        List<Integer>[] tree = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            tree[i] = new ArrayList<>();\n        }\n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            tree[u].add(v);\n            tree[v].add(u);\n        }\n        return tree;\n    }\n}\n",
    "submit_ts": 1719716504.0
}