{
    "username": "8symbols",
    "submission": "from sortedcontainers import SortedList\n\n\nclass SegmentTree:\n    def __init__(self, size, aggregate, empty_value=None) -> None:\n        self.size = size\n        self.values = [empty_value] * (2 * size)\n        self.empty_value = empty_value\n        self.aggregate = aggregate\n\n    def update(self, index, value):\n        index += self.size\n        self.values[index] = value\n\n        while index > 1:\n            self.values[index >> 1] = self.aggregate(self.values[index], self.values[index ^ 1])\n            index >>= 1\n\n    def query(self, left, right):\n        left += self.size\n        right += self.size + 1\n        result = self.empty_value\n\n        while left < right:\n            if left & 1 != 0:\n                result = self.aggregate(result, self.values[left])\n                left += 1\n            if right & 1 != 0:\n                result = self.aggregate(result, self.values[right - 1])\n                right -= 1\n            left >>= 1\n            right >>= 1\n\n        return result\n\n\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        segment_tree = SegmentTree(max(query[1] for query in queries) + 1, aggregate=max, empty_value=0)\n        obstacles = SortedList([0])\n\n        result = []\n\n        for query in queries:\n            if query[0] == 1:\n                new_obstacle = query[1]\n                new_obstacle_index = obstacles.bisect_right(new_obstacle)\n                previous_obstacle = obstacles[new_obstacle_index - 1]\n                segment_tree.update(previous_obstacle, new_obstacle - previous_obstacle)\n                if new_obstacle_index != len(obstacles):\n                    next_obstacle = obstacles[new_obstacle_index]\n                    segment_tree.update(new_obstacle, next_obstacle - new_obstacle)\n                obstacles.add(new_obstacle)\n            else:\n                end, size = query[1], query[2]\n                previous_obstacle = obstacles[obstacles.bisect_right(end) - 1]\n                max_size = max(segment_tree.query(0, previous_obstacle - 1), end - previous_obstacle)\n                result.append(max_size >= size)\n\n        return result",
    "submit_ts": "1716650114",
    "subm_id": "1267606726"
}