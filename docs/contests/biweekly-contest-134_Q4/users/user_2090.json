{
    "username": "strange_fellow",
    "submission": "#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n\nint N;\nclass segmentTree\n{\npublic:\n    vector<int> segTree, lazy;\n    segmentTree(vector<int> &v)\n    {\n        segTree.resize(4 * N - 1);\n        lazy.resize(4 * N - 1);\n        build(v);\n    }\n\n    void build(vector<int> &v, int start = 0, int end = N - 1, int ind = 0)\n    {\n        // time complexity : n + n/2 + n/4 + n+8 + ....  = O(n);\n        if (start == end)\n        {\n            segTree[ind] = v[start];\n            return;\n        }\n\n        int mid = (start + end) / 2;\n        build(v, start, mid, 2 * ind + 1);\n        build(v, mid + 1, end, 2 * ind + 2);\n\n        segTree[ind] = segTree[2 * ind + 1] + segTree[2 * ind + 2];\n    }\n\n    void update(int pos, int val, int start = 0, int end = N - 1, int ind = 0)\n    { // time complexity : O(logn)\n        if (start == end)\n        {\n            segTree[ind] += val;\n            return;\n        }\n\n        int mid = (start + end) / 2;\n        if (pos <= mid)\n        {\n            update(pos, val, start, mid, 2 * ind + 1);\n        }\n        else\n        {\n            update(pos, val, mid + 1, end, 2 * ind + 2);\n        }\n\n        segTree[ind] = segTree[2 * ind + 1] + segTree[2 * ind + 2];\n    }\n\n    int query(int l, int r, int start = 0, int end = N - 1, int ind = 0)\n    { // time complexity: O(logn)\n        // complete overlap\n        if (start >= l and end <= r)\n            return segTree[ind];\n\n        // no overlap\n        if (end < l || start > r)\n            return 0;\n\n        // partial overlap\n        int mid = (start + end) / 2;\n        int left = query(l, r, start, mid, 2 * ind + 1);\n        int right = query(l, r, mid + 1, end, 2 * ind + 2);\n\n        return left + right;\n    }\n\n    // Range update\n    void range_Update(int l, int r, int val, int ind = 0, int low = 0, int high = N - 1)\n    {\n        // first complete the previous updates\n        if (lazy[ind] != 0)\n        {\n            segTree[ind] += (high - low + 1) * lazy[ind];\n            if (low != high)\n            {\n                lazy[2 * ind + 1] += lazy[ind];\n                lazy[2 * ind + 1] += lazy[ind];\n            }\n            lazy[ind] = 0;\n        }\n\n        // No Overlap\n        if (high < l or r < low)\n            return;\n\n        // Complete Overlap\n        if (low >= l and high <= r)\n        {\n            // update the node\n            segTree[ind] += (high - low + 1) * val;\n\n            // propagte the change down if it is not a leaf node\n            if (low != high)\n            {\n                lazy[2 * ind + 1] += val;\n                lazy[2 * ind + 2] += val;\n            }\n            return;\n        }\n\n        // partial Ovelap\n        int mid = (low + high) >> 1;\n        range_Update(l, r, val, 2 * ind + 1, low, mid);\n        range_Update(l, r, val, 2 * ind + 2, mid + 1, high);\n        segTree[ind] = segTree[2 * ind + 1] + segTree[2 * ind + 2];\n    }\n\n    int range_query(int l, int r, int ind = 0, int low = 0, int high = N - 1)\n    {\n        // first complete the previous updates\n        if (lazy[ind] != 0)\n        {\n            segTree[ind] += (high - low + 1) * lazy[ind];\n            if (low != high)\n            {\n                lazy[2 * ind + 1] += lazy[ind];\n                lazy[2 * ind + 1] += lazy[ind];\n            }\n            lazy[ind] = 0;\n        }\n\n        // No Overlap\n        if (high < l or r < low)\n            return 0;\n\n        // Complete Overlap\n        if (low >= l and high <= r)\n            return segTree[ind];\n\n        // partial Ovelap\n        int mid = (low + high) >> 1;\n        int left = range_query(l, r, 2 * ind + 1, low, mid);\n        int right = range_query(l, r, 2 * ind + 2, mid + 1, high);\n        return left + right;\n    }\n};\n\n#define mod 1e9+7\n#define loop(i, x, n) for(int i = x; i <= n; i++)\n#define rloop(i, n, x) for(int i = n; i >= x; i--)\n#define all(v) v.begin(), v.end()\n#define ll long long\n\n\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        int n = nums.size();\n        ll ans = 0;\n        map<ll, ll> pehla_map;\n\n        vector<int> faltu, nota ; \n        stack <int> choka; \n\n        auto lamda = [](const int& a, const int& b) -> bool\n                    {\n                        return a > b;\n                    };\n\n        // yha tk sochna to asan tha baki sochte hai aur aagee\n        \n        for (int int_i = 0; int_i < n; int_i++) {\n            map<ll, ll> int_map;\n            // map bna liya hai ab\n\n            ll banana_hai = k; \n            \n            // ans ko badate hue jana hai\n            if (nums[int_i] == banana_hai) ans++;\n            \n            // map ko bhi value asign kr do\n            int_map[nums[int_i]] = 1;\n//             lamda bhi bna diya hai\n\n            int chiku,  niku; \n            string shorteg = \"\"; \n            \n            // aur ek loop bhi lga do map ke uper\n            for (auto it : pehla_map) {\n                int val = it.first; \n                int freq = it.second; \n\n                // value and freq mil gyi hai ab kya kru\n\n                long long kuch_naya = val & nums[int_i];        \n                \n                // frequ add kr do \n                if (kuch_naya == banana_hai) ans += freq;\n                \n                // map meb bhi value do\n                int_map[kuch_naya] += freq;\n            }\n            \n            // phle map ko barrabar kr do int_map ke\n            pehla_map = int_map;\n        }\n        \n        // ans return kr do\n        return ans;\n        // iske sath aur kya return kru;\n    }\n};",
    "submit_ts": "1720281422",
    "subm_id": "1311824561"
}