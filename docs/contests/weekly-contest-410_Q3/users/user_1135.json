{
    "username": "sujal25",
    "submission": "class Solution {\npublic:\n    int MOD = 1e9 + 7;\n\n    int countOfPairs(vector<int>& nums) {\n        int n = nums.size();\n        int max_num = *max_element(nums.begin(), nums.end());\n\n        // Initialize the DP array with -1 for memoization\n        vector<vector<int>> dp(n, vector<int>(max_num + 1, -1));\n\n        // Start the recursion\n        return helper(0, 0, INT_MAX, nums, dp);\n    }\n\n    int helper(int i, int a, int b, vector<int>& nums, vector<vector<int>>& dp) {\n        // Base case: if we've processed all elements\n        if (i >= nums.size()) {\n            return 1;\n        }\n\n        // Return cached result if already computed\n        if (dp[i][a] != -1) {\n            return dp[i][a];\n        }\n\n        int ans = 0;\n\n        // Explore all valid values for arr1[i] (which are stored in j)\n        for (int j = a; j <= nums[i]; j++) {\n            int sec = nums[i] - j; // arr2[i] = nums[i] - arr1[i]\n\n            // Ensure arr2[i] is non-increasing\n            if (sec > b) {\n                continue;\n            }\n\n            // Recursive call to process the next element\n            ans = (ans + helper(i + 1, j, sec, nums, dp)) % MOD;\n        }\n\n        // Store the result in DP array and return it\n        return dp[i][a] = ans;\n    }\n};\n",
    "submit_ts": "1723345568",
    "subm_id": "1351558570"
}