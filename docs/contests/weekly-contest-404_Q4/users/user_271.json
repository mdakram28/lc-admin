{
    "username": "jnfem112",
    "submission": "class Solution {\npublic:\n    vector<int> BFS(int num_node, int start, vector<vector<int>> &adj)\n    {\n        int v, last_node;\n        queue<int> q;\n        vector<bool> visit(num_node, false);\n        vector<int> dist(num_node, 0);\n        q.push(start);\n        visit[start] = true;\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            last_node = v;\n            for (auto u : adj[v])\n            {\n                if (visit[u])\n                    continue;\n                visit[u] = true;\n                dist[u] = dist[v] + 1;\n                q.push(u);\n            }\n        }\n        return {last_node, dist[last_node]};\n    }\n\n    int find_diameter(int num_node, vector<vector<int>> &adj)\n    {\n        vector<int> ret_1 = BFS(num_node, 0, adj);\n        vector<int> ret_2 = BFS(num_node, ret_1[0], adj);\n        return ret_2[1];\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int num_node_1 = edges1.size() + 1;\n        int num_node_2 = edges2.size() + 1;\n        vector<vector<int>> adj_1(num_node_1, vector<int>());\n        vector<vector<int>> adj_2(num_node_2, vector<int>());\n        for (auto edge : edges1)\n        {\n            adj_1[edge[0]].push_back(edge[1]);\n            adj_1[edge[1]].push_back(edge[0]);\n        }\n        for (auto edge : edges2)\n        {\n            adj_2[edge[0]].push_back(edge[1]);\n            adj_2[edge[1]].push_back(edge[0]);\n        }\n        int diameter_1 = find_diameter(num_node_1, adj_1);\n        int diameter_2 = find_diameter(num_node_2, adj_2);\n        return max(max(diameter_1, diameter_2), (diameter_1 + 1) / 2 + (diameter_2 + 1) / 2 + 1);\n    }\n};",
    "submit_ts": 1719718515.0
}