{
    "username": "Dhongee",
    "submission": "#include<bits/stdc++.h>\n//#include <sys/resource.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<ll,ll> pl;\ntypedef vector<pl> vpl;\n \n#define all(x) x.begin(), x.end()\n#define nl cout<<\"\\n\"\n#define ar  array\n#define PRECISION 9\n#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)\n#define clock() cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\"\n#define size(x) (int)x.size()\n#define pb push_back\n#define fr(i,j,k) for(int i=j;i<k;i++)\n#define rf(i,j,k) for(int i=k-1;i>j;i--)\n\n#ifdef LOCAL\n#include \"../Library/debug.h\"\n#else \n#define dbg(...) \"UNEMPLOYED\"\n#endif\n\n//#define STACK_INCREASE\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>> ed1, vector<vector<int>> ed2) {\n        vector<vi> adj1(size(ed1)+1);\n        vector<vi> adj2(size(ed2)+1);\n        // vi adj2[size(ed2)];\n        fr(i,0,size(ed1)){\n            int u=ed1[i][0],v=ed1[i][1];\n            adj1[u].pb(v);\n            adj1[v].pb(u);\n        }\n        dbg(\"ok\");\n        fr(i,0,size(ed2)){\n            int u=ed2[i][0],v=ed2[i][1];\n            adj2[u].pb(v);\n            adj2[v].pb(u);\n        }\n        function<vector<ar<int,2>>(vector<vi>)>get_dist=[&](vector<vi> adj){\n            int n=size(adj);\n            vi dp1(n);\n            function<void(int,int)>dfs1=[&](int u,int p){\n                for(auto v:adj[u]){\n                    if(v==p) continue;\n                    dfs1(v,u);\n                    dp1[u]=max(dp1[u],dp1[v]+1);\n                }\n            };\n            dfs1(0,-1);\n            dbg(dp1);\n            vector<ar<int,2>> dp(n);\n            function<void(int,int,int )>dfs2=[&](int u,int p,int mx){\n                int mx1=0,mx2=0,i1=-1,i2=-1;\n                mx++;\n                for(auto v: adj[u]){\n                    if(v==p) {\n                        if(mx>=mx1){\n                            mx2=mx1;\n                            i2=i1;\n                            mx1=mx;\n                            i1=p;\n                        }\n                        else if(mx>mx2){\n                            mx2=mx;\n                            i2=p;\n                        }\n                    }\n                    else {\n                        if(dp1[v]+1>=mx1){\n                            mx2=mx1;\n                            i2=i1;\n                            mx1=dp1[v]+1;\n                            i1=v;\n                        }\n                        else if(dp1[v]+1>mx2){\n                            mx2=dp1[v]+1;\n                            i2=v;\n                        }\n                    }\n                }\n                dbg(mx1,mx2,u);\n                dp[u]={mx1,mx2};\n                for(auto v: adj[u]){\n                    if(v==p) continue;\n                    if(v==i1) {\n                        dfs2(v,u,mx2);\n                    }\n                    else {\n                        dfs2(v,u,mx1);\n                    }\n                }\n            };\n            dfs2(0,-1,0);\n            return dp;\n        };\n        vector<ar<int,2>> dp1=get_dist(adj1);\n        vector<ar<int,2>> dp2=get_dist(adj2);\n        dbg(dp1);\n        dbg(dp2);\n        int d1=0,d2=0;\n        for(auto [x,y]: dp1){\n            d1=max(d1,x+y);\n        }\n        for(auto [x,y]: dp2){\n            d2=max(d2,x+y);\n        }\n        sort(all(dp1));\n        sort(all(dp2));\n        int d=dp1[0][0]+dp2[0][0]+1;\n        int ans=max({d1,d2,d});\n        return ans;\n    }\n};\n\n// int main(){\n//     if (0) cout<<fixed<<setprecision(PRECISION);\n//     fast_IO;\n//     #ifdef STACK_INCREASE\n//     rlimit rlim;\n//     if (getrlimit(RLIMIT_STACK, &rlim)) return 1;\n//     rlim.rlim_cur = 1024*1024*1024;\n//     if (setrlimit(RLIMIT_STACK, &rlim)) return 2;\n//     #endif\n//     int T=1;\n//     // cin>>T;\n//     while(T--){\n//         Solution sol;\n//         cout<<sol.minimumDiameterAfterMerge({{0,1},{0,2},{0,3}},{{0,1}});\n//         // solve();\n//         clock();\n//     }\n//     return 0;\n// }\n",
    "submit_ts": "1719718896",
    "subm_id": "1304428765"
}