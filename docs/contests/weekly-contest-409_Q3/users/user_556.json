{
    "username": "gradesking",
    "submission": "int L[400100], R[400100], tag[400100], sum[400100];\n\nvoid build_tree(int p, int l, int r) {\n    L[p] = l;\n    R[p] = r;\n    tag[p] = 0;\n    sum[p] = 0;\n    if (l == r) {\n        sum[p] = 1;\n        return;\n    }\n    int mid = (l + r) / 2;\n    build_tree(2 * p, l, mid);\n    build_tree(2 * p + 1, mid + 1, r);\n    sum[p] = sum[2 * p] + sum[2 * p + 1];\n}\n\nvoid tagdown(int p)\n{\n    if(L[p]==R[p]) return;\n    if(!tag[p]) return;\n    tag[2*p] = 1;\n    sum[2*p] = 0;\n    tag[2*p+1] = 1;\n    sum[2*p+1] = 0;\n}\n\nvoid change(int p, int l, int r)\n{\n    tagdown(p);\n    if(L[p]==l && R[p]==r)\n    {\n        tag[p] = 1;\n        sum[p] = 0;\n        return;\n    }\n    int mid = (L[p] + R[p]) / 2;\n    if(r<=mid) change(2*p, l, r);\n    else if(l>mid) change(2*p+1, l, r);\n    else \n    {\n        change(2*p, l, mid);\n        change(2*p+1, mid+1, r);\n    }\n    sum[p] = sum[2*p] + sum[2*p+1];\n}\n\nint get_sum(int p, int l, int r)\n{\n    tagdown(p);\n    if(L[p]==l && R[p]==r) return sum[p];\n    int mid = (L[p] + R[p]) / 2;\n    if(r<=mid) return get_sum(2*p, l, r);\n    if(l>mid) return get_sum(2*p+1, l, r);\n    return get_sum(2*p, l,mid) + get_sum(2*p+1,mid+1,r);\n}\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        build_tree(1, 0, n-1);\n        vector<int> ans;\n        for(const auto& p:  queries)\n        {\n            int a=p[0], b=p[1];\n            change(1, a+1, b-1);\n            ans.push_back(get_sum(1, 0, n-1) - 1);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722741667",
    "subm_id": "552339648"
}