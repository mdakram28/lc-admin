{
    "username": "berkeleyColin",
    "submission": "struct SegTree{\n    vector<int> isPeak;\n    int n;\n    \n    SegTree(vector<int>& isPeaks){\n        n=isPeaks.size();\n        isPeak=vector<int>(4*n,0);\n        build(isPeaks,0,0,n-1);\n    }\n    \n    void build(vector<int>& isPeaks, int node, int start, int end){\n        if(start==end){\n            isPeak[node]=isPeaks[start];\n        }else{\n            int mid=(start+end)/2;\n            build(isPeaks,2*node+1,start,mid);\n            build(isPeaks,2*node+2,mid+1,end);\n            isPeak[node]=isPeak[2*node+1]+isPeak[2*node+2];\n        }\n    }\n    \n    void update(int idx, int val){\n        update(0,0,n-1,idx,val);\n    }\n    void update(int node, int start, int end, int idx, int val){\n        if(start==end){\n            isPeak[node]=val;\n        }else {\n            int mid=(start+end)/2;\n            if(start<=idx&&idx<=mid){\n                update(2*node+1, start,mid,idx,val);\n            }else {\n                update(2*node+2, mid+1,end,idx,val);\n            }\n            isPeak[node]=isPeak[2*node+1]+isPeak[2*node+2];\n        }\n    }\n    int query(int l, int r){\n        return query(0,0,n-1,l,r);\n    }\n    int query(int node, int start, int end, int l, int r){\n        if(r<start||end<l){\n            return 0;\n        }\n        if(l<=start&&end<=r){\n            return isPeak[node];\n        }\n        int mid=(start+end)/2;\n        int leftSum=query(2*node+1,start,mid,l,r);\n        int rightSum=query(2*node+2,mid+1,end,l,r);\n        //cout<<node<<\" \"<<(leftSum+rightSum)<<endl;\n        return leftSum+rightSum;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        vector<int> peaks(n,0);\n        for(int i=1;i<n-1;i++){\n            if(nums[i]>nums[i-1]&&nums[i]>nums[i+1])peaks[i]=1;\n        }\n        SegTree tree=SegTree(peaks);\n        vector<int> ret;\n        for(auto& vec:queries){\n            int type=vec[0];\n            int left=vec[1];\n            int right=vec[2];\n            if(type==2){\n                if(nums[left]==right)continue;\n                nums[left]=right;\n                if(left-1>=0&&left+1<n&&nums[left]>nums[left-1]&&nums[left]>nums[left+1]){\n                    tree.update(left,1);\n                }else tree.update(left,0);\n                \n                if(left-1>=0&&left-2>=0&&nums[left-1]>nums[left-2]&&nums[left-1]>nums[left]){\n                    tree.update(left-1,1);\n                }else if(left-1>=0)tree.update(left-1,0);\n                \n                if(left+1<n&&left+2<n&&nums[left+1]>nums[left+2]&&nums[left+1]>nums[left]){\n                    tree.update(left+1,1);\n                }else if(left+1<n)tree.update(left+1,0);\n                \n            }else{\n                ret.push_back(tree.query(left+1,right-1));\n            }\n        }\n        return ret;\n        \n    }\n};",
    "submit_ts": "1718508485",
    "subm_id": "1289682632"
}