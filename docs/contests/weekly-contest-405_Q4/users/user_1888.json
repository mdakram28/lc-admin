{
    "username": "Jatin_Gupta_NITW",
    "submission": "class Solution {\npublic:\n    class StringMatcher {\n    public:\n        struct TrieNode {\n            unordered_map<char, int> children;\n            int fail;\n            vector<int> output;\n\n            TrieNode() : fail(-1) {}\n        };\n\n        vector<TrieNode> trie;\n\n        StringMatcher() {\n            trie.emplace_back();\n        }\n\n        void insert(const string& word, int index) {\n            int currentNode = 0;\n            for (char c : word) {\n                if (trie[currentNode].children.find(c) == trie[currentNode].children.end()) {\n                    trie[currentNode].children[c] = trie.size();\n                    trie.emplace_back();\n                }\n                currentNode = trie[currentNode].children[c];\n            }\n            trie[currentNode].output.push_back(index);\n        }\n\n        void build() {\n            queue<int> q;\n            for (auto& [key, value] : trie[0].children) {\n                trie[value].fail = 0;\n                q.push(value);\n            }\n\n            while (!q.empty()) {\n                int current = q.front();\n                q.pop();\n                \n                for (auto& [key, value] : trie[current].children) {\n                    int fail = trie[current].fail;\n                    while (fail != -1 && trie[fail].children.find(key) == trie[fail].children.end()) {\n                        fail = trie[fail].fail;\n                    }\n                    if (fail == -1) {\n                        trie[value].fail = 0;\n                    } else {\n                        trie[value].fail = trie[fail].children[key];\n                    }\n                    trie[value].output.insert(trie[value].output.end(),\n                                            trie[trie[value].fail].output.begin(),\n                                            trie[trie[value].fail].output.end());\n                    q.push(value);\n                }\n            }\n        }\n\n        int search(const string& target, const vector<pair<int, int>>& wordCosts) {\n            int n = target.size();\n            vector<int> dp(n + 1, INT_MAX);\n            dp[0] = 0;\n\n            int currentNode = 0;\n            for (int i = 0; i < n; ++i) {\n                while (currentNode != -1 && trie[currentNode].children.find(target[i]) == trie[currentNode].children.end()) {\n                    currentNode = trie[currentNode].fail;\n                }\n                if (currentNode == -1) {\n                    currentNode = 0;\n                } else {\n                    currentNode = trie[currentNode].children[target[i]];\n                }\n\n                for (int index : trie[currentNode].output) {\n                    int wordLen = wordCosts[index].first;\n                    int cost = wordCosts[index].second;\n                    if (i + 1 - wordLen >= 0 && dp[i + 1 - wordLen] != INT_MAX) {\n                        dp[i + 1] = min(dp[i + 1], dp[i + 1 - wordLen] + cost);\n                    }\n                }\n            }\n\n            return dp[n] == INT_MAX ? -1 : dp[n];\n        }\n    };\n\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        StringMatcher matcher;\n        vector<pair<int, int>> wordCosts;\n        for (int i = 0; i < words.size(); ++i) {\n            matcher.insert(words[i], i);\n            wordCosts.emplace_back(words[i].size(), costs[i]);\n        }\n        matcher.build();\n        return matcher.search(target, wordCosts);\n    }\n};",
    "submit_ts": "1720324006",
    "subm_id": "1312389363"
}