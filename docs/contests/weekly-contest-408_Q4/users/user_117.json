{
    "username": "Romy67",
    "submission": "#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define per(i, a, b) for(int i = a; i > (b); --i)\n#define ar array\n#define sz(x) (int) (x).size()\n#define pii pair<int,int>\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\n\ntemplate<typename T>\nvoid min_self(T& A, T B) {\n    A = min(A,B);\n}\ntemplate<typename T>\nvoid max_self(T& A, T B) {\n    A = max(A,B);\n}\n\ntemplate <class T> int sgn(T x) { return (x > 0) - (x < 0); }\ntemplate<class T>\nstruct Point {\n    typedef Point P;\n    T x, y;\n    explicit Point(T x=0, T y=0) : x(x), y(y) {}\n    bool operator<(P p) const { return tie(x,y) < tie(p.x,p.y); }\n    bool operator==(P p) const { return tie(x,y)==tie(p.x,p.y); }\n    P operator+(P p) const { return P(x+p.x, y+p.y); }\n    P operator-(P p) const { return P(x-p.x, y-p.y); }\n    P operator*(T d) const { return P(x*d, y*d); }\n    P operator/(T d) const { return P(x/d, y/d); }\n    T dot(P p) const { return x*p.x + y*p.y; }\n    T cross(P p) const { return x*p.y - y*p.x; }\n    T cross(P a, P b) const { return (a-*this).cross(b-*this); }\n    T dist2() const { return x*x + y*y; }\n    double dist() const { return sqrt((double)dist2()); }\n    // angle to x-axis in interval [-pi, pi]\n    double angle() const { return atan2(y, x); }\n    P unit() const { return *this/dist(); } // makes dist()=1\n    P perp() const { return P(-y, x); } // rotates +90 degrees\n    P normal() const { return perp().unit(); }\n    // returns point rotated 'a' radians ccw around the origin\n    P rotate(double a) const {\n        return P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }\n    friend ostream& operator<<(ostream& os, P p) {\n        return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n};\n\ntemplate<class P>\nvector<P> circleLine(P c, double r, P a, P b) {\n    P ab = b - a, p = a + ab * (c-a).dot(ab) / ab.dist2();\n    double s = a.cross(b, c), h2 = r*r - s*s / ab.dist2();\n    if (h2 < 0) return {};\n    if (h2 == 0) return {p};\n    P h = ab.unit() * sqrt(h2);\n    return {p - h, p + h};\n}\n\ntypedef Point<double> P;\nbool circleInter(P a,P b,double r1,double r2,pair<P, P>* out) {\n    if (a == b) { return false; }\n    P vec = b - a;\n    double d2 = vec.dist2(), sum = r1+r2, dif = r1-r2,\n           p = (d2 + r1*r1 - r2*r2)/(d2*2), h2 = r1*r1 - p*p*d2;\n    if (sum*sum < d2 || dif*dif > d2) return false;\n    P mid = a + vec*p, per = vec.perp() * sqrt(fmax(0, h2) / d2);\n    *out = {mid + per, mid - per};\n    return true;\n}\n\ndouble segDist(P& s, P& e, P& p) {\n    if (s==e) return (p-s).dist();\n    auto d = (e-s).dist2(), t = min(d,max(.0,(p-s).dot(e-s)));\n    return ((p-s)*d-(e-s)*t).dist()/d;\n}\nbool onSegment(P& a, P& b, P& p) {\n    return segDist(a,b,p) < 1e-10;\n}\n\nbool inside(P& cen, double r, P& p) {\n    return (p-cen).dist2() <=r*r;\n}\n\nstruct UF {\n    vi e;\n    vector<vector<bool>> flag;\n    UF(int n) : e(n, -1), flag(n, vector<bool>(4,0)) {}\n    bool sameSet(int a, int b) { return find(a) == find(b); }\n    int size(int x) { return -e[find(x)]; }\n    int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }\n    bool join(int a, int b) {\n        a = find(a), b = find(b);\n        if (a == b) return false;\n        if (e[a] > e[b]) swap(a, b);\n        e[a] += e[b]; e[b] = a;\n        rep(i,0,4) {\n            flag[a][i] = flag[a][i] || flag[b][i];\n        }\n        return true;\n    }\n};\n\nbool inRec(P p, double x, double y) {\n    return p.x>=0.0&&p.x<=x&&p.y>=0&&p.y<=y;\n}\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        UF uf(sz(circles));\n        rep(i,0,sz(circles)) {\n            vector<P> v = {P(0,0),P(X,0),P(X,Y),P(0,Y),P(0,0)};\n            P cen(circles[i][0],circles[i][1]);\n            double r = circles[i][2];\n            rep(j,0,4) {\n                auto res = circleLine(cen,r, v[j],v[j+1]);\n                if(sz(res)) {\n                    if(onSegment(v[j],v[j+1],res[0])) {\n                        uf.flag[i][j] = 1;\n                        continue;\n                    }\n                    if(sz(res)>1 && onSegment(v[j],v[j+1],res[1])) {\n                        uf.flag[i][j] = 1;\n                        continue;\n                    }\n                }\n                if(inside(cen,r, v[j])) {\n                    uf.flag[i][j] = 1;\n                }\n            }\n        }\n        rep(i,0,sz(circles)) {\n            rep(j,i+1,sz(circles)) {\n                pair<P, P> out;\n                P cen1(circles[i][0],circles[i][1]);\n                P cen2 (circles[j][0], circles[j][1]);\n                double r1 = circles[i][2], r2 = circles[j][2];\n                if(circleInter(cen1, cen2, r1, r2, &out)) {\n                    if(inRec(out.fi, X, Y) || inRec(out.se,X,Y)) {\n                        uf.join(i,j);\n                    } \n                }\n            }\n        }\n        rep(i,0,sz(circles)) {\n            int u = uf.find(i);\n            if(uf.flag[u][0] && uf.flag[u][2]) return false;\n            if(uf.flag[u][1] && uf.flag[u][3]) return false;\n            if(uf.flag[u][0] && uf.flag[u][3]) return false;\n            if(uf.flag[u][1] && uf.flag[u][2]) return false;\n        }\n        return true;\n    }\n};",
    "submit_ts": "1722138732",
    "subm_id": "1335798267"
}