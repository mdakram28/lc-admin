{
    "username": "AmenPark",
    "submission": "from queue import Queue\nclass Node(dict):\n        def __init__(self):\n            super().__init__()\n            self.final = False;\n            \n            self.out = set();\n            self.fail = None;\n            \n        def addout(self,out):\n            if type(out) is set:\n                self.out = self.out.union(out)\n            else :\n                self.out.add(out)\n        \n        def addchild(self,alphabet,node = None):\n            self[alphabet] = Node() if node is None else node\n\nclass AC():\n    def __init__(self,patterns):\n        self.patterns = patterns\n        self.head = Node()\n        \n        self.maketrie()\n        self.constructfail()\n        \n    def search(self,sentence, costmap):\n        crr = self.head\n        ret = [0]\n        for c in sentence :\n            while crr is not self.head and c not in crr:\n                crr = crr.fail\n            if c in crr:\n                crr = crr[c]\n            \n            if crr.final:\n                mval = math.inf\n                for s in crr.out:\n                    ls = len(s)\n                    if ret[-ls]!=0 or ls==len(ret):\n                        mval=min(ret[-ls]+costmap[s],mval)\n                if mval != math.inf:\n                    ret.append(mval)\n                else:\n                    ret.append(0)\n            else:\n                ret.append(0)\n        return ret[-1]\n    \n    def maketrie(self):\n        for pattern in self.patterns:\n            crr = self.head\n            for c in pattern :\n                if c not in crr:\n                    crr.addchild(c)\n                crr = crr[c]\n            crr.final = True\n            crr.addout(pattern)\n            \n    def constructfail(self):\n        queue = Queue()\n        self.head.fail = self.head\n        queue.put(self.head)\n        while not queue.empty():\n            crr = queue.get()\n            for nextc in crr:\n                child = crr[nextc]\n                \n                if crr is self.head:\n                    child.fail = self.head\n                else :\n                    f = crr.fail\n                    while f is not self.head and nextc not in f:\n                        f = f.fail\n                    if nextc in f:\n                        f = f[nextc]\n                    child.fail = f\n                \n                child.addout(child.fail.out)\n                child.final |= child.fail.final\n                \n                queue.put(child)\nclass Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        costmap={}\n        for w,c in zip(words,costs):\n            costmap[w]=min(costmap.get(w,c),c)\n        N=len(target)\n        dp=[0]*N\n        ac=AC(words)\n        return ac.search(target, costmap) or -1\n        ",
    "submit_ts": "1720322254",
    "subm_id": "1312344898"
}