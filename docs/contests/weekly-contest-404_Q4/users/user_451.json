{
    "username": "cy171",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def helper(edges):\n            # if len(edges) == 1:\n            #     return [1,1]\n            n = len(edges) + 1\n            child = defaultdict(int)\n            graph = defaultdict(set)\n            ans = []\n            for a,b in edges:\n                graph[a].add(b)\n                graph[b].add(a)\n                child[a] += 1\n                child[b] += 1\n            queue = []\n            for i in range(len(edges)+1):\n                if child[i] == 1:\n                    queue.append(i)\n            l = 0\n            while True:\n                # print(n)\n                new = []\n                if n == 1:\n                    return (l, 2*l)\n                elif n == 2:\n                    return (l+1, 2*l+1)\n                for node in queue:\n                    n -= 1\n                    for nei in graph[node]:\n                        child[nei] -= 1\n                        graph[nei].remove(node)\n                        if child[nei] <= 1:\n                            new.append(nei)\n                queue = new\n                l += 1\n\n        t1, tt1 = helper(edges1)\n        t2, tt2 = helper(edges2)\n        print(t1, tt1,t2, tt2)\n        return max(t1 + t2 + 1, tt1 , tt2)",
    "submit_ts": 1719718089.0
}