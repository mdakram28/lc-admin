{
    "username": "agarwalkunal2707",
    "submission": "class Solution {\npublic:\n    int ans=0;int ans1=0;\n    int dfs(int i,int p,unordered_map<int,list<int>>&adj, vector<int>&dp){\n    \n    int x=0;int maxi1=0;int maxi2=0;\n    for(auto j:adj[i]){\n        if(j==p)continue;\n        x=dfs(j,i,adj,dp);\n         if(x>maxi1){\n          maxi2=maxi1;\n          maxi1=x;\n      }\n      else if(x>maxi2){\n          maxi2=x;\n      }\n    }\n     dp[i]=max(dp[i],1+maxi1+maxi2);\n  ans=max(ans,dp[i]-1);\n    return 1+max(maxi1,maxi2);\n}\n     int dfs1(int i,int p,unordered_map<int,list<int>>&adj, vector<int>&dp){\n    \n    int x=0;int maxi1=0;int maxi2=0;\n    for(auto j:adj[i]){\n        if(j==p)continue;\n        x=dfs1(j,i,adj,dp);\n         if(x>maxi1){\n          maxi2=maxi1;\n          maxi1=x;\n      }\n      else if(x>maxi2){\n          maxi2=x;\n      }\n    }\n     dp[i]=max(dp[i],1+maxi1+maxi2);\n  ans1=max(ans1,dp[i]-1);\n    return 1+max(maxi1,maxi2);\n}\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n         unordered_map<int,list<int>> adj;\n        if(edges1.size()>0){\n            int n=edges1.size();\n             for(int i=0;i<edges1.size();i++){\n        int a=edges1[i][0];int b=edges1[i][1];\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n        \n    vector<int> dp(n+1,0);\n    dfs(0,-1,adj,dp);\n        }\n   \n  \n          unordered_map<int,list<int>> adj1;\n         if(edges2.size()>0){\n             int n1=edges2.size();\n              for(int i=0;i<edges2.size();i++){\n        int a=edges2[i][0];int b=edges2[i][1];\n        adj1[a].push_back(b);\n        adj1[b].push_back(a);\n    }\n       \n    vector<int> dp1(n1+1,0);\n    dfs1(0,-1,adj1,dp1);\n         } \n        int a=max(ans1,ans);\n        return max(a,(ans+1)/2+(ans1+1)/2+1);\n    }\n};",
    "submit_ts": 1719718312.0
}