{
    "username": "venilv251",
    "submission": "struct TrieNode {\n    TrieNode* children[26];\n    bool isEndOfWord = false;\n    int minCost = INT_MAX;\n    \n    bool containsChar(char ch) {\n        return (children[ch - 'a'] != nullptr);\n    }\n    \n    void addChar(char c, TrieNode* node) {\n        children[c - 'a'] = node;\n    }\n    \n    TrieNode* getChar(char ch) {\n        return children[ch - 'a'];\n    }\n};\n\nclass Trie {\npublic:\n    TrieNode* root;\n    \n    Trie() {\n        root = new TrieNode();\n    }\n    \n    void insertWord(string word, int cost) {\n        TrieNode* currentNode = root;\n        for (int i = 0; i < word.length(); i++) {\n            if (!currentNode->containsChar(word[i])) {\n                currentNode->addChar(word[i], new TrieNode());\n            }\n            currentNode = currentNode->getChar(word[i]);\n        }\n        currentNode->isEndOfWord = true;\n        currentNode->minCost = min(cost, currentNode->minCost);\n    }\n    \n    int searchWord(string word) {\n        TrieNode* currentNode = root;\n        for (int i = 0; i < word.length(); i++) {\n            if (!currentNode->containsChar(word[i])) {\n                return false;\n            }\n            currentNode = currentNode->getChar(word[i]);\n        }\n        return currentNode->minCost;\n    }\n    \n    bool startsWithPrefix(string prefix) {\n        TrieNode* currentNode = root;\n        for (int i = 0; i < prefix.length(); i++) {\n            if (!currentNode->containsChar(prefix[i])) {\n                return false;\n            }\n            currentNode = currentNode->getChar(prefix[i]);\n        }\n        return true;\n    }\n};\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int targetLen = target.size();\n        Trie* trieObj = new Trie();\n        vector<int> dpArray(targetLen + 2, INT_MAX);\n        \n        for (int i=0; i<costs.size(); i++) {\n            trieObj->insertWord(words[i], costs[i]);\n        }\n        \n        dpArray[0] = 0;\n        \n        for (int j = 0; j < targetLen; ++j) {\n            if (dpArray[j] == INT_MAX) continue;\n\n            TrieNode* currentNode = trieObj->root;\n            \n            for (int k = j; k < targetLen; ++k) {\n                if (!currentNode->containsChar(target[k])) break;\n                currentNode = currentNode->children[target[k] - 'a'];\n                if (currentNode->minCost != INT_MAX) {\n                    dpArray[k + 1] = min(dpArray[k + 1], dpArray[j] + (currentNode->minCost));\n                }\n            }\n        }\n        \n        return dpArray[targetLen] == INT_MAX ? -1 : dpArray[targetLen];\n    }\n};",
    "submit_ts": "1720324787",
    "subm_id": "1312408336"
}