{
    "username": "subodhr2001",
    "submission": "class Solution {\npublic:\n    \n    vector<int> segment_tree;\n\n    // build the segment tree\n    void build_segment_tree(vector<int>& segment_tree, vector<int>& peaks, int node, int start, int end) {\n        if (start == end) {\n            segment_tree[node] = peaks[start];\n        } else {\n            int mid = (start + end) / 2;\n            build_segment_tree(segment_tree, peaks, 2 * node, start, mid);\n            build_segment_tree(segment_tree, peaks, 2 * node + 1, mid + 1, end);\n            segment_tree[node] = segment_tree[2 * node] + segment_tree[2 * node + 1];\n        }\n    }\n\n    \n\n    // update the segment tree\n    void update_segment_tree(vector<int>& segment_tree, int node, int start, int end, int idx, int value) {\n        if (start == end) {\n            segment_tree[node] = value;\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid) {\n                update_segment_tree(segment_tree, 2 * node, start, mid, idx, value);\n            } else {\n                update_segment_tree(segment_tree, 2 * node + 1, mid + 1, end, idx, value);\n            }\n            segment_tree[node] = segment_tree[2 * node] + segment_tree[2 * node + 1];\n        }\n    }\n\n    // query the segment tree\n    int query_segment_tree(vector<int>& segment_tree, int node, int start, int end, int L, int R) {\n        if (R < start || end < L) {\n            return 0;\n        }\n        if (L <= start && end <= R) {\n            return segment_tree[node];\n        }\n        int mid = (start + end) / 2;\n        int left_sum = query_segment_tree(segment_tree, 2 * node, start, mid, L, R);\n        int right_sum = query_segment_tree(segment_tree, 2 * node + 1, mid + 1, end, L, R);\n        return left_sum + right_sum;\n    }\n    \n    bool is_peak(int i, vector<int>& nums, int n) {\n        return i > 0 && i < n - 1 && nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    }\n    \n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> answer;\n        vector<int> peaks(n, 0);\n        segment_tree.resize(4*n);\n        // check if a given index is a peak or not\n        \n\n        // Initialize the peaks array\n        for (int i = 1; i < n - 1; ++i) {\n            peaks[i] = is_peak(i, nums, n);\n        }\n        \n        build_segment_tree(segment_tree, peaks, 1, 0, n - 1);\n\n        for (const vector<int>& query : queries) {\n            \n            if (query[0] == 1) {\n                \n                int left = query[1], right = query[2];\n                \n                if (left + 1 <= right - 1) {\n                    answer.push_back(query_segment_tree(segment_tree, 1, 0, n - 1, left + 1, right - 1));\n                } \n                else {\n                    answer.push_back(0);\n                }\n                \n            } \n            else if (query[0] == 2) {\n                int index = query[1], value = query[2];\n                \n                nums[index] = value;\n                for (int i = max(1, index - 1); i <= min(n - 2, index + 1); ++i) {\n                    \n                    update_segment_tree(segment_tree, 1, 0, n - 1, i, is_peak(i, nums, n));\n                }\n            }\n        }\n\n        return answer;\n    }\n};",
    "submit_ts": 1718508593.0
}