{
    "username": "shu-xi",
    "submission": "# \u6bcf\u6b21\u66f4\u65b0\u53ea\u5f71\u54cd\u5de6\u4e2d\u53f3\u4e09\u4e2a\n\n# \u6a21\u677f: \u7ebf\u6bb5\u6811\nclass SegTree:\n    def __init__(self, a):\n        self.a, self.n = [0] + a, len(a)\n        self.d = [0 for i in range(4*self.n)]\n        self.b = [0 for i in range(4*self.n)] # for lazy update\n        self.__build(1, self.n, 1)\n    def __build(self, s, t, p): # build [s, t]\n        if s == t:\n            self.d[p] = self.a[s]\n            return\n        m = s + ((t - s) >> 1)\n        self.__build(s, m, p * 2)\n        self.__build(m + 1, t, p * 2 + 1)\n        self.d[p] = self.d[p * 2] + self.d[(p * 2) + 1]\n    def __update(self, l, r, c, s, t, p):\n        if l <= s and t <= r:\n            self.d[p] = self.d[p] + (t - s + 1) * c\n            self.b[p] = self.b[p] + c\n            return\n        m = s + ((t - s) >> 1)\n        if self.b[p] and s != t:\n            self.d[p * 2] = self.d[p * 2] + self.b[p] * (m - s + 1)\n            self.d[p * 2 + 1] = self.d[p * 2 + 1] + self.b[p] * (t - m)\n            self.b[p * 2] = self.b[p * 2] + self.b[p]\n            self.b[p * 2 + 1] = self.b[p * 2 + 1] + self.b[p]\n            self.b[p] = 0\n        if l <= m:\n            self.__update(l, r, c, s, m, p * 2)\n        if r > m:\n            self.__update(l, r, c, m + 1, t, p * 2 + 1)\n        self.d[p] = self.d[p * 2] + self.d[p * 2 + 1]\n    def update(self, l, r, c): # update [l, r] to add c\n        self.__update(l+1, r+1, c, 1, self.n, 1)\n    def __getsum(self, l, r, s, t, p):\n        if l <= s and t <= r:\n            return self.d[p]\n        m = s + ((t - s) >> 1)\n        if self.b[p]:\n            self.d[p * 2] = self.d[p * 2] + self.b[p] * (m - s + 1)\n            self.d[p * 2 + 1] = self.d[p * 2 + 1] + self.b[p] * (t - m)\n            self.b[p * 2] = self.b[p * 2] + self.b[p]\n            self.b[p * 2 + 1] = self.b[p * 2 + 1] + self.b[p]\n            self.b[p] = 0\n        res = 0\n        if l <= m:\n            res = self.__getsum(l, r, s, m, p * 2)\n        if r > m:\n            res = res + self.__getsum(l, r, m + 1, t, p * 2 + 1)\n        return res\n    def getsum(self, l, r): # getsum [l, r]\n        return self.__getsum(l+1, r+1, 1, self.n, 1)\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        res = []\n        mt = [0 for i in range(n)]\n        for i in range(1, n-1):\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:\n                mt[i] = 1\n        seg = SegTree(mt)\n\n        def getM(p):\n            if p == 0 or p == n-1:\n                return False\n            return nums[p] > nums[p-1] and nums[p] > nums[p+1]\n        \n        for t, p1, p2 in queries:\n            if t == 1:\n                cur = 0\n                if p2 - 1 >= p1 + 1:\n                    cur = seg.getsum(p1+1, p2-1)\n                res.append(cur)\n            else:\n                nums[p1] = p2\n                for i in range(-1, 2):\n                    if 0 <= p1 + i <= n-1:\n                        newC = getM(p1 + i)\n                        diff = newC - mt[p1 + i]\n                        seg.update(p1+i, p1+i, diff)\n                        mt[p1 + i] = newC\n        return res",
    "submit_ts": "1718506962",
    "subm_id": "539778358"
}