{
    "username": "seaman003",
    "submission": "class Solution {\npublic:\n    constexpr static int N = 2e5 + 10, M = 1e5 + 1, INF = 0x3f3f3f3f;\n    vector<int> g[N];\n    int deg[N];\n    vector<int> find(unordered_set<int>& nodes) {\n        queue<int> q;\n        vector<int> ans;\n        const int tree_nodes = nodes.size();\n        for (auto i : nodes) {\n            if (deg[i] <= 1) {\n                q.push(i);\n            }\n        }\n        int cnt = 0;\n        while (tree_nodes - cnt > 2) {\n            int s = q.size();\n            while (s -- ) {\n                auto cur = q.front(); q.pop();\n                cnt ++ ;\n                for (auto ne : g[cur]) {\n                    if ( -- deg[ne] == 1 ) {\n                        q.push(ne);\n                    }\n                }\n            }\n        }\n        assert(q.size() == 2 || q.size() == 1);\n        int s = q.size();\n        while (s -- ) {\n            int cur = q.front(); q.pop();\n            q.push(cur);\n            ans.push_back(cur);\n        }\n        return ans;\n    }\n    int get(int root, int p, int &ans) {\n        int res = 0;\n        priority_queue<int, vector<int>, greater<int>> heap;\n        for (auto ne : g[root]) {\n            if (ne == p) continue;\n            int cur = get(ne, root, ans) + 1;\n            res = max(res, cur);\n            if (heap.size() < 2) heap.push(cur);\n            else if (cur > heap.top()) {\n                heap.pop();\n                heap.push(cur);\n            }\n        }\n        int s = 0;\n        while (heap.size()) {\n            s += heap.top();\n            heap.pop();\n        }\n        ans = max(ans, s);\n        return res;\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        unordered_set<int> S1, S2;\n        S1.insert(0); S2.insert(M);\n        const int lower1 = 0, lower2 = M;\n        for (auto &v : edges1) {\n            const int a = v[0], b = v[1];\n            g[a].push_back(b);\n            g[b].push_back(a);\n            deg[a] ++ ; deg[b] ++ ;\n            S1.insert(a); S1.insert(b);\n        }\n        for (auto &v : edges2) {\n            const int a = v[0] + M, b = v[1] + M;\n            g[a].push_back(b);\n            g[b].push_back(a);\n            deg[a] ++ ; deg[b] ++ ;\n            S2.insert(a); S2.insert(b);\n        }\n        int l1 = 0;\n        get(lower1, -1, l1);\n        \n        int l2 = 0;\n        get(lower2, -1, l2);\n        \n        if (l1 > l2) swap(l1, l2);\n        if (l1 == 1) {\n            return max({l1, l2, (l2 + 1) / 2 + 2});\n        }\n        \n        int hl1 = l1 / 2, hl2 = l2 / 2;\n        int s1 = l1 & 1, s2 = l2 & 1;\n        int ans = max({l1, l2, hl1 + hl2 + 1 + min(1, s1 + s2)});\n        ans = max({l1, l2, (l1 + 1) / 2 + (l2 + 1) / 2 + 1});\n        return ans;\n#if 0\n        auto c1 = find(S1);\n        auto c2 = find(S2);\n        if (c2.size() < c1.size()) swap(c1, c2);\n        \n        \n        g[c1[0]].push_back(c2[0]);\n        g[c2[0]].push_back(c1[0]);\n        int ans = 0;\n        get(lower1, -1, ans);\n        g[c1[0]].pop_back();\n        g[c2[0]].pop_back();\n        \n        if (c2.size() > 1) {\n            g[c1[0]].push_back(c2[1]);\n            g[c2[1]].push_back(c1[0]);\n            auto tmp = 0;\n            get(lower1, -1, tmp);\n            ans = min(ans, tmp);\n        }\n        return ans;  \n#endif\n    }\n};",
    "submit_ts": 1719717812.0
}