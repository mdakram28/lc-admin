{
    "username": "scotchtape",
    "submission": "using ll = long long;\nstruct Lazy {\n    ll set, add;\n    ll time;\n    Lazy(ll s, ll a, ll t) {\n        set = s;\n        add = a;\n        time = t;\n    }\n    Lazy(ll s, ll a) {\n        set = s;\n        add = a;\n    }\n\n    // default is IMPORTANTR\n    Lazy() {\n        set = 1e9; // 1e9 means nothing to set\n        add = 0;\n        time = 0;\n    }\n};\n\nstruct Node {\n    ll l, r;\n    ll val = 0;\n    Lazy lazy;\n    Node() {}\n    Node(ll l, ll r, ll v, Lazy lz) {\n        this-> l = l;\n        this->r = r;\n        val = v;\n        lazy = lz;\n    }\n};\nstruct SegSum {\n    Lazy combine(Lazy first, Lazy second) {\n\n        if (first.time > second.time) swap(first, second);\n\n        Lazy res(1e9, 0, max(first.time, second.time));\n        res.add = first.add + second.add;\n        if (second.set != 1e9) {\n            res.set = second.set;\n            return res;\n        }\n        if (first.set != 1e9) {\n            res.set = first.set + second.add;\n            return res;\n        }\n        return res;\n    }\n\n    ll combine(ll a, ll b) {\n        return a+b;\n    }\n\n\n    vector<Node> seg;\n    ll n;\n    ll update_timer = 0;\n\n    bool leaf(ll cur) {\n        return seg[cur].l == seg[cur].r;\n    }\n\n    SegSum(ll n) {\n        this->n = n;\n        ll sz = 1; while (sz <= 2*n) sz *= 2;\n        seg = vector<Node>(sz+1);\n        setup(1, 1, n);\n    }\n\n    void setup(ll cur, ll l, ll r) {\n        seg[cur].l = l;\n        seg[cur].r = r;\n        if (l == r) return;\n\n        setup(cur*2, l, l+(r-l)/2);\n        setup(cur*2+1, l+(r-l)/2+1, r);\n    }\n\n    void upd(ll l, ll r, Lazy lz) {\n        lz.time = update_timer;\n        update_timer++;\n        upd(1, l+1, r+1, lz);\n    }\n\n    void upd(ll cur, ll l, ll r, Lazy lz) {\n        push(cur);\n        if (r < seg[cur].l || l > seg[cur].r) return;\n        if (l <= seg[cur].l && seg[cur].r <= r) {\n            seg[cur].lazy = combine(seg[cur].lazy, lz);\n            push(cur);\n            return;\n        }\n        if (leaf(cur)) return;\n\n        upd(cur*2, l, r, lz);\n        upd(cur*2+1, l, r, lz);\n        seg[cur].val = combine(seg[cur*2].val, seg[cur*2+1].val);\n    }\n\n    void push(ll cur) {\n        if (!leaf(cur)) {\n            seg[cur*2].lazy = combine(seg[cur*2].lazy, seg[cur].lazy);\n            seg[cur*2+1].lazy = combine(seg[cur*2+1].lazy, seg[cur].lazy);\n        }\n\n        if (seg[cur].lazy.set != 1e9) seg[cur].val = seg[cur].lazy.set;\n        else seg[cur].val += seg[cur].lazy.add * (seg[cur].r - seg[cur].l + 1); // THIS IS WHATS DIFFERENT\n\n        seg[cur].lazy = Lazy(); // set back to default since updated\n    }\n\n    ll query(ll l, ll r) {\n        return query(1, l+1, r+1);\n    }\n\n    ll query(ll cur, ll l, ll r) {\n        push(cur);\n        if (r < seg[cur].l || l > seg[cur].r) return 0;\n        if (l <= seg[cur].l && seg[cur].r <= r) {\n            return seg[cur].val;\n        }\n        return combine(query(cur*2, l, r), query(cur*2+1, l, r));\n    }\n};\n\nclass Solution {\npublic:\n    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n        using ll = long long;\n        int n = s.size();\n\n        vector<int> ps = {0}; for (char c : s) ps.push_back(ps.back() + (c=='1'));\n\n        auto ones = [&](int l, int r) {\n            return ps[r+1]-ps[l];\n        };\n\n        auto zeroes = [&](int l, int r) {\n            return (r-l+1) - ones(l, r);\n        };\n\n        vector<int> end(n);\n        for (int i = 0; i < n; ++i) {\n            int lo = 0, hi = n-1;\n            lo--;\n            while (lo < hi) {\n                int mid = lo + (hi - lo + 1) / 2;\n                if (ones(i, mid) <= k || zeroes(i, mid) <= k) lo = mid;\n                else hi = mid - 1;\n            }\n            end[i] = lo;\n        }\n        int Q = queries.size();\n        vector<pair<pair<int, int>, int>> q;\n        for (int i = 0; i < Q; ++i) q.push_back({{queries[i][0], queries[i][1]}, i});\n        sort(q.rbegin(), q.rend());\n\n        int cur = n-1;\n        vector<ll> ans(Q);\n        SegSum seg(n);\n        for (auto [p, idx] : q) {\n            int l = p.first, r = p.second;\n            while (cur >= l) {\n                seg.upd(cur, end[cur], Lazy(1e9, +1));\n                --cur;\n            }\n            ans[idx] = seg.query(l, r);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1723951601",
    "subm_id": "1359775526"
}