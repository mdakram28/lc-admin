{
    "username": "wjli",
    "submission": "\n\n// COPY ALL MACROS BELOW\n\ntypedef long long LL;\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define LB lower_bound\n#define UB upper_bound\n#define SZ(x) ((int)x.size())\n#define LEN(x) ((int)x.length())\n#define ALL(x) begin(x), end(x)\n#define RSZ resize\n#define ASS assign\n#define REV(x) reverse(x.begin(), x.end());\n#define trav(a, x) for (auto& a : x)\ntypedef pair<LL, LL> PL;\ntypedef vector<LL> VL;\ntypedef vector<PL> VPL;\ntypedef vector<VL> VVL;\ntypedef vector<VVL> VVVL;\ntypedef vector<VVVL> VVVVL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PI;\ntypedef vector<int> VI;\ntypedef vector<PI> VPI;\ntypedef vector<vector<int>> VVI;\ntypedef vector<vector<PI>> VVPI;\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\n#define FOR(i, n) for (int i = 0; i < n; i++) \n#define FOR1(i, n) for (int i = 1; i <= n; i++) \n#define SORT(x) sort(x.begin(), x.end())\n#define RSORT(x) sort(x.rbegin(), x.rend())\n#define SUM(x) accumulate(x.begin(), x.end(), 0LL)\n\n\ntemplate <typename T>\nclass segment_tree {\n    VVL t;\n    int size;\n    LL INF = (1LL << 50);\npublic:\n    //segment_tree(int n, bool range_max = true) {\n    //    size = n;\n    //}\n\n    void initialize_array(vector<int>& v) {\n        size = v.size();\n        t.assign(4 * size + 1, VL(4, 0));\n        initialize_with_array(1, 0, size - 1, v);\n    }\n\n    void initialize_with_array(int startpos, int l, int r, vector<int>& v) {\n        if (l == r) {\n            t[startpos][0] = 0;\n            t[startpos][1] = -INF;\n            t[startpos][2] = -INF;\n            t[startpos][3] = v[l];\n        }\n        else {\n            int m = (l + r) / 2, a = 2 * startpos, b = a + 1;\n            initialize_with_array(a, l, m, v);\n            initialize_with_array(b, m + 1, r, v);\n\n            t[startpos].assign(4, 0);\n            FOR(i, 4) {\n                FOR(j, 4) {\n                    if ((i & 2) && (j & 1)) continue;\n                    int bb = (i & 1) | (j & 2);\n                    t[startpos][bb] = max(t[startpos][bb], t[a][i] + t[b][j]);\n                }\n            }\n        }\n    }\n\n    void update(int index, T val) { // insert val into location index\n        update_full(1, 0, size - 1, index, val);\n    }\n\n    void update_full(int startpos, int l, int r, int index, T val) {\n        if (l == r) {\n            t[startpos][0] = 0;\n            t[startpos][1] = -INF;\n            t[startpos][2] = -INF;\n            t[startpos][3] = val;\n        }\n        else {\n            int m = (l + r) / 2, a = 2 * startpos, b = a + 1;\n            if (index <= m) update_full(2 * startpos, l, m, index, val);\n            else update_full(2 * startpos + 1, m + 1, r, index, val);\n\n            t[startpos].assign(4, 0);\n            FOR(i, 4) {\n                FOR(j, 4) {\n                    if ((i & 2) && (j & 1)) continue;\n                    int bb = (i & 1) | (j & 2);\n                    t[startpos][bb] = max(t[startpos][bb], t[a][i] + t[b][j]);\n                }\n            }\n        }\n    }\n\n    VL query(int l, int r) {  // get range min/max between l and r\n        if (l > r) {\n            VL ans(4, 0);\n            return ans;\n        }\n        return query_full(1, 0, size - 1, l, r);\n    }\n\n    VL query_full(int startpos, int left, int right, int l, int r) {\t // left/right = current range, l/r = intended query range\n        if ((left >= l) && (right <= r)) return t[startpos];\n        int m = (left + right) / 2;\n\n        VL ll(4, 0), rr(4, 0), ans(4, 0);\n\n        if (m >= l) {\n            ll = query_full(startpos * 2, left, m, l, r);\n        }\n        if (m + 1 <= r) {\n            rr = query_full(startpos * 2 + 1, m + 1, right, l, r);\n        }\n\n        FOR(i, 4) {\n            FOR(j, 4) {\n                if ((i & 2) && (j & 1)) continue;\n                int b = (i & 1) | (j & 2);\n                ans[b] = max(ans[b], ll[i] + rr[j]); \n            }\n        }\n\n        return ans;\n    }\n};\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        LL n = nums.size(), i, j, k, q = queries.size(), ans = 0, MOD = 1000000007;\n\n        segment_tree<LL> st;\n        st.initialize_array(nums);\n\n        VL dp(n), maxx(n);\n        FOR(i, n) {\n            dp[i] = max(0, nums[i]);\n            if (i == 0) maxx[i] = nums[i];\n            else if (i >= 2) {\n                dp[i] = max(dp[i], dp[i] + maxx[i - 2]);\n            }\n            if (i > 0) maxx[i] = max(maxx[i - 1], dp[i]);\n        }\n\n        for (auto p : queries) {\n            LL id = p[0], x = p[1], anss = 0;\n            nums[id] = x;\n            st.update(id, x);\n\n            VL ss = st.query(0, n - 1);\n            anss = MAX(ss);\n             ans += anss;\n        }\n        ans %= MOD;\n        return ans;\n    }\n};\n",
    "submit_ts": 1716694272.0
}