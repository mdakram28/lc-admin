{
    "username": "DivyanshJain2003",
    "submission": "class Solution {\npublic:\n    void construct_segment_tree(vector<int>& segtree,\n                            vector<int>& a, int n)\n{\n    // assign values to leaves of the segment tree\n    for (int i = 0; i < n; i++)\n        segtree[n + i] = a[i];\n \n    /* assign values to internal nodes\n    to compute maximum in a given range */\n    for (int i = n - 1; i >= 1; i--)\n        segtree[i] = max(segtree[2 * i],\n                         segtree[2 * i + 1]);\n}\n \nvoid update(vector<int>& segtree, int pos, int value,\n            int n)\n{\n    // change the index to leaf node first\n    pos += n;\n \n    // update the value at the leaf node\n    // at the exact index\n    segtree[pos] = value;\n \n    while (pos > 1) {\n \n        // move up one level at a time in the tree\n        pos >>= 1;\n \n        // update the values in the nodes in\n        // the next higher level\n        segtree[pos] = max(segtree[2 * pos],\n                           segtree[2 * pos + 1]);\n    }\n}\n \nint range_query(vector<int>& segtree, int left, int right, int n)\n{\n    /* Basically the left and right indices will move\n        towards right and left respectively and with\n        every each next higher level and compute the \n        maximum at each height. */\n    // change the index to leaf node first\n    left += n;\n    right += n;\n \n    // initialize maximum to a very low value\n    int ma = INT_MIN;\n \n    while (left < right) {\n \n        // if left index in odd\n        if (left & 1) {\n            ma = max(ma, segtree[left]);\n \n            // make left index even\n            left++;\n        }\n \n        // if right index in odd\n        if (right & 1) {\n \n            // make right index even\n            right--;\n \n            ma = max(ma, segtree[right]);\n        }\n \n        // move to the next higher level\n        left /= 2;\n        right /= 2;\n    }\n    return ma;\n}\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector<bool> ans;\n        set<int> val;\n        vector<int> v(1e5,-1);\n        v[0]=0;\n        val.insert(0);\n        int n = v.size();\n        vector<int> segtree(2 * n);\n        construct_segment_tree(segtree, v, n);\n        for(int i=0;i<queries.size();i++)\n        {\n            if(queries[i][0]==1)\n            {\n                auto it=val.lower_bound(queries[i][1]);\n                if(it!=val.end())\n                {\n                    update(segtree, *it, *it-queries[i][1], n);\n                    v[*it]=*it-queries[i][1];\n                }\n                it--;\n                int x=*it;\n                int f=queries[i][1]-x;\n                v[queries[i][1]]=f;\n                // cout<<queries[i][1]<<f<<endl;\n                update(segtree, queries[i][1], f, n);\n                val.insert(queries[i][1]);\n            }\n            else\n            {\n                auto it=val.lower_bound(queries[i][1]);\n                it--;\n                int x=*it;\n                int f=queries[i][1]-x;\n                if(v[queries[i][1]]==-1)\n                update(segtree, queries[i][1], f, n);\n                int g=range_query(segtree, 0, queries[i][1] + 1, n);\n                // cout<<g<<endl;\n                if(g>=queries[i][2])\n                ans.push_back(true);\n                else\n                ans.push_back(false);\n                if(v[queries[i][1]]==-1)\n                update(segtree, queries[i][1], -1, n);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716651363.0
}