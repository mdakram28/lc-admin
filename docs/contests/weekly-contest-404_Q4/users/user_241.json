{
    "username": "fsshakkhor",
    "submission": "class Solution {\npublic:\n    int Counter;\n    int findD(int numNodes, vector<vector<int>>& edges,int center){\n        vector<vector<int>> adjList(numNodes);\n        vector<int> vis(numNodes, 0);\n\n        // Build adjacency list and compute degrees\n        for (const vector<int>& edge : edges) {\n          adjList[edge[0]].push_back(edge[1]);\n          adjList[edge[1]].push_back(edge[0]);\n        }\n        queue<int>Q;\n        Q.push(center);\n        vis[center] = 1;\n        int ans = 1;\n        while(!Q.empty()){\n            int node = Q.front();\n            Q.pop();\n            for(int to : adjList[node]){\n                if(vis[to])continue;\n                Q.push(to);\n                vis[to] = vis[node] + 1;\n                ans = max(ans,vis[to]);\n            }\n        }\n        return ans;\n        \n    }\n    vector<int> findCenters(int numNodes, vector<vector<int>>& edges) {\n        vector<vector<int>> adjList(numNodes);\n        vector<int> nodeDegrees(numNodes, 0);\n\n        // Build adjacency list and compute degrees\n        for (const vector<int>& edge : edges) {\n          adjList[edge[0]].push_back(edge[1]);\n          adjList[edge[1]].push_back(edge[0]);\n          nodeDegrees[edge[0]]++;\n          nodeDegrees[edge[1]]++;\n        }\n\n        // Find leaves (nodes with degree 1 or 0)\n        vector<int> leaves;\n        for (int i = 0; i < numNodes; ++i) {\n          if (nodeDegrees[i] <= 1) {\n            leaves.push_back(i);\n            nodeDegrees[i] = 0; // Mark as processed\n          }\n        }\n\n        int totalLeaves = leaves.size();\n        while (totalLeaves < numNodes) {\n            Counter += 2;\n            vector<int> newLeaves;\n          for (int leaf : leaves) {\n            for (int neighbor : adjList[leaf]) {\n              nodeDegrees[neighbor]--;\n              if (nodeDegrees[neighbor] == 1) {\n                newLeaves.push_back(neighbor);\n              }\n            }\n          }\n          totalLeaves += newLeaves.size();\n          leaves = newLeaves;\n        }\n\n        return leaves;\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        vector<int>centers1 = findCenters(n, edges1);\n        vector<int>centers2 = findCenters(m, edges2);\n        \n        for(int i = 0;i < edges2.size();i++){\n            edges1.push_back({edges2[i][0] + n, edges2[i][1] + n});\n        }\n        edges1.push_back({centers1[0], centers2[0] + n});\n        \n        Counter = 0;\n        vector<int>centers = findCenters(n + m, edges1);\n        if(centers.size() != 1)Counter++;\n        return Counter;\n\n    }\n};",
    "submit_ts": "1719718019",
    "subm_id": "1304406720"
}