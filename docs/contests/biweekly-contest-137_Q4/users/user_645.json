{
    "username": "Shreya Pandey",
    "submission": "class Solution {\npublic:\nlong long maximumValueSum(vector<vector<int>>& board) {\n    int m = board.size();\n    int n = board[0].size();\n    \n    // Step 1: Find top 3 elements in each row\n    vector<vector<pair<int, int>>> topThree(m);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            topThree[i].push_back({board[i][j], j});\n        }\n        partial_sort(topThree[i].begin(), topThree[i].begin() + min(3, (int)topThree[i].size()), topThree[i].end(),\n                     greater<pair<int, int>>());\n        topThree[i].resize(min(3, (int)topThree[i].size()));\n    }\n    \n    // Step 2: Sort rows based on their maximum element\n    vector<int> rowOrder(m);\n    iota(rowOrder.begin(), rowOrder.end(), 0);\n    sort(rowOrder.begin(), rowOrder.end(),\n         [&](int a, int b) { return topThree[a][0].first > topThree[b][0].first; });\n    \n    long long maxSum = LLONG_MIN;\n    \n    // Step 3: Generate combinations and check column constraint\n    for (int i = 0; i < min(5, m); i++) {\n        for (int j = i + 1; j < min(6, m); j++) {\n            for (int k = j + 1; k < min(7, m); k++) {\n                for (auto& x : topThree[rowOrder[i]]) {\n                    for (auto& y : topThree[rowOrder[j]]) {\n                        for (auto& z : topThree[rowOrder[k]]) {\n                            if (x.second != y.second && y.second != z.second && z.second != x.second) {\n                                maxSum = max(maxSum, (long long)x.first + y.first + z.first);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return maxSum;\n}\n};",
    "submit_ts": "1723909460",
    "subm_id": "1359193431"
}