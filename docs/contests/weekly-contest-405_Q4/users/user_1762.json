{
    "username": "raararaara",
    "submission": "#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n// using lint = long long;\nusing lint = unsigned long long;\n\n#define all(x) (x).begin(),(x).end()\n#define compress(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())\nconst int mxn = 100010, INF = 1e9+7, MOD = 1000001333;\nconst lint p = 27;\n\nclass Solution {\npublic:\n    int minimumCost(string s, vector<string>& words, vector<int>& costs) {\n        int N = int(size(words));\n        int M = int(s.length());\n        vector<lint> pw(M);\n        vector<lint> h, hArr(N), d(M+1, INF);\n        vector<int> lengthList;\n        vector<unordered_map<lint, int>> dict, w;\n        auto toInt = [&](string &str) {\n            lint ret = 0;\n            for (int i = 0; str[i]; i++) {\n                ret = ret * p + (str[i] - 'A' + 1);\n//                ret %= MOD;\n            }\n\n            return ret;\n        };\n        auto build = [&](int i) {\n            for (int j = 0; j < (int) lengthList.size(); j++) {\n                int l = lengthList[j];\n                if (i - l < 0) {\n                    h[j] = h[j] * p + (s[i] - 'A' + 1);\n//                    h[j] %= MOD;\n                } else {\n                    h[j] = h[j] * p - pw[l] * (s[i - l] - 'A' + 1) + (s[i] - 'A' + 1);\n//                    h[j] %= MOD;\n                }\n            }\n        };\n        pw[0] = 1;\n        for (int i = 1; i < M; i++) {\n            pw[i] = pw[i - 1] * p;\n//            pw[i] %= MOD;\n        }\n\n        \n        for (int i = 0; i < N; i++) {\n            hArr[i] = toInt(words[i]);\n            lengthList.emplace_back(words[i].length());\n        }\n\n        compress(lengthList);\n        dict.resize((int) lengthList.size());\n        w.resize((int) lengthList.size());\n        h.resize((int) lengthList.size());\n        for (int i = 0; i < N; i++) {\n            int lIdx = int(lower_bound(all(lengthList), (int) words[i].length()) - lengthList.begin());\n            dict[lIdx][hArr[i]] = i;\n            if(w[lIdx].find(hArr[i]) == w[lIdx].end()) {\n                w[lIdx][hArr[i]] = costs[i];\n            } else w[lIdx][hArr[i]] = min(costs[i], w[lIdx][hArr[i]]);\n        }\n\n        for (int i = 0; s[i]; i++) {\n            build(i);\n            for (int lIdx = 0; lIdx < (int) lengthList.size(); lIdx++) {\n                int l = lengthList[lIdx];\n                if (i - l + 1 < 0) break;\n\n                lint hash = h[lIdx];\n                if (dict[lIdx].find(hash) != dict[lIdx].end()) {\n                    if(i-l==-1) d[i] = min(d[i], lint(w[lIdx][hash]));\n                    else d[i] = min(d[i], d[i-l] + w[lIdx][hash]);\n                }\n            }\n        }\n        if(d[(int) s.length() - 1] == INF) d[(int) s.length() - 1] = -1;\n        return d[(int) s.length() - 1];\n    }\n};\n",
    "submit_ts": "1720322358",
    "subm_id": "1312347752"
}