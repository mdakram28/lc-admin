{
    "username": "tepamid",
    "submission": "\n#define fo(i, n) for (int i = 0; i < n; ++i)\n#define foback(i, n) for (int i = n - 1; i >= 0; --i)\n#define fo1(i, n) for (int i = 1; i <= n; ++i)\n\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define makeunique(x) sort(all(x)), (x).resize(unique(all(x)) - (x).begin())\n\ntypedef long long ll;\n\nstruct segtree\n{\n    typedef ll Node;\n\n    Node op(Node lv, Node rv)\n    {\n        return lv + rv;\n    }\n\n    void setLeaf(int x, Node v)\n    {\n        tree[x] = v;\n    }\n\n    const Node ZERO = 0;\n\n    vector<Node> tree;\n    int size;\n\n    void init(int n)\n    {\n        size = 1;\n        while (size < n)\n            size *= 2;\n        tree.assign(2 * size - 1, ZERO);\n    }\n\n    void build(const vector<Node> &a, int x, int lx, int rx)\n    {\n        if (rx - lx == 1)\n        {\n            if (lx < a.size())\n                setLeaf(x, a[lx]);\n            return;\n        }\n\n        int m = (lx + rx) / 2;\n        build(a, getLeftChild(x), lx, m);\n        build(a, getRightChild(x), m, rx);\n\n        tree[x] = op(tree[getLeftChild(x)], tree[getRightChild(x)]);\n    }\n\n    void build(const vector<Node> &a)\n    {\n        init(a.size());\n        build(a, 0, 0, size);\n    }\n\n    void set(int i, Node v)\n    {\n        set(i, v, 0, 0, size);\n    }\n\n    void set(int i, Node v, int x, int lx, int rx)\n    {\n        if (rx - lx == 1)\n        {\n            setLeaf(x, v);\n            return;\n        }\n\n        int m = (lx + rx) / 2;\n        if (i < m)\n        {\n            set(i, v, getLeftChild(x), lx, m);\n        }\n        else\n        {\n            set(i, v, getRightChild(x), m, rx);\n        }\n\n        tree[x] = op(tree[getLeftChild(x)], tree[getRightChild(x)]);\n    }\n\n    Node get(int l, int r, int x, int lx, int rx)\n    {\n        if (lx >= r || l >= rx)\n        {\n            return ZERO;\n        }\n\n        if (lx >= l && rx <= r)\n        {\n            return tree[x];\n        }\n\n        int m = (lx + rx) / 2;\n        auto s1 = get(l, r, getLeftChild(x), lx, m);\n        auto s2 = get(l, r, getRightChild(x), m, rx);\n        return op(s1, s2);\n    }\n\n    Node get(int l, int r)\n    {\n        return get(l, r, 0, 0, size);\n    }\n\n    int getLeftChild(int x)\n    {\n        return 2 * x + 1;\n    }\n\n    int getRightChild(int x)\n    {\n        return 2 * x + 2;\n    }\n};\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& qs) {\n        vector<int> ans;//(qs.size());\n        \n        segtree st;\n        st.init(a.size());\n        \n        int n = a.size();\n        for(int i=1; i+1<n; i++) {\n            if (a[i-1] < a[i] && a[i] > a[i+1]) {\n                st.set(i,1);\n            }\n        }\n        \n        fo(qi,qs.size()) {\n            // auto [t,l,r] = qs[qi];\n            auto t = qs[qi][0];\n            auto l = qs[qi][1];\n            auto r = qs[qi][2];\n            \n            if (t==1) {\n                l++;\n                // r++;\n                \n                int cur = st.get(l,r);\n                ans.push_back(cur);\n            } else {\n                int I = l;\n                int val = r;\n                \n                a[I] = val;\n                \n                for(auto i : {I-1,I,I+1}) {\n                    if (i>0 && i+1<n) {\n                        if (a[i-1] < a[i] && a[i] > a[i+1]) {\n                            st.set(i,1);\n                        } else {\n                            st.set(i,0);\n                        }\n                    }\n                }\n            }\n        }\n        \n        \n        return ans;\n    }\n};",
    "submit_ts": 1718506535.0
}