{
    "username": "winter_dragon",
    "submission": "class Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        N = len(points)\n        BIG = 10**10\n        \n        def max_manhattan(points):\n            heap1, heap2, heap3, heap4 = [], [], [], []\n            ret = 0\n            N = len(points)\n            for i in range(N - 1, -1, -1):\n                x, y = points[i]\n                if heap1:\n                    v1 = -heap1[0]\n                    ret = max(ret, v1 - x - y)\n                    v2 = -heap2[0]\n                    ret = max(ret, v2 - x + y)\n                    v3 = heap3[0]\n                    ret = max(ret, abs(v3 - x - y))\n                    v4 = heap4[0]\n                    ret = max(ret, abs(v4 - x + y))\n                \n                heapq.heappush(heap1, -x - y)\n                heapq.heappush(heap2, -x + y)\n                heapq.heappush(heap3, x + y)\n                heapq.heappush(heap4, x - y)\n            return ret\n        \n        print(max_manhattan(points))\n\n        combiners = [lambda x, y: x - y, lambda x, y : x + y, lambda x, y: x, lambda x, y: y]\n        ret = BIG\n\n        for comb in combiners:\n            points.sort(key=lambda p: comb(p[0], p[1]))\n            for _ in range(2):\n                p1 = points.pop()\n                ret = min(ret, max_manhattan(points))\n                points.append(p1)\n                points = points[::-1]\n        \n        return ret\n"
}