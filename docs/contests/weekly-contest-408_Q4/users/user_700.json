{
    "username": "tilak_raj_dixit",
    "submission": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool bfs(const vector<vector<int>>& adjList, int src, int target1, int target2, int totalNodes) {\n        queue<int> toVisit;\n        vector<int> visited(totalNodes + 4, 0);\n        toVisit.push(src);\n        visited[src] = 1;\n\n        while (!toVisit.empty()) {\n            int currentNode = toVisit.front();\n            toVisit.pop();\n            for (int neighbor : adjList[currentNode]) {\n                if (!visited[neighbor]) {\n                    toVisit.push(neighbor);\n                    visited[neighbor] = 1;\n                }\n            }\n        }\n        return visited[target1] || visited[target2];\n    }\n\n    bool canReachCorner(int X, int Y, const vector<vector<int>>& circles) {\n        vector<pair<pair<int, int>, int>> circleData(circles.size());\n        vector<vector<int>> adjList(circles.size() + 4);\n        int totalCircles = circles.size();\n        for (int i = 0; i < totalCircles; ++i) {\n            circleData[i].first.first = circles[i][0];\n            circleData[i].first.second = circles[i][1];\n            circleData[i].second = circles[i][2];\n        }\n        for (int i = 0; i < totalCircles; ++i) {\n            if (circleData[i].first.first <= circleData[i].second) {\n                adjList[totalCircles].push_back(i);\n                adjList[i].push_back(totalCircles);\n            }\n            if (X - circleData[i].first.first <= circleData[i].second) {\n                adjList[totalCircles + 2].push_back(i);\n                adjList[i].push_back(totalCircles + 2);\n            }\n            if (circleData[i].first.second <= circleData[i].second) {\n                adjList[totalCircles + 1].push_back(i);\n                adjList[i].push_back(totalCircles + 1);\n            }\n            if (Y - circleData[i].first.second <= circleData[i].second) {\n                adjList[totalCircles + 3].push_back(i);\n                adjList[i].push_back(totalCircles + 3);\n            }\n            for (int j = i + 1; j < totalCircles; ++j) {\n                double dist = sqrt(pow(circleData[i].first.first - circleData[j].first.first, 2) +\n                                   pow(circleData[i].first.second - circleData[j].first.second, 2));\n                int combinedRadius = circleData[i].second + circleData[j].second;\n                if (combinedRadius >= dist) {\n                    adjList[i].push_back(j);\n                    adjList[j].push_back(i);\n                }\n            }\n        }\n        bool canReach = false;\n        canReach = max(canReach, bfs(adjList, totalCircles, totalCircles + 1, totalCircles + 2, totalCircles + 4));\n        canReach = max(canReach, bfs(adjList, totalCircles + 3, totalCircles + 2, totalCircles + 1, totalCircles + 4));\n\n        return !canReach;\n    }\n};\n\n",
    "submit_ts": "1722138371",
    "subm_id": "1335789060"
}