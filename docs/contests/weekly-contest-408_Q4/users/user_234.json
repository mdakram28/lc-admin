{
    "username": "Sundae2608",
    "submission": "def distance(c1, c2):\n    return math.sqrt((c1[0] - c2[0]) ** 2 + (c1[1] - c2[1]) ** 2)\n\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # Adjacency list for the graph\n        graph = defaultdict(list)\n        top_left = 'top-left'\n        bottom_right = 'bottom-right'\n        \n        # Add connections between circles\n        n = len(circles)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if distance(circles[i], circles[j]) <= circles[i][2] + circles[j][2]:\n                    graph[i].append(j)\n                    graph[j].append(i)\n        \n        # Connect circles to top-left and bottom-right\n        for i in range(n):\n            cx, cy, r = circles[i]\n            if cx - r <= 0 or cy + r >= Y:\n                graph[top_left].append(i)\n                graph[i].append(top_left)\n            if cx + r >= X or cy - r <= 0:\n                graph[bottom_right].append(i)\n                graph[i].append(bottom_right)\n        \n        # BFS to check connectivity from top-left to bottom-right\n        queue = deque([top_left])\n        visited = set([top_left])\n        \n        while queue:\n            node = queue.popleft()\n            if node == bottom_right:\n                return False\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        \n        return True",
    "submit_ts": "1722136376",
    "subm_id": "1335732462"
}