{
    "username": "parascoding",
    "submission": "class Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int a[] = new int[n - 2];\n        SegTree seg = new SegTree(n);\n        for(int i = 1; i < n - 1; i++){\n            if(nums[i] > nums[i - 1] && nums[i] > nums[i + 1]){\n                a[i - 1] = 1;\n                seg.update(i, 1);\n            }\n                \n        }\n        \n        // seg.build(a);\n        List<Integer> list = new ArrayList<>();\n        // for(int i = 0; i < nums.length; i++)\n        //         System.out.print(seg.find(i, i) + \" \");\n        //     System.out.println();\n        for(int x[] : queries){\n            if(x[0] == 1){\n                int l = x[1], r = x[2];\n                if(r - l < 2){\n                    list.add(0);\n                }\n                else\n                list.add((int)(seg.find(x[1]   + 1, x[2] - 1)));\n            } else{\n                int ind = x[1], val = x[2];\n                nums[ind] = val;\n                if(ind > 0 && ind < n - 1){\n                    if(val > nums[ind - 1] && val > nums[ind + 1])\n                        seg.update(ind, 1);\n                    else\n                        seg.update(ind, 0);\n                }\n                if(ind + 2 < n){\n                    if(nums[ind + 1] > nums[ind] && nums[ind + 2] < nums[ind + 1])\n                        seg.update(ind + 1, 1);\n                    else\n                        seg.update(ind + 1, 0);\n                }\n                if(ind - 2 > -1){\n                    if(nums[ind - 1] > nums[ind] && nums[ind - 1] > nums[ind - 2])\n                        seg.update(ind - 1, 1);\n                    else{\n                        seg.update(ind - 1, 0);\n                        // System.out.println(\"Updating to 0 \"+(ind - 1));\n                    }\n                        \n                }\n            }\n            // for(int i = 0; i < nums.length; i++)\n            //     System.out.print(seg.find(i, i) + \" \");\n            // System.out.println();\n        }\n        return list;\n    }\n}\nclass SegTree{\n    // Fix range to be [1, 10^5]\n    long seg[], lazy[];\n    int  n, m;\n    \n    SegTree(int n){\n        this.n = n;\n        this.seg = new long[n << 2];\n        this.lazy = new long[n << 2];\n        // this.m = m;\n    }\n    void build(int a[]){\n        build(0, n - 1, 0, a);\n    }\n    void build(int low, int high, int node, int a[]){\n        if(low == high){\n            seg[node] = a[low];\n            return;\n        }\n        int mid = (low + high) >> 1;\n        build(low, mid, (node << 1) + 1, a);\n        build(mid + 1, high, (node << 1) + 2, a);\n        seg[node] = seg[(node << 1) + 1] + seg[(node << 1) + 2];\n    }\n    long find(int l, int r){\n        if(l > r)\n            return 0;\n        return find(0, n - 1, l, r, 0);\n    }\n    void push(int low, int high, int node){\n        if(low > high || lazy[node] == 0)\n            return;\n        seg[node] ^= lazy[node];\n        if(low != high){\n            lazy[(node << 1) + 1] ^= lazy[node];\n            lazy[(node << 1) + 2] ^= lazy[node];\n        }\n        lazy[node] = 0;\n    }\n    long find(int low, int high, int l, int r, int node){\n        push(low, high, node);\n        if(low > r || high < l)\n            return 0;\n        if(low >= l && high <= r)\n            return seg[node];\n        int mid = (low + high) >> 1;\n        long left = find(low, mid, l, r, (node << 1) + 1);\n        long right = find(mid + 1, high, l, r, (node << 1) + 2);\n        return left + right;\n    }\n    void update(int ind, long val){\n        \n        update(0, n - 1, ind, val, 0);\n    }\n    void update(int low, int high, int ind, long val, int node){\n        if(low == high){\n            seg[node] = val;\n            return;\n        }\n        int mid = (low + high) >> 1;\n        if(ind <= mid)\n            update(low, mid, ind, val, (node << 1) + 1);\n        else\n            update(mid + 1, high, ind, val, (node << 1) + 2);\n        seg[node] = seg[(node << 1) + 1] +  seg[(node << 1) + 2];\n    }   \n}\n",
    "submit_ts": 1718507599.0
}