{
    "username": "qb_2008",
    "submission": "class Solution {\npublic:\n    struct Node {\n        int peak = 0;  \n    };\n    \n    vector<Node> segtree;\n    int n = 0;\n    \n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int size = nums.size();\n        n = 1;\n        while (n < size) {\n            n <<= 1;\n        }\n        segtree = vector<Node>(n * 2);\n        initSegtree(nums, 0, 0, n - 1);\n        vector<int> res;\n        for (auto& q : queries) {\n            if (q[0] == 2) {\n                nums[q[1]] = q[2];\n                updateSegtree(nums, 0, 0, n - 1, q[1]);\n            } else if (q[0] == 1) {\n                int ret = findSegtree(nums, 0, 0, n - 1, q[1], q[2]);\n                res.push_back(ret);\n            }\n        }\n        return res;\n    }\n    \n    void initSegtree(vector<int>& nums, int cur, int low, int high) {\n        if (low + 1 >= high) {\n            return;\n        }\n        int mid = (low + high) / 2;\n        initSegtree(nums, cur * 2 + 1, low, mid);\n        initSegtree(nums, cur * 2 + 2, mid + 1, high);\n        int peak = segtree[cur * 2 + 1].peak + segtree[cur * 2 + 2].peak;\n        // check mid\n        if (mid > 0 && mid > low && mid + 1 < nums.size() && mid < high) {\n            if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {\n                peak++;\n            }\n        }\n        // check mid + 1\n        if (mid + 2 < nums.size() && mid + 1 < high) {\n            if (nums[mid + 1] > nums[mid] && nums[mid + 1] > nums[mid + 2]) {\n                peak++;\n            }\n        }\n        segtree[cur].peak = peak;\n    }\n    \n    void updateSegtree(vector<int>& nums, int cur, int low, int high, int update_pos) {\n        if (low + 1 >= high) {\n            return;\n        }\n        int mid = (low + high) / 2;\n        if (update_pos <= mid) {\n            updateSegtree(nums, cur * 2 + 1, low, mid, update_pos);\n        } else {\n            updateSegtree(nums, cur * 2 + 2, mid + 1, high, update_pos);\n        }\n        int peak = segtree[cur * 2 + 1].peak + segtree[cur * 2 + 2].peak;\n        // check mid\n        if (mid > 0 && mid > low && mid + 1 < nums.size() && mid < high) {\n            if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {\n                peak++;\n            }\n        }\n        // check mid + 1\n        if (mid + 2 < nums.size() && mid + 1 < high) {\n            if (nums[mid + 1] > nums[mid] && nums[mid + 1] > nums[mid + 2]) {\n                peak++;\n            }\n        }\n        segtree[cur].peak = peak;\n    }\n    \n    int findSegtree(vector<int>& nums, int cur, int low, int high, int low_limit, int high_limit) {\n        if (low >= low_limit && high <= high_limit) {\n            return segtree[cur].peak;\n        }\n        if (low >= high_limit || high <= low_limit) {\n            return 0;\n        }\n        if (low + 1 >= high) {\n            return 0;\n        }\n        int mid = (low + high) / 2;\n        int peak = 0;\n        peak += findSegtree(nums, cur * 2 + 1, low, mid, low_limit, high_limit);\n        peak += findSegtree(nums, cur * 2 + 2, mid + 1, high, low_limit, high_limit);\n        // check mid\n        if (mid > low && mid > low_limit && mid < high && mid < high_limit) {\n            if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {\n                peak++;\n            }\n        }\n        // check mid + 1\n        if (mid + 1 > low_limit && mid + 1 < high_limit && mid + 1 < high) {\n            if (nums[mid + 1] > nums[mid] && nums[mid + 1] > nums[mid + 2]) {\n                peak++;\n            }\n        }\n        return peak;\n    }\n    \n    \n};",
    "submit_ts": 1718507789.0
}