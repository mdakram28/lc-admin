{
    "username": "KatherineLiu",
    "submission": "class Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        def computeMaxDistance(points):\n            min_sum, max_sum = float('inf'), float('-inf')\n            min_diff, max_diff = float('inf'), float('-inf')\n\n            for x, y in points:\n                sum_ = x + y\n                diff = x - y\n\n                min_sum = min(min_sum, sum_)\n                max_sum = max(max_sum, sum_)\n                min_diff = min(min_diff, diff)\n                max_diff = max(max_diff, diff)\n\n            # The maximum Manhattan distance is the larger of the two extreme differences\n            maximum_distance = max(max_sum - min_sum, max_diff - min_diff)\n            return maximum_distance\n        N = len(points)\n    \n        # Initial setup: assume first point contributes to all extremes\n        min_sum, max_sum, min_diff, max_diff = points[0][0] + points[0][1], points[0][0] + points[0][1], points[0][0] - points[0][1], points[0][0] - points[0][1]\n        indices_min_sum, indices_max_sum, indices_min_diff, indices_max_diff = [0], [0], [0], [0]\n\n        # Compute extremes and track contributing point indices\n        for i in range(1, N):\n            sum_ = points[i][0] + points[i][1]\n            diff = points[i][0] - points[i][1]\n\n            if sum_ < min_sum:\n                min_sum, indices_min_sum = sum_, [i]\n            elif sum_ == min_sum:\n                indices_min_sum.append(i)\n\n            if sum_ > max_sum:\n                max_sum, indices_max_sum = sum_, [i]\n            elif sum_ == max_sum:\n                indices_max_sum.append(i)\n\n            if diff < min_diff:\n                min_diff, indices_min_diff = diff, [i]\n            elif diff == min_diff:\n                indices_min_diff.append(i)\n\n            if diff > max_diff:\n                max_diff, indices_max_diff = diff, [i]\n            elif diff == max_diff:\n                indices_max_diff.append(i)\n\n        # Initial maximum distance\n        maximum = max(max_sum - min_sum, max_diff - min_diff)\n\n        # To store the minimum of the recalculated maximum distances\n        min_max_distance_after_removal = float('inf')\n\n        # Set of unique indices to consider for removal\n        unique_indices = set(indices_min_sum + indices_max_sum + indices_min_diff + indices_max_diff)\n\n        # Evaluate removal of each contributing point\n        for index in unique_indices:\n            new_points = points[:index] + points[index+1:]\n\n            # Recompute maximum distance without this point\n            new_max_distance = computeMaxDistance(new_points) # Assume computeMaxDistance is implemented\n\n            min_max_distance_after_removal = min(min_max_distance_after_removal, new_max_distance)\n\n        return min_max_distance_after_removal\n\n\t\n            "
}