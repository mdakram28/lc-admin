{
    "username": "DylanSmith",
    "submission": "typedef long long ll;\n \n#define pb push_back\n#define sz(x) (int)x.size()\n#define all(x) begin(x),end(x)\n#define lb(x,y) lower_bound(all(x),y)-begin(x)\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int N = sz(circles);\n        vector<vector<int>> adj(N + 2);\n        for (int i = 0; i < sz(circles); i++) {\n            for (int j = 0; j < sz(circles); j++) {\n                int dx = circles[i][0] - circles[j][0], dy = circles[i][1] - circles[j][1];\n                int r = circles[i][2] + circles[j][2];\n                if ((ll)dx * dx + (ll)dy * dy <= (ll)r * r) {\n                    adj[i].pb(j);\n                    adj[j].pb(i);\n                }\n            }\n            int x = circles[i][0], y = circles[i][1], r = circles[i][2];\n            if (x - r <= 0 || y + r >= Y) {\n                adj[N].pb(i);\n                adj[i].pb(N);\n            }\n            if (x + r >= X || y - r <= 0) {\n                adj[N + 1].pb(i);\n                adj[i].pb(N + 1);\n            }\n        }\n        queue<int> q; q.push(N);\n        vector<bool> vis(N + 2, 0);\n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            for (int v : adj[u]) {\n                if (vis[v]) continue;\n                vis[v] = 1;\n                q.push(v);\n            }\n        }\n        return !vis[N + 1];\n    }\n};",
    "submit_ts": "1722135260",
    "subm_id": "1335695612"
}