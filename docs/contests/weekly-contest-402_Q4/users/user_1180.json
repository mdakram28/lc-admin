{
    "username": "starryxsky",
    "submission": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint op(int a, int b){\n    return a+b;\n}\n\nint e() {\n    return 0;  // e() + a[i] = a[i]\n}\n\ntemplate <class S, S (*op)(S, S), S (*e)()>\nstruct SegTree {\n    int n, size, log;\n    vector<S> d;\n    SegTree() : SegTree(0) {}\n    explicit SegTree(int n) : SegTree(vector<S>(n, e())) {}\n    explicit SegTree(const vector<S> &v) : n(int(v.size())) {\n        log = ceil_lg(n), size = 1 << log;\n        d = vector<S>(2 * size, e());\n        for (int i = 0; i < n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) pull(i);\n    }\n    int ceil_lg(int x) {   // minimum non-neg x s.t. `n <= 2^x`\n        return x <= 1 ? 0 : 32 - __builtin_clz(x - 1);\n    }\n    void set(int p, S x) {  // assert(0 <= p < n)\n        p += size, d[p] = x;\n        for (int i = 1; i <= log; ++i) pull(p >> i);\n    }\n    S get(int p) const { return d[p + size];}\n    S get(int l, int r) {   // [l, r)\n        S sl = e(), sr = e();\n        l += size, r += size;\n        while (l < r) {\n            if (l & 1) sl = op(sl, d[l++]);\n            if (r & 1) sr = op(d[--r], sr);\n            l >>= 1, r >>= 1;\n        }\n        return op(sl, sr);\n    }\n    S get_all() const {return d[1];}\n\n    void pull(int k) { d[k] = op(d[2 * k], d[2 * k + 1]);}\n    template <bool (*f)(S)> int max_right(int l) const {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F>     // 0 <= l <= n, f(e()) is true\n    int max_right(int l, F f) const { \n        if (l == n) return n;\n        l += size;\n        S x = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(x, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(x, d[l]))) {\n                        x = op(x, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            x = op(x, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return n;\n    }\n    template <bool (*f)(S)> int min_left(int r) const {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F>  // 0 <= r <= n, f(e()) is true\n    int min_left(int r, F f) const {\n        if (r == 0) return 0;\n        r += size;\n        S x = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], x))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], x))) {\n                        x = op(d[r], x);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            x = op(d[r], x);\n        } while ((r & -r) != r);\n        return 0;\n    }\n};\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> ans;\n        int n = nums.size();\n        vector<int> status(n, 0);\n        for(int i = 1; i < n-1; ++i){\n            if(nums[i] > nums[i-1] && nums[i] > nums[i+1])status[i] = 1;\n        }\n        SegTree<int, op, e> seg(status);\n        for(auto q : queries){\n            if(q[0] == 1){\n                int l = q[1], r = q[2];\n                int tmp = seg.get(l+1,r);\n                // cout<<l+1<<\",\"<<r-1<<\";\"<<tmp<<\";\";\n                // for(int j = l+1; j <= r-1; ++j)cout<<status[j]<<\" \";\n                // cout<<endl;\n                ans.push_back(tmp);\n            }\n\n            if(q[0] == 2){\n                int idx = q[1];\n                int v = q[2];\n                nums[idx] = v;\n                for(int k = idx-1; k <= idx+1; ++k){\n                    int flip = 0;\n                    if(k <= 0 || k >= n-1)continue;\n                    if(k > 0 && k < n-1 && nums[k] > nums[k-1] && nums[k] > nums[k+1]){\n                        flip = 1;\n                    }\n                    // cout<<\"k:\"<<k<<\"flip\"<<flip<<\" yuan:\"<<status[k]<<endl;;\n                    if(status[k] != flip){\n                        seg.set(k, flip);\n                        status[k] = flip;\n                    }\n\n                }                \n            }\n        }\n        return ans;\n    }\n};\n",
    "submit_ts": "1718508820",
    "subm_id": "539789491"
}