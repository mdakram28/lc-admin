{
    "username": "LayCurse",
    "submission": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"inline\")\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<class T> struct cLtraits_identity{\n  using type = T;\n}\n;\ntemplate<class T> using cLtraits_try_make_signed =\n  typename conditional<\n    is_integral<T>::value,\n    make_signed<T>,\n    cLtraits_identity<T>\n    >::type;\ntemplate <class S, class T> struct cLtraits_common_type{\n  using tS = typename cLtraits_try_make_signed<S>::type;\n  using tT = typename cLtraits_try_make_signed<T>::type;\n  using type = typename common_type<tS,tT>::type;\n}\n;\ntemplate<class S, class T> inline auto max_L(S a, T b)\n-> typename cLtraits_common_type<S,T>::type{\n  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;\n}\ntemplate<class S, class T> inline S chmin(S &a, T b){\n  if(a>b){\n    a=b;\n  }\n  return a;\n}\nstruct Rand{\n  unsigned x;\n  unsigned y;\n  unsigned z;\n  unsigned w;\n  Rand(void){\n    x=123456789;\n    y=362436069;\n    z=521288629;\n    w=(unsigned)time(NULL);\n  }\n  Rand(unsigned seed){\n    x=123456789;\n    y=362436069;\n    z=521288629;\n    w=seed;\n  }\n  inline unsigned get(void){\n    unsigned t;\n    t = (x^(x<<11));\n    x=y;\n    y=z;\n    z=w;\n    w = (w^(w>>19))^(t^(t>>8));\n    return w;\n  }\n  inline double getUni(void){\n    return get()/4294967296.0;\n  }\n  inline int get(int a){\n    return (int)(a*getUni());\n  }\n  inline int get(int a, int b){\n    return a+(int)((b-a+1)*getUni());\n  }\n  inline long long get(long long a){\n    return(long long)(a*getUni());\n  }\n  inline long long get(long long a, long long b){\n    return a+(long long)((b-a+1)*getUni());\n  }\n  inline double get(double a, double b){\n    return a+(b-a)*getUni();\n  }\n  inline int getExp(int a){\n    return(int)(exp(getUni()*log(a+1.0))-1.0);\n  }\n  inline int getExp(int a, int b){\n    return a+(int)(exp(getUni()*log((b-a+1)+1.0))-1.0);\n  }\n}\n;\ntemplate<class T, class U> inline T GCD_L(T a, U b){\n  T r;\n  while(b){\n    r=a;\n    a=b;\n    b=r%a;\n  }\n  return a;\n}\n#define ROLLING_HASH_MOD (2305843009213693951ULL)\n#define ROLLING_HASH_PRIMITIVE_ROOT (3)\n#define ROLLING_HASH_MAX_MEMORY (2000000)\nint ROLLING_HASH_MEM;\nunsigned long long ROLLING_HASH_BASE;\nunsigned long long ROLLING_HASH_IBASE;\nunsigned long long*ROLLING_HASH_PW = NULL;\nunsigned long long*ROLLING_HASH_IPW = NULL;\ninline unsigned long long rollingHash61_mul(unsigned long long a, unsigned long long b){\n  __uint128_t r = (__uint128_t) a * b;\n  a = (r >> 61) + (r & ROLLING_HASH_MOD);\n  if(a >= ROLLING_HASH_MOD){\n    a -= ROLLING_HASH_MOD;\n  }\n  return a;\n}\ninline unsigned long long rollingHash61_pow(unsigned long long a, unsigned long long b){\n  unsigned long long r = 1;\n  for(;;){\n    if(b&1){\n      r = rollingHash61_mul(r, a);\n    }\n    if(b==0){\n      break;\n    }\n    b >>= 1;\n    a = rollingHash61_mul(a, a);\n  }\n  return r;\n}\nvoid rollingHashInit(){\n  int i;\n  Rand rnd;\n  unsigned long long x;\n  for(i=(0);i<(20);i++){\n    rnd.get(2);\n  }\n  do{\n    x = rnd.get(1.0, (double)(ROLLING_HASH_MOD-2));\n  }\n  while(GCD_L(x, ROLLING_HASH_MOD-1)!= 1);\n  ROLLING_HASH_BASE = rollingHash61_pow(ROLLING_HASH_PRIMITIVE_ROOT, x);\n  ROLLING_HASH_IBASE = rollingHash61_pow(ROLLING_HASH_BASE, ROLLING_HASH_MOD - 2);\n}\nvoid rollingHash_expand(int k){\n  int i;\n  if(ROLLING_HASH_MEM >= k){\n    return;\n  }\n  ROLLING_HASH_MEM =max_L(2 * ROLLING_HASH_MEM, k);\n  assert(ROLLING_HASH_MEM <= 2 * ROLLING_HASH_MAX_MEMORY);\n  ROLLING_HASH_PW = (unsigned long long*) realloc(ROLLING_HASH_PW, ROLLING_HASH_MEM * sizeof(unsigned long long));\n  ROLLING_HASH_IPW = (unsigned long long*) realloc(ROLLING_HASH_IPW, ROLLING_HASH_MEM * sizeof(unsigned long long));\n  ROLLING_HASH_PW[0] = 1;\n  for(i=(1);i<(ROLLING_HASH_MEM);i++){\n    ROLLING_HASH_PW[i] = rollingHash61_mul(ROLLING_HASH_PW[i-1], ROLLING_HASH_BASE);\n  }\n  ROLLING_HASH_IPW[0] = 1;\n  for(i=(1);i<(ROLLING_HASH_MEM);i++){\n    ROLLING_HASH_IPW[i] = rollingHash61_mul(ROLLING_HASH_IPW[i-1], ROLLING_HASH_IBASE);\n  }\n}\nstruct rollingHash{\n  long long len;\n  unsigned long long hs;\n  template<class T> void set(int N, T A[]){\n    int i;\n    long long tmp;\n    hs = 0;\n    len = N;\n    rollingHash_expand(N);\n    for(i=(0);i<(N);i++){\n      tmp = A[i] % ((long long)ROLLING_HASH_MOD);\n      if(tmp < 0){\n        tmp += ROLLING_HASH_MOD;\n      }\n      hs += rollingHash61_mul(tmp, ROLLING_HASH_PW[i]);\n      if(hs >= ROLLING_HASH_MOD){\n        hs -= ROLLING_HASH_MOD;\n      }\n    }\n  }\n  template<class S, class T> void change(long long ind, S bef, T aft){\n    long long tmp1;\n    long long tmp2;\n    tmp1 = bef % ((long long)ROLLING_HASH_MOD);\n    tmp2 = aft % ((long long)ROLLING_HASH_MOD);\n    tmp1 = tmp2 - tmp1;\n    if(tmp1 < 0){\n      tmp1 += ROLLING_HASH_MOD;\n    }\n    if(tmp1 < 0){\n      tmp1 += ROLLING_HASH_MOD;\n    }\n    if(tmp1 >= ROLLING_HASH_MOD){\n      tmp1 -= ROLLING_HASH_MOD;\n    }\n    if(ind+1 <= ROLLING_HASH_MAX_MEMORY || ind+1 >= ROLLING_HASH_MEM){\n      rollingHash_expand(ind+1);\n      hs += rollingHash61_mul(tmp1, ROLLING_HASH_PW[ind]);\n    }\n    else{\n      hs += rollingHash61_mul(tmp1, rollingHash61_pow(ROLLING_HASH_BASE, ind));\n    }\n    if(hs >= ROLLING_HASH_MOD){\n      hs -= ROLLING_HASH_MOD;\n    }\n  }\n  void push_front(rollingHash a){\n    if(a.len + 1 <= ROLLING_HASH_MAX_MEMORY || a.len + 1 >= ROLLING_HASH_MEM){\n      rollingHash_expand(a.len + 1);\n      hs = rollingHash61_mul(hs, ROLLING_HASH_PW[a.len]);\n    }\n    else{\n      hs = rollingHash61_mul(hs, rollingHash61_pow(ROLLING_HASH_BASE, a.len));\n    }\n    hs += a.hs;\n    if(hs >= ROLLING_HASH_MOD){\n      hs -= ROLLING_HASH_MOD;\n    }\n    len += a.len;\n  }\n  void push_back(rollingHash a){\n    if(len + 1 <= ROLLING_HASH_MAX_MEMORY || len + 1 >= ROLLING_HASH_MEM){\n      rollingHash_expand(len + 1);\n      hs += rollingHash61_mul(a.hs, ROLLING_HASH_PW[len]);\n    }\n    else{\n      hs += rollingHash61_mul(a.hs, rollingHash61_pow(ROLLING_HASH_BASE, len));\n    }\n    if(hs >= ROLLING_HASH_MOD){\n      hs -= ROLLING_HASH_MOD;\n    }\n    len += a.len;\n  }\n  void pop_front(rollingHash a){\n    if(hs >= a.hs){\n      hs -= a.hs;\n    }\n    else{\n      hs = hs + ROLLING_HASH_MOD - a.hs;\n    }\n    if(a.len + 1 <= ROLLING_HASH_MAX_MEMORY || a.len + 1 >= ROLLING_HASH_MEM){\n      rollingHash_expand(a.len + 1);\n      hs = rollingHash61_mul(hs, ROLLING_HASH_IPW[a.len]);\n    }\n    else{\n      hs = rollingHash61_mul(hs, rollingHash61_pow(ROLLING_HASH_IBASE, a.len));\n    }\n    len -= a.len;\n  }\n  void pop_back(rollingHash a){\n    unsigned long long tmp;\n    if(len + 1 <= ROLLING_HASH_MAX_MEMORY || len + 1 >= ROLLING_HASH_MEM){\n      rollingHash_expand(len + 1);\n      tmp = rollingHash61_mul(a.hs, ROLLING_HASH_PW[len]);\n    }\n    else{\n      tmp = rollingHash61_mul(a.hs, rollingHash61_pow(ROLLING_HASH_BASE, len));\n    }\n    if(hs >= tmp){\n      hs -= tmp;\n    }\n    else{\n      hs = hs + ROLLING_HASH_MOD - tmp;\n    }\n    len -= a.len;\n  }\n  bool operator==(const rollingHash a){\n    return len == a.len && hs == a.hs;\n  }\n  bool operator!=(const rollingHash a){\n    return len != a.len || hs != a.hs;\n  }\n}\n;\ntemplate<class T> rollingHash calcRollingHash(int N, T A[]){\n  rollingHash res;\n  res.set(N, A);\n  return res;\n}\nstruct rollingHashSubarrays{\n  unsigned long long*hs;\n  int mem;\n  int len;\n  void set(){\n    hs = NULL;\n    mem = len = 0;\n  }\n  void free(){\n    if(mem){\n      delete[] hs;\n    }\n  }\n  void expand(int k){\n    if(mem >= k){\n      return;\n    }\n    free();\n    mem =max_L(2*mem, k);\n    hs = new unsigned long long[mem];\n  }\n  template<class T> void set(int N, T A[]){\n    int i;\n    long long tmp;\n    if(N <= 0){\n      return;\n    }\n    rollingHash_expand(N);\n    expand(N);\n    len = N;\n    tmp = A[0] % ((long long)ROLLING_HASH_MOD);\n    if(tmp < 0){\n      tmp += ROLLING_HASH_MOD;\n    }\n    hs[0] = tmp;\n    for(i=(1);i<(N);i++){\n      tmp = A[i] % ((long long)ROLLING_HASH_MOD);\n      if(tmp < 0){\n        tmp += ROLLING_HASH_MOD;\n      }\n      hs[i] = hs[i-1] + rollingHash61_mul(tmp, ROLLING_HASH_PW[i]);\n      if(hs[i] >= ROLLING_HASH_MOD){\n        hs[i] -= ROLLING_HASH_MOD;\n      }\n    }\n  }\n  rollingHash get_len(int s, int len){\n    unsigned long long x;\n    rollingHash res;\n    res.len = len;\n    rollingHash_expand(s+1);\n    if(s == 0){\n      res.hs = hs[len-1];\n    }\n    else{\n      if(hs[s+len-1] >= hs[s-1]){\n        res.hs = hs[s+len-1] - hs[s-1];\n      }\n      else{\n        res.hs = hs[s+len-1] + ROLLING_HASH_MOD - hs[s-1];\n      }\n      res.hs = rollingHash61_mul(res.hs, ROLLING_HASH_IPW[s]);\n    }\n    return res;\n  }\n  rollingHash get(int a, int b){\n    return get_len(a, b - a + 1);\n  }\n  rollingHashSubarrays(){\n    set();\n  }\n  ~rollingHashSubarrays(){\n    free();\n  }\n}\n;\n#define main dummy_main\nint main(){\n  {\n    rollingHashInit();\n  }\n  return 0;\n}\n#undef main\nint lens;\nint len[1000000];\nint len_chk[1000000];\nmap<unsigned long long,int> hs[1000000];\nrollingHashSubarrays arr;\nclass Solution{\n  public:\n  int minimumCost(string t, vector<string>& words, vector<int>& costs){\n    dummy_main();\n    int i;\n    int j;\n    int k;\n    int m;\n    int N = t.size();\n    unsigned long long h;\n    static long long dp[1000000];\n    for(i=(0);i<(100000);i++){\n      len_chk[i] = 0;\n    }\n    for(i=(0);i<(100000);i++){\n      hs[i].clear();\n    }\n    for(i=(0);i<(words.size());i++){\n      k = words[i].size();\n      len_chk[k] = 1;\n      h = calcRollingHash(k,words[i].c_str()).hs;\n      if(hs[k].count(h)){\n        chmin(hs[k][h], costs[i]);\n      }\n      else{\n        hs[k][h] = costs[i];\n      }\n    }\n    lens = 0;\n    for(i=(0);i<(100000);i++){\n      if(len_chk[i]){\n        len[lens++] = i;\n      }\n    }\n    arr.set(N,t.c_str());\n    for(i=(0);i<(N+1);i++){\n      dp[i] = 4611686016279904256LL;\n    }\n    dp[0] = 0;\n    for(i=(0);i<(N);i++){\n      if(dp[i] < 4611686016279904256LL){\n        for(m=(0);m<(lens);m++){\n          k = len[m];\n          if(i+k > N){\n            continue;\n          }\n          h = arr.get_len(i,k).hs;\n          if(hs[k].count(h)){\n            chmin(dp[i+k], dp[i] + hs[k][h]);\n          }\n        }\n      }\n    }\n    if(dp[N] == 4611686016279904256LL){\n      dp[N] = -1;\n    }\n    return dp[N];\n  }\n}\n;\n// cLay version 20240420-1\n\n// --- original code ---\n// #define main dummy_main\n// {}\n// #undef main\n// \n// int lens, len[1d6], len_chk[1d6];\n// map<ull,int> hs[1d6];\n// \n// rollingHashSubarrays arr;\n// \n// class Solution {\n// public:\n//   int minimumCost(string t, vector<string>& words, vector<int>& costs) {\n//     dummy_main();\n// \n//     int i, j, k, m, N = t.size();\n//     ull h;\n// \n//     static ll dp[1d6];\n// \n//     rep(i,1d5) len_chk[i] = 0;\n//     rep(i,1d5) hs[i].clear();\n// \n//     rep(i,words.size()){\n//       k = words[i].size();\n//       len_chk[k] = 1;\n//       h = calcRollingHash(k,words[i].c_str()).hs;\n//       if(hs[k].count(h)) hs[k][h] <?= costs[i];\n//       else               hs[k][h] = costs[i];\n//     }\n// \n//     lens = 0;\n//     rep(i,1d5) if(len_chk[i]) len[lens++] = i;\n// \n//     arr.set(N,t.c_str());\n// \n//     rep(i,N+1) dp[i] = ll_inf;\n//     dp[0] = 0;\n//     rep(i,N) if(dp[i] < ll_inf) rep(m,lens){\n//       k = len[m];\n//       if(i+k > N) continue;\n//       h = arr.get_len(i,k).hs;\n//       if(hs[k].count(h)) dp[i+k] <?= dp[i] + hs[k][h];\n//     }\n// \n//     if(dp[N] == ll_inf) dp[N] = -1;\n//     return dp[N];\n//   }\n// };\n",
    "submit_ts": "1720320711",
    "subm_id": "1312302455"
}