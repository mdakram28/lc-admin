{
    "username": "Tanguilol",
    "submission": "class Solution {\n    \n    private static class Node implements Comparable<Node> {\n        \n        int i;\n        int v;\n        \n        public Node(int i, int v) {\n            this.i = i;\n            this.v = v;\n        }\n        \n        public int compareTo(Node other) {\n            int result = Integer.compare(v, other.v);\n            \n            if (result == 0) {\n                result = Integer.compare(i, other.i);\n            }\n            \n            return result;\n        }\n        \n        public String toString() {\n            return \"[\" + i + \", \" + v + \"]\";\n        }\n        \n    }\n    \n    public long minimumOperations(int[] nums, int[] target) {\n        List<List<Integer>> subarrays = new ArrayList<>();\n        List<Integer> current = new ArrayList<>();\n        Boolean prevPos = null;\n        \n        for (int i = 0; i < nums.length; i++) {\n            int diff = nums[i] - target[i];\n            boolean pos = diff >= 0;\n            \n            if (prevPos == null || prevPos != pos) {\n                prevPos = pos;\n                subarrays.add(current);\n                current = new ArrayList<>();\n            }\n            \n            current.add(Math.abs(diff));\n        }\n        \n        subarrays.add(current);\n        \n        //System.out.println(subarrays);\n        \n        long result = 0L;\n        \n        for (List<Integer> subarray : subarrays) {\n            result += processSubarray(subarray);\n        }\n            \n        return result;\n    }\n    \n    private long processSubarray(List<Integer> subarray) {\n        if (subarray.isEmpty()) {\n            return 0L;\n        }\n        \n        long result = 0L;\n        \n        PriorityQueue<Node> queue = new PriorityQueue<>();\n        TreeMap<Integer, Integer> applied = new TreeMap<>();\n        \n        int i = 0;\n        for (Integer v : subarray) {\n            queue.add(new Node(i, v));\n            i++;\n        }\n        \n        //System.out.println(queue);\n        \n        while (!queue.isEmpty()) {\n            Node n = queue.poll();\n            \n            Map.Entry<Integer, Integer> appliedEntry = applied.floorEntry(n.i);\n            int actualValue = n.v;\n            \n            if (appliedEntry != null) {\n                actualValue -= appliedEntry.getValue();\n                applied.put(appliedEntry.getKey(), n.v);\n            } else {\n                applied.put(0, n.v);\n            }\n            \n            result += actualValue;\n            //System.out.println(\"adding \" + actualValue + \" at \" + n.i + \" = \" + result + \" \" + applied);\n\n            applied.put(n.i, n.v);\n        }\n        \n        return result;\n    }\n}",
    "submit_ts": "1721531481",
    "subm_id": "1327962035"
}