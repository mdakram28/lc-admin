{
    "username": "BarryBondsOfLC",
    "submission": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#pragma region\ntemplate <typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ll long long\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define ins insert\n\nvoid __print(int x) { cout << x; }\nvoid __print(long x) { cout << x; }\nvoid __print(long long x) { cout << x; }\nvoid __print(unsigned x) { cout << x; }\nvoid __print(unsigned long x) { cout << x; }\nvoid __print(unsigned long long x) { cout << x; }\nvoid __print(float x) { cout << x; }\nvoid __print(double x) { cout << x; }\nvoid __print(long double x) { cout << x; }\nvoid __print(char x) { cout << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cout << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cout << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cout << (x ? \"true\" : \"false\"); }\ntemplate <size_t N>\nvoid __print(const bitset<N>& x) { cout << x; };\n\ntemplate <typename T>\nvoid __print(const T &x);\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x);\ntemplate <typename T>\nvoid __print(const T &x);\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v);\n\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n    cout << '{';\n    __print(x.first);\n    cout << \", \";\n    __print(x.second);\n    cout << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n    int f = 0;\n    cout << '{';\n    for (auto &i : x) cout << (f++ ? \", \" : \"\"), __print(i);\n    cout << \"}\";\n}\nvoid _print() { cout << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n    __print(t);\n    if (sizeof...(v)) cout << \", \";\n    _print(v...);\n}\n\ntemplate<class T> bool ckmin(T&a, const T& b) { bool B = a > b; a = min(a,b); return B; }\ntemplate<class T> bool ckmax(T&a, const T& b) { bool B = a < b; a = max(a,b); return B; }\n#pragma endregion\n\n#define dbg(x...)                                                            \\\n    cout << \"[\" << __func__ << \":\" << __LINE__ - 9 << \" [\" << #x << \"] = [\"; \\\n    _print(x);                                                               \\\n    cout << endl;\n// #define dbg(x...)\n\nclass DisjointSets {\n  private:\n\tvector<int> parents;\n\tvector<int> sizes;\n\n  public:\n\tDisjointSets(int size) : parents(size), sizes(size, 1) {\n\t\tfor (int i = 0; i < size; i++) { parents[i] = i; }\n\t}\n\n\t/** @return the \"representative\" node in x's component */\n\tint find(int x) {\n\t\treturn parents[x] == x ? x : (parents[x] = find(parents[x]));\n\t}\n\n\t/** @return whether the merge changed connectivity */\n\tbool unite(int x, int y) {\n\t\tint x_root = find(x);\n\t\tint y_root = find(y);\n\t\tif (x_root == y_root) { return false; }\n\n\t\tif (sizes[x_root] < sizes[y_root]) { swap(x_root, y_root); }\n\t\tsizes[x_root] += sizes[y_root];\n\t\tparents[y_root] = x_root;\n\t\treturn true;\n\t}\n\n\t/** @return whether x and y are in the same connected component */\n\tbool connected(int x, int y) { return find(x) == find(y); }\n};\n\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& C) {\n        int n = C.size();\n        auto ds = DisjointSets(n);\n\n        auto intersect = [&](const auto& c1, const auto& c2) {\n            auto x1 = c1[0], y1 = c1[1], r1 = c1[2];\n            auto x2 = c2[0], y2 = c2[1], r2 = c2[2];\n            return 1LL * (x1 - x2) * (x1 - x2) + 1LL * (y1 - y2) * (y1 - y2) <= 1LL * (r1 + r2) * (r1 + r2);\n        };\n\n        for (int i = 0; i < n - 1; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (intersect(C[i], C[j]))\n                    ds.unite(i, j);\n            }\n        }\n\n        map<int, vector<int>> groups;\n        for (int i = 0; i < n; ++i) groups[ds.find(i)].pb(i);\n        for (const auto& [_, g] : groups) {\n            int mnx = INT_MAX, mxx = INT_MIN, mny = INT_MAX, mxy = INT_MIN;\n            for (auto i : g) {\n                const auto& c = C[i];\n                auto x = c[0], y = c[1], r = c[2];\n                mnx = min(mnx, x - r);\n                mxx = max(mxx, x + r);\n                mny = min(mny, y - r);\n                mxy = max(mxy, y + r);\n            }\n            bool lr = mnx <= 0 && mxx >= X;\n            bool tb = mny <= 0 && mxy >= Y;\n            bool tl = mnx <= 0 && mny <= 0;\n            bool br = mxx >= X && mxy >= Y;\n            if (lr || tb || tl || br) return false;\n        }\n\n        return true;\n    }\n};",
    "submit_ts": "1722138048",
    "subm_id": "1335780754"
}