{
    "username": "triggered18101",
    "submission": "from typing import List\nfrom collections import deque\nimport math\n\nclass Solution:\n    def bfs(self, graph, start, target1, target2, total_nodes):\n        queue = deque([start])\n        visited = [0] * (total_nodes + 4)\n        visited[start] = 1\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    queue.append(neighbor)\n                    visited[neighbor] = 1\n                    \n        return visited[target1] or visited[target2]\n\n    def canReachCorner(self, X: int, Y: int, obstacles: List[List[int]]) -> bool:\n        num_obstacles = len(obstacles)\n        circles = [((obstacles[i][0], obstacles[i][1]), obstacles[i][2]) for i in range(num_obstacles)]\n        graph = [[] for _ in range(num_obstacles + 4)]\n\n        for i in range(num_obstacles):\n            if circles[i][0][0] <= circles[i][1]:\n                graph[num_obstacles].append(i)\n                graph[i].append(num_obstacles)\n            if X - circles[i][0][0] <= circles[i][1]:\n                graph[num_obstacles + 2].append(i)\n                graph[i].append(num_obstacles + 2)\n            if circles[i][0][1] <= circles[i][1]:\n                graph[num_obstacles + 1].append(i)\n                graph[i].append(num_obstacles + 1)\n            if Y - circles[i][0][1] <= circles[i][1]:\n                graph[num_obstacles + 3].append(i)\n                graph[i].append(num_obstacles + 3)\n            for j in range(i + 1, num_obstacles):\n                distance = math.sqrt((circles[i][0][0] - circles[j][0][0]) ** 2 + (circles[i][0][1] - circles[j][0][1]) ** 2)\n                if circles[i][1] + circles[j][1] >= distance:\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        return not (self.bfs(graph, num_obstacles, num_obstacles + 1, num_obstacles + 2, num_obstacles + 4) or \n                    self.bfs(graph, num_obstacles + 3, num_obstacles + 2, num_obstacles + 1, num_obstacles + 4))\n\n# Example usage:\nsolution = Solution()\nprint(solution.canReachCorner(5, 9, [[4, 7, 1], [2, 1, 1], [4, 7, 1], [3, 7, 1], [4, 1, 1], [4, 7, 1], [1, 5, 1]]))  # Expected Output: True\n",
    "submit_ts": "1722139066",
    "subm_id": "1335806926"
}