{
    "username": "beta-blue",
    "submission": "class DSU {\nprivate:\n    vector<int> parents;\n    vector<int> ranks;\n    \npublic:\n    DSU(int n) {\n        parents.resize(n);\n        for (int i=0; i<n; ++i)\n            parents[i] = i;\n\n        ranks.resize(n, 0);\n    }\n\n    int find(int x) {\n        if (x == parents[x])\n            return x;\n        return parents[x] = find(parents[x]);\n    }\n\n    void join(int x, int y) {\n        int px = find(x);\n        int py = find(y);\n\n        if (px != py) {\n            if (ranks[px] < ranks[py])\n                parents[px] = py;\n            else if (ranks[px] > ranks[py])\n                parents[py] = px;\n            else {\n                parents[py] = px;\n                ranks[px]++;\n            }\n        }\n    }\n};\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n        DSU dsu(n);\n        for (int i=0; i<n; ++i) {\n            auto& a = circles[i];\n            for (int j=i+1; j<n; ++j) {\n                auto& b = circles[j];\n\n                if (dsu.find(i) == dsu.find(j))\n                    continue;\n\n                int dx = a[0] - b[0];\n                int dy = a[1] - b[1];\n                auto d = sqrt(1LL * dx * dx + 1LL * dy * dy);\n                if (d <= a[2] + b[2]) // overlap\n                    dsu.join(i, j);\n            }\n        }\n\n        unordered_map<int, vector<int>> mp;\n        for (int i=0; i<n; ++i) {\n            auto& c = circles[i];\n            int x = c[0];\n            int y = c[1];\n            int r = c[2];\n            int x0 = x - r;\n            int x1 = x + r;\n            int y0 = y - r;\n            int y1 = y + r;\n\n            int par = dsu.find(i);\n            if (mp.find(par) == mp.end())\n                mp[par] = {x0, x1, y0, y1};\n            else {\n                auto& p = mp[par];\n                p = {min(p[0], x0), max(p[1], x1), min(p[2], y0), max(p[3], y1)};\n            }\n\n            auto& p = mp[par];\n            if ((p[0] <= 0 && p[1] >= X) ||\n                (p[2] <= 0 && p[3] >= Y) ||\n                (p[0] <= 0 && p[2] <= 0) ||\n                (p[1] >= X && p[3] >= Y)\n            )\n                return false;\n        }\n\n        return true;\n    }\n};",
    "submit_ts": "1722138678",
    "subm_id": "1335796907"
}