{
    "username": "ryanwong0127",
    "submission": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep_(i, a, b) for (int i = (a); i > (b); i--)\n#define mst(x, a) memset(x, a, sizeof(x))\n#define all(a) begin(a), end(a)\n#define lowbit(x) ((x) & (-(x)))\n#define bitcnt(x) (__builtin_popcountll(x))\n#define se second\n#define fi first\n#define pb push_back\n#define maxe max_element\n#define mine min_element\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, ll> pil;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\nconstexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\nconstexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;\nconst ll infl = 0x3f3f3f3f3f3f3f3fll;\ntemplate<class T> bool chmax(T &a, T b) {\n    if (a >= b) return false;\n    a = b; return true;\n}\ntemplate<class T> bool chmin(T &a, T b) {\n    if (a <= b) return false;\n    a = b; return true;\n}\ntemplate<class T> bool chsum(T &a, T b) {\n    a = (a + b + mod) % mod;\n    return 0;\n}\n// class SegmentTree {\n// public:\n//     SegmentTree(const std::vector<int>& data) {\n//         n = data.size();\n//         tree.resize(2 * n);\n//         build(data);\n//     }\n\n//     int rangeAnd(int left, int right) {\n//         int res = inf;\n//         left += n;\n//         right += n + 1;\n//         while (left < right) {\n//             if (left & 1) {\n//                 res &= tree[left++];\n//             }\n//             if (right & 1) {\n//                 res &= tree[--right];\n//             }\n//             left >>= 1;\n//             right >>= 1;\n//         }\n//         return res;\n//     }\n\n// private:\n//     int n;\n//     std::vector<int> tree;\n\n//     void build(const svector<int>& data) {\n//         for (int i = 0; i < n; ++i) {\n//             tree[n + i] = data[i];\n//         }\n//         for (int i = n - 1; i > 0; --i) {\n//             tree[i] = tree[2 * i] & tree[2 * i + 1];\n//         }\n//     }\n// };\nclass Segment {\npublic:\n    int L, R;\n    Segment* left = nullptr;\n    Segment* right = nullptr;\n    int and_val = 0xFFFFFFFF;\n\n    Segment(int L, int R) : L(L), R(R) {\n        if (L >= R) {\n            throw std::runtime_error(\"L >= R: \" + std::to_string(L) + \", \" + std::to_string(R));\n        }\n        int M = L + (R - L) / 2;\n        if (L < M) {\n            left = new Segment(L, M);\n            right = new Segment(M, R);\n        }\n    }\n\n    void set(int i, int v) {\n        and_val &= v;\n        int M = L + (R - L) / 2;\n        if (left != nullptr && i < M) {\n            left->set(i, v);\n        }\n        if (right != nullptr && M <= i) {\n            right->set(i, v);\n        }\n    }\n\n    int get(int l, int r) {\n        if (l <= L && R <= r) {\n            return and_val;\n        }\n        if (R <= l || L >= r) {\n            return 0xFFFFFFFF;\n        }\n        return left->get(l, r) & right->get(l, r);\n    }\n};\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& a, int k) {\n//         const int n = a.size();\n//         int res = inf;\n\n//         SegmentTree segment_tree(a);\n//         rep(r, 0, n) {\n//             int low = 0, high = r;\n//             while (low < high) {\n//                 int m = (low + high) / 2;\n//                 if (segment_tree.rangeAnd(m, r) >= k) {\n//                     high = m;\n//                 } else {\n//                     low = m + 1;\n//                 }\n//             }\n\n//             int cur = segment_tree.rangeAnd(low, r);\n//             chmin(res, abs(cur - k));\n//         }\n\n//         return res;\n        Segment seg(0, a.size());\n        for (int i = 0; i < a.size(); ++i) {\n            seg.set(i, a[i]);\n        }\n        int res = INT_MAX;\n        for (int l = 0; l < a.size(); ++l) {\n            int L = l + 1;\n            int R = a.size();\n            while (L < R) {\n                int M = L + (R - L + 1) / 2;\n                if (seg.get(l, M) >= k) {\n                    L = M;\n                } else {\n                    R = M - 1;\n                }\n            }\n            res = std::min(res, abs(k - seg.get(l, L)));\n            res = std::min(res, abs(k - seg.get(l, min(L + 1, (int)a.size()))));\n        }\n        return res;\n    }\n};\n",
    "submit_ts": 1717299352.0
}