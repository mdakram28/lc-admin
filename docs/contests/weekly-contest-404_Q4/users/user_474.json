{
    "username": "Tyrande",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int a = helper(edges1), b = helper(edges2);\n        int ra = (a + 1 ) / 2;\n        int rb = (b + 1) / 2;\n        //cout << a << \" \" << ra << endl;\n        //cout << b << \" \" << rb << endl;\n        return max(ra + rb + 1, max(a, b));\n        //return helper(edges1) + helper(edges2) + 1;\n    }\n    int helper(vector<vector<int>> & edges) {\n        int n = edges.size();\n        vector<int> in(n+1, 0);\n        vector<unordered_set<int>> graph(n+1);\n        for (auto & e : edges) {\n            in[e[0]]++;\n            in[e[1]]++;\n            graph[e[0]].insert(e[1]);\n            graph[e[1]].insert(e[0]);\n        }\n        queue<int> q;\n        for (int i = 0; i <= n; ++i)\n            if (in[i] == 1)\n                q.push(i);\n        \n        int d = 0;\n        int total = 0;\n        while (!q.empty()) {\n            int l = q.size();\n            total += l;\n            //cout << l << endl;\n            set<int> c;\n            for (int i = 0; i < l; ++i) {\n                auto cur = q.front();\n                q.pop();\n                for (int neigh : graph[cur]) {\n                    in[neigh]--;\n                    graph[neigh].erase(cur);\n                    if (in[neigh] == 1)\n                        c.insert(neigh);\n                }\n            }\n            for (int node : c) {\n                if (in[node] == 1)\n                    q.push(node);\n            }\n            d++;\n        }\n        //cout <<l <<  \" \" << d << endl;\n        if (total == n + 1) return d * 2 - 1;\n        else return d * 2;\n    }\n};",
    "submit_ts": 1719718460.0
}