{
    "username": "sho1004",
    "submission": "#ifdef _SM_LOCAL\n#include \"debug.hpp\" // IWYU pragma: keep\n#else\n#include <bits/stdc++.h>\n#define Debug(...)\n#endif\nusing namespace std;\n// using LL = __int128;\nusing ll = long long;\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    explicit dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n\n  private:\n    int _n;\n    std::vector<int> parent_or_size;\n};\n\n}  // namespace atcoder\n\nusing dsu = atcoder::dsu;\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = (int)circles.size();\n        const int L = n, T = n+ 1, R =n + 2, B = n + 3;\n        auto uf = dsu(B + 1);\n        for (int i = 0; i < n; i++) {\n            auto& v = circles[i];\n            int x = v[0], y = v[1], r = v[2];\n            int left = x - r, right = x + r;\n            int top = y + r, bottom = y - r;\n            if (left <= 0) uf.merge(L, i);\n            if (right >= X) uf.merge(R, i);\n            if (bottom <= 0) uf.merge(B, i);\n            if (top >= Y) uf.merge(T, i);\n        }\n        auto f = [&](int i, int j) -> void {\n            auto& v1 = circles[i];\n            auto& v2 = circles[j];\n            ll r = v1[2] + v2[2];\n            ll dx = v1[0] - v2[0];\n            ll dy = v1[1] - v2[1];\n            ll t = dx * dx + dy * dy;\n            r *= r;\n            if (t <= r) {\n                uf.merge(i, j);\n            }\n        };\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                f(i, j);\n            }\n        }\n        if (uf.same(L, R) || uf.same(T, B) || uf.same(T, R) || uf.same(L, B)) return false;\n        return true;\n\n    }\n};",
    "submit_ts": "1722135490",
    "subm_id": "1335703479"
}