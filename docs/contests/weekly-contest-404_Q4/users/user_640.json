{
    "username": "sky_akash",
    "submission": "typedef long long int ll; \ntypedef unsigned long long ull;\ntypedef long double ld;       \n#define pb push_back\n#define pob pop_back\n#define ff first\n#define ss second\n#define all(v) (v).begin(), (v).end()\n#define sare(v) (v).begin(), (v).end()\n#define MOD 1000000007\n\nclass Solution {\npublic:\n    \n    \nvector<vector<int>> adj; // Adjacency list representation of the tree\nint n; // Number of nodes in the tree\nint farthest_node;\nint max_distance;\nvector <ll> dist;\n\n// DFS function to find the farthest node and its distance from the start node\nvoid dfs(int node, int distance, vector<bool>& visited) {\n    visited[node] = true;\n\n    if (distance > max_distance) {\n        max_distance = distance;\n        farthest_node = node;\n    }\n\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, distance + 1, visited);\n        }\n    }\n}\n\n    \nvoid dijk(ll source)\n{\n    pair<ll,ll> p;\n    priority_queue< pair<ll,ll>, vector < pair<ll,ll> > , greater < pair<ll,ll> > > pq;\n    \n    pq.push({0,source});\n    while(pq.size()!=0)\n    {\n        p=pq.top();\n        pq.pop();\n        if(dist[p.ss]!=1e18) continue;\n        dist[p.ss]=p.ff;\n        for(auto i:adj[p.ss])\n        {\n            pq.push({p.ff+1,i});\n        }\n    }\n}\n    \nvoid dijk1(ll source)\n{\n    pair<ll,ll> p;\n    priority_queue< pair<ll,ll>, vector < pair<ll,ll> > , greater < pair<ll,ll> > > pq;\n    vector <ll> vis(dist.size());\n    pq.push({0,source});\n    while(pq.size()!=0)\n    {\n        p=pq.top();\n        pq.pop();\n        if(vis[p.ss]) continue;\n        vis[p.ss]++;\n        dist[p.ss]=max(dist[p.ss],p.ff);\n        for(auto i:adj[p.ss])\n        {\n            pq.push({p.ff+1,i});\n        }\n    }\n}\n\n// Function to find the diameter of the tree\nint find_diameter(vector<vector<int>>& edges) {\n    n = edges.size() + 1; // Number of nodes\n    adj.clear();\n    adj.resize(n);\n    \n    // Construct the adjacency list from edges\n    for (auto& edge : edges) {\n        int u = edge[0];\n        int v = edge[1];\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    vector<bool> visited(n, false);\n    max_distance = 0;\n    dfs(0, 0, visited); // Start from an arbitrary node (node 0)\n    dist.clear();\n    dist.resize(n+1,1e18);\n    fill(visited.begin(), visited.end(), false);\n    dijk(farthest_node);\n    fill(visited.begin(), visited.end(), false); // Reset the visited array\n    max_distance = 0;\n    dfs(farthest_node, 0, visited); // Run DFS from the farthest node found\n    \n    return max_distance;\n}\n    \n    \nvoid find_diameter1(vector<vector<int>>& edges) {\n    n = edges.size() + 1; // Number of nodes\n    adj.clear();\n    adj.resize(n);\n    \n    // Construct the adjacency list from edges\n    for (auto& edge : edges) {\n        int u = edge[0];\n        int v = edge[1];\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    vector<bool> visited(n, false);\n    max_distance = 0;\n    dfs(0, 0, visited); // Start from an arbitrary node (node 0)\n    dist.clear();\n    dist.resize(n+1,1e18);\n    fill(visited.begin(), visited.end(), false);\n    dijk(farthest_node);\n    ll x=0,y=0;\n    for(int i=0;i<n;i++)\n    {\n        if(dist[i]>y)\n        {\n            y=dist[i];\n            x=i;\n        }\n    }\n    \n    dijk1(x);\n    //return max_distance;\n}\n    \n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        ll x=find_diameter(edges1);\n        ll y=find_diameter(edges2);\n        ll ans=1e18;\n        if(x>y)\n        {\n            ll t1=y/2;\n            if(y%2) t1++;\n            find_diameter1(edges1);\n            for(auto i:dist)\n            {\n                ll t=i+t1+1;\n                if(t<x) t=x;\n                ans=min(ans,t);\n            }\n        }\n        else\n        {\n            ll t1=x/2;\n            if(x%2) t1++;\n            find_diameter1(edges2);\n            for(auto i:dist)\n            {\n                ll t=i+t1+1;\n                if(t<y) t=y;\n                ans=min(ans,t);\n            }\n        }\n        return ans;\n        \n    }\n};",
    "submit_ts": "1719719087",
    "subm_id": "1304433443"
}