{
    "username": "trchen",
    "submission": "using ll = long long;\n\nnamespace segment_tree_impl {\n\ntemplate <typename DataType, class Operator, bool LazyAssignment>\nstruct LazyAssignmentComponent {};\n\ntemplate <typename DataType, class Operator>\nstruct LazyAssignmentComponent<DataType, Operator, true> {\n  DataType lazy_assignment = Operator::Identity();\n};\n\ntemplate <typename DataType, class Operator, bool LazyIncrement>\nstruct LazyIncrementComponent {};\n\ntemplate <typename DataType, class Operator>\nstruct LazyIncrementComponent<DataType, Operator, true> {\n  DataType lazy_increment = Operator::Identity();\n};\n\ntemplate <bool Persistent>\nstruct PersistentComponent {};\n\ntemplate <>\nstruct PersistentComponent<true> {\n  int left_child;\n  int right_child;\n};\n\ntemplate <typename DataType, class Operator, bool LazyAssignment, bool LazyIncrement,\n          bool Persistent>\nstruct SegmentTreeNode : public LazyAssignmentComponent<DataType, Operator, LazyAssignment>,\n                         public LazyIncrementComponent<DataType, Operator, LazyIncrement>,\n                         public PersistentComponent<Persistent> {\n  DataType value;\n};\n\n}  // namespace segment_tree_impl\n\ntemplate <typename DataType, class Operator, bool LazyAssignment = false,\n          bool LazyIncrement = false, bool Persistent = false>\nclass SegmentTree {\n  using Node = segment_tree_impl::SegmentTreeNode<DataType, Operator, LazyAssignment, LazyIncrement,\n                                                  Persistent>;\n\n public:\n  template <class RawContainer>\n  inline void Build(const RawContainer& raw_container) noexcept\n    requires (!Persistent) {\n    data_size_ = static_cast<int>(raw_container.size());\n    tree_.resize(4 * data_size_);\n    BuildRecursive(raw_container, 1, 0, data_size_ - 1);\n  }\n\n  template <class RawContainer>\n  inline int Build(const RawContainer& raw_container, int number_of_future_operations) noexcept\n    requires (Persistent) {\n    data_size_ = static_cast<int>(raw_container.size());\n    int size = data_size_;\n    int height = 1;\n    while (size > 1) {\n      height++;\n      size /= 2;\n    }\n    tree_.resize(2 * data_size_ + 4 * height * number_of_future_operations);\n    next_valid_index_ = 1;\n    BuildRecursive(raw_container, 0, 0, data_size_ - 1);\n    return 0;\n  }\n\n  inline DataType Query(int left, int right) noexcept\n    requires (!Persistent) {\n    if (left > right) {\n      return Operator::Identity();\n    }\n    return QueryRecursive(1, 0, data_size_ - 1, left, right);\n  }\n\n  inline std::pair<DataType, int> Query(int left, int right, int root) noexcept\n    requires (Persistent) {\n    if (left > right) {\n      return { Operator::Identity(), root };\n    }\n    int new_root;\n    if constexpr (LazyAssignment || LazyIncrement) {\n      new_root = CopyRoot(root);\n    } else {\n      new_root = root;\n    }\n    return { QueryRecursive(new_root, 0, data_size_ - 1, left, right), new_root };\n  }\n\n  inline void Assign(int position, const DataType& assignment) noexcept\n    requires (!Persistent) {\n    AssignRecursive(1, 0, data_size_ - 1, position, assignment);\n  }\n\n  inline int Assign(int position, const DataType& assignment, int root) noexcept\n    requires (Persistent) {\n    const int new_root = CopyRoot(root);\n    AssignRecursive(new_root, 0, data_size_ - 1, position, assignment);\n    return new_root;\n  }\n\n  inline void RangeIncrease(int left, int right, const DataType& increment) noexcept\n    requires (LazyIncrement && !Persistent) {\n    if (left > right) {\n      return;\n    }\n    RangeIncreaseRecursive(1, 0, data_size_ - 1, left, right, increment);\n  }\n\n  inline int RangeIncrease(int left, int right, const DataType& increment, int root) noexcept\n    requires (LazyIncrement && Persistent) {\n    const int new_root = CopyRoot(root);\n    if (left <= right) {\n      RangeIncreaseRecursive(new_root, 0, data_size_ - 1, left, right, increment);\n    }\n    return new_root;\n  }\n\n private:\n  template <class RawContainer>\n  inline void BuildRecursive(const RawContainer& raw_container, int vertex, int segment_left,\n                             int segment_right) noexcept {\n    if constexpr (LazyAssignment) {\n      tree_[vertex].lazy_assignment = Operator::Identity();\n    }\n    if constexpr (LazyIncrement) {\n      tree_[vertex].lazy_increment = Operator::Identity();\n    }\n    if (segment_left == segment_right) {\n      tree_[vertex].value = raw_container[segment_left];\n    } else {\n      if constexpr (Persistent) {\n        tree_[vertex].left_child = next_valid_index_;\n        next_valid_index_++;\n        tree_[vertex].right_child = next_valid_index_;\n        next_valid_index_++;\n      }\n      const int segment_middle = (segment_left + segment_right) / 2;\n      BuildRecursive(raw_container, LeftChild(vertex), segment_left, segment_middle);\n      BuildRecursive(raw_container, RightChild(vertex), segment_middle + 1, segment_right);\n      PushUp(vertex);\n    }\n  }\n\n  inline DataType QueryRecursive(int vertex, int segment_left, int segment_right, int left,\n                                 int right) noexcept {\n    if (segment_left == left && segment_right == right) {\n      return tree_[vertex].value;\n    }\n    PushDown(vertex, segment_left, segment_right);\n    const int segment_middle = (segment_left + segment_right) / 2;\n    if (right <= segment_middle) {\n      return QueryRecursive(LeftChild(vertex), segment_left, segment_middle, left, right);\n    }\n    if (left >= segment_middle + 1) {\n      return QueryRecursive(RightChild(vertex), segment_middle + 1, segment_right, left, right);\n    }\n    return Operator::Combine(\n        QueryRecursive(LeftChild(vertex), segment_left, segment_middle, left, segment_middle),\n        QueryRecursive(RightChild(vertex), segment_middle + 1, segment_right, segment_middle + 1,\n                       right));\n  }\n\n  inline void IncreaseRecursive(int vertex, int segment_left, int segment_right, int position,\n                                const DataType& increment) noexcept {\n    if (segment_left == segment_right) {\n      tree_[vertex].value = Operator::Combine(tree_[vertex].value, increment);\n      return;\n    }\n    PushDown(vertex, segment_left, segment_right);\n    const int segment_middle = (segment_left + segment_right) / 2;\n    if (position <= segment_middle) {\n      CopyLeftChild<false>(vertex);\n      IncreaseRecursive(LeftChild(vertex), segment_left, segment_middle, position, increment);\n    } else {\n      CopyRightChild<false>(vertex);\n      IncreaseRecursive(RightChild(vertex), segment_middle + 1, segment_right, position, increment);\n    }\n    PushUp(vertex);\n  }\n\n  inline void RangeIncreaseRecursive(int vertex, int segment_left, int segment_right, int left,\n                                     int right, const DataType& increment) noexcept {\n    if (segment_left == left && segment_right == right) {\n      ReceiveLazyIncrement(vertex, segment_left, segment_right, increment);\n      return;\n    }\n    PushDown(vertex, segment_left, segment_right);\n    const int segment_middle = (segment_left + segment_right) / 2;\n    if (right <= segment_middle) {\n      CopyLeftChild<false>(vertex);\n      RangeIncreaseRecursive(LeftChild(vertex), segment_left, segment_middle, left, right,\n                             increment);\n    } else if (left >= segment_middle + 1) {\n      CopyRightChild<false>(vertex);\n      RangeIncreaseRecursive(RightChild(vertex), segment_middle + 1, segment_right, left, right,\n                             increment);\n    } else {\n      CopyLeftChild<false>(vertex);\n      CopyRightChild<false>(vertex);\n      RangeIncreaseRecursive(LeftChild(vertex), segment_left, segment_middle, left, segment_middle,\n                             increment);\n      RangeIncreaseRecursive(RightChild(vertex), segment_middle + 1, segment_right,\n                             segment_middle + 1, right, increment);\n    }\n    PushUp(vertex);\n  }\n\n  [[nodiscard]] inline int LeftChild(int vertex) const noexcept {\n    if constexpr (Persistent) {\n      return tree_[vertex].left_child;\n    } else {\n      return 2 * vertex;\n    }\n  }\n\n  [[nodiscard]] inline int RightChild(int vertex) const noexcept {\n    if constexpr (Persistent) {\n      return tree_[vertex].right_child;\n    } else {\n      return 2 * vertex + 1;\n    }\n  }\n\n  [[nodiscard]] inline int CopyRoot(int root) noexcept {\n    const int new_root = next_valid_index_;\n    tree_[new_root] = tree_[root];\n    next_valid_index_++;\n    return new_root;\n  }\n\n  template <bool BeforePushDown>\n  inline void CopyLeftChild(int vertex) noexcept {\n    if constexpr (Persistent && (BeforePushDown == (LazyAssignment || LazyIncrement))) {\n      tree_[next_valid_index_] = tree_[LeftChild(vertex)];\n      tree_[vertex].left_child = next_valid_index_;\n      next_valid_index_++;\n    }\n  }\n\n  template <bool BeforePushDown>\n  inline void CopyRightChild(int vertex) noexcept {\n    if constexpr (Persistent && (BeforePushDown == (LazyAssignment || LazyIncrement))) {\n      tree_[next_valid_index_] = tree_[RightChild(vertex)];\n      tree_[vertex].right_child = next_valid_index_;\n      next_valid_index_++;\n    }\n  }\n\n  inline void PushUp(int vertex) noexcept {\n    tree_[vertex].value =\n        Operator::Combine(tree_[LeftChild(vertex)].value, tree_[RightChild(vertex)].value);\n  }\n\n  inline void PushDown(int vertex, int segment_left, int segment_right) noexcept {\n    if constexpr (!LazyAssignment && !LazyIncrement) {\n      return;\n    } else {\n      CopyLeftChild<true>(vertex);\n      CopyRightChild<true>(vertex);\n      const int segment_middle = (segment_left + segment_right) / 2;\n      if constexpr (LazyAssignment) {\n        if (tree_[vertex].lazy_assignment != Operator::Identity()) {\n          ReceiveLazyAssignment(LeftChild(vertex), segment_left, segment_middle,\n                                tree_[vertex].lazy_assignment);\n          ReceiveLazyAssignment(RightChild(vertex), segment_middle + 1, segment_right,\n                                tree_[vertex].lazy_assignment);\n          tree_[vertex].lazy_assignment = Operator::Identity();\n          return;\n        }\n      }\n      if constexpr (LazyIncrement) {\n        if (tree_[vertex].lazy_increment != Operator::Identity()) {\n          ReceiveLazyIncrement(LeftChild(vertex), segment_left, segment_middle,\n                               tree_[vertex].lazy_increment);\n          ReceiveLazyIncrement(RightChild(vertex), segment_middle + 1, segment_right,\n                               tree_[vertex].lazy_increment);\n          tree_[vertex].lazy_increment = Operator::Identity();\n        }\n      }\n    }\n  }\n\n  inline void ReceiveLazyAssignment(int vertex, int segment_left, int segment_right,\n                                    const DataType& lazy_assignment) noexcept {\n    tree_[vertex].lazy_assignment = lazy_assignment;\n    tree_[vertex].value =\n        Operator::CombineMultiple(lazy_assignment, segment_right - segment_left + 1);\n    if constexpr (LazyIncrement) {\n      tree_[vertex].lazy_increment = Operator::Identity();\n    }\n  }\n\n  inline void ReceiveLazyIncrement(int vertex, int segment_left, int segment_right,\n                                   const DataType& lazy_increment) noexcept {\n    if constexpr (LazyAssignment) {\n      if (tree_[vertex].lazy_assignment == Operator::Identity()) {\n        tree_[vertex].lazy_increment =\n            Operator::Combine(tree_[vertex].lazy_increment, lazy_increment);\n      } else {\n        tree_[vertex].lazy_assignment =\n            Operator::Combine(tree_[vertex].lazy_assignment, lazy_increment);\n        tree_[vertex].lazy_increment = Operator::Identity();\n      }\n    } else {\n      tree_[vertex].lazy_increment =\n          Operator::Combine(tree_[vertex].lazy_increment, lazy_increment);\n    }\n    tree_[vertex].value = Operator::IncrementMultiple(tree_[vertex].value, lazy_increment,\n                                                      segment_right - segment_left + 1);\n  }\n\n  int next_valid_index_{};\n  int data_size_{};\n  std::vector<Node> tree_{};\n};\n\nstruct AddOperator {\n  static ll Identity() {\n    return 0;\n  }\n\n  static ll Combine(ll x, ll y) {\n    return x + y;\n  }\n\n  static ll IncrementMultiple(ll a, ll b, ll length) {\n    return a + b * length;\n  }\n};\n\ntemplate <typename Type1, typename Type2, typename Comparator1 = std::less<Type1>,\n          typename Comparator2 = std::greater<Type2>>\nclass DoublySortedArray {\n public:\n  inline bool Insert(const Type1& val1, const Type2& val2) noexcept {\n    auto iter = container_.upper_bound(val1);\n    while (iter != container_.end() && (comparator2_(val2, iter->second) || val2 == iter->second)) {\n      iter = container_.erase(iter);\n    }\n    if (iter == container_.begin()) {\n      container_.emplace(val1, val2);\n      return true;\n    }\n    --iter;\n    if (comparator2_(val2, iter->second)) {\n      container_.emplace(val1, val2);\n      return true;\n    }\n    return false;\n  }\n\n  inline void Clear() noexcept {\n    container_.clear();\n  }\n\n  inline size_t Size() const noexcept {\n    return container_.size();\n  }\n\n  inline auto begin() noexcept {\n    return container_.begin();\n  }\n\n  inline auto end() noexcept {\n    return container_.end();\n  }\n\n private:\n  std::map<Type1, Type2, Comparator1> container_;\n  Comparator2 comparator2_;\n};\n\nusing ST = SegmentTree<ll, AddOperator, false, true>;\n\nusing DS = DoublySortedArray<int, int>;\n\nclass Solution {\n public:\n  vector<int> shortestDistanceAfterQueries(int n_, vector<vector<int>>& queries) {\n    int n = n_;\n    d.resize(n);\n    for (int i = 0; i < n; ++i) {\n      d[i] = n - 1 - i;\n    }\n    prev.resize(n, n);\n    st.Build(d);\n    int m = queries.size();\n    vector<int> ret;\n    for (int i = 0; i < m; ++i) {\n      ret.push_back(AddEdge(queries[i][0], queries[i][1]));\n    }\n    return ret;\n  }\n\n  int AddEdge(int uu, int vv) {\n    if (ds.Insert(uu, vv) && prev[vv] > uu) {\n      prev[vv] = uu;\n      int du = st.Query(uu, uu);\n      int dv = st.Query(vv, vv);\n      if (du > dv + 1) {\n        int diff = dv + 1 - du;\n        st.RangeIncrease(0, uu, diff);\n      }\n    }\n    return st.Query(0, 0);\n  }\n\n  ST st;\n  DS ds;\n  int n;\n  vector<ll> d;\n  vector<int> prev;\n};",
    "submit_ts": "1722743712",
    "subm_id": "1343797986"
}