{
    "username": "Mr_Shyyyy_07",
    "submission": "#include <vector>\n\nclass Solution {\npublic:\n    std::vector<int> countOfPeaks(std::vector<int>& nums, std::vector<std::vector<int>>& queries) {\n        int n = nums.size();\n        std::vector<int> ans;\n\n        // Helper function to determine if an element at index is a peak\n        auto isPeak = [&nums](int i) {\n            if (i <= 0 || i >= nums.size() - 1) return false;\n            return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n        };\n\n        // Segment tree to maintain the number of peaks in each segment\n        std::vector<int> segTree(4 * n, 0);\n\n        // Function to build the segment tree\n        std::function<void(int, int, int)> build = [&](int node, int start, int end) {\n            if (start == end) {\n                segTree[node] = isPeak(start) ? 1 : 0;\n            } else {\n                int mid = (start + end) / 2;\n                build(2 * node + 1, start, mid);\n                build(2 * node + 2, mid + 1, end);\n                segTree[node] = segTree[2 * node + 1] + segTree[2 * node + 2];\n            }\n        };\n\n        // Function to update the segment tree\n        std::function<void(int, int, int, int)> update = [&](int node, int start, int end, int idx) {\n            if (start == end) {\n                segTree[node] = isPeak(start) ? 1 : 0;\n            } else {\n                int mid = (start + end) / 2;\n                if (start <= idx && idx <= mid) {\n                    update(2 * node + 1, start, mid, idx);\n                } else {\n                    update(2 * node + 2, mid + 1, end, idx);\n                }\n                segTree[node] = segTree[2 * node + 1] + segTree[2 * node + 2];\n            }\n        };\n\n        // Function to query the segment tree\n        std::function<int(int, int, int, int, int)> query = [&](int node, int start, int end, int L, int R) {\n            if (R < start || end < L) {\n                return 0;\n            }\n            if (L <= start && end <= R) {\n                return segTree[node];\n            }\n            int mid = (start + end) / 2;\n            int leftQuery = query(2 * node + 1, start, mid, L, R);\n            int rightQuery = query(2 * node + 2, mid + 1, end, L, R);\n            return leftQuery + rightQuery;\n        };\n\n        // Build the initial segment tree\n        build(0, 0, n - 1);\n\n        for (const auto& q : queries) {\n            if (q[0] == 1) {\n                int l = q[1], r = q[2];\n                if (l == r || l + 1 == r) {\n                    ans.push_back(0);\n                } else {\n                    ans.push_back(query(0, 0, n - 1, l + 1, r - 1));\n                }\n            } else if (q[0] == 2) {\n                int idx = q[1], val = q[2];\n                nums[idx] = val;\n                update(0, 0, n - 1, idx);\n                if (idx > 0) update(0, 0, n - 1, idx - 1);\n                if (idx < n - 1) update(0, 0, n - 1, idx + 1);\n            }\n        }\n\n        return ans;\n    }\n};\n",
    "submit_ts": 1718508852.0
}