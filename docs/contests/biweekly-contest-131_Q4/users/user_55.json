{
    "username": "RedHeadphone",
    "submission": "\nclass SortedList:\n    block_size = 700\n\n    def __init__(self, iterable=()):\n        self.macro = []\n        self.micros = [[]]\n        self.micro_size = [0]\n        self.ft_build()\n        self.size = 0\n        for item in iterable:\n            self.add(item)\n\n    def ft_build(self):\n        bit = self.bit = list(self.micro_size)\n        bit_size = self.bit_size = len(bit)\n        for i in range(bit_size):\n            j = i | (i + 1)\n            if j < bit_size:\n                bit[j] += bit[i]\n\n    def ft_update(self, idx, x):\n        while idx < self.bit_size:\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def ft_get(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\n    def ft_find_kth(self, k):\n        idx = -1\n        for d in reversed(range(self.bit_size.bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < self.bit_size and self.bit[right_idx] <= k:\n                idx = right_idx\n                k -= self.bit[idx]\n        return idx + 1, k\n\n    def add(self, x):\n        i = bisect_left(self.macro, x)\n        j = bisect_right(self.micros[i], x)\n        self.micros[i].insert(j, x)\n        self.size += 1\n        self.micro_size[i] += 1\n        self.ft_update(i, 1)\n        if len(self.micros[i]) >= self.block_size:\n            self.micros[i : i + 1] = (\n                self.micros[i][: self.block_size >> 1],\n                self.micros[i][self.block_size >> 1 :],\n            )\n            self.micro_size[i : i + 1] = self.block_size >> 1, self.block_size >> 1\n            self.ft_build()\n            self.macro.insert(i, self.micros[i + 1][0])\n\n    def pop(self, k=-1):\n        i, j = self._find_kth(k)\n        self.size -= 1\n        self.micro_size[i] -= 1\n        self.ft_update(i, -1)\n        return self.micros[i].pop(j)\n\n    def remove(self, x):\n        c = self.count(x)\n        ind = self.bisect_left(x)\n        for _ in range(c):\n            self.pop(ind)\n\n    def __getitem__(self, k):\n        i, j = self._find_kth(k)\n        return self.micros[i][j]\n\n    def count(self, x):\n        return self.bisect_right(x) - self.bisect_left(x)\n\n    def __contains__(self, x):\n        return self.count(x) > 0\n\n    def bisect_left(self, x):\n        i = bisect_left(self.macro, x)\n        return self.ft_get(i) + bisect_left(self.micros[i], x)\n\n    def bisect_right(self, x):\n        i = bisect_right(self.macro, x)\n        return self.ft_get(i) + bisect_right(self.micros[i], x)\n\n    def _find_kth(self, k):\n        return self.ft_find_kth(k + self.size if k < 0 else k)\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return (x for micro in self.micros for x in micro)\n\n    def __repr__(self):\n        return str(list(self))\n\n\nclass SegmentTree:\n    def __init__(self, arr, func=lambda x, y: x + y, defaultvalue=0):\n        self.n = len(arr)\n        self.segmentTree = [0] * self.n + arr\n        self.func = func\n        self.defaultvalue = defaultvalue\n        for i in range(self.n - 1, 0, -1):\n            self.segmentTree[i] = self.func(\n                self.segmentTree[2 * i], self.segmentTree[2 * i + 1]\n            )\n\n    def query(self, l, r):\n        l += self.n\n        r += self.n\n        res = self.defaultvalue\n        while l < r:\n            if l & 1:\n                res = self.func(res, self.segmentTree[l])\n                l += 1\n            l >>= 1\n            if r & 1:\n                r -= 1\n                res = self.func(res, self.segmentTree[r])\n            r >>= 1\n        return res\n\n    def update(self, i, value):\n        i += self.n\n        self.segmentTree[i] = value\n        while i > 1:\n            i >>= 1\n            self.segmentTree[i] = self.func(\n                self.segmentTree[2 * i], self.segmentTree[2 * i + 1]\n            )\n\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        arr = []\n        for q in queries:\n            if q[0] == 1:\n                arr.append(q[1])\n        arr.sort()\n        arr_mapp = {x: i for i, x in enumerate(arr)}\n        st = SegmentTree([0]*len(arr),lambda x,y: max(x,y))\n        sl = SortedList()\n        ans = []\n\n        for q in queries:\n            if q[0] == 1:\n                ind = sl.bisect_left(q[1])\n                if ind==0:\n                    st.update(arr_mapp[q[1]],q[1])\n                else:\n                    left = sl[ind-1]\n                    st.update(arr_mapp[q[1]],q[1]-left)\n                if ind<len(sl):\n                    right = sl[ind]\n                    st.update(arr_mapp[right], right - q[1])\n                sl.add(q[1])\n            elif q[0] == 2:\n                x,sz = q[1],q[2]\n                ind = sl.bisect_right(x)\n                if ind==0:\n                    ans.append(x>=sz)\n                else:\n                    extra_part = x-sl[ind-1]\n                    maxx = max(extra_part,st.query(0,arr_mapp[sl[ind-1]]+1))\n                    ans.append(maxx>=sz)\n\n        return ans",
    "submit_ts": 1716649727.0
}