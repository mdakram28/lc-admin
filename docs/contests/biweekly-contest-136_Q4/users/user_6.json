{
    "username": "PyIsTheBestLang",
    "submission": "def max(a, b):\n    return a if a > b else b\n\n\ndef min(a, b):\n    return a if a < b else b\n\n\nclass Solution:\n    def timeTaken(self, edges: List[List[int]]) -> List[int]:\n        n = len(edges)+1\n        dct = [[] for _ in range(n)]\n        for i, j in edges:\n            dct[i].append(j)\n            dct[j].append(i)\n        \n        weight = [2 if i %2 ==0 else 1 for i in range(n)]\n        n = len(dct)\n        sub = [[0, 0] for _ in range(n)]\n\n        # first bfs compute the largest distance and second large distance from bottom to up\n        stack = [[0, -1, 1]]\n        while stack:\n            i, fa, state = stack.pop()\n            if state:\n                stack.append([i, fa, 0])\n                for j in dct[i]:\n                    if j != fa:\n                        stack.append([j, i, 1])\n            else:\n                a, b = sub[i]\n                for j in dct[i]:\n                    if j != fa:\n                        x = sub[j][0] + weight[j]\n                        if x >= a:\n                            a, b = x, a\n                        elif x >= b:\n                            b = x\n                sub[i] = [a, b]\n\n        # second bfs compute large distance from up to bottom\n        stack = [(0, -1, 0)]\n        ans = [s[0] for s in sub]\n        while stack:\n            i, fa, d = stack.pop()\n            ans[i] = ans[i] if ans[i] > d else d\n            for j in dct[i]:\n                if j != fa:\n                    nex = d\n                    x = sub[j][0] + weight[j]\n                    a, b = sub[i]\n                    # distance from current child nodes excluded\n                    if x == a:\n                        nex = nex if nex > b else b\n                    else:\n                        nex = nex if nex > a else a\n                    stack.append((j, i, nex + weight[i]))\n        return ans",
    "submit_ts": "1722696433",
    "subm_id": "552260913"
}