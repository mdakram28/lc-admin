{
    "username": "kunaljha7456",
    "submission": "class Solution {\npublic:\n\n void dfs(int node, vector<int> &vis, vector<int> adj[], vector<int> &storeDfs) {\n        storeDfs.push_back(node); \n        vis[node] = 1; \n        for(auto it : adj[node]) {\n            if(!vis[it]) {\n                dfs(it, vis, adj, storeDfs); \n            }\n        }\n    }\n    struct TrieNode {\n        unordered_map<char, TrieNode*> children;\n        vector<pair<int, int>> endIndexes; \n    };\n\n    void print(string word){\n        for(int i=0;i<word.size();i++)\n        cout<<word[i]<<endl;\n    }\n\n    class Trie {\n    public:\n        TrieNode* rootNode;\n        Trie() { rootNode = new TrieNode(); }\n\n        void insertWord(string& word, int idx, int cost) {\n            TrieNode* currentNode = rootNode;\n            \n            for (char ch : word) {\n                if (!currentNode->children.count(ch))\n                    currentNode->children[ch] = new TrieNode();\n                currentNode = currentNode->children[ch];\n            }\n            currentNode->endIndexes.push_back({idx, cost});\n            \n        }\n    };\n\n    int minimumCost(string targetStr, vector<string>& wordList, vector<int>& costList) {\n        int targetLength = targetStr.size();\n        vector<int> minCost(targetLength + 1, INT_MAX);\n        minCost[0] = 0;\n        print(\"abc\");\n        print(\"abc\");\n        Trie trie;\n        for (int i = 0; i < wordList.size(); ++i) {\n            trie.insertWord(wordList[i], i, costList[i]);\n        } print(\"abc\");\n        for (int i = 0; i < targetLength; ++i) {\n            if (minCost[i] == INT_MAX) continue;\n            \n              \n            TrieNode* currentNode = trie.rootNode;\n           \n             \n            for (int j = i; j < targetLength; ++j) {\n                 \n                if (!currentNode->children.count(targetStr[j])) break;\n                currentNode = currentNode->children[targetStr[j]]; \n                for (auto& p : currentNode->endIndexes) {\n                    int wordIdx = p.first;\n                    int wordCost = p.second;\n                \n                    \n                    int wordLen = wordList[wordIdx].size();\n                    if (i + wordLen <= targetLength) {\n                        minCost[i + wordLen] = min(minCost[i + wordLen], minCost[i] + wordCost);          \n        \n                    }\n                }\n            }\n    \n        }\n        print(\"abc\");print(\"abc\");print(\"abc\");\n        return minCost[targetLength] == INT_MAX ? -1 : minCost[targetLength];\n    }\n};\n",
    "submit_ts": "1720322971",
    "subm_id": "1312363978"
}