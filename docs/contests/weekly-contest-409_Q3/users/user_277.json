{
    "username": "xylu",
    "submission": "using ll = long long;\ntemplate<class Info, class Tag>\nstruct LazySegmentTree {\n    int n;\n    vector<Info> info;\n    vector<Tag> tag;\n\n    LazySegmentTree() : n(0) {}\n\n    LazySegmentTree(int n_, Info v_ = Info()) {\n        init(vector<Info>(n_, v_));\n    }\n\n    template<class T>\n    LazySegmentTree(vector<T>& init_) {\n        vector<Info> tmp;\n        for (auto& x : init_) {\n            tmp.push_back({x});\n        }\n        init(tmp);\n    }\n\n    void init(vector<Info> init_) {\n        n = init_.size();\n        info.assign(4 << __lg(n), Info());\n        tag.assign(4 << __lg(n), Tag());\n        function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r == l) {\n                info[p] = init_[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m + 1, r);\n            pull(p);\n        };\n        build(1, 0, n-1);\n    }\n\n    void pull(int p) {\n        info[p] = info[2 * p] + info[2 * p + 1];\n    }\n\n    void apply(int p, const Tag &v) {\n        info[p].apply(v);\n        tag[p].apply(v);\n    }\n\n    void push(int p) {\n        apply(2 * p, tag[p]);\n        apply(2 * p + 1, tag[p]);\n        tag[p] = Tag();\n    }\n\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r == l) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        if (x <= m) modify(2 * p, l, m, x, v);\n        else modify(2 * p + 1, m + 1, r, x, v);\n        pull(p);\n    }\n\n    void modify(int p, const Info &v) {\n        modify(1, 0, n-1, p, v);\n    }\n\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l > y || r < x) return Info();\n        if (l >= x && r <= y) return info[p];\n        int m = (l + r) / 2;\n        push(p);\n        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m + 1, r, x, y);\n    }\n\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n-1, l, r);\n    }\n\n    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {\n        if (l > y || r < x) return;\n        if (l >= x && r <= y) {\n            apply(p, v);\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        rangeApply(2 * p, l, m, x, y, v);\n        rangeApply(2 * p + 1, m + 1, r, x, y, v);\n        pull(p);\n    }\n\n    void rangeApply(int l, int r, const Tag &v) {\n        return rangeApply(1, 0, n-1, l, r, v);\n    }\n\n    template<class F>\n    int findFirst(int p, int l, int r, int x, int y, F pred) {\n        if (l > y || r < x || !pred(info[p])) return -1;\n        if (r == l) return l;\n        int m = (l + r) / 2;\n        push(p);\n        int res = findFirst(2 * p, l, m, x, y, pred);\n        if (res == -1) res = findFirst(2 * p + 1, m+1, r, x, y, pred);\n        return res;\n    }\n\n    //\u627e[l,r)\u533a\u95f4\u5185\u7b2c\u4e00\u4e2a\u7b26\u5408pred\u6761\u4ef6\u7684\u4f4d\u7f6e,\u6ca1\u6709\u8fd4\u56de-1\n    template<class F>\n    int findFirst(int l, int r, F pred) {\n        return findFirst(1, 0, n-1, l, r, pred);\n    }\n\n    template<class F>\n    int findLast(int p, int l, int r, int x, int y, F pred) {\n        if (l > y || r < x || !pred(info[p])) return -1;\n        if (r == l) return l;\n        int m = (l + r) / 2;\n        push(p);\n        int res = findLast(2 * p + 1, m+1, r, x, y, pred);\n        if (res == -1) res = findLast(2 * p, l, m, x, y, pred);\n        return res;\n    }\n    \n    //\u627e[l,r)\u533a\u95f4\u5185\u6700\u540e\u4e00\u4e2a\u7b26\u5408pred\u6761\u4ef6\u7684\u4f4d\u7f6e,\u6ca1\u6709\u8fd4\u56de-1\n    template<class F>\n    int findLast(int l, int r, F pred) {\n        return findLast(1, 0, n-1, l, r, pred);\n    }\n};\n\nstruct Tag {\n    ll maxv = 0;\n    \n    void apply(const Tag &t) & {\n        maxv += t.maxv;\n    }\n};\n\nstruct Info {\n    ll maxv = 0;\n    \n    void apply(const Tag &t) & {\n        maxv -= t.maxv;\n    }\n\n    Info operator+(const Info &rhs) {\n        return {max(this->maxv, rhs.maxv)};\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<Info> init1(n, {0}), init2(n, {0});\n        for (int i = 0; i < n; ++i) {\n            init1[i].maxv = i;\n            init2[i].maxv = n - i - 1;\n        }\n        LazySegmentTree<Info, Tag> st1(init1), st2(init2);\n        int m = queries.size();\n        int p = n - 1;\n        vector<int> ans(m, 0);\n        for (int i = 0; i < m; ++i) {\n            int x = queries[i][0], y = queries[i][1];\n            int d1 = st1.rangeQuery(x, x).maxv;\n            int d2 = st2.rangeQuery(y, y).maxv;\n            int t = d1 + d2 + 1;\n            if (t < p) {\n                ans[i] = t;\n                p = t;\n                st1.rangeApply(y, n-1, {st1.rangeQuery(y, y).maxv - d1 - 1});\n                st2.rangeApply(0, x, {st2.rangeQuery(x, x).maxv - d2 - 1});\n            } else {\n                ans[i] = p;\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722740475",
    "subm_id": "552331736"
}