{
    "username": "realSaddy",
    "submission": "class Node {\npublic:\n    unordered_map<char, Node*> kids;\n    int cost = INT_MAX;\n};\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int n = target.size();\n        int m = words.size(); // assert == costs.size()\n\n\n        Node* root = new Node();\n        for(int i = 0 ; i < m ; i++) {\n            string word = words[i];\n            Node* z = root;\n            for(char c : word) {\n                if(!z->kids.contains(c)) z->kids[c] = new Node();\n                z = z->kids[c];\n            }\n            z->cost = min(z->cost, costs[i]);\n        }\n\n        vector<int> dp(n+1, INT_MAX);\n        dp[0] = 0; // blank string\n\n        for(int i = 0; i < n; i++) { // i = len of string\n            if(dp[i] == INT_MAX) continue;\n\n            Node* z = root;\n            for(int j = i; j < n; j++) {\n                if(!z->kids.contains(target[j])) break;\n                z = z->kids[target[j]];\n                int len = j-i+1;\n                if(z->cost != INT_MAX && i+len <= n) {\n                    dp[i+len] = min(dp[i+len], dp[i]+z->cost);\n                }\n            }\n        }\n\n        return dp[n] == INT_MAX ? -1 : dp[n];\n\n        // unordered_map<string, int> mp; // str -> cost\n\n        // mp[\"\"] = 0;\n        // int ret = -1;\n\n\n        // while(mp.size() != 0) {\n        //     unordered_map<string, int> new_mp;\n\n        //     for(auto& it : mp) {\n                \n        //         for(int i = 0; i < words.size(); i++) {\n        //             string new_word = it.first+words[i];\n        //             int new_cost = it.second+costs[i];\n        //             if(target == new_word) {\n        //                 if(ret == -1 || new_cost < ret) ret = new_cost;\n        //                 continue;\n        //             }\n        //             if(new_word.size() >= target.size()) continue;\n        //             // assert new_word size < target size\n        //             // check if what we added didn't change the word\n        //             for(int j = it.first.size(); j < it.first.size()+words[i].size(); j++) {\n        //                 if(new_word[j] != target[j]) continue;\n        //             }\n        //             // // O(w)\n        //             // if(!target.starts_with(new_word)) continue;\n                \n        //             // O(1)\n        //             if(new_mp.contains(new_word)) {\n        //                 new_mp[new_word] = min(new_mp[new_word], new_cost);\n        //             } else {\n        //                 new_mp[new_word] = new_cost;\n        //             }\n        //         }\n        //     }\n\n        //     mp = new_mp;\n\n        // }\n\n\n        // return ret;\n\n    }\n};",
    "submit_ts": "1720323601",
    "subm_id": "1312379522"
}