{
    "username": "MeetBrahmbhatt",
    "submission": "const long long INF = 1e9;\ntemplate<typename node, typename update>\nstruct segtree {\n    vector<node> t;\n    vector<update> upds;\n    vector<bool> lazy;\n    int size;\n\n    void init(int n) {\n        size = 1;\n        while (size < n) size *= 2;\n        t.assign(2 * size, node());\n        upds.assign(2 * size, update());\n        lazy.assign(2 * size, 0);\n    }\n\n    inline void propogate(int x, int lx, int rx) {\n        if (lazy[x]) {\n            int mid = (lx + rx) / 2;\n            apply(2 * x + 1, upds[x], lx, mid);\n            apply(2 * x + 2, upds[x], mid + 1, rx);\n            lazy[x] = 0;\n            upds[x] = update();\n        }\n    }\n\n    inline void apply(int x, update &val, int lx, int rx) {\n        if (lx != rx) {\n            lazy[x] = 1;\n            upds[x].combine(val, lx, rx);\n        }\n        val.apply(t[x], lx, rx);\n    }\n\n    template<typename T>\n    void build(T &v, int x, int lx, int rx) {\n        if (rx == lx) {\n            if (lx < (int) v.size()) t[x] = v[lx];\n            return;\n        }\n        int mid = (lx + rx) / 2;\n        build(v, 2 * x + 1, lx, mid);\n        build(v, 2 * x + 2, mid + 1, rx);\n        t[x].merge(t[2 * x + 1], t[2 * x + 2]);\n    }\n\n    node query(int l, int r, int x, int lx, int rx) {\n        if (lx > r || rx < l) return node();\n        if (l <= lx and rx <= r) return t[x];\n        propogate(x, lx, rx);\n        int mid = (lx + rx) / 2;\n        node L, R, ans;\n        L = query(l, r, 2 * x + 1, lx, mid);\n        R = query(l, r, 2 * x + 2, mid + 1, rx);\n        ans.merge(L, R);\n        return ans;\n    }\n\n    void rupd(int l, int r, update &v, int x, int lx, int rx) {\n        if (lx > r || rx < l) return;\n        if (l <= lx and rx <= r) {\n            apply(x, v, lx, rx); return;\n        }\n        propogate(x, lx, rx);\n        int mid = (lx + rx) / 2;\n        rupd(l, r, v, 2 * x + 1, lx, mid);\n        rupd(l, r, v, 2 * x + 2, mid + 1, rx);\n        t[x].merge(t[2 * x + 1], t[2 * x + 2]);\n    }\n    \n    \n    int find_first(int l, int val, int x, int lx, int rx, node &prev) {\n        if (rx < l) return size;\n        if (l <= lx) {\n            node curr;\n            curr.merge(prev, t[x]);\n            if (!curr.check(val)) {\n                swap(prev, curr);\n                return size;\n            }\n            if (lx == rx) return lx;\n        }\n        propogate(x, lx, rx);\n        int mid = (lx + rx) / 2;\n        int ans = find_first(l, val, 2 * x + 1, lx, mid, prev);\n        if (ans != size) return ans;\n        return find_first(l, val, 2 * x + 2, mid + 1, rx, prev);\n    }\n\n    int find_last(int r, int val, int x, int lx, int rx, node &prev) {\n        if (r < lx) return -1ll;\n        if (rx <= r) {\n            node curr;\n            curr.merge(prev, t[x]);\n            if (!curr.check(val)) {\n                swap(prev, curr);\n                return -1ll;\n            }\n            if (lx == rx) return lx;\n        }\n        propogate(x, lx, rx);\n        int mid = (lx + rx) / 2;\n        int ans = find_last(r, val, 2 * x + 2, mid + 1, rx, prev);\n        if (ans == -1) ans = find_last(r, val, 2 * x + 1, lx, mid, prev);\n        return ans;\n    }\n\n    template<typename T>\n    void build(T &v) {\n        build(v, 0, 0, size - 1);\n    }\n\n    node query(int l, int r) {\n        return query(l, r, 0, 0, size - 1);\n    }\n\n    void rupd(int l, int r, update val) {\n        rupd(l, r, val, 0, 0, size - 1);\n    }\n\n    int find_first(int l, int val) {\n        node prev = node();\n        return find_first(l, val, 0, 0, size - 1, prev);\n    }\n\n    int find_last(int r, int val) {\n        node prev = node();\n        return find_last(r, val, 0, 0, size - 1, prev);\n    }\n};\n\nstruct node {\n\tlong long pmx, smx, sum, mx;\n\tnode() : node(-INF) {}\n\tnode(int val) {\n\t\tpmx = smx = mx = sum = val;\n\t}\n\tinline void merge(node &l, node &r) {\n\t\tpmx = max(l.pmx, l.sum + r.pmx);\n\t\tsmx = max(r.smx, r.sum + l.smx);\n\t\tsum = l.sum + r.sum;\n\t\tmx = max({l.mx, r.mx, l.smx + r.pmx});\n\t}\n\tbool check(int x) {\n\t\treturn false;\n\t}\n};\n\nstruct update {\n    long long v = 0;\n    update() : update(0) {}\n    update(int val) {\n        v = val;\n    }\n    inline void combine(update &other, int l, int r) {\n\n    }\n    inline void apply(node &x, int l, int r) {\n        x = node(v);\n    }\n};\n\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& q) {\n        int n = (int) q.size();\n        vector<bool> ans;\n        \n        int m = 3 * n + 10;\n        vector<int> cur(m, 1);\n        segtree<node, update> st;\n        st.init(m);\n        st.build(cur);\n        \n        for (int i = 0; i < n; i++) {\n            int t = q[i][0];\n            int x = q[i][1];\n            if (t == 1) {\n                st.rupd(x, x, -INF);\n                cur[x] = -INF;\n            } else {\n                int sz = q[i][2];\n                bool one = cur[x] == 1;\n                if (one) {\n                    st.rupd(x, x, -INF);\n                }\n                bool res = max(0LL, min(0LL + x, st.query(1, x).mx)) + 1 >= sz;\n                ans.push_back(res);\n                if (one) {\n                    st.rupd(x, x, 1);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716649432.0
}