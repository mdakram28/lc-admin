{
    "username": "kevim",
    "submission": "// AC template\nstruct AhoCorasickNode {\n    AhoCorasickNode* children[26];\n    AhoCorasickNode* fail;\n    vector<int> output;\n    \n    AhoCorasickNode() : fail(nullptr) {\n        memset(children, 0, sizeof(children));\n    }\n};\n\nclass AhoCorasick {\npublic:\n    AhoCorasick(const vector<string>& words) {\n        root = new AhoCorasickNode();\n        buildTrie(words);\n        buildFailLinks();\n    }\n    \n    ~AhoCorasick() {\n        deleteTrie(root);\n    }\n\n    vector<pair<int, int>> search(const string& text) {\n        vector<pair<int, int>> results;\n        AhoCorasickNode* node = root;\n\n        for (int i = 0; i < text.length(); ++i) {\n            while (node != root && node->children[text[i] - 'a'] == nullptr) {\n                node = node->fail;\n            }\n            if (node->children[text[i] - 'a'] != nullptr) {\n                node = node->children[text[i] - 'a'];\n            }\n            for (int wordIndex : node->output) {\n                results.push_back({i, wordIndex});\n            }\n        }\n        return results;\n    }\n\nprivate:\n    AhoCorasickNode* root;\n\n    void buildTrie(const vector<string>& words) {\n        for (int i = 0; i < words.size(); ++i) {\n            AhoCorasickNode* node = root;\n            for (char c : words[i]) {\n                int index = c - 'a';\n                if (node->children[index] == nullptr) {\n                    node->children[index] = new AhoCorasickNode();\n                }\n                node = node->children[index];\n            }\n            node->output.push_back(i);\n        }\n    }\n\n    void buildFailLinks() {\n        queue<AhoCorasickNode*> q;\n        root->fail = root;\n\n        for (int i = 0; i < 26; ++i) {\n            if (root->children[i] != nullptr) {\n                root->children[i]->fail = root;\n                q.push(root->children[i]);\n            }\n        }\n\n        while (!q.empty()) {\n            AhoCorasickNode* node = q.front();\n            q.pop();\n\n            for (int i = 0; i < 26; ++i) {\n                if (node->children[i] != nullptr) {\n                    AhoCorasickNode* child = node->children[i];\n                    AhoCorasickNode* fail = node->fail;\n\n                    while (fail != root && fail->children[i] == nullptr) {\n                        fail = fail->fail;\n                    }\n                    if (fail->children[i] != nullptr) {\n                        child->fail = fail->children[i];\n                    } else {\n                        child->fail = root;\n                    }\n\n                    child->output.insert(child->output.end(), child->fail->output.begin(), child->fail->output.end());\n                    q.push(child);\n                }\n            }\n        }\n    }\n\n    void deleteTrie(AhoCorasickNode* node) {\n        for (int i = 0; i < 26; ++i) {\n            if (node->children[i] != nullptr) {\n                deleteTrie(node->children[i]);\n            }\n        }\n        delete node;\n    }\n};\n\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        map<string,int> tcost;\n        for(int i = 0;i < words.size();++i){\n            if(tcost.count(words[i]) == 0){\n                tcost[words[i]] = costs[i];\n            }else{\n                tcost[words[i]] = min(tcost[words[i]], costs[i]);\n                \n            }\n        }\n        words.clear();\n        costs.clear();\n        for(auto& [s, c]:tcost){\n            words.push_back(s);\n            costs.push_back(c);\n        }\n        vector<int> dp(target.length()+1, -1);\n        dp[0] = 0;\n        AhoCorasick ac(words);\n        vector<pair<int, int>> matches = ac.search(target);\n        for (auto& match : matches) {\n            int R = match.first + 1;\n            int word_index = match.second;\n            int L = R - words[word_index].length();\n            if (dp[L] != -1) {\n                if(dp[R] == -1){\n                    dp[R] = dp[L] + costs[word_index];\n                }else{\n                    dp[R] = min(dp[R], dp[L] + costs[word_index]);\n                }\n            }\n        }\n        return dp.back();\n    }\n};",
    "submit_ts": "1720322170",
    "subm_id": "1312342587"
}