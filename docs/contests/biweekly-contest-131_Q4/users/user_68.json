{
    "username": "Ujimatsu_Chiya",
    "submission": "# include <bits/stdc++.h>\n# define mem(a,b) memset(a,b,sizeof(a))\n# define lb(x) ((x) & -(x))\n# define pi pair<int,int>\n# define X first\n# define Y second\n# ifdef LOCAL\n# include \"leetcode.h\"\n# endif // LOCAL\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};\n\ntemplate<typename T>\nostream & operator << (ostream &out,const set<T>&obj){out<<\"set(\";for(auto it=obj.begin();it!=obj.end();it++) out<<(it==obj.begin()?\"\":\", \")<<*it;out<<\")\";return out;}\ntemplate<typename T>\nostream & operator << (ostream &out,const unordered_set<T>&obj){out<<\"unordered_set(\";for(auto it=obj.begin();it!=obj.end();it++) out<<(it==obj.begin()?\"\":\", \")<<*it;out<<\")\";return out;}\ntemplate<typename T1,typename T2>\nostream & operator << (ostream &out,const map<T1,T2>&obj){out<<\"map(\";for(auto it=obj.begin();it!=obj.end();it++) out<<(it==obj.begin()?\"\":\", \")<<it->first<<\": \"<<it->second;out<<\")\";return out;}\ntemplate<typename T1,typename T2>\nostream & operator << (ostream &out,const unordered_map<T1,T2>&obj){out<<\"unordered_map(\";for(auto it=obj.begin();it!=obj.end();it++) out<<(it==obj.begin()?\"\":\", \")<<it->first<<\": \"<<it->second;out<<\")\";return out;}\ntemplate<typename T1,typename T2>\nostream & operator << (ostream &out,const pair<T1,T2>&obj){out<<\"<\"<<obj.first<<\", \"<<obj.second<<\">\";return out;}\ntemplate<typename T>\nostream & operator << (ostream &out,const vector<T>&obj){out<<\"vector(\";for(auto it=obj.begin();it!=obj.end();it++) out<<(it==obj.begin()?\"\":\", \")<<*it;out<<\")\";return out;}\n\ntemplate <typename T>\nstruct HashTable {\n  vector<T> val;\n  void add(T x) { val.push_back(x); }\n  void init() {\n    sort(ALL(val));\n    val.erase(unique(ALL(val)), val.end());\n  }\n  int query(T x) { return lower_bound(ALL(val), x) - val.begin() + 1; }\n  T operator[](const int t) const { return val[t - 1]; }\n  int size() { return val.size(); }\n  void clear(){val.clear();}\n};\nint mod=1e9+7;\nvoid add(int &x, int y) {\n    (x += y) >= mod && (x -= mod);\n}\nvoid sub(int &x, int y) {\n    (x -= y) < 0 && (x += mod);\n}\n\nstruct ST{\n    int l,r,s;\n};\nstruct P{\n    # define ls p<<1\n    # define rs p<<1|1\n    static const int N=50014;\n    int a[N],n;\n    ST t[N<<2];\n    void build(int p,int tl,int tr){\n        t[p].l=tl;t[p].r=tr;\n        if(tl==tr){\n            t[p].s=a[tl];\n            return;\n        }\n        int mid=(tl+tr)>>1;\n        build(ls,tl,mid);\n        build(rs,mid+1,tr);\n        pushup(t[p],t[ls],t[rs]);\n    }\n    void pushup(ST &p,ST &l,ST &r){\n        p.s=max(l.s,r.s);\n    }\n    void update(int p,int q,int x){\n        if(t[p].l==t[p].r){\n            t[p].s=x;\n            return;\n        }\n        int mid=(t[p].l+t[p].r)>>1;\n        if(q<=mid) update(ls,q,x);\n        else update(rs,q,x);\n        pushup(t[p],t[ls],t[rs]);\n    }\n    ST que(int p,int ql,int qr){\n        if(ql<=t[p].l&&t[p].r<=qr) return t[p];\n        int mid=(t[p].l+t[p].r)>>1;\n        if(qr<=mid) return que(ls,ql,qr);\n        if(ql>mid) return que(rs,ql,qr);\n        ST left=que(ls,ql,qr),right=que(rs,ql,qr),res;\n        pushup(res,left,right);\n        return res;\n    }\n}st;\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        reverse(queries.begin(),queries.end());\n        set<int>b;\n        mem(st.a,0);\n        for(auto &u:queries){\n            if(u[0]==1) b.insert(u[1]);\n        }\n        int pre=0;\n        for(int x:b){\n            st.a[x]=x-pre;\n            pre=x;\n        }\n        int n=pre;\n        st.build(1,0,n);\n        vector<bool>ans;\n        for(auto u:queries){\n            if(u[0]==2){\n                int x=u[1],sz=u[2],w=0;\n                if(b.empty()) w=x;\n                else{\n                    auto it=b.upper_bound(x);\n                    if(it==b.begin()){\n                        w=x;\n                    }\n                    else{\n                        --it;\n                        int y=*it;\n                        w=max(x-y,st.que(1,0,y).s);\n                    }\n                }\n                ans.push_back(w>=sz);\n            }\n            else{\n                int x=u[1];\n                auto it=b.lower_bound(x);\n                auto il=it,ir=it;++ir;\n                if(ir==b.end()){\n                    b.erase(it);continue;\n                }\n                int r=*ir;\n                int l=0;\n                if(il!=b.begin()){\n                    --il;l=*il;\n                }\n                b.erase(it);\n                st.update(1,r,r-l);\n            }\n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n",
    "submit_ts": 1716649563.0
}