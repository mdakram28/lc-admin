{
    "username": "PyIsTheBestLang",
    "submission": "def max(a, b):\n    return a if a > b else b\n\n\ndef min(a, b):\n    return a if a < b else b\n\nclass PointAddRangeSum:\n    def __init__(self, n: int, initial=0) -> None:\n        \"\"\"index from 1 to n\"\"\"\n        self.n = n\n        self.t = [initial] * (self.n + 1)  # default nums = [0]*n\n        return\n\n    @staticmethod\n    def _lowest_bit(i: int) -> int:\n        return i & (-i)\n\n    def _pre_sum(self, i: int) -> int:\n        \"\"\"index start from 1 and the prefix sum of nums[:i] which is 0-index\"\"\"\n\n        val = 0  # assert 1 <= i <= self.n\n        while i:\n            val += self.t[i]\n            i -= self._lowest_bit(i)\n        return val\n\n    def build(self, nums) -> None:\n        \"\"\"initialize the tree array\"\"\"\n        pre = [0] * (self.n + 1)  # assert len(nums) == self.n\n        for i in range(self.n):\n            pre[i + 1] = pre[i] + nums[i]\n            # meaning of self.t[i+1]\n            self.t[i + 1] = pre[i + 1] - pre[i + 1 - self._lowest_bit(i + 1)]\n        return\n\n    def get(self):\n        \"\"\"get the original nums sometimes for debug\"\"\"\n        nums = [self._pre_sum(i) for i in range(1, self.n + 1)]\n        for i in range(self.n - 1, 0, -1):\n            nums[i] -= nums[i - 1]\n        return nums\n\n    def point_add(self, i: int, val: int) -> None:\n        \"\"\"index start from 1 and the value val can be any inter including positive and negative number\"\"\"\n        while i < len(self.t):  # assert 1 <= i <= self.n\n            self.t[i] += val\n            i += self._lowest_bit(i)\n        return\n\n    def range_sum(self, x: int, y: int) -> int:\n        \"\"\"index start from 1 and the range sum of nums[x-1:y]  which is 0-index\"\"\"\n        res = self._pre_sum(y) - self._pre_sum(x - 1) if x > 1 else self._pre_sum(y)  # assert 1 <= x <= y <= self.n\n        return res\n\n    def bisect_right(self, w):\n        # all value in nums must be non-negative\n        x, k = 0, 1\n        while k * 2 <= self.n:\n            k *= 2\n        while k > 0:\n            if x + k <= self.n and self.t[x + k] <= w:\n                w -= self.t[x + k]\n                x += k\n            k //= 2\n        # assert 0 <= x <= self.n\n        return x\n\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        ans = 0\n        n = len(nums)\n        tree = PointAddRangeSum(n)\n        for i in range(1, n - 1):\n            if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]:\n                tree.point_add(i+1 , 1)\n\n        res = []\n        for op, a, b in queries:\n            #print(op, a, b)\n            if op == 1:\n                res.append(tree.range_sum(a + 2, b) if a + 1 <= b - 1 else 0)\n            else:\n                for aa in [a - 1, a, a + 1]:\n                    if 0 <= aa <= aa + 1 < n and nums[aa] > nums[aa - 1] and nums[aa] > nums[aa + 1]:\n                        assert 1<=aa+1<=n\n                        tree.point_add(aa+1, -1)\n                nums[a] = b\n                for aa in [a - 1, a, a + 1]:\n                    if 0 <= aa < aa + 1 < n and nums[aa] > nums[aa - 1] and nums[aa] > nums[aa + 1]:\n                        assert 1 <= aa + 1 <= n\n                        tree.point_add(aa+1, 1)\n        return res",
    "submit_ts": "1718506128",
    "subm_id": "539772995"
}