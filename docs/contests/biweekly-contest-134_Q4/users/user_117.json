{
    "username": "plyusnovdmitrii",
    "submission": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\n/* clang-format off */\n\n/* TYPES  */\n#define ll long long\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vi vector<int>\n#define vll vector<long long>\n#define vpii vector<pair<int, int>>\n#define vpii vector<pair<int, int>>\n#define vvpii vector<vector<pair<int, int>>>\n#define vpll vector<pair<long long, long long>>\n#define vvpll vector<vector<pair<long long, long long>>>\n#define vvi vector<vector<int>>\n#define vvll vector<vector<long long>>\n#define mii map<int, int>\n#define si set<int>\n#define sc set<char>\n\n\n\n/* FUNCTIONS */\n#define feach(el, v) for(auto &el: v)\n#define rep(i, n) for(int i=0;i<n;i++)\n#define factloop(i, s, n) for(long long i=s;i*i<=n;i++)\n#define reprv(i, n) for(int i=n-1;i>=0;i--)\n#define reps(i, s, e) for(int i=s;i<e;i++)\n#define reprve(i, e, s) for(int i=e-1;i>=s;i--)\n#define repe(x, y) for (auto &x: y)\n#define repe2(x, a, y) for (auto &[x,a]: y)\n\n\n\nconst ll mod = 1000000007;\n\ntemplate<ll mod = 1000000007>\nstruct ModInt {\n    ll p;\n\n    ModInt() : p(0) {}\n\n    ModInt(ll x) { p = x >= 0 ? x % mod : x + (-x + mod - 1) / mod * mod; }\n\n    ModInt &operator+=(const ModInt &y) {\n        p = p + *y - ((p + *y) >= mod ? mod : 0);\n        return *this;\n    }\n\n    ModInt &operator-=(const ModInt &y) {\n        p = p - *y + (p - *y < 0 ? mod : 0);\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &y) {\n        p = (p * *y) % mod;\n        return *this;\n    }\n\n    ModInt &operator%=(const ModInt &y) {\n        if (y)p %= *y;\n        return *this;\n    }\n\n    ModInt operator+(const ModInt &y) const {\n        ModInt x = *this;\n        return x += y;\n    }\n\n    ModInt operator-(const ModInt &y) const {\n        ModInt x = *this;\n        return x -= y;\n    }\n\n    ModInt operator*(const ModInt &y) const {\n        ModInt x = *this;\n        return x *= y;\n    }\n\n    ModInt operator%(const ModInt &y) const {\n        ModInt x = *this;\n        return x %= y;\n    }\n\n    ModInt binpow(const ModInt &y, ll pow) const {\n        pow %= mod - 1;\n        ModInt res = 1, a = y;\n        while (pow) {\n            if (pow & 1) res *= a;\n            a *= a, pow >>= 1;\n        }\n        return res;\n    }\n\n    ModInt inv() const { return binpow(*this, mod - 2); }\n\n    ModInt &operator/=(const ModInt &y) {\n        p = (p * y.inv().p) % mod;\n        return *this;\n    }\n\n    ModInt operator/(const ModInt &y) const {\n        ModInt x = *this;\n        return x /= y;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int v;\n        is >> v;\n        a = ModInt(v);\n        return is;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &a) { return os << a.p; }\n\n    ModInt &operator++() {\n        p = (p + 1) % mod;\n        return *this;\n    }\n\n    ModInt &operator--() {\n        p = (p - 1 + mod) % mod;\n        return *this;\n    }\n\n    bool operator==(const ModInt &y) const { return p == *y; }\n\n    bool operator!=(const ModInt &y) const { return p != *y; }\n\n    const ll &operator*() const { return p; }\n\n    ll &operator*() { return p; }\n\n};\n\nusing Mint = ModInt<>;\n#define vmint vector<Mint>\n\n\n#pragma GCC target(\"popcnt\")\n#define IO ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\ntypedef tree<ll, null_type, less<>, rb_tree_tag, tree_order_statistics_node_update> oSet;\n//#define int long long int\n\n/////////////////////////////////\n\n\nclass Solution {\npublic:\n    vi str;\n\n    void build(vi &nums, int v, int tl, int tr) {\n        if (tl == tr) return void(str[v] = nums[tl]);\n\n        int tm = (tl + tr) >> 1;\n        build(nums, v << 1, tl, tm); build(nums, v << 1 | 1, tm + 1, tr);\n        str[v] = str[v << 1] & str[v << 1 | 1];\n    }\n\n    int getV(int l, int r, int v, int tl, int tr) {\n        if (l > r) return INT_MAX;\n        if (l == tl && r == tr) return str[v];\n        int tm = (tl + tr) >> 1;\n        return getV(l, min(r, tm), v << 1, tl, tm) & getV(max(l, tm + 1), r , v << 1 | 1, tm + 1, tr);\n    }\n\n    int binSearchFirst(int x, int k, int n) {\n        int l = x, r = n - 1;\n        while (r - l > 1) {\n            int m = (l + r) >> 1;\n            int qu = getV(x, m, 1, 0, n - 1);\n            if (qu > k) l = m + 1;\n            else r = m;\n        }\n        if (getV(x, l, 1, 0, n - 1) == k) return l;\n        if (getV(x, r, 1, 0, n - 1) == k) return r;\n        return -1;\n    }\n\n    int binSearchLast(int x, int k, int n) {\n        int l = x, r = n - 1;\n        while (r - l > 1) {\n            int m = (l + r) >> 1;\n            int qu = getV(x, m, 1, 0, n - 1);\n            if (qu < k) r = m - 1;\n            else l = m;\n        }\n        if (getV(x, r, 1, 0, n - 1) == k) return r;\n        if (getV(x, l, 1, 0, n - 1) == k) return l;\n        return -1;\n    }\n\n    long long countSubarrays(vector<int>& nums, int k) {\n        int n = nums.size();\n        str.resize(4 * n);\n        build(nums, 1, 0, n - 1);\n        ll ans = 0;\n        rep(i, n) {\n            int F = binSearchFirst(i, k, n);\n            if (F == -1) continue;\n            int L = binSearchLast(i, k, n);\n            ans += (L - F  + 1);\n        }\n        return ans;\n    }\n};\n",
    "submit_ts": "1720277808",
    "subm_id": "1311680962"
}