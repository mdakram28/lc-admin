{
    "username": "user0747oJ",
    "submission": "class Solution {\n    fun countOfPeaks(nums: IntArray, queries: Array<IntArray>): List<Int> {\n        val tree = SegmentPeak(nums)\n\n        return buildList {\n            for (query in queries) {\n                when (query[0]) {\n                    1 -> {\n                        val (_, l, r) = query\n\n                        add(tree.peaks(l, r + 1))\n                    }\n\n                    2 -> {\n                        val (_, index, value) = query\n\n                        tree.set(index, value)\n                    }\n                }\n            }\n        }\n    }\n\n    private class SegmentPeak(a: IntArray) {\n        private val size = a.size.takeHighestOneBit().let { if (it == a.size) it else it * 2 }\n        private val data = Array(size * 2) { Peak(0, Int.MAX_VALUE, Int.MAX_VALUE, Int.MAX_VALUE, Int.MAX_VALUE) }\n\n        init {\n            build(a, 0, 0, size)\n        }\n\n        private fun build(a: IntArray, v: Int, lv: Int, rv: Int) {\n            if (isLeaf(lv, rv)) {\n                if (lv !in a.indices) return\n\n                data[v].apply {\n                    count = 0\n                    f1 = a[lv]\n                    f2 = Int.MAX_VALUE\n                    l2 = f2\n                    l1 = f1\n                }\n                return\n            }\n\n            val middle = middle(lv, rv)\n\n            build(a, v.leftNode, lv, middle)\n            build(a, v.rightNode, middle, rv)\n            data[v].reduce(data[v.leftNode], data[v.rightNode])\n        }\n\n        private fun Peak.reduce(v1: Peak, v2: Peak) {\n            when {\n                v1.f1 == Int.MAX_VALUE -> {\n                    f1 = v2.f1\n                    f2 = v2.f2\n                    l2 = v2.l2\n                    l1 = v2.l1\n                    count = v2.count\n                }\n\n                v2.f1 == Int.MAX_VALUE -> {\n                    f1 = v1.f1\n                    f2 = v1.f2\n                    l2 = v1.l2\n                    l1 = v1.l1\n                    count = v1.count\n                }\n\n                else -> {\n                    f1 = v1.f1\n                    f2 = if (v1.f2 != Int.MAX_VALUE) v1.f2 else v2.f1\n                    l2 = if (v2.l2 != Int.MAX_VALUE) v2.l2 else v1.l1\n                    l1 = v2.l1\n                    count = v1.count + v2.count\n                    if (v1.l1 > v1.l2 && v1.l1 > v2.f1) count++\n                    if (v2.f1 > v2.f2 && v2.f1 > v1.l1) count++\n                }\n            }\n        }\n\n        fun set(index: Int, value: Int) = set(index, value, 0, 0, size)\n\n        fun peaks(l: Int, r: Int): Int = peaks(l, r, 0, 0, size).count\n\n        private fun set(index: Int, value: Int, v: Int, lv: Int, rv: Int) {\n            if (isLeaf(lv, rv)) {\n                data[v].apply {\n                    count = 0\n                    f1 = value\n                    f2 = Int.MAX_VALUE\n                    l2 = f2\n                    l1 = f1\n                }\n                return\n            }\n\n            val middle = middle(lv, rv)\n\n            if (index < middle) set(index, value, v.leftNode, lv, middle) else set(index, value, v.rightNode, middle, rv)\n            data[v].reduce(data[v.leftNode], data[v.rightNode])\n        }\n\n        private fun peaks(l: Int, r: Int, v: Int, lv: Int, rv: Int): Peak {\n            if (!intersects(l, r, lv, rv)) return Peak(0, Int.MAX_VALUE, Int.MAX_VALUE, Int.MAX_VALUE, Int.MAX_VALUE)\n            if (isInside(l, r, lv, rv)) return data[v]\n\n            val middle = middle(lv, rv)\n\n            return Peak(0, Int.MAX_VALUE, Int.MAX_VALUE, Int.MAX_VALUE, Int.MAX_VALUE).apply {\n                reduce(\n                    peaks(l, r, v.leftNode, lv, middle),\n                    peaks(l, r, v.rightNode, middle, rv)\n                )\n            }\n        }\n\n        fun intersects(l1: Int, r1: Int, l2: Int, r2: Int): Boolean = l1 < r2 && r1 > l2\n        private fun isInside(l1: Int, r1: Int, l2: Int, r2: Int): Boolean = l1 <= l2 && r2 <= r1\n\n        private fun isLeaf(lv: Int, rv: Int): Boolean = lv + 1 == rv\n        private fun middle(lv: Int, rv: Int): Int = (lv + rv) / 2\n\n        private val Int.leftNode: Int get() = 2 * this + 1\n        private val Int.rightNode: Int get() = 2 * this + 2\n    }\n\n    private class Peak(\n        var count: Int,\n        var f1: Int,\n        var f2: Int,\n        var l2: Int,\n        var l1: Int\n    )\n}",
    "submit_ts": 1718508125.0
}