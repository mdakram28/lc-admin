{
    "username": "dharani_1207",
    "submission": "from collections import deque\nfrom math import sqrt\nfrom typing import List, Tuple\n\nclass Solution:\n    def bfs_search(self, graph: List[List[int]], start_node: int, target1: int, target2: int, num_nodes: int) -> bool:\n        queue = deque([start_node])\n        visited_nodes = [False] * (num_nodes + 4)\n        visited_nodes[start_node] = True\n        \n        while queue:\n            current_node = queue.popleft()\n            for neighbor in graph[current_node]:\n                if not visited_nodes[neighbor]:\n                    queue.append(neighbor)\n                    visited_nodes[neighbor] = True\n        \n        return visited_nodes[target1] or visited_nodes[target2]\n\n    def canReachCorner(self, width: int, height: int, circle_data: List[List[int]]) -> bool:\n        num_circles = len(circle_data)\n        circles = [((circle[0], circle[1]), circle[2]) for circle in circle_data]\n        graph = [[] for _ in range(num_circles + 4)]\n        \n        for i in range(num_circles):\n            circle = circles[i]\n            \n            # Determine if the circle reaches the left boundary\n            if circle[0][0] <= circle[1]:\n                graph[num_circles].append(i)\n                graph[i].append(num_circles)\n            \n            # Determine if the circle reaches the right boundary\n            if width - circle[0][0] <= circle[1]:\n                graph[num_circles + 1].append(i)\n                graph[i].append(num_circles + 1)\n            \n            # Determine if the circle reaches the bottom boundary\n            if circle[0][1] <= circle[1]:\n                graph[num_circles + 2].append(i)\n                graph[i].append(num_circles + 2)\n            \n            # Determine if the circle reaches the top boundary\n            if height - circle[0][1] <= circle[1]:\n                graph[num_circles + 3].append(i)\n                graph[i].append(num_circles + 3)\n            \n            # Check for intersections between circles\n            for j in range(i + 1, num_circles):\n                other_circle = circles[j]\n                dist_between_centers = sqrt((circle[0][0] - other_circle[0][0]) ** 2 +\n                                            (circle[0][1] - other_circle[0][1]) ** 2)\n                if circle[1] + other_circle[1] >= dist_between_centers:\n                    graph[i].append(j)\n                    graph[j].append(i)\n        \n        # Verify if there is a path from one corner to the opposite corner\n        return not (self.bfs_search(graph, num_circles, num_circles + 1, num_circles + 2, num_circles + 4) or\n                    self.bfs_search(graph, num_circles + 3, num_circles + 1, num_circles + 2, num_circles + 4))\n",
    "submit_ts": "1722138313",
    "subm_id": "1335787549"
}