{
    "username": "jgorton500",
    "submission": "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.neighbors = set()\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        nodes1 = [Node(val) for val in range(len(edges1)+1)]\n        nodes2 = [Node(val) for val in range(len(edges2)+1)]\n\n        for a, b in edges1:\n            nodes1[a].neighbors.add(nodes1[b])\n            nodes1[b].neighbors.add(nodes1[a])\n\n        for a, b in edges2:\n            nodes2[a].neighbors.add(nodes2[b])\n            nodes2[b].neighbors.add(nodes2[a])         \n\n        def longestPath(node, prev=None):\n            if not node: return 0, 0\n            longestSinglePath = 0\n            deepest1 = 0\n            deepest2 = 0\n            for n in node.neighbors:\n                if n == prev: continue\n                depth, subPath = longestPath(n, node)\n                longestSinglePath = max(longestSinglePath, subPath)\n                deepest2, deepest1 = sorted([deepest1, deepest2, depth+1])[1:]\n            return deepest1, max(longestSinglePath, deepest1+deepest2)\n\n        tree1Longest = longestPath(nodes1[0])[1]\n        tree2Longest = longestPath(nodes2[0])[1]\n\n        # print(f'longestPath in tree1: {tree1Longest}')\n        # print(f'longestPath in tree2: {tree2Longest}')\n        return max([tree1Longest, tree2Longest, ceil(tree1Longest/2)+ceil(tree2Longest/2)+1])",
    "submit_ts": "1719718011",
    "subm_id": "1304406519"
}