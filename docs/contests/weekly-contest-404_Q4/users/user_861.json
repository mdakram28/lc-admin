{
    "username": "00101010",
    "submission": "class Solution {\npublic:\n    int finans = 0;\n    int cal(vector<vector<int>>& e) {\n        int n = e.size()+1;\n        int i;\n        vector<vector<int> > g(n);\n        vector<int> deg(n,0);\n        vector<int> lp(n,1);\n        for(i=0;i<n-1;i++) {\n            int x = e[i][0];\n            int y = e[i][1];\n            g[x].push_back(y);\n            g[y].push_back(x);\n            deg[x]++;\n            deg[y]++;\n        }\n        queue<int> q;\n        vector<int> flag(n,-1);\n        for(i=0;i<n;i++) {\n            if(deg[i]==1){\n                q.push(i);\n                flag[i] = 1;\n            }\n        }\n        int ans = 0;\n        int left = n;\n        queue<int> q1;\n        queue<int> q2;\n        while(!q.empty()) {\n            while(!q.empty()){\n                if(left==1) {\n                    int f = q.front();\n                    int max1 = -1;\n                    int max2 = -1;\n                    for(auto y:g[f]) {\n                        if(max1<=lp[y]) {\n                            max2 = max1;\n                            max1 = lp[y];\n                        } else if(max2<=lp[y]) {\n                            max2 = lp[y];\n                        }\n                    }\n                    int tt = 0;\n                    if(max1!=-1) {\n                        tt = max1;\n                    } if(max2!=-1) {\n                        tt = tt+max2;\n                    }\n                    finans = max(finans, tt);\n                    ans = max(ans, lp[f]);\n                    return ans;\n                } else if(left==2 && q.size()==2) {\n                    int f1 = q.front();\n                    q.pop();\n                    int f2 = q.front();\n                    q.pop();\n                    finans = max(finans,lp[f1]+lp[f2]-1);\n                    int tt = min(lp[f1]+1,lp[f2]);\n                    tt = min(tt,min(lp[f2]+1,lp[f1]));\n                    return max(ans,1+tt);\n                }\n                int f = q.front();\n                ans = max(ans, lp[f]);\n                q.pop();\n                left--;\n                for(auto x:g[f]) {\n                    if(flag[x]==-1) {\n                        deg[x]--;\n                        lp[x] = max(lp[x], lp[f]+1);\n                        if(deg[x]==1) {\n                            q1.push(x);\n                            flag[x] = 1;\n                        }\n                    }\n                }\n            }\n            q = q1;\n            q1 = q2;\n        }\n        return ans;\n        \n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& g1, vector<vector<int>>& g2) {\n       // cout << cal(g1) << endl;\n        //cout << cal(g2) << endl;\n        finans = 0;\n        int ans1 = max(cal(g1),1);\n        int ans2 = max(cal(g2),1);\n        return max(finans,ans1+ans2-1);\n        \n    }\n};",
    "submit_ts": "1719719873",
    "subm_id": "1304452764"
}