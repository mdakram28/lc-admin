{
    "username": "MofanLi",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def find_min_radius(edges):\n            g = defaultdict(set)\n            for a, b in edges:\n                g[a].add(b)\n                g[b].add(a)\n            \n            min_radius = [inf, inf]\n            seen = set()\n            @cache\n            def find_height(node):\n                seen.add(node)\n                result = 1\n                for child in g[node]:\n                    if child not in seen:\n                        result = max(result, find_height(child) + 1)\n                # print('found height for ', node, \":\", result)\n                return result\n            find_height(0)\n            def dfs(node, parent=-1, max_parent_depth=0):\n                radiuses = [(find_height(child), child) for child in g[node] if child != parent]\n                radiuses.append((max_parent_depth, parent))\n                radiuses.sort(reverse=True)\n                radiuses.append((0, -1))\n                nonlocal min_radius\n                # print('radiuses: ', radiuses)\n                min_radius = min(min_radius, [radiuses[0][0], radiuses[1][0]])\n                for child in g[node]:\n                    if child == parent:\n                        continue\n                    if child == radiuses[0][1]:\n                        mpd = radiuses[1][0]\n                    else:\n                        mpd = radiuses[0][0]\n                    dfs(child, node, mpd + 1)\n            dfs(0)\n            return min_radius\n        (r1, r2), (r3, r4) = find_min_radius(edges1), find_min_radius(edges2)\n        # print(r1, r2, r3, r4)\n        return max(r1 + r3 + 1, r1 + r2, r3 + r4)\n                    \n                    \n                    \n                    ",
    "submit_ts": 1719719488.0
}