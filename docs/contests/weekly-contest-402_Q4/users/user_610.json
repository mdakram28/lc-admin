{
    "username": "mittaludit768",
    "submission": "typedef long long ll;\n// class SegmentTree {\n// private:\n//     vector<int> tree;\n//     int n;\n\n//     bool is_peak(const vector<int>& nums, int i) {\n//         if (i <= 0 || i >= nums.size() - 1) return false;\n//         return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n//     }\n\n//     void build(const vector<int>& nums, int v, int tl, int tr) {\n//         if (tl == tr) {\n//             tree[v] = is_peak(nums, tl) ? 1 : 0;\n//         } else {\n//             int tm = (tl + tr) / 2;\n//             build(nums, v * 2, tl, tm);\n//             build(nums, v * 2 + 1, tm + 1, tr);\n//             tree[v] = tree[v * 2] + tree[v * 2 + 1];\n//         }\n//     }\n\n//     void update(const vector<int>& nums, int v, int tl, int tr, int pos) {\n//         if (tl == tr) {\n//             tree[v] = is_peak(nums, tl) ? 1 : 0;\n//         } else {\n//             int tm = (tl + tr) / 2;\n//             if (pos <= tm)\n//                 update(nums, v * 2, tl, tm, pos);\n//             else\n//                 update(nums, v * 2 + 1, tm + 1, tr, pos);\n//             tree[v] = tree[v * 2] + tree[v * 2 + 1];\n//         }\n//     }\n\n//     int query(int v, int tl, int tr, int l, int r) {\n//         if (l > r) return 0;\n//         if (l == tl && r == tr) {\n//             return tree[v];\n//         }\n//         int tm = (tl + tr) / 2;\n//         return query(v * 2, tl, tm, l, min(r, tm)) + query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);\n//     }\n\n// public:\n//     SegmentTree(const vector<int>& nums) {\n//         n = nums.size();\n//         tree.resize(4 * n);\n//         build(nums, 1, 0, n - 1);\n//     }\n\n//     void update(const vector<int>& nums, int pos) {\n//         update(nums, 1, 0, n - 1, pos);\n//         if (pos > 0) update(nums, 1, 0, n - 1, pos - 1);\n//         if (pos < n - 1) update(nums, 1, 0, n - 1, pos + 1);\n//     }\n\n//     int query(int l, int r) {\n//         return query(1, 0, n - 1, l, r);\n//     }\n// };\nclass SG {\npublic:\n    vector<ll> seg;\n    ll n;\n\n    SG(ll n) : n(n) {\n        seg.resize(4 * n + 1);\n    }\n\n    bool is_peak(const vector<ll>& nums, ll i) {\n        if (i <= 0 || i >= nums.size() - 1) return false;\n        return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    }\n\n    void build(const vector<ll>& arr, int low, int high, int ind) {\n        if (low == high) {\n            seg[ind] = is_peak(arr, low);\n            return;\n        }\n        ll mid = (high - low) / 2 + low;\n        build(arr, low, mid, 2 * ind + 1);\n        build(arr, mid + 1, high, 2 * ind + 2);\n        seg[ind] = seg[ind * 2 + 1] + seg[ind * 2 + 2];\n    }\n\n    ll query(ll ind, ll l, ll r, ll low, ll high) {\n        if (l > high || r < low) return 0;\n        if (l <= low && high <= r) return seg[ind];\n        ll mid = (high - low) / 2 + low;\n        return query(2 * ind + 1, l, r, low, mid) + query(2 * ind + 2, l, r, mid + 1, high);\n    }\n\n    void update(ll pos, ll low, ll high, const vector<ll>& arr) {\n        if (low == high) {\n            seg[pos] = is_peak(arr, low);\n            return;\n        }\n        ll mid = (high - low) / 2 + low;\n        if (pos <= mid) update(2 * pos + 1, low, mid, arr);\n        else update(2 * pos + 2, mid + 1, high, arr);\n        seg[pos] = seg[2 * pos + 1] + seg[2 * pos + 2];\n    }\n\n    void update_range(ll pos, ll low, ll high, const vector<ll>& arr, ll index) {\n        if (low == high) {\n            seg[pos] = is_peak(arr, low);\n            return;\n        }\n        ll mid = (high - low) / 2 + low;\n        if (index <= mid) update_range(2 * pos + 1, low, mid, arr, index);\n        else update_range(2 * pos + 2, mid + 1, high, arr, index);\n        seg[pos] = seg[2 * pos + 1] + seg[2 * pos + 2];\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        ll n = nums.size();\n        vector<ll> v(nums.begin(), nums.end());\n        SG sg(n);\n\n        sg.build(v, 0, n - 1, 0);\n\n        vector<int> ans;\n\n        for (const auto& query : queries) {\n            if (query[0] == 1) {\n                int li = query[1];\n                int ri = query[2];\n                if (li == ri || ri - li == 1) {\n                    ans.push_back(0);\n                } else {\n                    ans.push_back(sg.query(0, li + 1, ri - 1, 0, n - 1));\n                }\n            } else if (query[0] == 2) {\n                int indexi = query[1];\n                int vali = query[2];\n                v[indexi] = vali;\n\n                sg.update_range(0, 0, n - 1,v, indexi);\n                if (indexi > 0) sg.update_range(0, 0, n - 1,v, indexi - 1);\n                if (indexi < n - 1) sg.update_range(0, 0, n - 1,v, indexi + 1);\n            }\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": "1718508334",
    "subm_id": "1289678310"
}