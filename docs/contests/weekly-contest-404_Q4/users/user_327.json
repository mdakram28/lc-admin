{
    "username": "Arucade",
    "submission": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        Map<Integer, Set<Integer>> map1 = new HashMap<>(), map2 = new HashMap<>();\n        int n = edges1.length + 1, m = edges2.length + 1;\n        for (int[] e : edges1) {\n            map1.computeIfAbsent(e[0], k->new HashSet<>()).add(e[1]);\n            map1.computeIfAbsent(e[1], k->new HashSet<>()).add(e[0]);\n        }\n        for (int[] e : edges2) {\n            map2.computeIfAbsent(e[0], k->new HashSet<>()).add(e[1]);\n            map2.computeIfAbsent(e[1], k->new HashSet<>()).add(e[0]);\n        }\n        int[] c1 = new int[n], c2 = new int[m], max1 = new int[1], max2 = new int[1], min1 = new int[]{n - 1}, min2 = new int[]{m - 1};\n        dfs1(map1, 0, -1, c1);\n        dfs1(map2, 0, -1, c2);\n        dfs2(map1, 0, -1, 0, c1, max1, min1);\n        dfs2(map2, 0, -1, 0, c2, max2, min2);\n        \n        // System.out.println(min1[0] +\",\"+ min2[0]);\n        // System.out.println(max1[0] +\",\"+ max2[0]);\n        return Math.max(Math.max(max1[0], max2[0]), min1[0] + min2[0] + 1);\n    }\n    \n    private void dfs1(Map<Integer, Set<Integer>> map, int i, int p, int[] c) {\n        if (map.containsKey(i)) {\n            for (int j : map.get(i)) {\n                if (j == p) continue;\n                dfs1(map, j, i, c);\n                c[i] = Math.max(c[i], 1 + c[j]);\n            }\n        }\n    }\n    \n    private void dfs2(Map<Integer, Set<Integer>> map, int i, int p, int pv, int[] c, int[] max, int[] min) {\n        int d = Math.max(pv, c[i]);\n                // System.out.println(i +\",,\"+ d+ \",\" + pv);\n        min[0] = Math.min(min[0], d);\n        max[0] = Math.max(max[0], d);\n        \n        int m1 = 0, m2 = 0;\n        if (map.containsKey(i)) {\n            for (int j : map.get(i)) {\n                if (j == p) continue;\n                if (1 + c[j] > m1) {\n                    m2 = m1;\n                    m1 = 1 + c[j];\n                } else if (1 + c[j] > m2) m2 = 1 + c[j];     \n            }\n        }\n        \n        if (map.containsKey(i)) {\n            for (int j : map.get(i)) {\n                if (j == p) continue;\n                dfs2(map, j, i, Math.max(1 + pv, 1 + ((1 + c[j]) == m1 ? m2 : m1)), c, max, min);\n            }\n        }\n    }\n    \n}",
    "submit_ts": "1719718519",
    "subm_id": "1304419270"
}