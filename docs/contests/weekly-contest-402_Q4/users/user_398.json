{
    "username": "directioner1d",
    "submission": "from sortedcontainers import SortedList\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        # print('------------')\n        cur_peak=SortedList([])\n        for i in range(1, len(nums)-1):\n            if(nums[i-1]<nums[i] and nums[i]>nums[i+1]):\n                cur_peak.add(i)\n        ans=[]\n        n=len(nums)-1\n        def check(pos):\n            if(pos in {0,n}):\n                return \n            if(nums[pos]>nums[pos+1] and nums[pos]>nums[pos-1]):\n                if(pos not in cur_peak):\n                    cur_peak.add(pos)\n            else:\n                if(pos in cur_peak):\n                    cur_peak.discard(pos)\n        for j,i,k in queries:\n            if(j==2):\n                if(i in {0,n}):\n                    nums[i]=k\n                    if(i==0):\n                        check(i+1)\n                    else:\n                        check(i-1)\n                else:\n                    nums[i]=k\n                    check(i)\n                    check(i-1)\n                    check(i+1)\n            else:\n                # print(cur_peak)\n                p=bisect.bisect_right(cur_peak,i)\n                q=bisect.bisect_left(cur_peak,k)\n                ans.append(max(0,q-p))\n        return ans\n                        \n                \n            \n\"\"\"\nextremes can either spoil or make adjacent peak\n\nnon-extremes :\nnot a peak : can become peak or can ruin peak or help create a peak or do nothing\nfor a peak : can remain peak or can remove itself from peak or in some scenario make 1 or 2 peaks\n\"\"\"\n    ",
    "submit_ts": 1718507139.0
}