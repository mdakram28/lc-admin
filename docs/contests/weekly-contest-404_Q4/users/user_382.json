{
    "username": "danzhi",
    "submission": "class Solution {\n  public static int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n    // System.out.format(\"  edges1: %s\\n\", Utils.traceIn(edges1));\n    // System.out.format(\"  edges2: %s\\n\", Utils.traceIn(edges2));\n    int n = edges1.length + 1;\n    int m = edges2.length + 1;\n    List<Integer>[] adjs1 = getAdjs(edges1);\n    List<Integer>[] adjs2 = getAdjs(edges2);\n    List<Integer> dia1 = getDiameterOfTree(adjs1);\n    List<Integer> dia2 = getDiameterOfTree(adjs2);\n    // System.out.format(\"  dia1: %s\\n\", Utils.traceIn(dia1));\n    // System.out.format(\"  dia2: %s\\n\", Utils.traceIn(dia2));\n    int ans = dia1.size() /2 + 1 + dia2.size()/2;\n    ans = Math.max(ans, dia1.size() - 1);\n    ans = Math.max(ans, dia2.size() - 1);\n    return ans;\n  }\n\n  static List<Integer>[] getAdjs(int[][] edges) {\n    int n = edges.length + 1;\n    List<Integer>[] adjs = new ArrayList[n];\n    for (int i = 0; i < n; i++) {\n      adjs[i] = new ArrayList<>();\n    }\n    for (int[] edge : edges) {\n      int u = edge[0];\n      int v = edge[1];\n      adjs[u].add(v);\n      adjs[v].add(u);\n    }\n    return adjs;\n  }\n\n  static List<Integer> getDiameterOfTree(List<Integer>[] adjs) {\n    int n = adjs.length;\n    int[] dist1 = getDists(0, adjs);\n    // System.out.format(\"  dist1:%s\\n\", Utils.traceIn(dist1));\n    int a = 0;\n    for (int i = 0; i < n; i++) {\n      if (dist1[i] > dist1[a]) {\n        a = i;\n      }\n    }\n\n    int[] dista = getDists(a, adjs);\n    int b = 0;\n    for (int i = 0; i < n; i++) {\n      if (dista[i] > dista[b]) {\n        b = i;\n      }\n    }\n    // System.out.format(\"  a:%d b:%d\\n\", a, b);\n    // (a,b) is a diameter of the tree.\n    // Get the path from a to b.\n\n    int[] distb = getDists(b, adjs);\n    List<Integer> diameter = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n      int dsum = dista[i] + distb[i];\n      if (dsum == dista[b]) {\n        diameter.add(i);\n      }\n    }\n    Collections.sort(diameter, (x,y)->dista[x]-dista[y]);\n    return diameter;\n  }\n\n  public static int[] getDists(int r, List<Integer>[] adjs) {\n    int n = adjs.length - 1;\n    Queue<Integer> q = new LinkedList<>();\n    q.add(r);\n    int[] dists = new int[n+1];\n    Arrays.fill(dists, -1);\n    dists[r] = 0;\n    while (!q.isEmpty()) {\n      int size = q.size();\n      for (int i = 0; i < size; i++) {\n        int v = q.poll();\n        for (int w : adjs[v]) {\n          if (dists[w] == -1) {\n            dists[w] = dists[v] + 1;\n            q.add(w);\n          }\n        }\n      }\n    }\n    return dists;\n  }\n}",
    "submit_ts": 1719718740.0
}