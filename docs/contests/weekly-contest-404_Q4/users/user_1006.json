{
    "username": "Krishna_R_P",
    "submission": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int n1 = edges1.length + 1;\n        int n2 = edges2.length + 1;\n\n        List<Integer>[] tree1 = buildTree(n1, edges1);\n        List<Integer>[] tree2 = buildTree(n2, edges2);\n\n        int diameter1 = getDiameter(tree1, n1);\n        int diameter2 = getDiameter(tree2, n2);\n\n        // We need to consider the optimal node pairs from each tree\n        int[] farthestNodes1 = getFarthestNodes(tree1, n1);\n        int[] farthestNodes2 = getFarthestNodes(tree2, n2);\n\n        // Minimum possible diameter after merging the trees\n        int minDiameter = Integer.MAX_VALUE;\n        for (int node1 : farthestNodes1) {\n            for (int node2 : farthestNodes2) {\n                int potentialDiameter = Math.max(diameter1, Math.max(diameter2, (diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1));\n                minDiameter = Math.min(minDiameter, potentialDiameter);\n            }\n        }\n\n        return minDiameter;\n    }\n\n    private List<Integer>[] buildTree(int n, int[][] edges) {\n        List<Integer>[] tree = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            tree[i] = new ArrayList<>();\n        }\n        for (int[] edge : edges) {\n            tree[edge[0]].add(edge[1]);\n            tree[edge[1]].add(edge[0]);\n        }\n        return tree;\n    }\n\n    private int getDiameter(List<Integer>[] tree, int n) {\n        int[] farthest = bfs(tree, n, 0);\n        farthest = bfs(tree, n, farthest[0]);\n        return farthest[1];\n    }\n\n    private int[] getFarthestNodes(List<Integer>[] tree, int n) {\n        int[] farthest = bfs(tree, n, 0);\n        int[] result = bfs(tree, n, farthest[0]);\n        return new int[]{farthest[0], result[0]};\n    }\n\n    private int[] bfs(List<Integer>[] tree, int n, int start) {\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] visited = new boolean[n];\n        queue.offer(start);\n        visited[start] = true;\n\n        int node = start;\n        int distance = 0;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            distance++;\n            for (int i = 0; i < size; i++) {\n                int current = queue.poll();\n                for (int neighbor : tree[current]) {\n                    if (!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        queue.offer(neighbor);\n                        node = neighbor;\n                    }\n                }\n            }\n        }\n\n        return new int[]{node, distance - 1};\n    }\n}",
    "submit_ts": "1719718282",
    "subm_id": "1304413337"
}