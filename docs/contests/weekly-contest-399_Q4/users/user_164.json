{
    "username": "vermachakshu",
    "submission": "\ntypedef long long ll;\n\nstruct Node{\n    long long f1, f2, f3, f4;\n    long long f;\n    Node(int x = 0, int y = 0, int z = 0, int p = 0){\n        f1 = x; // [l, r]\n        f2 = y; // [l, r - 1]\n        f3 = z; // [l + 1, r - 1]\n        f4 = p; // [l + 1, r]\n        f = max({x, y, z, p});\n    }\n};\n\n\nconst int MOD = 1e9 + 7;\n\nstruct seg_tree{\n    Node NEUTRAL_ELEMENT;\n    int NEUTRAL_UPDATE;\n    ll size;\n    int N;\n    vector<int> lazy;\n    vector<Node> st;\n\n    void init(int n){\n        size = 1;\n        N = n;\n        while(size < n) size <<= 1;\n\n        NEUTRAL_UPDATE = -1;\n        NEUTRAL_ELEMENT = Node();\n        lazy.assign(2 * size, NEUTRAL_UPDATE);\n        st.assign(2 * size, NEUTRAL_ELEMENT);\n    }\n\n    Node combine(Node x, Node y){\n        Node res = Node();\n        res.f1 = max({x.f1 + y.f4, x.f2 + y.f1, x.f2 + y.f4}) % MOD;\n        res.f2 = max({x.f1 + y.f3, x.f2 + y.f2, x.f2 + y.f3}) % MOD;\n        res.f3 = max({x.f4 + y.f3, x.f3 + y.f2, x.f3 + y.f3}) % MOD;\n        res.f4 = max({x.f3 + y.f1, x.f3 + y.f4, x.f4 + y.f4}) % MOD;\n        res.f = max({res.f1, res.f2, res.f3 ,res.f4});\n        return res;\n    }\n\n    Node apply(Node curr, int upd, int lx, int rx){\n        if(upd == NEUTRAL_UPDATE)   return curr;\n        Node res = Node(upd, 0, 0, 0);\n        // res.f = res.f1 = upd;\n        return res;\n    }\n\n    int combineUpdate(int new_upd, int old_upd){\n        int res =(new_upd == NEUTRAL_UPDATE)?old_upd:new_upd;\n        return res;\n    }\n\n    void build(int node, int lx, int rx){\n        if(rx - lx == 1){\n            if(lx < N)\n                st[node] = 0;\n            return;\n        }\n        int tm = (lx + rx) >> 1;\n        build(2*node + 1, lx, tm);\n        build(2*node + 2, tm, rx);\n        st[node] = combine(st[2*node + 1], st[2*node + 2]);\n    }\n\n    void propagate(ll node, ll lx, ll rx){\n        if(rx - lx > 1){\n            // Non leaf node\n            int tm = (lx + rx) >> 1;\n            lazy[2*node + 1] = combineUpdate(lazy[node], lazy[2*node + 1]);\n            lazy[2*node + 2] = combineUpdate(lazy[node], lazy[2*node + 2]);\n            st[2*node + 1] = apply(st[2*node + 1], lazy[node], lx, tm);\n            st[2*node + 2] = apply(st[2*node + 2], lazy[node], tm, rx);\n            lazy[node] = NEUTRAL_UPDATE;\n        }\n    }\n\n    void update(int l, int r, int node, int val, int lx, int rx){\n        if(lx >= r || rx <= l){\n            return;\n        }\n        if(lx >= l && rx <= r){\n            lazy[node] = combineUpdate(val, lazy[node]);\n            st[node] = apply(st[node], val, lx, rx);\n            return;\n        }\n\n        propagate(node, lx, rx);\n        int m = (lx + rx) >> 1;\n        update(l, r, 2 * node + 1, val, lx, m);\n        update(l, r, 2 * node + 2, val, m, rx);\n        st[node] = combine(st[2 * node + 1], st[2 * node + 2]);\n    }\n\n    void update(int l, int r, int val){\n        update(l, r, 0, val, 0, size);\n    }\n\n    Node query(int l, int r, int node, int lx, int rx){\n        if(rx <= l || lx >= r)  return NEUTRAL_ELEMENT;\n        if(lx >= l && rx <= r){\n            return st[node];\n        }\n        propagate(node, lx, rx);\n        int m = (lx + rx) >> 1;\n        Node res = combine(query(l, r, 2 * node + 1, lx, m), query(l, r, 2 * node + 2, m, rx));\n        st[node] = combine(st[2 * node + 1], st[2 * node + 2]);\n        return res;\n    }\n\n    Node query(int l, int r){\n        return query(l, r, 0, 0, size);\n    }\n\n    void build(){\n        build(0, 0, size);\n    }\n};\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        ll ans = 0;\n        seg_tree st;\n        int n = nums.size();\n        st.init(n + 1);\n        \n        for(int i=0; i<n; i++){\n            st.update(i, i + 1, max(0, nums[i]));\n            // cout << st.query(i, i + 1).f << endl;\n        }\n        \n        for(auto q:queries){\n            int idx = q[0];\n            int x = max(0, q[1]);\n            // cout << idx << \" \";\n            st.update(idx, idx + 1, x);\n            // cout << st.query(idx, idx + 1).f1 << \"\\n\";\n            ll tmp = st.query(0, n).f;\n            // cout << tmp << endl;\n            ans = (ans + tmp) % MOD;\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": 1716695003.0
}