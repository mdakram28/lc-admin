{
    "username": "toshan-luktuke",
    "submission": "#define ll long long\nclass Solution {\npublic:\n\n    bool touchOrIntersect(const vector<int>& circle1, const vector<int>& circle2) {\n        int x1 = circle1[0], y1 = circle1[1], r1 = circle1[2];\n        int x2 = circle2[0], y2 = circle2[1], r2 = circle2[2];\n        long long distSq = (ll)(x1 - x2) * (ll)(x1 - x2) + (ll)(y1 - y2) * (ll)(y1 - y2);\n        long long radiusSumSq = (ll)(r1 + r2) * (ll)(r1 + r2);\n        return distSq <= radiusSumSq;\n    }\n\n    bool around(const vector<int>& circle, int X, int Y) {\n        int x = circle[0], y = circle[1], r = circle[2];\n        // Check if the circle contains the origin (0, 0)\n        if ((ll)x * (ll)x + (ll)y * (ll)y <= (ll)r * (ll)r) return true;\n        // Check if the circle contains the point (X, Y)\n        if ((ll)(x - X) * (ll)(x - X) + (ll)(y - Y) * (ll)(y - Y) <= (ll)r * (ll)r) return true;\n        return false;\n    }\n\n    // BFS to check if we can reach from one set of circles to another\n    bool bfsCheck(const vector<vector<int>>& adj, const unordered_set<int>& startSet, const unordered_set<int>& targetSet) {\n        queue<int> q;\n        unordered_set<int> visited;\n        \n        // Initialize the queue with the starting set\n        for (int start : startSet) {\n            q.push(start);\n            visited.insert(start);\n        }\n        \n        while (!q.empty()) {\n            int current = q.front();\n            q.pop();\n            \n            if (targetSet.find(current) != targetSet.end()) {\n                return true;\n            }\n            \n            for (int neighbor : adj[current]) {\n                if (visited.find(neighbor) == visited.end()) {\n                    q.push(neighbor);\n                    visited.insert(neighbor);\n                }\n            }\n        }\n        \n        return false;\n    }\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        // is there a circle around origin or around the edge\n        // if we can do something like bfs with the circles\n        // see if there is a chain of circles that all intersect or touch each other\n        // and see if they touch\n        // bottom wall AND left wall\n        // top wall AND right wall\n        // left wall AND right wall\n        // top wall AND bottom wall\n        int n = circles.size();\n        vector<vector<int>> adj(n);\n\n        // Build the adjacency list\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (touchOrIntersect(circles[i], circles[j])) {\n                    adj[i].push_back(j);\n                    adj[j].push_back(i);\n                }\n                if(around(circles[i], X, Y)){\n                    return false;\n                }\n            }\n        }\n        \n        // Sets to keep track of circles touching each wall\n        unordered_set<int> bottomWall, topWall, leftWall, rightWall;\n\n        // Determine which circles touch which walls\n        for (int i = 0; i < n; ++i) {\n            int x = circles[i][0], y = circles[i][1], r = circles[i][2];\n            if (y - r <= 0) bottomWall.insert(i);\n            if (y + r >= Y) topWall.insert(i);\n            if (x - r <= 0) leftWall.insert(i);\n            if (x + r >= X) rightWall.insert(i);\n        }\n        \n        // Check for connectivity between required walls using BFS\n        if (bfsCheck(adj, bottomWall, leftWall) || \n            bfsCheck(adj, topWall, rightWall) || \n            bfsCheck(adj, leftWall, rightWall) || \n            bfsCheck(adj, topWall, bottomWall)) {\n            return false;\n        }\n\n        return true;\n    }\n};",
    "submit_ts": "1722137370",
    "subm_id": "1335761825"
}