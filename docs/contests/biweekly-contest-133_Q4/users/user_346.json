{
    "username": "user6675CH",
    "submission": "class Solution {\npublic:\n    int numberOfPermutations(int n, vector<vector<int>>& requirements) {\n        const int MOD = 1'000'000'007;\n        int maxInversions = n * (n - 1) / 2;\n\n        // Sort requirements by end index to process them in order\n        sort(requirements.begin(), requirements.end());\n\n        // DP array: dp[k] -> number of permutations of length i with exactly k inversions\n        vector<int> dp(maxInversions + 1, 0);\n        dp[0] = 1; // Base case\n\n        // Precompute prefix sums for requirements\n        vector<int> reqCount(n + 1, -1); // -1 means no requirement\n        for (const auto& req : requirements) {\n            reqCount[req[0] + 1] = req[1];\n        }\n\n        for (int i = 1; i <= n; ++i) {\n            vector<int> new_dp(maxInversions + 1, 0);\n            vector<int> prefixSum(maxInversions + 2, 0);\n\n            // Compute prefix sums\n            for (int k = 0; k <= maxInversions; ++k) {\n                prefixSum[k + 1] = (prefixSum[k] + dp[k]) % MOD;\n            }\n\n            for (int k = 0; k <= maxInversions; ++k) {\n                if (k >= i) {\n                    new_dp[k] = (prefixSum[k + 1] - prefixSum[k + 1 - i] + MOD) % MOD;\n                } else {\n                    new_dp[k] = prefixSum[k + 1] % MOD;\n                }\n            }\n\n            dp = new_dp;\n\n            // Check requirements and invalidate states if necessary\n            if (reqCount[i] != -1) {\n                for (int k = 0; k <= maxInversions; ++k) {\n                    if (k != reqCount[i]) {\n                        dp[k] = 0;\n                    }\n                }\n            }\n        }\n\n        // Sum all valid permutations of length `n`\n        int result = 0;\n        for (int k = 0; k <= maxInversions; ++k) {\n            result = (result + dp[k]) % MOD;\n        }\n\n        return result;\n    }\n};\n",
    "submit_ts": "1719069072",
    "subm_id": "1296785743"
}