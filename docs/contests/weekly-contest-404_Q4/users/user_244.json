{
    "username": "zzjjbb",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def diameter(ed):\n            if not ed:\n                return 0\n            adj = defaultdict(list)\n            for u, v in ed:\n                adj[u].append(v)\n                adj[v].append(u)\n            def dfs(node, n):\n                visited[node] = True\n                cand = None\n                dd = 0\n                for ch in adj[node]:\n                    if not visited[ch]:\n                        flag = True\n                        nc, nd = dfs(ch, n + 1)\n                        if nd > dd:\n                            cand = nc\n                            dd = nd\n                if cand is None:\n                    return node, n\n                else:\n                    return cand, dd\n            # print(dfs(0, 0))\n            visited = [False] * len(adj)\n            node1, _ = dfs(0, 0)\n            visited = [False] * len(adj)\n            # print(dfs(node1, 0))\n            _, d = dfs(node1, 0)\n            return d\n        \n#         n, m = len(edges1) + 1, len(edges2) + 1\n#         adj1 = defaultdict(list)\n        \n#         for u, v in edges2:\n#             adj2[u].append(v)\n#             adj2[v].append(u)\n        d1, d2 = diameter(edges1), diameter(edges2)\n        return max(d1, d2, (d1 + 1) // 2 + (d2 + 1) // 2 + 1)",
    "submit_ts": 1719717448.0
}