{
    "username": "JasonL14",
    "submission": "class Node:\n    def __init__(self):\n        self.cost = -1 #-1 cost indicates it is not an ending.\n        self.children = [None] * 26\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def getIndex(self, character):\n        return ord(character) - ord('a')\n    \n    def insert(self, word, cost):\n        currentNode = self.root\n        for character in word:\n            if currentNode.children[self.getIndex(character)] is None:\n                currentNode.children[self.getIndex(character)] = Node()\n            currentNode = currentNode.children[self.getIndex(character)]\n        if currentNode.cost == -1:\n            currentNode.cost = cost\n        else:\n            currentNode.cost = min(cost, currentNode.cost)\n\n    #returns all prefix matches for the current target string\n    def findMatches(self, targetString):\n        currentNode = self.root\n        count = 0\n        res = []\n\n        for character in targetString:\n            if currentNode.children[self.getIndex(character)] is None:\n                return res\n            currentNode = currentNode.children[self.getIndex(character)]\n            count += 1\n            if currentNode.cost != -1:\n                res.append((count, currentNode.cost))\n        return res\n\nclass Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        if target == \"\": return 0\n\n        trie = Trie()\n        n = len(words)\n        for i in range(n):\n            trie.insert(words[i], costs[i])\n\n        # cache = [-1] * len(target)\n\n        # def recurs(targetIndex):\n        #     if targetIndex == len(target): return 0\n        #     if cache[targetIndex] != -1: return cache[targetIndex]\n        #     res = float('inf')\n\n        #     matches = trie.findMatches(target[targetIndex:])\n        #     for match in matches:\n        #         length, cost = match\n        #         res = min(res, cost + recurs(targetIndex + length))\n\n        #     cache[targetIndex] = res\n        #     return res\n        \n        # result = recurs(0)\n        # if result == float('inf'): return -1\n        # return result\n\n        dp = [0] * (len(target) + 1)\n        for i in range(len(target)-1, -1, -1):\n            dp[i] = float('inf')\n\n            matches = trie.findMatches(target[i:])\n            for match in matches:\n                length, cost = match\n                dp[i] = min(dp[i], cost + dp[i + length])\n        if dp[0] == float('inf'): return -1\n        return dp[0]\n\n\n    ",
    "submit_ts": "1720321384",
    "subm_id": "1312321431"
}