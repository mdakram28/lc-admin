{
    "username": "Weeentar_Wind",
    "submission": "class Solution {\npublic:\n    \n int getMid(int s, int e) \n{\n\treturn s + (e - s) / 2;\n}\n\nint MaxUtil(int* st, int ss, int se, int l, int r, int node)\n{\n\tif (l <= ss && r >= se)\n\t\treturn st[node];\n\n\tif (se < l || ss > r)\n\t\treturn -1;\n\n\tint mid = getMid(ss, se);\n\t\n\treturn max(MaxUtil(st, ss, mid, l, r, 2 * node + 1),MaxUtil(st, mid + 1, se, l, r, 2 * node + 2));\n}\n\n\nvoid updateValue(vector<int>&arr , int* st, int ss, int se, int index, int value, int node)\n{\n\tif (ss == se) \n\t{ \n\t\tarr[index] = value;\n\t\tst[node] = value;\n\t}\n\telse \n\t{\n\t\t\tint mid = getMid(ss, se);\n\t\t\t\n\t\t\tif (index >= ss && index <= mid)\n\t\t\t\tupdateValue(arr, st,ss, mid, index, value, 2 * node + 1);\n\t\t\telse\n\t\t\t\tupdateValue(arr, st, mid + 1, se, index,value, 2 * node + 2);\n\t\t\t\n\t\t\tst[node] = max(st[2 * node + 1], st[2 * node + 2]);\n\t}\n\treturn;\n}\n\nint getMax(int* st, int n, int l, int r)\n{\n\treturn MaxUtil(st, 0, n - 1, l, r, 0);\n}\n\nint constructSTUtil(vector<int> &arr , int ss, int se, int* st, int si)\n{\n\tif (ss == se) \n\t{\n\t\tst[si] = arr[ss];\n\t\treturn arr[ss];\n\t}\n\tint mid = getMid(ss, se);\n\tst[si] = max(constructSTUtil(arr, ss, mid, st, si * 2 + 1),constructSTUtil(arr, mid + 1, se, st, si * 2 + 2));\n\treturn st[si];\n}\n\n\nint* constructST(vector<int> &arr , int n)\n{\n\tint x = (int)(ceil(log2(n)));\n\tint max_size = 2 * (int)pow(2, x) - 1;\n\tint* st = new int[max_size];\n\tconstructSTUtil(arr, 0, n - 1, st, 0);\n\treturn st;\n}\n\nvector<bool> getResults(vector<vector<int>>& q) \n{\n   \n   int m = q.size();\n   m = 3*m;\t\n   \n   int n = m < 5e4 ? m + 1 : 5e4 + 1 ;\n   vector<int>arr(n,0);       \n   set<int>pos;\n   vector<bool>ans;\n   \n   int* st = constructST(arr, n);\n   \n   for( auto it : q )\n   {\n   \t    int type = it[0];\n   \t    int curr = it[1];\n   \t  \n\t    if( type == 1 )\n   \t    {\n   \t    \n\t\tif( pos.empty() )\n\t\t   \t\tupdateValue(arr, st , 0 , n - 1 , curr , curr , 0 );\n\t\telse\n\t\t{\n\t\t\tauto iter = pos.upper_bound(it[1]);\n\t\t\tif( iter != pos.end() )\n\t\t\t{\n\t\t\t\tint next = *iter;\t\t\n\t\t\t\tint gap = next - curr;\n\t\t\t\tupdateValue(arr, st , 0 , n - 1 , next , gap , 0 );\n\t\t\t}\n\t\t\t\n\t\t\tif( iter == pos.begin())\n\t\t\tupdateValue(arr, st , 0 , n - 1 , curr , curr , 0 );\n\t\t\telse\n\t\t\t{\n\t\t\t\titer--;\n\t\t\t\tint prev = *iter;\n\t\t\t\tint gap = curr - prev;\n\t\t\t\tupdateValue(arr, st , 0 , n - 1 , curr , gap , 0 );\n\t\t\t}\n\t\t    \t\n\t\t}\t\n            \n\t    pos.insert(curr);\t\t\n\t  \n\t  }\n\t  \n\t  else\n\t  {\n\t  \t\n\t  \tint size = it[2];\n\t  \tint mx = getMax(st,n,0,curr);\n\t  \t\n        if( size > curr ) \n        {\n            ans.push_back(false);\n            continue;\n        }\n          \n\t  \tif( pos.empty() || mx >= size )\n\t  \t{\n\t  \t  ans.push_back(true);\n\t\t  continue;\t\n\t\t}\n          \n        if( curr <= *pos.begin() )\n        {\n            ans.push_back(true);\n            continue;\n        }\n          \n\t//\tcout<<mx<<endl;\n\t  \t//check or get max in the previous \n\t  \tauto iter = pos.lower_bound(curr);  \n\t\tif( iter == pos.end() || *iter > curr )\n\t  \t{\n\t  \t  iter--;\n\t\t  int prev = *iter;\n\t\t  mx = max(mx,curr-prev);\t\t\n\t\t}\n\t\t\n\t\tif( mx >= size )\n\t\tans.push_back(true);\n\t\telse\n\t\tans.push_back(false);\n\t  }\n   }\n   \n   return ans;\n}\n};",
    "submit_ts": 1716652132.0
}