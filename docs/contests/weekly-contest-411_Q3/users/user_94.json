{
    "username": "megaspazz",
    "submission": "import java.math.*;\n\nclass Solution {\n    public String largestPalindrome(int n, int k) {\n        switch (k) {\n            case 1:\n            case 3:\n            case 9: {\n                return \"9\".repeat(n);\n            }\n            case 2: {\n                if (n == 1) {\n                    return \"8\";\n                }\n                return \"8\" + \"9\".repeat(n - 2) + \"8\";\n            }\n            case 4: {\n                if (n < 4) {\n                    return \"8\".repeat(n);\n                }\n                return \"88\" + \"9\".repeat(n - 4) + \"88\";\n            }\n            case 5: {\n                if (n == 1) {\n                    return \"5\";\n                }\n                return \"5\" + \"9\".repeat(n - 2) + \"5\";\n            }\n            case 6: {\n                if (n <= 4) {\n                    for (int x : PALINS[n]) {\n                        if (x % 6 == 0) {\n                            return Integer.toString(x);\n                        }\n                    }\n                }\n                int mids = (n % 2 == 0) ? 2 : 1;\n                int nines = ((n - mids) / 2) - 1;\n                for (int d = 9; d >= 0; --d) {\n                    String s = \"8\" + \"9\".repeat(nines) + Integer.toString(d).repeat(mids) + \"9\".repeat(nines) + \"8\";\n                    BigInteger bi = new BigInteger(s);\n                    if (bi.mod(BigInteger.valueOf(6)).equals(BigInteger.ZERO)) {\n                        return s;\n                    }\n                }\n                throw new RuntimeException(\"ggwp 6\");\n            }\n            case 7: {\n                if (n <= 2) {\n                    for (int x : PALINS[n]) {\n                        if (x % 7 == 0) {\n                            return Integer.toString(x);\n                        }\n                    }\n                }\n                int mids = (n % 2 == 0) ? 2 : 1;\n                int nines = (n - mids) / 2;\n                for (int d = 9; d >= 0; --d) {\n                    String s = \"9\".repeat(nines) + Integer.toString(d).repeat(mids) + \"9\".repeat(nines);\n                    BigInteger bi = new BigInteger(s);\n                    if (bi.mod(BigInteger.valueOf(7)).equals(BigInteger.ZERO)) {\n                        return s;\n                    }\n                }\n                throw new RuntimeException(\"ggwp 7\");\n            }\n            case 8: {\n                if (n <= 6) {\n                    return \"8\".repeat(n);\n                }\n                return \"888\" + \"9\".repeat(n - 6) + \"888\";\n            }\n        }\n        throw new RuntimeException(\"ggwp overall\");\n    }\n    \n    private static boolean isPalindrome(int x) {\n        if (x < 0 || ((x != 0) && (x % 10 == 0))) {\n            return false;\n        }\n        int y = 0;\n        while (x > y) {\n            y = (y * 10) + (x % 10);\n            x /= 10;\n        }\n        return (x == y) || (x == y / 10);\n    }\n    \n    private static final int[][] PALINS = {\n        null,\n        getPalins(1, 9),\n        getPalins(10, 99),\n        getPalins(100, 999),\n        getPalins(1000, 9999),\n    };\n    \n    private static int[] getPalins(int lo, int hi) {\n        IntDeque lst = new IntDeque();\n        for (int i = hi; i >= lo; --i) {\n            if (isPalindrome(i)) {\n                lst.add(i);\n            }\n        }\n        return lst.toArray();\n    }\n    \n    // private static int[] initPalins10() {\n    //     IntDeque lst = new IntDeque();\n    //     for (int i = 9999; i > 0; ++i) {\n    //         if (isPalindrome(i)) {\n    //             lst.add(i);\n    //         }\n    //     }\n    //     return lst.toArray();\n    // }\n    \n//     private static final long[][] PALINS = new long[10][];\n//     private static final long[] POW10 = new long[10];\n    \n//     private static long[] getPalindromes(int n) {\n//         if (PALINS[n] == null) {\n//             LongDeque lst = new LongDeque();\n//             int half = n >> 1;\n//             for (int i = 0; i < half; ++i) {\n                \n//             }\n            \n//         }\n//         return PALINS[k];\n//     }\n    \n//     private static long pow10(int x) {\n//         long ans = 1;\n//         for (int i = 0; i < x; ++i) {\n//             ans *= 10;\n//         }\n//         return ans;\n//     }\n        \n\t/**\n\t * Circular buffer of int values, can be used as:\n\t *   - ArrayList: values are added to end.\n\t *   - Queue: values are added to end and removed from front.\n\t *   - Stack: values are added to and removed from front.\n\t */\n\tpublic static class IntDeque {\n\t\tprivate int[] arr;\n\t\tprivate int off;\n\t\tprivate int len;\n\n\t\tpublic IntDeque() {\n\t\t\tthis(2);\n\t\t}\n\n\t\tpublic IntDeque(int capacity) {\n\t\t\tthis.arr = new int[capacity];\n\t\t}\n\n\t\tpublic void addFirst(int x) {\n\t\t\tif (len == arr.length) {\n\t\t\t\tincreaseCapacity();\n\t\t\t}\n\t\t\tif (off == 0) {\n\t\t\t\toff = arr.length;\n\t\t\t}\n\t\t\tarr[--off] = x;\n\t\t\t++len;\n\t\t}\n\n\t\tpublic void addLast(int x) {\n\t\t\tif (len == arr.length) {\n\t\t\t\tincreaseCapacity();\n\t\t\t}\n\t\t\tint idx = index(off + len);\n\t\t\tarr[idx] = x;\n\t\t\t++len;\n\t\t}\n\n\t\tpublic int peekFirst() {\n\t\t\treturn arr[off];\n\t\t}\n\n\t\tpublic int peekLast() {\n\t\t\tint idx = index(off + len - 1);\n\t\t\treturn arr[idx];\n\t\t}\n\n\t\tpublic int removeFirst() {\n\t\t\tint ans = peekFirst();\n\t\t\toff = index(off + 1);\n\t\t\t--len;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic int removeLast() {\n\t\t\tint ans = peekLast();\n\t\t\t--len;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic void add(int x) {\n\t\t\taddLast(x);\n\t\t}\n\n\t\tpublic void offer(int x) {\n\t\t\taddLast(x);\n\t\t}\n\n\t\tpublic int poll() {\n\t\t\treturn removeFirst();\n\t\t}\n\n\t\tpublic void push(int x) {\n\t\t\taddFirst(x);\n\t\t}\n\n\t\tpublic int pop() {\n\t\t\treturn removeFirst();\n\t\t}\n\n\t\tpublic int peek() {\n\t\t\treturn peekFirst();\n\t\t}\n\n\t\tpublic int get(int i) {\n\t\t\tif (i >= len) {\n\t\t\t\tthrow new ArrayIndexOutOfBoundsException(String.format(\"index %d out of range [0, %d)\", i, len));\n\t\t\t}\n\t\t\tint idx = index(i + off);\n\t\t\treturn arr[idx];\n\t\t}\n\n\t\tpublic void set(int i, int x) {\n\t\t\tif (i >= len) {\n\t\t\t\tthrow new ArrayIndexOutOfBoundsException(String.format(\"index %d out of range [0, %d)\", i, len));\n\t\t\t}\n\t\t\tint idx = index(i + off);\n\t\t\tarr[idx] = x;\n\t\t}\n\n\t\tpublic int size() {\n\t\t\treturn len;\n\t\t}\n\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size() == 0;\n\t\t}\n\n\t\tpublic int[] toArray() {\n\t\t\tif (len == 0) {\n\t\t\t\treturn new int[0];\n\t\t\t}\n\t\t\tint idx = index(off + len);\n\t\t\tif (idx > off) {\n\t\t\t\treturn Arrays.copyOfRange(arr, off, idx);\n\t\t\t}\n\t\t\tint[] A = new int[len];\n\t\t\tint endLen = arr.length - off;\n\t\t\tint startLen = len - endLen;\n\t\t\tSystem.arraycopy(arr, off, A, 0, endLen);\n\t\t\tSystem.arraycopy(arr, 0, A, endLen, startLen);\n\t\t\treturn A;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append('[');\n\t\t\tprintToBuffer(sb, \", \");\n\t\t\tsb.append(']');\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tprivate void increaseCapacity() {\n\t\t\tint[] next = new int[arr.length << 1];\n\t\t\tint endLen = arr.length - off;\n\t\t\tSystem.arraycopy(arr, off, next, 0, endLen);\n\t\t\tSystem.arraycopy(arr, 0, next, endLen, off);\n\t\t\tarr = next;\n\t\t\toff = 0;\n\t\t}\n\n\t\tprivate int index(int i) {\n\t\t\tif (i >= arr.length) {\n\t\t\t\ti -= arr.length;\n\t\t\t} else if (i < 0) {\n\t\t\t\ti += arr.length;\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\n\t\tprivate void printToBuffer(StringBuilder sb, CharSequence sep) {\n\t\t\tfor (int i = 0; i < len; ++i) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(sep);\n\t\t\t\t}\n\t\t\t\tsb.append(get(i));\n\t\t\t}\n\t\t}\n\n\t\tpublic static IntDeque of(int... arr) {\n\t\t\tIntDeque deq = new IntDeque();\n\t\t\tfor (int x : arr) {\n\t\t\t\tdeq.add(x);\n\t\t\t}\n\t\t\treturn deq;\n\t\t}\n\t}\n    \n\t/**\n\t * Circular buffer of long values, can be used as:\n\t *   - ArrayList: values are added to end.\n\t *   - Queue: values are added to end and removed from front.\n\t *   - Stack: values are added to and removed from front.\n\t */\n\tpublic static class LongDeque {\n\t\tprivate long[] arr;\n\t\tprivate int off;\n\t\tprivate int len;\n\n\t\tpublic LongDeque() {\n\t\t\tthis(2);\n\t\t}\n\n\t\tpublic LongDeque(int capacity) {\n\t\t\tthis.arr = new long[capacity];\n\t\t}\n\n\t\tpublic void addFirst(long x) {\n\t\t\tif (len == arr.length) {\n\t\t\t\tincreaseCapacity();\n\t\t\t}\n\t\t\tif (off == 0) {\n\t\t\t\toff = arr.length;\n\t\t\t}\n\t\t\tarr[--off] = x;\n\t\t\t++len;\n\t\t}\n\n\t\tpublic void addLast(long x) {\n\t\t\tif (len == arr.length) {\n\t\t\t\tincreaseCapacity();\n\t\t\t}\n\t\t\tint idx = index(off + len);\n\t\t\tarr[idx] = x;\n\t\t\t++len;\n\t\t}\n\n\t\tpublic long peekFirst() {\n\t\t\treturn arr[off];\n\t\t}\n\n\t\tpublic long peekLast() {\n\t\t\tint idx = index(off + len - 1);\n\t\t\treturn arr[idx];\n\t\t}\n\n\t\tpublic long removeFirst() {\n\t\t\tlong ans = peekFirst();\n\t\t\toff = index(off + 1);\n\t\t\t--len;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic long removeLast() {\n\t\t\tlong ans = peekLast();\n\t\t\t--len;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic void add(long x) {\n\t\t\taddLast(x);\n\t\t}\n\n\t\tpublic void offer(long x) {\n\t\t\taddLast(x);\n\t\t}\n\n\t\tpublic long poll() {\n\t\t\treturn removeFirst();\n\t\t}\n\n\t\tpublic void push(long x) {\n\t\t\taddFirst(x);\n\t\t}\n\n\t\tpublic long pop() {\n\t\t\treturn removeFirst();\n\t\t}\n\n\t\tpublic long peek() {\n\t\t\treturn peekFirst();\n\t\t}\n\n\t\tpublic long get(int i) {\n\t\t\tif (i >= len) {\n\t\t\t\tthrow new ArrayIndexOutOfBoundsException(String.format(\"index %d out of range [0, %d)\", i, len));\n\t\t\t}\n\t\t\tint idx = index(i + off);\n\t\t\treturn arr[idx];\n\t\t}\n\n\t\tpublic void set(int i, long x) {\n\t\t\tif (i >= len) {\n\t\t\t\tthrow new ArrayIndexOutOfBoundsException(String.format(\"index %d out of range [0, %d)\", i, len));\n\t\t\t}\n\t\t\tint idx = index(i + off);\n\t\t\tarr[idx] = x;\n\t\t}\n\n\t\tpublic int size() {\n\t\t\treturn len;\n\t\t}\n\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size() == 0;\n\t\t}\n\n\t\tpublic long[] toArray() {\n\t\t\tif (len == 0) {\n\t\t\t\treturn new long[0];\n\t\t\t}\n\t\t\tint idx = index(off + len);\n\t\t\tif (idx > off) {\n\t\t\t\treturn Arrays.copyOfRange(arr, off, idx);\n\t\t\t}\n\t\t\tlong[] A = new long[len];\n\t\t\tint endLen = arr.length - off;\n\t\t\tint startLen = len - endLen;\n\t\t\tSystem.arraycopy(arr, off, A, 0, endLen);\n\t\t\tSystem.arraycopy(arr, 0, A, endLen, startLen);\n\t\t\treturn A;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append('[');\n\t\t\tprintToBuffer(sb, \", \");\n\t\t\tsb.append(']');\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tprivate void increaseCapacity() {\n\t\t\tlong[] next = new long[arr.length << 1];\n\t\t\tint endLen = arr.length - off;\n\t\t\tSystem.arraycopy(arr, off, next, 0, endLen);\n\t\t\tSystem.arraycopy(arr, 0, next, endLen, off);\n\t\t\tarr = next;\n\t\t\toff = 0;\n\t\t}\n\n\t\tprivate int index(int i) {\n\t\t\tif (i >= arr.length) {\n\t\t\t\ti -= arr.length;\n\t\t\t} else if (i < 0) {\n\t\t\t\ti += arr.length;\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\n\t\tprivate void printToBuffer(StringBuilder sb, CharSequence sep) {\n\t\t\tfor (int i = 0; i < len; ++i) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(sep);\n\t\t\t\t}\n\t\t\t\tsb.append(get(i));\n\t\t\t}\n\t\t}\n\n\t\tpublic static LongDeque of(long... arr) {\n\t\t\tLongDeque deq = new LongDeque();\n\t\t\tfor (long x : arr) {\n\t\t\t\tdeq.add(x);\n\t\t\t}\n\t\t\treturn deq;\n\t\t}\n\t}\n}",
    "submit_ts": "1723950568",
    "subm_id": "1359749360"
}