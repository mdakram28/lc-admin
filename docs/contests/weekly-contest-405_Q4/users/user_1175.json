{
    "username": "panwu5588",
    "submission": "class Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {\n        /**\n        target = \"abcdef\", \n        words = [\"abdef\",\"abc\",\"d\",\"def\",\"ef\"], \n        costs = [100,      1,   1 ,  10,   5]\n        012345\n        abcdef  backwards\n            5-\n           1\n           6\n           10\n           6\n\n           n^2 solution\n        problem: I need to check if I have words starting from i and end with i+1 to n\n        turn words into a tree\n        \n        dp + tire\n        dp[i] = cost starting at ith char to the end of the string\n        abdef\n          15-\n\n         */\n        HashMap<String,Integer> costMap = new HashMap<>();\n        for(int i =0;i<costs.length;i++){\n            int min=costs[i];\n            if(costMap.containsKey(words[i])){\n                min=Math.min(min,costMap.get(words[i]));\n            }\n            costMap.put(words[i], min);\n        }\n        Trie head = new Trie();\n        int p =0;\n        \n        for(String word: costMap.keySet()){\n            Trie cur = head;\n            for(char c:word.toCharArray()){\n                int idx = c-'a';\n                if(cur.children[idx]==null)\n                    cur.children[idx]=new Trie();\n                cur=cur.children[idx];\n            }\n            cur.isWord=true;\n            cur.cost=costMap.get(word);\n        }\n        int n = target.length();\n        long[] dp = new long[n+1];\n        Arrays.fill(dp,Integer.MAX_VALUE);\n        dp[n]=0;\n        for(int i =n-1;i>=0;i--){\n            Trie cur = head;\n            for(int j=i;j<n;j++){\n                int idx= target.charAt(j)-'a';\n                if(cur.children[idx]!=null){\n                    cur=cur.children[idx];\n                    if(cur.isWord && dp[j-i+1]!=-1)\n                        dp[i]=Math.min(dp[i],cur.cost+dp[j+1]);\n                }else\n                    break;\n            }\n        }\n        if(dp[0]==Integer.MAX_VALUE)\n            return -1;\n        return (int)dp[0];\n        /**\n        target = abcdef\n        tree = a-b-d-e-F\n                  -C\n               D\n               d-e-F\n               e-F\n\n        dp          i   j   cur     idxChar\n        mmmmmm0     5   5   head      f\n        mmmm5m0     4   5   head      ef\n        mmmm5m0     3   3   head      d\n\n         */\n    }\n\n    class Trie{\n        Trie[] children = new Trie[26];\n        boolean isWord = false;\n        int cost=0;\n        public Trie(){}\n    }\n}",
    "submit_ts": "1720323611",
    "subm_id": "1312379732"
}