{
    "username": "StrugglingAgainstDestiny",
    "submission": "class SegmentTree {\n public:\n\tusing ValueType = int32_t;\n\tstatic constexpr ValueType kNeutralValue = 0;\n\n private:\n\tstd::vector<ValueType> tree;\n\tint32_t size;\n\n\t// Function to compare two values\n\tValueType combine(const ValueType &a, const ValueType &b) {\n\t\treturn a + b;\n\t}\n\n public:\n\t// Constructor to initialize the segment tree with a given size\n\tSegmentTree(int32_t n = 0, ValueType defaultValue = kNeutralValue)\n\t\t\t: tree(2 * n, defaultValue), size(n) {}\n\n\t// Update the value at a specific position\n\tvoid update(int32_t pos, ValueType value) {\n\t\tfor (tree[pos += size] = value; pos /= 2;)\n\t\t\ttree[pos] = combine(tree[pos * 2], tree[pos * 2 + 1]);\n\t}\n\n\t// Query the maximum value in the range [b, e)\n\tValueType query(int32_t start, int32_t end) {\n\t\tValueType leftResult = kNeutralValue, rightResult = kNeutralValue;\n\t\tfor (start += size, end += size; start < end; start /= 2, end /= 2) {\n\t\t\tif (start % 2) leftResult = combine(leftResult, tree[start++]);\n\t\t\tif (end % 2) rightResult = combine(tree[--end], rightResult);\n\t\t}\n\t\treturn combine(leftResult, rightResult);\n\t}\n};\n\nclass Solution {\n public:\n\tvector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n\t\tconst int N = (int)nums.size();\n\t\tvector<bool> isPeak(N, false);\n\t\tfor (int i = 1; i < N - 1; ++i) {\n\t\t\tif (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {\n\t\t\t\tisPeak[i] = true;\n\t\t\t}\n\t\t}\n\n\t\tvector<int> results;\n\t\tSegmentTree segTree(N);\n\t\tfor (int i = 1; i < N - 1; ++i)\n\t\t\tif (isPeak[i]) segTree.update(i, 1);\n\n\t\tfor (const vector<int> &query: queries) {\n\t\t\t// for (int i = 0; i < N; ++i) cout << segTree.query(0, i + 1) << \" \";\n\t\t\t// cout << '\\n';\n\t\t\tif (query[0] == 1) {\n\t\t\t\tint result = segTree.query(0, query[2] + 1);\n\t\t\t\tif (query[1] > 0) result -= segTree.query(0, query[1]);\n\t\t\t\tif (isPeak[query[1]]) --result;\n\t\t\t\tif (query[1] != query[2] && isPeak[query[2]]) --result;\n\t\t\t\tresults.push_back(result);\n\t\t\t} else if (query[0] == 2) {\n\t\t\t\tint idx = query[1], newNum = query[2];\n\t\t\t\tnums[idx] = newNum;\n\t\t\t\t// check for left element\n\t\t\t\tif (idx > 1) {\n\t\t\t\t\tif (!isPeak[idx - 1] && nums[idx - 1] > nums[idx] && nums[idx - 1] > nums[idx - 2]) {\n\t\t\t\t\t\tisPeak[idx - 1] = true;\n\t\t\t\t\t\tsegTree.update(idx - 1, 1);\n\t\t\t\t\t} else if (isPeak[idx - 1] && (nums[idx - 1] <= nums[idx] || nums[idx - 1] <= nums[idx - 2])) {\n\t\t\t\t\t\tisPeak[idx - 1] = false;\n\t\t\t\t\t\tsegTree.update(idx - 1, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// check for right element\n\t\t\t\tif (idx + 2 < N) {\n\t\t\t\t\tif (!isPeak[idx + 1] && nums[idx + 1] > nums[idx] && nums[idx + 1] > nums[idx + 2]) {\n\t\t\t\t\t\tisPeak[idx + 1] = true;\n\t\t\t\t\t\tsegTree.update(idx + 1, 1);\n\t\t\t\t\t} else if (isPeak[idx + 1] && (nums[idx + 1] <= nums[idx] || nums[idx + 1] <= nums[idx + 2])) {\n\t\t\t\t\t\tisPeak[idx + 1] = false;\n\t\t\t\t\t\tsegTree.update(idx + 1, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// check for self\n\t\t\t\tif (idx > 0 && idx + 1 < N) {\n\t\t\t\t\tif (!isPeak[idx] && nums[idx] > nums[idx + 1] && nums[idx] > nums[idx - 1]) {\n\t\t\t\t\t\tisPeak[idx] = true;\n\t\t\t\t\t\tsegTree.update(idx, 1);\n\t\t\t\t\t} else if (isPeak[idx] && nums[idx] <= nums[idx + 1] || nums[idx] <= nums[idx - 1]) {\n\t\t\t\t\t\tisPeak[idx] = false;\n\t\t\t\t\t\tsegTree.update(idx, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n};",
    "submit_ts": "1718508193",
    "subm_id": "1289674288"
}