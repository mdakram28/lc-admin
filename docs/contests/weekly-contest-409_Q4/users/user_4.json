{
    "username": "dong_liu",
    "submission": "template<class T> struct FT {\n    vector<T> t;\n    int n;\n    FT() {}\n    FT(int n) { init(n); }\n    void init(int n) {\n        this->n = n;\n        t.resize(n, 0);\n    }\n    void add(int i, T x) {\n        for ( ; i < n; i |= i + 1) {\n            t[i] += x;\n        }\n    }\n    T sum(int i) {\n        T x = 0;\n        for ( ; i >= 0; i &= i + 1, i--) {\n            x += t[i];\n        }\n        return x;\n    }\n    T sum(int l, int r) {\n        return sum(r) - sum(l - 1);\n    }\n    int lower_bound(T x) {\n        if (x < 0) {\n            return -1;\n        }\n        int i = 0;\n        for (int p = 1 << (31 - __builtin_popcount(n)); p > 0; p >>= 1) {\n            if (i + p <= n && t[i + p - 1] < x) {\n                i += p, x -= t[i - 1];\n            }\n        }\n        return i;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> numberOfAlternatingGroups(vector<int>& c, vector<vector<int>>& q) {\n        int n = c.size();\n        FT<int> C(n + 1);\n        FT<int> V(n + 1);\n\n        auto add = [&](int x, int t) {\n            C.add(x, t);\n            V.add(x, t * x);\n        };\n\n        set<int> p;\n        auto next = [&](int i) {\n            auto it = p.lower_bound(i);\n            if (it == p.end()) {\n                return n + *p.begin();\n            }\n            return *it;\n        };\n        auto prev = [&](int i) {\n            if (*p.begin() > i) {\n                return *p.rbegin() - n;\n            }\n            auto it = p.upper_bound(i);\n            --it;\n            return *it;\n        };\n        auto ins = [&](int i) {\n            if (p.empty()) {\n                p.insert(i);\n                add(n, 1);\n            } else {\n                add(next(i) - prev(i), -1);\n                add(next(i) - i, 1);\n                add(i - prev(i), 1);\n                p.insert(i);\n            }\n        };\n        auto rem = [&](int i) {\n            p.erase(i);\n            if (p.empty()) {\n                add(n, -1);\n            } else {\n                add(next(i) - prev(i), 1);\n                add(next(i) - i, -1);\n                add(i - prev(i), -1);\n            }\n        };\n        auto check = [&](int i) {\n            i %= n;\n            if (i < 0) i += n;\n            if (c[i] == c[(i + 1) % n]) {\n                if (p.find(i) == p.end())\n                    ins(i);\n            } else {\n                if (p.find(i) != p.end())\n                    rem(i);\n            }\n        };\n        for (int i = 0; i < n; i++) {\n            if (c[i] == c[(i + 1) % n]) {\n                ins(i);\n            }\n        }\n        vector<int> ans;\n        for (auto me : q) {\n            if (me[0] == 1) {\n                \n                int s = me[1];\n                if (p.size() == 0) ans.push_back(n);\n                else ans.push_back(V.sum(s, n) - (s - 1) * C.sum(s, n));\n            } else {\n                int i = me[1];\n                c[i] = me[2];\n                check(i);\n                check(i - 1);\n            }\n            // for (int i : p) cout << i << ' '; cout << endl;\n        }\n        return ans;\n        \n    }\n};",
    "submit_ts": "1722740888",
    "subm_id": "1343731301"
}