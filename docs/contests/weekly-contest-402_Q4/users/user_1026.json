{
    "username": "VimT",
    "submission": "impl Solution {\n    pub fn count_of_peaks(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        // \u6ca1\u6709lazy\uff0c\u5355\u70b9\u66f4\u65b0\n        pub struct SegmentTree {\n            nums: Vec<i32>,\n            val: Vec<i32>,\n            len: usize,\n        }\n    \n        impl SegmentTree {\n            pub fn new(nums: Vec<i32>) -> Self {\n                let len = nums.len();\n                let mut tree = Self { nums, val: vec![0; len * 4], len };\n                tree.build(0, len - 1, 1);\n                tree\n            }\n            fn build(&mut self, s: usize, t: usize, p: usize) {\n                if s == t {\n                    self.val[p] = if s > 0 && s < self.len - 1 && self.nums[s] > self.nums[s - 1] && self.nums[s] > self.nums[s + 1] { 1 } else { 0 };\n                    return;\n                }\n                let m = (s + t) / 2;\n                self.build(s, m, p * 2);\n                self.build(m + 1, t, p * 2 + 1);\n                self.val[p] = self.val[p * 2] + self.val[p * 2 + 1];\n            }\n    \n            fn _update(&mut self, pos: usize, s: usize, t: usize, p: usize, value: i32) {\n                if s == t {\n                    self.nums[s] = value;\n                    self.val[p] = if s > 0 && s < self.len - 1 && self.nums[s] > self.nums[s - 1] && self.nums[s] > self.nums[s + 1] { 1 } else { 0 };\n                    return;\n                }\n                let m = (s + t) / 2;\n                if pos <= m { self._update(pos, s, m, p * 2, value); } else { self._update(pos, m + 1, t, p * 2 + 1, value); }\n                self.val[p] = self.val[p * 2] + self.val[p * 2 + 1];\n            }\n    \n            pub fn update(&mut self, pos: usize, value: i32) {\n                assert!(pos < self.len);\n                self._update(pos, 0, self.len - 1, 1, value);\n            }\n            fn _query(&mut self, l: usize, r: usize, s: usize, t: usize, p: usize) -> i32 {\n                if l <= s && t <= r {\n                    return self.val[p].clone();\n                }\n                let m = (s + t) / 2;\n                let mut ans = 0;\n                if l <= m { ans += self._query(l, r, s, m, p * 2); }\n                if m < r { ans += self._query(l, r, m + 1, t, p * 2 + 1); }\n                ans\n            }\n            pub fn query(&mut self, l: usize, r: usize) -> i32 {\n                if l > r || r >= self.len { return 0; }\n                self._query(l, r, 0, self.len - 1, 1)\n            }\n        }\n    \n        let len = nums.len();\n        let mut tree = SegmentTree::new(nums);\n        queries.iter().filter_map(|q| {\n            match q[0] {\n                1 => {\n                    Some(tree.query(q[1] as usize + 1, q[2] as usize - 1))\n                }\n                2 => {\n                    let idx = q[1] as usize;\n                    tree.update(idx, q[2]);\n                    if idx > 0 { tree.update(idx - 1, tree.nums[idx - 1]); }\n                    if idx < len - 1 { tree.update(idx + 1, tree.nums[idx + 1]); }\n                    None\n                }\n                _ => unreachable!()\n            }\n        }).collect()\n    }\n}",
    "submit_ts": 1718507123.0
}