{
    "username": "pbhaskar2003",
    "submission": "class SegmentTree {\npublic:\n    struct node {\n        int mx;\n        node(int m = 0) : mx(m) {}\n    };\n\n    vector<int> v;\n    vector<node> tree;\n\n    SegmentTree(int size) {\n        v.resize(size, 0);\n        tree.resize(4 * size);\n        build(1, 0, size - 1);\n    }\n\n    node merge(node a, node b) {\n        return node(max(a.mx, b.mx));\n    }\n\n    void build(int ind, int l, int r) {\n        if (l == r) {\n            tree[ind] = node(v[l]);\n            return;\n        }\n\n        int mid = (l + r) / 2;\n        build(2 * ind, l, mid);\n        build(2 * ind + 1, mid + 1, r);\n\n        tree[ind] = merge(tree[2 * ind], tree[2 * ind + 1]);\n    }\n\n    void update(int ind, int l, int r, int a, int b) {\n        if (a < l || a > r) return;\n        if (l == r) {\n            v[a] = b;\n            tree[ind] = node(b);\n            return;\n        }\n\n        int mid = (l + r) / 2;\n        update(2 * ind, l, mid, a, b);\n        update(2 * ind + 1, mid + 1, r, a, b);\n\n        tree[ind] = merge(tree[2 * ind], tree[2 * ind + 1]);\n    }\n\n    node query(int ind, int l, int r, int a, int b) {\n        if (r < a || l > b) return node();\n        if (a <= l && r <= b) return tree[ind];\n\n        int mid = (l + r) / 2;\n        return merge(query(2 * ind, l, mid, a, b), query(2 * ind + 1, mid + 1, r, a, b));\n    }\n\n    void update(int pos, int value) {\n        update(1, 0, v.size() - 1, pos, value);\n    }\n\n    int query(int L, int R) {\n        return query(1, 0, v.size() - 1, L, R).mx;\n    }\n};\n\nclass Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {\n        struct DPState {\n            int maxLength;\n            set<int> uniqueElements;\n            map<int, int> counter;\n\n            DPState() : maxLength(0) {}\n        };\n\n        vector<DPState> dp(k + 1);\n\n        for (int num : nums) \n        {\n            int prevMax = 0;\n            for (int j = 0; j <= k; ++j) {\n                int curMax = max({prevMax + 1, (dp[j].maxLength + 1) * (dp[j].uniqueElements.count(num) > 0), dp[j].counter[num] + 1});\n                prevMax = dp[j].maxLength;\n                dp[j].counter[num] = curMax;\n\n                if (dp[j].maxLength < curMax) {\n                    dp[j].maxLength = curMax;\n                    dp[j].uniqueElements.clear();\n                }\n\n                if (curMax == dp[j].maxLength) {\n                    dp[j].uniqueElements.insert(num);\n                }\n            }\n        }\n\n        return dp[k].maxLength;\n    }\n};\n",
    "submit_ts": 1717861675.0
}