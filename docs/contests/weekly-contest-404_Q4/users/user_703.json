{
    "username": "hab_ee_b",
    "submission": "// C++ program to find root which gives minimum height to tree\n#include <bits/stdc++.h>\nusing namespace std;\n\n\n// This class represents a undirected graph using adjacency list\n// representation\nclass Graph\n{\npublic:\n\tint root=-1,dim=0,V; //no. of vertices\n    \n\t// Pointer to an array containing adjacency lists\n\tlist<int> *adj;\n\n\t// Vector which stores degree of all vertices\n\tvector<int> degree;\n\n\tGraph(int V);\t\t // Constructor\n\tvoid addEdge(int v, int w); // To add an edge\n\n\t// function to get roots which give minimum height\n\tint MinimumHeight();\n    \n    int maxDepth(int i,int p);\n};\n\n// Constructor of graph, initializes adjacency list and\n// degree vector\nGraph::Graph(int V)\n{\n\tthis->V = V;\n\tadj = new list<int>[V];\n\tfor (int i = 0; i < V; i++)\n\t\tdegree.push_back(0);\n}\n\n// addEdge method adds vertex to adjacency list and increases\n// degree by 1\nvoid Graph::addEdge(int v, int w)\n{\n\tadj[v].push_back(w); // Add w to v\u2019s list\n\tadj[w].push_back(v); // Add v to w\u2019s list\n\tdegree[v]++;\t\t // increment degree of v by 1\n\tdegree[w]++;\t\t // increment degree of w by 1\n}\n\nint Graph::maxDepth(int i,int p){\n    int ans=1,x=0,y=0,z=0;\n    for(auto j:adj[i]){\n        if(j==p)continue;\n        z = maxDepth(j,i);\n        ans = max(ans,z+1);\n        if(i==root){\n            if(z>x)y=x,x=z;\n            else if (z>y)y=z;\n            dim = max(dim,x+y);\n        }\n    }\n    return ans;\n}\n// Method to return roots which gives minimum height to tree\nint Graph::MinimumHeight()\n{\n    if(V==1)return 1;\n\tqueue<int> q;\n\n\t// first enqueue all leaf nodes in queue\n\tfor (int i = 0; i < V; i++)\n\t\tif (degree[i] == 1)\n\t\t\tq.push(i);\n\n\t// loop until total vertex remains less than 2\n\twhile (V > 2)\n\t{\n\t\tint popEle = q.size();\n\t\tV -= popEle;\t // popEle number of vertices will be popped\n\t\t\n\t\tfor (int i = 0; i < popEle; i++)\n\t\t{\n\t\t\tint t = q.front();\n\t\t\tq.pop();\n\n\t\t\t// for each neighbour, decrease its degree and\n\t\t\t// if it become leaf, insert into queue\n\t\t\tfor (auto j = adj[t].begin(); j != adj[t].end(); j++)\n\t\t\t{\n\t\t\t\tdegree[*j]--;\n\t\t\t\tif (degree[*j] == 1)\n\t\t\t\t\tq.push(*j);\n\t\t\t}\n\t\t}\n\t}\n    root = q.front();\n    int ans=maxDepth(root,-1);\n\treturn ans;\n}\n\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n=edges1.size()+1;\n        int m=edges2.size()+1;\n        Graph g(n),p(m);\n        for(auto i:edges1)g.addEdge(i[0],i[1]);\n        for(auto i:edges2)p.addEdge(i[0],i[1]);\n        int x = g.MinimumHeight();\n        int y = p.MinimumHeight();\n        int ans = x+y-1;\n        ans = max(ans,g.dim);\n        ans = max(ans,p.dim);\n        return ans;\n    }\n};",
    "submit_ts": "1719719309",
    "subm_id": "1304438789"
}