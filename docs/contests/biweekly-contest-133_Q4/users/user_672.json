{
    "username": "Last_Of_UsOO",
    "submission": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\n\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x)\n{\n    cerr << '{';\n    __print(x.first);\n    cerr << ',';\n    __print(x.second);\n    cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x)\n{\n    int f = 0;\n    cerr << '{';\n    for (auto i : x)\n        cerr << (f++ ? \",\" : \"\"), __print(i);\n    cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v)\n{\n    __print(t);\n    if (sizeof...(v))\n        cerr << \", \";\n    _print(v...);\n}\n#ifndef ONLINE_JUDGE\n#define debug(x...)               \\\n    cerr << \"[\" << #x << \"] = [\"; \\\n    _print(x)\n#else\n#define debug(x...)\n#endif\n\nstatic auto fastio = []()\n{\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n};\n\n#include <vector>\n#include <unordered_map>\n\nclass Solution\n{\nprivate:\n    static const int MOD = 1e9 + 7;\n    static const int NN = 400;\n\npublic:\n    int numberOfPermutations(int n, vector<vector<int>> &requirements)\n    {\n        unordered_map<int, int> hash;\n        for (auto &ii : requirements)\n        {\n            hash[ii[0] + 1] = ii[1];\n        }\n\n        vector<vector<long long>> Number_Of_Inv(n + 1, vector<long long>(NN + 1, 0));\n        Number_Of_Inv[0][0] = 1;\n\n        for (int pq = 1; pq <= n; pq++)\n        {\n            for (int rk = 0; rk <= NN; ++rk)\n            {\n                for (int jk = 0; jk < pq; ++jk)\n                {\n                    int Inversion_previous = rk - jk;\n                    if (Inversion_previous >= 0)\n                    {\n                        Number_Of_Inv[pq][rk] = (Number_Of_Inv[pq][rk] + Number_Of_Inv[pq - 1][Inversion_previous]) % MOD;\n                    }\n                }\n            }\n\n            if (hash.find(pq) != hash.end())\n            {\n                int fin_Inv = hash[pq];\n                for (int rk = 0; rk <= NN; ++rk)\n                {\n                    if (rk != fin_Inv)\n                    {\n                        Number_Of_Inv[pq][rk] = 0;\n                    }\n                }\n            }\n        }\n\n        long long result = 0;\n        for (auto &ii : Number_Of_Inv[n])\n        {\n            result = (result + ii) % MOD;\n        }\n\n        return result % MOD;\n    }\n};",
    "submit_ts": 1719070652.0
}