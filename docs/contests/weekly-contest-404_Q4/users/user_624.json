{
    "username": "ArinGupta",
    "submission": "class Solution {\nprivate:\n    pair<int,int> bfs(vector<int>adj[],int u,int&n){\n        vector<int>dist(n,-1);\n        queue<int>q;\n        q.push(u);\n        dist[u]=0;\n        while(!q.empty()){\n            int i = q.front();\n            q.pop();\n            for(auto&it:adj[i]){\n                if(dist[it]==-1){\n                    q.push(it);\n                    dist[it]=dist[i]+1;\n                }\n            }\n        }\n        int node=0,mx = 0;\n        for(int i=0;i<n;i++){\n            if(dist[i]>mx){\n                mx=dist[i];\n                node=i;\n            }\n        }\n        return make_pair(node,mx);\n        \n    }\n    int fx(vector<vector<int>>&edges){\n        int n = edges.size()+1;\n        vector<int>adj[n];\n        for(auto&it:edges){adj[it[0]].push_back(it[1]);adj[it[1]].push_back(it[0]);}\n        pair<int,int>a = bfs(adj,0,n);\n        pair<int,int>b = bfs(adj,a.first,n);\n        return b.second;\n    }\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int len1 = fx(edges1);\n        int len2 = fx(edges2);\n        int ans = len1/2+len1%2+len2%2+len2/2+1;\n        return max({ans,len1,len2});\n    }\n};",
    "submit_ts": 1719718145.0
}