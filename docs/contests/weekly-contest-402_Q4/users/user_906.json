{
    "username": "SUVU01",
    "submission": "class Solution {\npublic:\n    #define ll long long\n    void buildTree(int index, int l, int r, vector<int> &A, vector<ll> &tree)\n    {\n        if (l == r)\n        {\n            tree[index] = A[l];\n            return;\n        }\n\n        int mid = (l + r) / 2;\n        buildTree(2 * index + 1, l, mid, A, tree);\n        buildTree(2 * index + 2, mid + 1, r, A, tree);\n\n        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];\n    }\n\n    void update(int index, int l, int r, int pos, int &val, vector<ll> &tree)\n    {\n        if (r == l and l == pos)\n        {\n            tree[index] = val;\n            return;\n        }\n\n        if (l > pos or r < pos)\n            return;\n\n        int mid = (l + r) / 2;\n        update(2 * index + 1, l, mid, pos, val, tree);\n        update(2 * index + 2, mid + 1, r, pos, val, tree);\n        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];\n    }\n\n    ll sum(int index, int left, int right, int l, int r, vector<ll> &tree)\n    {\n        if (l >= left and r <= right)\n            return tree[index];\n        else if (r < left or l > right)\n            return 0;\n\n        int mid = (l + r) / 2;\n        return sum(2 * index + 1, left, right, l, mid, tree) + sum(2 * index + 2, left, right, mid + 1, r, tree);\n    }\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<ll> tree(4 * n + 1, 0);\n        vector<int> A(n, 0);\n        for(int i = 1; i < n - 1; i++)\n        {\n            if(nums[i] > nums[i - 1] and nums[i] > nums[i + 1])\n                A[i] = 1;\n        }\n        buildTree(0, 0, n - 1, A, tree);\n        \n        int m = queries.size();\n        vector<int> ans;\n        for(int i = 0; i < m; i++)\n        {\n            int type = queries[i][0];\n            if(type == 1)\n            {\n                int l = queries[i][1], r = queries[i][2];\n                if(l == r)\n                {\n                    ans.push_back(0);\n                    continue;\n                }\n                ll curr = sum(0, l, r, 0, n - 1, tree);\n                int f = sum(0, l, l, 0, n - 1, tree), s = sum(0, r, r, 0, n - 1, tree);\n                curr -= (f + s);\n                ans.push_back(curr);\n            }\n            else\n            {\n                int index = queries[i][1], value = queries[i][2];\n                int prev = A[index];\n                nums[index] = value;\n                if(index > 0 and index < n - 1)\n                {\n                    if(value > nums[index - 1] and value > nums[index + 1])\n                        A[index] = 1;\n                    else\n                        A[index] = 0;\n                    if(A[index] != prev)\n                        update(0, 0, n - 1, index, A[index], tree);\n                }\n                if(index > 0)\n                {\n                    prev = A[index - 1];\n                    if(nums[index] >= nums[index - 1])\n                        A[index - 1] = 0;\n                    if(index > 1 and nums[index] < nums[index - 1] and nums[index - 2] < nums[index - 1])\n                        A[index - 1] = 1;\n                    if(A[index - 1] != prev)\n                        update(0, 0, n - 1, index - 1, A[index - 1], tree);\n                }\n                if(index < n - 1)\n                {\n                    prev = A[index + 1];\n                    if(nums[index] >= nums[index + 1])\n                        A[index + 1] = 0;\n                    if(index < n - 2 and nums[index + 1] > nums[index + 2] and nums[index + 1] > nums[index])\n                        A[index + 1] = 1;\n                    if(A[index + 1] != prev)\n                        update(0, 0, n - 1, index + 1, A[index + 1], tree);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718507557.0
}