{
    "username": "flowing",
    "submission": "class Solution {\n\n    public int findMinHeightTreesHelper(int n, int[][] edges) {\n        List<Integer> ans = new ArrayList<>();\n\n        if (n <= 0) return 0;\n\n        if (n == 1) {\n            return 0;\n        }\n\n        int[] deg = new int[n];\n        List<List<Integer>> gr = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            gr.add(new ArrayList<>());\n        }\n\n        for (int[] e : edges) {\n            deg[e[0]]++;\n            deg[e[1]]++;\n\n            gr.get(e[0]).add(e[1]);\n            gr.get(e[1]).add(e[0]);\n        }\n\n        Queue<Integer> q = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            if (deg[i] == 1)\n                q.offer(i);\n        }\n        int depth = 0;\n\n        while (n > 2) {\n            int sz = q.size();\n            n -= sz;\n            depth++;\n\n            while (sz-- > 0) {\n                int el = q.poll();\n\n                for (int ne : gr.get(el)) {\n                    deg[ne]--;\n                    if (deg[ne] == 1) {\n                        q.offer(ne);\n                    }\n                }\n            }\n        }\n        return depth + (n == 2 ? 1 : 0);\n    }\n\n    static class Pair {\n        int node;\n        int distance;\n\n        Pair(int node, int distance) {\n            this.node = node;\n            this.distance = distance;\n        }\n    }\n\n    private static Pair findFarthestNode(int startNode, Map<Integer, List<Integer>> graph) {\n        Stack<Pair> stack = new Stack<>();\n        stack.push(new Pair(startNode, 0));\n        Set<Integer> visited = new HashSet<>();\n        Pair farthestNode = new Pair(startNode, 0);\n\n        while (!stack.isEmpty()) {\n            Pair current = stack.pop();\n            if (visited.contains(current.node)) {\n                continue;\n            }\n            visited.add(current.node);\n\n            if (current.distance > farthestNode.distance) {\n                farthestNode = current;\n            }\n\n            for (int neighbor : graph.getOrDefault(current.node, new ArrayList<>())) {\n                if (!visited.contains(neighbor)) {\n                    stack.push(new Pair(neighbor, current.distance + 1));\n                }\n            }\n        }\n\n        return farthestNode;\n    }\n\n    public static int treeDiameter(int[][] edges) {\n        if (edges.length == 0) {\n            return 0;\n        }\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int[] edge : edges) {\n            graph.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(edge[1]);\n            graph.computeIfAbsent(edge[1], k -> new ArrayList<>()).add(edge[0]);\n        }\n        int startNode = edges[0][0];\n        Pair nodeA = findFarthestNode(startNode, graph);\n        Pair result = findFarthestNode(nodeA.node, graph);\n\n        return result.distance;\n    }\n\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int d1 = findMinHeightTreesHelper(edges1.length + 1, edges1);\n        int d2 = findMinHeightTreesHelper(edges2.length + 1, edges2);\n        int d1Only = treeDiameter(edges1), d2Only = treeDiameter(edges2);\n        return Math.max(d1 + d2 + 1, Math.max(d1Only, d2Only));\n    }\n}",
    "submit_ts": 1719719235.0
}