{
    "username": "ShyamSunder_11",
    "submission": "class SegmentTree {\nprivate:\n    vector<int> st;\n    int n;\n    \n    int getMid(int s, int e) {\n        return s + (e - s) / 2;\n    }\n    \n    int constructSTUtil(const vector<int>& arr, int ss, int se, int si) {\n        if (ss == se) {\n            st[si] = isPeak(ss, arr) ? 1 : 0;\n            return st[si];\n        }\n        int mid = getMid(ss, se);\n        st[si] = constructSTUtil(arr, ss, mid, si * 2 + 1) +\n                 constructSTUtil(arr, mid + 1, se, si * 2 + 2);\n        return st[si];\n    }\n    \n    int getSumUtil(int ss, int se, int qs, int qe, int si) {\n        if (qs <= ss && qe >= se) return st[si];\n        if (se < qs || ss > qe) return 0;\n        int mid = getMid(ss, se);\n        return getSumUtil(ss, mid, qs, qe, 2 * si + 1) +\n               getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);\n    }\n    \n    void updateValueUtil(int ss, int se, int i, int newVal, int si, vector<int>& arr) {\n        if (i < ss || i > se) return;\n        if (ss == se) {\n            st[si] = isPeak(i, arr) ? 1 : 0;\n            return;\n        }\n        int mid = getMid(ss, se);\n        updateValueUtil(ss, mid, i, newVal, 2 * si + 1, arr);\n        updateValueUtil(mid + 1, se, i, newVal, 2 * si + 2, arr);\n        st[si] = st[2 * si + 1] + st[2 * si + 2];\n    }\n    \npublic:\n    SegmentTree(const vector<int>& arr, int n) {\n        this->n = n;\n        int x = (int) (ceil(log2(n)));\n        int max_size = 2 * (int) pow(2, x) - 1;\n        st.resize(max_size);\n        constructSTUtil(arr, 0, n - 1, 0);\n    }\n    \n    void updateValue(vector<int>& arr, int i, int newVal) {\n        if (i < 0 || i >= n) return;\n        arr[i] = newVal;\n        updateValueUtil(0, n - 1, i, newVal, 0, arr);\n        if (i > 0) updateValueUtil(0, n - 1, i - 1, arr[i - 1], 0, arr);\n        if (i < n - 1) updateValueUtil(0, n - 1, i + 1, arr[i + 1], 0, arr);\n    }\n    \n    int getSum(int qs, int qe) {\n        if (qs < 0 || qe >= n || qs > qe) return 0;\n        return getSumUtil(0, n - 1, qs, qe, 0);\n    }\n    \n    bool isPeak(int i, const vector<int>& arr) {\n        if (i <= 0 || i >= arr.size() - 1) return false;\n        return arr[i] > arr[i - 1] && arr[i] > arr[i + 1];\n    }\n};\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        SegmentTree tree(nums, n);\n        vector<int> ans;\n        \n        for (auto& q : queries) {\n            if (q[0] == 2) {\n                tree.updateValue(nums, q[1],q[2]);\n            } else if (q[0] == 1) {\n                ans.push_back(tree.getSum(q[1] + 1, q[2] - 1));\n            }\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": 1718508514.0
}