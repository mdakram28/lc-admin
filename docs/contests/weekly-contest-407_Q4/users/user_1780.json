{
    "username": "man-ray",
    "submission": "class Solution {\n    static void init(int n) {\n        int len = 4 * n;\n        lazy = new int[len];\n        sum = new long[len];\n        max = new long[len];\n        min = new long[len];\n        build(1, 0, n - 1);//\u9ed8\u8ba4\u6839\u8282\u70b9\u7f16\u53f7\u4e3a 1\uff0c\u533a\u95f4\u5de6\u7aef\u70b9\u4e3a 0 \uff0c\u53f3\u7aef\u70b9\u4e3a n - 1\n    }\n\n    static void build(int u, int le, int ri) {\n        if (le == ri) return;\n        int mid = le + ri >> 1;\n        build(u << 1, le, mid);\n        build(u << 1 | 1, mid + 1, ri);\n        pushUp(u);\n    }\n\n    static void init(int n, int[] a) {\n        int len = 4 * n;\n        lazy = new int[len];\n        sum = new long[len];\n        max = new long[len];\n        min = new long[len];\n        build(1, 0, n - 1, a);//\u9ed8\u8ba4\u6839\u8282\u70b9\u7f16\u53f7\u4e3a 1\uff0c\u533a\u95f4\u5de6\u7aef\u70b9\u4e3a 0 \uff0c\u53f3\u7aef\u70b9\u4e3a n - 1\n    }\n\n    static void build(int u, int le, int ri, int[] a) {\n        if (le == ri) {\n            sum[u] = max[u] = min[u] = a[le];\n            return;\n        }\n        int mid = le + ri >> 1;\n        build(u << 1, le, mid, a);\n        build(u << 1 | 1, mid + 1, ri, a);\n        pushUp(u);\n    }\n\n    //\u5b50\u8282\u70b9\u4fe1\u606f\u66f4\u65b0\u7236\u8282\u70b9\u4fe1\u606f\n    static void pushUp(int u) {\n        max[u] = Math.max(max[u << 1], max[u << 1 | 1]);\n        min[u] = Math.min(min[u << 1], min[u << 1 | 1]);\n        sum[u] = sum[u << 1] + sum[u << 1 | 1];\n    }\n\n    //\u4e0b\u4f20\u61d2\u6807\u8bb0\n    static void pushDown(int u, int l, int r) {\n        if (lazy[u] == 0) return;\n        pd(u << 1, lazy[u], l, r);\n        pd(u << 1 | 1, lazy[u], l, r);\n        lazy[u] = 0;\n    }\n\n    static void pd(int u, int lz, int l, int r) {\n        sum[u] += lz * (r - l + 1);\n        lazy[u] += lz;\n        max[u] += lz;\n        min[u] += lz;\n    }\n\n    //\u533a\u95f4\u4fee\u6539 \u533a\u95f4 + v\n    static void updateRange(int u, int le, int ri, int v, int l, int r) {\n        if (le <= l && r <= ri) {//\u5b8c\u5168\u8986\u76d6\n            pd(u, v, l, r);\n            return;\n        }\n        pushDown(u, l, r);\n        int mid = l + r >> 1;\n        if (mid >= le) updateRange(u << 1, le, ri, v, l, mid);\n        if (mid < ri) updateRange(u << 1 | 1, le, ri, v, mid + 1, r);\n        pushUp(u);\n    }\n\n    //\u5355\u70b9\u4fee\u6539,\u5c06\u4e0b\u6807 idx \u5904\u7684\u503c\u52a0\u4e0a v\n    static void update(int u, int idx, int v, int l, int r) {\n        if (l == idx && r == idx) {\n            pd(u, v, l, r);\n            return;\n        }\n        pushDown(u, l, r);\n        int mid = l + r >> 1;\n        if (mid >= idx) update(u << 1, idx, v, l, mid);\n        else update(u << 1 | 1, idx, v, mid + 1, r);\n        pushUp(u);\n    }\n\n    //\u5355\u70b9\u67e5\u8be2\n    static long querySingle(int u, int x, int l, int r) {\n        if (l == x && r == x) return sum[u];\n        pushDown(u, l, r);\n        int mid = l + r >> 1;\n        if (mid >= x) return querySingle(u << 1, x, l, mid);\n        else return querySingle(u << 1 | 1, x, mid + 1, r);\n    }\n\n    //\u533a\u95f4\u548c\u67e5\u8be2\n    static long queryRangeSum(int u, int le, int ri, int l, int r) {\n        if (le <= l && r <= ri) {//\u5b8c\u5168\u8986\u76d6\n            return sum[u];\n        }\n        pushDown(u, l, r);\n        int mid = l + r >> 1;\n        long ret = 0;\n        if (mid >= le) ret += queryRangeSum(u << 1, le, ri, l, mid);\n        if (mid < ri) ret += queryRangeSum(u << 1 | 1, le, ri, mid + 1, r);\n        return ret;\n    }\n\n    //\u533a\u95f4\u6700\u5927\u503c\u67e5\u8be2\n    static long queryRangeMax(int u, int le, int ri, int l, int r) {\n        if (le <= l && r <= ri) {//\u5b8c\u5168\u8986\u76d6\n            return max[u];\n        }\n        pushDown(u, l, r);\n        int mid = l + r >> 1;\n        long ret = Long.MIN_VALUE;\n        if (mid >= le) ret = Math.max(ret, queryRangeMax(u << 1, le, ri, l, mid));\n        if (mid < ri) ret = Math.max(ret, queryRangeMax(u << 1 | 1, le, ri, mid + 1, r));\n        return ret;\n    }\n\n    //\u533a\u95f4\u6700\u5c0f\u503c\u67e5\u8be2\n    static long queryRangeMin(int u, int le, int ri, int l, int r) {\n        if (le <= l && r <= ri) {//\u5b8c\u5168\u8986\u76d6\n            return min[u];\n        }\n        pushDown(u, l, r);\n        int mid = l + r >> 1;\n        long ret = Long.MAX_VALUE;\n        if (mid >= le) ret = Math.min(ret, queryRangeMin(u << 1, le, ri, l, mid));\n        if (mid < ri) ret = Math.min(ret, queryRangeMin(u << 1 | 1, le, ri, mid + 1, r));\n        return ret;\n    }\n\n    static int[] lazy;\n    static long[] sum, max, min;\n\n\n    static long minimumOperations(int[] nums, int[] target) {\n        n = nums.length;\n        ans = 0;\n        int[] a = new int[n];\n        int[] b = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            a[i] = nums[i] - target[i];\n            b[i] = Math.abs(a[i]);\n        }\n        init(n, b);\n        map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.putIfAbsent(b[i], new TreeSet<>());\n            map.get(b[i]).add(i);\n        }\n\n        int l = 0, r = 0;\n        boolean f = a[0] >= 0;\n        while (r < n) {\n            if (f) {\n                while (r < n && a[r] >= 0) {\n                    r++;\n                }\n                solve(a, l, r - 1, f, 0);\n                f = false;\n                l = r;\n\n            } else {\n                while (r < n && a[r] <= 0) {\n                    r++;\n                }\n                solve(a, l, r - 1, f, 0);\n                f = true;\n                l = r;\n            }\n\n        }\n        System.out.println(ans);\n        return ans;\n\n    }\n\n    static long ans;\n    static Map<Integer, TreeSet<Integer>> map;\n    static int n;\n\n    static void solve(int[] a, int l, int r, boolean f, int sub) {\n        int len = r - l + 1;\n        if (len == 1) {\n            ans += Math.abs(a[r] - sub);\n            return;\n        }\n        if (len == 0) return;\n        if (!f) {\n            f = true;\n            for (int i = l; i <= r; i++) {\n                a[i] = -a[i];\n            }\n        }\n        int min = (int) queryRangeMin(1, l, r, 0, n - 1);\n        Integer idx = map.get(min + sub).ceiling(l);\n        updateRange(1, l, r, -min, 0, n - 1);\n        ans += min;\n        solve(a, l, idx - 1, f, sub + min);\n        solve(a, idx + 1, r, f, sub + min);\n\n    }\n}",
    "submit_ts": "1721532443",
    "subm_id": "548392401"
}