{
    "username": "jaikritsanandiya",
    "submission": "class SegTree{\npublic:\n\tint len;\n\tvector<int> t, unpropUpd;\n\tvector<bool> isLazy;\n\tSegTree(){}\n\tSegTree(int l){\n\t\tlen = l;\n\t\tt.resize(4 * len);\n\t\tisLazy.resize(4 * len);\n\t\tunpropUpd.resize(4 * len);\n\t}\n\t\n\t// asking v, to remember that he has 'val' update for his range\n\tvoid apply(int v, int tl, int tr, int val){ // [tl, tr] is node range\n\t\tif(tl != tr){ // leaf nodes can't be lazy, as they have no-one to propogate to\n\t\t\tisLazy[v] = true;\n\t\t\tunpropUpd[v] = val; //stacking up the unpropogaed value, which i'll propogate down\n\t\t}\n\t\tt[v] = (tr - tl + 1) * val; // this \"= shows assign update\", \"+= shows range add update\" \n\t}\n\t\n\t// assigning the value whatsoever we had on 'v' to its children ('2*v' & '2*v+1')\n\tvoid pushDown(int v, int tl, int tr){\n\t\tif(!isLazy[v]) return; // if not lazy then no push-down required\n\t\tisLazy[v] = false; //no more lazy\n\t\tint tm = (tl + tr)/2;\n\t\tapply(2*v, tl, tm, unpropUpd[v]); // propogates to left child\n\t\tapply(2*v+1, tm+1, tr, unpropUpd[v]); // propogates to right child\n\t\tunpropUpd[v] = 0; // identity-transformation -- updated the children(job done)\n\t}\n\n\t// Build Segment Tree -- build(a, 1, 0, len-1);\n\tvoid build(vector<int>& a, int v, int tl, int tr){\n\t\tif(tl == tr){\n\t\t\tt[v] = a[tl];\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr)/2;\n\t\tbuild(a, 2*v, tl, tm);\n\t\tbuild(a, 2*v+1, tm+1, tr);\n\t\tt[v] = t[2*v] + t[2*v+1];\n\t}\n\n\t// Query input question is = [l, r] included -- query(1, 0, len-1, l, r)\n\tint query(int v, int tl, int tr, int l, int r){\n\t\tif(tl > r || tr < l) return 0; // no overlap\n\t\tif(l <= tl && tr <= r) return t[v]; //Full overlap\n\n\t\t// Partial Overlap\n\t\tpushDown(v, tl, tr); //we remove the lazy tag before going down, so children have correct info\n\t\tint tm = (tl + tr)/2;\n\t\tint leftAns = query(2*v, tl, tm, l, r);\n\t\tint rightAns = query(2*v+1, tm+1, tr, l, r);\n\t\treturn leftAns + rightAns;\n\t}\n\n\t// Update at index id of nums to a value val (assign/override/set) -- update(1, 0, len-1, l, r, val) \n\tvoid update(int v, int tl, int tr, int l, int r, int val){\n\t\t// reached leaf node\n\t\tif(l <= tl && tr <= r){ // full overlap -- apply update and return back\n\t\t\tapply(v, tl, tr, val); \n\t\t\treturn;\n\t\t}\n\t\tif(tl > r || tr < l) return; // no overlap\n\t\t\n\t\t// Partial Overlap\n\t\tpushDown(v, tl, tr);\n\t\tint tm = (tl + tr)/2;\n\t\tupdate(2*v, tl, tm, l, r, val);\n\t\tupdate(2*v+1, tm+1, tr, l, r, val);\n\t\tt[v] = t[2*v] + t[2*v+1];\n\t}\n\t\n\t//over-ridden functions\n\tvoid build(vector<int>& a){\n\t\tbuild(a, 1, 0, len-1);\n\t}\n\t\n\tint query(int l, int r){\n\t\treturn query(1, 0, len-1, l, r);\n\t}\n\t\n\tvoid update(int l, int r, int val){\n\t\tupdate(1, 0, len-1, l, r, val);\n\t}\n};\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int> ans;\n        vector<int> v(n,0);\n        SegTree st(n);\n        st.build(v);\n        for(auto it:queries){\n            int u = it[0];\n            int v = it[1];\n            st.update(u+1,v-1,1);\n            ans.push_back(n-st.query(0,n-1)-1);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722741878",
    "subm_id": "1343755651"
}