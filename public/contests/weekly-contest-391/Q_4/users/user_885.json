{
    "username": "recursing-almeidafxd",
    "submission": "class Solution {\n    public int minimumDistance(int[][] points) {\n        TreeMap<Integer,Integer>[] pre=new TreeMap[2];\n        TreeMap<Integer,Integer>[] suff=new TreeMap[2];\n        Arrays.setAll(pre,e->new TreeMap<>());\n        Arrays.setAll(suff,e->new TreeMap<>());\n        int n=points.length,ans= (int) 2e8,minInf= (int) -2e8,maxInf= (int) 2e8;\n        for (int i = 0; i <n; i++) {\n            int x=points[i][0],y=points[i][1];\n            suff[0].put(x+y,suff[0].getOrDefault(x+y,0)+1);\n            suff[1].put(x-y,suff[1].getOrDefault(x-y,0)+1);\n        }\n        for (int i = 0; i <n; i++) {\n            int x=points[i][0],y=points[i][1];\n            suff[0].put(x+y,suff[0].get(x+y)-1);\n            if (suff[0].get(x+y)==0)suff[0].remove(x+y);\n            suff[1].put(x-y,suff[1].get(x-y)-1);\n            if (suff[1].get(x-y)==0)suff[1].remove(x-y);\n            int abs0Max=Math.max(suff[0].isEmpty()?0:suff[0].lastKey(),pre[0].isEmpty()?0:pre[0].lastKey()),\n                    abs1Max=Math.max(suff[1].isEmpty()?minInf:suff[1].lastKey(),pre[1].isEmpty()?minInf:pre[1].lastKey()),\n                    abs0Min=Math.min(suff[0].isEmpty()?maxInf:suff[0].firstKey(),pre[0].isEmpty()?maxInf:pre[0].firstKey()),\n                    abs1Min=Math.min(suff[1].isEmpty()?maxInf:suff[1].firstKey(),pre[1].isEmpty()?maxInf:pre[1].firstKey());\n            ans=Math.min(ans,Math.max(abs0Max-abs0Min,abs1Max-abs1Min));\n            pre[0].put(x+y,pre[0].getOrDefault(x+y,0)+1);\n            pre[1].put(x-y,pre[1].getOrDefault(x-y,0)+1);\n        }\n        return ans;\n    }\n}"
}