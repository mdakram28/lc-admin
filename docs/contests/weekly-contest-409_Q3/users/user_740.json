{
    "username": "opalXDnaja123",
    "submission": "typedef long long ll;\n\nclass Solution {\npublic:\n\n    vector<ll> seg, lazy, setLazy;\n\n    void build(ll node, ll l, ll r, vector<ll> &vec) {\n        ll l_node = 2 * node + 1;\n        ll r_node = 2 * node + 2;\n        if (l == r) {\n            seg[node] = vec[l];\n            return;\n        }\n        ll mid = l + (r - l) / 2;\n        build(l_node, l, mid, vec);\n        build(r_node, mid + 1, r, vec);\n        seg[node] = seg[l_node] + seg[r_node];\n    }\n\n    void propagate(ll node, ll l, ll r) {\n        ll l_node = 2 * node + 1;\n        ll r_node = 2 * node + 2;\n        if (setLazy[node] != -1) {\n            seg[node] = (r - l + 1) * setLazy[node];\n            if (l != r) {\n                setLazy[l_node] = setLazy[node];\n                setLazy[r_node] = setLazy[node];\n                lazy[l_node] = 0;\n                lazy[r_node] = 0;\n            }\n            setLazy[node] = -1;\n        }\n        if (lazy[node] != 0) {\n            seg[node] += (r - l + 1) * lazy[node];\n            if (l != r) {\n                lazy[l_node] += lazy[node];\n                lazy[r_node] += lazy[node];\n            }\n            lazy[node] = 0;\n        }\n    }\n\n    void update(ll node, ll l, ll r, ll l_idx, ll r_idx, ll val, bool isSetOperation) {\n        propagate(node, l, r);\n        if (r < l_idx || l > r_idx) {\n            return;\n        }\n        if (l_idx <= l && r <= r_idx) {\n            if (isSetOperation) {\n                seg[node] = (r - l + 1) * val;\n                if (l != r) {\n                    ll l_node = 2 * node + 1;\n                    ll r_node = 2 * node + 2;\n                    setLazy[l_node] = val;\n                    setLazy[r_node] = val;\n                    lazy[l_node] = 0;\n                    lazy[r_node] = 0;\n                }\n            } else {\n                seg[node] += (r - l + 1) * val;\n                if (l != r) {\n                    ll l_node = 2 * node + 1;\n                    ll r_node = 2 * node + 2;\n                    lazy[l_node] += val;\n                    lazy[r_node] += val;\n                }\n            }\n            return;\n        }\n        ll mid = l + (r - l) / 2;\n        update(2 * node + 1, l, mid, l_idx, r_idx, val, isSetOperation);\n        update(2 * node + 2, mid + 1, r, l_idx, r_idx, val, isSetOperation);\n        seg[node] = seg[2 * node + 1] + seg[2 * node + 2];\n    }\n\n    ll query(ll node, ll l, ll r, ll l_query, ll r_query) {\n        propagate(node, l, r);\n        if (l_query <= l && r <= r_query) {\n            return seg[node];\n        }\n        if (r < l_query || l > r_query) {\n            return 0;\n        }\n        ll mid = l + (r - l) / 2;\n        return query(2 * node + 1, l, mid, l_query, r_query) + query(2 * node + 2, mid + 1, r, l_query, r_query);\n    }\n\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        seg.resize(4 * n, 0);\n        lazy.resize(4 * n, 0);\n        setLazy.resize(4 * n, -1);\n        update(0, 0, n - 1, 0, 0, 0, true);\n        for (int i = 1; i < n; i++) {\n            update(0, 0, n - 1, i, i, 1, true);\n        }\n        vector<int> ans;\n        for (auto e : queries) {\n            update(0, 0, n - 1, e[0] + 1, e[1] - 1, 0, true);\n            ans.push_back(query(0, 0, n - 1, 0, n - 1));\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722742602",
    "subm_id": "1343772763"
}