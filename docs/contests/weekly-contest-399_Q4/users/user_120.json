{
    "username": "hicoder",
    "submission": "class SegmentTree:\n    def __init__(self, data):\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        # Each element in the tree is a tuple (f(l, r), f(l+1, r), f(l, r-1), f(l+1, r-1))\n        self.data = [(0, 0, 0, 0)] * (2 * _size)\n        for i in range(self._len):\n            self.data[_size + i] = (data[i], 0, 0, 0)\n        for i in reversed(range(1, _size)):\n            self.data[i] = self._combine(self.data[i + i], self.data[i + i + 1])\n\n    # def _combine(self, left, right):\n    #     \"\"\"Combine two nodes\"\"\"\n    #     A = max(left[0] + right[2], left[1] + right[2], left[0] + right[3])\n    #     B = max(left[2] + right[0], left[2] + right[1], left[3] + right[0])\n    #     C = max(left[0] + right[0], left[1] + right[0], left[0] + right[1])\n    #     D = max(left[1] + right[1], left[1] + right[3], left[3] + right[1])\n    #     return (A, B, C, D)\n\n            \n    def _combine(self, left, right):\n        \"\"\"Combine two nodes\"\"\"\n        A = max((left[2] + right[1]), (left[0] + right[1]), (left[2] + right[0]))\n        B = max((left[3] + right[1]), (left[1] + right[1]), (left[3] + right[0]))\n        C =  max((left[2] + right[3]), (left[0] + right[3]), (left[2] + right[2]))\n        D = max((left[3] + right[3]), (left[1] + right[3]), (left[3] + right[2]))\n        return (A, B, C, D)\n\n\n\n    def __getitem__(self, idx):\n        return max(self.data[idx + self._size])\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = (value, 0, 0, 0)\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._combine(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def query(self, start, stop):\n        \"\"\"maximum subsequence sum of data[start, stop) such that no two consecutive elements are used\"\"\"\n        start += self._size\n        stop += self._size\n\n        res_left = (0, 0, 0, 0)\n        res_right = (0, 0, 0, 0)\n        while start < stop:\n            if start & 1:\n                res_left = self._combine(res_left, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res_right = self._combine(self.data[stop], res_right)\n            start >>= 1\n            stop >>= 1\n\n        result = self._combine(res_left, res_right)\n        return max(result)\n\n\n\n\nclass Solution:\n    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:\n        st = SegmentTree(nums)\n        ret = 0\n        MOD = 10**9 + 7\n        \n        \n        for i, j in queries:\n            st[i] = j\n            ret += st.query(0, len(nums))\n            ret %= MOD\n            \n        return ret",
    "submit_ts": 1716694807.0
}