{
    "username": "g129512",
    "submission": "\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\nclass SimpleSegTree {\n\n    static class Node {\n        Node left;\n        Node right;\n        long ls, rs;\n        long[][] dp=new long[2][2];\n    }\n\n    int maxN;\n    Node root;\n\n    public SimpleSegTree(int maxN) {\n        this.maxN = maxN;\n        this.root = createNode(0, maxN);\n    }\n\n    Node createNode(int ls, int rs) {\n        Node node = new Node();\n        node.ls = ls;\n        node.rs = rs;\n        return node;\n    }\n\n    public void build(int[] vals) {\n        build(vals, root, 0, maxN);\n    }\n\n    private void build(int[] vals, Node node, int ls, int rs) {\n        if (ls == rs) {\n            if (ls >= vals.length) return;\n            apply(node, 0, vals[ls], ls, rs);\n            return;\n        }\n        pushDown(node, ls, rs);\n        int mid = ls + rs >> 1;\n        build(vals, node.left, ls, mid);\n        build(vals, node.right, mid + 1, rs);\n        reduce(node, node.left, node.right, ls, rs);\n    }\n\n    /**\n     * \u4fee\u6539\u5355\u70b9\n     */\n    public void apply(Node node, int type, int val, int ls, int rs) {\n        node.dp[1][1] = val;\n        node.dp[0][0] = 0;\n        node.dp[0][1] = Long.MIN_VALUE;\n        node.dp[1][0] = Long.MIN_VALUE;\n    }\n\n    public void reduce(Node node, Node left, Node right, int ls, int rs) {\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                node.dp[i][j] = Long.MIN_VALUE;\n            }\n        }\n        for (int ll = 0; ll < 2; ll++) {\n            for (int lr = 0; lr < 2; lr++) {\n                for (int rl = 0; rl < 2; rl++) {\n                    for (int rr = 0; rr < 2; rr++) {\n                        long v=Long.MIN_VALUE;\n                        if (lr==0||rl==0) {\n                            long v1=left.dp[ll][lr];\n                            long v2=right.dp[rl][rr];\n                            if (v1!=Long.MIN_VALUE&&v2!=Long.MIN_VALUE){\n                                v=v1+v2;\n                            }\n                        }\n                        node.dp[ll][rr]=Math.max(v,node.dp[ll][rr]);\n                    }\n                }\n            }\n        }\n    }\n\n    public void add(int i, int val) {\n        add(root, i, 0, val, 0, maxN);\n    }\n\n    /**\n     * \u5f53\u524dNode\u7684\u8303\u56f4: [ls,rs]\n     */\n    private void add(Node node, int i, int type, int val, int ls, int rs) {\n        if (ls == rs) {\n            apply(node, type, val, ls, rs);\n            return;\n        }\n\n        pushDown(node, ls, rs);\n        int mid = ls + rs >> 1;\n        //\u5de6\u5b50\u6811[ls,mid]\n        //\u53f3\u5b50\u6811[mid+1,rs]\n        if (i <= mid) {\n            add(node.left, i, type, val, ls, mid);\n        } else if (i >= mid + 1) {\n            add(node.right, i, type, val, mid + 1, rs);\n        }\n        reduce(node, node.left, node.right, ls, rs);\n    }\n\n    void pushDown(Node node, int ls, int rs) {\n        int mid = ls + rs >> 1;\n        if (node.left == null) {\n            node.left = createNode(ls, mid);\n        }\n        if (node.right == null) {\n            node.right = createNode(mid + 1, rs);\n        }\n    }\n\n    Node query(Node node, int l, int r, int ls, int rs) {\n        if (l < 0 || r > maxN) {\n            throw new IllegalArgumentException();\n        }\n        if (l <= ls && rs <= r) {\n            return node;\n        }\n        pushDown(node, ls, rs);\n        int mid = ls + rs >> 1;\n        Node res = createNode(Math.max(ls, l), Math.min(rs, r)), leftRes = null, rightRes = null;\n        if (l <= mid) {\n            leftRes = query(node.left, l, r, ls, mid);\n        }\n        if (r >= mid + 1) {\n            rightRes = query(node.right, l, r, mid + 1, rs);\n        }\n        if (leftRes == null) return rightRes;\n        if (rightRes == null) return leftRes;\n        reduce(res, leftRes, rightRes, ls, rs);\n        return res;\n    }\n}\n\nclass Solution {\n    public int maximumSumSubsequence(int[] nums, int[][] qs) {\n        SimpleSegTree tree = new SimpleSegTree(nums.length-1);\n        tree.build(nums);\n        long res=0;\n        int M = (int) (1e9+7);\n        for (int[] q : qs) {\n            tree.add(q[0],q[1]);\n            SimpleSegTree.Node node = tree.query(tree.root, 0, nums.length - 1, 0, nums.length - 1);\n            long mx = Long.MIN_VALUE;\n            for (int i = 0; i < 2; i++) {\n                for (int j = 0; j < 2; j++) {\n                    mx = Math.max(mx, node.dp[i][j]);\n                }\n            }\n            res+=mx;\n            res%=M;\n        }\n        return (int) res;\n    }\n}",
    "submit_ts": 1716693496.0
}