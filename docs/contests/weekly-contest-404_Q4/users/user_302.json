{
    "username": "raararaara",
    "submission": "using lint = long long;\nusing ii = pair<int, int>;\nusing il = pair<int, lint>;\nusing li = pair<lint, int>;\nusing ll = pair<lint, lint>;\n\nconst int mxn = 1000100, mxp = 1000001;\nconst int MOD = 998244353, inf = -1e9 - 7, INF = 1e9 + 1;\nconst lint lnf = -4e18, LNF = 5e18;\nconst double eps = 1e-10;\nconst int sqrtN = 200;\n\n#define sz(x) int(size(x))\n#define all(x) (x).begin(),(x).end()\n#define compress(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())\n#define lb(x, v) (lower_bound(all(x), v) - (x).begin())\n#define ub(x, v) (upper_bound(all(x), v) - (x).begin())\n#define eb emplace_back\n#define pb push_back\n#define getName(var)  #var\nvector<lint> xl, yl;\n\n#define Yes \"Yes\\n\"\n#define No \"No\\n\"\n\nconst int dr[] = {-1, 0, 1, 0};\nconst int dc[] = {0, -1, 0, 1};\n\ninline int inRange(int r, int c, int R, int C) {\n    return 0 <= r && r < R && 0 <= c && c < C;\n}\n\nlint N, M, Q, R, C, H, K, T;\n\nvoid init() {\n\n}\n\ntemplate<typename T>\nstruct Tree {\n    struct EDG {\n        int u{}, v{};\n        T w;\n        EDG() = default;\n        EDG(int u, int v, T w): u(u), v(v), w(w){}\n    };\n    int N{};\n\n    vector<vector<int>> adj;\n    vector<int> ch, par;\n    vector<EDG> eList;\n    vector<T> weight;\n\n    Tree(int n): adj(n), ch(n, 1), par(n, -1), weight(n) {\n        N = n;\n    }\n\n    void build(int rt = 0) {\n        make_tree(rt);\n\n        // adjust (u,v,w) as (u,par[u],w)\n        for(auto &[u, v, w]: eList) {\n            if(u == par[v]) swap(u, v);\n            if(weight[u]) continue;\n            weight[u] = w;\n        }\n    }\n\n    void make_tree(int cur, int prv = -1) {\n        if(~par[cur]) adj[cur].erase(find(all(adj[cur]), par[cur]));\n\n        for(auto &nxt: adj[cur]) {\n            par[nxt] = cur;\n            make_tree(nxt, cur);\n            ch[cur] += ch[nxt];\n            if(ch[nxt] > ch[adj[cur][0]]) {\n                swap(nxt, adj[cur][0]);\n            }\n        }\n    }\n\n    void add_edge(int u, int v) {\n        adj[u].emplace_back(v);\n        adj[v].emplace_back(u);\n    }\n\n    void add_edge(int u, int v, int w) {\n        add_edge(u, v);\n        eList.emplace_back(u, v, w);\n    }\n\n    // diameter\n    T get_diameter(int rt = 0) {\n        int x;  // end point of diameter\n        T ret = 0;\n        vector<int> vis(N);\n        auto dfs = [&](const auto &self, int cur, T dist) -> void {\n            vis[cur] = 1;\n            if(ret < dist) {\n                ret = dist; x = cur;\n            }\n            if(~par[cur] && !vis[par[cur]]) self(self, par[cur], dist + weight[cur]);\n            for(auto &nxt: adj[cur]) {\n                if(!vis[nxt]) {\n                    self(self, nxt, dist + weight[nxt]);\n                }\n            }\n        };\n\n        dfs(dfs, rt, 0);\n        ret = 0; vis = vector(N, 0);\n        dfs(dfs, x, 0);\n\n        return ret;\n    }\n};\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = 0, m = 0;\n        for(auto &vec: edges1) {\n            n = max(n, vec[0]);\n            n = max(n, vec[1]);\n        }\n        for(auto &vec: edges2) {\n            m = max(m, vec[0]);\n            m = max(m, vec[1]);\n        }\n        n++; m++;\n        Tree<int> t1(n), t2(m);\n        for(auto &vec: edges1) {\n            int u = vec[0], v = vec[1];\n            t1.add_edge(u, v, 1);\n        }\n        for(auto &vec: edges2) {\n            int u = vec[0], v = vec[1];\n            t2.add_edge(u, v, 1);\n        }\n        t1.build();\n        t2.build();\n        int res1 = t1.get_diameter(), res2 = t2.get_diameter();\n        return max({res1, res2, (res1+1)/2 + (res2+1)/2 + 1});\n    }\n};",
    "submit_ts": "1719715900",
    "subm_id": "1304349480"
}