{
    "username": "guobaoli123",
    "submission": "struct SegmentTreeNode {  \n    int start, end; // \u533a\u95f4\u8303\u56f4  \n    int count;      // \u533a\u95f4\u51851\u7684\u4e2a\u6570  \n    int lazy;       // \u61d2\u60f0\u6807\u8bb0\uff0c\u7528\u4e8e\u533a\u95f4\u66f4\u65b0  \n    SegmentTreeNode *left, *right;  \n  \n    SegmentTreeNode(int s, int e) : start(s), end(e), count(e - s + 1), lazy(0), left(nullptr), right(nullptr) {}  \n};  \n  \nclass SegmentTree {  \nprivate:  \n    SegmentTreeNode* root;  \n  \n    // \u6784\u5efa\u7ebf\u6bb5\u6811  \n    SegmentTreeNode* buildTree(vector<int>& nums, int start, int end) {  \n        if (start > end) return nullptr;  \n        SegmentTreeNode* node = new SegmentTreeNode(start, end);  \n        if (start == end) {  \n            node->count = nums[start];  \n            return node;  \n        }  \n        int mid = start + (end - start) / 2;  \n        node->left = buildTree(nums, start, mid);  \n        node->right = buildTree(nums, mid + 1, end);  \n        node->count = node->left->count + node->right->count;  \n        return node;  \n    }  \n  \n    // \u66f4\u65b0\u7ebf\u6bb5\u6811\u8282\u70b9  \n    void updateNode(SegmentTreeNode* node) {  \n        if (node->lazy != 0) {  \n            node->count = 0; // \u66f4\u65b0\u4e3a0\u8868\u793a\u533a\u95f4\u5185\u6240\u6709\u5143\u7d20\u90fd\u88ab\u7f6e\u4e3a0  \n            if (node->start != node->end) { // \u975e\u53f6\u5b50\u8282\u70b9  \n                node->left->lazy = 1;  \n                node->right->lazy = 1;  \n            }  \n            node->lazy = 0; // \u6e05\u9664\u61d2\u60f0\u6807\u8bb0  \n        }  \n    }  \n  \n    // \u66f4\u65b0\u533a\u95f4  \n    void updateRange(SegmentTreeNode* node, int start, int end) {  \n        updateNode(node);  \n        if (node->start == start && node->end == end) {  \n            node->lazy = 1; // \u8bbe\u7f6e\u61d2\u60f0\u6807\u8bb0  \n            updateNode(node);  \n            return;  \n        }  \n        int mid = node->start + (node->end - node->start) / 2;  \n        if (end <= mid) {  \n            updateRange(node->left, start, end);  \n        } else if (start > mid) {  \n            updateRange(node->right, start, end);  \n        } else {  \n            updateRange(node->left, start, mid);  \n            updateRange(node->right, mid + 1, end);  \n        }  \n        node->count = node->left->count + node->right->count;  \n    }  \n  \n    // \u67e5\u8be2\u533a\u95f41\u7684\u4e2a\u6570  \n    int queryRange(SegmentTreeNode* node, int start, int end) {  \n        updateNode(node);  \n        if (node->start == start && node->end == end) {  \n            return node->count;  \n        }  \n        int mid = node->start + (node->end - node->start) / 2;  \n        if (end <= mid) {  \n            return queryRange(node->left, start, end);  \n        } else if (start > mid) {  \n            return queryRange(node->right, start, end);  \n        } else {  \n            return queryRange(node->left, start, mid) + queryRange(node->right, mid + 1, end);  \n        }  \n    }  \n  \npublic:  \n    SegmentTree(vector<int>& nums) {  \n        root = buildTree(nums, 0, nums.size() - 1);  \n    }  \n  \n    void update(int start, int end) {  \n        updateRange(root, start, end);  \n    }  \n  \n    int query(int start, int end) {  \n        return queryRange(root, start, end);  \n    }  \n};  \n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int>nums(n,1);\n        for(int i = 0;i<n;++i) nums[i] = i;\n        // SegmentTree st(nums);\n        set<int>ss(nums.begin(),nums.end());\n        int m = queries.size();\n        vector<int>ans(m);\n        for(int i = 0;i<m;++i){\n            if(queries[i][1]-queries[i][0]>1){\n                auto p = ss.lower_bound(queries[i][0]+1);\n                while(p!=ss.end()&&*p<queries[i][1]){\n                    // cout<<*p<<endl;\n                    p = ss.erase(p);\n                }\n                // st.update(queries[i][0]+1,queries[i][1]-1);\n            }\n            ans[i] = ss.size()-1;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722743778",
    "subm_id": "552352755"
}