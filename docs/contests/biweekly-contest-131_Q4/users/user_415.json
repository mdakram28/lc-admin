{
    "username": "Chandrachur",
    "submission": "class SegmentTree {\nprivate:\n    vector<int> tree;\n    int n;\n\n    void buildTree(const vector<int>& arr, int start, int end, int node) {\n        if (start == end) {\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            buildTree(arr, start, mid, 2 * node + 1);\n            buildTree(arr, mid + 1, end, 2 * node + 2);\n            tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    void updateTree(int start, int end, int index, int value, int node) {\n        if (start == end) {\n            tree[node] = value;\n        } else {\n            int mid = (start + end) / 2;\n            if (index <= mid) {\n                updateTree(start, mid, index, value, 2 * node + 1);\n            } else {\n                updateTree(mid + 1, end, index, value, 2 * node + 2);\n            }\n            tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    int queryTree(int start, int end, int l, int r, int node) {\n        if (l <= start && r >= end) {\n            return tree[node];\n        }\n        if (end < l || start > r) {\n            return INT_MIN;\n        }\n        int mid = (start + end) / 2;\n        return max(queryTree(start, mid, l, r, 2 * node + 1),\n                   queryTree(mid + 1, end, l, r, 2 * node + 2));\n    }\n\npublic:\n    SegmentTree(const vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        buildTree(arr, 0, n - 1, 0);\n    }\n\n    void update(int index, int value) {\n        updateTree(0, n - 1, index, value, 0);\n    }\n\n    int query(int r) {\n        return queryTree(0, n - 1, 0, r, 0);\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector<bool> res;\n        vector<int> arr(1e5 + 2, 0);\n        arr[0] = 1e5 + 2;\n        SegmentTree segTree(arr);\n        set<int> obstacles;\n        obstacles.insert(0);\n        obstacles.insert(1e5 + 2);\n        \n        for(auto &q : queries) {\n            int type = q[0];\n            int x = q[1];\n            if(type == 1) {\n                int prevObs = *prev(obstacles.upper_bound(x));\n                int nextObs = *obstacles.upper_bound(x);\n                int size = arr[prevObs];\n                \n                arr[x] = arr[prevObs] - (x - prevObs);\n                arr[prevObs] = x - prevObs;\n                \n                segTree.update(prevObs, arr[prevObs]);\n                segTree.update(x, arr[x]);\n                obstacles.insert(x);\n            } else {\n                int sz = q[2];\n                int val = segTree.query(x - sz);\n                if(val >= sz) {\n                    res.push_back(true);\n                } else {\n                    res.push_back(false);\n                }\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1716652240.0
}