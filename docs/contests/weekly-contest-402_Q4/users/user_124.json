{
    "username": "smilences",
    "submission": "import typing\n\nclass SegTree:\n    def __init__(self,\n                 op: typing.Callable[[typing.Any, typing.Any], typing.Any],\n                 e: typing.Any,\n                 v: typing.Union[int, typing.List[typing.Any]]) -> None:\n        self._op = op # \u51fd\u6570\uff0c\u4f8b\u5982\uff1amax,add,gcd\n        self._e = e # \u5e7a\u5143\uff0c\u9ed8\u8ba4\u5927\u5c0f\n\n        if isinstance(v, int): # \u539f\u6570\u7ec4\uff08\u5982\u679c\u8f93\u5165int\u5219\u8868\u793a\u6570\u7ec4\u957f\u5ea6\uff0c\u7528\u5e7a\u5143\u751f\u6210\u6570\u7ec4\uff09\n            v = [e] * v\n\n        self._n = len(v)\n        self._log = self._ceil_pow2(self._n)\n        self._size = 1 << self._log\n        self._d = [e] * (2 * self._size)\n\n        for i in range(self._n):\n            self._d[self._size + i] = v[i]\n        for i in range(self._size - 1, 0, -1):\n            self._update(i)\n\n    def _ceil_pow2(self, n: int) -> int:\n        x = 0\n        while (1 << x) < n:\n            x += 1\n\n        return x\n\n    # \u5355\u70b9\u4fee\u6539\uff0c\u4fee\u6539a[p] = x\uff0c\u590d\u6742\u5ea6\uff1ao(logn)\n    def set(self, p: int, x: typing.Any) -> None:\n        assert 0 <= p < self._n\n\n        p += self._size\n        self._d[p] = x\n        for i in range(1, self._log + 1):\n            self._update(p >> i)\n\n    # \u5355\u70b9\u67e5\u8be2\uff0c\u8fd4\u56dea[p]\uff0c\u590d\u6742\u5ea6\uff1ao(1)\n    def get(self, p: int) -> typing.Any:\n        assert 0 <= p < self._n\n\n        return self._d[p + self._size]\n\n    # \u533a\u95f4\u67e5\u8be2\uff0c\u8fd4\u56deop(a[l],\u2026\u2026,a[r-1])\uff0c\u590d\u6742\u5ea6\uff1ao(logn)\n    def prod(self, left: int, right: int) -> typing.Any:\n        assert 0 <= left <= right <= self._n\n        sml = self._e\n        smr = self._e\n        left += self._size\n        right += self._size\n\n        while left < right:\n            if left & 1:\n                sml = self._op(sml, self._d[left])\n                left += 1\n            if right & 1:\n                right -= 1\n                smr = self._op(self._d[right], smr)\n            left >>= 1\n            right >>= 1\n\n        return self._op(sml, smr)\n\n    # \u8fd4\u56deop(a[0], ..., a[n - 1])\uff0c\u590d\u6742\u5ea6\uff1ao(1)\n    def all_prod(self) -> typing.Any:\n        return self._d[1]\n\n    # \u6811\u4e0a\u4e8c\u5206\uff0c\u8fd4\u56de\u4e00\u4e2ar\u6ee1\u8db3f(op(a[l],\u2026\u2026,a[r-1])) == True\uff0cf(a[r]) == False\n    def max_right(self, left: int,\n                  f: typing.Callable[[typing.Any], bool]) -> int:\n        assert 0 <= left <= self._n\n        assert f(self._e)\n\n        if left == self._n:\n            return self._n\n\n        left += self._size\n        sm = self._e\n\n        first = True\n        while first or (left & -left) != left:\n            first = False\n            while left % 2 == 0:\n                left >>= 1\n            if not f(self._op(sm, self._d[left])):\n                while left < self._size:\n                    left *= 2\n                    if f(self._op(sm, self._d[left])):\n                        sm = self._op(sm, self._d[left])\n                        left += 1\n                return left - self._size\n            sm = self._op(sm, self._d[left])\n            left += 1\n\n        return self._n\n\n    def min_left(self, right: int,\n                 f: typing.Callable[[typing.Any], bool]) -> int:\n        assert 0 <= right <= self._n\n        assert f(self._e)\n\n        if right == 0:\n            return 0\n\n        right += self._size\n        sm = self._e\n\n        first = True\n        while first or (right & -right) != right:\n            first = False\n            right -= 1\n            while right > 1 and right % 2:\n                right >>= 1\n            if not f(self._op(self._d[right], sm)):\n                while right < self._size:\n                    right = 2 * right + 1\n                    if f(self._op(self._d[right], sm)):\n                        sm = self._op(self._d[right], sm)\n                        right -= 1\n                return right + 1 - self._size\n            sm = self._op(self._d[right], sm)\n\n        return 0\n\n    def _update(self, k: int) -> None:\n        self._d[k] = self._op(self._d[2 * k], self._d[2 * k + 1])\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        l = [0]*n\n        for i in range(1,n-1):\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:\n                l[i] = 1\n        st = SegTree(add,0,l)\n        \n        ans = []\n        for x,y,z in queries:\n            if x == 1:\n                if y + 1 >= z:\n                    ans.append(0)\n                else:\n                    ans.append(st.prod(y+1,z))\n            else:\n                nums[y] = z\n                for i in (y-1,y,y+1):\n                    if 0 < i < n-1:\n                        if nums[i] > nums[i-1] and nums[i] > nums[i+1]:\n                            st.set(i,1)\n                        else:\n                            st.set(i,0)\n        return ans\n\n\n\n\n\n\n\n",
    "submit_ts": 1718506715.0
}