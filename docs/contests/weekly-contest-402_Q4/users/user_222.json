{
    "username": "abid_humza",
    "submission": "class Solution {\npublic:\n    std::vector<int> countOfPeaks(std::vector<int>& nums, std::vector<std::vector<int>>& queries) {\n        int n = nums.size();\n        std::vector<int> peaks(n, 0);\n        std::vector<int> result;\n\n        auto is_peak = [&](int i) -> bool {\n            if (i <= 0 || i >= n - 1) return false;\n            return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n        };\n\n        // Initialize peaks array\n        for (int i = 1; i < n - 1; ++i) {\n            peaks[i] = is_peak(i) ? 1 : 0;\n        }\n\n        // Segment Tree implementation\n        struct SegmentTree {\n            std::vector<int> tree;\n            int size;\n\n            SegmentTree(int n) {\n                size = n;\n                tree.resize(4 * n, 0);\n            }\n\n            void build(const std::vector<int>& peaks, int node, int start, int end) {\n                if (start == end) {\n                    tree[node] = peaks[start];\n                } else {\n                    int mid = (start + end) / 2;\n                    build(peaks, 2 * node, start, mid);\n                    build(peaks, 2 * node + 1, mid + 1, end);\n                    tree[node] = tree[2 * node] + tree[2 * node + 1];\n                }\n            }\n\n            void update(int node, int start, int end, int idx, int value) {\n                if (start == end) {\n                    tree[node] = value;\n                } else {\n                    int mid = (start + end) / 2;\n                    if (start <= idx && idx <= mid) {\n                        update(2 * node, start, mid, idx, value);\n                    } else {\n                        update(2 * node + 1, mid + 1, end, idx, value);\n                    }\n                    tree[node] = tree[2 * node] + tree[2 * node + 1];\n                }\n            }\n\n            int query(int node, int start, int end, int l, int r) {\n                if (r < start || end < l) {\n                    return 0;\n                }\n                if (l <= start && end <= r) {\n                    return tree[node];\n                }\n                int mid = (start + end) / 2;\n                int p1 = query(2 * node, start, mid, l, r);\n                int p2 = query(2 * node + 1, mid + 1, end, l, r);\n                return p1 + p2;\n            }\n        };\n\n        SegmentTree segTree(n);\n        segTree.build(peaks, 1, 0, n - 1);\n\n        for (const auto& query : queries) {\n            if (query[0] == 1) {\n                // Count peaks in the subarray nums[li..ri]\n                int li = query[1], ri = query[2];\n                int count = segTree.query(1, 0, n - 1, li + 1, ri - 1);\n                result.push_back(count);\n            } else if (query[0] == 2) {\n                // Update nums[indexi] to vali\n                int index = query[1], value = query[2];\n                nums[index] = value;\n                // Update the segment tree for affected elements\n                for (int i = std::max(1, index - 1); i <= std::min(n - 2, index + 1); ++i) {\n                    int newValue = is_peak(i) ? 1 : 0;\n                    segTree.update(1, 0, n - 1, i, newValue);\n                }\n            }\n        }\n\n        return result;\n    }\n};",
    "submit_ts": "1718505635",
    "subm_id": "1289588587"
}