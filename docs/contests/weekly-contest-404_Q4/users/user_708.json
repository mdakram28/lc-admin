{
    "username": "ThisIsDPS08",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& tree1Edges, vector<vector<int>>& tree2Edges) {\n        int tree1Diameter = calculateDiameter(tree1Edges);\n        int tree2Diameter = calculateDiameter(tree2Edges);\n\n        return max({tree1Diameter, tree2Diameter, (tree1Diameter + 1) / 2 + (tree2Diameter + 1) / 2 + 1});\n    }\n\nprivate:\n    int calculateDiameter(const vector<vector<int>>& edges) {\n        int nodeCount = edges.size() + 1;\n        vector<vector<int>> adjacencyList(nodeCount);\n        for (const auto& edge : edges) {\n            adjacencyList[edge[0]].push_back(edge[1]);\n            adjacencyList[edge[1]].push_back(edge[0]);\n        }\n        int farthestNode = bfs(adjacencyList, 0).first;\n        int diameter = bfs(adjacencyList, farthestNode).second;\n        return diameter;\n    }\n\n    pair<int, int> bfs(const vector<vector<int>>& adjacencyList, int startNode) {\n        int nodeCount = adjacencyList.size();\n        vector<int> distances(nodeCount, -1);\n        queue<int> toVisit;\n        toVisit.push(startNode);\n        distances[startNode] = 0;\n        int farthestNode = startNode;\n        while (!toVisit.empty()) {\n            int currentNode = toVisit.front();\n            toVisit.pop();\n            for (int neighbor : adjacencyList[currentNode]) {\n                if (distances[neighbor] == -1) {\n                    distances[neighbor] = distances[currentNode] + 1;\n                    toVisit.push(neighbor);\n                    if (distances[neighbor] > distances[farthestNode]) {\n                        farthestNode = neighbor;\n                    }\n                }\n            }\n        }\n        return make_pair(farthestNode, distances[farthestNode]);\n    }\n};\n",
    "submit_ts": "1719716696",
    "subm_id": "1304371532"
}