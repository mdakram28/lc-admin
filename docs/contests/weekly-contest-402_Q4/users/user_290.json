{
    "username": "hahahiehie",
    "submission": "import java.util.*;\n\nclass Utils {\n    public static int log2(long n) {\n        return 63 - Long.numberOfLeadingZeros(n);\n    }\n\n    // nums = \"aaabaaaba\" odd d[1] return [1, 2, 1, 4, 1, 2, 2]\n    // d[0] for even, d[1] for odd\n    public static int[][] manacher(String s) {\n        int n = s.length();\n        int[] d1 = new int[n];\n        for (int i = 0, l = 0, r = -1; i < n; ++i) {\n            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);\n            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;\n            d1[i] = k;\n            if (i + k - 1 > r) {\n                l = i - k + 1;\n                r = i + k - 1;\n            }\n        }\n\n        int[] d0 = new int[n];\n        for (int i = 0, l = 0, r = -1; i < n; i++) {\n            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);\n            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {\n                k++;\n            }\n            d0[i] = k;\n            if (i + k - 1 > r) {\n                l = i - k;\n                r = i + k - 1;\n            }\n        }\n        return new int[][]{d0, d1};\n    }\n\n    // generate primes that is <= n\n    public static int[] genPrimes(int n) {\n        if (n <= 1) return new int[0];\n        boolean[] isComp = new boolean[n + 1];\n        int len = 0;\n        for (int i = 2; i <= n; i++) {\n            if (!isComp[i]) {\n                len++;\n                for (int j = i + i; j <= n; j += i) {\n                    isComp[j] = true;\n                }\n            }\n        }\n        int[] ans = new int[len];\n        for (int i = 2, j = 0; i <= n; i++) {\n            if (!isComp[i]) {\n                ans[j++] = i;\n            }\n        }\n        return ans;\n    }\n\n    // int[0] = primeFactor, int[1] = count of that primeFactor\n    // NOTE: factors[0] and factors[1] are empty list.\n    public static List<int[]>[] genPrimeFactors(int n) {\n        List<int[]>[] factors = new List[n + 1];\n        for (int i = 0; i <= n; i++) {\n            factors[i] = new ArrayList<>();\n        }\n        boolean[] isComp = new boolean[n + 1];\n        for (int i = 2; i <= n; i++) {\n            if (!isComp[i]) {\n                factors[i].add(new int[]{i, 1});\n                for (int j = i + i; j <= n; j += i) {\n                    isComp[j] = true;\n                    int t = j, count = 0;\n                    while (t % i == 0) {\n                        count++;\n                        t /= i;\n                    }\n                    factors[j].add(new int[]{i, count});\n                }\n            }\n        }\n        return factors;\n    }\n\n    // generate factors (not prime factors), factors[0] is empty list.\n    public static List<Integer>[] genFactors(int n) {\n        List<Integer>[] factors = new List[n + 1];\n        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            for (int j = i; j <= n; j += i) {\n                factors[j].add(i);\n            }\n        }\n        return factors;\n    }\n\n    public static int lowerBound(int[] a, int target) {\n        return lowerBound(a, target, a.length);\n    }\n\n    public static int lowerBound(int[] a, int target, int n) {\n        int low = 0;\n        int high = n;\n        while (low < high) {\n            int mid = low + ((high - low) >> 1);\n            if (a[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    public static int upperBound(int[] a, int target) {\n        return upperBound(a, target, a.length);\n    }\n\n    public static int upperBound(int[] a, int target, int n) {\n        int low = 0;\n        int high = n;\n        while (low < high) {\n            int mid = low + ((high - low) >> 1);\n            if (a[mid] <= target) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    public static int lowerBound(long[] a, long target) {\n        return lowerBound(a, target, a.length);\n    }\n\n    public static int lowerBound(long[] a, long target, int n) {\n        int low = 0;\n        int high = n;\n        while (low < high) {\n            int mid = low + ((high - low) >> 1);\n            if (a[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    public static int upperBound(long[] a, long target) {\n        return upperBound(a, target, a.length);\n    }\n\n    public static int upperBound(long[] a, long target, int n) {\n        int low = 0;\n        int high = n;\n        while (low < high) {\n            int mid = low + ((high - low) >> 1);\n            if (a[mid] <= target) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {\n        int low = 0;\n        int high = n;\n        while (low < high) {\n            int mid = low + ((high - low) >> 1);\n            if (a[mid].compareTo(target) < 0) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {\n        int low = 0;\n        int high = n;\n        while (low < high) {\n            int mid = low + ((high - low) >> 1);\n            if (a[mid].compareTo(target) <= 0) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {\n        int low = 0;\n        int high = a.size();\n        while (low < high) {\n            int mid = low + ((high - low) >> 1);\n            if (a.get(mid).compareTo(target) < 0) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {\n        int low = 0;\n        int high = a.size();\n        while (low < high) {\n            int mid = low + ((high - low) >> 1);\n            if (a.get(mid).compareTo(target) <= 0) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    public static long or(int x, int y) {\n        return ((long) x << 32) | ((long) y << 32 >>> 32);\n    }\n\n    // k = 0...nums.length - 1\n    // After calling this function, nums[k] is the k-th number.\n    public static int kthNumber(int[] nums, int k) {\n        return kthNumberHelper(nums, k, 0, nums.length - 1);\n    }\n\n    // end is inclusive (0 to nums.length - 1)\n    private static int kthNumberHelper(int[] nums, int K, int start, int end) {\n        if (start == end) return nums[start];\n        int i = partition(nums, start, end);\n        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);\n    }\n\n    // end is inclusive (0 to nums.length - 1)\n    public static int partition(int[] nums, int start, int end) {\n        int pos = start + ((end - start) >> 1);\n        int pivot = nums[pos];\n\n        int i = start, j = end;\n        nums[pos] = nums[end];\n        while (i < j) {\n            while (i < j && nums[i] < pivot) i++;\n            if (i < j) nums[j--] = nums[i];\n\n            while (i < j && pivot < nums[j]) j--;\n            if (i < j) nums[i++] = nums[j];\n        }\n\n        // pos is the final position for pivot.\n        nums[i] = pivot;\n        return i;\n    }\n\n    public static void swap(int[] nums, int i, int j) {\n        int t = nums[i];\n        nums[i] = nums[j];\n        nums[j] = t;\n    }\n\n    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]\n    public static void partition3(int[] nums, int pivot) {\n        int n = nums.length;\n        int l = 0, r = n - 1;\n        for (int i = 0; i <= r; i++) {\n            if (nums[i] < pivot) {\n                swap(nums, l++, i);\n            } else if (nums[i] > pivot) {\n                swap(nums, r--, i--);\n            }\n        }\n    }\n\n    // end is inclusive\n    public static void reverse(int[] nums, int start, int end) {\n        for (int i = start, j = end; i < j; i++, j--) {\n            int t = nums[i];\n            nums[i] = nums[j];\n            nums[j] = t;\n        }\n    }\n\n    // Return false if next permutation is not available. (nums is not changed for this case)\n    public static boolean nextPermutation(int[] nums) {\n        int n = nums.length;\n        if (n <= 1) return false;\n        int i = n - 1;\n        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {\n            i--;\n        }\n        if (i <= 0) return false;\n        for (int j = n - 1; j >= i; j--) {\n            if (nums[j] > nums[i - 1]) {\n                int t = nums[j];\n                nums[j] = nums[i - 1];\n                nums[i - 1] = t;\n\n                reverse(nums, i, n - 1);\n                break;\n            }\n        }\n        return true;\n    }\n\n    // Return false if previous permutation is not available. (nums is not changed for this case)\n    public static boolean prevPermutation(int[] nums) {\n        int n = nums.length;\n        if (n <= 1) return false;\n        int i = n - 1;\n        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {\n            i--;\n        }\n        if (i <= 0) return false;\n        for (int j = n - 1; j >= i; j--) {\n            if (nums[j] < nums[i - 1]) {\n                int t = nums[j];\n                nums[j] = nums[i - 1];\n                nums[i - 1] = t;\n\n                reverse(nums, i, n - 1);\n                break;\n            }\n        }\n        return true;\n    }\n\n    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash\n    // rolling hash of substrings of 's' with length == k\n    // long[pos] = hash(s.substring(pos, pos + k))\n    public static long[] rollingHash(String s, int k) {\n        long[] ans = new long[s.length() - k + 1];\n        int seed1 = 31;\n        int seed2 = 131;\n        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;\n        for (int i = 0; i < k; i++) {\n            h1 = h1 * seed1 + s.charAt(i);\n            h2 = h2 * seed2 + s.charAt(i);\n\n            power1 *= seed1;\n            power2 *= seed2;\n        }\n\n        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);\n        for (int i = k; i < s.length(); i++) {\n            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);\n            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);\n            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);\n        }\n\n        return ans;\n    }\n\n    public static int[] kmpNext(String s) {\n        int n = s.length();\n        int[] next = new int[n];\n        next[0] = 0;\n        for (int i = 1; i < n; i++) {\n            int k = next[i - 1];\n            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];\n            if (s.charAt(i) == s.charAt(k)) {\n                next[i] = k + 1;\n            } else {\n                next[i] = 0;\n            }\n        }\n        return next;\n    }\n\n    // s is the original String\n    // p is the pattern String\n    public static boolean kmpMatch(String s, String p) {\n        int[] next = kmpNext(p);\n        int n = s.length();\n        int m = p.length();\n        for (int i = 0, j = 0; i < n; i++) {\n            while (j > 0 && p.charAt(j) != s.charAt(i)) {\n                j = next[j - 1];\n            }\n            if (p.charAt(j) == s.charAt(i)) j++;\n            if (j == m) return true;\n        }\n        return false;\n    }\n\n    public static int[] kmpNext(int[] s) {\n        int n = s.length;\n        int[] next = new int[n];\n        next[0] = 0;\n        for (int i = 1; i < n; i++) {\n            int k = next[i - 1];\n            while (k > 0 && s[i] != s[k]) k = next[k - 1];\n            if (s[i] == s[k]) {\n                next[i] = k + 1;\n            } else {\n                next[i] = 0;\n            }\n        }\n        return next;\n    }\n\n    // s is the original String\n    // p is the pattern String\n    public static boolean kmpMatch(int[] s, int[] p) {\n        int[] next = kmpNext(p);\n        int n = s.length;\n        int m = p.length;\n        for (int i = 0, j = 0; i < n; i++) {\n            while (j > 0 && p[j] != s[i]) {\n                j = next[j - 1];\n            }\n            if (p[j] == s[i]) j++;\n            if (j == m) return true;\n        }\n        return false;\n    }\n\n    // a, b could be negative\n    // remainder >= 0\n    // return [a / b, a % b]\n    public static int[] divMod(int a, int b) {\n        int r = a % b;\n        int c = a / b;\n        if (r < 0) {\n            r += Math.abs(b);\n            c++;\n        }\n        return new int[]{c, r};\n    }\n\n    public static List<Integer> negativeBase(int n, int base) {\n        List<Integer> digits = new ArrayList<>();\n        if (n == 0) {\n            digits.add(0);\n            return digits;\n        }\n        while (n != 0) {\n            // t[0] = n / base\n            // t[1] = n % base;\n            int[] t = divMod(n, base);\n            digits.add(t[1]);\n            n = t[0];\n        }\n        Collections.reverse(digits);\n        return digits;\n    }\n\n    // (a ^ b) % MOD\n    public static long powMod(long a, long b, long MOD) {\n        long res = 1L;\n        a %= MOD; // In case a * a is overflow\n        while (b > 0) {\n            if ((b & 1) != 0) res = (res * a) % MOD;\n            a = a * a % MOD;\n            b >>= 1;\n        }\n        return res;\n    }\n\n    public static void preprocessCombination(long[][] C, long MOD) {\n        int m = C.length;\n        int n = C[0].length;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j <= i && j < n; j++) {\n                if (j == 0 || i == j) C[i][j] = 1;\n                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;\n            }\n        }\n    }\n\n    public static void preprocessCombination(long[][] C) {\n        int m = C.length;\n        int n = C[0].length;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j <= i && j < n; j++) {\n                if (j == 0 || i == j) C[i][j] = 1;\n                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);\n            }\n        }\n    }\n\n    public static void preprocessPermutation(long[][] P, long MOD) {\n        int m = P.length;\n        int n = P[0].length;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j <= i && j < n; j++) {\n                if (i == 0 || j == 0) P[i][j] = 1;\n                else P[i][j] = P[i][j - 1] * (i - j + 1) % MOD;\n            }\n        }\n    }\n\n    public static long gcd(long x, long y) {\n        return x != 0 ? gcd(y % x, x) : y;\n    }\n\n    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive\n        int[] lg = new int[n + 1];\n        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {\n            while ((1 << k) <= i) {\n                k++;\n            }\n        }\n        return lg;\n    }\n\n    public static long max(long[] nums) {\n        long ret = Long.MIN_VALUE;\n        for (long v : nums) ret = Math.max(ret, v);\n        return ret;\n    }\n\n    public static int max(int[] nums) {\n        int ret = Integer.MIN_VALUE;\n        for (int v : nums) ret = Math.max(ret, v);\n        return ret;\n    }\n}\n\n// Tested by leetcode 1163\nclass SuffixArray {\n    int[] s;\n    int[] SA; // SA[i] => index of the i-th ranked suffix\n    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i\n    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).\n\n    private int[][] d;\n    private int n;\n    private int[] lg;\n\n    private int log2(int n) {\n        return 31 - Integer.numberOfLeadingZeros(n);\n    }\n\n    private static int[] stringToIntArray(String str) {\n        int[] nums = new int[str.length()];\n        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);\n        return nums;\n    }\n\n    public SuffixArray(String str) {\n        this(str, true);\n    }\n\n    public SuffixArray(String str, boolean toBuildRMQ) {\n        this(stringToIntArray(str), toBuildRMQ);\n    }\n\n    public SuffixArray(int[] nums) {\n        this(nums, true);\n    }\n\n    public SuffixArray(int[] nums, boolean toBuildRMQ) {\n        this.s = nums;\n        this.n = nums.length;\n        this.SA = new int[n];\n        this.rank = new int[n];\n        suffixSort(s);\n        if (toBuildRMQ) {\n            this.height = new int[n];\n            this.d = new int[log2(n) + 1][n];\n            this.lg = new int[n + 1];\n            buildHeight();\n            buildRMQ();\n        }\n    }\n\n    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).\n    // ?? s[n] = 0 or s[n] = -INF.\n    private void buildHeight() {\n        int i, j, h;\n        height[0] = 0;\n        for (i = 0; i < n; i++)\n            rank[SA[i]] = i;\n        for (h = i = 0; i < n; i++)\n            if (rank[i] > 0) {\n                j = SA[rank[i] - 1];\n                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;\n                height[rank[i]] = h;\n                if (h > 0) --h;\n            }\n    }\n\n    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.\n    private void buildRMQ() {\n        int i, j, k;\n        for (i = 0; i < n; i++)\n            d[0][i] = height[i];\n        for (j = 1; (1 << j) <= n; j++)\n            for (i = 0; i + (1 << j) <= n; i++)\n                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);\n        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)\n            while ((1 << k) <= i) k++;\n    }\n\n    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.\n    public int LCP(int i, int j) {\n        if (i == j) return n - SA[i];\n        if (i > j) {\n            int t = i;\n            i = j;\n            j = t;\n        }\n        int k = lg[j - (++i) + 1];\n        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);\n    }\n\n    // LCPIndex(i, j) = LCP(s[i], s[j])\n    public int LCPIndex(int i, int j) {\n        return LCP(rank[i], rank[j]);\n    }\n\n    private void sortIndex(int[] nums, int start, int end) {\n        if (start >= end) return;\n        int pos = start + ((end - start) >> 1);\n        int pivot = nums[pos];\n\n        int i = start, j = end;\n        nums[pos] = nums[end];\n        while (i < j) {\n            while (i < j && s[nums[i]] < s[pivot]) i++;\n            if (i < j) nums[j--] = nums[i];\n\n            while (i < j && s[pivot] < s[nums[j]]) j--;\n            if (i < j) nums[i++] = nums[j];\n        }\n        nums[i] = pivot; // index i is the final position for pivot.\n        sortIndex(nums, start, i - 1);\n        sortIndex(nums, i + 1, end);\n    }\n\n    private void suffixSort(int[] s) {\n        int[] count = new int[n], t;\n        int[] nSA = new int[n];\n        int[] nRank = new int[n];\n//        Integer[] tempArray = new Integer[n];\n//        for (int x = 0; x < n; x++) tempArray[x] = x;\n//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));\n//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];\n        int i, k;\n        int minV = s[0], maxV = s[0];\n        for (i = 1; i < n; i++) {\n            minV = Math.min(minV, s[i]);\n            maxV = Math.max(maxV, s[i]);\n        }\n        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small\n            for (i = 0; i < n; i++) count[s[i] - minV]++;\n            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];\n            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;\n        } else {\n            for (i = 0; i < n; i++) SA[i] = i;\n            sortIndex(SA, 0, n - 1);\n        }\n        for (rank[SA[0]] = 0, i = 1; i < n; i++) {\n            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];\n        }\n        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {\n            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;\n            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;\n            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;\n            t = SA;\n            SA = nSA;\n            nSA = t;\n            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {\n                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];\n            }\n            t = rank;\n            rank = nRank;\n            nRank = t;\n        }\n    }\n}\n\nclass Combination {\n    long[] factorial;\n    long[] inverseFactorial;\n    long MOD;\n\n    // O(maxSize) for preprocessing\n    // MOD must be prime\n    public Combination(int maxSize, long MOD) {\n        factorial = new long[maxSize + 1];\n        inverseFactorial = new long[maxSize + 1];\n        factorial[0] = 1;\n        inverseFactorial[0] = 1;\n        this.MOD = MOD;\n        for (int i = 1; i <= maxSize; i++) {\n            factorial[i] = factorial[i - 1] * i % MOD;\n            inverseFactorial[i] = inverse(factorial[i]);\n        }\n    }\n\n    // x, y are long[1]\n    // ax + by = gcd(a, b)\n    private long extGcd(long a, long b, long[] x, long[] y) {\n        if (b == 0) {\n            x[0] = 1;\n            y[0] = 0;\n            return a;\n        } else {\n            long r = extGcd(b, a % b, y, x);\n            y[0] -= x[0] * (a / b);\n            return r;\n        }\n    }\n\n    // (a * x) % MOD = 1\n    // x is the inverse element\n    public long inverse(long a) {\n        long[] x = new long[1], y = new long[1];\n        extGcd(a, MOD, x, y);\n        return (x[0] % MOD + MOD) % MOD;\n    }\n\n    // m >= n\n    // O(1)\n    public long P(int m, int n) {\n        if (m == 0 || n == 0) return 1;\n        else if (m == n) return factorial[m];\n            //return factorial[m] * inverse(factorial[m - n]) % MOD;\n        else return factorial[m] * inverseFactorial[m - n] % MOD;\n    }\n\n    // m >= n\n    // O(1)\n    public long C(int m, int n) {\n        if (m == 0 || n == 0 || m == n) return 1;\n            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;\n        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;\n    }\n}\n\nclass CombinationNoMod {\n\n    long[][] C;\n    long[][] P;\n\n    public CombinationNoMod(int maxSize) {\n        C = new long[maxSize + 1][maxSize + 1];\n        P = new long[maxSize + 1][maxSize + 1];\n        int m = C.length;\n        int n = C[0].length;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j <= i && j < n; j++) {\n                if (j == 0 || i == j) C[i][j] = 1;\n                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j <= i && j < n; j++) {\n                if (i == 0 || j == 0) P[i][j] = 1;\n                else P[i][j] = P[i][j - 1] * (i - j + 1);\n            }\n        }\n    }\n\n    // m >= n. O(1)\n    public long P(int m, int n) {\n        if (m == 0 || n == 0) return 1;\n        return P[m][n];\n    }\n\n    // m >= n. O(1)\n    public long C(int m, int n) {\n        if (m == 0 || n == 0 || m == n) return 1;\n        return C[m][n];\n    }\n}\n\nclass Fraction {\n    long n, d; // n / d (d != 0)\n\n    public Fraction(long n, long d) {\n        if (d == 0) {\n            this.n = Long.MAX_VALUE;\n            this.d = 1;\n            return;\n        }\n        long g = gcd(Math.abs(n), Math.abs(d));\n        this.n = n / g;\n        this.d = d / g;\n        if (this.d < 0) {\n            this.d = -this.d;\n            this.n = -this.n;\n        }\n    }\n\n    public void add(Fraction other) {\n        long numerator = this.n * other.d + this.d * other.n;\n        long denominator = this.d * other.d;\n        long g = gcd(Math.abs(numerator), Math.abs(denominator));\n        this.n = numerator / g;\n        this.d = denominator / g;\n        if (this.d < 0) {\n            this.d = -this.d;\n            this.n = -this.n;\n        }\n    }\n\n    @Override\n    public boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof Fraction) {\n            Fraction anotherObject = (Fraction) anObject;\n            return n == anotherObject.n && d == anotherObject.d;\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return (int) (n * 31 + d);\n    }\n\n    private long gcd(long x, long y) {\n        return x != 0 ? gcd(y % x, x) : y;\n    }\n}\n\nclass UnionFind {\n    int[] parent;\n    int[] sz;\n\n    // from 0 ... n - 1\n    public UnionFind(int n) {\n        parent = new int[n];\n        sz = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    public void clear() {\n        for (int i = 0; i < parent.length; i++) {\n            parent[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    public int find(int x) {\n        //return parent[x] == x ? x : (parent[x] = find(parent[x]));\n        if (parent[x] == x) return x;\n        int px = x;\n        while (px != parent[px]) px = parent[px];\n        while (x != px) {\n            int next = parent[x];\n            parent[x] = px;\n            x = next;\n        }\n        return px;\n    }\n\n    // px is the final parent\n    public boolean union(int x, int y) {\n        int px = find(x);\n        int py = find(y);\n        if (px == py) return false;\n        parent[py] = px;\n        sz[px] += sz[py];\n        return true;\n    }\n\n    public int size(int x) {\n        return sz[find(x)];\n    }\n\n    public UnionFind clone() {\n        UnionFind cloned = new UnionFind(parent.length);\n        for (int i = 0; i < parent.length; i++) {\n            cloned.parent[i] = parent[i];\n            cloned.sz[i] = sz[i];\n        }\n        return cloned;\n    }\n}\n\nclass Trie {\n    static class TrieNode {\n        TrieNode[] next = new TrieNode[26];\n        boolean isWord = false;\n        long count = 0L;\n    }\n\n    TrieNode root = new TrieNode();\n\n    public void add(String word) {\n        add(word, 1L);\n    }\n\n    public void remove(String word) {\n        add(word, -1L);\n    }\n\n    private void add(String word, long count) {\n        TrieNode cur = root;\n        cur.count += count;\n        for (int i = 0; i < word.length(); i++) {\n            int c = word.charAt(i) - 'a';\n            if (cur.next[c] == null) cur.next[c] = new TrieNode();\n            cur = cur.next[c];\n            cur.count += count;\n        }\n        cur.isWord = true;\n    }\n\n    public boolean contains(String word) {\n        TrieNode cur = root;\n        for (int i = 0; i < word.length(); i++) {\n            int c = word.charAt(i) - 'a';\n            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;\n            cur = cur.next[c];\n            //if (cur.isWord) return true;\n        }\n        return cur.isWord;\n    }\n}\n\n// Tested by Leetcode 1707 and Leetcode 1803\nclass TrieBinary {\n    static class TrieNode {\n        TrieNode[] next = new TrieNode[2];\n        long count;\n    }\n\n    private TrieNode root;\n    private int numOfBits;\n\n    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long\n        this.numOfBits = numOfBits;\n        this.root = new TrieNode();\n    }\n\n    public void add(long v) {\n        add(v, 1L);\n    }\n\n    public void remove(long v) { // Tested by Leetcode 1938\n        add(v, -1L);\n    }\n\n    public void add(long v, long count) {\n        TrieNode cur = root;\n        root.count += count;\n        for (int i = numOfBits - 1; i >= 0; i--) {\n            int b = ((v >>> i) & 1) == 0 ? 0 : 1;\n            if (cur.next[b] == null) cur.next[b] = new TrieNode();\n            cur = cur.next[b];\n            cur.count += count;\n        }\n    }\n\n    // Tested by Leetcode 1707\n    public long xorMax(long v) {\n        TrieNode cur = root;\n        long key = 0;\n        for (int i = numOfBits - 1; i >= 0; i--) {\n            int b = ((v >>> i) & 1) == 0 ? 0 : 1;\n            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {\n                cur = cur.next[1 - b];\n                key |= (1L - b) << i;\n            } else {\n                cur = cur.next[b];\n                key |= (long) b << i;\n            }\n        }\n        return key ^ v;\n    }\n\n    public boolean contains(long v) {\n        TrieNode cur = root;\n        for (int i = numOfBits - 1; i >= 0; i--) {\n            int b = ((v >>> i) & 1) == 0 ? 0 : 1;\n            if (cur.next[b] == null || cur.next[b].count <= 0) return false;\n            cur = cur.next[b];\n        }\n        return true;\n    }\n\n    // Tested by Leetcode 1803\n    // count(x ^ v <= limit)\n    public long xorLessOrEqualCount(long v, long limit) {\n        if (limit < 0) return 0;\n        TrieNode cur = root;\n        long ans = 0;\n        for (int i = numOfBits - 1; i >= 0; i--) {\n            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;\n            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;\n            if (bitLimit == 1) {\n                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);\n            }\n            cur = cur.next[bitV ^ bitLimit];\n            if (cur == null) break;\n            if (i == 0) ans += cur.count;\n        }\n        return ans;\n    }\n}\n\n// Tested by Leetcode 732\n// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/\n// Refer to AlgorithmCompilation.java\n\n\n// Tested by Leetcode 307\nclass DynamicSegmentTreeRangeSum {\n    class TreeNode {\n        TreeNode left, right;\n        long sum;\n    }\n\n    private final TreeNode root;\n    private final long L, R;\n\n    public DynamicSegmentTreeRangeSum(long l, long r) {\n        L = l;\n        R = r;\n        root = new TreeNode();\n    }\n\n    public long get(long index) {\n        long l = L, r = R;\n        TreeNode cur = root;\n        while (l < r && cur != null) {\n            long m = (l + r) >> 1;\n            if (index <= m) {\n                cur = cur.left;\n                r = m;\n            } else {\n                cur = cur.right;\n                l = m + 1;\n            }\n        }\n        return sum(cur);\n    }\n\n    public void add(long index, long value) {\n        set(index, get(index) + value);\n    }\n\n    private long sum(TreeNode node) {\n        return node == null ? 0L : node.sum;\n    }\n\n    public void set(long index, long value) {\n        set(root, L, R, index, value);\n    }\n\n    private void set(TreeNode root, long L, long R, long index, long value) {\n        if (index < L || R < index) return;\n        if (L == R) {\n            root.sum = value;\n            return;\n        }\n        long M = L + ((R - L) >> 1);\n        if (index <= M) {\n            if (root.left == null) root.left = new TreeNode();\n            set(root.left, L, M, index, value);\n        } else {\n            if (root.right == null) root.right = new TreeNode();\n            set(root.right, M + 1, R, index, value);\n        }\n        root.sum = sum(root.left) + sum(root.right);\n    }\n\n    // Sum[queryL...queryR] inclusive\n    public long query(long queryL, long queryR) {\n        return query(root, L, R, queryL, queryR);\n    }\n\n    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.\n    private long query(TreeNode root, long L, long R, long queryL, long queryR) {\n        if (root == null || queryL > R || queryR < L) return 0L;\n        if (queryL <= L && R <= queryR) return root.sum;\n        long M = L + ((R - L) >> 1);\n        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);\n    }\n}\n\n// Tested by Leetcode 239, 2926\nclass DynamicSegmentTreeRangeMax {\n    class TreeNode {\n        TreeNode left, right;\n        long max = Long.MIN_VALUE;\n    }\n\n    private final TreeNode root;\n    private final long L, R;\n\n    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive\n        L = l;\n        R = r;\n        root = new TreeNode();\n    }\n\n    public long get(long index) {\n        long l = L, r = R;\n        TreeNode cur = root;\n        while (l < r && cur != null) {\n            long m = (l + r) >> 1;\n            if (index <= m) {\n                cur = cur.left;\n                r = m;\n            } else {\n                cur = cur.right;\n                l = m + 1;\n            }\n        }\n        return max(cur);\n    }\n\n    private long max(TreeNode node) {\n        return node == null ? Long.MIN_VALUE : node.max;\n    }\n\n    public void set(long index, long value) {\n        set(root, L, R, index, value);\n    }\n\n    private void set(TreeNode root, long L, long R, long index, long value) {\n        if (index < L || R < index) return;\n        if (L == R) {\n            root.max = value;\n            return;\n        }\n\n        long M = L + ((R - L) >> 1);\n        if (index <= M) {\n            if (root.left == null) root.left = new TreeNode();\n            set(root.left, L, M, index, value);\n        } else {\n            if (root.right == null) root.right = new TreeNode();\n            set(root.right, M + 1, R, index, value);\n        }\n        root.max = Math.max(max(root.left), max(root.right));\n    }\n\n    // Max[queryL...queryR] inclusive\n    public long query(long queryL, long queryR) {\n        return query(root, L, R, queryL, queryR);\n    }\n\n    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.\n    private long query(TreeNode root, long L, long R, long queryL, long queryR) {\n        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;\n        if (queryL <= L && R <= queryR) return root.max;\n        long M = L + ((R - L) >> 1);\n        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));\n    }\n}\n\nclass DynamicSegmentTreeRangeMin {\n    class TreeNode {\n        TreeNode left, right;\n        long min = Long.MAX_VALUE;\n    }\n\n    private final TreeNode root;\n    private final long L, R;\n\n    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive\n        L = l;\n        R = r;\n        root = new TreeNode();\n    }\n\n    public long get(long index) {\n        long l = L, r = R;\n        TreeNode cur = root;\n        while (l < r && cur != null) {\n            long m = (l + r) >> 1;\n            if (index <= m) {\n                cur = cur.left;\n                r = m;\n            } else {\n                cur = cur.right;\n                l = m + 1;\n            }\n        }\n        return min(cur);\n    }\n\n    private long min(TreeNode node) {\n        return node == null ? Long.MAX_VALUE : node.min;\n    }\n\n    public void set(long index, long value) {\n        set(root, L, R, index, value);\n    }\n\n    private void set(TreeNode root, long L, long R, long index, long value) {\n        if (index < L || R < index) return;\n        if (L == R) {\n            root.min = value;\n            return;\n        }\n\n        long M = L + ((R - L) >> 1);\n        if (index <= M) {\n            if (root.left == null) root.left = new TreeNode();\n            set(root.left, L, M, index, value);\n        } else {\n            if (root.right == null) root.right = new TreeNode();\n            set(root.right, M + 1, R, index, value);\n        }\n        root.min = Math.min(min(root.left), min(root.right));\n    }\n\n    // Max[queryL...queryR] inclusive\n    public long query(long queryL, long queryR) {\n        return query(root, L, R, queryL, queryR);\n    }\n\n    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.\n    private long query(TreeNode root, long L, long R, long queryL, long queryR) {\n        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;\n        if (queryL <= L && R <= queryR) return root.min;\n        long M = L + ((R - L) >> 1);\n        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));\n    }\n}\n\nclass BinaryIndexTree {\n    private long[] c;\n    private int n;\n\n    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)\n    public BinaryIndexTree(int n) {\n        this.n = n;\n        this.c = new long[n + 1];\n    }\n\n    // Add value to position k, k is from 1 to n.\n    public void add(int k, long value) {\n        while (k <= n) {\n            c[k] += value;\n            k += (k & (k ^ (k - 1)));\n        }\n    }\n\n    // k is from 1 to n.\n    public long getSum(int k) {\n        long sum = 0;\n        while (k > 0) {\n            sum += c[k];\n            k -= (k & (k ^ (k - 1)));\n        }\n        return sum;\n    }\n}\n\nclass RangeSum {\n    BinaryIndexTree tree;\n    int start;\n\n    // [low, high] inclusive\n    public RangeSum(int low, int high) {\n        start = low;\n        tree = new BinaryIndexTree(high - low + 1);\n    }\n\n    public void add(int index, long value) {\n        tree.add(index - start + 1, value);\n    }\n\n    public long get(int index) {\n        return tree.getSum(index - start + 1) - tree.getSum(index - start);\n    }\n\n    public void set(int index, long value) {\n        tree.add(index - start + 1, value - get(index));\n    }\n\n    // [l, r] inclusive\n    public long getSum(int l, int r) {\n        return tree.getSum(r - start + 1) - tree.getSum(l - start);\n    }\n}\n\nclass RangeMax {\n    int start;\n    int n;\n    long[] t;\n\n    // [low, high] inclusive\n    public RangeMax(int low, int high) {\n        start = low;\n        n = high - low + 1;\n        t = new long[n * 2 + 2];\n        Arrays.fill(t, Long.MIN_VALUE);\n    }\n\n    public RangeMax(int low, int high, long defaultValue) {\n        start = low;\n        n = high - low + 1;\n        t = new long[n * 2 + 2];\n        Arrays.fill(t, defaultValue);\n    }\n\n    long get(int index) {\n        return t[index - start + n];\n    }\n\n    void set(int index, long value) {\n        index -= start;\n        for (t[index += n] = value; (index >>= 1) > 0; ) {\n            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);\n        }\n    }\n\n    // [l, r] inclusive\n    long getMax(int l, int r) {\n        l -= start;\n        r = (r + 1 - start); // make it as [l, r)\n        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);\n            if ((r & 1) != 0) resr = Math.max(t[--r], resr);\n        }\n        return Math.max(resl, resr);\n    }\n}\n\nclass RangeMin {\n    int start;\n    int n;\n    long[] t;\n\n    // [low, high] inclusive\n    public RangeMin(int low, int high) {\n        start = low;\n        n = high - low + 1;\n        t = new long[n * 2 + 2];\n        Arrays.fill(t, Long.MAX_VALUE);\n    }\n\n    public RangeMin(int low, int high, long defaultValue) {\n        start = low;\n        n = high - low + 1;\n        t = new long[n * 2 + 2];\n        Arrays.fill(t, defaultValue);\n    }\n\n    long get(int index) {\n        return t[index - start + n];\n    }\n\n    void set(int index, long value) {\n        index -= start;\n        for (t[index += n] = value; (index >>= 1) > 0; ) {\n            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);\n        }\n    }\n\n    // [l, r] inclusive\n    long getMin(int l, int r) {\n        l -= start;\n        r = (r + 1 - start); // make it as [l, r)\n        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);\n            if ((r & 1) != 0) resr = Math.min(t[--r], resr);\n        }\n        return Math.min(resl, resr);\n    }\n}\n\n\n// Including topological sort.\n// Tested by Leetcode 1203 and 1857\nclass Graph<E> {\n    Map<E, List<E>> adj = new HashMap<>();\n    List<E> emptyList = new ArrayList<>();\n\n    // NOTE: remember to call addNode() to add single nodes\n    public void addNode(E node) {\n        adj.computeIfAbsent(node, k -> new ArrayList<>());\n    }\n\n    // directed edge x -> y\n    public void link(E x, E y) {\n        adj.computeIfAbsent(x, k -> new ArrayList<>()).add(y);\n    }\n\n    public List<E> getChildren(E x) {\n        return adj.getOrDefault(x, emptyList);\n    }\n\n    public Set<E> getAllNodes() {\n        return adj.keySet();\n    }\n\n    private static final int TEMPORARY = 1;\n    private static final int PERMANENT = 2;\n\n    // x -> y means x should be processed before y\n    // The input is a directed graph.\n    // 1. return null, means there is a cycle inside the graph, or the input is\n    // invalid.\n    // 2. return List<Node> as the result.\n    public List<E> topologicalSort() {\n        Map<E, Integer> vst = new HashMap<>();\n        List<E> result = new ArrayList<>();\n        for (E x : getAllNodes()) {\n            if (!topologicalSort(x, vst, result)) {\n                return null;\n            }\n        }\n        Collections.reverse(result);\n        return result;\n    }\n\n    private boolean topologicalSort(E root, Map<E, Integer> vst, List<E> result) {\n        if (vst.getOrDefault(root, 0) == PERMANENT) {\n            return true;\n        }\n        if (vst.getOrDefault(root, 0) == TEMPORARY) { // found cycle\n            return false;\n        }\n\n        vst.put(root, TEMPORARY);\n        for (E child : getChildren(root)) {\n            if (!topologicalSort(child, vst, result)) {\n                return false;\n            }\n        }\n        result.add(root);\n        vst.put(root, PERMANENT);\n        return true;\n    }\n}\n\nclass GraphIntegerFaster {\n    public List<Integer>[] adj;\n\n    public GraphIntegerFaster(int n) {\n        adj = new List[n];\n        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();\n    }\n\n    // directed edge x -> y\n    public void link(int x, int y) {\n        adj[x].add(y);\n    }\n\n    public List<Integer> getChildren(int x) {\n        return adj[x];\n    }\n\n    private static final int TEMPORARY = 1;\n    private static final int PERMANENT = 2;\n\n    // x -> y means x should be processed before y\n    // The input is a directed graph.\n    // 1. return null, means there is a cycle inside the graph, or the input is\n    // invalid.\n    // 2. return List<Node> as the result.\n    public List<Integer> topologicalSort() {\n        //Map<E, Integer> vst = new HashMap<>();\n        int n = adj.length;\n        int[] vst = new int[n];\n        List<Integer> result = new ArrayList<>();\n        for (int x = 0; x < n; x++) {\n            if (!topologicalSort(x, vst, result)) {\n                return null;\n            }\n        }\n        Collections.reverse(result);\n        return result;\n    }\n\n    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {\n        if (vst[root] == PERMANENT) {\n            return true;\n        }\n        if (vst[root] == TEMPORARY) { // found cycle\n            return false;\n        }\n\n        vst[root] = TEMPORARY;\n        for (int child : getChildren(root)) {\n            if (!topologicalSort(child, vst, result)) {\n                return false;\n            }\n        }\n        result.add(root);\n        vst[root] = PERMANENT;\n        return true;\n    }\n}\n\nclass Dijkstra {\n    public static class Edge {\n        long to;\n        long w;\n\n        public Edge(long to, long w) {\n            this.to = to;\n            this.w = w;\n        }\n    }\n\n    public Map<Long, List<Edge>> adj = new HashMap<>();\n\n    public void link(long x, long y, long w) {\n        adj.computeIfAbsent(x, k -> new ArrayList<>()).add(new Edge(y, w));\n    }\n\n    public Map<Long, Long> shortestPath(long src) {\n        Map<Long, Long> dist = new HashMap<>();\n        Set<Long> vst = new HashSet<>();\n\n        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));\n        q.add(new Edge(src, 0L));\n        dist.put(src, 0L);\n\n        while (!q.isEmpty()) {\n            Edge cur = q.poll();\n            long u = cur.to;\n            if (vst.contains(u)) continue;\n            long w = cur.w;\n            vst.add(u);\n            if (adj.containsKey(u)) {\n                for (Edge e : adj.get(u)) {\n                    if (dist.getOrDefault(e.to, Long.MAX_VALUE) > w + e.w) {\n                        dist.put(e.to, w + e.w);\n                        q.add(new Edge(e.to, w + e.w));\n                    }\n                }\n            }\n        }\n        return dist;\n    }\n}\n\nclass DijkstraLongFaster {\n    public static class Edge {\n        int to;\n        long w;\n\n        public Edge(int to, long w) {\n            this.to = to;\n            this.w = w;\n        }\n    }\n\n    public static final long INF = Long.MAX_VALUE / 4;\n    public List<Edge>[] adj;\n\n    public DijkstraLongFaster(int n) {\n        this.adj = new List[n];\n        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();\n    }\n\n    public void link(int x, int y, long w) {\n        adj[x].add(new Edge(y, w));\n    }\n\n    public long[] shortestPath(int src) {\n        int n = adj.length;\n        long[] dist = new long[n];\n        boolean[] vst = new boolean[n];\n        Arrays.fill(dist, INF);\n\n        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));\n        q.add(new Edge(src, 0));\n        dist[src] = 0;\n\n        while (!q.isEmpty()) {\n            Edge cur = q.poll();\n            if (vst[cur.to]) continue;\n            int u = cur.to;\n            long w = cur.w;\n            vst[u] = true;\n\n            for (Edge e : adj[u]) {\n                if (!vst[e.to] && dist[e.to] > w + e.w) {\n                    dist[e.to] = w + e.w;\n                    q.add(new Edge(e.to, w + e.w));\n                }\n            }\n        }\n        return dist;\n    }\n\n    // NOTE: w of each edge must be the same.\n    public long[] bfs(int src) {\n        int n = adj.length;\n        long[] dist = new long[n];\n        boolean[] vst = new boolean[n];\n        Arrays.fill(dist, INF);\n\n        Queue<Integer> q = new ArrayDeque<>();\n        q.add(src);\n        dist[src] = 0;\n        vst[src] = true;\n\n        while (!q.isEmpty()) {\n            int u = q.poll();\n            long w = dist[u];\n            for (Edge e : adj[u]) {\n                if (!vst[e.to]) {\n                    dist[e.to] = w + e.w;\n                    vst[e.to] = true;\n                    q.add(e.to);\n                }\n            }\n        }\n        return dist;\n    }\n}\n\nclass TreapSet<E> {\n    private class Node {\n        E key;\n        int priority, count, total;\n        Node left, right, pnt;\n\n        public Node(E key, int priority, Node pnt) {\n            this.key = key;\n            this.priority = priority;\n            this.pnt = pnt;\n            this.count = 1;\n            this.total = 1;\n        }\n    }\n\n    private static final Random RANDOM = new Random();\n    private final Comparator<? super E> comparator;\n    private Node root;\n\n    public TreapSet(Comparator<? super E> comparator) {\n        this.comparator = comparator;\n    }\n\n    public boolean isEmpty() {\n        return root == null;\n    }\n\n    public void clear() {\n        root = null;\n    }\n\n    public int size() {\n        return root == null ? 0 : root.total;\n    }\n\n    private int leftRank(Node p) {\n        return p.left != null ? p.left.total : 0;\n    }\n\n    private int rightRank(Node p) {\n        return p.right != null ? p.right.total : 0;\n    }\n\n    private void rotateLeft(Node x) {\n        Node y = x.right;\n        if ((x.right = y.left) != null) y.left.pnt = x;\n        y.pnt = x.pnt;\n        if (x == root) root = y;\n        else if (x == x.pnt.left) x.pnt.left = y;\n        else x.pnt.right = y;\n        y.left = x;\n        x.pnt = y;\n        x.total = leftRank(x) + rightRank(x) + x.count;\n        y.total = leftRank(y) + rightRank(y) + y.count;\n    }\n\n    private void rotateRight(Node x) {\n        Node y = x.left;\n        if ((x.left = y.right) != null) y.right.pnt = x;\n        y.pnt = x.pnt;\n        if (x == root) root = y;\n        else if (x == x.pnt.right) x.pnt.right = y;\n        else x.pnt.left = y;\n        y.right = x;\n        x.pnt = y;\n        x.total = leftRank(x) + rightRank(x) + x.count;\n        y.total = leftRank(y) + rightRank(y) + y.count;\n    }\n\n    public void add(E key) {\n        if (root == null) {\n            root = new Node(key, RANDOM.nextInt(), null);\n            return;\n        }\n        Node x = root, p = null;\n        while (x != null) {\n            ++((p = x).total);\n            int cmp = comparator.compare(key, x.key);\n            if (cmp < 0) x = x.left;\n            else if (cmp > 0) x = x.right;\n            else {\n                ++(x.count);\n                return;\n            }\n        }\n\n        x = new Node(key, RANDOM.nextInt(), p);\n        if (comparator.compare(key, p.key) < 0) p.left = x;\n        else p.right = x;\n        while ((p = x.pnt) != null && p.priority < x.priority) {\n            if (p.left == x) rotateRight(p);\n            else rotateLeft(p);\n        }\n    }\n\n    public void remove(E key) {\n        Node x = root, p = null;\n        while (x != null) {\n            --(x.total);\n            int cmp = comparator.compare(key, x.key);\n            if (cmp < 0) x = x.left;\n            else if (cmp > 0) x = x.right;\n            else {\n                if (--(x.count) > 0) return;\n                break;\n            }\n        }\n        if (x == null) return;\n        while (x.left != null || x.right != null) {\n            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {\n                rotateLeft(x);\n            } else {\n                rotateRight(x);\n            }\n        }\n        if ((p = x.pnt) != null) {\n            if (p.left == x) p.left = null;\n            else p.right = null;\n        } else {\n            root = null;\n        }\n        // delete x;\n    }\n\n    // number of elements smaller than key\n    public int lowerCount(E key) {\n        int sum = 0;\n        Node x = root;\n        while (x != null) {\n            int cmp = comparator.compare(key, x.key);\n            if (cmp < 0) x = x.left;\n            else if (cmp > 0) {\n                sum += leftRank(x) + x.count;\n                x = x.right;\n            } else {\n                sum += leftRank(x);\n                break;\n            }\n        }\n        return sum;\n    }\n\n    // number of elements larger than key\n    public int higherCount(E key) {\n        //return size() - lowerCount(key) - count(key);\n        int sum = 0;\n        Node x = root;\n        while (x != null) {\n            int cmp = comparator.compare(key, x.key);\n            if (cmp > 0) x = x.right;\n            else if (cmp < 0) {\n                sum += rightRank(x) + x.count;\n                x = x.left;\n            } else {\n                sum += rightRank(x);\n                break;\n            }\n        }\n        return sum;\n    }\n\n    public int index(E key) {\n        return lowerCount(key);\n    }\n\n    public E get(int index) // index = 0 ... size - 1\n    {\n        Node p = root;\n        ++index;\n        while (true) {\n            int t = leftRank(p);\n            if (index <= t) p = p.left;\n            else {\n                if ((index -= t + p.count) <= 0) break;\n                p = p.right;\n            }\n        }\n        return p.key;\n    }\n\n    public int count(E key) {\n        Node x = root;\n        while (x != null) {\n            int cmp = comparator.compare(key, x.key);\n            if (cmp < 0) x = x.left;\n            else if (cmp > 0) {\n                x = x.right;\n            } else {\n                return x.count;\n            }\n        }\n        return 0;\n    }\n\n    public E first() {\n        if (root == null) return null;\n        Node x = root;\n        while (x.left != null) {\n            x = x.left;\n        }\n        return x.key;\n    }\n\n    public E last() {\n        if (root == null) return null;\n        Node x = root;\n        while (x.right != null) {\n            x = x.right;\n        }\n        return x.key;\n    }\n\n    public boolean contains(E key) {\n        return count(key) > 0;\n    }\n\n    public E ceiling(E key) {\n        int id = lowerCount(key);\n        return id >= size() ? null : get(id);\n    }\n\n    public E floor(E key) {\n        int id = size() - higherCount(key) - 1;\n        return id < 0 ? null : get(id);\n    }\n\n    public E lower(E key) {\n        int id = lowerCount(key) - 1;\n        return id < 0 ? null : get(id);\n    }\n\n    public E higher(E key) {\n        int id = size() - higherCount(key);\n        return id >= size() ? null : get(id);\n    }\n\n    // return the first index whose value >= target\n    // if this value doesn't exist, return index = size()\n    public int lowerBound(E target) {\n        return lowerCount(target);\n    }\n\n    // return the first index whose value > target\n    // if this value doesn't exist, return index = size()\n    public int upperBound(E target) {\n        return size() - higherCount(target);\n    }\n\n    public List<E> keys() {\n        List<E> list = new ArrayList<>();\n        inorder(root, list);\n        return list;\n    }\n\n    private void inorder(Node x, List<E> list) {\n        if (x == null) return;\n        inorder(x.left, list);\n        list.add(x.key);\n        inorder(x.right, list);\n    }\n}\n\nclass ArraySum {\n    long[] sum;\n    int n;\n\n    // nums index starts from 0 to nums.length - 1;\n    public ArraySum(int[] nums) {\n        n = nums.length;\n        sum = new long[nums.length + 1];\n        for (int i = 1; i <= nums.length; i++) {\n            sum[i] = sum[i - 1] + nums[i - 1];\n        }\n    }\n\n    public ArraySum(long[] nums) {\n        n = nums.length;\n        sum = new long[nums.length + 1];\n        for (int i = 1; i <= nums.length; i++) {\n            sum[i] = sum[i - 1] + nums[i - 1];\n        }\n    }\n\n    // [l, r], index starts from 0\n    public long getSum(int l, int r) {\n        // error handling\n        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;\n        return sum[r + 1] - sum[l];\n    }\n}\n\nclass TwoDArraySum {\n    int[][] sum;\n    int m, n;\n\n    // nums index starts from 0\n    public TwoDArraySum(final int[][] nums) {\n        m = nums.length;\n        n = nums[0].length;\n        sum = new int[m + 1][n + 1];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];\n            }\n        }\n    }\n\n    // [(x1, y1), (x2, y2)], index starts from 0\n    // x1 <= x2 and y1 <= y2\n    public int getSum(int x1, int y1, int x2, int y2) {\n        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)\n            return 0;\n        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];\n    }\n}\n\nclass ArrayUtils {\n    static void fill(int[] array, int defaultValue) {\n        Arrays.fill(array, defaultValue);\n    }\n\n    static void fill(int[][] array, int defaultValue) {\n        for (int[] a1 : array) {\n            Arrays.fill(a1, defaultValue);\n        }\n    }\n\n    static void fill(int[][][] array, int defaultValue) {\n        for (int[][] a2 : array) {\n            for (int[] a1 : a2) {\n                Arrays.fill(a1, defaultValue);\n            }\n        }\n    }\n\n    static void fill(int[][][][] array, int defaultValue) {\n        for (int[][][] a3 : array) {\n            for (int[][] a2 : a3) {\n                for (int[] a1 : a2) {\n                    Arrays.fill(a1, defaultValue);\n                }\n            }\n        }\n    }\n\n    static void fill(int[][][][][] array, int defaultValue) {\n        for (int[][][][] a4 : array) {\n            for (int[][][] a3 : a4) {\n                for (int[][] a2 : a3) {\n                    for (int[] a1 : a2) {\n                        Arrays.fill(a1, defaultValue);\n                    }\n                }\n            }\n        }\n    }\n\n    static void fill(int[][][][][][] array, int defaultValue) {\n        for (int[][][][][] a5 : array) {\n            for (int[][][][] a4 : a5) {\n                for (int[][][] a3 : a4) {\n                    for (int[][] a2 : a3) {\n                        for (int[] a1 : a2) {\n                            Arrays.fill(a1, defaultValue);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    static void fill(long[] array, long defaultValue) {\n        Arrays.fill(array, defaultValue);\n    }\n\n    static void fill(long[][] array, long defaultValue) {\n        for (long[] a1 : array) {\n            Arrays.fill(a1, defaultValue);\n        }\n    }\n\n    static void fill(long[][][] array, long defaultValue) {\n        for (long[][] a2 : array) {\n            for (long[] a1 : a2) {\n                Arrays.fill(a1, defaultValue);\n            }\n        }\n    }\n\n    static void fill(long[][][][] array, long defaultValue) {\n        for (long[][][] a3 : array) {\n            for (long[][] a2 : a3) {\n                for (long[] a1 : a2) {\n                    Arrays.fill(a1, defaultValue);\n                }\n            }\n        }\n    }\n\n    static void fill(long[][][][][] array, long defaultValue) {\n        for (long[][][][] a4 : array) {\n            for (long[][][] a3 : a4) {\n                for (long[][] a2 : a3) {\n                    for (long[] a1 : a2) {\n                        Arrays.fill(a1, defaultValue);\n                    }\n                }\n            }\n        }\n    }\n\n    static void fill(long[][][][][][] array, long defaultValue) {\n        for (long[][][][][] a5 : array) {\n            for (long[][][][] a4 : a5) {\n                for (long[][][] a3 : a4) {\n                    for (long[][] a2 : a3) {\n                        for (long[] a1 : a2) {\n                            Arrays.fill(a1, defaultValue);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nclass DoubleUtils {\n    private static final double EPS = 1e-8;\n\n    public static int compare(double a, double b) {\n        if (a - b > EPS) return 1;\n        else if (a - b < -EPS) return -1;\n        else return 0;\n    }\n\n    public static boolean isInteger(double a) {\n        return compare(floor(a), a) == 0;\n    }\n\n    public static double floor(double a) {\n        return Math.floor(a + EPS);\n    }\n\n    public static double ceil(double a) {\n        return Math.ceil(a - EPS);\n    }\n}\n\n// Better to use this when length of string >= 2^11\nclass StringHash {\n    static class SingleStringHash {\n        long[] h;\n        long[] pow;\n        final long SEED;\n        final long MOD;\n\n        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;\n            this.SEED = SEED;\n            this.MOD = MOD;\n            int n = s.length();\n            h = new long[n + 1];\n            pow = new long[n + 1];\n            pow[0] = 1;\n            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;\n            //h[i] = hash[s[0...i - 1]]\n            h[0] = 0;\n            for (int i = 1; i <= n; i++) {\n                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;\n            }\n        }\n\n        // hash[s[l....r]]\n        public long hash(int l, int r) {\n            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;\n            return ret >= 0 ? ret : ret + MOD;\n        }\n    }\n\n    private SingleStringHash hash1, hash2;\n    static final long SEED1 = 31L, SEED2 = 131L;\n    static final long MOD = 1_000_000_007L;\n\n    public StringHash(String s) {\n        hash1 = new SingleStringHash(s, SEED1, MOD);\n        hash2 = new SingleStringHash(s, SEED2, MOD);\n    }\n\n    public long hash(int l, int r) {\n        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);\n    }\n\n    public static long hashCode(String s) {\n        long h1 = 0, h2 = 0;\n        for (int i = 0; i < s.length(); i++) {\n            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;\n            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;\n        }\n        return (h1 << 32) | (h2 << 32 >>> 32);\n    }\n\n    public static long hashCode(char[] s) {\n        long h1 = 0, h2 = 0;\n        for (int i = 0; i < s.length; i++) {\n            h1 = (h1 * SEED1 + s[i]) % MOD;\n            h2 = (h2 * SEED2 + s[i]) % MOD;\n        }\n        return (h1 << 32) | (h2 << 32 >>> 32);\n    }\n}\n\nclass IntegerArrayHash {\n    static class SingleIntegerArrayHash {\n        long[] h;\n        long[] pow;\n        final long SEED;\n        final long MOD;\n\n        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;\n            this.SEED = SEED;\n            this.MOD = MOD;\n            int n = s.length;\n            h = new long[n + 1];\n            pow = new long[n + 1];\n            pow[0] = 1;\n            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;\n            //h[i] = hash[s[0...i - 1]]\n            h[0] = 0;\n            for (int i = 1; i <= n; i++) {\n                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;\n                if (h[i] < 0) h[i] += MOD;\n            }\n        }\n\n        // hash[s[l....r]]\n        public long hash(int l, int r) {\n            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;\n            return ret >= 0 ? ret : ret + MOD;\n        }\n    }\n\n    private SingleIntegerArrayHash hash1, hash2;\n    static final long SEED1 = 31L, SEED2 = 131L;\n    static final long MOD = 1_000_000_007L; // or 1_000_000_123L\n\n    public IntegerArrayHash(int[] s) {\n        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);\n        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);\n    }\n\n    public long hash(int l, int r) {\n        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);\n    }\n\n    public static long hashCode(int[] s) {\n        long h1 = 0, h2 = 0;\n        for (int i = 0; i < s.length; i++) {\n            h1 = (h1 * SEED1 + s[i]) % MOD;\n            if (h1 < 0) h1 += MOD;\n            h2 = (h2 * SEED2 + s[i]) % MOD;\n            if (h2 < 0) h2 += MOD;\n        }\n        return (h1 << 32) | (h2 << 32 >>> 32);\n    }\n\n    public static long hashCode(List<Integer> s) {\n        long h1 = 0, h2 = 0;\n        for (int i = 0; i < s.size(); i++) {\n            h1 = (h1 * SEED1 + s.get(i)) % MOD;\n            if (h1 < 0) h1 += MOD;\n            h2 = (h2 * SEED2 + s.get(i)) % MOD;\n            if (h2 < 0) h2 += MOD;\n        }\n        return (h1 << 32) | (h2 << 32 >>> 32);\n    }\n}\n\nclass RMQ { // NOTE!!! query return index, not value\n    // tested by LC 1438,239\n    final long[] a; // input data array copy\n    int[][] d;\n\n    int[] log2;\n    boolean useMax;\n\n    private static long[] intArrayToLongArray(int[] nums) {\n        long[] ret = new long[nums.length];\n        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];\n        return ret;\n    }\n\n    // useMax == true means RMQMax\n    public RMQ(int[] input, boolean useMax) {\n        this(intArrayToLongArray(input), useMax);\n    }\n\n    public RMQ(long[] input, boolean useMax) {\n        int n = input.length;\n        this.a = input;\n        this.log2 = Utils.preprocessLog2(n);\n        this.useMax = useMax;\n        this.d = new int[log2[n] + 1][n];\n        for (int i = 0; i < n; i++) d[0][i] = i;\n        for (int j = 1; (1 << j) <= n; j++)\n            for (int i = 0; i + (1 << j) <= n; i++)\n                if (useMax) {\n                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];\n                } else {\n                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];\n                }\n    }\n\n    // i <= j, and index starts from 0.\n    public int query(int i, int j) { // NOTE!!! return index, not value\n        int k = log2[j - i + 1];\n        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];\n        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];\n    }\n}\n\n// Tested by 2827\n// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397\nclass DigitDP {\n    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info\n    static final long UNSET = -1;\n    // dp[isStart][hasLimit][pos] | [odd][even][r]\n    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific\n    long[][][][][][] dp;\n    int K;\n\n    public long digitDP(long num, int k) {\n        String numString = String.valueOf(num); // TODO\n        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];\n        this.K = k;\n\n        if (ENABLE_DEBUG_MODE) System.out.println(\"num = \" + numString);\n        ArrayUtils.fill(dp, UNSET);\n        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);\n        if (ENABLE_DEBUG_MODE) System.out.println(\"---------------------\\n\");\n        return ans;\n    }\n\n    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {\n        if (pos == s.length()) {\n            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO\n            if (r == 0 && odd == even) { // TODO\n                if (ENABLE_DEBUG_MODE) System.out.println(\"result = \" + curResult);\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];\n\n        int start = 0;\n        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not\n\n        long ans = 0;\n        for (int digit = start; digit <= end; digit++) {\n            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros\n                // [0, 999..9]\n                // [0\uff0c 10^(len(s) - pos - 1) - 1]\n                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);\n                continue;\n            }\n            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;\n\n            int newOdd = odd + (digit % 2); // TODO\n            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO\n            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;\n\n            if (ENABLE_DEBUG_MODE) curResult.append(digit);\n            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);\n            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);\n\n        }\n        return dp[isStart][hasLimit][pos][odd][even][r] = ans;\n    }\n}\n\nclass Printer {\n    static boolean ENABLE_LOCAL_PRINT = false;\n\n    static void println(String x) {\n        if (!ENABLE_LOCAL_PRINT) return; // do nothing\n        System.out.println(x);\n    }\n\n    static void printf(String format, Object... args) {\n        if (!ENABLE_LOCAL_PRINT) return; // do nothing\n        System.out.printf(format, args);\n    }\n}\n\n\npublic class Solution {\n    private static final int INF = 1_000_000_001;\n    private static final long MOD = 1_000_000_007L;\n\n    private static final int UNSET = -131;\n    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left\n    private static final int[] DY = {0, 1, 0, -1};\n    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};\n    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};\n    private static final double EPS = 1e-8;\n    private static final long SEED = 31L;\n\n    static class DynamicSegmentTreeRangeSum {\n        class TreeNode {\n            TreeNode left, right;\n            long sum;\n        }\n\n        int[] values;\n\n        private final TreeNode root;\n        private final long L, R;\n\n        public DynamicSegmentTreeRangeSum(int[] input) {\n            this.values = input;\n            L = 0;\n            R = input.length - 1;\n            root = new TreeNode();\n            build(root, (int) L, (int) R, input);\n        }\n\n        boolean isPeak(long index, long l, long r) {\n            if (index - 1 >= l && index + 1 <= r && values[(int) index] > values[(int) index - 1] && values[(int) index] > values[(int) index + 1]) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n        private void build(TreeNode root, int l, int r, int[] input) {\n            if (l == r) {\n                root.sum = 0;\n                return;\n            }\n            int m = (l + r) >> 1;\n            root.left = new TreeNode();\n            root.right = new TreeNode();\n            build(root.left, l, m, input);\n            build(root.right, m + 1, r, input);\n\n            // merge\n\n            root.sum = root.left.sum + root.right.sum;\n            if (isPeak(m, l, r)) root.sum++;\n            if (isPeak(m + 1, l, r)) root.sum++;\n        }\n\n\n        private long sum(TreeNode node) {\n            return node == null ? 0L : node.sum;\n        }\n\n        public void set(long index, long value) {\n            set(root, L, R, index, value);\n        }\n\n        private void set(TreeNode root, long L, long R, long index, long value) {\n            if (index < L || R < index) return;\n            //System.out.println(\"outside set values = \" + Arrays.toString(values));\n            if (L == R) {\n\n                root.sum = 0;\n                values[(int) index] = (int) value;\n                //System.out.println(\"set values = \" + Arrays.toString(values));\n                return;\n            }\n            long M = L + ((R - L) >> 1);\n            if (index <= M) {\n                set(root.left, L, M, index, value);\n            } else {\n                set(root.right, M + 1, R, index, value);\n            }\n            root.sum = root.left.sum + root.right.sum;\n            if (isPeak((int) M, (int)L, (int) R)) root.sum++;\n            if (isPeak((int) M + 1, (int) L, (int) R)) root.sum++;\n        }\n\n        // Sum[queryL...queryR] inclusive\n        public long query(long queryL, long queryR) {\n            return query(root, L, R, queryL, queryR);\n        }\n\n        // [queryL, queryR] is range of query, [L, R] are range of TreeNode.\n        private long query(TreeNode root, long L, long R, long queryL, long queryR) {\n            if (root == null || queryL > R || queryR < L) return 0L;\n            if (queryL <= L && R <= queryR) {\n                long ret = root.sum;\n                if (isPeak(L, queryL, queryR)) ret++;\n                if (R != L && isPeak(R, queryL, queryR)) ret++;\n                //System.out.println(\"values = \" + Arrays.toString(values));\n                //System.out.println(\"L = \" + L + \" R = \" + R + \" ret = \" + ret);\n                return ret;\n            }\n            long M = L + ((R - L) >> 1);\n            return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);\n        }\n    }\n\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        DynamicSegmentTreeRangeSum tree = new DynamicSegmentTreeRangeSum(nums);\n\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            int type = queries[i][0];\n            if (type == 1) {\n                int l = queries[i][1];\n                int r = queries[i][2];\n                list.add((int) tree.query(l, r));\n            } else {\n                int index = queries[i][1];\n                int value = queries[i][2];\n                tree.set(index, value);\n            }\n        }\n        return list;\n    }\n\n    public static void main(String[] args) throws Exception {\n        long startTime = System.currentTimeMillis();\n        Printer.ENABLE_LOCAL_PRINT = true;\n        /* ------------------------------------------------------- */\n        /* ------------------------------------------------------- */\n        /* ------------------------------------------------------- */\n\n\n\n        /* ------------------------------------------------------- */\n        /* ------------------------------------------------------- */\n        /* ------------------------------------------------------- */\n        System.out.println((System.currentTimeMillis() - startTime) + \"ms\");\n    }\n}",
    "submit_ts": 1718507345.0
}