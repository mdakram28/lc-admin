{
    "username": "salyu",
    "submission": "constexpr int INV = numeric_limits<int>::max();\n\nstruct trie_t {\n    array<trie_t*, 26> next{};\n    int cost{ INV };\n};\n\nnamespace {\n    vector<unique_ptr<trie_t[]>> buffers;\n    trie_t* current_p;\n    constexpr int SIZE = 1024;\n    int current_size = SIZE;\n    trie_t* alloc() {\n        if (current_size == SIZE) {\n            current_p = buffers.emplace_back(make_unique<trie_t[]>(SIZE)).get();\n            current_size = 0;\n        }\n        return &current_p[current_size++];\n    }\n}\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        trie_t root;\n        int n = words.size(), m = target.size();\n        for (int i = 0; i < n; ++i) {\n            auto p = &root;\n            for (char c : words[i]) {\n                auto & q = p->next[c - 'a'];\n                if (!q) {\n                    q = alloc();\n                }\n                p = q;\n            }\n            p->cost = min(p->cost, costs[i]);\n        }\n        \n        vector<int> memo(m + 1);\n        \n        for (int i = m - 1; i >= 0; --i) {\n            auto p = &root;\n            int res = INV;\n            for (int j = i; j < m; ++j) {\n                p = p->next[target[j] - 'a'];\n                if (!p) {\n                    break;\n                }\n                if (p->cost != INV && memo[j + 1] != INV) {\n                    res = min(res, memo[j + 1] + p->cost);\n                }\n            }\n            memo[i] = res;\n        }\n        \n        int res = memo[0];\n        return res == INV ? -1 : res;\n    }\n};",
    "submit_ts": "1720321501",
    "subm_id": "1312324539"
}