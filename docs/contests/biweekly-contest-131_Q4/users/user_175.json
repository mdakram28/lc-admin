{
    "username": "night_732",
    "submission": "\nconst long long maxn = 50005;\n\n\n#define L(id) id<<1\n#define R(id) id<<1|1\n#define MID(l,r) l+r>>1\n\nstruct node{\n    long long l,r,v,lazy;\n} tree[maxn<<2];\nvoid push_down(long long id) {\n    long long t = tree[id].lazy;\n    if(t == 0){\n        return;\n    }\n    tree[L(id)].lazy = t; \n    tree[R(id)].lazy = t; \n\n    tree[L(id)].v = t; \n    tree[R(id)].v = t; \n    tree[id].lazy = 0;\n}\nvoid build(long long id,long long l1,long long r1){\n    tree[id].l = l1,tree[id].r = r1;\n    tree[id].v = 0;\n    if(l1 == r1){\n        return;\n    }\n    long long mid = MID(l1,r1);\n    build(L(id),l1,mid);\n    build(R(id),mid+1,r1);\n    tree[id].v = max(tree[L(id)].v, tree[R(id)].v);\n}\nlong long que(long long id,long long l1,long long r1){\n    if(l1<=tree[id].l&&r1>=tree[id].r){\n        return tree[id].v;\n    }\n    push_down(id);\n    long long sum = 0;\n    if(l1<=tree[L(id)].r){\n        sum=max(sum, que(L(id),l1,r1));\n    }\n    if(r1>=tree[R(id)].l){\n        sum=max(sum, que(R(id),l1,r1));\n    }\n    return sum;\n}\nvoid add(long long id, long long l1, long long r1, long long k) {\n    if(l1 <= tree[id].l && r1 >= tree[id].r) {\n        tree[id].v = k;\n        tree[id].lazy = k;\n        return;\n    }\n    push_down(id);\n    if(l1 <= tree[L(id)].r) {\n        add(L(id), l1, r1, k);\n    } \n    if(r1 >= tree[R(id)].l) {\n        add(R(id), l1, r1, k);\n    } \n    tree[id].v = max(tree[L(id)].v, tree[R(id)].v);\n}\n\nclass Solution {\npublic:\n\n    \n    vector<bool> getResults(vector<vector<int>>& queries) {\n        multiset<int> st;\n        st.insert(0);\n        build(1,1,50004);\n        vector<bool> ans;\n        \n        auto add_node = [&](int x) {\n            auto k = st.upper_bound(x);\n            if (k != st.end()) {\n                add(1, x + 1, *k, *k - x);\n            }\n            st.insert(x);\n            k = st.lower_bound(x);\n            --k;\n            add(1, *k + 1, x, x - *k);\n        };\n        \n        auto del_node = [&](int x) {\n            int r = x;\n            auto k = st.upper_bound(x);\n            if (k != st.end()) {\n                r = *k;\n            }\n            st.erase(x);\n            k = st.upper_bound(x);\n            --k;\n            int l = *k;\n            add(1, l + 1, r, r - l);\n        };\n        \n        for(auto &q : queries) {\n            int t = q[0];\n            if (t == 1) {\n                int x = q[1];\n                add_node(x);\n            } else {\n                int x = q[1], sz = q[2], del = 0;\n                if (!st.count(x)) {\n                    del = 1;\n                    add_node(x);\n                }\n                int mx = que(1, 1, x);\n                if ((mx == 0 && sz <= x) || mx >= sz) {\n                    ans.push_back(true);\n                } else {\n                    ans.push_back(false);\n                }   \n                if (del) {\n                    del_node(x);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716650176.0
}