{
    "username": "MeetBrahmbhatt",
    "submission": "template<typename node, typename update>\nstruct segtree {\n    vector<node> t;\n    vector<update> upds;\n    vector<bool> lazy;\n    int size;\n\n    void init(int n) {\n        size = 1;\n        while (size < n) size *= 2;\n        t.assign(2 * size, node());\n        upds.assign(2 * size, update());\n        lazy.assign(2 * size, 0);\n    }\n\n    inline void propogate(int x, int lx, int rx) {\n        if (lazy[x]) {\n            int mid = (lx + rx) / 2;\n            apply(2 * x + 1, upds[x], lx, mid);\n            apply(2 * x + 2, upds[x], mid + 1, rx);\n            lazy[x] = 0;\n            upds[x] = update();\n        }\n    }\n\n    inline void apply(int x, update &val, int lx, int rx) {\n        if (lx != rx) {\n            lazy[x] = 1;\n            upds[x].combine(val, lx, rx);\n        }\n        val.apply(t[x], lx, rx);\n    }\n\n    template<typename T>\n    void build(T &v, int x, int lx, int rx) {\n        if (rx == lx) {\n            if (lx < (int) v.size()) t[x] = v[lx];\n            return;\n        }\n        int mid = (lx + rx) / 2;\n        build(v, 2 * x + 1, lx, mid);\n        build(v, 2 * x + 2, mid + 1, rx);\n        t[x].merge(t[2 * x + 1], t[2 * x + 2]);\n    }\n\n    node query(int l, int r, int x, int lx, int rx) {\n        if (lx > r || rx < l) return node();\n        if (l <= lx and rx <= r) return t[x];\n        propogate(x, lx, rx);\n        int mid = (lx + rx) / 2;\n        node L, R, ans;\n        L = query(l, r, 2 * x + 1, lx, mid);\n        R = query(l, r, 2 * x + 2, mid + 1, rx);\n        ans.merge(L, R);\n        return ans;\n    }\n\n    void rupd(int l, int r, update &v, int x, int lx, int rx) {\n        if (lx > r || rx < l) return;\n        if (l <= lx and rx <= r) {\n            apply(x, v, lx, rx); return;\n        }\n        propogate(x, lx, rx);\n        int mid = (lx + rx) / 2;\n        rupd(l, r, v, 2 * x + 1, lx, mid);\n        rupd(l, r, v, 2 * x + 2, mid + 1, rx);\n        t[x].merge(t[2 * x + 1], t[2 * x + 2]);\n    }\n    \n    \n    int find_first(int l, int val, int x, int lx, int rx, node &prev) {\n        if (rx < l) return size;\n        if (l <= lx) {\n            node curr;\n            curr.merge(prev, t[x]);\n            if (!curr.check(val)) {\n                swap(prev, curr);\n                return size;\n            }\n            if (lx == rx) return lx;\n        }\n        propogate(x, lx, rx);\n        int mid = (lx + rx) / 2;\n        int ans = find_first(l, val, 2 * x + 1, lx, mid, prev);\n        if (ans != size) return ans;\n        return find_first(l, val, 2 * x + 2, mid + 1, rx, prev);\n    }\n\n    int find_last(int r, int val, int x, int lx, int rx, node &prev) {\n        if (r < lx) return -1ll;\n        if (rx <= r) {\n            node curr;\n            curr.merge(prev, t[x]);\n            if (!curr.check(val)) {\n                swap(prev, curr);\n                return -1ll;\n            }\n            if (lx == rx) return lx;\n        }\n        propogate(x, lx, rx);\n        int mid = (lx + rx) / 2;\n        int ans = find_last(r, val, 2 * x + 2, mid + 1, rx, prev);\n        if (ans == -1) ans = find_last(r, val, 2 * x + 1, lx, mid, prev);\n        return ans;\n    }\n\n    template<typename T>\n    void build(T &v) {\n        build(v, 0, 0, size - 1);\n    }\n\n    node query(int l, int r) {\n        return query(l, r, 0, 0, size - 1);\n    }\n\n    void rupd(int l, int r, update val) {\n        rupd(l, r, val, 0, 0, size - 1);\n    }\n\n    int find_first(int l, int val) {\n        node prev = node();\n        return find_first(l, val, 0, 0, size - 1, prev);\n    }\n\n    int find_last(int r, int val) {\n        node prev = node();\n        return find_last(r, val, 0, 0, size - 1, prev);\n    }\n};\n\nstruct node {\n    long long sum00, sum01, sum10, sum11;\n    node() : node(-1) {}\n    node(int val) {\n        sum11 = max(0, val);\n        sum01 = sum10 = sum00 = 0;\n    }\n    inline void merge(node &l, node &r) {\n        sum11 = max({l.sum10 + r.sum01, l.sum11 + r.sum01, l.sum10 + r.sum11});\n        sum10 = max({l.sum10 + r.sum00, l.sum11 + r.sum00, l.sum10 + r.sum10});\n        sum01 = max({l.sum01 + r.sum01, l.sum00 + r.sum01, l.sum00 + r.sum11});\n        sum00 = max({l.sum00 + r.sum10, l.sum01 + r.sum00, l.sum00 + r.sum00});\n    }\n    bool check(int x) {\n        return false;\n    }\n};\n\nstruct update {\n    int v = 0;\n    update() : update(0) {}\n    update(int val) {\n        v = val;\n    }\n    inline void combine(update &other, int l, int r) {\n\n    }\n    inline void apply(node &x, int l, int r) {\n        x = node(v);\n    }\n};\n\nconstexpr int MOD = 1e9 + 7;\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& v, vector<vector<int>>& Q) {\n        int n = (int) v.size();\n        \n        segtree<node, update> st;\n        st.init(n);\n        st.build(v);\n        \n        long long ans = 0;\n        for (auto q : Q) {\n            int pos = q[0];\n            int val = q[1];\n            \n            st.rupd(pos, pos, val);\n            node res = st.query(0, n - 1);\n            \n            ans += max({res.sum00, res.sum01, res.sum10, res.sum11});\n            ans %= MOD;\n        }\n        return ans % MOD;\n    }\n};",
    "submit_ts": 1716692777.0
}