{
    "username": "\u5495\u565c\u5495\u565c\u602a\u2714",
    "submission": "fmax = lambda x, y: x if x > y else y\nfmin = lambda x, y: x if x < y else y\nclass ZKW:\n    # n = 1\n    # size = 1\n    # log = 2\n    # d = [0]\n    # op = None\n    # e = 10 ** 15\n    \"\"\"\u81ea\u4f4e\u5411\u4e0a\u975e\u9012\u5f52\u5199\u6cd5\u7ebf\u6bb5\u6811\uff0c0_indexed\n    tmx = ZKW(pre, max, -2 ** 61)\n    \"\"\"\n    __slots__ = ('n', 'op', 'e', 'log', 'size', 'd')\n\n    def __init__(self, V, OP, E):\n        \"\"\"\n        V: \u539f\u6570\u7ec4\n        OP: \u64cd\u4f5c:max,min,sum\n        E: \u6bcf\u4e2a\u5143\u7d20\u9ed8\u8ba4\u503c\n        \"\"\"\n        self.n = len(V)\n        self.op = OP\n        self.e = E\n        self.log = (self.n - 1).bit_length()\n        self.size = 1 << self.log\n        self.d = [E for i in range(2 * self.size)]\n        for i in range(self.n):\n            self.d[self.size + i] = V[i]\n        for i in range(self.size - 1, 0, -1):\n            self.update(i)\n\n    def set(self, p, x):\n        # assert 0 <= p and p < self.n\n        update = self.update\n        p += self.size\n        self.d[p] = x\n        for i in range(1, self.log + 1):\n            update(p >> i)\n\n    def get(self, p):\n        # assert 0 <= p and p < self.n\n        return self.d[p + self.size]\n\n    def query(self, l, r):  # [l,r)\u5de6\u95ed\u53f3\u5f00\n        # assert 0 <= l and l <= r and r <= self.n\n        sml, smr, op, d = self.e, self.e, self.op, self.d\n\n        l += self.size\n        r += self.size\n\n        while l < r:\n            if l & 1:\n                sml = op(sml, d[l])\n                l += 1\n            if r & 1:\n                smr = op(d[r - 1], smr)\n                r -= 1\n            l >>= 1\n            r >>= 1\n        return self.op(sml, smr)\n\n    def all_query(self):\n        return self.d[1]\n\n    def max_right(self, l, f):\n        \"\"\"\u8fd4\u56del\u53f3\u4fa7\u7b2c\u4e00\u4e2a\u4e0d\u6ee1\u8db3f\u7684\u4f4d\u7f6e\"\"\"\n        # assert 0 <= l and l <= self.n\n        # assert f(self.e)\n        if l == self.n:\n            return self.n\n        l += self.size\n\n        sm, op, d, size = self.e, self.op, self.d, self.size\n        while True:\n            while l % 2 == 0:\n                l >>= 1\n            if not (f(op(sm, d[l]))):\n                while l < size:\n                    l = 2 * l\n                    if f(op(sm, d[l])):\n                        sm = op(sm, d[l])\n                        l += 1\n                return l - size\n            sm = op(sm, d[l])\n            l += 1\n            if (l & -l) == l:\n                break\n        return self.n\n\n    def min_left(self, r, f):\n        \"\"\"\u8fd4\u56der\u5de6\u4fa7\u8fde\u7eed\u6ee1\u8db3f\u7684\u6700\u8fdc\u4f4d\u7f6e\u7684\u4f4d\u7f6e\"\"\"\n        # assert 0 <= r and r < self.n\n        # assert f(self.e)\n        if r == 0:\n            return 0\n        r += self.size\n        sm, op, d, size = self.e, self.op, self.d, self.size\n\n        while True:\n            r -= 1\n            while r > 1 and (r % 2):\n                r >>= 1\n            if not (f(op(d[r], sm))):\n                while r < size:\n                    r = (2 * r + 1)\n                    if f(op(d[r], sm)):\n                        sm = op(d[r], sm)\n                        r -= 1\n                return r + 1 - size\n            sm = op(d[r], sm)\n            if (r & -r) == r:\n                break\n        return 0\n\n    def update(self, k):\n        self.d[k] = self.op(self.d[2 * k], self.d[2 * k + 1])\n\n    def __str__(self):\n        return str([self.get(i) for i in range(self.n)])\n\n\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_value = -3 * 10**9\n        result = []\n\n        for row in board:\n            top1, top2, top3 = -3 * 10**9, -3 * 10**9, -3 * 10**9\n            idx1, idx2, idx3 = -1, -1, -1\n            \n            for c in range(n):\n                value = row[c]\n                if value > top1:\n                    top3, idx3 = top2, idx2\n                    top2, idx2 = top1, idx1\n                    top1, idx1 = value, c\n                elif value > top2:\n                    top3, idx3 = top2, idx2\n                    top2, idx2 = value, c\n                elif value > top3:\n                    top3, idx3 = value, c\n            \n            result.append([(top1, idx1), (top2, idx2), (top3, idx3)])\n        \n        max_cols = [-inf] * (n + 1)\n        for e, c in result[0]:\n            max_cols[c] = e\n        zkw = ZKW(max_cols, max, -inf)\n        #\u679a\u4e3e\u540e2\u884c\n        for r1 in range(1, m):\n            for r2 in range(r1 + 1, m):\n                for e1, j1 in result[r1]:\n                    for e2, j2 in result[r2]:\n                        if j1 == j2: continue\n                        #\u8003\u8651\u5982\u4f55O(1)\u627e\u5230\u524d\u9762\u65e2\u4e0d\u7b49\u4e8ej1\u53c8\u4e0d\u7b49\u4e8ej2\u7684\u5217\u91cc\u9762\u7684\u6700\u5927\u503c\n                        l, r = fmin(j1, j2), fmax(j1, j2)\n                        max_pre = max(zkw.query(0, l), zkw.query(l + 1, r), zkw.query(r + 1, n))\n                        max_value = max(max_value, max_pre + e1 + e2)\n            for e, c in result[r1]:\n                max_cols[c] = fmax(max_cols[c], e)\n                zkw.set(c, max_cols[c])\n        \n        return max_value\n",
    "submit_ts": "1723908993",
    "subm_id": "556333925"
}