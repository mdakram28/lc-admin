{
    "username": "vikasss",
    "submission": "#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nclass Solution {\n    \n    struct Node {\n        long long sum, prefixsum, suffixsum, maxsum;\n    };\n\n    vector<Node> tree;\n    long long size;\n\n    Node combine(Node left, Node right) {\n        Node parent;\n        parent.sum = left.sum + right.sum;\n        parent.prefixsum = max(left.prefixsum, left.sum + right.prefixsum);\n        parent.suffixsum = max(right.suffixsum, right.sum + left.suffixsum);\n        parent.maxsum = max({left.maxsum, right.maxsum, left.suffixsum + right.prefixsum});\n        return parent;\n    }\n\n    void build(vector<long long>& arr, long long low, long long high, long long index) {\n        if (low == high) {\n            tree[index] = {arr[low], arr[low], arr[low], arr[low]};\n        } else {\n            long long mid = (low + high) / 2;\n            build(arr, low, mid, 2 * index + 1);\n            build(arr, mid + 1, high, 2 * index + 2);\n            tree[index] = combine(tree[2 * index + 1], tree[2 * index + 2]);\n        }\n    }\n\n    void update(long long index, long long low, long long high, long long idx, long long value) {\n        if (low == high) {\n            tree[index] = {value, value, value, value};\n        } else {\n            long long mid = (low + high) / 2;\n            if (idx <= mid)\n                update(2 * index + 1, low, mid, idx, value);\n            else\n                update(2 * index + 2, mid + 1, high, idx, value);\n            tree[index] = combine(tree[2 * index + 1], tree[2 * index + 2]);\n        }\n    }\n\n    Node query(long long index, long long low, long long high, long long l, long long r) {\n        if (r < low || high < l)\n            return {0, LLONG_MIN, LLONG_MIN, LLONG_MIN};\n        if (l <= low && high <= r)\n            return tree[index];\n\n        long long mid = (low + high) / 2;\n        Node left = query(2 * index + 1, low, mid, l, r);\n        Node right = query(2 * index + 2, mid + 1, high, l, r);\n\n        if (left.maxsum == LLONG_MIN) return right;\n        if (right.maxsum == LLONG_MIN) return left;\n\n        return combine(left, right);\n    }\n\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int mini = min((int)queries.size() * 3, 50000);\n        long long N = (mini * 2) + 1;\n        vector<long long> arr(N + 1, 0);\n\n        for (long long i = 1; i <= mini; i++) {\n            arr[2 * i] = 1;\n        }\n\n        vector<bool> ans;\n        tree.resize(4 * N);\n        size = N;\n\n        build(arr, 0, N - 1, 0);\n\n        for (auto& it : queries) {\n            long long type = it[0];\n            if (type == 1) {\n                long long x = it[1];\n                arr[(x * 2) + 1] = -1e9;\n                update(0, 0, N - 1, (x * 2) + 1, -1e9);\n            } else {\n                long long x = it[1], sz = it[2];\n                long long temp = query(0, 0, N - 1, 0, (x * 2) + 1).maxsum;\n                ans.push_back(temp >= sz);\n            }\n        }\n        return ans;\n    }\n};\n",
    "submit_ts": 1716652606.0
}