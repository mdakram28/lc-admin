{
    "username": "virchau13",
    "submission": "template<typename T>\nstruct segtree {\n    // root node is at 1, node k has nodes 2k and 2k+1 as children\n    inline T trans(T i, T j){\n        return min(i, j);\n    }\n\n    T* tree;\n    int len;\n\n    segtree(int length) { // build the tree\n        len = length;\n        tree = new T[2*len];\n        for(int i = len; i < 2*len; i++) tree[i] = {2147483647,0};\n        for(int i = len-1; i > 0; i--) tree[i] = trans(tree[2*i], tree[2*i+1]);\n    }\n\n    void update(int p, T v){\n        p += len; // to get it to the correct spot\n        tree[p] = v;\n        while(p != 1){\n            p /= 2; // int division makes (2k+1)/2 ~ k\n            tree[p] = trans(tree[2*p], tree[2*p+1]);\n        }\n    }\n\n    T query(int l, int r){ // [l, r]\n        // get them to where we want\n        l += len;\n        r += len;\n        T result = {2147483647,0};\n        while(l < r){\n            if(l % 2 == 1){ // right child of parent\n                // should not include parent node\n                result = trans(result, tree[l]);\n                l++;\n            }\n            if(r % 2 == 0){ // left child of parent\n                // should not include parent node\n                result = trans(result, tree[r]);\n                r--;\n            }\n            l /= 2;\n            r /= 2;\n        }\n        if(l == r) result = trans(result, tree[l]);\n        return result;\n    }\n};\n\nsegtree<pair<int,int>> arrmins(1e5 + 7);\n\ntemplate<typename T>\nlong long recurse(T start, T end, T base, int height) {\n    if(start == end) return 0;\n    auto m = arrmins.query(start - base, end - base - 1);\n    auto mi = base + m.second;\n    return recurse(start, mi, base, *mi) + recurse(mi+1, end, base, *mi) + (*mi) - height;\n}\n\nclass Solution {\npublic:\n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n        int n = nums.size();\n        vector<int> diff(nums.size());\n        for(int i = 0; i < nums.size(); i++) diff[i] = nums[i] - target[i];\n        vector<vector<int>> regions;\n        int sign = 5105;\n        for(int i = 0; i < n; i++) {\n            int s = (diff[i] > 0) - (diff[i] < 0);\n            if(s == sign) {\n                regions.back().push_back(s * diff[i]);\n            } else {\n                regions.emplace_back(1, s*diff[i]);\n            }\n            sign = s;\n        }\n        long long ans = 0;\n        for (const auto &r: regions) {\n            for(int i = 0; i < r.size(); i++) {\n                arrmins.update(i, {r[i],i});\n            }\n            ans += recurse(r.begin(), r.end(), r.begin(), 0);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1721532991",
    "subm_id": "1327998799"
}