{
    "username": "22cs01048",
    "submission": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to perform DFS and find the furthest node and its distance\nvoid dfs(int node, int parent, vector<vector<int>>& adj, int& maxDist, int& furthestNode, int dist) {\n    if (dist > maxDist) {\n        maxDist = dist;\n        furthestNode = node;\n    }\n    for (int neighbor : adj[node]) {\n        if (neighbor != parent) {\n            dfs(neighbor, node, adj, maxDist, furthestNode, dist + 1);\n        }\n    }\n}\n\n// Function to find the diameter of the tree\nint findDiameter(vector<vector<int>>& edges) {\n    if (edges.empty()) return 0;\n    \n    int n = edges.size() + 1;\n    vector<vector<int>> adj(n);\n    \n    for (const auto& edge : edges) {\n        adj[edge[0]].push_back(edge[1]);\n        adj[edge[1]].push_back(edge[0]);\n    }\n    \n    int maxDist = 0, furthestNode = 0;\n    // First DFS to find one endpoint of the diameter\n    dfs(0, -1, adj, maxDist, furthestNode, 0);\n    \n    maxDist = 0;\n    // Second DFS to find the actual diameter\n    dfs(furthestNode, -1, adj, maxDist, furthestNode, 0);\n    \n    return maxDist;\n}\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = findDiameter(edges1);\n        int m = findDiameter(edges2);\n        \n        int n1 = n / 2;\n        int m1 = m / 2;\n        int n2 = n1, m2 = m1;\n        \n        if (n % 2) n2++;\n        if (m % 2) m2++;\n        \n        cout << n1 << \" \" << n2 << \" \" << m1 << \" \" << m2 << \"\\n\";\n        if(n2==0)return m2+1;\n        if(m2==0)return n2+1;\n        int ans=max(n,m);\n        \n        ans=max(ans,m2+n2+1);\n        ans=max(ans,m2+n1+1);\n        return ans;\n    }\n};\n",
    "submit_ts": "1719719545",
    "subm_id": "1304444612"
}