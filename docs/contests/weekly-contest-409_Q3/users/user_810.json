{
    "username": "fu-bo-luo-mu",
    "submission": "struct Node{\n    int l,r;\n    int val,tag;\n};\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<Node> tree(n << 2);\n        int m = queries.size();\n        auto pushup = [&](int u){\n            tree[u].val = tree[u << 1].val + tree[u << 1 | 1].val;\n        };\n        auto build = [&](auto && self,int u,int l,int r) -> void{\n            tree[u].l = l;\n            tree[u].r = r;\n            if(l == r){\n                tree[u].val = 1;\n                tree[u].tag = 0;\n                return;\n            }\n            int mid = (l + r) >> 1;\n            self(self,u << 1,l,mid);\n            self(self,u << 1 | 1,mid + 1,r);\n            pushup(u);\n        };\n        build(build,1,1,n - 1);\n        auto pushdown = [&](int u){\n            if(tree[u].tag){\n                if(tree[u].tag == -1){\n                    tree[u << 1].val = 0;\n                    tree[u << 1 | 1].val = 0;\n                    tree[u << 1].tag = -1;\n                    tree[u << 1 | 1].tag = -1;\n                }\n                else{\n                    tree[u << 1].val = tree[u << 1].r - tree[u << 1].l + 1;\n                    tree[u << 1 | 1].val = tree[u << 1 | 1].r - tree[u << 1 | 1].l + 1;\n                    tree[u << 1].tag = 1;\n                    tree[u << 1 | 1].tag = 1;\n                }\n                tree[u].tag = 0;\n            }\n        };\n        auto query = [&](auto && self,int u,int l,int r) -> int{\n            if(tree[u].l >= l && tree[u].r <= r){\n                return tree[u].val;\n            }\n            int mid = (tree[u].l + tree[u].r) >> 1;\n            int ans = 0;\n            pushdown(u);\n            if(l <= mid){\n                ans += self(self,u << 1,l,r);\n            }\n            if(r > mid){\n                ans += self(self,u << 1 | 1,l,r);\n            }\n            return ans;\n        };\n        auto update = [&](auto && self,int u,int l,int r,int val) -> void{\n            if(tree[u].l >= l && tree[u].r <= r){\n                if(val == -1){\n                    tree[u].val = 0;\n                }\n                else{\n                    tree[u].val = tree[u].r - tree[u].l + 1;\n                }\n                tree[u].tag = val;\n                return;\n            }\n            pushdown(u);\n            int mid = (tree[u].l + tree[u].r) >> 1;\n            if(l <= mid){\n                self(self,u << 1,l,r,val);\n            }\n            if(r > mid){\n                self(self,u << 1 | 1,l,r,val);\n            }\n            pushup(u);\n        };\n        vector<int> ans;\n        // cout << tree[1].val << endl;\n        for(int i = 0;i < m;i++){\n            int l = queries[i][0] + 1;\n            int r = queries[i][1];\n            int x = query(query,1,r,r);\n            update(update,1,l,r,-1);\n            if(x) update(update,1,r,r,1);\n            // cout << query(query,1,1,n - 1) << endl;\n            ans.push_back(query(query,1,1,n - 1));\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722741061",
    "subm_id": "552335762"
}