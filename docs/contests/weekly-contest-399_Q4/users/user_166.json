{
    "username": "satyabratojha04",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nclass SegmentTree\n{\n    vector<vector<long long>> seg;\n\npublic:\n    SegmentTree(int n)\n    {\n        seg.resize(4 * n, vector<long long>(4));\n    }\n\n    void build(int ind, int low, int high, vector<int> &a)\n    {\n        if (low == high)\n        {\n            seg[ind][3] = max(a[low], 0);\n            return;\n        }\n        int mid = (low + high) >> 1;\n        build(2 * ind + 1, low, mid, a);\n        build(2 * ind + 2, mid + 1, high, a);\n        \n        // seg[ind] = seg[2 * ind + 1] + seg[2 * ind + 2];\n        seg[ind][0] = max(seg[2 * ind + 1][1] + seg[2 * ind + 2][0], seg[2 * ind + 1][0] + seg[2 * ind + 2][2]);\n        seg[ind][1] = max(seg[2 * ind + 1][0] + seg[2 * ind + 2][3], seg[2 * ind + 1][1] + seg[2 * ind + 2][1]);\n        seg[ind][2] = max(seg[2 * ind + 1][3] + seg[2 * ind + 2][0], seg[2 * ind + 1][2] + seg[2 * ind + 2][2]);\n        seg[ind][3] = max(seg[2 * ind + 1][2] + seg[2 * ind + 2][3], seg[2 * ind + 1][3] + seg[2 * ind + 2][1]);\n    }\n\n    void update(int ind, int low, int high, int l, int r, int val)\n    {\n        if (r < low || high < l)\n            return;\n        if (l <= low && high <= r)\n        {\n            seg[ind][3] = max(val, 0);\n            return;\n        }\n        int mid = (low + high) >> 1;\n        update(2 * ind + 1, low, mid, l, r, val);\n        update(2 * ind + 2, mid + 1, high, l, r, val);\n\n        // seg[ind] = seg[2 * ind + 1] + seg[2 * ind + 2];\n        seg[ind][0] = max(seg[2 * ind + 1][1] + seg[2 * ind + 2][0], seg[2 * ind + 1][0] + seg[2 * ind + 2][2]);\n        seg[ind][1] = max(seg[2 * ind + 1][0] + seg[2 * ind + 2][3], seg[2 * ind + 1][1] + seg[2 * ind + 2][1]);\n        seg[ind][2] = max(seg[2 * ind + 1][3] + seg[2 * ind + 2][0], seg[2 * ind + 1][2] + seg[2 * ind + 2][2]);\n        seg[ind][3] = max(seg[2 * ind + 1][2] + seg[2 * ind + 2][3], seg[2 * ind + 1][3] + seg[2 * ind + 2][1]);\n\n\n    }\n\n    vector<long long> query(int ind, int low, int high, int l, int r)\n    {\n        if (r < low || high < l)\n            return {0,0,0,0};\n\n        if (l <= low && high <= r)\n            return seg[ind];\n\n        int mid = (low + high) >> 1;\n        auto left = query(2 * ind + 1, low, mid, l, r);\n        auto right = query(2 * ind + 2, mid + 1, high, l, r);\n\n        vector<long long> ans(4);\n        ans[0] = max(left[1] + right[0], left[0] + right[2]);\n        ans[1] = max(left[0] + right[3], left[1] + right[1]);\n        ans[2] = max(left[3] + right[0], left[2] + right[2]);\n        ans[3] = max(left[2] + right[3], left[3] + right[1]);\n        return ans;\n    }\n};\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        SegmentTree ST(n);\n        ST.build(0,0,n-1,nums);\n        long long ans = 0;\n        \n        for(auto q:queries) {\n            int pos = q[0], val = q[1];\n\n            ST.update(0,0,n-1,pos,pos,val);\n            ans += ST.query(0,0,n-1,0,n-1)[3];\n            ans %= MOD;\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": "1716695607",
    "subm_id": "1268142786"
}