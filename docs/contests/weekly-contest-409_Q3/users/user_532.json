{
    "username": "SaHiL7264",
    "submission": "\ntemplate <typename node, typename update>\nclass SegTree{\npublic:\n\tint len;\n\t// t is the segment Tree\n\tvector<node> t;\n\tvector<update> unpropUpd; \n\tvector<bool> isLazy;\n\tnode identityElement;\n\tupdate identityTransformation; \n\t\n\tSegTree(){}\n\tSegTree(int l){\n\t\tlen = l;\n\t\tt.resize(4 * len);\n\t\tisLazy.resize(4 * len);\n\t\tunpropUpd.resize(4 * len);\n\t\tidentityElement = node();\n\t\tidentityTransformation = update();\n\t}\n\tvoid apply(const int& v,const int& tl,const int& tr,const update& upd){ // [tl, tr] is node range\n\t\tif(tl != tr){ \n\t\t\tisLazy[v] = true;\n\t\t\tunpropUpd[v].combine(upd, tl, tr); \n\t\t}\n\t\tupd.apply(t[v], tl, tr); \n\t}\n\tvoid pushDown(const int& v,const int& tl,const int& tr){\n\t\tif(!isLazy[v]) return;\n\t\tisLazy[v] = false; \n\t\tint tm = (tl + tr)/2;\n\t\tapply(2*v, tl, tm, unpropUpd[v]); \n\t\tapply(2*v+1, tm+1, tr, unpropUpd[v]); \n\t\tunpropUpd[v] = identityTransformation; \n\t}\n\ttemplate<typename T>\n\tvoid build(const T& a,const int& v,const int& tl,const int& tr){\n\t\tif(tl == tr){\n\t\t\tt[v] = a[tl];\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr)/2;\n\t\tbuild(a, 2*v, tl, tm);\n\t\tbuild(a, 2*v+1, tm+1, tr);\n\t\tt[v].merge(t[2*v], t[2*v+1]);\n\t}\n\tnode query(const int& v,const int& tl,const int& tr,const int& l,const int& r){\n\t\tif(tl > r || tr < l) return identityElement; \n\t\tif(l <= tl && tr <= r) return t[v];\n\t\tpushDown(v, tl, tr);\n\t\tint tm = (tl + tr)/2;\n\t\tnode leftAns = query(2*v, tl, tm, l, r);\n\t\tnode rightAns = query(2*v+1, tm+1, tr, l, r);\n\t\tnode ans;\n\t\tans.merge(leftAns, rightAns);\n\t\treturn ans;\n\t}\n\tvoid rangeUpdate(const int& v,const int& tl,const int& tr,const int& l,const int& r, const update& upd){\n\t\tif(l <= tl && tr <= r){\n\t\t\tapply(v, tl, tr, upd); \n\t\t\treturn;\n\t\t}\n\t\tif(tl > r || tr < l) return;\n\t\tpushDown(v, tl, tr);\n\t\tint tm = (tl + tr)/2;\n\t\trangeUpdate(2*v, tl, tm, l, r, upd);\n\t\trangeUpdate(2*v+1, tm+1, tr, l, r, upd);\n\t\tt[v].merge(t[2*v], t[2*v+1]);\n\t}\n\ttemplate<typename T>\n\tvoid build(const T& a){\n\t\tbuild(a, 1, 0, len-1);\n\t}\n\tnode query(const int& l,const int& r){\n\t\treturn query(1, 0, len-1, l, r);\n\t}\n\t\n\tvoid up(const int& l,const int& r, const update& upd){\n\t\trangeUpdate(1, 0, len-1, l, r, upd);\n\t}\n};\nclass Node{\npublic:\n\tint v = 0;\n\tNode(){}\n\tNode(int val){\n\t\tv = val; \n\t}\n\t\n\tvoid merge(const Node& l, const Node& r){ \n\t\tv = l.v + r.v; \n\t}\n};\n\nclass Update{\npublic:\n\tint v = 0;\n\tUpdate(){};\n\tUpdate(int val){\n\t\tv = val; // 5. Update constructor initialization\n\t}\n\t\n\tvoid combine(const Update& otherUpdate, const int& tl, const int& tr){\n\t\tv = otherUpdate.v;\n\t}\n\t\n\tvoid apply(Node& node, const int& tl, const int& tr) const{\n\t\tnode.v = (tr - tl + 1) * v;\n\t}\t\n};\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int> result;\n        \n        SegTree<Node, Update> sg(n);\n        vector<int> a(n);\n\t    sg.build(a);\n     \n        int ans = n-1;\n        for(vector<int> &q :queries) {\n            int l = q[0];\n            int r = q[1];\n            \n            int ok = sg.query(l+1, r-1).v;\n            ans -= (r-l-1) - ok;\n            result.push_back(ans);\n            \n            sg.up(l+1, r-1, 1);\n        }\n        \n        return result;\n    }\n};",
    "submit_ts": "1722742182",
    "subm_id": "1343762977"
}