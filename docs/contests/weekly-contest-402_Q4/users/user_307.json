{
    "username": "ghj123h",
    "submission": "template <typename T>\nclass SegTreeLazyRangeSet {\n  vector<T> tree, lazy;\n  vector<T> *arr;\n  int n, root, n4, end;\n\n  void maintain(int cl, int cr, int p) {\n    int cm = cl + (cr - cl) / 2;\n    if (cl != cr && lazy[p]) {\n      lazy[p * 2] = lazy[p];\n      lazy[p * 2 + 1] = lazy[p];\n      tree[p * 2] = lazy[p] * (cm - cl + 1);\n      tree[p * 2 + 1] = lazy[p] * (cr - cm);\n      lazy[p] = 0;\n    }\n  }\n\n  T range_sum(int l, int r, int cl, int cr, int p) {\n    if (l <= cl && cr <= r) return tree[p];\n    int m = cl + (cr - cl) / 2;\n    T sum = 0;\n    maintain(cl, cr, p);\n    if (l <= m) sum += range_sum(l, r, cl, m, p * 2);\n    if (r > m) sum += range_sum(l, r, m + 1, cr, p * 2 + 1);\n    return sum;\n  }\n\n  void range_set(int l, int r, T val, int cl, int cr, int p) {\n    if (l <= cl && cr <= r) {\n      lazy[p] = val;\n      tree[p] = (cr - cl + 1) * val;\n      return;\n    }\n    int m = cl + (cr - cl) / 2;\n    maintain(cl, cr, p);\n    if (l <= m) range_set(l, r, val, cl, m, p * 2);\n    if (r > m) range_set(l, r, val, m + 1, cr, p * 2 + 1);\n    tree[p] = tree[p * 2] + tree[p * 2 + 1];\n  }\n\n  void build(int s, int t, int p) {\n    if (s == t) {\n      tree[p] = (*arr)[s];\n      return;\n    }\n    int m = s + (t - s) / 2;\n    build(s, m, p * 2);\n    build(m + 1, t, p * 2 + 1);\n    tree[p] = tree[p * 2] + tree[p * 2 + 1];\n  }\n\n public:\n  explicit SegTreeLazyRangeSet<T>(vector<T> v) {\n    n = v.size();\n    n4 = n * 4;\n    tree = vector<T>(n4, 0);\n    lazy = vector<T>(n4, 0);\n    arr = &v;\n    end = n - 1;\n    root = 1;\n    build(0, end, 1);\n    arr = nullptr;\n  }\n\n  void show(int p, int depth = 0) {\n    if (p > n4 || tree[p] == 0) return;\n    show(p * 2, depth + 1);\n    for (int i = 0; i < depth; ++i) putchar('\\t');\n    printf(\"%d:%d\\n\", tree[p], lazy[p]);\n    show(p * 2 + 1, depth + 1);\n  }\n\n  T range_sum(int l, int r) { if (l <= r) return range_sum(l, r, 0, end, root); else return 0; }\n\n  void range_set(int l, int r, int val) { if (l >= 0 && r < n) range_set(l, r, val, 0, end, root); }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> idx(n), ans;\n        for (int i = 0; i < n; ++i) if (isMountain(nums, i)) idx[i] = 1; else idx[i] = 0;\n        SegTreeLazyRangeSet<int> tree(idx);\n        for (auto &q: queries) {\n            if (q[0] == 1) ans.push_back(tree.range_sum(q[1]+1, q[2]-1));\n            else {\n                nums[q[1]] = q[2];\n                if (isMountain(nums,q[1])) tree.range_set(q[1],q[1],1);\n                else tree.range_set(q[1],q[1],0);\n                if (isMountain(nums,q[1]+1)) tree.range_set(q[1]+1,q[1]+1,1);\n                else tree.range_set(q[1]+1,q[1]+1,0);\n                if (isMountain(nums,q[1]-1)) tree.range_set(q[1]-1,q[1]-1,1);\n                else tree.range_set(q[1]-1,q[1]-1,0);\n            }\n        }\n        return ans;\n    }\n    \n    bool isMountain(vector<int> &nums, int i) {\n        return i > 0 && i < nums.size() - 1 && nums[i] > nums[i-1] && nums[i] > nums[i+1];\n    }\n};\n\n",
    "submit_ts": 1718507114.0
}