{
    "username": "Algoh9",
    "submission": "class SegmentTree {\nprivate:\n    inline int getMid(int start, int end) {\n        return start + (end - start) / 2;\n    }\n    \n    vector<int> getSumHelper(int segmentStart, int segmentEnd, int qStart, int qEnd, int index) {\n        if (qStart <= segmentStart && segmentEnd <= qEnd) {\n            return vector<int>({segmentTree[index], segmentTreeL[index], segmentTreeR[index], segmentTreeB[index]});\n        }\n        if (segmentEnd < qStart || segmentStart > qEnd) {\n            return vector<int>({0,0,0,0});\n        }\n        int mid = getMid(segmentStart, segmentEnd);\n        vector<int> left = getSumHelper(segmentStart, mid, qStart, qEnd, 2*index+1);\n        vector<int> right = getSumHelper(mid+1, segmentEnd, qStart, qEnd, 2*index+2);\n        \n        int l1 = max(left[0]+right[1], left[2]+right[0]);\n        int l2 = max(left[1]+right[1], left[3]+right[0]);\n        int l3 =  max(left[2]+right[2], left[0]+right[3]);\n        int l4 =  max(left[3]+right[2], left[1]+right[3]);\n        \n        return vector<int>({l1,l2,l3,l4});\n    }\n    \n    void updateMaxHelper(int segmentStart, int segmentEnd, int ii, int diff, int index) {\n        if (ii < segmentStart || ii > segmentEnd) {\n            return;\n        }\n\n        // MAX\n        if (segmentEnd == segmentStart) {\n            // base case\n            segmentTree[index] = max(diff,0);\n        } else {\n            int mid = getMid(segmentStart, segmentEnd);\n\n            updateMaxHelper(segmentStart, mid, ii, diff, 2*index+1);\n            updateMaxHelper(mid+1, segmentEnd, ii, diff, 2*index+2);\n\n            segmentTree[index] = max(segmentTree[2*index+1]+segmentTreeL[2*index+2], \n                                    segmentTreeR[2*index+1]+segmentTree[2*index+2]);\n            segmentTreeL[index] = max(segmentTreeL[2*index+1]+segmentTreeL[2*index+2], \n                                      segmentTreeB[2*index+1] + segmentTree[2*index+2]);\n            segmentTreeR[index] = max(segmentTreeR[2*index+1]+segmentTreeR[2*index+2], \n                                      segmentTree[2*index+1] + segmentTreeB[2*index+2]);\n            segmentTreeB[index] = max(segmentTreeB[2*index+1]+segmentTreeR[2*index+2], \n                                      segmentTreeL[2*index+1] + segmentTreeB[2*index+2]);\n        }\n    }\n    \n    vector<int> constructHelper(vector<int> &arr, int segmentStart, int segmentEnd, int index) {\n        if (segmentStart == segmentEnd) {\n            segmentTree[index] = max(0,arr[segmentStart]);\n            segmentTreeL[index] = 0;\n            segmentTreeR[index] = 0;\n            return vector<int>({segmentTree[index], 0, 0, 0});\n        }\n        \n        int mid = getMid(segmentStart, segmentEnd);\n        \n        vector<int> left = constructHelper(arr, segmentStart, mid, 2*index+1);\n        vector<int> right =  constructHelper(arr, mid+1, segmentEnd, 2*index+2);\n        \n        segmentTree[index] = max(left[0]+right[1], left[2]+right[0]);\n        segmentTreeL[index] = max(left[1]+right[1], left[3]+right[0]);\n        segmentTreeR[index] = max(left[2]+right[2], left[0]+right[3]);\n        segmentTreeB[index] = max(left[3]+right[2], left[1]+right[3]);\n        \n        return vector<int>({segmentTree[index], segmentTreeL[index], segmentTreeR[index], segmentTreeB[index]});\n    }\n \n    vector<int> segmentTree;\n    vector<int> segmentTreeL;\n    vector<int> segmentTreeR;\n    vector<int> segmentTreeB;\n    int nn = 0;\npublic:\n    void updateMax(vector<int> &arr, int ii, int newValue) {\n        if (ii < 0 || ii > nn-1) {\n            return;\n        }\n        \n        // MAX\n        arr[ii] = newValue;\n        updateMaxHelper(0, nn-1, ii, newValue, 0);\n    }\n    \n    int get(int qStart, int qEnd) {\n        if (qStart < 0 || qEnd > nn-1 || qStart > qEnd) {\n            return -1;\n        }\n        return getSumHelper(0, nn-1, qStart, qEnd, 0)[0];\n    }\n    \n    vector<int> construct(vector<int> &arr) {\n        int n = arr.size();\n        nn = n;\n        int x = (int) (ceil(log2(n)));\n        int maxSize = 2*(1 << x) - 1;\n        segmentTree.resize(maxSize);\n        segmentTreeL.resize(maxSize);\n        segmentTreeR.resize(maxSize);\n        segmentTreeB.resize(maxSize);\n        constructHelper(arr, 0, n-1, 0);\n        return segmentTree;\n    }\n};\n\nclass Solution {\npublic:\n    int bcase(vector<int>& nums, vector<vector<int>>& queries) {\n        const int MOD = 1e9+7;\n        int total = 0;\n        for (vector<int> &q : queries) {\n            total += max(0, q[1]);\n            total %= MOD;\n        }\n        return total;\n    }\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        const int n = nums.size();\n        const int MOD = 1e9+7;\n        long total = 0;\n        \n        if (n == 1) {\n            return bcase(nums, queries);\n        }\n        \n        SegmentTree st;\n        \n        st.construct(nums);\n        for (vector<int> &q : queries) {\n            int idx = q[0];\n            int val = q[1];\n            st.updateMax(nums, idx, val);\n            total += st.get(0, n-1);\n            total %= MOD;   \n        }\n        return total;\n    }\n};",
    "submit_ts": "1716694919",
    "subm_id": "1268128423"
}