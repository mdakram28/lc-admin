{
    "username": "ccba",
    "submission": "import heapq\nfrom typing import List, Tuple, Optional\n\nclass SiftHeap:\n    def __init__(self, length, mapping, comp=lambda x, y: x < y):\n        self.m_heap = []\n        self.m_pos = [-1] * length\n        self.m_size = 0\n        self.m_map = mapping\n        self.m_comp = comp\n\n    def sift_up(self, i):\n        curpos = self.m_pos[i]\n        curvalue = self.m_map(i)\n        while curpos > 0:\n            parent_pos = (curpos - 1) // 2\n            parent = self.m_heap[parent_pos]\n            if not self.m_comp(self.m_map(parent), curvalue):\n                break\n            self.m_heap[curpos] = parent\n            self.m_pos[parent] = curpos\n            curpos = parent_pos\n        self.m_heap[curpos] = i\n        self.m_pos[i] = curpos\n\n    def sift_down(self, i):\n        curpos = self.m_pos[i]\n        curvalue = self.m_map(i)\n        while curpos * 2 + 1 < self.m_size:\n            left_child_pos = curpos * 2 + 1\n            right_child_pos = curpos * 2 + 2\n            child_pos = left_child_pos\n            if right_child_pos < self.m_size and self.m_comp(self.m_map(self.m_heap[left_child_pos]), self.m_map(self.m_heap[right_child_pos])):\n                child_pos = right_child_pos\n            child = self.m_heap[child_pos]\n            if not self.m_comp(curvalue, self.m_map(child)):\n                break\n            self.m_heap[curpos] = child\n            self.m_pos[child] = curpos\n            curpos = child_pos\n        self.m_heap[curpos] = i\n        self.m_pos[i] = curpos\n\n    def push(self, i):\n        if self.m_pos[i] == -1:\n            self.m_pos[i] = self.m_size\n            self.m_heap.append(i)\n            self.m_size += 1\n        self.sift_up(i)\n\n    def pop(self):\n        top = self.m_heap[0]\n        self.m_size -= 1\n        if self.m_size > 0:\n            last = self.m_heap.pop()\n            self.m_heap[0] = last\n            self.sift_down(last)\n        else:\n            self.m_heap.pop()\n        self.m_pos[top] = -1\n        return top\n\n    def top(self):\n        return self.m_heap[0]\n\n    def empty(self):\n        return self.m_size == 0\n\n    def size(self):\n        return self.m_size\n\nclass Graph:\n    def __init__(self, vertex_cnt, edge_cnt):\n        self.vertex_cnt = vertex_cnt\n        self.edges = []\n        self.adj = [[] for _ in range(vertex_cnt)]\n        self.stored = False\n\n    def add_edge(self, from_vertex, to_vertex, cap, cost):\n        self.edges.append([from_vertex, to_vertex, cap, cost])\n        self.adj[from_vertex].append(len(self.edges) - 1)\n        self.edges.append([to_vertex, from_vertex, 0, -cost])\n        self.adj[to_vertex].append(len(self.edges) - 1)\n\n    def min_cost_flow(self, source, sink, flow_limit=float('inf')):\n        potential = [0] * self.vertex_cnt\n        dist = [float('inf')] * self.vertex_cnt\n        prev_vertex = [0] * self.vertex_cnt\n        prev_edge = [0] * self.vertex_cnt\n\n        flow = 0\n        cost = 0\n        while flow < flow_limit:\n            dist = [float('inf')] * self.vertex_cnt\n            dist[source] = 0\n            heap = [(0, source)]\n            while heap:\n                d, v = heapq.heappop(heap)\n                if d > dist[v]:\n                    continue\n                for i in range(len(self.adj[v])):\n                    e = self.edges[self.adj[v][i]]\n                    if e[2] > 0 and dist[e[1]] > dist[v] + e[3] + potential[v] - potential[e[1]]:\n                        dist[e[1]] = dist[v] + e[3] + potential[v] - potential[e[1]]\n                        prev_vertex[e[1]] = v\n                        prev_edge[e[1]] = self.adj[v][i]\n                        heapq.heappush(heap, (dist[e[1]], e[1]))\n            if dist[sink] == float('inf'):\n                break\n\n            for i in range(self.vertex_cnt):\n                potential[i] += dist[i]\n\n            add_flow = flow_limit - flow\n            v = sink\n            while v != source:\n                add_flow = min(add_flow, self.edges[prev_edge[v]][2])\n                v = prev_vertex[v]\n\n            flow += add_flow\n            cost += add_flow * potential[sink]\n            v = sink\n            while v != source:\n                self.edges[prev_edge[v]][2] -= add_flow\n                self.edges[prev_edge[v] ^ 1][2] += add_flow\n                v = prev_vertex[v]\n\n        return flow, cost\n\nclass Solution:\n    def maximumValueSum(self, a: List[List[int]]) -> int:\n        n = len(a)\n        m = len(a[0])\n        G = Graph(n + m + 3, n * m + n + m + 3)\n        S = n + m\n        T = S + 1\n        TT = T + 1\n        for i in range(n):\n            G.add_edge(S, i, 1, 0)\n        for i in range(n):\n            for j in range(m):\n                G.add_edge(i, j + n, 1, -a[i][j])\n        for j in range(m):\n            G.add_edge(j + n, T, 1, 0)\n        G.add_edge(T, TT, 3, 0)\n        return -G.min_cost_flow(S, TT)[1]\n",
    "submit_ts": "1723910241",
    "subm_id": "556340285"
}