{
    "username": "spaded06543",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def getDiameter(edges) -> int:\n            if not edges:\n                return 0\n            graph = defaultdict(set)\n            degree = defaultdict(int)\n            for a, b in edges:\n                graph[a].add(b)\n                graph[b].add(a)\n                degree[a] += 1\n                degree[b] += 1\n            queue = [i for i in range(len(edges) + 1) if degree[i] == 1]\n            #get root\n            root = queue[0]\n            while queue:\n                node = queue.pop()\n                degree[node] = 0\n                root = node\n                for neighbor in graph[node]:\n                    degree[neighbor] -= 1\n                    if degree[neighbor] == 1:\n                        queue.append(neighbor)\n            maxDepth = 0\n            farNode = root\n            queue = [(-1, root, 0)]\n            while queue:\n                parent, node, depth = queue.pop()\n                if depth > maxDepth:\n                    maxDepth = depth\n                    farNode = node\n                for neighbor in graph[node]:\n                    if neighbor != parent:\n                        queue.append((node, neighbor, depth + 1))\n            maxDepth = 0\n            queue = [(-1, farNode, 0)]\n            while queue:\n                parent, node, depth = queue.pop()\n                if depth > maxDepth:\n                    maxDepth = depth\n                for neighbor in graph[node]:\n                    if neighbor != parent:\n                        queue.append((node, neighbor, depth + 1))\n            return maxDepth\n        diameter1 = getDiameter(edges1)\n        diameter2 = getDiameter(edges2)\n        return max(diameter1, diameter2, 1 + (diameter1 + 1) // 2 + (diameter2 + 1) // 2)\n        \n            ",
    "submit_ts": 1719719138.0
}