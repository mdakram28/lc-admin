{
    "username": "prachiagrawal194",
    "submission": "class Solution {\npublic:\n    int treeDiameter(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vector<vector<int>> graph(n);\n        for (auto& edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n        \n        auto farthest = dfs(graph, 0);\n        auto diameter = dfs(graph, farthest.first);\n        return diameter.second;\n    }\n\n    pair<int, int> dfs(const vector<vector<int>>& graph, int start) {\n        vector<int> distance(graph.size(), -1);\n        distance[start] = 0;\n        int maxDist = 0, farthestNode = start;\n        dfsUtil(graph, start, distance, maxDist, farthestNode);\n        return {farthestNode, maxDist};\n    }\n    void dfsUtil(const vector<vector<int>>& graph, int node, vector<int>& distance, int& maxDist, int& farthestNode) {\n        for (int next : graph[node]) {\n            if (distance[next] == -1) {\n                distance[next] = distance[node] + 1;\n                if (distance[next] > maxDist) {\n                    maxDist = distance[next];\n                    farthestNode = next;\n                }\n                dfsUtil(graph, next, distance, maxDist, farthestNode);\n            }\n        }\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int diameter1 = treeDiameter(edges1);\n        int diameter2 = treeDiameter(edges2);\n        int radius1 = (diameter1 + 1) / 2;\n        int radius2 = (diameter2 + 1) / 2;\n        return max({diameter1, diameter2, radius1 + radius2 + 1});\n    }\n};",
    "submit_ts": 1719717734.0
}