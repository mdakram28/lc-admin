{
    "username": "suraj_chaudhary2021",
    "submission": "class Solution {\n    \n    static class Pair {\n        int node, dist;\n        Pair(int node, int dist) {\n            this.node = node;\n            this.dist = dist;\n        }\n    }\n    \n    // Function to perform BFS and return the farthest node and its distance\n    static Pair bfs(int start, List<List<Integer>> adj) {\n        int n = adj.size();\n        int[] dist = new int[n];\n        Arrays.fill(dist, -1);\n        dist[start] = 0;\n        \n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        \n        int maxDist = 0;\n        int maxNode = start;\n        \n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            for (int neighbor : adj.get(node)) {\n                if (dist[neighbor] == -1) {\n                    dist[neighbor] = dist[node] + 1;\n                    queue.offer(neighbor);\n                    if (dist[neighbor] > maxDist) {\n                        maxDist = dist[neighbor];\n                        maxNode = neighbor;\n                    }\n                }\n            }\n        }\n        \n        return new Pair(maxNode, maxDist);\n    }\n    \n    \n    \n    // Function to compute the diameter of a tree given its adjacency list\n    static int getDiameter(List<List<Integer>> adj) {\n        Pair farthest = bfs(0, adj);\n        Pair diameter = bfs(farthest.node, adj);\n        return diameter.dist;\n    }\n    \n    // Function to find the minimum possible diameter of the resulting tree\n    public static int minDiameterOfConnectedTrees(int n, int[][] edges1, int m, int[][] edges2) {\n        // Create adjacency lists for both trees\n        List<List<Integer>> adj1 = new ArrayList<>();\n        List<List<Integer>> adj2 = new ArrayList<>();\n        for (int i = 0; i < n; i++) adj1.add(new ArrayList<>());\n        for (int i = 0; i < m; i++) adj2.add(new ArrayList<>());\n        // System.out.println(n+\" n,  \"+m+\" m\");\n        for (int[] edge : edges1) {\n            // System.out.println(edge[0]+\" edge[0] \"+edge[1]+\" edge[0]\");\n            adj1.get(edge[0]).add(edge[1]);\n            adj1.get(edge[1]).add(edge[0]);\n        }\n        \n        for (int[] edge : edges2) {\n            adj2.get(edge[0]).add(edge[1]);\n            adj2.get(edge[1]).add(edge[0]);\n            // System.out.println(edge[0]+\" edge[0] \"+edge[1]+\" edge[0]\");\n        }\n        \n        // System.out.println(diameter1+\" diameter1 \"+diameter2+\" diameter1\");\n        int diameter1 = getDiameter(adj1);\n        int diameter2 = getDiameter(adj2);\n        \n        \n        // Calculate the minimum possible diameter when connecting the two trees\n        int newDiameter = (diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1;\n        int minDiameter = Math.max(Math.max(diameter1, diameter2), newDiameter);\n        \n        return minDiameter;\n    }\n    \n    \n    \n    \n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int n=0;\n        int m=0;\n        \n        for(int[] edge: edges1)\n            n=Math.max(n,Math.max(edge[0], edge[1]));\n        for(int[] edge: edges2)\n            m=Math.max(m,Math.max(edge[0], edge[1]));\n        \n        return minDiameterOfConnectedTrees(n+1, edges1, m+1, edges2);\n        \n    }\n}",
    "submit_ts": 1719719490.0
}