{
    "username": "hacch141",
    "submission": "typedef long long ll;\ntypedef vector<ll> vl;\ntypedef pair<ll, ll> pll; // Define a pair type for value and index\n\n// ======================================== SEGMENT TREE ==============================================\nclass SegmentTree {\npublic:\n    vector<pll> tree; // Store pairs of (value, index)\n    vl arr;\n    \n    SegmentTree(vl& a) {\n        arr = a;\n        tree.resize(4 * a.size(), {0, -1});\n        BuildTree(0, 0, a.size() - 1);\n    }\n\n    void BuildTree(ll ind, ll ss, ll se) {\n        if (ss == se) {\n            tree[ind] = {arr[ss], ss};\n            return;\n        }\n        ll mid = (ss + se) >> 1, lc = (ind << 1) + 1, rc = (ind << 1) + 2;\n        BuildTree(lc, ss, mid);\n        BuildTree(rc, mid + 1, se);\n        tree[ind] = max(tree[lc], tree[rc]);\n    }\n\n    void update(ll ind, ll ss, ll se, ll i, ll val) {\n        if (ss > i || se < i) return;\n        if (ss == se) {\n            tree[ind] = {val, i};\n            arr[i] = val;\n            return;\n        }\n        ll mid = (ss + se) >> 1, lc = (ind << 1) + 1, rc = (ind << 1) + 2;\n        if (i <= mid) update(lc, ss, mid, i, val);\n        else update(rc, mid + 1, se, i, val);\n        tree[ind] = max(tree[lc], tree[rc]);\n    }\n\n    pll getMax(ll ind, ll ss, ll se, ll qs, ll qe) {\n        if (se < qs || qe < ss) return {LLONG_MIN, -1}; // Return negative infinity and invalid index for max query\n        if (qs <= ss && se <= qe) return tree[ind];\n        ll mid = (ss + se) >> 1, lc = (ind << 1) + 1, rc = (ind << 1) + 2;\n        pll left = getMax(lc, ss, mid, qs, qe);\n        pll right = getMax(rc, mid + 1, se, qs, qe);\n        return max(left, right);\n    }\n};\n\n// ====================================================================================================\n\nll help(vl& v) {\n    int n = v.size();\n    if(n == 0) return 0;\n    long long ans = 0;\n    SegmentTree st(v);\n    pll  mx = st.getMax(0, 0, n - 1, 0, n - 1);\n    while(mx.first > 0) {\n        ans += mx.first;\n        ll ind = mx.second;\n        vl a = st.arr;\n        ll mn = mx.first;\n        for(int i = ind + 1; i < n; i++) {\n            mn = min(mn, a[i]);\n            st.update(0, 0, n - 1, i, a[i] - mn);\n        }\n        mn = mx.first;\n        for(int i = ind - 1; i >= 0; i--) {\n            mn = min(mn, a[i]);\n            st.update(0, 0, n - 1, i, a[i] - mn);\n        }\n        st.update(0, 0, n - 1, ind, 0);\n        mx = st.getMax(0, 0, n - 1, 0, n - 1);\n    }\n    return ans;\n}\n\nclass Solution {\npublic:\n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n        int n = nums.size();\n        vector<int> f(n, 0);\n        for(int i = 0; i < n; i++) {\n            f[i] = target[i] - nums[i];\n            cout << f[i] << \" \";\n        }\n        cout << endl;\n        \n        long long ans = 0;\n        int ptr = 0;\n        while(ptr < n) {\n            vl v;\n            if(f[ptr] > 0) {\n                while(ptr < n && f[ptr] > 0) {\n                    v.push_back(f[ptr]);\n                    ptr++;\n                }\n            }\n            else if(f[ptr] < 0) {\n                while(ptr < n && f[ptr] < 0) {\n                    v.push_back(-f[ptr]);\n                    ptr++;\n                }\n            }\n            else {\n                while(ptr < n && f[ptr] == 0) {\n                    ptr++;\n                }\n            }\n            for(auto i : v) cout << i << \" \";\n            cout << endl;\n            ans += help(v);\n            cout << help(v) << endl;\n        }\n        cout << \"===\" << endl;\n        return ans;\n    }\n};",
    "submit_ts": "1721533698",
    "subm_id": "1328014699"
}