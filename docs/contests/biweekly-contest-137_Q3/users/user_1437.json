{
    "username": "twitch_tv_qiqi_impact",
    "submission": "from sortedcontainers import SortedSet\n\ndef bit_ceil(n):\n    x = 1\n    while x < n: x *= 2\n    return x\n\ndef countr_zero(n):\n    for i in range(32):\n        if n & 1 << i:\n            return i\n    return 32\n\nclass LazySegtree:\n    def __init__(self, v):\n        n = len(v)\n        self._n = n\n        self.size = bit_ceil(n)\n        self.log = countr_zero(self.size)\n        self.d = [e() for _ in range(2 * self.size)]\n        self.lz = [id() for _ in range(self.size)]\n        for i in range(n):\n            self.d[self.size + i] = v[i]\n        for i in range(self.size - 1, 0, -1):\n            self.update(i)\n\n    def _psh(self, p):\n        for i in range(self.log, 0, -1):\n            self.push(p >> i)\n\n    def _upd(self, p):\n        for i in range(1, self.log + 1):\n            self.update(p >> i)\n\n    def _lrpsh(self, l, r):\n        for i in range(self.log, 0, -1):\n            if ((l >> i) << i) != l:\n                self.push(l >> i)\n            if ((r >> i) << i) != r:\n                self.push((r - 1) >> i)\n\n    def set(self, p, x):\n        assert 0 <= p and p < self._n\n        p += self.size\n        self._psh(p)\n        self.d[p] = x\n        self._upd(p)\n\n    def get(self, p):\n        assert 0 <= p and p < self._n\n        p += self.size\n        self._psh(p)\n        return self.d[p]\n\n    def prod(self, l, r):\n        # assert 0 <= l and l <= r and r <= self._n\n        l = max(l, 0)\n        r = min(r, self._n)\n        \n        if l >= r: return e()\n        l += self.size\n        r += self.size\n        self._lrpsh(l, r)\n        \n        sml, smr = e(), e()\n        while l < r:\n            if l & 1:\n                sml = op(sml, self.d[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                smr = op(self.d[r], smr)\n            l >>= 1\n            r >>= 1\n\n        return op(sml, smr)\n\n    def all_prod(self):\n        return self.d[1]\n\n    def apply(self, p, f):\n        assert 0 <= p and p < self._n\n        p += self.size\n        self._psh(p)\n        self.d[p] = mapping(f, self.d[p])\n        self._upd(p)\n\n    def apply(self, l, r, f):\n        # assert 0 <= l and l <= r and r <= self._n\n        l = max(l, 0)\n        r = min(r, self._n)\n        if l >= r:\n            return\n\n        l += self.size\n        r += self.size\n        self._lrpsh(l, r)\n\n        l2, r2 = l, r\n        while l < r:\n            if l & 1:\n                self.all_apply(l, f)\n                l += 1\n            if r & 1:\n                r -= 1\n                self.all_apply(r, f)\n            l >>= 1\n            r >>= 1\n        l, r = l2, r2\n\n        for i in range(1, self.log + 1):\n            if ((l >> i) << i) != l: self.update(l >> i)\n            if ((r >> i) << i) != r: self.update((r - 1) >> i)\n\n    # maximum i s.t. g(a[l]...a[i]) == True\n    def max_right(self, l, g):\n        assert 0 <= l and l <= self._n\n        assert g(e())\n        if l == self._n: return self._n\n        l += self.size\n        self._psh(l)\n        sm = e()\n        while True:\n            while l % 2 == 0: l >>= 1\n            if not g(op(sm, self.d[l])):\n                while l < self.size:\n                    self.push(l)\n                    l = 2 * l\n                    if g(op(sm, self.d[l])):\n                        sm = op(sm, self.d[l])\n                        l += 1\n                return l - self.size\n            sm = op(sm, self.d[l])\n            l += 1\n            if l & -l == l:\n                break\n        return self._n\n\n    # minimum i s.t. g(a[i]...a[r - 1]) == True\n    def min_left(self, r, g):\n        assert 0 <= r and r <= self._n\n        assert g(e())\n        if r == 0: return 0\n        r += self.size\n        self._psh(r - 1)\n        sm = e()\n        while True:\n            r -= 1\n            while r > 1 and r % 2: r >>= 1\n            if not g(op(self.d[r], sm)):\n                while r < self.size:\n                    self.push(r)\n                    r = 2 * r + 1\n                    if g(op(self.d[r], sm)):\n                        sm = op(self.d[r], sm)\n                        r -= 1\n                return r + 1 - self.size\n            sm = op(self.d[r], sm)\n            if r & -r == r:\n                break\n        return 0\n\n    def update(self, k):\n        self.d[k] = op(self.d[2 * k], self.d[2 * k + 1])\n\n    def all_apply(self, k, f):\n        self.d[k] = mapping(f, self.d[k])\n        if (k < self.size):\n            self.lz[k] = composition(f, self.lz[k])\n    \n    def push(self, k):\n        self.all_apply(2 * k, self.lz[k])\n        self.all_apply(2 * k + 1, self.lz[k])\n        self.lz[k] = id()\n\ndef op(l, r):\n    return (max(l[0], r[0]),)\n\ndef e():\n    return (-inf,)\n\ndef mapping(l, r):\n    return (max(l, r[0]),)\n\ndef composition(l, r):\n    return max(l, r)\n\ndef id():\n    return -inf\n\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        R, C = len(board), len(board[0])\n        sl = SortedSet()\n        \n        lst = LazySegtree([(-inf,) for _ in range(C)])\n        \n            \n        cs = [[] for _ in range(C)]\n        for j in range(C):\n            for i in range(R):\n                cs[j].append((board[i][j], i, j))\n            cs[j] = sorted(cs[j])[-3:]\n            \n        rs = [[] for _ in range(R)]\n        for i in range(R):\n            for j in range(C):\n                rs[i].append((board[i][j], i, j))\n            rs[i] = [x for x in sorted(rs[i])[-3:] if x in cs[x[2]]]\n        \n        ret = -inf\n        \n        for a in range(R):\n            for b in range(C):\n                ret = max(ret, board[a][b] + lst.get(b)[0])\n            \n            for x in rs[a]:\n                for i in range(a):\n                    for y in rs[i]:\n                        if x[2] != y[2]:\n                            c, d = min(x[2], y[2]), max(x[2], y[2])\n                            lst.apply(0, c, x[0]+y[0])                          \n                            lst.apply(c+1, d, x[0]+y[0])\n                            lst.apply(d+1, C, x[0]+y[0])\n\n                            \n                            \n                            # sl.add((x[0]+y[0], x[1], x[2], y[1], y[2]))\n            \n            \n        return ret\n                            ",
    "submit_ts": "1723910067",
    "subm_id": "1359216104"
}