{
    "username": "trying_01",
    "submission": "/*AUTHOR : ANTU RANA*/\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\nconst int maxn = 200005;\n\nvector<int> adj[maxn];\nint depth[maxn];\nint ans;\n\nvoid calc_depth(int root, int par)\n{\n    depth[root] = 0;\n    for (auto child : adj[root])\n    {\n        if (child == par)\n            continue;\n        calc_depth(child, root);\n    }\n    for (auto child : adj[root])\n    {\n        if (child == par)\n            continue;\n        depth[root] = max(depth[root], 1 + depth[child]);\n    }\n}\n\nvoid diameter(int root, int par)\n{\n    vector<int> store_depth;\n    for (auto child : adj[root])\n    {\n        if (child == par)\n            continue;\n        store_depth.push_back(depth[child]);\n    }\n    sort(store_depth.begin(), store_depth.end());\n    int n = store_depth.size();\n    if (n == 0)\n    {\n        // do nothing\n    }\n    else if (n == 1)\n    {\n        ans = max(ans, 1 + store_depth[0]);\n    }\n    else\n    {\n        ans = max(ans, 2 + store_depth[n - 1] + store_depth[n - 2]);\n    }\n\n    for (auto child : adj[root])\n    {\n        if (child == par)\n            continue;\n        diameter(child, root);\n    }\n}\n// signed main()\n// {\n//     int n;\n//     cin >> n;\n//     for (int i = 0; i + 1 < n; i++)\n//     {\n//         int u, v;\n//         cin >> u >> v;\n//         --u, --v;\n\n//         adj[u].push_back(v);\n//         adj[v].push_back(u);\n//     }\n//     ans = 0;\n//     calc_depth(0, -1);\n//     diameter(0, -1);\n//     cout << ans << \"\\n\";\n//     return 0;\n// }\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int ans1 = 0,ans2 = 0;\n        set<int>nodecount1;\n        for(auto i:edges1){\n            nodecount1.insert(i[0]);\n            nodecount1.insert(i[1]);\n        }\n        int n1 = nodecount1.size();\n        for(auto i:edges1){\n            int u = i[0], v = i[1];\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        ans = 0;\n        calc_depth(0, -1);\n        diameter(0, -1);\n        ans1 = ans;\n        for(int i=0;i<n1+5000;i++)depth[i] = 0,adj[i].clear();\n        \n        set<int>nodecount2;\n        for(auto i:edges2){\n            nodecount2.insert(i[0]);\n            nodecount2.insert(i[1]);\n        }\n        int n2 = nodecount2.size();\n        for(auto i:edges2){\n            int u = i[0], v = i[1];\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        ans = 0;\n        calc_depth(0, -1);\n        diameter(0, -1);\n        ans2 = ans;\n        for(int i=0;i<n2+5000;i++)depth[i] = 0,adj[i].clear();\n        \n        int ultimate_ans = max({ans1,ans2,(ans1+1)/2 + (ans2+1)/2 + 1});\n        return ultimate_ans;\n        \n    }\n};",
    "submit_ts": "1719718321",
    "subm_id": "1304414286"
}