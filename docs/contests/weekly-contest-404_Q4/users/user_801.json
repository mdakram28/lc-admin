{
    "username": "pein531",
    "submission": "const int N = 200010;\nint n, m, cnt, dist[N], pre[N];\nvector<int> graph[N];\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        n = edges1.size() + 1, m = edges2.size() + 1;\n        for(int i = 1; i <= n; i++) {\n            graph[i].clear();\n        }\n        for(auto&edge: edges1) {\n            int u = edge[0] + 1, v = edge[1] + 1;\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n        }\n        int mid1 = get(n).second;\n        for(int i = 1; i <= m; i++) {\n            graph[i].clear();\n        }\n        for(auto&edge: edges2) {\n            int u = edge[0] + 1, v = edge[1] + 1;\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n        }\n        int mid2 = get(m).second;\n        for(int i = 1; i <= n + m; i++) {\n            graph[i].clear();\n        }\n        for(auto&edge: edges1) {\n            int u = edge[0] + 1, v = edge[1] + 1;\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n        }\n        for(auto&edge: edges2) {\n            int u = edge[0] + n + 1, v = edge[1] + n + 1;\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n        }\n        mid2 += n;\n        graph[mid1].push_back(mid2);\n        graph[mid2].push_back(mid1);\n        return get(n + m, false).first;\n    }\n\n    pair<int, int> get(int n, bool flag=true) {\n        int now_mx = -1, mx_i;\n        for(int i = 1; i <= n; i++) {\n            dist[i] = pre[i] = 0;\n        }\n        // \u6c42\u8ddd\u79bb1\u6700\u8fdc\u7684\u70b9p\n        dfs(1, 0);\n        int maxdist = 0, p = 1;\n        for(int i = 1; i <= n; i++) {\n            if(dist[i] > maxdist) {\n                maxdist = dist[i], p = i;\n            }\n        }\n        // \u6c42\u8ddd\u79bbp\u6700\u8fdc\u7684\u70b9\n        int cur = p;\n        for(int i = 1; i <= n; i++) {\n            dist[i] = pre[i] = 0;\n        }\n        dfs(p, 0);\n        maxdist = 0, p = 1;\n        for(int i = 1; i <= n; i++) {\n            if(dist[i] > maxdist) {\n                maxdist = dist[i];\n                p = i;\n            }\n        }\n        // \u628a\u6574\u4e2a\u76f4\u5f84\u8ffd\u51fa\u6765\n        if(flag) {\n            vector<int> path;\n            cur = p;\n            while(cur) {\n                path.push_back(cur);\n                cur = pre[cur];\n            }\n            int len = path.size(), mid = path[(len + 1) / 2 - 1];\n            if(len > now_mx) {\n                now_mx = len;\n                mx_i = cnt;\n            }\n            return {len, mid};\n        }else {\n            return {maxdist, 0};\n        }\n    }\n\n    void dfs(int u, int fa){\n        for(auto&v: graph[u]){\n            if(v == fa) continue;\n            pre[v] = u;\n            dist[v] = dist[u] + 1;\n            dfs(v, u);\n        }\n    }\n};",
    "submit_ts": 1719717855.0
}