{
    "username": "kamtuo",
    "submission": "/*----------------------------------*/\n/* Author : KaMtuo                  */\n/* Email : kamtuo@qq.com            */\n/* Creation_time : 2024-08-04 11:02 */\n/* Software : Visual Studio Code    */\n/*----------------------------------*/\n\n#include <map>\n#include <set>\n#include <array>\n#include <queue>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <type_traits>\n#include <unordered_map>\n\n#define endl \"\\n\"\ntypedef long long LL;\n\nusing std::cin;\nusing std::cout;\nusing std::getline;\n\nusing std::max;\nusing std::min;\nusing std::sort;\n\nusing std::map;\nusing std::set;\nusing std::array;\nusing std::queue;\nusing std::vector;\nusing std::string;\nusing std::stringstream;\nusing std::unordered_map;\nusing std::priority_queue;\n\n// #define KAMTUO_DEBUG\n#define KAMTUO_LEETCODE\n\n#ifdef KAMTUO_DEBUG\n\ntemplate<typename T>\nstruct is_vector : std::false_type {};\ntemplate<typename T, typename A>\nstruct is_vector<std::vector<T, A>> : std::true_type {};\n\ntemplate<typename T>\nstruct is_unordered_map : std::false_type {};\ntemplate<typename K, typename V, typename H, typename P, typename A>\nstruct is_unordered_map<std::unordered_map<K, V, H, P, A>> : std::true_type {};\n\ntemplate<typename T>\nstruct is_map : std::false_type {};\ntemplate<typename K, typename V, typename C, typename A>\nstruct is_map<std::map<K, V, C, A>> : std::true_type {};\n\ntemplate<typename T>\nstruct is_queue : std::false_type {};\ntemplate<typename T, typename C>\nstruct is_queue<std::queue<T, C>> : std::true_type {};\n\ntemplate<typename T>\nstruct is_priority_queue : std::false_type {};\ntemplate<typename T, typename C, typename Comp>\nstruct is_priority_queue<std::priority_queue<T, C, Comp>> : std::true_type {};\n\ntemplate<typename T>\nstruct is_set : std::false_type {};\ntemplate<typename T, typename C, typename A>\nstruct is_set<std::set<T, C, A>> : std::true_type {};\n\ntemplate<typename T>\nstruct is_pair : std::false_type {};\ntemplate<typename T1, typename T2>\nstruct is_pair<std::pair<T1, T2>> : std::true_type {};\n\ntemplate <typename T, typename ... Args>\nvoid print_value(const T& t);\n\ntemplate <typename T>\nvoid print_struct(const T& t) {\n    auto members = std::tuple(t.a, t.b); \n    vector<string> names = {\"a\", \"b\"};\n    int idx = 0;\n    cout << \"{ \";\n    std::apply([&](auto&&... args) {\n        ((print_value(names[idx ++] + \":\"), print_value(args)), ...);\n    }, members);\n    cout << \"} \";\n}\n\ntemplate <typename T, typename ... Args>\nvoid print_value(const T& t) {\n    if constexpr (is_vector<T>::value) {\n        for (const auto& elem : t) {\n            print_value(elem);\n        }\n//    } else if constexpr (std::is_array_v<T>) {\n//        for (const auto& elem : t) {\n//            print_value(elem);\n//         }\n    } else if constexpr (is_set<T>::value) {\n        for (const auto& elem : t) {\n            print_value(elem);\n        }\n    } else if constexpr (is_pair<T>::value) {\n        const auto& [first, second] = t;\n        cout << \"{ \";\n        print_value(first);\n        cout << \", \";\n        print_value(second);\n        cout << \"} \";\n    } else if constexpr (is_unordered_map<T>::value) {\n        for (const auto& [key, value] : t) {\n            cout << \"{ \";\n            print_value(key);\n            cout << \": \";\n            print_value(value);\n            cout << \"} \";\n        }\n    } else if constexpr (is_map<T>::value) {\n        for (const auto& [key, value] : t) {\n            cout << \"{ \";\n            print_value(key);\n            cout << \": \";\n            print_value(value);\n            cout << \"} \";\n        }\n    } else if constexpr (is_queue<T>::value) {\n        auto temp = t;\n        while (!temp.empty()) {\n            print_value(temp.front());\n            temp.pop();\n        }\n    } else if constexpr (is_priority_queue<T>::value) {\n        auto temp = t;\n        while (!temp.empty()) {\n            print_value(temp.top());\n            temp.pop();\n        }\n    } else if constexpr (std::is_same_v<T, std::string>) {\n        cout << t << \" \";\n    } else if constexpr (std::is_arithmetic_v<T>) {\n        cout << t << \" \";\n    } else if constexpr (std::is_class_v<T>) {\n        print_struct(t);\n    } else {\n        cout << t << \" \";\n    }\n}\n\ntemplate <typename T, typename ... Args>\nvoid debug(const T& t, const Args&... args) {\n    print_value(t);\n    if constexpr (sizeof...(args) > 0) {\n        debug(args...);\n    } else {\n        cout << \"\\n\";\n    }\n}\n\ntemplate <typename A, typename T, size_t N>\nvoid debug_array(const T& t, const A (&arr)[N], const size_t& l, const size_t& r) {\n    print_value(t);\n    for (size_t i = l; i <= r; i ++) {\n        print_value(arr[i]);\n    }\n    cout << \"\\n\";\n}\n\n#else\n\ntemplate <typename T, typename ... Args>\nvoid debug(const T& t, const Args&... args) {}\n\ntemplate <typename A, typename T, size_t N>\nvoid debug_array(const T& t, const A (&arr)[N], const size_t& l, const size_t& r) {}\n\n#endif\n\n    typedef long long LL;\nconst int N=123456;\n\n\nclass Solution {\npublic:\nstruct Node{\n    int l,r;\n    LL sum,add;\n    LL mina;\n}tr[N*4];\nint a[N];\nvoid pushup(int x){\n    tr[x].sum=tr[x<<1].sum+tr[x<<1|1].sum;\n    tr[x].mina = min(tr[x << 1].mina, tr[x << 1 | 1].mina);\n}\nvoid pushdown(int x){\n    if(tr[x].add){\n        tr[x<<1].add+=tr[x].add,tr[x<<1].sum+=(LL)(tr[x<<1].r-tr[x<<1].l+1)*(tr[x].add);\n        tr[x << 1].mina += tr[x].add;\n        tr[x<<1|1].add+=tr[x].add,tr[x<<1|1].sum+=(LL)(tr[x<<1|1].r-tr[x<<1|1].l+1)*(tr[x].add);\n        tr[x << 1 | 1].mina += tr[x].add;\n        tr[x].add=0;\n    }\n}\nvoid modify(int x,int l,int r,int d){\n    if(tr[x].l>=l&&tr[x].r<=r){\n        tr[x].sum+=(LL)(tr[x].r-tr[x].l+1)*(d);\n        tr[x].mina+=d;\n        tr[x].add+=d;\n    }\n    else {\n        pushdown(x);\n        int mid=tr[x].l+tr[x].r>>1;\n        if(l<=mid)modify(x<<1,l,r,d);\n        if(r>mid)modify(x<<1|1,l,r,d);\n        pushup(x);\n    }\n}\nvoid build(int x,int l,int r){\n    tr[x]={l,r};\n    if(l==r){\n        tr[x].sum=a[l];\n        tr[x].mina=a[l];\n        tr[x].add=0;\n    }\n    else {\n        int mid=l+r>>1;\n        build(x<<1,l,mid);\n        build(x<<1|1,mid+1,r);\n        pushup(x);\n    }\n}\nLL query(int x,int l,int r){\n    LL res=0x3f3f3f3f;\n    if(tr[x].l>=l&&tr[x].r<=r){\n        return tr[x].mina;\n    }\n    else{\n        pushdown(x);\n        int mid=tr[x].l+tr[x].r>>1;\n        if(l<=mid)res=min(res,query(x<<1,l,r));\n        if(r>mid)res=min(res,query(x<<1|1,l,r));\n    }\n    return res;\n}\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int> ans;\n        for (int i = 1; i < n; i ++) a[i] = n - i;\n        a[n + 1] = 0;\n        build(1, 1, n);\n        for (int i = 0; i < queries.size(); i ++) {\n            int x = queries[i][0], y = queries[i][1];\n            x ++, y ++;\n            int z = y - x - 1;\n            int l = 1, r = x;\n            int now = query(1, y, y) + 1;\n            z = query(1, x, x) - now;\n            debug(\"z:\", z);\n            debug(\"x:\", x,\"y:\", y);\n            while (l < r) {\n                int mid = l + r + 1 >> 1;\n                if (query(1, mid, x) <= now) l = mid;\n                else r = mid - 1;\n            }\n            if (query(1, l, x) <= now) {\n                if (l != x) modify(1, l + 1, x, -z);\n            } else {\n                modify(1, 1, x, -z);\n            }\n            ans.push_back(query(1, 1, 1));\n        }\n        return ans;\n    }\n};\n\n#ifndef KAMTUO_LEETCODE\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    vector<vector<int>> q = {{2,4},{0,2},{0,4}};\n    debug(Solution().shortestDistanceAfterQueries(5, q));\n    return 0;\n}\n\n#endif\n\n/*\n\n*/",
    "submit_ts": "1722742642",
    "subm_id": "552345964"
}