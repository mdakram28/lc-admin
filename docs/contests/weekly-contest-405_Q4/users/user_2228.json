{
    "username": "Zanger",
    "submission": "class Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        indicesToWords = defaultdict(list)\n        wordToCost = {}\n        for w, c in zip(words, costs) :\n            if w in wordToCost and wordToCost[w] <= c :\n                continue\n            wordToCost[w] = c\n\n        words = sorted(list(set(words)), key=lambda x: len(x))\n        maxWrd = len(words) - 1\n\n        # for i in range(len(target)) :\n            # while maxWrd >= 0 and len(words[maxWrd]) > len(target) - i :\n            #     maxWrd -= 1\n            # if maxWrd < 0 :\n            #     break\n            \n            # for word in words[:maxWrd + 1] :\n            #     if word == target[i:i+len(word)] :\n            #         indicesToWords[i].append((len(word), wordToCost[word]))\n        # print(indicesToWords)\n        # if not indicesToWords[0] :\n        #     return -1\n\n        dp = [0] + [inf] * len(target)\n\n        for i in range(len(target)) :\n            while maxWrd >= 0 and len(words[maxWrd]) > len(target) - i :\n                maxWrd -= 1\n            if maxWrd < 0 :\n                break\n\n            for word in words[:maxWrd + 1] :\n                if word == target[i:i+len(word)] :\n                    dp[i + len(word)] = min(dp[i + len(word)], dp[i] + wordToCost[word])\n                    # toCheck.append((len(word), wordToCost[word]))\n\n            # for l, c in indicesToWords[i] :\n            #     dp[i + l] = min(dp[i + l], dp[i] + c)\n        \n        return -1 if dp[-1] == inf else dp[-1] \n\n        # # costs.sort()\n        # # trie = {}       # str\n        # # minCost = inf\n\n        # # for word in words :\n        # #     if len(word) <= len(target) and word == target[:len(word)] :\n        # #         trie[word] += \n\n        # # minCost = 999999999\n        # # toVisit = [(costs[i], words[i]) for i in range(len(words)) if (len(words[i]) <= len(target) and words[i] == target[:len(words[i])])]\n\n        # # print(toVisit)\n        # # heapq.heapify(toVisit)\n\n        # # while toVisit :\n        # #     print(toVisit)\n        # #     cost, progress = heapq.heappop(toVisit)\n            \n        # #     for c, w in zip(costs, words) :\n        # #         if c + cost >= minCost :\n        # #             break\n        # #         temp = progress + w\n        # #         if temp == target :\n        # #             minCost = c + cost\n        # #             continue\n        # #         if len(temp) > len(target) or temp != target[:len(temp)] :\n        # #             continue\n        # #         heapq.heappush(toVisit, (cost + c, temp))\n        \n        # return minCost",
    "submit_ts": "1720323987",
    "subm_id": "1312388904"
}