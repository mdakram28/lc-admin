{
    "username": "u77",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        \n        def findMinHeightTrees(edges: List[List[int]]) -> List[int]:\n            n = max(itertools.chain.from_iterable(edges), default=0)+1\n            G = collections.defaultdict(set)\n            for u,v in edges:\n                G[u].add(v)\n                G[v].add(u)\n\n            indegree = {vertex: len(edges) for vertex, edges in G.items()}\n            queue = collections.deque(vertex for vertex, edges in G.items() if len(edges) == 1)\n            while n > 2: # stop at center\n                Q = len(queue)\n                n -= Q\n                for _ in range(Q): # level order\n                    vertex = queue.popleft()\n                    for adjacent in G[vertex]:\n                        indegree[adjacent] -= 1\n                        if indegree[adjacent] == 1:\n                            queue.append(adjacent)\n            return queue[0] if queue else 0\n        \n        def bfs(root, edges):\n            G = collections.defaultdict(set)\n            for u,v in edges:\n                G[u].add(v)\n                G[v].add(u)\n            \n            res = 0\n            visited = {root}\n            queue = collections.deque([(0,root)])\n            while queue:\n                d,node = queue.popleft()\n                res = d\n                for nei in G[node]:\n                    if nei not in visited:\n                        visited.add(nei)\n                        queue.append((d+1, nei))\n            return res\n        \n        def diameter(edges):\n            G = collections.defaultdict(set)\n            for u,v in edges:\n                G[u].add(v)\n                G[v].add(u)\n                \n            start = last = 0\n            visited = {start}\n            queue = collections.deque([(0, start)])\n            while queue:\n                d,node = queue.popleft()\n                last = node\n                for nei in G[node]:\n                    if nei not in visited:\n                        visited.add(nei)\n                        queue.append((d+1, nei))\n            \n            return bfs(last, edges)\n        \n        root1 = findMinHeightTrees(edges1)\n        root2 = findMinHeightTrees(edges2)\n        return max(bfs(root1, edges1) + bfs(root2, edges2) + 1, diameter(edges1), diameter(edges2))\n        ",
    "submit_ts": "1719718933",
    "subm_id": "1304429656"
}