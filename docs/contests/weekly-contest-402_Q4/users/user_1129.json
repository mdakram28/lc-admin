{
    "username": "kavascgjmd39",
    "submission": "const double eps = 1e-6;\n#define ll long long\n#define pi pair\ntypedef long double ld;\n#define pb push_back\n#define all(a) a.begin(), a.end()\n#define rep(i, a, b) for (ll i = a; i < b; i++)\n#define ff first\n#define ss second\n#define vt vector\n#define vi vt<ll>\n#define ub upper_bound\n#define lb lower_bound\n#define repr(i, n, a) for (ll i = n; i >= a; i--)\n#define dq deque\n#define inset(a, st) st.find(a) != st.end()\n#define issub(a, b) b.find(a) != string::npos\n#define len(a) (ll)a.size()\nconst ld PI = 2 * acos(0.0);\nconst ll mod2 = 1e9+7;\nconst ll mod = 998244353;\nconst ll nax = 2e5 + 5;\nconst ll N = 2e5 + 1;\n\nvt<ll>seg;\nll build(ll l , ll r, ll i , vt<int>&a){\n  if(l == r){\n   return seg[i] = a[l];\n  }\n  ll mid = l + (r-l)/2;\n  ll val1 = build(l , mid , 2*i , a);\n  ll val2 = build(mid+1, r , 2*i+1, a);\n  return seg[i] = val1 + val2;\n}\n \nll query(ll l , ll r, ll i, ll a , ll b){\n  if(l>=a && r <= b ){\n    return seg[i];\n  }\n  if(l > b || r < a){\n    return 0;\n  }\n  ll mid = l + (r-l)/2;\n  ll val1 = query(l , mid , 2*i , a, b);\n  ll val2 = query(mid+1, r , 2*i+1, a, b);\n  return val1 + val2;\n}\n \n \nll update(ll l ,ll r , ll i, ll k, ll val){\n  if(l == r && l == k){\n    seg[i] = val;\n    return seg[i];\n  }\n  if( l > k || r < k){\n    return seg[i];\n  }\n  ll mid = l + (r-l)/2;\n  ll val1 = update(l , mid , 2*i , k , val);\n  ll val2 = update(mid+1, r , 2*i+1, k ,val);\n  return seg[i] = val1 + val2;\n}\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& v, vector<vector<int>>& queries) {\n       \n        vt<int>count(v.size() , 0);\n        rep(i , 1 , v.size()-1){\n            if(v[i] > v[i-1] && v[i] > v[i+1]){\n                count[i] = 1;\n            }\n        }\n        vt<int>sol;\n        seg.resize(4*v.size());\n        build(0 , v.size()- 1 , 1 , count);\n        rep(i , 0 , queries.size()){\n            int x = queries[i][0];\n            if(x  == 2){\n                int ind = queries[i][1], val = queries[i][2]; \n                v[ind] = val;\n                \n                if(ind > 0 && ind < v.size()-1){\n                int nval = 0;\n                if(v[ind] > v[ind-1] && v[ind] > v[ind+1]){\n                    nval  = 1 ;\n                }\n                update(0 , v.size()-1 , 1 , ind, nval);}\n                ind -- ;\n                 if(ind > 0 && ind < v.size()-1){\n                int nval = 0;\n                if(v[ind] > v[ind-1] && v[ind] > v[ind+1]){\n                    nval  = 1 ;\n                }\n                update(0 , v.size()-1 , 1 , ind, nval);}\n                ind += 2;\n                 if(ind > 0 && ind < v.size()-1){\n                int nval = 0;\n                if(v[ind] > v[ind-1] && v[ind] > v[ind+1]){\n                    nval  = 1 ;\n                }\n                update(0 , v.size()-1 , 1 , ind, nval);}\n                \n                \n            }\n            else {\n                int l = queries[i][1], r = queries[i][2];\n                int s = query(0 , v.size()-1, 1 , l+1 , r-1);\n                sol.push_back(s);\n            }\n        }\n        return sol;\n    }\n};",
    "submit_ts": 1718508704.0
}