{
    "username": "adarsh2706",
    "submission": "class Solution {\npublic:\n    bool canReachCorner(int width, int height, const vector<vector<int>>& obstacles) {\n        int numObstacles = obstacles.size();\n        vector<pair<pair<int, int>, int>> obstacleDetails(numObstacles);\n        vector<vector<int>> adjList(numObstacles + 4);\n\n        for (int i = 0; i < numObstacles; ++i) {\n            obstacleDetails[i] = {{obstacles[i][0], obstacles[i][1]}, obstacles[i][2]};\n        }\n\n        for (int i = 0; i < numObstacles; ++i) {\n            if (obstacleDetails[i].first.first <= obstacleDetails[i].second) {\n                adjList[numObstacles].push_back(i);\n                adjList[i].push_back(numObstacles);\n            }\n            if (width - obstacleDetails[i].first.first <= obstacleDetails[i].second) {\n                adjList[numObstacles + 2].push_back(i);\n                adjList[i].push_back(numObstacles + 2);\n            }\n            if (obstacleDetails[i].first.second <= obstacleDetails[i].second) {\n                adjList[numObstacles + 1].push_back(i);\n                adjList[i].push_back(numObstacles + 1);\n            }\n            if (height - obstacleDetails[i].first.second <= obstacleDetails[i].second) {\n                adjList[numObstacles + 3].push_back(i);\n                adjList[i].push_back(numObstacles + 3);\n            }\n            for (int j = i + 1; j < numObstacles; ++j) {\n                double dist = sqrt(pow(obstacleDetails[i].first.first - obstacleDetails[j].first.first, 2) +\n                                   pow(obstacleDetails[i].first.second - obstacleDetails[j].first.second, 2));\n                if (obstacleDetails[i].second + obstacleDetails[j].second >= dist) {\n                    adjList[i].push_back(j);\n                    adjList[j].push_back(i);\n                }\n            }\n        }\n\n        auto bfs = [&](int src, int dest1, int dest2) {\n            queue<int> q;\n            vector<bool> visited(adjList.size(), false);\n            q.push(src);\n            visited[src] = true;\n\n            while (!q.empty()) {\n                int node = q.front();\n                q.pop();\n                for (int neigh : adjList[node]) {\n                    if (!visited[neigh]) {\n                        q.push(neigh);\n                        visited[neigh] = true;\n                    }\n                }\n            }\n            return visited[dest1] || visited[dest2];\n        };\n\n        bool block = bfs(numObstacles, numObstacles + 1, numObstacles + 2) || \n                       bfs(numObstacles + 3, numObstacles + 2, numObstacles + 1);\n\n        return !block;\n    }\n};\n",
    "submit_ts": "1722137482",
    "subm_id": "1335765061"
}