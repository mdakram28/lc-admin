{
    "username": "pvduy1996",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n/******** Debug Code *******/\nvoid __print(int x) { cout << x; }\nvoid __print(long x) { cout << x; }\nvoid __print(long long x) { cout << x; }\nvoid __print(unsigned x) { cout << x; }\nvoid __print(unsigned long x) { cout << x; }\nvoid __print(unsigned long long x) { cout << x; }\nvoid __print(float x) { cout << x; }\nvoid __print(double x) { cout << x; }\nvoid __print(long double x) { cout << x; }\nvoid __print(char x) { cout << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cout << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cout << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cout << (x ? \"true\" : \"false\"); }\ntemplate <typename A>\nvoid __print(const A &x);\ntemplate <typename A, typename B>\nvoid __print(const pair<A, B> &p);\ntemplate <typename... A>\nvoid __print(const tuple<A...> &t);\ntemplate <typename T>\nvoid __print(stack<T> s);\ntemplate <typename T>\nvoid __print(queue<T> q);\ntemplate <typename T, typename... U>\nvoid __print(priority_queue<T, U...> q);\ntemplate <typename A>\nvoid __print(const A &x) {\nbool first = true;\ncout << '{';\nfor (const auto &i : x) {\n    cout << (first ? \"\" : \",\"), __print(i);\n    first = false;\n}\ncout << '}';\n}\ntemplate <typename A, typename B>\nvoid __print(const pair<A, B> &p) {\ncout << '(';\n__print(p.first);\ncout << ',';\n__print(p.second);\ncout << ')';\n}\ntemplate <typename... A>\nvoid __print(const tuple<A...> &t) {\nbool first = true;\ncout << '(';\napply([&first](const auto &...args) { ((cout << (first ? \"\" : \",\"), __print(args), first = false), ...); }, t);\ncout << ')';\n}\ntemplate <typename T>\nvoid __print(stack<T> s) {\nvector<T> debugVector;\nwhile (!s.empty()) {\n    T t = s.top();\n    debugVector.push_back(t);\n    s.pop();\n}\nreverse(debugVector.begin(), debugVector.end());\n__print(debugVector);\n}\ntemplate <typename T>\nvoid __print(queue<T> q) {\nvector<T> debugVector;\nwhile (!q.empty()) {\n    T t = q.front();\n    debugVector.push_back(t);\n    q.pop();\n}\n__print(debugVector);\n}\ntemplate <typename T, typename... U>\nvoid __print(priority_queue<T, U...> q) {\nvector<T> debugVector;\nwhile (!q.empty()) {\n    T t = q.top();\n    debugVector.push_back(t);\n    q.pop();\n}\n__print(debugVector);\n}\nvoid _print() { cout << \"]\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid _print(const Head &H, const Tail &...T) {\n__print(H);\nif (sizeof...(T))\n    cout << \", \";\n_print(T...);\n}\n\n#ifndef DUY\n#define debug(x...) cout << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif \nclass Solution {\npublic:\nint n;\nvoid  build (vector<int> &tree,vector<int> &a, int node, int start,\n               int end)\n        {\n            if (start == end) {\n                tree[node] = a[start];\n                // debug(start,a[start]);\n            }\n            else {\n                int mid = (start + end) / 2;\n                build(tree,a, 2 * node + 1, start, mid);\n                build(tree,a, 2 * node + 2, mid + 1, end);\n\n                // bitwise AND of the children nodes\n                tree[node]\n                    =( tree[2 * node + 1] & tree[2 * node + 2]);\n            }\n        }\n        int  query1(vector<int> &tree,int node, int start, int end, int l, int r) \n        {\n            if (r < start || end < l) {\n                return INT_MAX;\n            }\n            if (l <= start && end <= r) {\n                return tree[node];\n            }\n            int mid = (start + end) / 2;\n            int p1 = query1(tree,2 * node + 1, start, mid, l, r);\n            int p2 = query1(tree,2 * node + 2, mid + 1, end, l, r);\n            return (p1 & p2);\n        }\n        // Overloading query function to be used recursively\n        int  query(vector<int> &tree,int l, int r)\n        {\n            return query1(tree,0, 0, n - 1, l, r);\n        }\n    \n\n    int minimumDifference(vector<int>& a, int k) {\n        //segtree\n         n = a.size();\n        int res = INT_MAX;\n        vector<int> tree(4*n+10);\n        \n        build(tree,a,0, 0, n - 1);\n        // debug(tree);\n        // debug(query(3,3));\n        \n        for (int i = 0; i < n; i++) {\n            int lo = i - 1, hi = n - 1, mid;\n            int val = lo;\n            // binary search implementation\n            while (hi-lo>1) {\n                mid = (hi+lo) / 2;\n                if (query(tree,i, mid) >= k)\n                {\n                    lo = mid;\n                }\n                else\n                    hi = mid;\n            }\n            if (lo != i - 1)\n                res = min(res, abs(query(tree,i,lo ) - k));\n            res = min(res, abs(k -query(tree,i,hi)));\n            \n            // debug(res,lo,hi,i);\n            // debug(query(i,hi));\n            // debug(query(i,lo));\n        }\n        return res;\n    }\n};",
    "submit_ts": "1717300384",
    "subm_id": "1274842474"
}