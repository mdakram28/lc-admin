{
    "username": "Sagar_Goel",
    "submission": "class Solution {\npublic:\n    int findParent(int i, vector<int>&parent){\n        if(i==parent[i]) return i;\n        else return parent[i]=findParent(parent[i],parent);\n    }\n    \n    void unionByRank(vector<int>&ranks,vector<int>&parent,int i,int j){\n        int u=findParent(i,parent);\n        int v=findParent(j,parent);\n        if(ranks[u]>ranks[v]){\n            parent[v]=u;\n        }\n        else if(ranks[v]>ranks[u]){\n            parent[u]=v;\n        }\n        else{\n            parent[v]=u;\n            ranks[u]++;\n        }\n    }\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        vector<vector<int> > comp;\n        vector<int> ranks(circles.size(),0),parent(circles.size());\n        for(int i=0;i<circles.size();i++){\n            parent[i]=i;\n        }\n        for(int i=0;i<circles.size();i++){\n            for(int j=i+1;j<circles.size();j++){\n                double dist = sqrt(((long long)circles[i][0]-(long long)circles[j][0])*((long long)circles[i][0]-(long long)circles[j][0]) + ((long long)circles[i][1]-(long long)circles[j][1])*((long long)circles[i][1]-(long long)circles[j][1]));\n                if((double)((double)circles[i][2]+(double)circles[j][2])>=dist){\n                    unionByRank(ranks,parent,i,j);\n                }\n            }\n        }\n        unordered_map<int,int> u;\n        for(int i=0;i<circles.size();i++){\n            int par = findParent(i,parent);\n            int num;\n            if(u.count(par)){\n                num = u[par];\n                comp[num][0]=max(comp[num][0],circles[i][1]+circles[i][2]);\n                comp[num][1]=max(comp[num][1],circles[i][0]+circles[i][2]);\n                comp[num][2]=min(comp[num][2],circles[i][1]-circles[i][2]);\n                comp[num][3]=min(comp[num][3],circles[i][0]-circles[i][2]);\n            }\n            else{\n                num = comp.size();\n                u[par] = num;\n                comp.push_back({circles[i][1]+circles[i][2],circles[i][0]+circles[i][2],circles[i][1]-circles[i][2],circles[i][0]-circles[i][2]});\n            }\n        }\n        for(int i=0;i<comp.size();i++){\n            bool top = (comp[i][0]>=Y);\n            bool right = (comp[i][1]>=X);\n            bool bottom = (comp[i][2]<=0);\n            bool left = (comp[i][3]<=0);\n            \n            if(top && right) return false;\n            if(top && bottom) return false;\n            if(right && left) return false;\n            if(bottom && left) return false;\n        }\n        return true;\n    }\n};",
    "submit_ts": "1722137738",
    "subm_id": "1335772308"
}