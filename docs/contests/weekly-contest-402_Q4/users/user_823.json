{
    "username": "21Cash",
    "submission": "\nclass SegmentTree {\nprivate:\n    int n;\n    std::vector<long long> t;\n\n    void build(const std::vector<long long>& a, int v, int tl, int tr) {\n        if (tl == tr) {\n            t[v] = a[tl];\n        } else {\n            int tm = (tl + tr) / 2;\n            build(a, v * 2, tl, tm);\n            build(a, v * 2 + 1, tm + 1, tr);\n            t[v] = t[v * 2] + t[v * 2 + 1];\n        }\n    }\n\n    long long sum(int v, int tl, int tr, int l, int r) {\n        if (l > r)\n            return 0;\n        if (l == tl && r == tr) {\n            return t[v];\n        }\n        int tm = (tl + tr) / 2;\n        return sum(v * 2, tl, tm, l, std::min(r, tm))\n               + sum(v * 2 + 1, tm + 1, tr, std::max(l, tm + 1), r);\n    }\n\n    void update(int v, int tl, int tr, int pos, long long new_val) {\n        if (tl == tr) {\n            t[v] = new_val;\n        } else {\n            int tm = (tl + tr) / 2;\n            if (pos <= tm)\n                update(v * 2, tl, tm, pos, new_val);\n            else\n                update(v * 2 + 1, tm + 1, tr, pos, new_val);\n            t[v] = t[v * 2] + t[v * 2 + 1];\n        }\n    }\n\npublic:\n    SegmentTree() {\n        n = 0;\n    }\n\n    void init(const std::vector<long long>& a) {\n        n = a.size();\n        t.resize(4 * n);\n        build(a, 1, 0, n - 1);\n    }\n\n    long long querySum(int l, int r) {\n        return sum(1, 0, n - 1, l, r);\n    }\n\n    void pointUpdate(int pos, long long new_val) {\n        update(1, 0, n - 1, pos, new_val);\n    }\n};\n\n\n#define toLongLong(vec) vector<long long>((vec).begin(), (vec).end())\n#define ll long long\n\nvoid printTree(int N, SegmentTree &tree) {\n    for(int i = 0; i < N; i++) {\n        cout << tree.querySum(i, i) << \" \"; \n    }\n    \n    cout << \"\\n\";\n}\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<long long> numsL;\n        for(long long  x : nums) numsL.push_back(x);\n        SegmentTree segTree;\n        segTree.init(numsL);\n        \n        \n        int N = nums.size();\n\n        vector<long long> temp(N, 0);\n        SegmentTree sumTree;\n        sumTree.init(temp);\n        \n        auto isPeak = [&] (int index) {\n            if(index <= 0 || index >= N -1 ) return false;\n            ll back_val = segTree.querySum(index - 1, index - 1);\n            ll front_val = segTree.querySum(index + 1, index + 1);\n            ll cur_val = segTree.querySum(index, index);\n            \n            return cur_val > back_val && cur_val > front_val;\n        };\n        \n        for(int i = 0; i < N; i++) {\n            if(isPeak(i)) {\n                sumTree.pointUpdate(i, 1);\n            }\n        }\n        vector<int> res;\n        int t = 0;\n        for(auto &query : queries) {\n            int type = query[0];\n            int l = query[1], r = query[2];\n            int index = query[1], new_val = query[2];\n            \n            if(type == 1) {\n                int curRes = sumTree.querySum(l, r);\n                if(isPeak(l)) curRes--;\n                if(isPeak(r)) curRes--;\n                \n                curRes = max(curRes, 0);\n                res.push_back(curRes);\n            }\n            else { // Type 2 Update Query\n                segTree.pointUpdate(index, new_val);\n                ll cur_is_good = isPeak(index);\n                ll back_is_good = isPeak(index - 1);\n                ll front_is_good = isPeak(index + 1);\n                \n                sumTree.pointUpdate(index, cur_is_good);\n                if(index - 1 >= 0) sumTree.pointUpdate(index - 1, back_is_good);\n                if(index + 1 < N - 1) sumTree.pointUpdate(index + 1, front_is_good);\n            }\n            \n        }\n        \n        return res;\n    }\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "submit_ts": 1718508248.0
}