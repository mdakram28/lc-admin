{
    "username": "soustabhaldar10",
    "submission": "class SegmentTree {\npublic:\n    vector<long> tree;\n\n    SegmentTree(int size) { tree.resize(size); }\n\n    void buildTree(int start, int end, int node, long arr[]) {\n        if (start == end) {\n            tree[node] = arr[start];\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        buildTree(start, mid, 2 * node + 1, arr);\n        buildTree(mid + 1, end, 2 * node + 2, arr);\n        tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);\n    }\n\n    void updateTree(int start, int end, int node, int index, long value) {\n        if (start == end) {\n            tree[node] = value;\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        if (index <= mid)\n            updateTree(start, mid, 2 * node + 1, index, value);\n        else\n            updateTree(mid + 1, end, 2 * node + 2, index, value);\n        tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);\n    }\n\n    long queryTree(int start, int end, int node, int left, int right) {\n        if (left <= start && right >= end)\n            return tree[node];\n        if (left > end || right < start)\n            return LONG_MIN;\n        int mid = start + (end - start) / 2;\n        long leftQuery = queryTree(start, mid, 2 * node + 1, left, right);\n        long rightQuery = queryTree(mid + 1, end, 2 * node + 2, left, right);\n        return max(leftQuery, rightQuery);\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector<bool> r;\n        set<int> b;\n        b.insert(0);\n        b.insert(100000);\n        unordered_map<int, int> d;\n        d[0] = 0;\n        d[100000] = 100000;\n\n        SegmentTree t(5 * (int)(1e5));\n\n        for (auto& q : queries) {\n            if (q[0] == 1) {\n                b.insert(q[1]);\n                int p = *prev(b.lower_bound(q[1]));\n                auto nIt = b.upper_bound(q[1]);\n                if (nIt == b.end())\n                    continue;\n                int n = *nIt;\n                d[n] = n - q[1];\n                d[q[1]] = q[1] - p;\n                t.updateTree(0, 100000, 0, q[1], d[q[1]]);\n                t.updateTree(0, 100000, 0, n, d[n]);\n            } else {\n                int p = *prev(b.lower_bound(q[1]));\n                if (q[1] - p >= q[2]) {\n                    r.push_back(true);\n                    continue;\n                } else if (t.queryTree(0, 100000, 0, 0, q[1]) >= q[2]) {\n                    r.push_back(true);\n                    continue;\n                }\n                r.push_back(false);\n            }\n        }\n        return r;\n    }\n};",
    "submit_ts": 1716652562.0
}