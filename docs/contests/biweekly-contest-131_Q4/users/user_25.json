{
    "username": "jeffreyhu8",
    "submission": "// https://github.com/kth-competitive-programming/kactl/blob/main/content/data-structures/LazySegmentTree.h\nconst int inf = 1e9;\nstruct Node {\n\tNode *l = 0, *r = 0;\n\tint lo, hi, mset = inf, madd = 0, val = -inf;\n\tNode(int lo,int hi):lo(lo),hi(hi){} // Large interval of -inf\n\tNode(vector<int>& v, int lo, int hi) : lo(lo), hi(hi) {\n\t\tif (lo + 1 < hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(v, lo, mid); r = new Node(v, mid, hi);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t\telse val = v[lo];\n\t}\n\tint query(int L, int R) {\n\t\tif (R <= lo || hi <= L) return -inf;\n\t\tif (L <= lo && hi <= R) return val;\n\t\tpush();\n\t\treturn max(l->query(L, R), r->query(L, R));\n\t}\n\tvoid set(int L, int R, int x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) mset = val = x, madd = 0;\n\t\telse {\n\t\t\tpush(), l->set(L, R, x), r->set(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid add(int L, int R, int x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) {\n\t\t\tif (mset != inf) mset += x;\n\t\t\telse madd += x;\n\t\t\tval += x;\n\t\t}\n\t\telse {\n\t\t\tpush(), l->add(L, R, x), r->add(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid push() {\n\t\tif (!l) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(lo, mid); r = new Node(mid, hi);\n\t\t}\n\t\tif (mset != inf)\n\t\t\tl->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;\n\t\telse if (madd)\n\t\t\tl->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;\n\t}\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        set<int> div;\n        div.insert(0);\n        div.insert(inf);\n\n        Node st(0, 3 * queries.size() + 2);\n        vector<bool> res;\n\n        for (auto v : queries) {\n            if (v[0] == 1) {\n                int lb = *(--div.upper_bound(v[1]));\n                int ub = *div.upper_bound(v[1]);\n                st.set(lb, v[1], v[1] - lb);\n                st.set(v[1], ub, ub - v[1]);\n\n                div.insert(v[1]);\n\n                // cout << \"INSERT \" << v[1] << \" \" << lb << \" \" << ub << endl;\n            } else {\n                int lb = *(--div.upper_bound(v[1]));\n                int prev = st.query(v[1] - 1, v[1]);\n\n                st.set(lb, v[1], v[1] - lb);\n\n                res.push_back(st.query(0, v[1]) >= v[2]);\n\n                // cout << \"SEG\" << endl;\n                // cout << v[1] << \" \" << lb << \" \" << prev << \" \" << v[1] - lb << endl;\n                // for (int i = 0; i < 10 ; ++i) {\n                //     cout << st.query(i, i + 1) << endl;\n                // }\n                // cout << st.query(0, v[1]) << \" \" << v[2] << endl;\n\n                st.set(lb, v[1], prev);\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": "1716649302",
    "subm_id": "1267583911"
}