{
    "username": "Amit_321",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace chrono;\n\n#define D             double\n#define in          long long int\n#define ll           long long\n#define PI           3.1415926535897932384626\n#define rep(i,num)     for(int i=0;i<num;i++)\n#define repk(i,k,num)  for(int i=k;i<num;i++)\n#define pb           push_back\n#define vec          vector<in>\n#define vecc         vector<vector<in>>\n#define veccc        vector<vector<vector<in>>>\n#define vecll          vector<ll>\n#define vecp         vector<pair<in,in>>\n#define pii            pair<in,in>\n#define pll            pair<ll,ll>\n#define nl             '\\n'\n#define np           cout<<-1<<nl;\n#define ff           first\n#define ss           second\n#define yes          {cout << \"YES\" << nl;}\n#define no           {cout << \"NO\" << nl;}\n#define all(v)       v.begin(),v.end()\n#define rall(v)      v.rbegin(),v.rend()\n#define seev(v)          for(auto i:v)cout<<i<<\" \";\n#define checking            cout<<\"Checking\"<<nl;\n#define pr              pair<int , int >\n#define S                string\n#define print(a)           for(auto x : a) cout << x << \" \";cout<<nl;\n#define printpair(a)       for(auto x : a) cout << x.first << \" \" << x.second<< nl;\n#define c(n)            cin>> n ;\n#define cc(a,b)     cin>>a>>b;\n#define ccc(a,b,c)      cin>>a>>b>>c;\n#define p(n)            cout<<n<<nl;\n#define ps(n)           cout<<n<<' ';\n#define pp(a,b)         cout<<a<<' '<<b<<nl;\n#define ppp(a,b,c)      cout<<a<<' '<<b<<' '<<c<<nl ;\n#define si( v )             (int)v.size()\n#define vin(v) for(int i = 0; i < (int)v.size(); i++) cin>>v[i];\nll bits(ll x) { ll cnt = 0; while (x > 0) { cnt++; x >>= 1; } return cnt; }\nll setbits(ll x) { ll cnt = 0; while (x > 0) { cnt += (x & 1); x >>= 1; } return cnt; }\nint Add(vec a ) {int s = 0 ; for (auto &i : a) s += i ; return s ;}\ntemplate <typename T> void put(T s) { cout << s << '\\n';}\ntemplate <typename T> void puts(T s) { cout << s << \" \";}\n#define ins         insert\n#define pob         pop_back\n#define im          p(\"IMPOSSIBLE\")\n/*****************************#define*************************/\n#define w(x)int x ; cin>>x ;while(x--)\n/******************** Policy_Based****************************/\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate<typename T> using ordset = tree<T, null_type, less_equal<T>, rb_tree_tag,\n                           tree_order_statistics_node_update> ;\n\n// *s.find_by_order(k) -> kth largest element\n// s.order_of_key( val )-> Numbers stricly smaller than val\ntemplate<typename T >\nvoid myerase(ordset<T> & t, T v) {\n    int rank = t.order_of_key(v);//Number of elements that are less than v in t\n    auto   it = t.find_by_order(rank); //Iterator that points to the (rank+1)th element in t\n    t.erase(it);\n}\n\n/******************** Policy_Based****************************/\nconst int modi = 998244353;\nconst int mod = 1e9 + 7;\nconst int N6 = 1000005;\nconst int N5 = 100005 ;\nconst int N3 = 1005 ;\nconst ll INF = 1e18 ;\n\nauto init = []()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 'c';\n}();\nstruct Node {\n    int p , s , a , l ;\n    Node(int p = 0  , int s = 0 , int a = 0 , int l = 0 ) {\n        this->p = p ; this->s = s ;\n        this -> a = a ; this -> l = l ;\n    }\n};\n\ntemplate<typename T > class SegmentTree {\nprivate:\n    vector< T > tree;\n    int n ;\n    T  pull( T  a , T b )\n    {\n        int p = a.l == a.p ? a.p + b.p : a.p ;\n        int s = b.s == b.l ? b.s + a.s : b.s ;\n        int al = max({ a.s + b.p , a.a , b.a }) ;\n        int l = a.l + b.l ;\n        return {p, s, al, l} ;\n    }\n    T  query(int u , int l , int r , const int tl , const int tr ) {\n        if ( r < tl || l > tr ) {\n            return {0, 0, 0, 0};\n        }\n        if ( tl <= l && tr >= r) {\n            return tree[u];\n        }\n        int m = ( l + r ) / 2;\n        return pull(query(2 * u, l, m, tl, tr), query(2 * u + 1, m + 1, r, tl, tr));\n    }\n \n    void update(int u , int l , int r , const int pos , const T val )\n    {\n        if ( l == r) {\n            tree[u] = val ;\n            return;\n        }\n        int m = ( l + r ) / 2;\n        if ( pos <= m )update( 2 * u , l , m , pos , val );\n        else update( 2 * u + 1, m + 1 , r , pos , val );\n        tree[u] = pull(tree[2 * u], tree[2 * u + 1]);\n    }\npublic:\n    SegmentTree ( int n  )\n    {\n        this->n = n ;\n        tree.resize( 4 * n + 1  ) ;\n    }\n    void update( int i , T val)\n    {\n        update( 1 , 0 , n - 1 , i , val  );\n    }\n    int query( int l , int r  )\n    {\n        T  res =  query( 1 , 0 , n - 1 , l , r ) ;\n        return res . a  ;\n    }\n};\n\n class Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        \n        int n = min(5 * 10000, 3 * si(queries) )  + 8 ; \n        SegmentTree< Node > seg( n );\n\n        repk( i ,1 ,  n ) seg.update(i , {1,1,1,1}) ;\n        // seg.update( 0 , {0,0,0,0} ) ;\n        vector<bool> res ; \n        for( auto i : queries )\n        {\n            if( i[0] == 1 )\n            {\n                seg.update( i[1] , {0,0,0,1} );\n            }\n            else\n            {\n                int x = seg.query(0 , i[1] - 1 );\n                // p( x );\n                res.pb(( x + 1  >= i[2] ? 1 : 0 )) ;\n            }\n        }\n        return res ;\n    }\n};",
    "submit_ts": 1716651574.0
}