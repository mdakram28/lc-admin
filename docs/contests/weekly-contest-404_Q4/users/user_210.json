{
    "username": "lochristopher9",
    "submission": "from collections import deque\n\nclass Solution:\n    def bfs_farthest_node(self, tree, start):\n        n = len(tree)\n        dist = [-1] * n\n        dist[start] = 0\n        queue = deque([start])\n        farthest_node = start\n        while queue:\n            node = queue.popleft()\n            for neighbor in tree[node]:\n                if dist[neighbor] == -1:\n                    dist[neighbor] = dist[node] + 1\n                    queue.append(neighbor)\n                    if dist[neighbor] > dist[farthest_node]:\n                        farthest_node = neighbor\n        return farthest_node, dist\n    \n    def tree_diameter_and_heights(self, tree):\n        n = len(tree)\n        start = 0\n        far_node, dist_from_start = self.bfs_farthest_node(tree, start)\n        far_node2, dist_from_far = self.bfs_farthest_node(tree, far_node)\n        diameter = dist_from_far[far_node2]\n        heights = dist_from_far\n        return diameter, heights\n    \n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        n1 = len(edges1) + 1\n        n2 = len(edges2) + 1\n        tree1 = [[] for _ in range(n1)]\n        tree2 = [[] for _ in range(n2)]\n        for a, b in edges1:\n            tree1[a].append(b)\n            tree1[b].append(a)\n        \n        for u, v in edges2:\n            tree2[u].append(v)\n            tree2[v].append(u)\n        \n        diameter1, heights1 = self.tree_diameter_and_heights(tree1)\n        diameter2, heights2 = self.tree_diameter_and_heights(tree2)\n        res = max(diameter1, diameter2)\n        res = max(res, ceil(max(heights1) / 2) + ceil(max(heights2) / 2) + 1)\n        return res\n        \n        ",
    "submit_ts": 1719718148.0
}