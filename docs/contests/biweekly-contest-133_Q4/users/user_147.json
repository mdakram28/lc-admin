{
    "username": "Homie_Lander7",
    "submission": "const int MOD = 1e9 + 7;\nstruct mi\n{\n    int val;\n    mi(long long v = 0)\n    {\n        if (v < 0)\n        {\n            v = v % MOD + MOD;\n        }\n        if (v >= MOD)\n        {\n            v %= MOD;\n        }\n        val = v;\n    }\n    static int mod_inv(int a, int m = MOD)\n    {\n        int g = m, r = a, x = 0, y = 1;\n        while (r != 0)\n        {\n            int q = g / r;\n            g %= r;\n            swap(g, r);\n            x -= q * y;\n            swap(x, y);\n        }\n        return x < 0 ? x + m : x;\n    }\n    explicit operator int() const\n    {\n        return val;\n    }\n    mi &operator+=(const mi &other)\n    {\n        val += other.val;\n        if (val >= MOD)\n            val -= MOD;\n        return *this;\n    }\n    mi &operator-=(const mi &other)\n    {\n        val -= other.val;\n        if (val < 0)\n            val += MOD;\n        return *this;\n    }\n    typedef unsigned long long ull;\n    ull fast_mod(ull a, ull b, ull M = MOD)\n    {\n        long long ret = a * b - M * ull(1.L / M * a * b);\n        return ret + M * (ret < 0) - M * (ret >= (long long)M);\n    }\n    mi &operator*=(const mi &other)\n    {\n        val = fast_mod((ull)val, other.val);\n        return *this;\n    }\n    mi &operator/=(const mi &other)\n    {\n        return *this *= other.inv();\n    }\n    friend mi operator+(const mi &a, const mi &b) { return mi(a) += b; }\n    friend mi operator-(const mi &a, const mi &b) { return mi(a) -= b; }\n    friend mi operator*(const mi &a, const mi &b) { return mi(a) *= b; }\n    friend mi operator/(const mi &a, const mi &b) { return mi(a) /= b; }\n    mi &operator++()\n    {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n    mi &operator--()\n    {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n    mi operator++(int32_t)\n    {\n        mi before = *this;\n        ++*this;\n        return before;\n    }\n    mi operator--(int32_t)\n    {\n        mi before = *this;\n        --*this;\n        return before;\n    }\n    mi operator-() const\n    {\n        return val == 0 ? 0 : MOD - val;\n    }\n    bool operator==(const mi &other) const { return val == other.val; }\n    bool operator!=(const mi &other) const { return val != other.val; }\n    mi inv() const\n    {\n        return mod_inv(val);\n    }\n    mi pow(long long p) const\n    {\n        assert(p >= 0);\n        mi a = *this, result = 1;\n\n        while (p > 0)\n        {\n            if (p & 1)\n                result *= a;\n\n            a *= a;\n            p >>= 1;\n        }\n        return result;\n    }\n    friend ostream &operator<<(ostream &stream, const mi &m)\n    {\n        return stream << m.val;\n    }\n    friend istream &operator>>(istream &stream, mi &m)\n    {\n        return stream >> m.val;\n    }\n    friend void __print(const mi &x)\n    {\n        cerr << x.val;\n    }\n};\nclass Solution {\npublic:\n    int numberOfPermutations(int n, vector<vector<int>>& r) {\n        vector<int>req(n+1,-1);\n        int mx=0;\n        for(auto &i:r){\n            req[i[0]+1]=i[1];\n            mx=max(mx,i[1]);\n        }\n\n        // ith index,j inversions\n        vector<vector<bool>>vis(n+1,vector<bool>(mx+1));\n        vector<vector<mi>>dp(n+1,vector<mi>(mx+1));\n        auto dfs=[&](auto &&dfs,int i,int j){\n             if(j>mx)return mi(0);\n             if(i==n+1)return mi(1);\n             if(vis[i][j])return dp[i][j];\n             vis[i][j]=1;\n             mi &ans=dp[i][j];\n             ans=0;\n             for(int inv=0;inv<=i-1;inv++){\n                if(req[i]==-1){\n                  \n                   ans+=dfs(dfs,i+1,j+inv);\n                }else{\n                   if(j+inv==req[i]){\n                      ans+=dfs(dfs,i+1,j+inv);\n                   }\n                }\n             }\n             return ans;\n        };\n        mi ans = dfs(dfs,1,0);\n        return ans.val;\n        \n    } \n};",
    "submit_ts": 1719068479.0
}