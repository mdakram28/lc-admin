{
    "username": "LarryNY",
    "submission": "from sortedcontainers import SortedList\n\nMAX = 50010\nINF = 10 ** 20\n\nclass SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (4 * n)\n        self.lazy = [0] * (4 * n)\n    \n    def _build(self, start, end, node):\n        if start == end:\n            self.tree[node] = MAX\n        else:\n            mid = (start + end) // 2\n            self._build(start, mid, 2 * node + 1)\n            self._build(mid + 1, end, 2 * node + 2)\n            self.tree[node] = max(self.tree[2 * node + 1], self.tree[2 * node + 2])\n    \n    def _update_range(self, start, end, l, r, value, node):\n        if self.lazy[node] != 0:\n            self.tree[node] = self.lazy[node]\n            if start != end:\n                self.lazy[2 * node + 1] = self.lazy[node]\n                self.lazy[2 * node + 2] = self.lazy[node]\n            self.lazy[node] = 0\n        \n        if start > end or start > r or end < l:\n            return\n        \n        if start >= l and end <= r:\n            self.tree[node] = value\n            if start != end:\n                self.lazy[2 * node + 1] = value\n                self.lazy[2 * node + 2] = value\n            return\n        \n        mid = (start + end) // 2\n        self._update_range(start, mid, l, r, value, 2 * node + 1)\n        self._update_range(mid + 1, end, l, r, value, 2 * node + 2)\n        self.tree[node] = max(self.tree[2 * node + 1], self.tree[2 * node + 2])\n    \n    def _query_range(self, start, end, l, r, node):\n        if start > end or start > r or end < l:\n            return -INF\n        \n        if self.lazy[node] != 0:\n            self.tree[node] = self.lazy[node]\n            if start != end:\n                self.lazy[2 * node + 1] = self.lazy[node]\n                self.lazy[2 * node + 2] = self.lazy[node]\n            self.lazy[node] = 0\n        \n        if start >= l and end <= r:\n            return self.tree[node]\n        \n        mid = (start + end) // 2\n        left_query = self._query_range(start, mid, l, r, 2 * node + 1)\n        right_query = self._query_range(mid + 1, end, l, r, 2 * node + 2)\n        return max(left_query, right_query)\n    \n    def build(self):\n        self._build(0, self.n - 1, 0)\n    \n    def update_range(self, l, r, value):\n        self._update_range(0, self.n - 1, l, r, value, 0)\n    \n    def query_range(self, l, r):\n        return self._query_range(0, self.n - 1, l, r, 0)\n\n\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        st = SegmentTree(MAX)\n        sl = SortedList()\n        \n        sl.add(0)\n        sl.add(MAX)\n        ans = []\n        \n        for row in queries:\n            if len(row) == 2:\n                _, x = row\n                \n                index = sl.bisect_left(x)\n                nxt = sl[index]\n                prev = sl[index - 1]\n                \n                sl.add(x)\n                st.update_range(prev + 1, x, x - prev)\n                #print(f\"update {prev + 1} {x} {x - prev}\")\n                st.update_range(x + 1, nxt, nxt - x)\n                #print(f\"update {x + 1} {nxt} {nxt - x}\")\n            else:\n                _, x, sz = row\n                if sz > x:\n                    ans.append(False)\n                    continue\n                \n                index = sl.bisect_right(x) - 1\n                \n                p = sl[index]\n                mx = 0\n                if p != 0:\n                    mx = st.query_range(0, p)\n                mx = max(mx, x - p)\n                \n                #print(f\"querying {x} {sz} {index=} {p=} {mx=} {x - p} {st.query_range(0, p)}\")\n                ans.append(mx >= sz)\n        \n        return ans",
    "submit_ts": 1716650389.0
}