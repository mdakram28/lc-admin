{
    "username": "manishmeena_0007",
    "submission": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int diameter1 = calculateDiameter(edges1);\n        int diameter2 = calculateDiameter(edges2);\n\n        // The maximum possible height of the trees (height = diameter / 2 rounded up)\n        int height1 = (diameter1 + 1) / 2;\n        int height2 = (diameter2 + 1) / 2;\n\n        // The minimum possible diameter after merging the trees\n        int mergedDiameter = Math.max(Math.max(diameter1, diameter2), height1 + height2 + 1);\n\n        return mergedDiameter;\n    }\n\n    private int calculateDiameter(int[][] edges) {\n        if (edges.length == 0) return 0;\n        \n        // Build the graph from edges\n        int n = edges.length + 1;\n        List<Integer>[] graph = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        for (int[] edge : edges) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n\n        // Find the farthest node from an arbitrary node (0) to get one end of the diameter\n        int[] farthest = bfs(graph, 0);\n        // Find the farthest node from the previously found node to get the diameter\n        farthest = bfs(graph, farthest[0]);\n\n        // The distance to this node is the diameter of the tree\n        return farthest[1];\n    }\n\n    private int[] bfs(List<Integer>[] graph, int start) {\n        int n = graph.length;\n        boolean[] visited = new boolean[n];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{start, 0});\n        visited[start] = true;\n\n        int[] farthest = new int[2]; // {node, distance}\n        while (!queue.isEmpty()) {\n            int[] node = queue.poll();\n            int currentNode = node[0];\n            int currentDistance = node[1];\n            farthest = node;\n\n            for (int neighbor : graph[currentNode]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    queue.offer(new int[]{neighbor, currentDistance + 1});\n                }\n            }\n        }\n\n        return farthest;\n    }\n}",
    "submit_ts": "1719717619",
    "subm_id": "1304396429"
}