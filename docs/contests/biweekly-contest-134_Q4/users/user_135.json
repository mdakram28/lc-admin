{
    "username": "jamshedmd1111",
    "submission": "#define ll int\n\nclass Node{\n    public:\n\n    ll d;\n    Node *l, *r;\n\n    Node(ll data){\n        d = data;\n        l = NULL;\n        r = NULL;\n    }\n};\n\nclass SegmentTree {\n    Node *root;\n    ll n;\npublic:\n    ll op(ll num1, ll num2){\n        return num1 & num2;\n    }\n\n    Node* make(ll l, ll r, vector<ll> &a){\n        if(l == r){\n            Node* newNode = new Node(a[l]);\n            return newNode;\n        }\n\n        ll m = (l+r)/2;\n\n        Node* left = make(l, m, a);\n        Node* right = make(m+1, r, a);\n\n        ll ans = op(left->d, right->d);\n\n        Node* newNode = new Node(ans);\n        newNode->l = left;\n        newNode->r = right;\n        return newNode;\n    }\n\n    SegmentTree(vector<ll>& a) {\n        n = a.size();\n        if(n == 0){\n            //cout << \"You_are_passing_empty_vector_in_Segment_Tree\\n\";\n            return;\n        }\n        root = make(0, a.size() - 1, a);\n    }\n\n    ll update(Node* t, ll l, ll r, ll index, ll val) {\n        if(l == r){\n            ll ans = val;\n            t->d = val;\n            return ans;\n        }\n\n        ll m = (l+r)/2;\n\n        if(index > m){\n            ll ans = op(update(t->r, m+1, r, index, val), t->l->d);\n            t->d = ans;\n        }\n        else{\n            ll ans = op(update(t->l, l, m, index, val), t->r->d);\n            t->d = ans;\n        }\n        return t->d;\n    }\n\n    ll query(Node* t, ll currL, ll currR, ll reqL, ll reqR) {\n\n        if(currL == reqL && currR == reqR){\n            return t->d;\n        }\n        \n        ll m = (currL + currR)/2;\n\n        ll ans;\n\n        if(reqL <= min(m, reqR) && max(m+1, reqL) <= reqR){\n            ll ansL = query(t->l, currL, m, reqL, min(m, reqR));\n            ll ansR = query(t->r, m+1, currR, max(m+1, reqL), reqR);\n\n            ans = op(ansL, ansR);\n        }\n        else if(reqL <= min(m, reqR)){\n            ll ansL = query(t->l, currL, m, reqL, min(m, reqR));\n            ans = ansL;\n        }\n        else{//case of max(m+1, reqL) <= reqR\n            ll ansR = query(t->r, m+1, currR, max(m+1, reqL), reqR);\n            ans = ansR;\n        }\n        \n        return ans;\n    }\n\n    void update(ll index, ll val) {\n        update(root, 0, n-1, index, val);\n    }\n    \n    ll query(ll left, ll right) {\n        return query(root, 0, n-1, left, right);\n    }\n};\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& a, int k) {\n        ll n = a.size();\n\n        SegmentTree st (a);\n\n        long long ans = 0;\n\n        for(ll i = 0; i<a.size(); i++){\n            long long l = i;\n            long long r = n - 1;\n\n            long long m1 = n;\n\n            while(l <= r){\n                long long m = (l + r)/2;\n\n                long long c = st.query(i, m);\n\n                if(c <= k){\n                    m1 = m;\n                    r = m - 1;\n                }\n                else{\n                    l = m + 1;\n                }\n            }\n\n            l = i;\n            r = n - 1;\n\n            long long m2 = n;\n\n            while(l <= r){\n                long long m = (l + r)/2;\n\n                long long c = st.query(i, m);\n\n                if(c <= k - 1){\n                    m2 = m;\n                    r = m - 1;\n                }\n                else{\n                    l = m + 1;\n                }\n            }\n\n            ans += m2 - m1;\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": "1720278243",
    "subm_id": "1311700658"
}