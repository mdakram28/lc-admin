{
    "username": "Wilsano",
    "submission": "class Solution {\npublic:\n    vector<int> find_center(int n, vector<int>& degree, unordered_map<int, vector<int>>& graph){\n        queue<int> queue;\n        for(int i = 0; i < n; ++i){\n            if(degree[i] == 1){\n                queue.push(i);\n            }\n        }\n\n        int distance = 0;\n        vector<int> centers;\n        while(!queue.empty()){\n            vector<int> nodes;\n            int size = queue.size();\n            for(int i = 0; i < size; ++i){\n                int u = queue.front();\n                queue.pop();\n                nodes.push_back(u);\n                for(const auto& v : graph[u]){\n                    degree[v] -= 1;\n                    if(degree[v] == 1){\n                        queue.push(v);\n                    }\n                }\n            }\n            distance += 1;\n            centers = nodes;\n        }\n        \n        distance = 2 * (distance - 1) + (centers.size() > 1);\n        centers.push_back(distance);\n        return centers;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n1 = edges1.size() + 1;\n        int n2 = edges2.size() + 1;\n        vector<int> degree_1(n1, 0), degree_2(n2, 0), degree(n1 + n2, 0);\n        unordered_map<int, vector<int>> graph_1, graph_2, graph;\n        for(const auto& edge : edges1){\n            int u = edge[0];\n            int v = edge[1];\n            graph_1[u].push_back(v);\n            graph_1[v].push_back(u);\n            degree_1[u] += 1;\n            degree_1[v] += 1;\n        }\n\n        for(const auto& edge : edges2){\n            int u = edge[0];\n            int v = edge[1];\n            graph_2[u].push_back(v);\n            graph_2[v].push_back(u);\n            degree_2[u] += 1;\n            degree_2[v] += 1;\n        }\n        \n        vector<int> center_1 = find_center(n1, degree_1, graph_1);\n        vector<int> center_2 = find_center(n2, degree_2, graph_2);\n        \n        if(edges1.empty()){\n            center_1 = {0, 1};\n        }\n        \n        if(edges2.empty()){\n            center_2 = {0, 1};\n        }\n\n        int c1 = center_1[0];\n        int c2 = center_2[0];\n    \n        graph[c1].push_back(c2 + n1);\n        graph[c2 + n1].push_back(c1);\n        degree[c1] += 1;\n        degree[c2 + n1] += 1;\n        \n        for(const auto& edge : edges1){\n            int u = edge[0];\n            int v = edge[1];\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n            degree[u] += 1;\n            degree[v] += 1;\n        }\n\n        for(const auto& edge : edges2){\n            int u = edge[0] + n1;\n            int v = edge[1] + n1;\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n            degree[u] += 1;\n            degree[v] += 1;\n        }\n        \n        vector<int> center = find_center(n1 + n2, degree, graph);\n        \n        return center.back();\n    }\n};",
    "submit_ts": "1719718318",
    "subm_id": "1304414229"
}