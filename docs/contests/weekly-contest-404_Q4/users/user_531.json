{
    "username": "professor43236",
    "submission": "class Solution {\npublic:\n    class Tree {\n    public:\n        int n;\n        vector<vector<int>> adj;\n\n        Tree(int size) : n(size), adj(size) {}\n\n        void addEdge(int u, int v) {\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n\n        pair<int, int> bfs(int start) {\n            vector<int> dist(n, -1);\n            queue<int> q;\n            q.push(start);\n            dist[start] = 0;\n            int farthestNode = start;\n            while (!q.empty()) \n            {\n                int node = q.front();\n                q.pop();\n                for (int child : adj[node]) \n                {\n                    if (dist[child] == -1) \n                    {\n                        dist[child] = dist[node] + 1;\n                        q.push(child);\n                        if (dist[child] > dist[farthestNode])\n                            farthestNode = child;\n                    }\n                }\n            }\n            return {farthestNode, dist[farthestNode]};\n        }\n\n        int getDiameter() {\n            auto [farthestNode, _] = bfs(0);\n            auto [otherFarthestNode, diameter] = bfs(farthestNode);\n            return diameter;\n        }\n    };\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n=edges1.size()+1,m=edges2.size()+1;\n        Tree tree1(n);\n        Tree tree2(m);\n        for(int i=0;i<(n-1);++i) {\n            tree1.addEdge(edges1[i][0], edges1[i][1]);\n        }\n        for(int i=0;i<(m-1);++i) {\n            tree2.addEdge(edges2[i][0], edges2[i][1]);\n        }\n        int diameter1 = tree1.getDiameter();\n        int diameter2 = tree2.getDiameter();\n        return max({diameter1, diameter2, (diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1});\n    }\n};",
    "submit_ts": "1719718162",
    "subm_id": "1304410297"
}