{
    "username": "lost-temple-2",
    "submission": "public class Solution {\n    public IList<bool> GetResults(int[][] queries) {\n        List<int> list = new List<int>();\n        list.Add(0);\n        list.Add((int)1e6);\n        foreach (var query in queries) {\n            int t = query[0];\n            if (t == 1) {\n                list.Add(query[1]);\n            }\n        }\n        list.Sort();\n        Dictionary<int,int> idxMap = new Dictionary<int,int>();\n        int n = list.Count;\n        Treap<int> treap = new Treap<int>((a,b) => {\n           return a-b; \n        });\n        for (int i=0;i<n;i++) {\n            idxMap[list[i]] = i;\n            treap.Insert(list[i]);\n        }\n        //int dp = 0;\n        SegTree segTree = new SegTree(n);\n        for (int i=1;i<n;i++) {\n            //dp = Math.Max(dp,list[i]-list[i-1]);\n            segTree.Update(i,i,list[i]-list[i-1],1,1,n);\n        }\n        int q = queries.Length;\n        List<bool> revList = new List<bool>();\n        for (int i=q-1;i>=0;i--) {\n            //Console.WriteLine(\"query {0} :\",i);\n            int t = queries[i][0];\n            if (t == 1) {\n                int x = queries[i][1];\n                int rank = treap.Rank(x);\n                //Console.WriteLine(rank);\n                int next = treap.GetValueByRank(rank+1);\n                int pre = treap.GetValueByRank(rank-1);\n                int idx = idxMap[next];\n                segTree.Update(idx,idx,next-pre,1,1,n);\n                treap.Delete(x);\n            } else {\n                int x = queries[i][1],sz = queries[i][2];\n                int upper = 0;\n                bool res = treap.UpperBound(x,ref upper);\n                int maxSize = x - upper;\n                if (upper != 0) {\n                    maxSize = Math.Max(maxSize,segTree.Query(1,idxMap[upper],1,1,n));\n                }\n                revList.Add(maxSize >= sz);\n            }\n        }\n        revList.Reverse();\n        return revList;\n    }\n    \n    class SegTree\n    {\n        private int[] tree;\n        private int[] add;\n        private int n;\n\n        public SegTree(int n)\n        {\n            this.n = n;\n            tree = new int[n << 2];\n            add = new int[n << 2];\n        }\n\n        public void Update(int s, int e, int val, int rt, int l, int r)\n        {\n            if (l >= s && r <= e)\n            {\n                tree[rt] = Math.Max(tree[rt],val);\n                add[rt] = Math.Max(add[rt],val);\n                return;\n            }\n            PushDown(rt);\n            int m = l + (r - l) / 2;\n            if (m >= s)\n            {\n                Update(s, e, val, rt << 1, l, m);\n            }\n            if (m + 1 <= e)\n            {\n                Update(s, e, val, rt << 1 | 1, m + 1, r);\n            }\n            PushUp(rt);\n        }\n\n        public int Query(int s, int e, int rt, int l, int r)\n        {\n            if (l >= s && r <= e)\n            {\n                return tree[rt];\n            }\n            PushDown(rt);\n            int ans = 0;\n            int m = l + (r - l) / 2;\n            if (m >= s)\n            {\n                ans = Math.Max(ans, Query(s, e, rt << 1, l, m));\n            }\n            if (m + 1 <= e)\n            {\n                ans = Math.Max(ans, Query(s, e, rt << 1 | 1, m + 1, r));\n            }\n            return ans;\n        }\n\n        private void PushUp(int rt)\n        {\n            tree[rt] = Math.Max(tree[rt << 1], tree[rt << 1 | 1]);\n        }\n\n        private void PushDown(int rt)\n        {\n            if (add[rt] != 0)\n            {\n                tree[rt << 1] = Math.Max(add[rt],tree[rt << 1]);\n                tree[rt << 1 | 1] = Math.Max(add[rt],tree[rt << 1 | 1]);\n                add[rt << 1] = Math.Max(add[rt],add[rt << 1]);\n                add[rt << 1 | 1] = Math.Max(add[rt],add[rt << 1 | 1]);\n                add[rt] = 0;\n            }\n        }\n    }\n    \n    class Treap<T> : IEnumerable<T>\n    {\n        private class TreapNode\n        {\n            public T val;\n            public long seed;\n            public int size;\n            public int count;\n            public TreapNode left;\n            public TreapNode right;\n\n            public TreapNode(T v, long seed)\n            {\n                this.val = v;\n                this.seed = seed;\n                this.count = 1;\n                this.size = 1;\n            }\n\n            public TreapNode LeftRotate()\n            {\n                int preSize = size;\n                int curSize = count + (left == null ? 0 : left.size) + (right.left == null ? 0 : right.left.size);\n                TreapNode newRoot = this.right;\n                this.right = newRoot.left;\n                newRoot.left = this;\n                newRoot.size = preSize;\n                size = curSize;\n                return newRoot;\n            }\n\n            public TreapNode RightRotate()\n            {\n                int preSize = size;\n                int curSize = count + (left.right == null ? 0 : left.right.size) + (right == null ? 0 : right.size);\n                TreapNode newRoot = this.left;\n                this.left = newRoot.right;\n                newRoot.right = this;\n                newRoot.size = preSize;\n                size = curSize;\n                return newRoot;\n            }\n\n            /// <summary>\n            /// recalculate size for current node\n            /// </summary>\n            public void RecalSize()\n            {\n                size = count + (left != null ? left.size : 0) + (right != null ? right.size : 0);\n            }\n        }\n\n        internal sealed class TreapRandom\n        {\n            private const int MOD = int.MaxValue;\n            private int _seed;\n\n            public TreapRandom(int seed = 703)\n            {\n                _seed = seed;\n            }\n\n            public int NextInt()\n            {\n                _seed = (int)((_seed * 48271L) % MOD);\n                return _seed;\n            }\n        }\n\n        internal sealed class MyComparer<W> : IComparer<W>\n        {\n            private Comparison<W> _comparision;\n\n            public MyComparer(Comparison<W> comparision)\n            {\n                _comparision = comparision;\n            }\n\n            public int Compare(W x, W y)\n            {\n                return _comparision(x, y);\n            }\n        }\n\n        private TreapNode _root;\n        private int _size;\n        private TreapRandom rand;\n        private IComparer<T> _comparer;\n\n        public Treap()\n            : this(Comparer<T>.Default)\n        {\n\n        }\n\n        public Treap(Comparison<T> comparison)\n            : this(new MyComparer<T>(comparison))\n        {\n\n        }\n\n        public Treap(IComparer<T> comparer)\n        {\n            _root = null;\n            _size = 0;\n            rand = new TreapRandom(1849);\n            _comparer = comparer == null ? Comparer<T>.Default : comparer;\n        }\n\n        public int Count\n        {\n            get { return _size; }\n        }\n\n        public bool LowerBound(T val, ref T lowerKey)\n        {\n            bool res = false;\n            TreapNode current = _root;\n            while (current != null)\n            {\n                int cmpRes = _comparer.Compare(val, current.val);\n                if (cmpRes > 0)\n                {\n                    current = current.right;\n                }\n                else if (cmpRes < 0)\n                {\n                    res = true;\n                    lowerKey = current.val;\n                    current = current.left;\n                }\n                else\n                {\n                    res = true;\n                    lowerKey = current.val;\n                    break;\n                }\n            }\n            return res;\n        }\n\n        public bool UpperBound(T val, ref T upperKey)\n        {\n            bool res = false;\n            TreapNode current = _root;\n            while (current != null)\n            {\n                int cmpRes = _comparer.Compare(val, current.val);\n                if (cmpRes < 0)\n                {\n                    current = current.left;\n                }\n                else if (cmpRes > 0)\n                {\n                    res = true;\n                    upperKey = current.val;\n                    current = current.right;\n                }\n                else\n                {\n                    res = true;\n                    upperKey = current.val;\n                    break;\n                }\n            }\n            return res;\n        }\n\n        public T GetValueByRank(int rank)\n        {\n            if (rank <= 0 || rank > _size)\n            {\n                throw new Exception(\"Rank can not be lower than 0 or higher than treap size\");\n            }\n            TreapNode current = _root;\n            int leftRank = current.left == null ? 0 : current.left.size;\n            int rightRank = leftRank + current.count;\n            while (rank <= leftRank || rank > rightRank)\n            {\n                if (rank <= leftRank)\n                {\n                    current = current.left;\n                }\n                else\n                {\n                    rank -= rightRank;\n                    current = current.right;\n                }\n                leftRank = current.left == null ? 0 : current.left.size;\n                rightRank = leftRank + current.count;\n            }\n            return current.val;\n        }\n\n        /// <summary>\n        /// \n        /// </summary>\n        /// <param name=\"val\"></param>\n        /// <param name=\"equal\"></param>\n        /// <returns></returns>\n        public int Rank(T val, bool isEqual = false)\n        {\n            int ans = 0;\n            TreapNode current = _root;\n            while (current != null)\n            {\n                int cmpRes = _comparer.Compare(current.val, val);\n                if (cmpRes > 0)\n                {\n                    current = current.left;\n                }\n                else\n                {\n                    ans += (current.left != null ? current.left.size : 0);\n                    if (cmpRes == 0)\n                    {\n                        return ans + (isEqual ? current.count : 1);\n                    }\n                    ans += current.count;\n                    current = current.right;\n                }\n            }\n            return ans;\n        }\n\n        public void Insert(T val)\n        {\n            _root = Insert(_root, val);\n            _size = _root.size;\n        }\n\n        public bool Contains(T key)\n        {\n            TreapNode current = _root;\n            while (current != null)\n            {\n                int cmpRes = _comparer.Compare(key, current.val);\n                if (cmpRes == 0)\n                {\n                    return true;\n                }\n                else if (cmpRes < 0)\n                {\n                    current = current.left;\n                }\n                else\n                {\n                    current = current.right;\n                }\n            }\n            return false;\n        }\n\n        public void Delete(T key)\n        {\n            _root = Delete(_root, key);\n            _size = _root == null ? 0 : _root.size;\n        }\n\n        private TreapNode Delete(TreapNode node, T key)\n        {\n            if (node == null)\n            {\n                return null;\n            }\n            int cmpRes = _comparer.Compare(node.val, key);\n            if (cmpRes < 0)\n            {\n                node.right = Delete(node.right, key);\n                node.RecalSize();\n            }\n            else if (cmpRes > 0)\n            {\n                node.left = Delete(node.left, key);\n                node.RecalSize();\n            }\n            else\n            {\n                if (node.count > 1)\n                {\n                    node.count--;\n                    node.RecalSize();\n                    return node;\n                }\n                if (node.left == null)\n                {\n                    return node.right;\n                }\n                if (node.right == null)\n                {\n                    return node.left;\n                }\n                if (node.left.seed < node.right.seed)\n                {\n                    node = node.RightRotate();\n                    node.right = Delete(node.right, key);\n                    node.RecalSize();\n                }\n                else\n                {\n                    node = node.LeftRotate();\n                    node.left = Delete(node.left, key);\n                    node.RecalSize();\n                }\n            }\n            return node;\n        }\n\n        private TreapNode Insert(TreapNode node, T key)\n        {\n            if (node == null)\n            {\n                return new TreapNode(key, rand.NextInt());\n            }\n            int res = _comparer.Compare(node.val, key);\n            if (res == 0)\n            {\n                node.count++;\n                node.RecalSize();\n            }\n            else if (res < 0)\n            {\n                node.right = Insert(node.right, key);\n                node.RecalSize();\n                if (node.right.seed < node.seed)\n                {\n                    node = node.LeftRotate();\n                }\n            }\n            else\n            {\n                node.left = Insert(node.left, key);\n                node.RecalSize();\n                if (node.left.seed < node.seed)\n                {\n                    node = node.RightRotate();\n                }\n            }\n            return node;\n        }\n\n        public T this[int idx]\n        {\n            get\n            {\n                return GetValueByRank(idx + 1);\n            }\n        }\n\n        IEnumerator IEnumerable.GetEnumerator()\n        {\n            if (_root == null)\n            {\n                yield break;\n            }\n            Stack<TreapNode> stack = new Stack<TreapNode>();\n            stack.Push(_root);\n            while (stack.Count > 0)\n            {\n                TreapNode current = stack.Pop();\n                if (current == null)\n                {\n                    current = stack.Pop();\n                    yield return current.val;\n                }\n                else\n                {\n                    if (current.right != null)\n                    {\n                        stack.Push(current.right);\n                    }\n                    stack.Push(current);\n                    stack.Push(null);\n                    if (current.left != null)\n                    {\n                        stack.Push(current.left);\n                    }\n                }\n            }\n        }\n\n        public IEnumerator<T> GetEnumerator()\n        {\n            if (_root == null)\n            {\n                yield break;\n            }\n            Stack<TreapNode> stack = new Stack<TreapNode>();\n            stack.Push(_root);\n            while (stack.Count > 0)\n            {\n                TreapNode current = stack.Pop();\n                if (current == null)\n                {\n                    current = stack.Pop();\n                    yield return current.val;\n                }\n                else\n                {\n                    if (current.right != null)\n                    {\n                        stack.Push(current.right);\n                    }\n                    stack.Push(current);\n                    stack.Push(null);\n                    if (current.left != null)\n                    {\n                        stack.Push(current.left);\n                    }\n                }\n            }\n        }\n    }\n}",
    "submit_ts": 1716651131.0
}