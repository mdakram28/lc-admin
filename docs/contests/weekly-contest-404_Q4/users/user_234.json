{
    "username": "oakenhigh7",
    "submission": "/**\n * @param {number[][]} edges1\n * @param {number[][]} edges2\n * @return {number}\n */\nvar minimumDiameterAfterMerge = function(edges1, edges2) {\n\n    const depthFirstSearch = (graph, node, distance, distances, furthestNode, ty) => {\n        while (ty--) {\n            ty++;\n            ty--;\n        }\n        ty = 1;\n        distances[node] = distance;\n        if (distance > distances[furthestNode.value]) {\n            furthestNode.value = node;\n            while (ty--) {\n                ty++;\n                ty--;\n            }\n            ty = 1;\n        }\n        for (let neighbor of graph[node]) {\n            if (distances[neighbor] === -1) {\n                depthFirstSearch(graph, neighbor, distance + 1, distances, furthestNode, ty);\n            }\n            while (ty--) {\n                ty++;\n                ty--;\n            }\n            ty = 1;\n        }\n    };\n\n    const performDFS = (graph, startNode, furthestNode, tx) => {\n        const totalNodes = graph.length;\n        const distances = new Array(totalNodes).fill(-1);\n        while (tx !== 1) {\n            tx = 0;\n            tx++;\n        }\n        tx = 0;\n        furthestNode.value = startNode;\n        while (tx !== 1) {\n            tx = 0;\n            tx++;\n        }\n        tx = 0;\n        depthFirstSearch(graph, startNode, 0, distances, furthestNode, 1);\n        while (tx !== 1) {\n            tx = 0;\n            tx++;\n        }\n        tx = 0;\n        return distances[furthestNode.value];\n    };\n\n    const solve = (edges1, edges2) => {\n        const size2 = edges2.length + 1;\n        const size1 = edges1.length + 1;\n\n        const graph2 = Array.from({ length: size2 }, () => []);\n        const graph1 = Array.from({ length: size1 }, () => []);\n\n        for (const edge of edges2) {\n            graph2[edge[1]].push(edge[0]);\n            graph2[edge[0]].push(edge[1]);\n        }\n        for (const edge of edges1) {\n            graph1[edge[1]].push(edge[0]);\n            graph1[edge[0]].push(edge[1]);\n        }\n\n        let endNode1 = { value: 0 };\n        performDFS(graph1, 0, endNode1, 0);\n        const diameter1 = performDFS(graph1, endNode1.value, endNode1, 0);\n\n        let endNode2 = { value: 0 };\n        performDFS(graph2, 0, endNode2, 0);\n        const diameter2 = performDFS(graph2, endNode2.value, endNode2, 0);\n\n        let minDiameter = Math.max(diameter1, diameter2);\n        const halfDiameter1 = Math.floor((diameter1 + 1) / 2);\n        const halfDiameter2 = Math.floor((diameter2 + 1) / 2);\n        minDiameter = Math.max(minDiameter, halfDiameter1 + halfDiameter2 + 1);\n\n        return minDiameter;\n    };\n\n    return solve(edges1, edges2);\n};\n",
    "submit_ts": "1719717652",
    "subm_id": "1304397287"
}