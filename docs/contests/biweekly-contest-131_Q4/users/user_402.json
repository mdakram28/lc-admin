{
    "username": "CutSandstone",
    "submission": "class Solution {\n    private class Node {\n        public long l, r;\n        public Node left, right;\n        public long val = 0, max = 0, min = 0, add = 0;\n        public boolean isSet = false;\n        public Node(long a, long b) {\n            l = a;\n            r = b;\n        }\n        public void set(long num) {\n            isSet = true;\n            add = max = min = num;\n            val = num*(r-l+1);\n        }\n        public void add(long num) {\n            add+=num;\n            val+=num*(r-l+1);\n            max+=num;\n            min+=num;\n        }\n        public void prop() {\n            long mid = (l+r)>>1;\n            if(left == null) left = new Node(l, mid);\n            if(right == null) right = new Node(mid+1, r);\n            if(isSet) {\n                isSet = false;\n                if(l != r) {\n                    left.set(add);\n                    right.set(add);\n                }\n            }else if(add != 0) {\n                if(l != r) {\n                    left.add(add);\n                    right.add(add);\n                }\n            }\n            add = 0;\n        }\n        public void upd() {\n            val = left.val+right.val;\n            min = Math.min(left.min, right.min);\n            max = Math.max(left.max, right.max);\n        }\n    }\n    Node top;\n    void init(long N){\n        assert(N > 0);\n        top = new Node(0, N-1);\n    }\n    private void set(long s, long e, long num, Node curr) {\n        if(curr.l == s && curr.r == e) {\n            curr.set(num);\n            return;\n        }\n        curr.prop();\n        if(e <= curr.left.r) set(s, e, num, curr.left);\n        else if(s >= curr.right.l) set(s, e, num, curr.right);\n        else{\n            set(s, curr.left.r, num, curr.left);\n            set(curr.right.l, e, num, curr.right);\n        }\n        curr.upd();\n    }\n    private void add(long s, long e, long num, Node curr) {\n        if(curr.l == s && curr.r == e) {\n            curr.add(num);\n            return;\n        }\n        curr.prop();\n        if(e <= curr.left.r) add(s, e, num, curr.left);\n        else if(s >= curr.right.l) add(s, e, num, curr.right);\n        else{\n            add(s, curr.left.r, num, curr.left);\n            add(curr.right.l, e, num, curr.right);\n        }\n        curr.upd();\n    }\n    private long sum(long s, long e, Node curr) {\n        if(curr.l == s && curr.r == e) return curr.val;\n        curr.prop();\n        if(e <= curr.left.r) return sum(s, e, curr.left);\n        if(s >= curr.right.l) return sum(s, e, curr.right);\n        return sum(s, curr.left.r, curr.left)+sum(curr.right.l, e, curr.right);\n    }\n    private long max(long s, long e, Node curr) {\n        if(curr.l == s && curr.r == e) return curr.max;\n        curr.prop();\n        if(e <= curr.left.r) return max(s, e, curr.left);\n        if(s >= curr.right.l) return max(s, e, curr.right);\n        return Math.max(max(s, curr.left.r, curr.left), max(curr.right.l, e, curr.right));\n    }\n    private long min(long s, long e, Node curr) {\n        if(curr.l == s && curr.r == e) return curr.min;\n        curr.prop();\n        if(e <= curr.left.r) return min(s, e, curr.left);\n        if(s >= curr.right.l) return min(s, e, curr.right);\n        return Math.min(min(s, curr.left.r, curr.left), min(curr.right.l, e, curr.right));\n    }\n    public long get(long s) {\n        assert(s >= top.l && s <= top.r);\n        Node curr = top;\n        LinkedList<Node> stk = new LinkedList<>();\n        while(curr.l != curr.r) {\n            stk.push(curr);\n            curr.prop();\n            if(s <= curr.left.r) curr = curr.left;\n            else curr = curr.right;\n        }\n        while(!stk.isEmpty()) stk.pop().upd();\n        return curr.val;\n    }\n    public long sum(long s, long e) {\n        assert(s >= top.l && s <= top.r && e >= top.l && e <= top.r && s <= e);\n        return sum(s, e, top);\n    }\n    public long max(long s, long e) {\n        assert(s >= top.l && s <= top.r && e >= top.l && e <= top.r && s <= e);\n        return max(s, e, top);\n    }\n    public long min(long s, long e) {\n        assert(s >= top.l && s <= top.r && e >= top.l && e <= top.r && s <= e);\n        return min(s, e, top);\n    }\n    public void add(long s, long e, long num) {\n        assert(s >= top.l && s <= top.r && e >= top.l && e <= top.r && s <= e);\n        add(s, e, num, top);\n    }\n    public void add(long s, long num) {\n        assert(s >= top.l && s <= top.r);\n        add(s, s, num);\n    }\n    public void set(long s, long e, long num) {\n        assert(s >= top.l && s <= top.r && e >= top.l && e <= top.r && s <= e);\n        set(s, e, num, top);\n    }\n    public void set(long s, long num) {\n        assert(s >= top.l && s <= top.r);\n        set(s, s, num);\n    }\n    public List<Boolean> getResults(int[][] queries) {\n        List<Boolean> ans = new ArrayList<>();\n        int mx = 0;\n        for(int[] a: queries) mx = Math.max(mx,a[1]);\n        init(mx+2);\n        TreeSet<Integer> blocks = new TreeSet<>();\n        blocks.add(mx+1);\n        for(int i = 0; i<=mx; i++) set(i,i);\n        for(int[] a: queries){\n            if(a[0] == 1){\n                int next = blocks.higher(a[1]);\n                blocks.add(a[1]);\n                add(a[1]+1,next,-get(a[1]));\n            }else{\n                ans.add(max(0,a[1]) >= a[2]);\n            }\n        }\n        return ans;\n    }\n}",
    "submit_ts": 1716649729.0
}