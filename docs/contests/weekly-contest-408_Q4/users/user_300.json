{
    "username": "myselfshivams",
    "submission": "import Foundation\n\nclass Solution {\n    private func bfs(graph: [[Int]], startNode: Int, target1: Int, target2: Int, totalNodes: Int) -> Bool {\n        var queue: [Int] = [startNode]\n        var visited: [Bool] = Array(repeating: false, count: totalNodes + 4)\n        visited[startNode] = true\n        \n        while !queue.isEmpty {\n            let currentNode = queue.removeFirst()\n            var neighborIndex = 0\n            while neighborIndex < graph[currentNode].count {\n                let neighbor = graph[currentNode][neighborIndex]\n                if !visited[neighbor] {\n                    queue.append(neighbor)\n                    visited[neighbor] = true\n                }\n                neighborIndex += 1\n            }\n        }\n        \n        return visited[target1] || visited[target2]\n    }\n\n    func canReachCorner(_ targetX: Int, _ targetY: Int, _ circles: [[Int]]) -> Bool {\n        let numberOfCircles = circles.count\n        var circleDetails: [[Int]] = []\n        var adjacencyList: [[Int]] = Array(repeating: [], count: numberOfCircles + 4)\n        \n   \n        for index in 0..<numberOfCircles {\n            let circle = circles[index]\n            circleDetails.append(circle)\n        }\n        \n        for currentIndex in 0..<numberOfCircles {\n            let currentCircle = circleDetails[currentIndex]\n            let centerX = currentCircle[0]\n            let centerY = currentCircle[1]\n            let radius = currentCircle[2]\n            \n            if centerX <= radius {\n                adjacencyList[numberOfCircles].append(currentIndex)\n                adjacencyList[currentIndex].append(numberOfCircles)\n            }\n            if targetX - centerX <= radius {\n                adjacencyList[numberOfCircles + 2].append(currentIndex)\n                adjacencyList[currentIndex].append(numberOfCircles + 2)\n            }\n            if centerY <= radius {\n                adjacencyList[numberOfCircles + 1].append(currentIndex)\n                adjacencyList[currentIndex].append(numberOfCircles + 1)\n            }\n            if targetY - centerY <= radius {\n                adjacencyList[numberOfCircles + 3].append(currentIndex)\n                adjacencyList[currentIndex].append(numberOfCircles + 3)\n            }\n            \n            for otherIndex in (currentIndex + 1)..<numberOfCircles {\n                let otherCircle = circleDetails[otherIndex]\n                let centerX2 = otherCircle[0]\n                let centerY2 = otherCircle[1]\n                let radius2 = otherCircle[2]\n                let distance = sqrt(pow(Double(centerX - centerX2), 2) + pow(Double(centerY - centerY2), 2))\n                let radiusSum = radius + radius2\n                if Double(radiusSum) >= distance {\n                    adjacencyList[currentIndex].append(otherIndex)\n                    adjacencyList[otherIndex].append(currentIndex)\n                }\n            }\n        }\n        \n        let isPathBlocked = bfs(graph: adjacencyList, startNode: numberOfCircles, target1: numberOfCircles + 1, target2: numberOfCircles + 2, totalNodes: numberOfCircles + 4) ||\n                            bfs(graph: adjacencyList, startNode: numberOfCircles + 3, target1: numberOfCircles + 2, target2: numberOfCircles + 1, totalNodes: numberOfCircles + 4)\n        \n        return !isPathBlocked\n    }\n}\n",
    "submit_ts": "1722136829",
    "subm_id": "1335746176"
}