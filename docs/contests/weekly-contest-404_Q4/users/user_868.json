{
    "username": "NDR0216",
    "submission": "class Solution {\npublic:\n    int diameter(vector<vector<int>>& edges) {\n        \n        int n = edges.size()+1;\n\n        // Kahn\n        vector<int>* graph = new vector<int>[n];\n        int* degree = new int[n]();\n\n        for (int i = 0; i < edges.size(); i++) {\n            int a_i = edges[i][0];\n            int b_i = edges[i][1];\n\n            graph[a_i].push_back(b_i);\n            graph[b_i].push_back(a_i);\n            degree[a_i] += 1;\n            degree[b_i] += 1;\n        }\n\n        queue<int> leaves;\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 1) {\n                leaves.push(i);\n            }\n        }\n\n        int diameter = 0;\n        while (n > 2) {\n            for (int _ = leaves.size(); _ > 0; _--) {\n                int v = leaves.front();\n                leaves.pop();\n\n                n--;\n\n                for (int i = 0; i < graph[v].size(); i++) {\n                    int u = graph[v][i];\n\n                    degree[u] -= 1;\n\n                    if (degree[u] == 1) {\n                        leaves.push(u);\n                    }\n                }\n            }\n            diameter+=2;\n        }\n        \n        return diameter + n-1;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int d1 = diameter(edges1); \n        int d2 = diameter(edges2); \n        \n        if (d1 < 2 && d2 < 2) {\n            return d1+d2+1;\n        }\n        \n        // cout << diameter(edges1);\n        //  cout << diameter(edges2);\n        \n        if (d1/2 >= (d2+1)/2+1) {\n            return d1;\n        } else if (d2/2 >= (d1+1)/2+1) {\n            return d2;\n        } else {\n            return (d1+1)/2 + (d2+1)/2 +1;\n        }\n        \n        return 0;\n    }\n};",
    "submit_ts": 1719719633.0
}