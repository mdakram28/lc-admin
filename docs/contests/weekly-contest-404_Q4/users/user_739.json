{
    "username": "yunjiexiao13",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        n = len(edges1) + 1\n        m = len(edges2) + 1\n        g1 = [[] for _ in range(n)]\n        g2 = [[] for _ in range(m)]\n        for x,y in edges1:\n            g1[x].append(y)\n            g1[y].append(x)\n        for x,y in edges2: \n            g2[x].append(y)\n            g2[y].append(x)\n        parents = [0]*n\n        def bfs(start,N,g):\n            vis = [False] * N\n            vis[start] = True\n            q = deque([start])\n            while q:\n                x = q.popleft()\n                for y in g[x]:\n                    if not vis[y]:\n                        parents[y] =  x\n                        vis[y] = True\n                        q.append(y)\n            return x\n        x = bfs(0,n,g1)\n        y = bfs(x,n,g1)\n        d1 = -1\n        parents[x] = -1\n        while y != -1:\n            y = parents[y]\n            d1 += 1\n        parents = [0]*m\n        x = bfs(0,m,g2)\n        y = bfs(x,m,g2)\n        d2 = -1\n        parents[x] = -1\n        while y != -1:\n            y = parents[y]\n            d2 += 1\n        r1 = (d1 + 1)//2\n        r2 = (d2 + 1)//2\n        return max(r1 + r2 + 1,d1,d2)",
    "submit_ts": 1719718823.0
}