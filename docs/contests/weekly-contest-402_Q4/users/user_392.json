{
    "username": "realstar",
    "submission": "class Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int[] arr = new int[n];\n        for (int i = 1; i < n - 1; i++) {\n        \tif (nums[i] > nums[i - 1] && nums[i] > nums[i + 1])\n        \t\tarr[i] = 1;\n        }\n        SegmentTree tree = new SegmentTree(arr, n);\n        List<Integer> list = new ArrayList();\n        \n        for (int[] query : queries) {\n        \tif (query[0] == 1) {\n        \t\tquery[1]++;\n        \t\tquery[2]--;\n        \t\tif (query[1] > query[2])\n        \t\t\tlist.add(0);\n        \t\telse\n        \t\t\tlist.add(tree.getSum(n, query[1], query[2]));\n        \t} else {\n        \t\tint index = query[1];\n        \t\tnums[index] = query[2];\n        \t\tint newValue = (index > 0 && index < n - 1 && nums[index] > nums[index - 1] && nums[index] > nums[index + 1]) ? 1 : 0;\n        \t\ttree.updateValue(arr, n, index, newValue);\n        \t\tif (index > 0) {\n        \t\t\tint prev = index - 1;\n        \t\t\tnewValue = (prev > 0 && prev < n - 1 && nums[prev] > nums[prev - 1] && nums[prev] > nums[prev + 1]) ? 1 : 0;\n            \t\ttree.updateValue(arr, n, prev, newValue);\n        \t\t}\n        \t\tif (index < n - 1) {\n        \t\t\tint next = index + 1;\n        \t\t\tnewValue = (next > 0 && next < n - 1 && nums[next] > nums[next - 1] && nums[next] > nums[next + 1]) ? 1 : 0;\n            \t\ttree.updateValue(arr, n, next, newValue);\n        \t\t}\n        \t}\n        }\n        \n        return list;\n    }\n}\n\nclass SegmentTree\n{\n    int st[]; \n    \n    SegmentTree(int arr[], int n)\n    {\n        int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));\n \n        int max_size = 2 * (int) Math.pow(2, x) - 1;\n \n        st = new int[max_size]; \n \n        constructSTUtil(arr, 0, n - 1, 0);\n    }\n \n    int getMid(int s, int e) {\n        return s + (e - s) / 2;\n    }\n \n    int getSumUtil(int ss, int se, int qs, int qe, int si)\n    {\n        if (qs <= ss && qe >= se)\n            return st[si];\n \n        if (se < qs || ss > qe)\n            return 0;\n \n        int mid = getMid(ss, se);\n        return getSumUtil(ss, mid, qs, qe, 2 * si + 1) +\n                getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);\n    }\n \n    void updateValueUtil(int ss, int se, int i, int diff, int si)\n    {\n        if (i < ss || i > se)\n            return;\n \n        st[si] = st[si] + diff;\n        if (se != ss) {\n            int mid = getMid(ss, se);\n            updateValueUtil(ss, mid, i, diff, 2 * si + 1);\n            updateValueUtil(mid + 1, se, i, diff, 2 * si + 2);\n        }\n    }\n \n    void updateValue(int arr[], int n, int i, int new_val)\n    {\n        if (i < 0 || i > n - 1) {\n            System.out.println(\"Invalid Input\");\n            return;\n        }\n \n        int diff = new_val - arr[i];\n \n        arr[i] = new_val;\n \n        updateValueUtil(0, n - 1, i, diff, 0);\n    }\n \n    int getSum(int n, int qs, int qe)\n    {\n        if (qs < 0 || qe > n - 1 || qs > qe) {\n            System.out.println(\"Invalid Input\");\n            return -1;\n        }\n        return getSumUtil(0, n - 1, qs, qe, 0);\n    }\n \n    int constructSTUtil(int arr[], int ss, int se, int si)\n    {\n        if (ss == se) {\n            st[si] = arr[ss];\n            return arr[ss];\n        }\n        int mid = getMid(ss, se);\n        st[si] = constructSTUtil(arr, ss, mid, si * 2 + 1) +\n                 constructSTUtil(arr, mid + 1, se, si * 2 + 2);\n        return st[si];\n    }\n \n}",
    "submit_ts": "1718507411",
    "subm_id": "1289650780"
}