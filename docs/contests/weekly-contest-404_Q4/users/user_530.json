{
    "username": "BytefulRashi",
    "submission": "#include <vector>\n#include <queue>\n#include <algorithm> \n#include <utility>   \n\nusing namespace std;\n\nclass Solution {\npublic:\n    // Function to calculate the diameter of a graph\n    int calculateDiameter(const vector<vector<int>>& edges) {\n        int numNodes = edges.size() + 1;\n        vector<vector<int>> adjacencyList(numNodes);\n        for (const auto& edge : edges) {\n            int u = edge[0], v = edge[1];\n            adjacencyList[u].push_back(v);\n            adjacencyList[v].push_back(u);\n        }\n        \n        auto bfs = [&](int start) {\n            vector<int> distance(numNodes, -1);\n            queue<int> q;\n            q.push(start);\n            distance[start] = 0;\n            int farthestNode = start;\n            while (!q.empty()) {\n                int node = q.front();\n                q.pop();\n                for (int neighbor : adjacencyList[node]) {\n                    if (distance[neighbor] == -1) {\n                        distance[neighbor] = distance[node] + 1;\n                        q.push(neighbor);\n                        if (distance[neighbor] > distance[farthestNode]) {\n                            farthestNode = neighbor;\n                        }\n                    }\n                }\n            }\n            return make_pair(farthestNode, distance[farthestNode]);\n        };\n        \n        int startNode = bfs(0).first;\n        int diameter = bfs(startNode).second;\n        return diameter;\n    }\n    \n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n   \n        int diameter1 = calculateDiameter(edges1);\n        int diameter2 = calculateDiameter(edges2);\n\n        return max({diameter1, diameter2, (diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1});\n    }\n};\n",
    "submit_ts": "1719718318",
    "subm_id": "1304414225"
}