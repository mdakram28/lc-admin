{
    "username": "gary_34",
    "submission": "class Solution {\n    vector<vector<int>> next1;\n    vector<vector<int>> next2;\n    int mnD1 = INT_MAX;\n    int mnD2 = INT_MAX;\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        next1.resize(100005);\n        next2.resize(100005);\n        for (auto edge: edges1)\n        {\n            int a = edge[0], b = edge[1];\n            next1[a].push_back(b);\n            next1[b].push_back(a);\n        }\n        for (auto edge: edges2)\n        {\n            int a = edge[0], b = edge[1];\n            next2[a].push_back(b);\n            next2[b].push_back(a);\n        }\n        int dia1 = getdia(next1);\n        int dia2 = getdia(next2);\n        int mx = max(dia1, dia2);\n        if (dia1 % 2 == 0) dia1 /= 2;\n        else dia1 = dia1/2 + 1;\n        if (dia2 % 2 == 0) dia2 /= 2;\n        else dia2 = dia2/2 + 1;\n        return max(dia1 + dia2 + 1, mx);\n    }\n    int getdia(vector<vector<int>>& next) {\n        int farest = 0;\n        queue<int> q;\n        vector<int> visited(100005);\n        visited[0] = 1;\n        for (auto nxt: next[0])\n            q.push(nxt);\n        \n        while (!q.empty())\n        {\n            int len = q.size();\n            while (len--)\n            {\n                int cur = q.front();\n                visited[cur] = 1;\n                farest = cur;\n                q.pop();\n                for (auto nxt: next[cur])\n                {\n                    if (visited[nxt] == 1) continue;\n                    \n                    q.push(nxt);\n                }\n            }\n        }\n        return bfs(next, farest);\n    }\n    int bfs(vector<vector<int>>& next, int start)\n    {\n        queue<int> q;\n        vector<int> visited(100005);\n        visited[start] = 1;\n        for (auto nxt: next[start])\n            q.push(nxt);\n        int dia = 0;\n        while (!q.empty())\n        {\n            dia++;\n            int len = q.size();\n            while (len--)\n            {\n                int cur = q.front();\n                visited[cur] = 1;\n                q.pop();\n                for (auto nxt: next[cur])\n                {\n                    if (visited[nxt] == 1) continue;\n                    q.push(nxt);\n                }\n            }\n        }\n        return dia;\n    }\n};",
    "submit_ts": "1719719222",
    "subm_id": "1304436676"
}