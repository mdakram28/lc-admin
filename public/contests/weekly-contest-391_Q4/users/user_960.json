{
    "username": "sdckivenchen",
    "submission": "class Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        def calculate_max_dist(points, ri):\n            ub = [float('-inf')] * 4  # max(x+y), max(x-y), max(y-x), max(-x-y)\n            lb = [float('inf')] * 4  # min(x+y), min(x-y), min(y-x), min(-x-y)\n\n            for i, (x, y) in enumerate(points):\n                if i == ri: continue\n                for i, f in enumerate((x+y, x-y, y-x, -x-y)):\n                    ub[i] = max(ub[i], f)\n                    lb[i] = min(lb[i], f)\n\n            # Compute the Manhattan distance using the expression extrema\n            max_distance = 0\n            for i in range(4):\n                max_distance = max(max_distance, ub[i] - lb[i])\n\n            return max_distance\n\n        transform = [(p[0] + p[1], p[0] - p[1], -p[0] + p[1], -p[0] - p[1], i) for i, p in enumerate(points)]\n        \n        sort_by_sum = sorted(transform, key=lambda x: x[0])\n        sort_by_diff = sorted(transform, key=lambda x: x[1])\n        sort_by_inv_sum = sorted(transform, key=lambda x: x[2])\n        sort_by_inv_diff = sorted(transform, key=lambda x: x[3])\n\n        # Add the extreme points from each sorted array to the candidates\n        candidates = [sort_by_sum[0][4], sort_by_sum[-1][4],\n                      sort_by_diff[0][4], sort_by_diff[-1][4],\n                      sort_by_inv_sum[0][4], sort_by_inv_sum[-1][4],\n                      sort_by_inv_diff[0][4], sort_by_inv_diff[-1][4]]\n\n        max_dist = calculate_max_dist(points, None)\n        min_max_dist_after_removal = max_dist\n\n        for ri in candidates:\n            max_dist_after_removal = calculate_max_dist(points, ri)\n            min_max_dist_after_removal = min(min_max_dist_after_removal, max_dist_after_removal)\n    \n        return min_max_dist_after_removal\n"
}