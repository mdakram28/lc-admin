{
    "username": "DedsecKnight",
    "submission": "class Solution {\nprivate:\n    struct Tree {\n        typedef int T;\n        static constexpr T unit = 0;\n        T f(T a, T b) { return a + b; } // (any associative fn)\n        vector<T> s; int n;\n        Tree(int n = 0, T def = unit) : s(2*n, def), n(n) {}\n        void update(int pos, T val) {\n            for (s[pos += n] = val; pos /= 2;)\n                s[pos] = f(s[pos * 2], s[pos * 2 + 1]);\n        }\n        T query(int b, int e) { // query [b, e)\n            T ra = unit, rb = unit;\n            for (b += n, e += n; b < e; b /= 2, e /= 2) {\n                if (b % 2) ra = f(ra, s[b++]);\n                if (e % 2) rb = f(s[--e], rb);\n            }\n            return f(ra, rb);\n\t}};\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = int(nums.size());\n        Tree tree{n};\n        for (int i = 1; i<n-1; i++) {\n            if (nums[i] > nums[i-1] && nums[i] > nums[i+1]) {\n                tree.update(i, 1);\n            }\n        }\n        vector<int> ret;\n        for (const auto& q : queries) {\n            if (q[0] == 1) {\n                int curr_ans = tree.query(q[1], q[2] + 1);\n                if (q[2] + 1 < n && q[2] - 1 >= 0 && nums[q[2]] > nums[q[2]-1] && nums[q[2]] > nums[q[2]+1]) {\n                    curr_ans--;\n                }\n                if (q[1] != q[2] && q[1] + 1 < n && q[1] - 1 >= 0 && nums[q[1]] > nums[q[1]-1] && nums[q[1]] > nums[q[1]+1]) {\n                    curr_ans--;\n                }\n                ret.push_back(curr_ans);\n            } else {\n                int i = q[1];\n                if (i-1 >= 1 && nums[i-1] > nums[i-2] && nums[i-1] > q[2]) {\n                    tree.update(i-1, 1);\n                } else if (i-1 >= 0) {\n                    tree.update(i-1, 0);\n                }               \n                if (i+2 < n && nums[i+1] > nums[i+2] && nums[i+1] > q[2]) {\n                    tree.update(i+1, 1);\n                } else if (i+1 < n) {\n                    tree.update(i+1, 0);\n                }\n                if (i >= 1 && i + 1 < n && q[2] > nums[i-1] && q[2] > nums[i+1]) {\n                    tree.update(i, 1);\n                } else {\n                    tree.update(i, 0);\n                }\n                nums[i] = q[2];\n            }\n            \n        }\n        return ret;\n    }\n};",
    "submit_ts": 1718507218.0
}