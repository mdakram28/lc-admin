{
    "username": "wanderingCicada",
    "submission": "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n\n        # nums[i] = 20\n        # nums[i - 1] = 30\n\n        # 0, 20 -> prev combos with 0, 30\n        # 11, 19 -> prev combos with 0, 20 or 1, 19\n\n        #at index k where nums[k] = x\n        #total number of possible arr1 and arr2 combos up until index k =\n        #possible arr1's and arr2's that contain a arr1[k]= 0, arr2[k] = x\n        #arr1[k] = 1, arr2[k] = x - 1\n\n        #in order to figure out how many possible arrays can end with arr1[k] = y and arr2[k] = x - y, we need to figure out how many arr1[k - 1] , and arr2[k - 1] combos\n        #work with this new arr1[k], arr2[k] combo\n        modulo = 10 ** 9 + 7\n        memo = [[] for i in range(len(nums))]\n        for index, num in enumerate(nums):\n            possibleCombinations = 0\n            if index == 0 or num <= nums[index - 1]:\n                for oneValue in range(num + 1):\n                    twoValue = num - oneValue\n                    if index == 0:\n                        possibleCombinations = 1\n                    else:\n                        possibleCombinations += memo[index - 1][oneValue]\n                    memo[index].append(possibleCombinations % modulo)\n            else:\n                memo[index] = [0] * (num + 1)\n                for twoValue in range(nums[index - 1], -1, -1):\n                    oneValue = num - twoValue\n                    possibleCombinations += memo[index - 1][oneValue - (num - nums[index - 1])]\n                    memo[index][oneValue] = possibleCombinations\n                \n        return sum(memo[-1]) % modulo",
    "submit_ts": "1723346994",
    "subm_id": "1351589660"
}