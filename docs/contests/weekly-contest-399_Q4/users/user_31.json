{
    "username": "Wibo",
    "submission": "class Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        \n        struct node {\n            long long ans[4];\n            bool valid = false;\n            node() {}\n            node(long long val) {\n                ans[0] = 0;\n                ans[1] = ans[2] = -1e15;\n                ans[3] = val;\n                valid = true;\n            }\n        };\n        auto merge = [&](node l, node r) -> node {\n            if (!l.valid) return r;\n            if (!r.valid) return l;\n            node ret;\n            ret.ans[0] = max({l.ans[1] + r.ans[0], l.ans[0] + max(r.ans[0], r.ans[2])});\n            ret.ans[1] = max({r.ans[1] + max(l.ans[0], l.ans[1]), r.ans[3] + l.ans[0]});\n            ret.ans[2] = max({l.ans[2] + max(r.ans[0], r.ans[2]), l.ans[3] + r.ans[0]});\n            ret.ans[3] = max({l.ans[2] + max(r.ans[1], r.ans[3]), l.ans[3] + r.ans[1]});\n            ret.valid = true;\n            return ret;\n        };\n        \n        vector<node> tree(4*n);\n        auto build = [&](auto self, int l, int r, int v) -> void {\n            if (l == r) tree[v] = node(nums[l]);\n            else {\n                int mid = (l+r)/2;\n                self(self, l, mid, v*2);\n                self(self, mid+1, r, v*2+1);\n                tree[v] = merge(tree[v*2], tree[v*2+1]);\n            }\n        };\n        build(build, 0, n-1, 1);\n        auto update = [&](auto self, int pos, long long val, int l, int r, int v) -> void {\n            if (l == r) tree[v] = node(val);\n            else {\n                int mid = (l+r)/2;\n                if (pos <= mid) self(self, pos, val, l, mid, v*2);\n                else self(self, pos, val, mid+1, r, v*2+1);\n                tree[v] = merge(tree[v*2], tree[v*2+1]);\n            }\n        };\n        auto query = [&](auto self, int ql, int qr, int l, int r, int v) -> node {\n            if (r < ql || l > qr) return node();\n            if (l >= ql && r <= qr) return tree[v];\n            int mid = (l+r)/2;\n            return merge(self(self, ql, qr, l, mid, v*2), self(self, ql, qr, mid+1, r, v*2+1));\n        };\n        auto final_ans = [&](node v) -> long long {\n            return max({v.ans[0], v.ans[1], v.ans[2], v.ans[3]});\n        };\n        \n        // cout << final_ans(tree[0]) << '\\n';\n        // for (int i=0; i<n; i++) {\n        //     for (int j=i; j<n; j++) {\n        //         cout << final_ans(query(query, i, j, 0, n-1, 1)) << ' ';\n        //     }\n        //     cout << '\\n';\n        // }\n        \n        long long ans = 0;\n        for (auto &q : queries) {\n            int pos = q[0], val = q[1];\n            update(update, pos, val, 0, n-1, 1);\n            ans += final_ans(tree[1]);\n        }\n        \n        return ans % 1000000007;\n    }\n};",
    "submit_ts": 1716692638.0
}