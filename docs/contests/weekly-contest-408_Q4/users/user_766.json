{
    "username": "Abhineet309",
    "submission": "from collections import deque\nimport math\nimport itertools\nimport functools\nimport operator\nimport sys\n\nclass Solution:\n    def canReachCorner(self, grid_width, grid_height, circle_data):\n        def euclidean_distance_calculator(point_a, point_b):\n            return math.sqrt(sum((a - b) ** 2 for a, b in zip(point_a, point_b)))\n\n        def circle_intersection_checker(circle_one, circle_two):\n            center_distance = euclidean_distance_calculator(circle_one[:2], circle_two[:2])\n            radii_sum = circle_one[2] + circle_two[2]\n            return radii_sum >= center_distance\n\n        def graph_explorer(adjacency_matrix, starting_vertex, target_vertex_alpha, target_vertex_beta, total_vertex_count):\n            vertices_to_visit = deque([starting_vertex])\n            visited_vertices = [0] * (total_vertex_count + 4)\n            visited_vertices[starting_vertex] = 1\n            \n            while vertices_to_visit:\n                current_vertex = vertices_to_visit.popleft()\n                for adjacent_vertex in adjacency_matrix[current_vertex]:\n                    if not visited_vertices[adjacent_vertex]:\n                        vertices_to_visit.append(adjacent_vertex)\n                        visited_vertices[adjacent_vertex] = 1\n            \n            return functools.reduce(operator.or_, [visited_vertices[target_vertex_alpha], visited_vertices[target_vertex_beta]])\n\n        total_circle_count = len(circle_data)\n        graph_adjacency_list = [[] for _ in range(total_circle_count + 4)]\n\n        # Construct the graph\n        for circle_index, circle_properties in enumerate(circle_data):\n            circle_x, circle_y, circle_radius = circle_properties\n            \n            # Check for intersections with grid boundaries\n            boundary_conditions = [\n                (circle_x <= circle_radius, total_circle_count),\n                (grid_width - circle_x <= circle_radius, total_circle_count + 2),\n                (circle_y <= circle_radius, total_circle_count + 1),\n                (grid_height - circle_y <= circle_radius, total_circle_count + 3)\n            ]\n            \n            for condition, boundary_vertex in boundary_conditions:\n                if condition:\n                    graph_adjacency_list[boundary_vertex].append(circle_index)\n                    graph_adjacency_list[circle_index].append(boundary_vertex)\n            \n            # Check for intersections with other circles\n            for comparison_circle_index in range(circle_index + 1, total_circle_count):\n                if circle_intersection_checker(circle_properties, circle_data[comparison_circle_index]):\n                    graph_adjacency_list[circle_index].append(comparison_circle_index)\n                    graph_adjacency_list[comparison_circle_index].append(circle_index)\n\n        # Check for path blockage\n        blockage_indicator = 0\n        corner_checks = [\n            (total_circle_count, total_circle_count + 1, total_circle_count + 2),  # bottom-left corner\n            (total_circle_count + 3, total_circle_count + 2, total_circle_count + 1)  # top-right corner\n        ]\n        \n        for start, target1, target2 in corner_checks:\n            blockage_indicator = max(blockage_indicator, \n                                     graph_explorer(graph_adjacency_list, start, target1, target2, total_circle_count + 4))\n\n        return blockage_indicator == 0\n\n    @staticmethod\n    def performance_timer(func):\n        import time\n        def wrapper(*args, **kwargs):\n            start_time = time.time()\n            result = func(*args, **kwargs)\n            end_time = time.time()\n            print(f\"Function {func.__name__} took {end_time - start_time:.6f} seconds to execute.\")\n            return result\n        return wrapper\n\n    @performance_timer\n    def optimized_canReachCorner(self, *args):\n        return self.canReachCorner(*args)\n\n# Additional utility functions (not used in the main logic)\ndef generate_random_circles(num_circles, max_x, max_y, max_radius):\n    import random\n    return [(random.randint(0, max_x), random.randint(0, max_y), random.randint(1, max_radius)) for _ in range(num_circles)]\n\ndef visualize_circles(grid_width, grid_height, circles):\n    import matplotlib.pyplot as plt\n    fig, ax = plt.subplots()\n    ax.set_xlim(0, grid_width)\n    ax.set_ylim(0, grid_height)\n    for x, y, r in circles:\n        circle = plt.Circle((x, y), r, fill=False)\n        ax.add_artist(circle)\n    plt.show()\n\n# Example usage (commented out to avoid execution)\n# if __name__ == \"__main__\":\n#     solver = Solution()\n#     grid_width, grid_height = 100, 100\n#     circles = generate_random_circles(10, grid_width, grid_height, 20)\n#     result = solver.optimized_canReachCorner(grid_width, grid_height, circles)\n#     print(f\"Can reach corner: {result}\")\n#     visualize_circles(grid_width, grid_height, circles)",
    "submit_ts": "1722138848",
    "subm_id": "1335801264"
}