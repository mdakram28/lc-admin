{
    "username": "singla__rohan",
    "submission": "int findTreeDiameter(vector<vector<int>>& connections, int nodes) {\n    if (nodes == 0) return 0;\n\n    vector<vector<int>> graph(nodes);\n    for (auto& edge : connections) {\n        graph[edge[0]].push_back(edge[1]);\n        graph[edge[1]].push_back(edge[0]);\n    }\n\n    auto dfs = [&](int start, int parent, vector<vector<int>>& adj, int& maxDistance, int& farthest, int distance, auto& dfs_ref) -> void {\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthest = start;\n        }\n        for (int neighbor : adj[start]) {\n            if (neighbor != parent) {\n                dfs_ref(neighbor, start, adj, maxDistance, farthest, distance + 1, dfs_ref);\n            }\n        }\n    };\n\n    int maxDistance = 0;\n    int farthestNode = 0;\n    dfs(0, -1, graph, maxDistance, farthestNode, 0, dfs);\n\n    maxDistance = 0;\n    dfs(farthestNode, -1, graph, maxDistance, farthestNode, 0, dfs);\n\n    return maxDistance;\n}\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int a = findTreeDiameter(edges1, edges1.size() + 1);\n        int b = findTreeDiameter(edges2, edges2.size() + 1);\n        int ans = 1 + (ceil(a/2.0) + ceil(b/2.0));\n\n        return max(a, max(b, ans));\n    }\n};",
    "submit_ts": "1719715304",
    "subm_id": "1304333258"
}