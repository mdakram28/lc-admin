{
    "username": "JJZin",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        global matrix\n        \n        matrix = 0\n   \n        @cache\n        def deepfucc(node, para):\n            global matrix\n            \n            \n            ans = 0\n            basons = []\n            for ea in conns[node]:\n                if ea == para:\n                    continue\n                    \n                basons.append(1 + deepfucc(ea, node))\n                ans = max(ans, 1 + deepfucc(ea, node))\n            basons.sort()\n            matrix = max(matrix, sum(basons[-2:]))\n            \n            return ans\n        \n        c1 = defaultdict(list)\n        for ea, jh in edges1:\n            c1[ea].append(jh)\n            c1[jh].append(ea)\n            \n        conns = c1\n        \n        \n        d1 = 10**12\n        \n        for ea in range(len(edges1) + 1):\n            d1 = min(d1, deepfucc(ea, -1))\n            \n        if d1 > 10**9:\n            d1 = 0\n        c2 = defaultdict(list)\n        for ea, jh in edges2:\n            c2[ea].append(jh)\n            c2[jh].append(ea)\n        \n        d2 = 10**12\n        \n        deepfucc.cache_clear()\n        conns = c2\n        for ea in range(len(edges2) + 1):\n            \n            d2 = min(d2, deepfucc(ea, -1))\n        if d2 > 10**9:\n            d2 = 0\n        \n        conns = c2\n        \n        \n        \n        print(d1, d2)\n        \n        return max(1 + d1 + d2, matrix)\n            \n                \n        ",
    "submit_ts": "1719717166",
    "subm_id": "1304384264"
}