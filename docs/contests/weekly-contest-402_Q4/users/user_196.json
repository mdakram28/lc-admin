{
    "username": "hughstudy-n",
    "submission": "class Solution {\n    class SegmentTree {\n        int[] tree;\n        int n;\n\n        public SegmentTree(int[] nums) {\n            if (nums.length > 0) {\n                n = nums.length;\n                tree = new int[n * 2];\n                buildTree(nums);\n            }\n        }\n\n        private void buildTree(int[] nums) {\n            for (int i = n, j = 0;  i < 2 * n; i++,  j++)\n                tree[i] = nums[j];\n            for (int i = n - 1; i > 0; --i)\n                tree[i] = tree[i * 2] + tree[i * 2 + 1];\n        }\n\n        void update(int pos, int val) {\n            pos += n;\n            tree[pos] = val;\n            while (pos > 0) {\n                int left = pos;\n                int right = pos;\n                if (pos % 2 == 0) {\n                    right = pos + 1;\n                } else {\n                    left = pos - 1;\n                }\n                tree[pos / 2] = tree[left] + tree[right];\n                pos /= 2;\n            }\n        }\n\n        public int sumRange(int l, int r) {\n            l += n;\n            r += n;\n            int sum = 0;\n            while (l <= r) {\n                if ((l % 2) == 1) {\n                    sum += tree[l];\n                    l++;\n                }\n                if ((r % 2) == 0) {\n                    sum += tree[r];\n                    r--;\n                }\n                l /= 2;\n                r /= 2;\n            }\n            return sum;\n        }\n    }\n\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        int len = nums.length;\n        int[] ori = new int[len];\n        for (int i = 0; i < len; ++i) {\n            ori[i] = isPeak(nums, i);\n        }\n        SegmentTree tree = new SegmentTree(ori);\n        List<Integer> res = new ArrayList<>();\n        for (int[] q : queries) {\n            if (q[0] == 2) {\n                nums[q[1]] = q[2];\n                tree.update(q[1], isPeak(nums,q[1]));\n                if (q[1] - 1 >= 0) {\n                    tree.update(q[1] - 1, isPeak(nums,q[1] - 1));\n                }\n                if (q[1] + 1 < nums.length) {\n                    tree.update(q[1] + 1, isPeak(nums,q[1] + 1));\n                }\n            } else {\n                int tmp = tree.sumRange(q[1], q[2]) - isPeak(nums, q[1]);\n                if (q[1] != q[2]) {\n                    tmp -= isPeak(nums, q[2]);\n                }\n                res.add(tmp);\n            }\n        }\n        return res;\n    }\n\n    private int isPeak(int[] nums, int pos) {\n        if (pos - 1 >= 0 && pos + 1 < nums.length && nums[pos] > nums[pos - 1] && nums[pos] > nums[pos + 1]) {\n            return 1;\n        }\n        return 0;\n    }\n}",
    "submit_ts": 1718505672.0
}