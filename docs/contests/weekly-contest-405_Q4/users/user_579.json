{
    "username": "freakin23",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef freakin23\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\ntemplate <long long mod>\nstruct modular {\n    long long value;\n    modular(long long x = 0) {\n        value = x % mod;\n        if (value < 0) value += mod;\n    }\n    modular& operator+=(const modular& other) {\n        if ((value += other.value) >= mod) value -= mod;\n        return *this;\n    }\n    modular& operator-=(const modular& other) {\n        if ((value -= other.value) < 0) value += mod;\n        return *this;\n    }\n    modular& operator*=(const modular& other) {\n        value = value * other.value % mod;\n        return *this;\n    }\n    modular& operator/=(const modular& other) {\n        long long a = 0, b = 1, c = other.value, m = mod;\n        while (c != 0) {\n            long long t = m / c;\n            m -= t * c;\n            swap(c, m);\n            a -= t * b;\n            swap(a, b);\n        }\n        a %= mod;\n        if (a < 0) a += mod;\n        value = value * a % mod;\n        return *this;\n    }\n    friend modular operator+(const modular& lhs, const modular& rhs) { return modular(lhs) += rhs; }\n    friend modular operator-(const modular& lhs, const modular& rhs) { return modular(lhs) -= rhs; }\n    friend modular operator*(const modular& lhs, const modular& rhs) { return modular(lhs) *= rhs; }\n    friend modular operator/(const modular& lhs, const modular& rhs) { return modular(lhs) /= rhs; }\n    modular& operator++() { return *this += 1; }\n    modular& operator--() { return *this -= 1; }\n    modular operator++(int) {\n        modular res(*this);\n        *this += 1;\n        return res;\n    }\n    modular operator--(int) {\n        modular res(*this);\n        *this -= 1;\n        return res;\n    }\n    modular operator-() const { return modular(-value); }\n    bool operator==(const modular& rhs) const { return value == rhs.value; }\n    bool operator!=(const modular& rhs) const { return value != rhs.value; }\n    bool operator<(const modular& rhs) const { return value < rhs.value; }\n};\ntemplate <long long mod>\nstring to_string(const modular<mod>& x) {\n    return to_string(x.value);\n}\ntemplate <long long mod>\nostream& operator<<(ostream& stream, const modular<mod>& x) {\n    return stream << x.value;\n}\ntemplate <long long mod>\nistream& operator>>(istream& stream, modular<mod>& x) {\n    stream >> x.value;\n    x.value %= mod;\n    if (x.value < 0) x.value += mod;\n    return stream;\n}\n\nconstexpr long long mod = (int) 1e9 + 7;\nusing mint = modular<mod>;\n\nmint power(mint a, long long n) {\n    mint res = 1;\n    while (n > 0) {\n        if (n & 1) {\n            res *= a;\n        }\n        a *= a;\n        n >>= 1;\n    }\n    return res;\n}\n\nvector<mint> fact(1, 1);\nvector<mint> finv(1, 1);\n\nmint C(int n, int k) {\n    if (n < k || k < 0) {\n        return mint(0);\n    }\n    while ((int) fact.size() < n + 1) {\n        fact.emplace_back(fact.back() * (int) fact.size());\n        finv.emplace_back(mint(1) / fact.back());\n    }\n    return fact[n] * finv[k] * finv[n - k];\n}\n\nclass Solution {\npublic:\n    struct TrieNode {\n        unordered_map<char, TrieNode*> child;\n        vector<pair<int, int>> exit; \n    };\n\n    class Trie {\n    public:\n        TrieNode* Root;\n        Trie() { \n            Root = new TrieNode();\n        }\n\n        void insert(string& word, int index, int cost) {\n            TrieNode* Node = Root;\n            for (char x : word) {\n                if (!Node->child.count(x))\n                    Node->child[x] = new TrieNode();\n                Node = Node->child[x];\n            }\n            Node->exit.push_back({index, cost});\n        }\n    };\n\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int n = (int)target.size();\n        vector<int> Dp(n + 1, INT_MAX);\n        Dp[0] = 0;\n\n        Trie t;\n        for (int i = 0; i < words.size(); ++i) {\n            t.insert(words[i], i, costs[i]);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            if (Dp[i] == INT_MAX) {\n                continue;\n            }\n            TrieNode* Node = t.Root;\n            for (int j = i; j < n; ++j) {\n                if (!Node->child.count(target[j])) break;\n                Node = Node->child[target[j]];\n                for (auto& p : Node->exit) {\n                    int sz = words[p.first].size();\n                    if (i + sz <= n) {\n                        Dp[i + sz] = min(Dp[i + sz], Dp[i] + p.second);\n                    }\n                }\n            }\n        }\n\n        return (Dp[n] == INT_MAX ? -1 : Dp[n]);\n    }\n};\n\n#ifdef freakin23\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt;\n    cin >> tt;\n    while (tt--) {\n        \n    }\n    return 0;\n}\n#endif",
    "submit_ts": "1720322468",
    "subm_id": "1312350749"
}