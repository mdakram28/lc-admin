{
    "username": "laggerk",
    "submission": "\nclass Solution {\n    private Map<Integer, List<Integer>> graph;\n\n    public int treeDiameter(int[][] edges) {\n        int n = edges.length + 1;\n        graph = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            graph.put(i, new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n\n        int[] result = dfs(0, -1, 0);\n        result = dfs(result[1], -1, 0);\n        return result[0];\n    }\n\n    private int[] dfs(int node, int parent, int dist) {\n        int maxDist = dist;\n        int farthestNode = node;\n        for (int child : graph.get(node)) {\n            if (child != parent) {\n                int[] childResult = dfs(child, node, dist + 1);\n                if (childResult[0] > maxDist) {\n                    maxDist = childResult[0];\n                    farthestNode = childResult[1];\n                }\n            }\n        }\n        return new int[]{maxDist, farthestNode};\n    }\n\n    public int findRadius(int[][] edges) {\n        int diameter = treeDiameter(edges);\n        return (diameter + 1) / 2;  // This gives us the correct radius\n    }\n\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int diameter1 = treeDiameter(edges1);\n        int diameter2 = treeDiameter(edges2);\n\n        int radius1 = findRadius(edges1);\n        int radius2 = findRadius(edges2);\n\n        return Math.max(Math.max(diameter1, diameter2), radius1 + radius2 + 1);\n    }\n}",
    "submit_ts": "1719719362",
    "subm_id": "1304440087"
}