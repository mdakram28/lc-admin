{
    "username": "BZH110",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1, m = edges2.size() + 1;\n        vector<vector<int>> t1(n), t2(m);\n        for(auto& e:edges1){\n            t1[e[0]].push_back(e[1]);\n            t1[e[1]].push_back(e[0]);\n        }\n        for(auto& e:edges2){\n            t2[e[0]].push_back(e[1]);\n            t2[e[1]].push_back(e[0]);\n        }\n        int l1 = INT_MAX, l2 = INT_MAX; // low\n        int r1 = 0, r2 = 0; // round\n        vector<int> h1(n, 0), h2(m, 0), s1(n, 0), s2(m, 0), i1(n, -1), i2(m, -1);\n        function<int(int, int, int, vector<vector<int>>&, vector<int>&, vector<int>&, vector<int>&, int&, int&)> dfs = [&](int now, int out, int pre, vector<vector<int>>& t, vector<int>& h, vector<int>& s, vector<int>& i, int& l, int& r)->int{\n            int ret = 0, high = 0, sub = 0;\n            for(auto next:t[now]) {\n                if(next == pre)\n                    continue;\n                auto k = dfs(next, out + 1, now, t, h, s, i, l, r) + 1;\n                ret = max(ret, k);\n                if(k > high){\n                    sub = high;\n                    high = k;\n                    i[now] = next;\n                }\n                else if(k > sub){\n                    sub = k;\n                }\n            }\n            r = max(r, high + sub);\n            h[now] = high;\n            s[now] = sub;\n            return ret;\n        };\n        function<void(int,int,int,vector<vector<int>>&, vector<int>&, vector<int>&, vector<int>&, int&)> d2 = [&](int now, int pre, int out, vector<vector<int>>& t, vector<int>& h, vector<int>& s, vector<int>& i, int& l){\n            l = min(l, max(out, h[now]));\n            for(auto next:t[now]){\n                if(next == pre)\n                    continue;\n                d2(next, now, max(out + 1, i[now] == next ? s[now] + 1 : h[now] + 1), t, h, s, i, l);\n            }\n        };\n        dfs(0, 0, -1, t1, h1, s1, i1, l1, r1);\n        dfs(0, 0, -1, t2, h2, s2, i2, l2, r2);\n        d2(0, -1, 0, t1, h1, s1, i1, l1);\n        d2(0, -1, 0, t2, h2, s2, i2, l2);\n        cout << l1 << \" \" << l2 << \" \" << r1 << \" \" << r2 << endl;\n        return max({l1 + l2 + 1, r1, r2});\n    }\n};",
    "submit_ts": 1719717298.0
}