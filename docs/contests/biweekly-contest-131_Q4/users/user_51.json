{
    "username": "FreeYourMind",
    "submission": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\n\n\"\"\"\nThere exists an infinite number line, with its origin at 0 and extending towards the positive\nx-axis.\n\nYou are given a 2D array queries, which contains two types of queries:\n\n 1. For a query of type 1, queries[i] = [1, x]. Build an obstacle at distance x from the origin. It\n    is guaranteed that there is no obstacle at distance x when the query is asked.\n 2. For a query of type 2, queries[i] = [2, x, sz]. Check if it is possible to place a block of size\n    sz anywhere in the range [0, x] on the line, such that the block entirely lies in the range [0,\n    x]. A block cannot be placed if it intersects with any obstacle, but it may touch it. Note that\n    you do not actually place the block. Queries are separate.\n\nReturn a boolean array results, where results[i] is true if you can place the block specified in the\nith query of type 2, and false otherwise.\n\n \n\nExample 1:\n\nInput: queries = [[1,2],[2,3,3],[2,3,1],[2,2,2]]\n\nOutput: [false,true,true]\n\nExplanation:\n\n[https://assets.leetcode.com/uploads/2024/04/22/example0block.png]\n\nFor query 0, place an obstacle at x = 2. A block of size at most 2 can be placed before x = 3.\n\nExample 2:\n\nInput: queries = [[1,7],[2,7,6],[1,2],[2,7,5],[2,7,6]]\n\nOutput: [true,true,false]\n\nExplanation:\n\n[https://assets.leetcode.com/uploads/2024/04/22/example1block.png]\n\n * Place an obstacle at x = 7 for query 0. A block of size at most 7 can be placed before x = 7.\n * Place an obstacle at x = 2 for query 2. Now, a block of size at most 5 can be placed before x =\n   7, and a block of size at most 2 before x = 2.\n\n \n\nConstraints:\n\n * 1 <= queries.length <= 15 * 104\n * 2 <= queries[i].length <= 3\n * 1 <= queries[i][0] <= 2\n * 1 <= x, sz <= min(5 * 104, 3 * queries.length)\n * The input is generated such that for queries of type 1, no obstacle exists at distance x when the\n   query is asked.\n * The input is generated such that there is at least one query of type 2.\n\"\"\"\n\n\nclass SegmentTree:\n    __slots__ = [\"n\", \"oper\", \"e\", \"log\", \"size\", \"data\"]\n\n    def __init__(self, n, oper, e):\n        self.n = n\n        self.oper = oper\n        self.e = e\n        self.log = (n - 1).bit_length()\n        self.size = 1 << self.log\n        self.data = [e] * (2 * self.size)\n\n    def _update(self, k):\n        self.data[k] = self.oper(self.data[2 * k], self.data[2 * k + 1])\n\n    def build(self, arr):\n        # assert len(arr) <= self.n\n        for i in range(self.n):\n            self.data[self.size + i] = arr[i]\n        for i in range(self.size - 1, 0, -1):\n            self._update(i)\n\n    def set(self, p, x):\n        # assert 0 <= p < self.n\n        p += self.size\n        self.data[p] = x\n        for i in range(self.log):\n            p >>= 1\n            self._update(p)\n\n    def get(self, p):\n        # assert 0 <= p < self.n\n        return self.data[p + self.size]\n\n    def prod(self, l, r):\n        # assert 0 <= l <= r <= self.n\n        sml = smr = self.e\n        l += self.size\n        r += self.size\n        while l < r:\n            if l & 1:\n                sml = self.oper(sml, self.data[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                smr = self.oper(self.data[r], smr)\n            l >>= 1\n            r >>= 1\n        return self.oper(sml, smr)\n\n    def all_prod(self):\n        return self.data[1]\n\n    def max_right(self, l, f):\n        # assert 0 <= l <= self.n\n        # assert f(self.)\n        if l == self.n:\n            return self.n\n        l += self.size\n        sm = self.e\n        while True:\n            while l % 2 == 0:\n                l >>= 1\n            if not f(self.oper(sm, self.data[l])):\n                while l < self.size:\n                    l = 2 * l\n                    if f(self.oper(sm, self.data[l])):\n                        sm = self.oper(sm, self.data[l])\n                        l += 1\n                return l - self.size\n            sm = self.oper(sm, self.data[l])\n            l += 1\n            if (l & -l) == l:\n                break\n        return self.n\n\n    def min_left(self, r, f):\n        # assert 0 <= r <= self.n\n        # assert f(self.)\n        if r == 0:\n            return 0\n        r += self.size\n        sm = self.e\n        while True:\n            r -= 1\n            while r > 1 and (r % 2):\n                r >>= 1\n            if not f(self.oper(self.data[r], sm)):\n                while r < self.size:\n                    r = 2 * r + 1\n                    if f(self.oper(self.data[r], sm)):\n                        sm = self.oper(self.data[r], sm)\n                        r -= 1\n                return r + 1 - self.size\n            sm = self.oper(self.data[r], sm)\n            if (r & -r) == r:\n                break\n        return 0\n\n\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        mx = max(qy[1] for qy in queries)\n\n        def op(a, b):\n            if b[0] == 0:\n                return a\n\n            lena, lefta, mida, righta = a\n            lenb, leftb, midb, rightb = b\n            lenab = lena + lenb\n            midab = mida if mida > midb else midb\n            midab = midab if midab > righta + leftb else righta + leftb\n            leftab = lefta\n            if lena == lefta:\n                leftab += leftb\n            rightab = rightb\n            if lenb == rightb == leftb:\n                rightab += righta\n            return lenab, leftab, midab, rightab\n\n        st = SegmentTree(mx + 5, oper=op, e=(0, 0, 0, 0))\n        st.build([(1, 1, 1, 1) for _ in range(mx + 5)])\n\n        res = []\n        for qy in queries:\n            if qy[0] == 1:\n                st.set(qy[1], (1, 0, 0, 1))\n            else:\n                len, left, mid, right = st.prod(0, qy[1])\n                mid = max(mid, left, right)\n                res.append(mid >= qy[2])\n        return res\n\n\ntestcases = [\n    # [[[1, 2], [2, 3, 3], [2, 3, 1], [2, 2, 2]]],\n    # [],\n]\n\ns = Solution()\nfunc_name = dir(s)[-1]\nfunc = getattr(s, func_name)\n\nfor args in testcases:\n    print(func(*args))\n",
    "submit_ts": 1716649394.0
}