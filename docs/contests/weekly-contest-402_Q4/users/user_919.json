{
    "username": "sampleaccountpage",
    "submission": "class Node:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        self.total = 0\n        self.left_tree = None\n        self.right_tree = None\n\n\nclass SegmentTree:\n    def __init__(self, nums):\n        self.nums = nums\n\n        \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n        #helper function to create the tree from input array\n        def createTree(nums, l, r):\n            #base case\n            if l > r:\n                return None\n\n            #leaf node\n            if l == r:\n                n = Node(l, r)\n                n.total = 0\n\n                return n\n\n            mid = (l + r) // 2\n            root = Node(l, r)\n            #recursively build the Segment tree\n            root.left_tree = createTree(nums, l, mid)\n            root.right_tree = createTree(nums, mid + 1, r)\n            #Total stores the sum of all leaves under root\n            #i.e. those elements lying between (start, end)\n            root.total = root.left_tree.total + root.right_tree.total\n            root.total += self.adjust_bounds(mid, l, r)\n\n            return root\n\n        self.root = createTree(nums, 0, len(nums)-1)\n\n    def adjust_bounds(self, mid, l, r):\n        count = 0\n        if mid - 1 >= l and mid + 1 <= r:\n            d = self.nums[mid] > self.nums[mid + 1] and self.nums[mid] > self.nums[mid - 1]\n            # print(\"mid: \", mid, \"d: \", d)\n            count += d\n        if mid + 2 <= r:\n            d = self.nums[mid + 1] > self.nums[mid] and self.nums[mid + 1] > self.nums[mid + 2]\n            # print(\"mid + 1: \", mid + 1, \"d: \", d)\n            count += d\n        return count\n\n    def update(self, i, val):\n        \"\"\"\n        :type i: int\n        :type val: int\n        :rtype: int\n        \"\"\"\n        #Helper function to update a value\n        def update_helper(root, i, val):\n            #Base case. The actual value will be updated in a leaf.\n            #The total is then propogated upwards\n            if root.start == root.end:\n                # root.total = 0\n                return\n\n            mid = (root.start + root.end) // 2\n\n            #If the index is less than the mid, that leaf must be in the left_tree subtree\n            if i <= mid:\n                update_helper(root.left_tree, i, val)\n\n            #Otherwise, the right_tree subtree\n            else:\n                update_helper(root.right_tree, i, val)\n\n            #Propogate the changes after recursive call returns\n            root.total = root.left_tree.total + root.right_tree.total\n            d = self.adjust_bounds(mid, root.start, root.end)\n            root.total += d\n\n        self.nums[i] = val\n        update_helper(self.root, i, val)\n\n    def range_sum(self, i, j):\n        \"\"\"\n        sum of elements nums[i..j], inclusive.\n        :type i: int\n        :type j: int\n        :rtype: int\n        \"\"\"\n        #Helper function to calculate range sum\n        def range_sum_helper(root, i, j):\n            #If the range exactly matches the root, we already have the sum\n            if root.start == i and root.end == j:\n                return root.total\n\n            mid = (root.start + root.end) // 2\n\n            #If end of the range is less than the mid, the entire interval lies\n            #in the left_tree subtree\n            if j <= mid:\n                return range_sum_helper(root.left_tree, i, j)\n\n            #If start of the interval is greater than mid, the entire inteval lies\n            #in the right_tree subtree\n            elif i >= mid + 1:\n                return range_sum_helper(root.right_tree, i, j)\n\n            #Otherwise, the interval is split. So we calculate the sum recursively,\n            #by splitting the interval\n            else:\n                ans = range_sum_helper(root.left_tree, i, mid) + range_sum_helper(root.right_tree, mid + 1, j)\n                ans += self.adjust_bounds(mid, i, j)\n                return ans\n\n        return range_sum_helper(self.root, i, j)\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        st = SegmentTree(nums)\n        res = []\n        for query in queries:\n            if query[0] == 1:\n                res.append(st.range_sum(query[1], query[2]))\n            else:\n                st.update(query[1], query[2])\n        return res\n",
    "submit_ts": 1718508793.0
}