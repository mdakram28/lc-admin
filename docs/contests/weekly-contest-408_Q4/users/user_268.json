{
    "username": "sarvagya2545",
    "submission": "class Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n        vector<vector<int>> graph(n);\n        vector<bool> left_or_top(n, false), right_or_bottom(n, false);\n        \n        // auto is_point_inside = [&] (int i, int x, int y) {\n        //     long long x1 = circles[i][0], y1 = circles[i][1], r = circles[i][2];\n        //     return (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y) <= (r * r);\n        // };\n        \n        auto touch_or_overlap = [&](int i, int j) -> bool {\n            long long x1 = circles[i][0], y1 = circles[i][1], r1 = circles[i][2];\n            long long x2 = circles[j][0], y2 = circles[j][1], r2 = circles[j][2];\n            \n            return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2);\n        };\n        \n        auto touch_left = [&](int i) -> bool {\n            return circles[i][0] <= circles[i][2];\n        };\n        \n        auto touch_bottom = [&](int i) -> bool {\n            return circles[i][1] <= circles[i][2];\n        };\n        \n        auto touch_right = [&](int i) -> bool {\n            return abs(circles[i][0] - X) <= circles[i][2];\n        };\n        \n        auto touch_top = [&](int i) -> bool {\n            return abs(circles[i][1] - Y) <= circles[i][2];\n        };\n        \n        \n        vector<int> visited(n, 0);\n        queue<int> Q;\n        \n        for(int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                if(touch_or_overlap(i, j)) {\n                    graph[i].push_back(j);\n                    graph[j].push_back(i);\n                }\n            }\n            \n            left_or_top[i] = touch_left(i) or touch_top(i);\n            right_or_bottom[i] = touch_right(i) or touch_bottom(i);\n            \n            if(left_or_top[i] and right_or_bottom[i]) {\n                return false;\n            }\n            \n            if(left_or_top[i]) {\n                visited[i] = 1;\n                Q.push(i);\n            }\n        }\n        \n        while(!Q.empty()) {\n            int i = Q.front();\n            Q.pop();\n            \n            if(right_or_bottom[i]) {\n                return false;\n            }\n            \n            for(auto j: graph[i]) {\n                if(!visited[j]) {\n                    visited[j] = 1;\n                    Q.push(j);\n                }\n            }\n        }\n        \n        return true;\n    }\n};",
    "submit_ts": "1722136974",
    "subm_id": "1335750460"
}