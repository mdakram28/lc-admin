{
    "username": "Abhinav_Jain_1234",
    "submission": "class Solution {\npublic:\n    int minimumCost(const std::string& target, std::vector<std::string>& words, std::vector<int>& costs) {\n        int n = target.size();\n        std::unordered_map<std::string, long long> wordCostMap;\n\n        // Fill the map with minimum cost for each word\n        for (int i = 0; i < words.size(); ++i) {\n            if (wordCostMap.find(words[i]) == wordCostMap.end() || costs[i] < wordCostMap[words[i]]) {\n                wordCostMap[words[i]] = costs[i];\n            }\n        }\n\n        // Initialize DP array with a large number (LLONG_MAX) indicating impossible states\n        std::vector<long long> dp(n + 1, LLONG_MAX);\n        dp[0] = 0; // Base case: zero cost to form an empty string\n\n        // Iterate over the target string and fill the DP array\n        for (int i = 0; i < n; ++i) {\n            if (dp[i] == LLONG_MAX) continue; // Skip impossible states\n\n            // Check all words to see if they can form a valid substring starting at i\n            for (const auto& pair : wordCostMap) {\n                const std::string& word = pair.first;\n                long long cost = pair.second;\n                int len = word.size();\n                if (i + len <= n && target.compare(i, len, word) == 0) {\n                    dp[i + len] = std::min(dp[i + len], dp[i] + cost);\n                }\n            }\n        }\n\n        // The answer is the minimum cost to form the target string\n        return dp[n] == LLONG_MAX ? -1 : dp[n];\n    }\n};",
    "submit_ts": "1720324573",
    "subm_id": "1312402843"
}