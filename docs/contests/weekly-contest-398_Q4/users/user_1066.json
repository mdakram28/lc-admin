{
    "username": "amanbaluni1234",
    "submission": "// Author - Aman Baluni\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long \n#define pb(x) push_back(x)\n#define uni unsigned long long int\n#define ssz(s) s.length()\n#define nl endl\n#define sz(arr) arr.size()\n#define srt(arr) sort(arr.begin(),arr.end())\n#define read(arr,n) for(ll i=0;i<n;i++) cin>>arr[i]\n#define rev(arr) reverse(arr.begin(),arr.end())\n#define srtr(arr) sort(arr.rbegin(),arr.rend())\n#define pl pair<ll,ll>\n#define pi pair<int,int>\n#define vii vector<vector<int>>\n#define vi vector<int>\n#define mn(a) *min_element(a.begin(),a.end())\n#define vll vector<ll>\n#define vlll vector<vector<ll>>\n#define mx(a) *max_element(a.begin(),a.end())\n#define vss vector<vector<string>>\n#define vs vector<string>\n#define vc vector<char>\n#define pre_sum(pre,arr,n) for(i=1;i<n;i++) pre[i]=pre[i-1]+arr[i]\n#define vcc vector<vector<char>>\n#define suf_sum(suf,arr,n) for(i=n-2;i>=0;i--) suf[i]=suf[i+1]+arr[i]\n// ll gcd(ll a,ll b) { if (b==0) return a; return gcd(b, a%b); }\n// ll lcm(ll a,ll b) { return a/gcd(a,b)*b; }\n/*  All Required define Pre-Processors and typedef Constants */\n// typedef long long ll;\n// typedef unsigned long long ull;\n// typedef vector<ll> vl;\n// typedef vector<int> vi;\n// typedef vector<char> vc;\n// typedef vector<string> vs;\n// typedef vector<int>::iterator vit;\n// typedef set<int> si;\n// typedef map<int, int> mii;\nconst double pie=3.14159265358979323846264338327950;\n// const ll mod=1e9+7;\nvoid yes() { cout<<\"YES\"<<endl; }\nvoid no() { cout<<\"NO\"<<endl; }\n\n\nclass Solution {\npublic:\n\nint recursiveSolve(int target, int currentIndex, int currentJump, bool canJump, unordered_map<int, vii> &memoization) {\n    if (currentIndex > target + 5)\n        return 0;\n\n    if (currentJump > 31)\n        return 0;\n    \n    //base cases finished\n    \n    //check\n\n    if (memoization.count(currentIndex) && memoization[currentIndex][currentJump][canJump] != -1)\n        return memoization[currentIndex][currentJump][canJump];\n\n    int result = (currentIndex == target);\n    if (canJump)\n        //recursive call aage ke liye\n        result += recursiveSolve(target, currentIndex - 1, currentJump, false, memoization);\n    if (currentIndex + (1 << currentJump) <= target + 1)\n        result += recursiveSolve(target, currentIndex + (1 << currentJump), currentJump + 1, true, memoization);\n\n    memoization[currentIndex].resize(32, vi(2, -1));\n    //final\n    return memoization[currentIndex][currentJump][canJump] = result;\n}\n    int waysToReachStair(int k) {\n        unordered_map<int, vii> memoization;\n       return recursiveSolve(k, 1, 0, 1, memoization);\n    }\n};\n\n//END//",
    "submit_ts": "1716090470",
    "subm_id": "1261867974"
}