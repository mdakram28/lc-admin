{
    "username": "congthanh2000",
    "submission": "struct SegmentTree {\n    vector<int> IT;\n    int n;\n\n    SegmentTree(int _n) {\n        n = _n;\n        IT = vector<int>(n * 4, 0);\n    }\n\n    void update(int i, int L, int R, int u, int val) {\n        if (L > u || R < u) {\n            return;\n        }\n        IT[i] = max(IT[i], val);\n        if (L == R) {\n            return;\n        }\n        int mid = (L + R) >> 1;\n        update(i << 1, L, mid, u, val);\n        update(i << 1 | 1, mid + 1, R, u, val);\n    }\n\n    int get(int i, int L, int R, int u, int v) {\n        if (L > v || R < u) return 0;\n        if (L >= u && R <= v) return IT[i];\n        int mid = (L + R) >> 1;\n        int left = get(i << 1, L, mid, u, v);\n        int right = get(i << 1 | 1, mid + 1, R, u, v);\n        return max(left, right);\n    }\n};\n\nclass Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {\n        vector<int> values(nums.begin(), nums.end());\n        sort(values.begin(), values.end());\n        values.resize(unique(values.begin(), values.end()) - values.begin());\n        int m = values.size();\n        for (int i = 0; i < nums.size(); i++) {\n            nums[i] = lower_bound(values.begin(), values.end(), nums[i]) - values.begin();\n        }\n        k++;\n        vector<SegmentTree> vs(k, SegmentTree(m));\n        int n = nums.size();\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int u = 0; u < k; u++) {\n                int length = vs[u].get(1, 0, m - 1, nums[i], nums[i]) + 1;\n                if (u > 0) {\n                    length = max(length, vs[u - 1].get(1, 0, m - 1, 0, nums[i] - 1) + 1);\n                    length = max(length, vs[u - 1].get(1, 0, m - 1, nums[i] + 1, m - 1) + 1);\n                }\n                vs[u].update(1, 0, m - 1, nums[i], length);\n                ans = max(ans, length);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1717862036.0
}