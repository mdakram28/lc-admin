{
    "username": "alcorzb",
    "submission": "  class SegmentTree {\n    static constexpr int MAX_NODES = 1048576; // Up to 500k array.\n\n    // T[i]: stored value at the ith node of the tree, which represents\n    //       a specific calculation on a subrange.\n    // T[0]: 0 - M\n    // T[1] = 0 - M/2\n    // T[2] = M/2+1 - M\n    // T[3] = 0 - M/4\n    // T[4] = M/4+1 - M/2\n    int T[MAX_NODES];\n\n    // Number of leafs (items in the array).\n    int n;\n\n    // Set init value for queries.. 0 for sums, large number for mins, etc..\n    int init_value;\n\n\n    public:\n    SegmentTree(int n, int init_value) {\n        this->n = n;\n        this->init_value = init_value;\n        for (int i = 0; i < MAX_NODES; i++)\n        T[i] = init_value;\n    }\n\n    // What to do to indivdual values (what's the operation).\n    void set_op(int& target, int val) {\n        target = val;  // set value\n        target &= val; // add value\n    }\n\n    // How to combine two values\n    // (e.g. add to keep track of sums, min to keep track of minimums).\n    void combine_op(int& target, int left, int right) {\n        target = left & right;  // pick min of the two.\n    }\n\n    // Update value of element idx with value val.\n    void update(int idx, int val) {\n        update(0, 0, n - 1, idx, val);\n    }\n\n    void update(int root, int start, int end, int idx, int val) {\n        if (start == end) {\n        set_op(T[root], val);\n        return;\n        }\n        int mid = (start + end) / 2;\n        int left = root * 2 + 1;\n        int right = root * 2 + 2;\n        if (idx <= mid) {\n        // Update left tree.\n        update(left, start, mid, idx, val);\n        } else {\n        update(right, mid + 1, end, idx, val);\n        }\n        combine_op(T[root], T[left], T[right]);\n    }\n\n    int query(int start, int end) {\n        return query(0, 0, n - 1, start, end);\n    }\n\n    int query(int root, int start, int end, int query_start, int query_end) {\n        if (query_start > end || query_end < start) // no overlap.\n        return init_value;\n\n        if (query_start <= start && query_end >= end) // full overlap.\n        return T[root];\n\n        // While there's even a bit of overlap, try subranges.\n        int mid = (start + end) / 2;\n        int left = root * 2 + 1;\n        int right = root * 2 + 2;\n\n        int left_q = query(left, start, mid, query_start, query_end);\n        int right_q = query(right, mid + 1, end, query_start, query_end);\n        int ans;\n        combine_op(ans, left_q, right_q);\n        return ans;\n    }\n\n    void print() {\n        cout << \"[\";\n        for (int i = 0; i < 4 * n; i++) {\n        cout << T[i] << \", \";\n        }\n        cout << \"]\" << endl;\n    }\n\n};\n\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        SegmentTree tree(nums.size(), 2147483647);\n        for (int i = 0; i < nums.size(); i++) {\n            tree.update(i, nums[i]);\n        }\n        long long ans = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            int lo = i;\n            int hi = nums.size() - 1;\n            while (lo < hi) {\n                int mid = (lo + hi) / 2;\n                int val = tree.query(i, mid);\n                if (val >= k) {\n                    lo = mid + 1;\n                } else {\n                    hi = mid;\n                }\n            }\n            int right_bound = lo;\n            while (right_bound >= i && tree.query(i, right_bound) < k)\n              right_bound--;\n            if (right_bound < i || tree.query(i, right_bound) != k) {\n                continue;\n            }\n            lo = i, hi = nums.size() - 1;\n            while (lo < hi) {\n                int mid = (lo + hi) / 2;\n                int val = tree.query(i, mid);\n                if (val > k) {\n                    lo = mid + 1;\n                } else {\n                    hi = mid;\n                }\n            }\n            int left_bound = lo;\n            while (left_bound < right_bound && tree.query(i, left_bound) > k)\n              left_bound++;\n            ans += right_bound - left_bound + 1;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720281240",
    "subm_id": "1311818028"
}