{
    "username": "bttsv",
    "submission": "class Solution {\npublic:\n    vector<int> v;\n    void dfs(int x, int depth, int x0, vector<vector<int>> &g) {\n        v[x] = depth;\n        for (int y : g[x])\n            if (y != x0)\n                dfs(y, depth + 1, x, g);\n    }\n    int run(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vector<vector<int>> g(n);\n        for (int i = 0; i < n; i++)\n            g[i] = vector<int>();\n        for (auto &e : edges) {\n            g[e[0]].push_back(e[1]);\n            g[e[1]].push_back(e[0]);\n        }\n        v = vector<int>(n);\n        dfs(0, 0, -1, g);\n        int pos = 0;\n        for (int i = 1; i < n; i++)\n            if (v[i] > v[pos])\n                pos = i;\n        dfs(pos, 0, -1, g);\n        int len = 0;\n        for (int x : v)\n            len = max(len, x);\n        return len;\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int x = run(edges1), y = run(edges2);\n        return max((x + 1) / 2 + (y + 1) / 2 + 1, max(x, y));\n    }\n};",
    "submit_ts": 1719718932.0
}