{
    "username": "KhushiHansrajani",
    "submission": "struct TrieNode {\n    unordered_map<char, TrieNode*> children;\n    vector<int> costs;\n    \n    TrieNode() {}\n};\n\nclass Trie {\npublic:\n    Trie() {\n        root = new TrieNode();\n    }\n    \n    void insert(const string& word, int cost) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (!node->children[c]) {\n                node->children[c] = new TrieNode();\n            }\n            node = node->children[c];\n        }\n        node->costs.push_back(cost);\n    }\n    \n    vector<int> search(const string& prefix) {\n        TrieNode* node = root;\n        for (char c : prefix) {\n            if (!node->children[c]) {\n                return {};\n            }\n            node = node->children[c];\n        }\n        return node->costs;\n    }\n    \npublic:\n    TrieNode* root;\n};\n\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n         int n = target.size();\n    Trie trie;\n    \n    // Insert words and costs into trie\n    for (int i = 0; i < words.size(); ++i) {\n        trie.insert(words[i], costs[i]);\n    }\n    \n    // DP array to store minimum cost to form target up to index i\n    vector<int> dp(n + 1, INT_MAX);\n    dp[0] = 0;  // Base case: cost to form empty string is 0\n    \n    // Iterate over each character in target\n    for (int i = 0; i < n; ++i) {\n        if (dp[i] == INT_MAX) continue;  // Skip if current state is unreachable\n        \n        TrieNode* node = trie.root;\n        \n        // Iterate over remaining part of target starting from i\n        for (int j = i; j < n; ++j) {\n            char c = target[j];\n            if (node->children.find(c) == node->children.end()) {\n                break;  // No more matching prefixes\n            }\n            node = node->children[c];\n            \n            // Update dp[j + 1] with minimum cost found in TrieNode\n            for (int cost : node->costs) {\n                dp[j + 1] = min(dp[j + 1], dp[i] + cost);\n            }\n        }\n    }\n    \n    return dp[n] == INT_MAX ? -1 : dp[n];\n//         int n = target.size();\n//         vector<int> dp(n+1 , INT_MAX);\n//         dp[0] =0;\n        \n//         unordered_map<string , vector<pair<int, int>>> mpp;\n        \n//         for(int i=0 ; i<words.size() ; i++){\n//             mpp[words[i]].push_back({i , costs[i]});\n//         }\n//         for(int i=0 ; i<n ; i++){\n//             if(dp[i] == INT_MAX) continue;\n            \n//             for(int j= 1 ; j<=n-i ; j++){\n//                 string sub = target.substr(i , j);\n                \n//                 if(mpp.find(sub) != mpp.end()){\n//                     for(const auto& [index , cost] : mpp[sub]){\n//                         dp[i+j] = min(dp[i+j] , dp[i]+cost);\n\n//                     }\n//                 }\n//                 }\n//             }\n        \n//         return dp[n] == INT_MAX ? -1 : dp[n];\n    }\n};",
    "submit_ts": "1720321683",
    "subm_id": "1312329516"
}