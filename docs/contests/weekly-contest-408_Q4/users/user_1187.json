{
    "username": "Ostosis",
    "submission": "class Solution {\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        Arrays.sort(circles, (a, b) -> {\n            int xA = a[0];\n            int rA = a[2];\n            int leftPointA = xA - rA;\n\n            int xB = b[0];\n            int rB = b[2];\n            int leftPointB = xB - rB;\n            return leftPointA - leftPointB;\n        });\n\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\n\n        for (int i = 0; i < circles.length; i++) {\n            int[] circleA = circles[i];\n            int xA = circleA[0];\n            int yA = circleA[1];\n            int rA = circleA[2];\n            int rightPointA = xA + rA;\n\n            if (dist(xA, yA, 0, 0) <= rA || dist(xA, yA, X, Y) <= rA) {\n                return false;\n            }\n\n            for (int j = i + 1; j < circles.length; j++) {\n                int[] circleB = circles[j];\n                int xB = circleB[0];\n                int rB = circleB[2];\n                int leftPointB = xB - rB;\n\n                // no more circles can connect\n                if (rightPointA < leftPointB) {\n                    break;\n                }\n\n                if (intersects(circleA, circleB)) {\n                    graph.computeIfAbsent(i, (k) -> new ArrayList<>()).add(j);\n                    graph.computeIfAbsent(j, (k) -> new ArrayList<>()).add(i);\n                }\n            }\n        }\n\n        boolean[] visited = new boolean[circles.length];\n\n        for (int i = 0; i < visited.length; i++) {\n            if (!visited[i]) {\n                boolean partitions = bfs(graph, circles, X, Y, visited, i);\n\n                if (partitions) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    private boolean bfs(HashMap<Integer, List<Integer>> graph, int[][] circles, int x, int y, boolean[] visited, int start) {\n        ArrayDeque<Integer> queue = new ArrayDeque<>();\n        visited[start] = true;\n        queue.add(start);\n\n        boolean touchesLeftOrTop = false;\n        boolean touchesBottomOrRight = false;\n\n        // Order should be geometrically left-to-right\n        while (!queue.isEmpty()) {\n            int node = queue.pollFirst();\n\n            if (!touchesLeftOrTop) {\n                int xCircle = circles[node][0];\n                int yCircle = circles[node][1];\n                int rCircle = circles[node][2];\n\n                int leftPos = xCircle - rCircle;\n                int rightPos = xCircle + rCircle;\n                int topPos = yCircle + rCircle;\n                int botPos = yCircle - rCircle;\n\n                if (leftPos <= 0 && rightPos >= 0 || topPos >= y && botPos <= y) {\n                    touchesLeftOrTop = true;\n                }\n            }\n\n            if (!touchesBottomOrRight) {\n                int xCircle = circles[node][0];\n                int yCircle = circles[node][1];\n                int rCircle = circles[node][2];\n\n                int leftPos = xCircle - rCircle;\n                int rightPos = xCircle + rCircle;\n                int topPos = yCircle + rCircle;\n                int botPos = yCircle - rCircle;\n\n                if (leftPos <= x && rightPos >= x || topPos >= 0 && botPos <= 0) {\n                    touchesBottomOrRight = true;\n                }\n            }\n\n            List<Integer> children = graph.getOrDefault(node, Collections.emptyList());\n\n            for (Integer child : children) {\n                if (!visited[child]) {\n                    visited[child] = true;\n                    queue.add(child);\n                }\n            }\n        }\n\n        return touchesLeftOrTop && touchesBottomOrRight;\n    }\n\n    private boolean intersects(int[] circleA, int[] circleB) {\n        int xA = circleA[0];\n        int yA = circleA[1];\n        int xB = circleB[0];\n        int yB = circleB[1];\n\n        double dist = dist(xA, yA, xB, yB);\n        int radiusSum = circleA[2] + circleB[2];\n        double diff = radiusSum - dist;\n        return diff >= 0;\n    }\n\n    private double dist(int x1, int y1, int x2, int y2) {\n        int absX = Math.abs(x1 - x2);\n        int absY = Math.abs(y1 - y2);\n        double absSquareSum = Math.pow(absX, 2) + Math.pow(absY, 2);\n        return Math.sqrt(absSquareSum);\n    }\n}",
    "submit_ts": "1722138366",
    "subm_id": "1335788940"
}