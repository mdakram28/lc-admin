{
    "username": "JavOliva",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n1 = -1, n2 = -1;\n        for (int i = 0; i < edges1.size(); i ++){\n            n1 = max(edges1[i][0], edges1[i][1]);\n        }\n        for (int i = 0; i < edges2.size(); i ++){\n            n2 = max(edges2[i][0], edges2[i][1]);\n        }\n        n1 ++; n2 ++;\n        vector<vector<int> > adj1(n1), adj2(n2);\n        for (int i = 0; i < edges1.size(); i ++){\n            int a = edges1[i][0];\n            int b = edges1[i][1];\n            adj1[a].push_back(b);\n            adj1[b].push_back(a);\n        }\n        for (int i = 0; i < edges2.size(); i ++){\n            int a = edges2[i][0];\n            int b = edges2[i][1];\n            adj2[a].push_back(b);\n            adj2[b].push_back(a);\n        }\n        vector<int> dp1(n1, 0), dp2(n2, 0);\n\n        function<void (int, int, vector<vector<int> >&, vector<int>&)> dfs1 = [&](int u, int p, vector<vector<int> > &adj, vector<int>&dp){\n            for (int v : adj[u]) if (v != p){\n                dfs1(v, u, adj, dp);\n                dp[u] = max(dp[u], dp[v] + 1);\n            }\n        };\n        if (n1 >= 1)\n            dfs1(0, -1, adj1, dp1);\n        if (n2 >= 1)\n            dfs1(0, -1, adj2, dp2);\n        function<void (int, int, vector<vector<int> >&, vector<int>&, int&, int, int&)> dfs2 = [&](int u, int p, vector<vector<int> > &adj, vector<int> &dp, int &ans, int n, int &diametro){\n            int maxi = -1, maxi2 = -1;\n            int v1 = -1, v2 = -1;\n            for (int v : adj[u]){\n                if (maxi < dp[v]){\n                    maxi2 = maxi;\n                    maxi = dp[v];\n                    v2 = v1;\n                    v1 = v;\n                }\n                else if (maxi2 < dp[v]){\n                    maxi2 = dp[v];\n                    v2 = v;\n                }\n            }\n            ans = min(ans, dp[u]);\n            if (maxi2 != -1)\n                diametro = max(diametro, maxi + maxi2 + 2);\n            else\n                diametro = max(diametro, dp[u]);\n            for (int v : adj[u]) if (v != p){\n                int root = u, new_root = v;\n                int befroot = dp[root];\n                int befnew_root = dp[new_root];\n\n                if (v != v1) {\n                    dp[root] = maxi + 1;\n                }\n                else{\n                    if (v2 == -1)\n                        dp[root] = 0;\n                    else\n                        dp[root] = maxi2 + 1;\n                }\n                dp[new_root] = max(dp[new_root], 1 + dp[root]);\n                dfs2(v, u, adj, dp, ans, n, diametro);\n                dp[new_root] = befnew_root;\n                dp[root] = befroot;\n            }\n        };\n        int ans1 = n1, ans2 = n2, diam1 = 0, diam2 = 0;\n        if (n1 >= 1)\n            dfs2(0, -1, adj1, dp1, ans1, n1, diam1);\n        if (n2 >= 1)\n            dfs2(0, -1, adj2, dp2, ans2, n2, diam2);\n        int answer = max({diam1, ans1 + ans2 + 1, diam2});\n        return answer;\n    }\n};",
    "submit_ts": 1719717743.0
}