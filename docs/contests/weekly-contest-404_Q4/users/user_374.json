{
    "username": "ShikiNatsume",
    "submission": "class Solution:\n    def dfs(self, graph, node, vis, distance):\n        vis[node] = True\n        mx = distance\n        far = node\n        for n in graph[node]:\n            if not vis[n]:\n                cnode, curr = self.dfs(graph, n, vis, distance + 1)\n                if curr > mx:\n                    mx = curr\n                    far = cnode\n        return far, mx\n\n    def find(self, graph):\n        n = len(graph)\n        vis = [False] * n\n        far, _ = self.dfs(graph, 0, vis, 0)\n        vis = [False] * n\n        _, d = self.dfs(graph, far, vis, 0)\n        return d\n\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        tree1 = [[] for _ in range(len(edges1) + 1)]\n        tree2 = [[] for _ in range(len(edges2) + 1)]\n        \n        for u, v in edges1:\n            tree1[u].append(v)\n            tree1[v].append(u)\n        for u, v in edges2:\n            tree2[u].append(v)\n            tree2[v].append(u)\n\n        d1 = self.find(tree1)\n        d2 = self.find(tree2)\n\n        total1 = max(d1, d2)\n        return max(max(d1, d2), (d1 + 1) // 2 + (d2 + 1) // 2 + 1)\n",
    "submit_ts": "1719718996",
    "subm_id": "1304431183"
}