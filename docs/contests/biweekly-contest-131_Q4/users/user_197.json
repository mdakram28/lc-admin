{
    "username": "nnv-nick",
    "submission": "#define ll int\n\nclass ExplicitSegmentTree {\npublic:\n    ExplicitSegmentTree() {\n    }\n\n    ExplicitSegmentTree(ll sz) {\n        calc_tree_size(sz);\n    }\n\n    // builds tree with n elements starting from 0 index of a\n    void Build(ll *a, ll n) {\n        if (tree_size < n) {\n            calc_tree_size(n);\n        }\n        ll ind = tree_size;\n        for (ll i = 0; i < n; ++i) {\n            tree[tree_size + i].first = a[i];\n        }\n        ind >>= 1;\n        while (ind > 0) {\n            for (ll i = 0; i < ind; ++i) {\n                tree[ind + i].first = f(tree[(ind + i) * 2].first, tree[(ind + i) * 2 + 1].first);\n            }\n            ind >>= 1;\n        }\n    }\n\n    void Build(vector<ll>& a) {\n        ll n = a.size();\n        Build(a.data(), n);\n    }\n\n    // add x on the segment [lef, rig]\n    void AddOnSegment(ll lef, ll rig, ll x) {\n        add_on_segment(1, 0, tree_size - 1, lef, rig, x);\n    }\n\n    ll GetMax(ll lef, ll rig) {\n        if (rig < lef) {\n            return 0;\n        }\n        return get_max_on_segment(1, 0, tree_size - 1, lef, rig);\n    }\n\n    ll GetValueByIdx(ll idx) {\n        return get_max_on_segment(1, 0, tree_size - 1, idx, idx);\n    }\n    \n    void SetVal(ll idx, ll val) {\n        //cout << idx << \" is now \" << val << \"\\n\";\n        auto tmp = GetValueByIdx(idx);\n        AddOnSegment(idx, idx, val - tmp);\n    }\n\nprivate:\n    void calc_tree_size(ll sz) {\n        tree_size = 1;\n        while (tree_size < sz) {\n            tree_size <<= 1;\n        }\n        tree.resize(tree_size * 2, make_pair(neutral(), 0));\n    }\n\n    ll add_on_segment(ll ind, ll lef, ll rig, ll lgr, ll rgr, ll x) {\n        if (rig < lgr || lef > rgr) {\n            return tree[ind].first + tree[ind].second;\n        }\n        if (lef >= lgr && rig <= rgr) {\n            tree[ind].second += x;\n            return tree[ind].first + tree[ind].second;\n        }\n        ll sz = (rig - lef + 1);\n        ll one = add_on_segment(ind * 2, lef, lef + (sz / 2) - 1, lgr, rgr, x);\n        ll two = add_on_segment(ind * 2 + 1, lef + (sz / 2), rig, lgr, rgr, x);\n        tree[ind].first = f(one, two);\n        return tree[ind].first + tree[ind].second;\n    }\n\n    ll get_max_on_segment(ll ind, ll lef, ll rig, ll lgr, ll rgr) {\n        if (rig < lgr || lef > rgr) {\n            return neutral();\n        }\n        if (lef >= lgr && rig <= rgr) {\n            return tree[ind].first + tree[ind].second;\n        }\n        push(ind);\n        ll sz = (rig - lef + 1);\n        ll one = get_max_on_segment(ind * 2, lef, lef + (sz / 2) - 1, lgr, rgr);\n        ll two = get_max_on_segment(ind * 2 + 1, lef + (sz / 2), rig, lgr, rgr);\n        return f(one, two);\n    }\n\n    void push(ll idx) {\n        tree[idx * 2].second += tree[idx].second;\n        tree[idx * 2 + 1].second += tree[idx].second;\n        tree[idx].first = f(tree[idx * 2].first + tree[idx * 2].second, tree[idx * 2 + 1].first + tree[idx * 2 + 1].second);\n        tree[idx].second = 0;\n    }\n\n    ll f(ll a, ll b) {\n        return max(a, b);\n    }\n\n    ll neutral() {\n        return 0;\n    }\n\n    // second value in pair -- value that adds to every element on segment\n    vector<pair<ll, ll>> tree;\n    ll tree_size{-1};\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        auto tree = ExplicitSegmentTree(min<int>(50000, queries.size() * 3) + 5);\n        tree.SetVal(0, 200000);\n        set<int> objs;\n        vector<bool> ans;\n        \n        for (const auto& query : queries) {\n            if (query[0] == 1) {\n                int x = query[1];\n                auto prv = objs.lower_bound(x);\n                int prv_ind;\n                if (prv == objs.begin()) {\n                    int block_sz = tree.GetValueByIdx(0);\n                    tree.SetVal(0, x);\n                    tree.SetVal(x, block_sz - x);\n                    objs.insert(x);\n                    continue;\n                }\n                --prv;\n                prv_ind = (*prv);\n                int block_sz = tree.GetValueByIdx(prv_ind);\n                tree.SetVal(prv_ind, x - prv_ind);\n                tree.SetVal(x, block_sz - (x - prv_ind));\n                objs.insert(x);\n            } else {\n                int x = query[1];\n                int sz = query[2];\n                auto prv = objs.upper_bound(x);\n                if (prv == objs.begin()) {\n                    ans.push_back(x >= sz);\n                    continue;\n                }\n                --prv;\n                int prv_ind = *prv;\n                //cout << prv_ind << \"\\n\";\n                int tmp = tree.GetMax(0, prv_ind - 1);\n                //cout << tmp << \" \" << x - prv_ind << \" HMM\\n\";\n                tmp = max(tmp, x - prv_ind);\n                ans.push_back(tmp >= sz);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1716650432",
    "subm_id": "1267615378"
}