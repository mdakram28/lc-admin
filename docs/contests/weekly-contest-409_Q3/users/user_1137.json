{
    "username": "faulea",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\nclass Solution {\n    class NumArray {\n        class SegmentTree {\n        public:\n            SegmentTree *ls, *rs;\n            int lazy;\n            int val;\n\n            SegmentTree() {\n                lazy = -1;\n                val = 0;\n                ls = rs = nullptr;\n            }\n        };\n\n    public:\n        NumArray(int n) {\n            this->N = n;\n            this->root = new SegmentTree();\n            updateTree(this->root, 0, this->N, 0, this->N, 1);\n        }\n\n        void update(int l, int r) {\n            updateTree(this->root, 0, this->N, l +1, r - 1, 0);\n        }\n\n        int sumRange(int left, int right) {\n            return query(this->root, 0, this->N, left, right) - 1;\n        }\n\n    private:\n        SegmentTree* root;\n        int N;\n\n        // \u5efa\u6811(\u533a\u95f4\u4fee\u6539)\n        void updateTree(SegmentTree* node, int start, int end, int l, int r,\n                        int val) {\n            // node \u4e3a\u5f53\u524d\u8282\u70b9\uff0cstart, end\u4e3a\u5f53\u524d\u8282\u70b9\u6240\u4ee3\u8868\u7684\u5de6\u53f3\u754c, \u95ed\u533a\u95f4\n            // l,r\u4e3a\u5f85\u66f4\u65b0\u7684\u533a\u95f4\u5de6\u53f3\u754c\uff0cv\u4e3a\u66f4\u65b0\u7684\u503c\n\n            // \u5f53\u524d\u8282\u70b9\u533a\u95f4\u843d\u5728\u5f85\u66f4\u65b0\u533a\u95f4\u4e2d\uff0c\u76f4\u63a5\u6c42\u6539\u503c\n            if (l <= start && end <= r) {\n                node->val = (end - start + 1) * val; // \u533a\u95f4\u6c42\u548c\n                node->lazy = val;\n                return;\n            }\n\n            // \u5411\u4e0b\u66f4\u65b0\u61d2\u6807\u8bb0\n            int m = start + (end - start) / 2;\n            pushdown(node, m - start + 1, end - m);\n\n            // \u5de6\u533a\u95f4\u6709\u90e8\u5206\u843d\u5728\u5f85\u66f4\u65b0\u533a\u95f4\n            if (l <= m) {\n                updateTree(node->ls, start, m, l, r, val);\n            }\n\n            // \u53f3\u533a\u95f4\u6709\u90e8\u5206\u843d\u5728\u5f85\u66f4\u65b0\u533a\u95f4\n            if (r > m) {\n                updateTree(node->rs, m + 1, end, l, r, val);\n            }\n\n            // \u4fee\u6539\u5b50\u8282\u70b9\u540e\u66f4\u65b0\u5f53\u524d\u8282\u70b9\n            pushup(node);\n        }\n\n        // \u533a\u95f4\u67e5\u8be2\n        int query(SegmentTree* node, int start, int end, int l, int r) {\n            // node\u4e3a\u5f53\u524d\u8282\u70b9\uff0cstart, end \u4e3a\u5f53\u524d\u8282\u70b9\u7684\u5de6\u53f3\u754c\n            // l, r\u4e3a\u67e5\u8be2\u7684\u533a\u95f4\u5de6\u53f3\u754c\n\n            // \u5f53\u524d\u8282\u70b9\u533a\u95f4\u5b8c\u5168\u843d\u5728\u5f85\u67e5\u533a\u95f4\n            if (l <= start && end <= r) {\n                return node->val;\n            }\n\n            // \u9700\u8981\u67e5\u8be2\uff0c\u5411\u4e0b\u66f4\u65b0\u61d2\u6807\u8bb0\uff0c\n            int m = start + (end - start) / 2;\n            pushdown(node, m - start + 1, end - m);\n\n            int ret = 0;\n            if (m >= l) {\n                ret += query(node->ls, start, m, l, r) - 1;\n            }\n            if (m < r) {\n                ret += query(node->rs, m + 1, end, l, r) - 1;\n            }\n            return ret;\n        }\n\n        // \u4e0b\u653e\u61d2\u60f0\u6807\u8bb0\n        void pushdown(SegmentTree* node, int leftlen, int rightlen) {\n            // node\u4e3a\u7236\u8282\u70b9\uff0cleftlen,rightlen\u4e3a\u5de6\u53f3\u533a\u95f4\u957f\u5ea6\n\n            // \u5982\u679c\u6ca1\u6709\u5b50\u8282\u70b9\u5219\u5efa\u7acb\u5b50\u8282\u70b9\n            if (node->ls == nullptr) {\n                node->ls = new SegmentTree();\n            }\n            if (node->rs == nullptr) {\n                node->rs = new SegmentTree();\n            }\n\n            // \u6ca1\u6709\u61d2\u6807\u8bb0\uff0c\u65e0\u9700\u66f4\u65b0\n            if (node->lazy == -1) {\n                return;\n            }\n\n            // \u533a\u95f4\u6c42\u503c\uff0c\u9700\u8981\u4e58\u533a\u95f4\u957f\u5ea6\n            node->ls->val = node->lazy * leftlen;\n            node->rs->val = node->lazy * rightlen;\n\n            // \u61d2\u6807\u8bb0\u4e0b\u653e\uff0c\u91cd\u7f6e\u5f53\u524d\u8282\u70b9\u61d2\u6807\u8bb0\n            node->ls->lazy = node->lazy;\n            node->rs->lazy = node->lazy;\n            node->lazy = -1;\n        }\n\n        // \u5b50\u8282\u70b9\u66f4\u65b0\u5230\u7236\u8282\u70b9\n        void pushup(SegmentTree* node) {\n            node->val = node->ls->val + node->rs->val;\n        }\n    };\n\npublic:\n    vector<int> shortestDistanceAfterQueries(int n,\n                                             vector<vector<int>>& queries) {\n        vector<int> ans;\n        ans.reserve(queries.size());\n        NumArray* na = new NumArray(n);\n        int cur = n - 1;\n        for (const auto& q : queries) {\n            int u = q[0], v = q[1];\n            na->update(u, v);\n            ans.emplace_back(na->sumRange(0, n) - 1);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722743522",
    "subm_id": "552351298"
}