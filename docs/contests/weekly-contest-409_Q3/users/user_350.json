{
    "username": "cpp20",
    "submission": "class SegmentTree(object):\n    def __init__(self, nums):\n        self.nums = nums\n        self.n = len(nums)\n        self.tree = [0] * (self.n<<2)\n        self._build(1, 0, self.n-1)\n    \n    def _build(self, p, lo, hi):\n        #print('_build',p,lo,hi)\n        if lo == hi:\n            self.tree[p] = self.nums[lo]\n        else:      \n            mid = lo+hi >> 1\n            self._build(p<<1, lo, mid)\n            self._build(p<<1|1, mid+1, hi)\n            self.tree[p] = self.tree[p<<1] + self.tree[p<<1|1]\n    \n    def update(self, left, right, val):\n        self._update(1, 0, self.n-1, left, right, val)\n\n    def _update(self, p, lo, hi, left, right, val): \n        if lo == hi or left == lo and right == hi or not self.tree[p]:\n            self.tree[p] = val\n            return\n\n        mid = lo+hi >> 1\n        if left <= mid:\n            self._update(p<<1, lo, mid, left, min(mid,right), val)\n        if right > mid:\n            self._update(p<<1|1, mid+1, hi, max(left,mid+1), right, val)\n        self.tree[p] = self.tree[p<<1] + self.tree[p<<1|1]\n    \n    def sum(self, left, right):\n        return self._sum(1, 0, self.n-1, left, right)\n\n    def _sum(self, p, lo, hi, left, right):\n        if lo == hi or lo == left and hi == right:\n            return self.tree[p]\n\n        mid = lo+hi >> 1\n        csum = 0\n        if left <= mid:\n            csum += self._sum(p<<1, lo, mid, left, min(mid, right))\n        if right > mid:\n            csum += self._sum(p<<1|1, mid+1, hi, min(mid+1, left), right)\n        return csum\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        st = SegmentTree([1]*n)\n        res = []\n        for a,b in queries:\n            st.update(a+1,b-1,0)\n            res.append(st.sum(0,n-1)-1)\n        return res",
    "submit_ts": "1722741089",
    "subm_id": "552335965"
}