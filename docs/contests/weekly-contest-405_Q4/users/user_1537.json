{
    "username": "qu1ck",
    "submission": "MAX_STATES = 51000\nOUT = [0]*MAX_STATES\nFAIL = [-1]*MAX_STATES\nGOTO = [[-1]*26 for _ in range(MAX_STATES)]\n\nclass AhoCorasick:\n    def __init__(self, words): \n        self.words = list(words)\n        self.max_states = sum([len(word) for word in self.words]) \n        self.max_characters = 26\n        for i in range(self.max_states+1):\n            OUT[i] = 0\n        self.out = OUT\n        for i in range(self.max_states+1):\n            FAIL[i] = -1\n        self.fail = FAIL\n        for i in range(self.max_states+1):\n            for j in range(26):\n                GOTO[i][j] = -1\n        self.goto = GOTO\n\n        self.states_count = self.__build_matching_machine() \n\n    def __build_matching_machine(self): \n        k = len(self.words) \n        states = 1\n        for i in range(k): \n            word = self.words[i] \n            current_state = 0\n            for character in word: \n                ch = ord(character) - 97 # Ascii value of 'a' = 97 \n                if self.goto[current_state][ch] == -1: \n                    self.goto[current_state][ch] = states \n                    states += 1\n                current_state = self.goto[current_state][ch] \n            self.out[current_state] |= (1<<i) \n        for ch in range(self.max_characters): \n            if self.goto[0][ch] == -1: \n                self.goto[0][ch] = 0\n        queue = [] \n        for ch in range(self.max_characters): \n            if self.goto[0][ch] != 0: \n                self.fail[self.goto[0][ch]] = 0\n                queue.append(self.goto[0][ch]) \n        while queue: \n            state = queue.pop(0) \n            for ch in range(self.max_characters): \n                if self.goto[state][ch] != -1: \n                    failure = self.fail[state] \n                    while self.goto[failure][ch] == -1: \n                        failure = self.fail[failure] \n                    failure = self.goto[failure][ch] \n                    self.fail[self.goto[state][ch]] = failure \n                    self.out[self.goto[state][ch]] |= self.out[failure] \n                    queue.append(self.goto[state][ch]) \n        return states \n\n    def __find_next_state(self, current_state, next_input): \n        answer = current_state \n        ch = ord(next_input) - 97 # Ascii value of 'a' is 97 \n        while self.goto[answer][ch] == -1: \n            answer = self.fail[answer] \n        return self.goto[answer][ch] \n\n    def search_words(self, text, W): \n        text = text.lower() \n        current_state = 0\n        dp = [0]\n        for i in range(len(text)):\n            dp.append(1000000000)\n            current_state = self.__find_next_state(current_state, text[i]) \n            if self.out[current_state] == 0: continue\n            for j in range(len(self.words)): \n                if (self.out[current_state] & (1<<j)) > 0: \n                    word = self.words[j] \n                    s = i - len(word)+1\n                    if dp[s] + W[word] < dp[-1]:\n                        dp[-1] = dp[s] + W[word]\n        return dp[-1]\n\nclass Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        W = {}\n        for w, c in zip(words, costs):\n            if c < W.get(w, 10000000):\n                W[w] = c\n        G = defaultdict(list)\n        AC = AhoCorasick(W.keys())\n        R = AC.search_words(target, W)\n        \n        return R if R < 1000000000 else -1\n            \n            ",
    "submit_ts": "1720323543",
    "subm_id": "1312378111"
}