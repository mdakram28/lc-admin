{
    "username": "Aylup",
    "submission": "using ll = int;\nclass StreamChecker {\n\n    struct TrieNode {\n        TrieNode *sfx;\n        TrieNode *dict;\n        std::array<TrieNode*, 26> child{};\n        bool isWord;\n        TrieNode() {\n            sfx = dict = this;\n            isWord = false;\n        }\n        ll depth = 0;\n        ll cost = 1e9;\n    } *root = new TrieNode(), *curr;\n\n    TrieNode nodes[(int)1e5]{};\n    int count = 0;\n    TrieNode *newTrieNode() {\n        return &nodes[count++];\n    }\n\npublic:\n    StreamChecker(vector<string>& words, vector<int> &costs) {\n        root = new TrieNode();\n        for (int i = 0; i < words.size(); ++i) {\n            auto &&word = words[i];\n            TrieNode *u = root;\n            for (auto c : word) {\n                if (!u->child[c - 'a']) {\n                    u->child[c -'a'] = newTrieNode();\n                }\n                u = u->child[c-'a'];\n            }\n            u->isWord = true;\n            u->depth = word.size();\n            u->cost = std::min((ll)u->cost, (ll)costs[i]);\n        }\n\n        std::deque<TrieNode*> q{root};\n        while (!q.empty()) {\n            TrieNode *u = q.front();\n            q.pop_front();\n            for (int i = 0; i < 26; ++i) {\n                auto c = i + 'a';\n                auto v = u->child[i];\n                if (!v) {\n                    continue;\n                }\n                TrieNode *p = u->sfx;\n                while (p != root && !p->child[c-'a']) {\n                    p = p->sfx;\n                }\n\n                if (u != root && p->child[c - 'a']) {\n                    v->sfx = p->child[c - 'a'];\n                } else {\n                    v->sfx = root;\n                }\n\n                v->dict = v->sfx->isWord ? v->sfx : v->sfx->dict;\n                q.push_back(v);\n            }\n        }\n        curr = root;\n    }\n    \n    std::vector<std::array<ll, 2>> query(char letter) {\n        while (curr != root && !curr->child[letter - 'a']) {\n            curr = curr->sfx;\n        }\n\n        std::vector<std::array<ll, 2>> ans;\n        if (curr->child[letter - 'a']) {\n            curr = curr->child[letter - 'a'];\n            auto u = curr;\n            if (!u->isWord) {\n                u = u->dict;\n            }\n            while (u->isWord) {\n                ans.push_back({u->depth, u->cost});\n                u = u->dict;\n            }\n        }\n        return ans;\n    }\n};\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        auto checker = StreamChecker(words, costs);\n        int n = target.size();\n        std::vector<int> dp(n + 1, 1e9);\n        dp[0] = 0;\n        for (int i = 1; i <= n; ++i) {\n            for (auto [x, c] : checker.query(target[i - 1])) {\n                dp[i] = std::min((ll)dp[i], dp[i - x] + c);\n            }\n        }\n        return dp[n] == 1e9 ? -1 : dp[n];\n    }\n};",
    "submit_ts": "1720324319",
    "subm_id": "1312396660"
}