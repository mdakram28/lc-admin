{
    "username": "dhakad_239",
    "submission": "class Solution {\npublic:\n    \n    map <int ,int > l;\n   int best;\n   int node;\n   int dfs(int v, bool* visited, vector <int> graph[], int c = 0){\n      visited[v] = true;\n      int ans = 0;\n      for(int i = 0; i < graph[v].size(); i++){\n         if(!visited[graph[v][i]])ans = max(ans,dfs(graph[v][i], visited, graph, c+1));\n      }\n      if(c > best){\n         best = c;\n         node = v ;\n      }\n      visited[v] = false;\n      return max(c,ans);\n   }\n    \n    \n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& e1, vector<vector<int>>& e2) {\n        int n=e1.size()+1,m=e2.size()+1,i,j;\n        int x=max(n,m);\n      vector <int> graph[n+1],graph1[m+1];\n      for(i=0;i<n-1;i++){\n            graph[e1[i][0]].push_back(e1[i][1]);\n            graph[e1[i][1]].push_back(e1[i][0]);\n        }\n         for(i=0;i<m-1;i++){\n            graph1[e2[i][0]].push_back(e2[i][1]);\n            graph1[e2[i][1]].push_back(e2[i][0]);\n        }\n      bool* visited = new bool[n+1]();\n      best = 0;\n      node = 0;\n      dfs(0, visited, graph);\n      bool* visited2 = new bool[n+1]();\n      int ma= dfs(node, visited2, graph);\n        \n         bool* visited1 = new bool[m+1]();\n      best = 0;\n      node = 0;\n      dfs(0, visited1, graph1);\n      bool* visited3 = new bool[m+1]();\n      int ma1= dfs(node, visited3, graph1);\n       \n        int ans=INT_MAX;\n        ans=ma1/2+ma1%2+1+ma/2+ma%2;\n        ma=max(ma,ma1);\n        if(ans<ma){\n            ans=ma;\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1719718161.0
}