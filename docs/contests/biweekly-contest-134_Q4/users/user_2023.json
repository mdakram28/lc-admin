{
    "username": "sujankarthikm",
    "submission": "class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        from collections import defaultdict\n\n        from collections import Counter\n        def count_bitwise_and_zero(nums) :\n            \"\"\"Count nonempty subarrays with & of elements equal to 0.\n            Given a list on nonnegative integers,\n            returns the number of contiguous, nonempty subarrays for which the\n            bitwise and of all elements in the subarray are equal to 0.\n\n            Runs in linear time on fixed-width integers.\n            \"\"\"\n\n            def get_set_bit_indices(x: int):\n                \"\"\"Return indices of set bits in x\"\"\"\n                pow_2 = 1\n                exponent = 0\n                set_bits = []\n\n                while pow_2 <= x:\n                    if pow_2 & x != 0:\n                        set_bits.append(exponent)\n\n                    exponent += 1\n                    pow_2 *= 2\n\n                return set_bits\n\n            def is_bitwise_and_zero(window_length: int, bit_counts) -> bool:\n                \"\"\"Given bit counts for a window of an array, return whether the\n                window's elements have bitwise AND equal to zero.\"\"\"\n                return all(value < window_length for value in bit_counts.values())\n\n            n = len(nums)\n            total_subarray_count = n * (n + 1) // 2\n\n            nonzero_subarray_count = 0\n            window_bit_counts = Counter()\n\n            \"\"\"At every iteration start, [left_idx, right_idx] is the longest subarray\n            ending at right_idx whose bitwise AND is nonzero.\"\"\"\n            left_idx = 0\n\n            for right_idx, right_element in enumerate(nums):\n                if right_element == 0:\n                    window_bit_counts.clear()\n                    left_idx = right_idx + 1\n                    continue\n\n                # Expand window to include right\n                window_bit_counts += Counter(get_set_bit_indices(right_element))\n\n                # Shrink window until AND is nonzero\n                while (left_idx < right_idx\n                    and is_bitwise_and_zero(right_idx - left_idx + 1, window_bit_counts)):\n\n                    window_bit_counts -= Counter(get_set_bit_indices(nums[left_idx]))\n                    left_idx += 1\n\n                nonzero_subarray_count += (right_idx - left_idx + 1)\n\n            return total_subarray_count - nonzero_subarray_count\n\n\n        if k==0:\n            return count_bitwise_and_zero(nums)\n        count = 0\n        current_ands = defaultdict(int)\n        current_ands[0] = 1  # To handle subarrays that start from the beginning\n\n        for num in nums:\n            next_ands = defaultdict(int)\n            for and_val in current_ands:\n                new_and = and_val & num\n                next_ands[new_and] += current_ands[and_val]\n            \n            next_ands[num] += 1  # Subarray that starts at this element\n            \n            if k in next_ands:\n                count += next_ands[k]\n\n            current_ands = next_ands\n\n\n\n\n        return count",
    "submit_ts": "1720280834",
    "subm_id": "1311803687"
}