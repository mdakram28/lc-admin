{
    "username": "leetgoat_dot_dev",
    "submission": "# MY 2D SEGMENT TREE TEMPLATE\n\nclass SegmentTree2D:\n    def __init__(self, matrix):\n        if not matrix:\n            return\n        \n        self.n = len(matrix)\n        self.m = len(matrix[0])\n        self.tree = [[(float('-inf'), -1)] * (2 * self.m) for _ in range(2 * self.n)]\n        \n        # Build the segment tree\n        self._build(matrix)\n\n    def _build(self, matrix):\n        for i in range(self.n):\n            for j in range(self.m):\n                self.tree[i + self.n][j + self.m] = (matrix[i][j], i)\n        \n        for i in range(self.n):\n            for j in range(self.m - 1, 0, -1):\n                left_child = self.tree[i + self.n][j * 2]\n                right_child = self.tree[i + self.n][j * 2 + 1]\n                self.tree[i + self.n][j] = max(left_child, right_child, key=lambda x: x[0])\n        \n        for i in range(self.n - 1, 0, -1):\n            for j in range(2 * self.m):\n                top_child = self.tree[i * 2][j]\n                bottom_child = self.tree[i * 2 + 1][j]\n                self.tree[i][j] = max(top_child, bottom_child, key=lambda x: x[0])\n\n    def query(self, row1, col1, row2, col2):\n        row1 += self.n\n        row2 += self.n\n        col1 += self.m\n        col2 += self.m\n        result = (float('-inf'), -1)\n        \n        while row1 <= row2:\n            if row1 % 2 == 1:\n                c1, c2 = col1, col2\n                while c1 <= c2:\n                    if c1 % 2 == 1:\n                        result = max(result, self.tree[row1][c1], key=lambda x: x[0])\n                        c1 += 1\n                    if c2 % 2 == 0:\n                        result = max(result, self.tree[row1][c2], key=lambda x: x[0])\n                        c2 -= 1\n                    c1 //= 2\n                    c2 //= 2\n                row1 += 1\n            if row2 % 2 == 0:\n                c1, c2 = col1, col2\n                while c1 <= c2:\n                    if c1 % 2 == 1:\n                        result = max(result, self.tree[row2][c1], key=lambda x: x[0])\n                        c1 += 1\n                    if c2 % 2 == 0:\n                        result = max(result, self.tree[row2][c2], key=lambda x: x[0])\n                        c2 -= 1\n                    c1 //= 2\n                    c2 //= 2\n                row2 -= 1\n            row1 //= 2\n            row2 //= 2\n        \n        return result\n    \n    \n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        st = SegmentTree2D(board)\n        # print(st.query(1, 0, 3, 0))\n        # return\n        height = len(board)\n        width = len(board[0])\n        \n        res = -inf\n        \n        def constructSegments(height, blockedRows):\n            blockedRows.sort()\n            segments = []\n            prev = 0\n\n            for b in blockedRows:\n                if b > prev:\n                    segments.append([prev, b - 1])\n                prev = b + 1\n\n            if prev <= height - 1:\n                segments.append([prev, height - 1])\n\n            return segments\n\n#         def constructSegments(blockedRows):\n#             blockedRows.sort()\n#             segments = []\n#             prev = 0\n\n#             for b in blockedRows:\n#                 if b > prev:\n#                     segments.append([prev, b - 1])\n#                 prev = b + 1\n\n#             if prev <= height - 1:\n#                 segments.append([prev, height - 1])\n\n#             return segments\n        \n        # pick a center\n        for r in range(height):\n            for c in range(1, width - 1):\n                # print('_______')\n                # print(f'center is r={r} c={c} val={board[r][c]}')\n                center = board[r][c]\n                \n                regions = [] # up to 2 regions we can put the right rook in\n                if r > 0:\n                    topRegionR1 = 0\n                    topRegionR2 = r - 1\n                    topRegionC1 = c + 1\n                    topRegionC2 = width - 1\n                    regions.append((topRegionR1, topRegionC1, topRegionR2, topRegionC2))\n                \n                # bottom region\n                if r != height - 1:\n                    bottomRegionR1 = r + 1\n                    bottomRegionR2 = height - 1\n                    bottomRegionC1 = c + 1\n                    bottomRegionC2 = width - 1\n                    regions.append((bottomRegionR1, bottomRegionC1, bottomRegionR2, bottomRegionC2))\n                \n                # print(f'regions: {regions}')\n                \n                maxRightScore = -inf\n                rowOccurence = None\n                for region in regions:\n                    q = st.query(region[0], region[1], region[2], region[3])\n                    maxRightScoreHere = q[0]\n                    if maxRightScoreHere > maxRightScore:\n                        maxRightScore = maxRightScoreHere\n                        rowOccurence = q[1]\n                \n                # print(f'max right score: {maxRightScore}, rowOccurence: {rowOccurence}')\n                \n                blockedRows = list(set([r, rowOccurence]))\n                # print(f'blocked rows: {blockedRows}')\n                \n                rowSegments = constructSegments(height, blockedRows)\n                # print(f'row segments: {rowSegments}')\n                \n                # find the max left region\n                leftC1 = 0\n                leftC2 = c - 1\n                bigLeft = -inf\n                for r1, r2 in rowSegments:\n                    # print(f'querying on r1={r1} c1={leftC1} r2={r2} leftC2={leftC2}')\n                    q = st.query(r1, leftC1, r2, leftC2)\n                    bigLeft = max(bigLeft, q[0])\n                \n                # print(f'max big left region: {bigLeft}')\n                \n                score = center + maxRightScore + bigLeft\n                res = max(score, res)\n                \n                \n                \n                # take max from left first\n                regions = []\n                \n                # top left\n                if r > 0:\n                    topRegionR1 = 0\n                    topRegionR2 = r - 1\n                    topRegionC1 = 0\n                    topRegionC2 = c - 1\n                    regions.append((topRegionR1, topRegionC1, topRegionR2, topRegionC2))\n                # bottom left\n                if r != height - 1:\n                    bRegionR1 = r + 1\n                    bRegionR2 = height - 1\n                    bRegionC1 = 0\n                    bRegionC2 = c - 1\n                    regions.append((bRegionR1, bRegionC1, bRegionR2, bRegionC2))\n                \n                # print(f'left regions: {regions}')\n                \n                maxLeftScore = -inf\n                rowOcc = None\n                for region in regions:\n                    q = st.query(region[0], region[1], region[2], region[3])\n                    maxLeftScoreHere = q[0]\n                    if maxLeftScoreHere > maxLeftScore:\n                        maxLeftScore = maxLeftScoreHere\n                        rowOcc = q[1]\n                \n                # print(f'max left score: {maxLeftScore}, rowOcc: {rowOcc}')\n                \n                blockedRows = list(set([r, rowOcc]))\n                # print(f'blocked rows: {blockedRows}')\n                rowSegments = constructSegments(height, blockedRows)\n                # print(f'row segments: {rowSegments}')\n                \n                # find the max right region when taking this left\n                rightC1 = c + 1\n                rightC2 = width - 1\n                bigRight = -inf\n                for r1, r2 in rowSegments:\n                    q = st.query(r1, rightC1, r2, rightC2)\n                    bigRight = max(bigRight, q[0])\n                \n                # print(f'max big right region when taking biggest from left: {bigRight}')\n                \n                score = center + maxLeftScore + bigRight\n                \n                res = max(score, res)\n                    \n                \n        \n        return res\n                    \n                \n                \n                    \n        \n        ",
    "submit_ts": "1723908803",
    "subm_id": "1359167751"
}