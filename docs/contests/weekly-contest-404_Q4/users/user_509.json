{
    "username": "YarosHarm",
    "submission": "class Solution {\n    static void dbg(Object... args) {\n        List<String> lst = new ArrayList<>();\n        for(Object arg : args) {\n        if(arg.getClass().isArray()) {\n        lst.add(Arrays.toString((int[]) arg));\n        } else {\n        lst.add(arg.toString());\n        }\n        }\n        System.out.println(\"[\" + String.join(\", \", lst) + \"]\");\n        }\n\nstatic void dbg(Object obj) {\n        System.out.println(obj);\n        }\n\nstatic void dbg(int[] arr) {\n        System.out.println(Arrays.toString(arr));\n        }\n\nstatic void dbg(boolean[] arr) {\n        System.out.println(Arrays.toString(arr));\n        }\n\nstatic void dbg(long[] arr) {\n        System.out.println(Arrays.toString(arr));\n        }\n\nstatic void dbg(char[] arr) {\n        System.out.println(Arrays.toString(arr));\n        }\n\nstatic void dbg(int[][] arr) {\n        List<String> lst = new ArrayList<>();\n        for(int i = 0; i < arr.length; i++) {\n        lst.add(Arrays.toString(arr[i]));\n        }\n        System.out.println(\"[\" + String.join(\",\", lst) + \"]\");\n        }\n\nstatic void dbg(long[][] arr) {\n        List<String> lst = new ArrayList<>();\n        for(int i = 0; i < arr.length; i++) {\n        lst.add(Arrays.toString(arr[i]));\n        }\n        System.out.println(\"[\" + String.join(\",\", lst) + \"]\");\n        }\n\nstatic void dbg(List<int[]> lst) {\n        List<String> res = new ArrayList<>();\n        for(int i = 0; i < lst.size(); i++) {\n        res.add(Arrays.toString(lst.get(i)));\n        }\n        System.out.println(\"[\" + String.join(\",\", res) + \"]\");\n        }\n\nstatic void dbg(Queue<int[]> q) {\n        List<int[]> lst = new ArrayList<>(q);\n        List<String> res = new ArrayList<>();\n        for(int i = 0; i < lst.size(); i++) {\n        res.add(Arrays.toString(lst.get(i)));\n        }\n        System.out.println(\"[\" + String.join(\",\", res) + \"]\");\n        }\n\nstatic void dbgSegmentTree(long[] tree) {\n        int n = tree.length;\n        List<List<String>> res = new ArrayList<>();\n        for(int level = 2; level <= n; level = (level << 1)) {\n        List<String> curr = new ArrayList<>();\n        int c = n / level;\n        for(int j = c; j < c + c; j++) {\n        curr.add(tree[j] + \"\");\n        }\n        res.add(curr);\n        }\n        Collections.reverse(res);\n        for (List<String> re : res) {\n        dbg(re);\n        }\n        }\n\n\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int n = edges1.length + 1;\n        int m = edges2.length + 1;\n\n        List<Integer>[] graph1 = new ArrayList[n];\n        List<Integer>[] graph2 = new ArrayList[m];\n        for(int i = 0; i < n; i++) {\n            graph1[i] = new ArrayList<>();\n        }\n        for(int i = 0; i < m; i++) {\n            graph2[i] = new ArrayList<>();\n        }\n        \n        List<Integer>[] graph = new ArrayList[n + m];\n        for(int i = 0; i < n + m; i++) {\n            graph[i] = new ArrayList<>();\n        }\n\n        int[] deg1 = new int[n];\n        int[] deg2 = new int[m];\n        for(int[] e : edges1) {\n            graph1[e[0]].add(e[1]);\n            graph1[e[1]].add(e[0]);\n            deg1[e[0]]++;\n            deg1[e[1]]++;\n            graph[e[0]].add(e[1]);\n            graph[e[1]].add(e[0]);\n        }\n        for(int[] e : edges2) {\n            graph2[e[1]].add(e[0]);\n            graph2[e[0]].add(e[1]);\n            deg2[e[0]]++;\n            deg2[e[1]]++;\n            graph[e[1] + n].add(e[0] + n);\n            graph[e[0] + n].add(e[1] + n);\n        }\n\n        // int[] ss1 = new int[n];\n        // int[] ss2 = new int[m];\n        // subSize(ss1, graph1, -1, 0);\n        // subSize(ss2, graph2, -1, 0);\n\n        // int c1 = centroid(n, ss1, graph1, -1, 0);\n        // int c2 = centroid(m, ss2, graph2, -1, 0);\n        List<Integer> core1 = getCore(graph1, deg1);\n        List<Integer> core2 = getCore(graph2, deg2);\n        if(core1.isEmpty()) {\n            core1.add(0);\n        }\n        if(core2.isEmpty()) {\n            core2.add(0);\n        }\n        //dbg(core1);\n        //dbg(core2);\n        int res = Integer.MAX_VALUE;\n        for(Integer cr1 : core1) {\n            for(Integer cr2 : core2) {\n                graph[cr1].add(cr2 + n);\n                graph[cr2 + n].add(cr1);\n\n                int[] a = furthestNode(graph, n + m, 0);\n                int[] b = furthestNode(graph, n + m, a[0]);\n                graph[cr1].remove(graph[cr1].size() - 1);\n                graph[cr2 + n].remove(graph[cr2 + n].size() - 1);\n                res = Math.min(res, b[1]);\n            }\n        }\n        \n        return res == Integer.MAX_VALUE ? 1 : res;\n    }\n\n    List<Integer> getCore(List<Integer>[] graph, int[] deg) {\n        int n = deg.length;\n        Queue<Integer> q = new LinkedList<>();\n        for(int i = 0; i < n; i++) {\n            if(deg[i] == 1) {\n                q.add(i);\n                deg[i]--;\n            }\n        }\n        //dbg(q);\n        List<Integer> res = new ArrayList<>(q);\n        while(!q.isEmpty()) {\n            int size = q.size();\n            Queue<Integer> temp = new LinkedList<>();\n            while(size-- > 0) {\n                int v = q.poll();\n                for(Integer u : graph[v]) {\n                    deg[u]--;\n                    if(deg[u] == 1) {\n                        temp.add(u);\n                        deg[u]--;\n                    }\n                }\n            }\n            //dbg(\"TEMP\", temp);\n            q = temp;\n            if(!temp.isEmpty()) {\n                res = new ArrayList<>(temp);\n            }\n        }\n        //dbg(\"local\", res);\n        return res;\n    }\n\n    static int[] furthestNode(List<Integer>[] graph, int n, int s) {\n        boolean[] visited = new boolean[n];\n        Queue<int[]> q = new LinkedList<>();\n        q.add(new int[]{ s, 0});\n        visited[s] = true;\n        int[] res = new int[]{ s, 0 };\n        while(!q.isEmpty()) {\n            int[] v = q.poll();\n            res = v;\n            for(Integer c : graph[v[0]]) {\n                if(!visited[c]) {\n                    visited[c] = true;\n                    q.add(new int[]{ c, v[1] + 1 });\n                }\n            }\n        }\n\n        return res;\n    }\n\n    void subSize(int[] ss, List<Integer>[] graph, int p, int v) {\n        ss[v] = 1;\n        for(Integer u : graph[v]) {\n            if(p == u) {\n                continue;\n            }\n            subSize(ss, graph, v, u);\n            ss[v] += ss[u];\n        }\n    }\n\n    int centroid(int n, int[] ss, List<Integer>[] graph, int p, int v) {\n        for(Integer u : graph[v]) {\n            if(u != p && ss[u] * 2 > n) {\n                return centroid(n, ss, graph, v, u);\n            }\n        }\n        return v;\n    }\n}",
    "submit_ts": 1719718619.0
}