{
    "username": "HarleyLiu",
    "submission": "class Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        const int m = target.size();\n        const int n = words.size();\n        unordered_map<string, int> cost;\n        for (int i = 0; i < n; ++i) {\n            auto itr = cost.find(words[i]);\n            if (itr == cost.end())\n                cost[words[i]] = costs[i];\n            else\n                itr->second = min(itr->second, costs[i]);\n        }\n\n        // vector<int> mem(m+1, -1);\n        // mem[0] = 0;\n        // for (int l = 1; l <= m; ++l) {\n        //     auto itr = cost.find(target.substr(0, l));\n        //     int ret = (itr==cost.end() ? INT_MAX : itr->second);\n        //     for (int s = 0; s < l; ++s) {\n        //         auto it = cost.find(target.substr(s, l - s));\n        //         if (it == cost.end()) continue;\n        //         const int prev = mem[s];\n        //         if (prev > 0)\n        //             ret = min(ret, it->second + prev);\n        //     }\n        //     if (ret != INT_MAX)\n        //         mem[l] = ret;\n        // }\n        // return mem[m];\n\n        vector<int> dp(m+1, INT_MAX);\n        dp[0] = 0;\n        for (int i = 0; i <= m; ++i) {\n            if (dp[i] == INT_MAX) continue; // skip if this prefix of target cannot be formed\n\n            for (auto& [w, c] : cost) {\n                int len = w.length();\n                if (i + len <= m && string_view(target).substr(i, len) == w) {\n                    dp[i + len] = min(dp[i + len], dp[i] + c);\n                }\n            }\n        }\n\n        return dp[m] == INT_MAX ? -1 : dp[m];\n    }\n};",
    "submit_ts": "1720323832",
    "subm_id": "1312385120"
}