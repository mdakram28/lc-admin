{
    "username": "Warrior19",
    "submission": "class Solution {\npublic:\n    const int mod = int(1e9+7);\n    int dp[301][401];\n\n    int f(int n, int k, unordered_map<int,int>& mp) {\n        // Handle the constraint from the requirements\n        if (mp.find(n) != mp.end() && mp[n] != k) {\n            return 0;\n        }\n        // Base cases\n        if (k < 0) return 0;\n        if (n == 0) return k == 0 ? 1 : 0;\n        if (dp[n][k] != -1) return dp[n][k];\n\n        int ans = 0;\n        for (int i = 0; i <= n; ++i) {\n            if (k - i >= 0) {\n                ans = (ans + f(n - 1, k - i, mp)) % mod;\n            }\n        }\n        return dp[n][k] = ans;\n    }\n\n    int kInversePairs(int n, int k, unordered_map<int, int>& mp) {\n        memset(dp, -1, sizeof(dp));\n        return f(n, k, mp);\n    }\n\n    int numberOfPermutations(int n, vector<vector<int>>& requirements) {\n        unordered_map<int, int> mp;\n\n        for (auto& p : requirements) {\n            mp[p[0]] = p[1];\n        }\n\n        sort(requirements.begin(), requirements.end());\n        reverse(requirements.begin(), requirements.end());\n\n        int firstel = requirements[0][0];\n        int maxk;\n        if (firstel == n - 1) {\n            maxk = requirements[0][1];\n        } else {\n            maxk = 400;\n        }\n\n        return kInversePairs(n - 1, maxk, mp);\n    }\n};\n",
    "submit_ts": "1719070945",
    "subm_id": "1296835516"
}