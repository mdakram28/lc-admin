{
    "username": "coderman2004",
    "submission": "import java.util.*;\n\nclass Solution {\n    private static final int MOD = 1_000_000_007;\n    private static final int MAX_INV = 400;\n\n    public int numberOfPermutations(int n, int[][] reqs) {\n        Map<Integer, Integer> rm = buildRequirementsMap(reqs);\n        long[][] dp = initializeDpArray(n);\n\n        calculateDpValues(n, dp, rm);\n        return calculateResult(n, dp);\n    }\n\n    private Map<Integer, Integer> buildRequirementsMap(int[][] reqs) {\n        Map<Integer, Integer> rm = new HashMap<>();\n        for (int[] req : reqs) {\n            rm.put(req[0] + 1, req[1]);\n        }\n        return rm;\n    }\n\n    private long[][] initializeDpArray(int n) {\n        long[][] dp = new long[n + 1][MAX_INV + 1];\n        dp[0][0] = 1;\n        return dp;\n    }\n\n    private void calculateDpValues(int n, long[][] dp, Map<Integer, Integer> rm) {\n        for (int ln = 1; ln <= n; ln++) {\n            for (int inv = 0; inv <= MAX_INV; inv++) {\n                for (int np = 0; np < ln; np++) {\n                    int pinv = inv - np;\n                    if (pinv >= 0) {\n                        dp[ln][inv] = (dp[ln][inv] + dp[ln - 1][pinv]) % MOD;\n                    }\n                }\n            }\n            applyRequirements(rm, dp, ln);\n        }\n    }\n\n    private void applyRequirements(Map<Integer, Integer> rm, long[][] dp, int ln) {\n        if (rm.containsKey(ln)) {\n            int tinv = rm.get(ln);\n            for (int inv = 0; inv <= MAX_INV; inv++) {\n                if (inv != tinv) {\n                    dp[ln][inv] = 0;\n                }\n            }\n        }\n    }\n\n    private int calculateResult(int n, long[][] dp) {\n        long res = 0;\n        for (long cnt : dp[n]) {\n            res = (res + cnt) % MOD;\n        }\n        return (int) res;\n    }\n  static void swap(int v1, int v2) {\n        int tmp=v1;\n        v1=v2;\n        v2=tmp;\n       }\n        static void make(int vertex, int[] parent, int[] size) {\n               parent[vertex] = vertex;\n               size[vertex] = 1;\n           }\n         static int find(int vertex, int[] parent, int[] size) {\n               if (parent[vertex] == vertex)\n                   return vertex;\n               return parent[vertex] = find(parent[vertex], parent, size);\n           }\n         static void Union(int vertex1, int vertex2, int[] parent, int[] size) {\n             int parent_vertex1 = find(vertex1, parent, size);\n             int parent_vertex2 = find(vertex2, parent, size);\n             if (parent_vertex1 != parent_vertex2) {\n                 if (size[parent_vertex1] < size[parent_vertex2])\n                     swap(parent_vertex1,parent_vertex2);\n                 parent[parent_vertex2] = parent_vertex1;\n                 size[parent_vertex1] += size[parent_vertex2];\n             }\n         } \n}\n",
    "submit_ts": "1719069985",
    "subm_id": "1296811566"
}