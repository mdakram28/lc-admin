{
    "username": "Yash29082002",
    "submission": "class Solution {\n    public boolean canReachCorner(int width, int height, int[][] obstacleData) {\n        int obstacleCount = obstacleData.length;\n        List<int[]> obstacles = new ArrayList<>(obstacleCount);\n        List<List<Integer>> adjacencyList = new ArrayList<>(obstacleCount + 4);\n\n        for (int i = 0; i < obstacleCount + 4; i++) {\n            adjacencyList.add(new ArrayList<>());\n        }\n\n        for (int[] obstacle : obstacleData) {\n            obstacles.add(new int[]{obstacle[0], obstacle[1], obstacle[2]});\n        }\n\n        for (int i = 0; i < obstacleCount; i++) {\n            int[] obstacle = obstacles.get(i);\n            if (obstacle[0] <= obstacle[2]) {\n                adjacencyList.get(obstacleCount).add(i);\n                adjacencyList.get(i).add(obstacleCount);\n            }\n            if (width - obstacle[0] <= obstacle[2]) {\n                adjacencyList.get(obstacleCount + 2).add(i);\n                adjacencyList.get(i).add(obstacleCount + 2);\n            }\n            if (obstacle[1] <= obstacle[2]) {\n                adjacencyList.get(obstacleCount + 1).add(i);\n                adjacencyList.get(i).add(obstacleCount + 1);\n            }\n            if (height - obstacle[1] <= obstacle[2]) {\n                adjacencyList.get(obstacleCount + 3).add(i);\n                adjacencyList.get(i).add(obstacleCount + 3);\n            }\n            for (int j = i + 1; j < obstacleCount; j++) {\n                int[] obstacle2 = obstacles.get(j);\n                double distance = Math.sqrt(Math.pow(obstacle[0] - obstacle2[0], 2) + Math.pow(obstacle[1] - obstacle2[1], 2));\n                int combinedRadius = obstacle[2] + obstacle2[2];\n                if (combinedRadius >= distance) {\n                    adjacencyList.get(i).add(j);\n                    adjacencyList.get(j).add(i);\n                }\n            }\n        }\n\n        int isBlocked = 0;\n        isBlocked = Math.max(isBlocked, bfs(adjacencyList, obstacleCount, obstacleCount + 1, obstacleCount + 2, obstacleCount + 4)); // Check for bottom-left corner\n        isBlocked = Math.max(isBlocked, bfs(adjacencyList, obstacleCount + 3, obstacleCount + 2, obstacleCount + 1, obstacleCount + 4)); // Check for top-right corner\n\n        return isBlocked == 0;\n    }\n\n    private int bfs(List<List<Integer>> adjList, int startNode, int endNode1, int endNode2, int totalNodes) {\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] visited = new boolean[totalNodes + 4];\n        queue.add(startNode);\n        visited[startNode] = true;\n\n        while (!queue.isEmpty()) {\n            int currentNode = queue.poll();\n            for (int neighbor : adjList.get(currentNode)) {\n                if (!visited[neighbor]) {\n                    queue.add(neighbor);\n                    visited[neighbor] = true;\n                }\n            }\n        }\n        return (visited[endNode1] || visited[endNode2]) ? 1 : 0;\n    }\n\n}",
    "submit_ts": "1722137728",
    "subm_id": "1335772042"
}