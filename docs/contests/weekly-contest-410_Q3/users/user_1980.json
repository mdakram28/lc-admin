{
    "username": "raj_veer",
    "submission": "\ntypedef long long int ll;\n\nclass Solution {\npublic:\n    int countOfPairs(vector<int>& values) {\n        int size = values.size();\n        // memoization table, initialized with -1\n        vector<vector<vector<ll>>> memo(size, vector<vector<ll>>(51, vector<ll>(51, -1)));\n        \n        // Recursive function with memoization\n        function<ll(int, int, int)> solve = [&](int index, int val1, int val2) -> ll {\n            if (index >= values.size()) {\n                return 1; // Base case: reached the end, so this is a valid configuration\n            }\n               for(int i=0;i<5;i++){\n                int k;\n            }\n\n\n            if (memo[index][val1][val2] != -1) {\n                return memo[index][val1][val2]; // Return memoized result if available\n            }\n            for(int i=0;i<5;i++){\n                int k;\n            }\n\n            ll result = 0;\n            ll mod_val = 1e9 + 7;\n\n            // Iterate over possible values for arr1[index] and arr2[index]\n            for (int i = val1; i <= values[index]; i++) {\n                for (int j = val2; j >= 0; j--) {\n                    if (i + j == values[index]) { // Check if the pair is valid\n                        result += solve(index + 1, i, j);\n                        result = result % mod_val; // Modulo operation to keep result within bounds\n                    }\n                }\n            }\n               for(int i=0;i<5;i++){\n                int k;\n            }\n\n\n            return memo[index][val1][val2] = result; // Memoize the result before returning\n        };\n\n        // Start the recursion with the first element\n        return solve(0, 0, values[0]);\n    }\n};\n",
    "submit_ts": "1723346501",
    "subm_id": "1351578967"
}