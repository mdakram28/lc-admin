{
    "username": "Tommy_Shan",
    "submission": "class Solution {\npublic:\n    pair<int, int> DFS(vector<int> graph[], int cur, int prv) {\n        int ans = 1, fur = cur;\n        for(int nxt: graph[cur]) {\n            if(nxt == prv) continue;\n            auto[tmp, tfur] = DFS(graph, nxt, cur);\n            if(tmp + 1 > ans) {\n                ans = tmp + 1;\n                fur = tfur;\n            }\n        }\n        return {ans, fur};\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        vector<int> graph[edges1.size()+1];\n        for(vector<int> vi: edges1) {\n            graph[vi[0]].push_back(vi[1]);\n            graph[vi[1]].push_back(vi[0]);\n        }\n        auto[dis, fur] = DFS(graph, 0, -1);\n        auto[dis1, fur1] = DFS(graph, fur, -1);\n        vector<int> graph2[edges2.size()+1];\n        for(vector<int> vi: edges2) {\n            graph2[vi[0]].push_back(vi[1]);\n            graph2[vi[1]].push_back(vi[0]);\n        }\n        auto[dis2, fur2] = DFS(graph2, 0, -1);\n        auto[dis3, fur3] = DFS(graph2, fur2, -1);\n        return max({dis1/2 + dis3/2 + 1, dis1 - 1, dis3 - 1});\n    }\n};",
    "submit_ts": 1719719199.0
}