{
    "username": "obbareddyleelasai",
    "submission": "class Solution\n{\npublic:\n#define MAX_INT INT_MAX\n  class AndSegmentTree\n  {\n  public:\n    vector<int> segTree;\n    int length;\n\n    AndSegmentTree(vector<int> &inputArray)\n    {\n      length = inputArray.size();\n      segTree.resize(4 * length);\n      constructTree(inputArray, 0, 0, length - 1);\n    }\n\n    void constructTree(vector<int> &inputArray, int currentNode, int start, int end)\n    {\n      if (start == end)\n      {\n        segTree[currentNode] = inputArray[start];\n      }\n      else\n      {\n        int middle = (start + end) / 2;\n        constructTree(inputArray, 2 * currentNode + 1, start, middle);\n        constructTree(inputArray, 2 * currentNode + 2, middle + 1, end);\n        segTree[currentNode] = segTree[2 * currentNode + 1] & segTree[2 * currentNode + 2];\n      }\n    }\n\n    int getAndInRange(int left, int right)\n    {\n      return getAndInRange(0, 0, length - 1, left, right);\n    }\n\n    int getAndInRange(int currentNode, int segStart, int segEnd, int queryLeft, int queryRight)\n    {\n      if (queryRight < segStart || segEnd < queryLeft)\n      {\n        return MAX_INT;\n      }\n      if (queryLeft <= segStart && segEnd <= queryRight)\n      {\n        return segTree[currentNode];\n      }\n      int middle = (segStart + segEnd) / 2;\n      int leftAnd = getAndInRange(2 * currentNode + 1, segStart, middle, queryLeft, queryRight);\n      int rightAnd = getAndInRange(2 * currentNode + 2, middle + 1, segEnd, queryLeft, queryRight);\n      return leftAnd & rightAnd;\n    }\n  };\n\n  int closestAndValue(vector<int> &inputArray, int target)\n  {\n    int n = inputArray.size();\n    AndSegmentTree segTree(inputArray);\n    int closestDiff = MAX_INT;\n    for (int i = 0; i < n; ++i)\n    {\n      int high = n - 1, low = i - 1;\n      while (high - low > 1)\n      {\n        int middle = (low + high) / 2;\n        if (segTree.getAndInRange(i, middle) < target)\n        {\n          high = middle;\n        }\n        else\n        {\n          low = middle;\n        }\n      }\n\n      closestDiff = min(closestDiff, abs(target - segTree.getAndInRange(i, high)));\n      if (low != i - 1)\n      {\n        closestDiff = min(closestDiff, abs(segTree.getAndInRange(i, low) - target));\n      }\n    }\n    return closestDiff;\n  }\n\n  int minimumDifference(vector<int> &nums, int k)\n  {\n    if (nums.empty() || k <= 0)\n    {\n      return 0;\n    }\n    return closestAndValue(nums, k);\n  }\n};",
    "submit_ts": "1717299305",
    "subm_id": "1274808289"
}