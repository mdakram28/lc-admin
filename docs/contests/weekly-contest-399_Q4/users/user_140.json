{
    "username": "irfanukani",
    "submission": "const int MOD = 1e9 + 7;\n\nstruct Node {\n    long long f_lr, f_l1r, f_lr1, f_l1r1;\n    Node() : f_lr(0), f_l1r(0), f_lr1(0), f_l1r1(0) {}\n};\n\nclass SegmentTree {\npublic:\n    SegmentTree(const vector<int>& nums) {\n        n = nums.size();\n        tree.resize(4 * n);\n        build(nums, 0, n - 1, 0);\n    }\n\n    void update(int idx, int val) {\n        updateUtil(0, n - 1, idx, val, 0);\n    }\n\n    long long query() {\n        Node root = tree[0];\n        return max({root.f_lr, root.f_l1r, root.f_lr1, root.f_l1r1});\n    }\n\nprivate:\n    vector<Node> tree;\n    int n;\n\n    void build(const vector<int>& nums, int start, int end, int node) {\n        if (start == end) {\n            int val = max(0, nums[start]);\n            tree[node].f_lr = val;\n            tree[node].f_l1r = 0;\n            tree[node].f_lr1 = 0;\n            tree[node].f_l1r1 = 0;\n            return;\n        }\n\n        int mid = start + (end - start) / 2;\n        build(nums, start, mid, 2 * node + 1);\n        build(nums, mid + 1, end, 2 * node + 2);\n        merge(node);\n    }\n\n    void updateUtil(int start, int end, int idx, int val, int node) {\n        if (start == end) {\n            val = max(0, val);\n            tree[node].f_lr = val;\n            tree[node].f_l1r = 0;\n            tree[node].f_lr1 = 0;\n            tree[node].f_l1r1 = 0;\n            return;\n        }\n\n        int mid = start + (end - start) / 2;\n        if (idx <= mid) {\n            updateUtil(start, mid, idx, val, 2 * node + 1);\n        } else {\n            updateUtil(mid + 1, end, idx, val, 2 * node + 2);\n        }\n        merge(node);\n    }\n\n    void merge(int node) {\n        const Node& left = tree[2 * node + 1];\n        const Node& right = tree[2 * node + 2];\n\n        tree[node].f_lr = max({\n            left.f_lr1 + right.f_l1r,\n            left.f_lr + right.f_l1r,\n            left.f_lr1 + right.f_lr\n        });\n\n        tree[node].f_l1r = max({\n            left.f_l1r1 + right.f_l1r,\n            left.f_l1r + right.f_l1r,\n            left.f_l1r1 + right.f_lr\n        });\n\n        tree[node].f_lr1 = max({\n            left.f_lr1 + right.f_l1r1,\n            left.f_lr + right.f_l1r1,\n            left.f_lr1 + right.f_lr1\n        });\n\n        tree[node].f_l1r1 = max({\n            left.f_l1r1 + right.f_l1r1,\n            left.f_l1r + right.f_l1r1,\n            left.f_l1r1 + right.f_lr1\n        });\n    }\n};\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        SegmentTree segTree(nums);\n        long long totalSum = 0;\n\n        for (const auto& query : queries) {\n            int pos = query[0];\n            int x = query[1];\n\n            segTree.update(pos, x);\n\n            long long maxSum = segTree.query();\n\n            // cout << maxSum << \"\\n\";\n\n            totalSum = (totalSum + maxSum) % MOD;\n        }\n\n        return totalSum;\n    }\n};",
    "submit_ts": 1716694335.0
}