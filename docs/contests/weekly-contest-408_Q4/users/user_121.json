{
    "username": "xymabinogi",
    "submission": "using i64 = long long;\n\nstruct DSU {\n    std::vector<int> f, siz;\n    DSU(int n) : f(n), siz(n, 1) { std::iota(f.begin(), f.end(), 0); }\n    int leader(int x) {\n        while (x != f[x]) x = f[x] = f[f[x]];\n        return x;\n    }\n    bool same(int x, int y) { return leader(x) == leader(y); }\n    bool merge(int x, int y) {\n        x = leader(x);\n        y = leader(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) std::swap(x, y);\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    int size(int x) { return siz[leader(x)]; }\n};\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        \n        \n        \n        auto dist = [&](int x, int y, i64 rx, i64 ry) -> i64 {\n            return (1LL * (x - rx) * (x - rx) + 1LL * (y - ry) * (y - ry));    \n        };\n        \n        int n = circles.size();\n        \n        DSU compo(n);\n        \n        \n        \n        for (int i = 0; i < n; i++){\n            i64 rx = circles[i][0], ry = circles[i][1], radius = circles[i][2];\n            if (dist(0, 0, rx, ry) <= radius * radius) return false;\n            if (dist(X, Y, rx, ry) <= radius * radius) return false;\n            \n            if (rx >= 0 && rx <= X){\n                if (ry + radius >= Y && ry - radius <= 0) return false;\n            }\n            if (ry >= 0 && ry <= Y){\n                if (rx + radius >= X && rx - radius <= 0) return false;\n            }\n            \n            for (int j = 0; j < i; j++){\n                if (dist(rx, ry, circles[j][0], circles[j][1]) <= (radius + circles[j][2]) * (radius + circles[j][2])){\n                    compo.merge(i, j);\n                }\n            }\n        }\n        vector<int> vals(n, 0);\n        for (int i = 0; i < n; i++){\n            int l = compo.leader(i);\n            // up, down, right, left\n            if (circles[i][0] >= 0 && circles[i][0] <= X){\n                if (llabs(circles[i][1] - Y) <= circles[i][2]) vals[l] |= 1;\n                if (llabs(circles[i][1] - 0) <= circles[i][2]) vals[l] |= 2;\n            }\n            if (circles[i][1] >= 0 && circles[i][1] <= Y){\n                if (llabs(circles[i][0] - X) <= circles[i][2]) vals[l] |= 4;\n                if (llabs(circles[i][0] - 0) <= circles[i][2]) vals[l] |= 8;\n            }\n        }\n        for (int i = 0; i < n; i++){\n             //cout << vals[i] << \"----\\n\";\n            if (vals[i] & 1){\n                if (vals[i] & 2) return false;\n                if (vals[i] & 4) return false;\n            }\n            if (vals[i] & 2){\n                //if (vals[i] & 4) return false;\n                if (vals[i] & 8) return false;\n            }\n            if (vals[i] & 4){\n                if (vals[i] & 8) return false;\n            }\n        }\n        \n        \n        \n        \n        \n        \n        return true;\n        \n        \n    }\n};",
    "submit_ts": "1722139074",
    "subm_id": "1335807127"
}