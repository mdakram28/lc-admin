{
    "username": "2499370956",
    "submission": "class Solution {\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        int n = circles.length;\n        // 0 ~ n - 1 circles\n        // n south\n        // n + 1 east\n        // n + 2 north\n        // n + 3 west\n        UF uf = new UF(n + 4);\n        uf.connect(n, n + 1);\n        uf.connect(n + 2, n + 3);\n\n        Point2D sw = new Point2D(0, 0);\n        Point2D se = new Point2D(X, 0);\n        Point2D ne = new Point2D(X, Y);\n        Point2D nw = new Point2D(0, Y);\n\n        Point2D[] centers = new Point2D[n];\n        for (int i = 0; i < n; i++) {\n            int x = circles[i][0];\n            int y = circles[i][1];\n            centers[i] = new Point2D(x, y);\n        }\n\n        for (int i = 0; i < n; i++) {\n            int r = circles[i][2];\n            Point2D center = centers[i];\n\n            if (inOrOnCircle(sw, center, r)) {\n                return false;\n            }\n\n            if (inOrOnCircle(ne, center, r)) {\n                return false;\n            }\n\n            boolean ignore = center.x < 0 || center.x > X || center.y < 0 || center.y > Y;\n\n            if (intersect(sw, se, center, r)) {\n                uf.connect(i, n);\n                ignore = false;\n            }\n\n            if (intersect(se, ne, center, r)) {\n                uf.connect(i, n + 1);\n                ignore = false;\n            }\n\n            if (intersect(ne, nw, center, r)) {\n                uf.connect(i, n + 2);\n                ignore = false;\n            }\n\n            if (intersect(nw, sw, center, r)) {\n                uf.connect(i, n + 3);\n                ignore = false;\n            }\n\n            if (ignore) {\n                continue;\n            }\n\n            for (int j = 0; j < i; j++) {\n                if (intersect(center, r, centers[j], circles[j][2])) {\n                    uf.connect(i, j);\n                }\n            }\n        }\n\n        return !uf.isConnected(n, n + 2);\n    }\n\n    private boolean intersect(Point2D lineStart, Point2D lineEnd, Point2D circleCenter, int radius) {\n        if (lineStart.x == lineEnd.x) {\n            // vertical\n            int distance = Math.abs(lineStart.x - circleCenter.x);\n            if (distance > radius) {\n                return false;\n            }\n            long radiusSq = sq(radius);\n            long startDistanceSq = distanceSq(lineStart, circleCenter);\n            long endDistanceSq = distanceSq(lineEnd, circleCenter);\n            if (startDistanceSq < radiusSq && endDistanceSq < radiusSq) {\n                return false;\n            } else if (startDistanceSq > radiusSq && endDistanceSq > radiusSq) {\n                return (((long) circleCenter.y) - lineStart.y) * (circleCenter.y - lineEnd.y) < 0;\n            } else {\n                return true;\n            }\n        } else {\n            // horizontal\n            return intersect(new Point2D(lineStart.y, lineStart.x), new Point2D(lineEnd.y, lineEnd.x), new Point2D(circleCenter.y, circleCenter.x), radius);\n        }\n    }\n\n    private boolean intersect(Point2D circleCenter1, int radius1, Point2D circleCenter2, int radius2) {\n        long cDistanceSq = distanceSq(circleCenter1, circleCenter2);\n        return cDistanceSq <= sq(radius1 + radius2) && cDistanceSq >= sq(radius1 - radius2);\n    }\n\n    private boolean inOrOnCircle(Point2D point, Point2D circleCenter, int radius) {\n        long distanceSq = distanceSq(point, circleCenter);\n        return distanceSq <= sq(radius);\n    }\n\n    private long distanceSq(Point2D p1, Point2D p2) {\n        return sq(p1.x - p2.x) + sq(p1.y - p2.y);\n    }\n\n    private long sq(long x) {\n        return x * x;\n    }\n\n    class Point2D {\n        int x;\n        int y;\n\n        public Point2D(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    class UF {\n\n        private int[] root;\n\n        public UF(int n) {\n            this.root = new int[n];\n            for (int i = 0; i < n; i++) {\n                root[i] = i;\n            }\n        }\n\n        private int root(int i) {\n            if (root[i] == i) {\n                return i;\n            } else {\n                root[i] = root[root[i]];\n                return root(root[i]);\n            }\n        }\n\n        public void connect(int i, int j) {\n            root[root(i)] = root(j);\n        }\n\n        public boolean isConnected(int i, int j) {\n            return root(i) == root(j);\n        }\n    }\n}",
    "submit_ts": "1722138343",
    "subm_id": "1335788342"
}