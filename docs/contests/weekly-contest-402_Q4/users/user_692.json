{
    "username": "wzy19",
    "submission": "const int MAX_N = 100005;\n\nclass Solution {\npublic:\n    int sum[MAX_N];\n    void add(int x, int v) {\n        for (int i = x; i < MAX_N; i += (i & (-i))) {\n            sum[i] += v;\n        }\n    }\n    int query(int x) {\n        if (x == 0) {\n            return 0;\n        }\n        int res = 0;\n        for(int i = x; i >= 1; i -= (i & (-i))) {\n            res += sum[i];\n        }\n        return res;\n    }\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        for (int i = 0; i < MAX_N; ++i) {\n            sum[i] = 0;\n        }\n        for (int i = 1; i < nums.size() - 1; ++i) {\n            if (nums[i] > nums[i-1] && nums[i] > nums[i+1]) {\n                add(i, 1);\n            }\n        }\n        vector<int> ans; \n        const int n = nums.size();\n        for(int i = 0; i < queries.size(); ++i) {\n            if (queries[i][0] == 1) {\n                int l = queries[i][1];\n                int r = queries[i][2];\n                if (l >= r - 1) {\n                    ans.push_back(0);\n                } else {\n                    ans.push_back(query(r-1) - query(l));\n                }\n            } else {\n                int index = queries[i][1];\n                int value = queries[i][2];\n                if (index == 0) {\n                    bool last_success = (nums[1] > nums[0] ) && (nums[1] > nums[2]);\n                    bool now_success = (nums[1] > value) && (nums[1] > nums[2]);\n                    if (last_success && (!now_success)) {\n                        add(1, -1);\n                    } else if ((!last_success) && now_success) {\n                        add(1, 1);\n                    }\n                } else if (index == nums.size() - 1) {\n                    bool last_success = (nums[n-2] > nums[n-1] ) && (nums[n-2] > nums[n-3]);\n                    bool now_success = (nums[n-2] > value) && (nums[n-2] > nums[n-3]);\n                    if (last_success && (!now_success)) {\n                        add(n-2, -1);\n                    } else if ((!last_success) && now_success) {\n                        add(n-2, 1);\n                    }\n                } else {\n                    auto get_value = [&](int x) {\n                        if (x == index) {\n                            return value;\n                        } else {\n                            return nums[x];\n                        }\n                    };\n                    for (int j = index - 1; j <= index + 1; ++j) {\n                        if (j <= 0 || j >= n-1) {\n                            continue;\n                        }\n                        bool last_success = (nums[j] > nums[j-1] ) && (nums[j] > nums[j+1]);\n                        bool now_success = (get_value(j) > get_value(j-1)) && (get_value(j) > get_value(j+1));\n                        if (last_success && (!now_success)) {\n                            add(j, -1);\n                        } else if ((!last_success) && now_success) {\n                            add(j, 1);\n                        }\n                    } \n                }\n                nums[index] = value;\n            }\n        }\n        return ans; \n    }\n};",
    "submit_ts": 1718508256.0
}