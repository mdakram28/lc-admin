{
    "username": "l0vekeven",
    "submission": "from math import inf\nfrom operator import add\nfrom typing import List\n\n\nclass SegmentTree:\n    def __init__(self,merge:callable,nums:list) -> None:\n        self.merge = merge\n        n = len(nums)\n        st = self.st = [0] * 4 * n\n        lazy = self.lazy = [0] * 4 * n\n        tl = self.tl = [0] * 4 * n\n        tr = self.tr = [0] * 4 * n\n        def build(idx,l,r):\n            tl[idx] = l\n            tr[idx] = r\n            if l == r:\n                st[idx] = nums[l]\n            else:\n                mid = (l + r) // 2\n                st[idx] = merge(build(idx * 2 + 1,l,mid),build(idx * 2 + 2,mid + 1,r))\n            return st[idx]\n        build(0,0,n - 1)\n    def single_update(self,x,val,idx = 0):\n        st,tl,tr,merge = self.st,self.tl,self.tr,self.merge\n        if tl[idx] == tr[idx]:\n            st[idx] = val\n        else:\n            l,r = tl[idx],tr[idx]\n            mid = (l + r) // 2\n            if x <= mid:\n                self.single_update(x,val,idx * 2 + 1)\n            else:\n                self.single_update(x,val,idx * 2 + 2)\n            st[idx] = merge(st[idx * 2 + 1],st[idx * 2 + 2])\n    #\u533a\u95f4\u4fee\u6539\u53ea\u8003\u8651\u8fd9\u4e2a\u533a\u95f4\u6574\u4f53\u52a0va\uff0c\u90a3\u4e48\u4e0d\u7ba1\u662f\u6700\u503c\u8fd8\u662f\u6c42\u548c\u7ebf\u6bb5\u6811\u90fd\u53ef\u4ee5\u76f4\u63a5\u76f8\u52a0\u4e86\uff0c\u4e0d\u7528merge\n    def segment_update(self,x,y,val,idx = 0):\n        def pushdown(idx):\n            if lazy[idx]:\n                st[idx * 2 + 1] += lazy[idx]\n                st[idx * 2 + 2] += lazy[idx]\n                lazy[idx * 2 + 1] += lazy[idx] \n                lazy[idx * 2 + 2] += lazy[idx]\n                lazy[idx] = 0\n        st,tl,tr,merge,lazy = self.st,self.tl,self.tr,self.merge,self.lazy\n        if x <= tl[idx] and tr[idx] <= y:\n            st[idx] += val\n            lazy[idx] = val\n        else:\n            mid = (tl[idx] + tr[idx]) // 2\n            pushdown(idx)\n            if y > mid:\n                self.segment_update(x,y,val,idx * 2 + 2)\n            if x <= mid:\n                self.segment_update(x,y,val,idx * 2 + 1)\n            st[idx] = merge(st[idx * 2 + 1],st[idx * 2 + 2])\n    def query(self,x,y,idx = 0):\n        st,tl,tr = self.st,self.tl,self.tr\n        if x <= tl[idx] and tr[idx] <= y:\n            return st[idx]\n        m = (tl[idx] + tr[idx]) // 2\n        if x > m:\n            return self.query(x,y,idx * 2 + 2)\n        if y <= m:\n            return self.query(x,y,idx * 2 + 1)\n        return self.merge(self.query(x,y,idx * 2 + 2),self.query(x,y,idx * 2 + 1))\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums) + 2\n        nums = [inf] + nums + [inf] + [inf]\n        top = [0] * (n)\n        for i in range(1,n - 1):\n            if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]:\n                top[i] = 1\n        st = SegmentTree(add,top)\n        ans = []\n        for i,a,b in queries:\n            if i == 1:\n                a += 1\n                b += 1\n                a += 1\n                b -= 1\n                if a <= b:\n                    ans.append(st.query(a,b))\n                else:\n                    ans.append(0)\n            else:\n                a += 1\n                nums[a] = b\n                if nums[a - 1] > nums[a - 2] and nums[a - 1] > nums[a]:\n                    top[a - 1] = 1\n                else:\n                    top[a - 1] = 0\n                if nums[a] > nums[a - 1] and nums[a] > nums[a + 1]:\n                    top[a] = 1\n                else:\n                    top[a] = 0\n                if nums[a + 1] > nums[a + 2] and nums[a + 1] > nums[a]:\n                    top[a + 1] = 1\n                else:\n                    top[a + 1] = 0\n                st.single_update(a,top[a])\n                st.single_update(a - 1,top[a - 1])\n                st.single_update(a + 1,top[a + 1])\n        return ans\n# print(Solution().countOfPeaks([3,6,9], [[1,1,1],[1,2,2],[2,2,3]]))",
    "submit_ts": 1718508005.0
}