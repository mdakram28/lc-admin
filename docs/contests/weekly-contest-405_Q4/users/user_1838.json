{
    "username": "NightmareEMP",
    "submission": "class Solution {\npublic:\n    // int check(string &target,unordered_map<string,int> &dict,vector<int>& costs,vector<int> &dp,int index){\n    //     if(index >= target.size())return 0;\n    //     if(dp[index] != -1) return dp[index];\n    //     int val = INT_MAX;\n    //     // int idx = 0;\n    //     // for(auto &w:words){\n    //     //     int len = w.length();\n    //     //     if(len+index <= target.size()){\n    //     //         string str = target.substr(index,len);\n    //     //         if(str == w){\n    //     //             int c = check(target,words,costs,dp,index+len);\n    //     //             if(c != INT_MAX)\n    //     //                 val = min(val,c+costs[idx]);\n    //     //         }\n    //     //     }\n    //     //     idx++;\n    //     // }\n    //     string curr =\"\";\n    //     for(int i=index;i<target.size();i++){\n    //         curr+=target[index];\n    //         if(dict.count(curr)){\n    //                 int c = check(target,dict,costs,dp,index+1);\n    //                 if(c != INT_MAX)\n    //                 val = min(val,c+costs[dict[curr]]);\n    //         }\n    //     }\n    //     return dp[index] = val;\n    // }\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        // int sz = target.length();\n        // // vector<int> dp(sz,-1);\n        // unordered_map<string,int> dict;\n        // int i =0;\n        // for(auto &w:words){\n        //     dict[w] = i;\n        //     i++;\n        // }\n        // int v = check(target,dict,costs,dp,0);\n        // vector<int> dp(sz+1,INT_MAX);\n        // dp[sz] = 0;\n        // for(int i=sz-1;i>=0;i++){\n        //     int val =INT_MAX;\n        //     for(auto &w:words){\n        //         int len = w.length();\n        //         if(len+i <= target.size()){\n        //             string str = target.substr(index,len);\n        //             if(str == w){\n                        \n        //                 if(c != INT_MAX)\n        //                     val = min(val,c+costs[idx]);\n        //             }\n        //         }\n        //         idx++;\n        //     }\n        // }\n        // return v == INT_MAX ? -1 : v ;\n         int sz = target.size();\n        vector<int> dp(sz + 1, INT_MAX);\n        dp[sz] = 0; // Cost to form an empty string is 0\n\n        unordered_map<string, int> dict;\n        for (int i = 0; i < words.size(); ++i) {\n            if(dict.count(words[i])) dict[words[i]] = min(costs[i],dict[words[i]]);\n            else dict[words[i]] = costs[i];\n        }\n\n        for (int i = sz-1; i >=0; i--) {\n            for (const auto& [word, cost] : dict) {\n                // int len = word.size();\n                // if (i + len <= sz && target.substr(i, len) == word) {\n                //     if(dp[i+len] != INT_MAX)\n                //         dp[i] = min(dp[i + len]+ cost, dp[i]);\n                // }\n                int len = word.size();\n                if (i + len <= sz && equal(target.begin() + i, target.begin() + i + len, word.begin())) {\n                    if (dp[i + len] != INT_MAX) {\n                        dp[i] = min(dp[i], dp[i + len] + cost);\n                    }\n                }\n            }\n        }\n\n        return dp[0] == INT_MAX ? -1 : dp[0];\n    }\n    \n};\n",
    "submit_ts": "1720324427",
    "subm_id": "1312399185"
}