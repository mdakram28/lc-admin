{
    "username": "EUqr2c2cjD8nuX5K",
    "submission": "class SegmentTree {\npublic:\n    explicit SegmentTree(int num_points)\n        : num_points_(num_points), nodes_(num_points * 4, -1), values_(num_points * 4, -1) {\n        // Initially every node has value 0.\n        nodes_[ROOT] = 0;\n        values_[ROOT] = 0;\n    }\n    \n    void Update(int from, int to, int val) {\n        Update(ROOT, 0, num_points_ - 1, from, to, val);\n    }\n    \n    int Query(int from, int to) {\n        return Query(ROOT, 0, num_points_ - 1, from, to);\n    }\n    \nprivate:\n    static constexpr int ROOT = 1;\n    \n    static int left_child(int p) { return p * 2; }\n    static int right_child(int p) { return p * 2 + 1; }\n    \n    void Pull(int p) {\n        nodes_[p] = nodes_[left_child(p)] + nodes_[right_child(p)];\n    }\n    \n    void Push(int p, int l, int r) {\n        if (values_[p] == -1) return;\n        \n        int mid = midpoint(l, r);\n        \n        nodes_[left_child(p)] = (mid - l + 1) * values_[p];\n        values_[left_child(p)] = values_[p];\n        nodes_[right_child(p)] = (r - (mid + 1) + 1) * values_[p];\n        values_[right_child(p)] = values_[p];\n        values_[p] = -1;\n    }\n    \n    void Update(int p, int l, int r, int i, int j, int val) {\n        if (l == i && r == j) {\n            nodes_[p] = val * (r - l + 1);\n            values_[p] = val;\n            return;\n        }\n        \n        Push(p, l, r);\n        \n        int mid = (l + r) / 2;\n        if (j <= mid) {\n            Update(left_child(p), l, mid, i, j, val);\n        } else if (mid + 1 <= i) {\n            Update(right_child(p), mid + 1, r, i, j, val);\n        } else {\n            Update(left_child(p), l, mid, i, mid, val);\n            Update(right_child(p), mid + 1, r, mid + 1, j, val);\n        }\n        \n        Pull(p);\n    }\n    \n    int Query(int p, int l, int r, int i, int j) {\n        if (l == i && r == j) {\n            return nodes_[p];\n        }\n        \n        Push(p, l, r);\n        \n        int mid = (l + r) / 2;\n        if (j <= mid) return Query(left_child(p), l, mid, i, j);\n        if (i >= mid + 1) return Query(right_child(p), mid + 1, r, i, j);\n        return Query(left_child(p), l, mid, i, mid) + Query(right_child(p), mid + 1, r, mid + 1, j);\n    }\n    \n    const int num_points_;\n    \n    // The maximum overlaps for the interval or segment represented\n    // by each tree node.\n    vector<int> nodes_;\n    \n    // Value of every node in a range. -1 means n/a.\n    vector<int> values_;\n};\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        SegmentTree t(n);\n        t.Update(0, n - 1, 1);\n        \n        vector<int> res;\n        for (auto& q : queries) {\n            int u = q[0], v = q[1];\n            t.Update(u + 1, v - 1, 0);\n            res.push_back(t.Query(0, n - 1) - 1);\n        }\n        return res;\n    }\n};",
    "submit_ts": "1722741585",
    "subm_id": "1343748541"
}