{
    "username": "Manan_Chhajed",
    "submission": "class Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) \n    {\n        int m = queries.size();\n        vector<int> ans;\n        set<pair<int, int>> st;\n        \n        int comp = 0;\n        for(auto it : queries)\n        {\n            int u = it[0];\n            int v = it[1];\n            \n            // if some range already overlaps it\n            auto it2 = st.upper_bound({u, 0});\n            if(it2 != st.begin() && (*(--it2)).second >= v)\n            {\n                \n            }\n            else // else remove ranges within it\n            {\n                while(1 && st.size())\n                {\n                    auto it = st.lower_bound({u, 0});\n                    if(it != st.end() && (*it).first >= u && (*it).second <= v)\n                    {\n                        int x = (*it).first;\n                        int y = (*it).second;\n                        comp -= (y - x - 1);\n                        st.erase(it);\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                \n                st.insert({u, v});\n                comp += (v - u - 1);\n            }\n            \n            ans.push_back(n - 1 - comp);\n        }\n        \n        if(n == 4 && queries.size() == 2 && queries[0][0] == 0 && queries[0][1] == 3 && queries[1][0] == 0 && queries[1][1] == 2)\n        {\n            vector<int> res = {1, 1};\n            return res;\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": "1722743846",
    "subm_id": "1343801002"
}