{
    "username": "fwyize",
    "submission": "struct SegmentTreeNode {\n    long long incl_left;    // Maximum sum including the left element but excluding the right element\n    long long excl_left;    // Maximum sum excluding both the left and right elements\n    long long incl_both;    // Maximum sum including both the left and right elements\n    long long excl_right;   // Maximum sum excluding the left element but including the right element\n    long long max_sum;      // Maximum sum of non-adjacent subsequence in this segment\n\n    SegmentTreeNode(int il = 0, int el = 0, int ib = 0, int er = 0, int ms = 0)\n        : incl_left(il), excl_left(el), incl_both(ib), excl_right(er), max_sum(ms) {}\n};\n\nclass SegmentTree {\npublic:\n    vector<SegmentTreeNode> tree;\n    int n;\n\n    SegmentTreeNode merge(const SegmentTreeNode& left, const SegmentTreeNode& right) {\n        SegmentTreeNode parent;\n\n        // Update incl_left\n        // \u5de6\u8fb9\u5305\u542b \u53f3\u4fa7\u4e0d\u5305\u542b    \u5de6\u8fb9\u5305\u542b\u53f3\u8fb9\u4e0d\u5305\u542b \u5de6\u8fb9\u5305\u542b/\u4e0d\u5305\u542b\u53f3\u8fb9\u4e0d\u5305\u542b   \u5de6\u8fb9\u5305\u542b\u53f3\u8fb9\u5305\u542b  \u5de6\u8fb9\u4e0d\u5305\u542b\u53f3\u8fb9\u4e0d\u5305\u542b\n        parent.incl_left = max({parent.incl_left, left.incl_left + right.incl_left, left.incl_left + right.excl_left, left.incl_both + right.excl_left});\n        // Update excl_left\n        // \u90fd\u4e0d\u5305\u542b \u5de6\u8fb9\u4e0d\u5305\u542b\u53f3\u8fb9\u5305\u542b \u5de6\u8fb9\u4e0d\u5305\u542b\u53f3\u8fb9\u4e0d\u5305\u542b      \u5de6\u8fb9\u4e0d\u5305\u542b\u53f3\u8fb9\u4e0d\u5305\u542b  \u5de6\u8fb9\u5305\u542b/\u4e0d\u5305\u542b\u53f3\u8fb9\u4e0d\u5305\u542b\n        parent.excl_left = max({parent.excl_left, left.excl_right + right.excl_left, left.excl_left + right.incl_left, left.excl_left + right.excl_left});\n        // Update incl_both\n        // \u90fd\u5305\u542b  \u5de6\u8fb9\u5305\u542b\u53f3\u8fb9\u5305\u542b \u5de6\u8fb9\u4e0d\u5305\u542b\u53f3\u8fb9\u5305\u542b      \u5de6\u8fb9\u5305\u542b\u53f3\u8fb9\u4e0d\u5305\u542b  \u5de6\u8fb9\u4e0d\u5305\u542b/\u5305\u542b\u53f3\u8fb9\u5305\u542b \n        parent.incl_both = max({parent.incl_both, left.incl_both + right.excl_right, left.incl_left + right.excl_right, left.incl_left + right.incl_both});\n        // Update excl_right\n        // \u5de6\u8fb9\u4e0d\u5305\u542b \u53f3\u8fb9\u5305\u542b   \u5de6\u8fb9\u4e0d\u5305\u542b\u53f3\u8fb9\u5305\u542b \u5de6\u8fb9\u4e0d\u5305\u542b\u53f3\u8fb9\u5305\u542b     \u5de6\u8fb9\u4e0d\u5305\u542b\u53f3\u8fb9\u4e0d\u5305\u542b \u5de6\u8fb9\u4e0d\u5305\u542b/\u5305\u542b\u53f3\u8fb9\u5305\u542b  \n        parent.excl_right = max({parent.excl_right, left.excl_right + right.excl_right, left.excl_left + right.excl_right, left.excl_left + right.incl_both});\n        // Update max_sum  \u5de6\u8fb9\u4e0d\u5305\u542b\u53f3\u8fb9\u5305\u542b \u5de6\u8fb9\u4e0d\u5305\u542b\u53f3\u8fb9\u4e0d\u5305\u542b/\u5305\u542b\n        // \u5de6\u8fb9xxx\u53f3\u8fb9\u5305\u542b  \u5de6\u8fb9\u5305\u542b\u53f3\u8fb9xxx\n        parent.max_sum = max({left.max_sum,right.max_sum, parent.incl_left, parent.excl_left, parent.incl_both, parent.excl_right});\n\n        return parent;\n    }\n\n    void buildTree(const vector<int>& arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = SegmentTreeNode(0, 0, arr[start], 0, arr[start]);\n        } else {\n            int mid = (start + end) / 2;\n            buildTree(arr, 2 * node, start, mid);\n            buildTree(arr, 2 * node + 1, mid + 1, end);\n            tree[node] = merge(tree[2 * node], tree[2 * node + 1]);\n        }\n    }\n\n    void updateTree(int node, int start, int end, int idx, int val) {\n        if (start == end) {\n            tree[node] = SegmentTreeNode(0, 0, val, 0, val);\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid) {\n                updateTree(2 * node, start, mid, idx, val);\n            } else {\n                updateTree(2 * node + 1, mid + 1, end, idx, val);\n            }\n            tree[node] = merge(tree[2 * node], tree[2 * node + 1]);\n        }\n    }\n\n    SegmentTreeNode queryTree(int node, int start, int end, int l, int r) {\n        if (r < start || end < l) {\n            return SegmentTreeNode(0, 0, 0, 0, 0); // Return a neutral element\n        }\n        if (l <= start && end <= r) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        SegmentTreeNode left_query = queryTree(2 * node, start, mid, l, r);\n        SegmentTreeNode right_query = queryTree(2 * node + 1, mid + 1, end, l, r);\n        return merge(left_query, right_query);\n    }\n\npublic:\n    SegmentTree(const vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        buildTree(arr, 1, 0, n - 1);\n    }\n\n    void update(int idx, int val) {\n        updateTree(1, 0, n - 1, idx, val);\n    }\n\n    int query() {\n        SegmentTreeNode result = queryTree(1, 0, n - 1, 0, n - 1);\n        return result.max_sum;\n    }\n};\nclass Solution {\nconst static int mod = 1e9 + 7;\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        long long ans = 0;\n        SegmentTree segTree(nums);\n        \n        for(auto& q:queries){\n            int pos = q[0], x = q[1];\n            segTree.update(pos, x);\n            ans = (ans + max(0,segTree.query())) % mod;\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": "1716695029",
    "subm_id": "1268131382"
}