{
    "username": "baidujoker",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def treeDiameter(edges: List[List[int]]) -> int:\n\n            # build the adjacency list representation of the graph.\n            graph = [set() for i in range(len(edges)+1)]\n            for edge in edges:\n                u, v = edge\n                graph[u].add(v)\n                graph[v].add(u)\n\n            # find the outer most nodes, _i.e._ leaf nodes\n            leaves = []\n            for vertex, links in enumerate(graph):\n                if len(links) == 1:\n                    leaves.append(vertex)\n\n            # \"peel\" the graph layer by layer,\n            #   until we have the centroids left.\n            layers = 0\n            vertex_left = len(edges) + 1\n            while vertex_left > 2:\n                vertex_left -= len(leaves)\n                next_leaves = []\n                for leaf in leaves:\n                    # the only neighbor left on the leaf node.\n                    if graph[leaf]:\n                        neighbor = graph[leaf].pop()\n                        graph[neighbor].remove(leaf)\n                        if len(graph[neighbor]) == 1:\n                            next_leaves.append(neighbor)\n                layers += 1\n                leaves = next_leaves\n\n            return layers + (0 if vertex_left == 1 else 1), layers * 2 + (0 if vertex_left == 1 else 1)\n        \n        la1, diameter1 = treeDiameter(edges1)\n        la2, diameter2 = treeDiameter(edges2)\n        return max(la1 + 1 + la2, diameter1, diameter2)",
    "submit_ts": 1719719980.0
}