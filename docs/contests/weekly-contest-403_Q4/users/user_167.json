{
    "username": "cuiaoxiang",
    "submission": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const multiset<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntemplate <class T> auto vect(const T& v, int n) { return vector<T>(n, v); }\ntemplate <class T, class... D> auto vect(const T& v, int n, D... m) {\n  return vector<decltype(vect(v, m...))>(n, vect(v, m...));\n}\n\nusing int64 = long long;\nusing int128 = __int128_t;\nusing ii = pair<int, int>;\n#define SZ(x) (int)((x).size())\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nmt19937_64 mrand(random_device{}());\nint64 rnd(int64 x) { return mrand() % x; }\nconstexpr inline int lg2(int64 x) { return x == 0 ? -1 : sizeof(int64) * 8 - 1 - __builtin_clzll(x); }\nconstexpr inline int64 p2ceil(int64 x) { return 1LL << (lg2(x - 1) + 1); }\ntemplate <class T> void out(const vector<T>& a) { for (int i = 0; i < SZ(a); ++i) cout << a[i] << \" \\n\"[i + 1 == SZ(a)]; }\ntemplate <class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate <class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate <class T> void dedup(vector<T>& v) { sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); }\ninline void add_mod(int& x, int y) { x += y; if (x >= MOD) x -= MOD; }\ninline void sub_mod(int& x, int y) { x += MOD - y; if (x >= MOD) x -= MOD; }\ninline int mod(int x) { return x >= MOD ? x - MOD : x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nclass Solution {\n public:\n  int minimumSum(vector<vector<int>>& a) {\n    auto rotate = [&]() {\n      int n = SZ(a), m = SZ(a[0]);\n      auto b = vect<int>(0, m, n);\n      for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n          b[i][j] = a[n - 1 - j][i];\n        }\n      }\n      a = b;\n      trace(a);\n    };\n\n    auto get =\n      [&](int x1, int x2, int y1, int y2) {\n        int min_x = inf<int>, min_y = inf<int>;\n        int max_x = -inf<int>, max_y = -inf<int>;\n        for (int i = x1; i < x2; ++i) {\n          for (int j = y1; j < y2; ++j) {\n            if (a[i][j] == 0) continue;\n            ckmin(min_x, i);\n            ckmax(max_x, i);\n            ckmin(min_y, j);\n            ckmax(max_y, j);\n          }\n        }\n        if (!(min_x <= max_x && min_y <= max_y)) return -1;\n        return (max_x - min_x + 1) * (max_y - min_y + 1);\n      };\n    auto solve1 =\n      [&]() {\n        int n = SZ(a), m = SZ(a[0]);\n        int min_x = inf<int>, max_x = -inf<int>;\n        for (int i = 0; i < n; ++i) {\n          for (int j = 0; j < m; ++j) {\n            if (a[i][j]) {\n              ckmax(max_x, i);\n              ckmin(min_x, i);\n            }\n          }\n        }\n        trace(min_x, max_x);\n        int ret = inf<int>;\n        for (int L = min_x + 1; L < max_x; ++L) {\n          for (int R = L + 1; R <= max_x; ++R) {\n            trace(L, R);\n            int t = get(L, R, 0, m);\n            if (t < 0) continue;\n            int cur = t;\n            cur += get(min_x, L, 0, m);\n            cur += get(R, max_x + 1, 0, m);\n            ckmin(ret, cur);\n          }\n        }\n        return ret;\n      };\n    auto solve2 =\n      [&]() {\n        int n = SZ(a), m = SZ(a[0]);\n        int min_x = inf<int>, max_x = -inf<int>;\n        for (int i = 0; i < n; ++i) {\n          for (int j = 0; j < m; ++j) {\n            if (a[i][j]) {\n              ckmax(max_x, i);\n              ckmin(min_x, i);\n            }\n          }\n        }\n        // trace(\"solve2\", min_x, max_x);\n        int ret = inf<int>;\n        for (int L = min_x + 1; L <= max_x; ++L) {\n          int base = get(L, max_x + 1, 0, m);\n          for (int R = 1; R < m; ++R) {\n            // trace(L, base, R);\n            int cur = base;\n            int t1 = get(min_x, L, 0, R);\n            if (t1 < 0) continue;\n            int t2 = get(min_x, L, R, m);\n            if (t2 < 0) continue;\n            cur += t1 + t2;\n            ckmin(ret, cur);\n          }\n        }\n        return ret;\n      };\n\n    int ret = inf<int>;\n    for (int k = 0; k < 4; ++k) {\n      trace(k, a);\n      ckmin(ret, solve1());\n      ckmin(ret, solve2());\n      trace(ret);\n      rotate();\n    }\n    return ret;\n  }\n};\n",
    "submit_ts": 1719112318.0
}