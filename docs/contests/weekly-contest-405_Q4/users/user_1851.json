{
    "username": "Rajat-Raj",
    "submission": "#define ll long long\n\nclass TrieNode {\npublic:\n    unordered_map<char, TrieNode*> children;\n    bool isEndOfWord;\n    ll cost;\n\n    TrieNode() {\n        isEndOfWord = false;\n        cost = LLONG_MAX;\n    }\n};\n\nclass Trie {\npublic:\n    TrieNode* root;\n\n    Trie() {\n        root = new TrieNode();\n    }\n\n    void insert(const string& word, const ll cost) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (node->children.find(c) == node->children.end()) {\n                node->children[c] = new TrieNode();\n            }\n            node = node->children[c];\n        }\n        if (node->isEndOfWord) {\n            node->cost = min(node->cost, cost);\n        } else {\n            node->isEndOfWord = true;\n            node->cost = cost;\n        }\n    }\n\n    ll search(const string& word) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (node->children.find(c) == node->children.end()) {\n                return LLONG_MAX;\n            }\n            node = node->children[c];\n        }\n        return node->isEndOfWord ? node->cost : LLONG_MAX;\n    }\n\n    bool startsWith(const string& prefix) {\n        TrieNode* node = root;\n        for (char c : prefix) {\n            if (node->children.find(c) == node->children.end()) {\n                return false;\n            }\n            node = node->children[c];\n        }\n        return true;\n    }\n\n    ~Trie() {\n        clear(root);\n    }\n\nprivate:\n    void clear(TrieNode* node) {\n        if (node == nullptr) return;\n        for (auto& pair : node->children) {\n            clear(pair.second);\n        }\n        delete node;\n    }\n};\n\nclass Solution {\npublic:\n    ll rec(vector<ll> & dp, string & target, Trie & trie, ll i) {\n        if(i >= target.size()) return 0;\n        if(dp[i] != LLONG_MAX) return dp[i];\n        \n        ll ans = LLONG_MAX;\n        TrieNode* node = trie.root;\n        for(ll j = i; j < target.size(); j ++) {\n            ll child = LLONG_MAX;\n            if(node->children.find(target[j]) != node->children.end()) {\n                node = node->children[target[j]];\n                if(node->isEndOfWord) {\n                    child = rec(dp, target, trie, j + 1);\n                    child +=  node->cost;\n                    if(child >= 0)ans = min(child, ans);\n                }\n            } else {\n                break;\n            }\n            \n        }\n        return dp[i] = (ans == LLONG_MAX ? LLONG_MIN : ans);\n    }\n\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        ll n = target.size();\n        ll m = words.size();\n        Trie trie;\n        for(int i = 0; i < m; i++) {\n           trie.insert(words[i], costs[i]);\n        }\n        vector<ll> dp(n + 5, LLONG_MAX);\n        ll ans = rec(dp, target, trie, 0);\n        \n        return ans == LLONG_MIN ? -1 : ans;    \n    }\n};",
    "submit_ts": "1720324359",
    "subm_id": "1312397591"
}