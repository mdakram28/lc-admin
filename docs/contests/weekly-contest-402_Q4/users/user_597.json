{
    "username": "JustSNguyen",
    "submission": "from typing import List, Optional\nfrom collections import defaultdict, deque\nfrom functools import lru_cache\nfrom heapq import heappush, heappop\nfrom itertools import combinations, permutations \n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        N = len(nums)\n        class Node:\n            def __init__(self, l, r):\n                self.l = l \n                self.r = r \n                self.peaks = 0 \n                self.lc = None \n                self.rc = None\n\n            def build(self):\n                l, r = self.l, self.r \n                if l == r:\n                    if l == 0 or l == N - 1:\n                        return \n                    \n                    if nums[l] > nums[l - 1] and nums[l] > nums[l + 1]:\n                        self.peaks = 1 \n\n                    # print(l, r, self.peaks)\n\n                    return \n\n                mid = (l + r) // 2 \n                if not self.lc:\n                    self.lc = Node(l, mid)\n                if not self.rc:\n                    self.rc = Node(mid + 1, r)\n                \n                self.lc.build()\n                self.rc.build()\n                self.peaks = self.lc.peaks + self.rc.peaks \n                # print(l, r, self.peaks)\n\n                return \n            \n            def update(self, i):\n                l, r = self.l, self.r \n                if l - i >= 2 or i - r >= 2:\n                    return \n                \n                if l == r:\n                    if l == 0 or l == N - 1:\n                        self.peaks = 0 \n                        return \n\n                    if nums[l] > nums[l - 1] and nums[l] > nums[l + 1]:\n                        self.peaks = 1 \n                    else:\n                        self.peaks = 0 \n                    \n                    return \n\n                self.lc.update(i)\n                self.rc.update(i)\n                self.peaks = self.lc.peaks + self.rc.peaks \n            \n            def query(self, ql, qr):\n                l, r  = self.l, self.r \n                if qr < l or ql > r:\n                    return 0 \n                \n                if ql <= l and r <= qr:\n                    return self.peaks\n                \n                result = self.lc.query(ql, qr) + self.rc.query(ql, qr)\n                return result \n        \n        root = Node(0, N - 1)\n        results = []\n\n        root.build()\n\n        for q in queries:\n            t, val1, val2 = q \n            if t == 1:\n                q_range = val2 - val1 + 1 \n                if q_range < 3: \n                    results.append(0)\n                else:\n                    result = root.query(val1 + 1, val2 - 1)\n                    results.append(result)\n            elif t == 2:\n                nums[val1] = val2 \n                root.update(val1)\n        \n        return results \n\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [3,1,4,2,5]\n    queries =   [[2,3,4],[1,0,4]]\n    result = sol.countOfPeaks(nums, queries)\n    print(result)\n    ",
    "submit_ts": 1718507716.0
}