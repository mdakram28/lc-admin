{
    "username": "dj3013158",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def treeDiameter(edges: List[List[int]]) -> int:\n            # build the adjacency list representation of the graph\n            graph = [set() for i in range(len(edges)+1)]\n            for edge in edges:\n                u, v = edge\n                graph[u].add(v)\n                graph[v].add(u)\n\n            def bfs(start):\n                \"\"\"\n                 return the farthest node from the 'start' node\n                   and the distance between them.\n                \"\"\"\n                visited = [False] * len(graph)\n\n                visited[start] = True\n                queue = deque([start])\n                distance = -1\n                last_node = start\n                while queue:\n                    next_queue = deque()\n                    while queue:\n                        next_node = queue.popleft()\n                        for neighbor in graph[next_node]:\n                            if not visited[neighbor]:\n                                visited[neighbor] = True\n                                next_queue.append(neighbor)\n                                last_node = neighbor\n                    distance += 1\n                    queue = next_queue\n\n                return last_node, distance\n\n            # 1). find one of the farthest nodes\n            farthest_node, distance_1 = bfs(0)\n            # 2). find the other farthest node\n            #  and the distance between two farthest nodes\n            another_farthest_node, distance_2 = bfs(farthest_node)\n            return distance_2\n\n        d1 = treeDiameter(edges1)\n        d2 = treeDiameter(edges2)\n        return max((d1 + 1) // 2 + (d2 + 1) // 2 + 1, d1, d2)",
    "submit_ts": "1719718413",
    "subm_id": "1304416586"
}