{
    "username": "Rad0miR",
    "submission": "public class Solution {\n    private class Tree2D\n    {\n        private int N, M;\n        private int[][] board;\n        private int[][] t;\n        \n        private void Build_Y(int vx, int lx, int rx, int vy, int ly, int ry) \n        {\n            if (ly == ry) \n            {\n                if (lx == rx)\n                    t[vx][vy] = board[lx][ly];\n                else\n                    t[vx][vy] = Math.Max(t[vx * 2][vy], t[vx * 2 + 1][vy]);\n            } \n            else \n            {\n                int my = (ly + ry) / 2;\n                Build_Y(vx, lx, rx, vy * 2, ly, my);\n                Build_Y(vx, lx, rx, vy * 2 + 1, my + 1, ry);\n                t[vx][vy] = Math.Max(t[vx][vy * 2], t[vx][vy * 2 + 1]);\n            }\n        }\n        \n        private void Build_X(int vx, int lx, int rx) \n        {\n            if (lx != rx) \n            {\n                int mx = (lx + rx) / 2;\n                Build_X(vx * 2, lx, mx);\n                Build_X(vx * 2 + 1, mx + 1, rx);\n            }\n            Build_Y(vx, lx, rx, 1, 0, M - 1);\n        }\n        \n        public Tree2D(int[][] board) \n        {\n            this.board = board;\n            N = board.Length;\n            M = board[0].Length;\n            t = Enumerable.Range(0, N * 4 + 10).Select(_ => new int[M * 4 + 10]).ToArray();\n            \n            Build_X(1, 0, N - 1);\n        }\n        \n        public int Max_Y(int vx, int vy, int tly, int try_, int ly, int ry) \n        {\n            if (ly > ry) return -1_000_000_001;\n            if (ly == tly && try_ == ry) return t[vx][vy];\n            \n            int tmy = (tly + try_) / 2;\n            return Math.Max(Max_Y(vx, vy*2, tly, tmy, ly, Math.Min(ry, tmy)), \n                            Max_Y(vx, vy*2+1, tmy+1, try_, Math.Max(ly, tmy+1), ry));\n        }\n        \n        public int Max_X(int vx, int tlx, int trx, int lx, int rx, int ly, int ry) \n        {\n            if (lx > rx) return -1_000_000_001;\n            \n            if (lx == tlx && trx == rx) return Max_Y(vx, 1, 0, M - 1, ly, ry);\n            \n            int tmx = (tlx + trx) / 2;\n            return Math.Max(Max_X(vx * 2, tlx, tmx, lx, Math.Min(rx, tmx), ly, ry), \n                            Max_X(vx * 2 + 1, tmx + 1, trx, Math.Max(lx, tmx + 1), rx, ly, ry));\n        }\n    }\n       \n    \n    public long MaximumValueSum(int[][] board) \n    {\n        int n = board.Length, m = board[0].Length;\n        Tree2D tree = new(board);\n        \n        int[][] top2 = board\n            .Select(row => row.Select((x, i) => (x, i)).OrderDescending().Take(2).Select(p => p.i).ToArray())\n            .ToArray();\n        \n        long best = -1_000_000_000_0;\n        for (int i = 0; i < n; ++i) \n        {\n            for (int j = 0; j < n; ++j) \n            {\n                if (i == j) continue;\n                \n                int yFori = top2[i][0];\n                int yForj = top2[j][0] == yFori ? top2[j][1] : top2[j][0];\n                \n                long cur = board[i][yFori];\n                cur += board[j][yForj];\n                \n                int x1 = 0, y1 = 0, x2 = 0, y2 = 0;\n                \n                if (i < j) \n                {\n                    x1 = i; x2 = j;\n                }\n                else \n                {\n                    x1 = j; x2 = i;\n                }\n                \n                if (yFori < yForj)\n                {\n                    y1 = yFori; y2 = yForj;\n                }\n                else \n                {\n                    y1 = yForj; y2 = yFori;\n                }\n                \n                int max = new int[] { Max(0, 0, x1 - 1, y1 - 1),\n                                      Max(0, y1 + 1, x1 - 1, y2 - 1),\n                                      Max(0, y2 + 1, x1 - 1, m - 1), \n                                        Max(x1 + 1, 0, x2 - 1, y1 - 1), \n                                        Max(x1 + 1, y1 + 1, x2 - 1, y2 - 1), \n                                        Max(x1 + 1, y2 + 1, x2 - 1, m - 1), \n                                        Max(x2 + 1, 0, n - 1, y1 - 1), \n                                        Max(x2 + 1, y1 + 1, n - 1, y2 - 1), \n                                        Max(x2 + 1, y2 + 1, n - 1, m - 1) }.Max();\n                \n                cur += max;\n                \n                best = Math.Max(best, cur);\n                \n                int Max(int x1, int y1, int x2, int y2) \n                {\n                    if (x1 > x2 || y1 > y2) return -1_000_000_001;\n                    \n                    return tree.Max_X(1, 0, n - 1, x1, x2, y1, y2);\n                }\n            }\n        }\n        return best;\n    }\n}\n\n /*\n    private class TreeX\n    {\n        private int _begin, _end;\n        \n        private TreeX _leftNode = null, _rightNode = null;\n        private TreeY treeY = null;\n        \n        public int Count { get; private set; }\n        \n        public TreeX(int begin, int end) => (_begin, _end) = (begin, end);\n        \n        public Max(int x1, int x2, int y1, int y2) \n        {\n            \n        }\n        \n        public int Add(int l, int r) \n        {\n            if (l > r || l > _end || r < _begin) return Count;\n            \n            if ((l == _begin && r == _end) || Count == _end - _begin + 1) return Count = _end - _begin + 1;\n            \n            int middle = _begin + (_end - _begin) / 2;\n            \n            _leftNode = _leftNode ?? new SegmentTreeNode(_begin, middle);\n            _rightNode = _rightNode ?? new SegmentTreeNode(middle + 1, _end);\n            \n            return Count = _leftNode.Add(l, Math.Min(middle, r)) + _rightNode.Add(Math.Max(l, middle + 1), r);\n        }\n    }*/",
    "submit_ts": "1723910380",
    "subm_id": "1359228416"
}