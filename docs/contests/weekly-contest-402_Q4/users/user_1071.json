{
    "username": "sanskarverma12",
    "submission": "class Solution {\npublic: \n     void buildSegmentTree(vector<int>& segTree, vector<int>& nums, int start, int end, int node) {\n        if (start == end) {\n            segTree[node] = isPeak(nums, start) ? 1 : 0;\n            return;\n        }\n        int mid = (start + end) / 2;\n        buildSegmentTree(segTree, nums, start, mid, 2 * node + 1);\n        buildSegmentTree(segTree, nums, mid + 1, end, 2 * node + 2);\n        segTree[node] = segTree[2 * node + 1] + segTree[2 * node + 2];\n    }\n\n    // Function to update the segment tree\n    void updateSegmentTree(vector<int>& segTree, vector<int>& nums, int start, int end, int node, int idx) {\n        if (start == end) {\n            segTree[node] = isPeak(nums, start) ? 1 : 0;\n            return;\n        }\n        int mid = (start + end) / 2;\n        if (idx <= mid) {\n            updateSegmentTree(segTree, nums, start, mid, 2 * node + 1, idx);\n        } else {\n            updateSegmentTree(segTree, nums, mid + 1, end, 2 * node + 2, idx);\n        }\n        segTree[node] = segTree[2 * node + 1] + segTree[2 * node + 2];\n    }\n\n    // Function to query the peak count in a range\n    int querySegmentTree(vector<int>& segTree, int start, int end, int l, int r, int node) {\n        if (r < start || l > end) {\n            return 0;\n        }\n        if (l <= start && r >= end) {\n            return segTree[node];\n        }\n        int mid = (start + end) / 2;\n        int leftSum = querySegmentTree(segTree, start, mid, l, r, 2 * node + 1);\n        int rightSum = querySegmentTree(segTree, mid + 1, end, l, r, 2 * node + 2);\n        return leftSum + rightSum;\n    }\n\n    // Function to check if an index is a peak\n    bool isPeak(vector<int>& nums, int i) {\n        int n = nums.size();\n        if (i <= 0 || i >= n - 1) return false;\n        return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    }\n    \n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n           int n = nums.size();\n        vector<int> segTree(4 * n, 0);\n        buildSegmentTree(segTree, nums, 0, n - 1, 0);\n\n        vector<int> result;\n\n        for (const auto& query : queries) {\n            if (query[0] == 1) { // Count peaks in the subarray\n                int l = query[1], r = query[2];\n                if (r - l < 2) {\n                    result.push_back(0);\n                } else {\n                    result.push_back(querySegmentTree(segTree, 0, n - 1, l + 1, r - 1, 0));\n                }\n            } else if (query[0] == 2) { // Update value at index\n                int index = query[1], val = query[2];\n                nums[index] = val;\n\n                // Update the segment tree for the affected indices\n                for (int i = index - 1; i <= index + 1; ++i) {\n                    if (i > 0 && i < n - 1) {\n                        updateSegmentTree(segTree, nums, 0, n - 1, 0, i);\n                    }\n                }\n            }\n        }\n\n        return result;\n    \n    }\n};",
    "submit_ts": 1718509144.0
}