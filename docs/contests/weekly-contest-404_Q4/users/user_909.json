{
    "username": "pcwuu",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = (int)edges1.size() + 1;\n        int m = (int)edges2.size() + 1;\n        vector<vector<int>> graph1(n), graph2(m);\n        for(int i = 0; i < n - 1; i++) {\n            graph1[edges1[i][0]].push_back(edges1[i][1]);\n            graph1[edges1[i][1]].push_back(edges1[i][0]);\n        }\n        \n        for(int i = 0; i < m - 1; i++) {\n            graph2[edges2[i][0]].push_back(edges2[i][1]);\n            graph2[edges2[i][1]].push_back(edges2[i][0]);\n        }\n        \n        vector<int> depth1(n);\n        vector<bool> visited1(n);\n        dfs(0, graph1, depth1, visited1);\n        pair d1 = rerooting(graph1, depth1);\n        \n        vector<int> depth2(m);\n        vector<bool> visited2(m);\n        dfs(0, graph2, depth2, visited2);\n        pair d2 = rerooting(graph2, depth2);\n        \n        return max(d1.first + d2.first + 1, max(d1.second, d2.second));\n    }\n    \n    void dfs(int cur, vector<vector<int>> &graph, vector<int> &depth, vector<bool> &visited) {\n        visited[cur] = true;\n        int d = 0;\n        for(int i = 0; i < graph[cur].size(); i++)\n            if(!visited[graph[cur][i]]) {\n                dfs(graph[cur][i], graph, depth, visited);\n                d = max(d, depth[graph[cur][i]] + 1);\n            }\n        depth[cur] = d;\n    }\n    \n    pair<int, int> rerooting(vector<vector<int>> &graph, vector<int> &depth) {\n        int cur = 0;\n        \n        while(true) {\n            pair<int, int> mx[2] = {{-1, -1}, {-1, -1}};\n            for(int i = 0; i < graph[cur].size(); i++) {\n                if(depth[graph[cur][i]] > mx[0].first) {\n                    mx[1] = mx[0];\n                    mx[0] = {depth[graph[cur][i]], graph[cur][i]};\n                }\n                else if(depth[graph[cur][i]] > mx[1].first) {\n                    mx[1] = {depth[graph[cur][i]], graph[cur][i]};\n                }\n            }\n            \n            if(mx[0].first - mx[1].first <= 1) {\n                return {depth[cur], mx[0].first + mx[1].first + 2};\n            }\n                \n            \n            depth[cur] = mx[1].first + 1;\n            cur = mx[0].second;\n            //cout << cur << ' ' << mx[0].first << ' ' << mx[0].second << ' ' << mx[1].first << ' ' << mx[1].second << '\\n';\n        }\n        return {-1, -1};\n        \n    } \n};",
    "submit_ts": 1719719847.0
}