{
    "username": "placehloder",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        d1 = self.impl(edges1)\n        d2 = self.impl(edges2)\n        dmix = int((d1+1)/2) + int((d2+1)/2) + 1\n        return max([d1,d2,dmix])\n        \n    def impl(self, edges):\n        if not edges:\n            return 0\n\n        # Step 1: Build the tree as an adjacency list\n        tree = defaultdict(list)\n        for ai, bi in edges:\n            tree[ai].append(bi)\n            tree[bi].append(ai)\n\n        # Helper function to perform BFS and return the farthest node and its distance from the start node\n        def bfs(start):\n            visited = set()\n            queue = deque([(start, 0)])\n            farthest_node = start\n            max_distance = 0\n\n            while queue:\n                node, distance = queue.popleft()\n                if node not in visited:\n                    visited.add(node)\n                    if distance > max_distance:\n                        max_distance = distance\n                        farthest_node = node\n                    for neighbor in tree[node]:\n                        if neighbor not in visited:\n                            queue.append((neighbor, distance + 1))\n\n            return farthest_node, max_distance\n\n        # Step 2: Perform BFS from an arbitrary node (node 0) to find the farthest node A\n        arbitrary_node = edges[0][0]\n        farthest_node_A, _ = bfs(arbitrary_node)\n\n        # Step 3: Perform BFS from the farthest node A to find the farthest node B and the diameter\n        _, diameter = bfs(farthest_node_A)\n\n        return diameter",
    "submit_ts": "1719718367",
    "subm_id": "1304415448"
}