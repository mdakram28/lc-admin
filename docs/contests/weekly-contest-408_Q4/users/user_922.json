{
    "username": "poiuyt123",
    "submission": "class Circle {\npublic:\n    long long x, y, radius;\n    bool touchesSide1, touchesSide2, touchesSide3, touchesSide4;\n\n    Circle(long long x, long long y, long long radius)\n        : x(x), y(y), radius(radius), touchesSide1(false), touchesSide2(false), touchesSide3(false), touchesSide4(false) {}\n\n    void checkTouchingSides(long long rectX1, long long rectY1, long long rectX2, long long rectY2) {\n        // Reset the booleans\n        touchesSide1 = touchesSide2 = touchesSide3 = touchesSide4 = false;\n\n        // Check if the circle touches the sides of the rectangle\n        if (x - radius <= rectX1) touchesSide1 = true; // Left side\n        if (x + radius >= rectX2) touchesSide2 = true; // Right side\n        if (y - radius <= rectY1) touchesSide3 = true; // Bottom side\n        if (y + radius >= rectY2) touchesSide4 = true; // Top side\n    }\n\n    bool isTouchingOrOverlapping(const Circle& other) const {\n        double distance = std::sqrt((x - other.x) * (x - other.x) + (y - other.y) * (y - other.y));\n        return distance <= (radius + other.radius);\n    }\n};\n\nvoid dfs(int node, const std::vector<std::vector<int>>& graph, std::vector<bool>& visited, std::vector<int>& component) {\n    visited[node] = true;\n    component.push_back(node);\n\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, graph, visited, component);\n        }\n    }\n}\n\nbool checkComponent(const std::vector<Circle>& circles, const std::vector<int>& component) {\n    bool touchesSide1Or4 = false;\n    bool touchesSide2Or3 = false;\n\n    for (int index : component) {\n        const Circle& circle = circles[index];\n        if (circle.touchesSide1 || circle.touchesSide4) {\n            touchesSide1Or4 = true;\n        }\n        if (circle.touchesSide2 || circle.touchesSide3) {\n            touchesSide2Or3 = true;\n        }\n    }\n\n    return touchesSide1Or4 && touchesSide2Or3;\n}\n\nclass Solution {\npublic:\n\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        std::vector<Circle> circles_class;\n    int n = circles.size();\n    // Input circle properties\n    for (int i = 0; i < n; ++i) {\n        long long  x = (long long)circles[i][0];\n        long long  y = (long long)circles[i][1];\n        long long  radius = (long long)circles[i][2];\n        circles_class.emplace_back(x, y, radius); // Create and add a new Circle object to the vector\n    }\n\n    // Input rectangle properties\n    long long rectX1, rectY1, rectX2, rectY2;\n    rectX1 = 0ll;\n    rectY1 = 0ll;\n    rectX2 = (long long)X;\n    rectY2 = (long long)Y;\n    \n\n    // Check which sides each circle touches\n    for (int i = 0; i < n; ++i) {\n        circles_class[i].checkTouchingSides(rectX1, rectY1, rectX2, rectY2);\n        // std::cout << \"Circle \" << (i + 1) << \":\" << std::endl;\n        // std::cout << \"Touches left side: \" << (circles_class[i].touchesSide1 ? \"Yes\" : \"No\") << std::endl;\n        // std::cout << \"Touches right side: \" << (circles_class[i].touchesSide2 ? \"Yes\" : \"No\") << std::endl;\n        // std::cout << \"Touches bottom side: \" << (circles_class[i].touchesSide3 ? \"Yes\" : \"No\") << std::endl;\n        // std::cout << \"Touches top side: \" << (circles_class[i].touchesSide4 ? \"Yes\" : \"No\") << std::endl;\n    }\n\n    // Create graph adjacency list\n    std::vector<std::vector<int>> graph(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (circles_class[i].isTouchingOrOverlapping(circles_class[j])) {\n                graph[i].push_back(j);\n                graph[j].push_back(i);\n            }\n        }\n    }\n\n    // Find connected components using DFS\n    std::vector<bool> visited(n, false);\n    std::vector<std::vector<int>> connectedComponents;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            std::vector<int> component;\n            dfs(i, graph, visited, component);\n            connectedComponents.push_back(component);\n        }\n    }\n\n    // Check each connected component\n    bool isValid = true;\n    for (const auto& component : connectedComponents) {\n        if (checkComponent(circles_class, component)) {\n            isValid = false;\n            break;\n        }\n    }\n    return isValid;\n    }\n};",
    "submit_ts": "1722138681",
    "subm_id": "1335796955"
}