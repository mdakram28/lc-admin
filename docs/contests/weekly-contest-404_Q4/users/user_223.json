{
    "username": "yc-li",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        \n        def get(edges):\n            n = len(edges) + 1\n            nxt = {u: [] for u in range(n)}\n            \n            for u, v in edges:\n                nxt[u].append(v)\n                nxt[v].append(u)\n            \n            mm = [0] * n\n            \n            def dfs(cur, pre):\n                ans = 0\n                \n                for v in nxt[cur]:\n                    if v == pre:\n                        continue\n                    dfs(v, cur)\n                    ans = max(ans, mm[v] + 1)\n                    \n                mm[cur] = ans\n            \n            \n            st = n - 1\n            \n            dfs(st, -1)\n            \n            \n            def it(cur, pre):\n                m1, m2 = -1, -1\n                nn = None\n                \n                \n                for v in nxt[cur]:\n                    # if v == pre:\n                    #     continue\n                    \n                    _, m2, m1 = sorted([mm[v], m1, m2])\n                    if mm[v] == m1:\n                        nn = v\n                    \n                    # print(v)\n                \n                # print(cur, mm, m1, m2)\n                \n                if m1 > m2 + 1:\n                    mm[cur] = m2 + 1\n                    return it(nn, cur)\n                else:\n                    return m1 + 1, m2 + 1\n                \n            \n            \n            x, y = it(st, -1)\n            # print(x, y)\n            return x, y\n            \n        \n        \n        a, b = get(edges1)\n        c, d = get(edges2)\n        \n        return max([a + b, c + d, max(a, b) + max(c, d) + 1])\n            \n            \n            \n            ",
    "submit_ts": 1719717893.0
}