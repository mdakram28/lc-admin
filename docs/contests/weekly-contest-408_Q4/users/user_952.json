{
    "username": "cyach",
    "submission": "class Solution {\npublic:\n    int findHead(int i, vector<int>& groups) {\n        if (groups[i] == -1) {\n            return i;\n        }\n        return groups[i] = findHead(groups[i], groups);\n    }\n    void unionGroup(int i, int j, vector<int>& groups) {\n        int h1 = findHead(i, groups);\n        int h2 = findHead(j, groups);\n        if (h1 != h2) {\n            groups[h1] = h2;\n        }\n    }\n    bool inCircle(vector<int>& c, int x, int y) {\n        long long d = pow((long long)x-c[0], 2) + pow((long long)y-c[1], 2);\n        return sqrt(d) <= c[2];\n    }\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int len = circles.size();\n        vector<int> groups(len, -1);\n        \n        // union groups\n        for (int i=0; i<len; i++) {\n            for (int j=i+1; j<len; j++) {\n                if (findHead(i, groups) == findHead(j, groups)) {\n                    continue;\n                }\n                auto& ci = circles[i], cj = circles[j];\n                long long d = pow((long long)ci[0]-cj[0], 2) + pow((long long)ci[1]-cj[1], 2);\n                long long rsum = pow((long long)ci[2] + cj[2], 2);\n                if (d <= rsum) {\n                    unionGroup(i, j, groups);\n                }\n            }\n        }\n        // for each group, check if border touch boundry\n        for (int i=0; i<len; i++) {\n            findHead(i, groups);\n        }\n        // for (int i=0; i<len; i++) {\n        //     cout << groups[i] << \",\";\n        // }\n        // cout << endl;\n        bool canReach = true;\n        for (int h=0; h<len; h++) {\n            if (groups[h] != -1) {\n                continue;\n            }\n            // cout << \"h=\" << h << endl;\n            vector<int> touched(4, 0); // up, right, down, left\n            for (int i=0; i<len; i++) {\n                if (findHead(i, groups) != h) {\n                    continue;\n                }\n                auto& c = circles[i];\n                int r = c[2];\n                // touch start or end\n                if (inCircle(c, 0, 0) || inCircle(c, X, Y)) {\n                    canReach = false;\n                    break;\n                }\n                // touch boundry\n                if (c[1]+r >= Y) {\n                    touched[0] = 1;\n                }\n                if (c[0]+r >= X) {\n                    touched[1] = 1;\n                }\n                if (c[1]-r <= 0) {\n                    touched[2] = 1;\n                }\n                if (c[0]-r <= 0) {\n                    touched[3] = 1;\n                }\n            }\n            if ((touched[0] == 1 && touched[1] == 1)\n                || (touched[0] == 1 && touched[2] == 1)\n                || (touched[3] == 1 && touched[1] == 1)\n                || (touched[3] == 1 && touched[2] == 1)) {\n                    canReach = false;\n            }\n            if (!canReach) {\n                break;\n            }\n        }\n        return canReach;\n    }\n};",
    "submit_ts": "1722139088",
    "subm_id": "1335807513"
}