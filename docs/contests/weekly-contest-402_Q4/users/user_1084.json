{
    "username": "workcool",
    "submission": "class SegmentTree:\n    def __init__(self, nums: List[int]):\n        n = len(nums)\n        self.arr = nums\n        self.tree = [0] * 4 * n\n        self._build(0, 0, n-1)\n    \n    def _build(self, node, start, end):\n        # build tree for node, with arr index [start, end]\n        if start == end:\n            self.tree[node] = self.arr[start]\n            return \n        mid = (start + end) //2\n        self._build(2*node+1, start, mid)\n        self._build(2*node+2, mid+1, end)\n        self.tree[node] = self.tree[2*node+1] + self.tree[2*node+2]\n        return\n    \n    def _update(self, idx, val, node, start, end):\n        # update for tree node, mapped to arr's inclusive [start, end]\n        # similar to b_search, need to locate idx in 1st half or 2nd half\n        if start == end:\n            self.tree[node] = val\n            self.arr[idx] = val\n            return \n        mid = (start + end) // 2\n        if start <= idx <= mid:\n            self._update(idx, val, 2*node+1, start, mid)\n        else:\n            self._update(idx, val, 2*node+2, mid+1, end)\n        self.tree[node] = self.tree[2*node+1] + self.tree[2*node+2]\n        return\n\n    def _query(self, left, right, node, start, end):\n        # query the range [left, right], need to find values in tree!\n        if left > end or right < start:\n            return 0\n        if left <= start and right >= end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        l_sum = self._query(left, right, 2*node+1, start, mid)\n        r_sum = self._query(left, right, 2*node+2, mid+1, end)\n        return l_sum + r_sum\n        \n    \n    def update(self, index: int, val: int) -> None:\n        self._update(index, val, 0, 0, len(self.arr)-1)\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self._query(left, right, 0, 0, len(self.arr)-1)\n\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        # store peak index: when change, only -1,0,1 affect\n        # segment tree: array with only 0 or 1, range sum\n        # each time change, update this array\n        \n        peaks = [0] * len(nums)\n        for i in range(1, len(nums)-1):\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:\n                peaks[i] = 1\n        segtree = SegmentTree(peaks)\n        res = []\n        for elem in queries:\n            # print(nums)\n            # print(segtree.arr)\n            if elem[0] == 2:\n                nums[elem[1]] = elem[2]\n                # need to update segment tree: find index and value to change\n                # affect x-1, x, x+1\n                if 1 <= elem[1] <= len(nums)-2:\n                    idx_to_chg = [elem[1]-1, elem[1], elem[1]+1]\n                    val_to_chg = [0] * 3\n                    for i, idx in enumerate(idx_to_chg):\n                        if idx != 0 and idx != len(nums) - 1:\n                            if nums[idx-1] < nums[idx] > nums[idx+1]:\n                                val_to_chg[i] = 1\n                            else:\n                                val_to_chg[i] = 0\n                    for i in range(3):\n                        segtree.update(idx_to_chg[i], val_to_chg[i])\n                elif elem[1] == 0:\n                    idx_to_chg = 1\n                    if nums[0] < nums[1] > nums[2]:\n                        val_to_chg = 1\n                    else:\n                        val_to_chg = 0\n                    segtree.update(idx_to_chg, val_to_chg)\n                else:\n                    # last elem\n                    idx_to_chg = len(nums) - 2\n                    if nums[-3] < nums[-2] > nums[-1]:\n                        val_to_chg = 1\n                    else:\n                        val_to_chg = 0\n                    segtree.update(idx_to_chg, val_to_chg)\n                \n            else:\n                l, r = elem[1], elem[2]\n                if l + 1 >= r:\n                    res.append(0)\n                else:\n                    cnt = segtree.sumRange(l+1, r-1)\n                    res.append(cnt)\n                \n        return res\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n        ",
    "submit_ts": 1718509206.0
}