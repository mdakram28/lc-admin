{
    "username": "krishnamohansingh",
    "submission": "class Solution {\npublic:\n    vector<int>indegree, outDegree;\n    int n;\n    vector<vector<int>>adj;\n    stack<int> combine ;\n\n    void helper1(int node, int par) {\n        indegree[node] = 0;\n        int ans = 0;\n        for (auto c : adj[node]) {\n            if (c == par)continue;\n            int cnt = 0;\n            if (c & 1) {\n                cnt++;\n            }\n            else {\n                cnt += 2;\n            }\n            helper1(c, node);\n            ans = max(ans, cnt + indegree[c]);\n        }\n        if( combine.size()>0 && ans>combine.top()){\n               combine.pop() ;\n            }else{\n              combine.push(ans) ;\n          }\n        indegree[node] = ans;\n    }\n\n    void helper2(int node, int par) {\n        multiset<int>st;\n        for (auto c : adj[node]) {\n            if (c == par)continue;\n            int cnt = 0;\n            if (c & 1) {\n                cnt++;\n            }\n            else {\n                cnt += 2;\n            }\n            st.insert(cnt + indegree[c]);\n            if (st.size() == 3) {\n                st.erase(st.begin());\n            }\n        }\n\n        for (auto c : adj[node]) {\n            if (c == par)continue;\n            int resFirst = 0, resSecond = 0;\n            if (node & 1) {\n                resFirst++;\n            }\n            else {\n                resFirst += 2;\n            }\n            if (c & 1) {\n                resSecond += 1;\n            }\n            else {\n                resSecond += 2;\n            }\n            int resThird = 0;\n            \n            if (resSecond + indegree[c] == *st.rbegin() && st.size() != 1) {\n                resThird = *st.begin();\n            }\n            else if(st.size() != 1) {\n                resThird = *st.rbegin();\n            }\n            \n            if(resFirst>resSecond && combine.size()>0){\n               combine.pop() ;\n            }else{\n              combine.push(resFirst) ;\n            }\n            outDegree[c] = max({outDegree[node] + resFirst, resFirst + resThird});\n            helper2(c, node);\n        }\n    }\n\n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        n = edges.size() + 1;\n        adj.resize(n);\n        for (auto edge : edges) {\n            int u = edge[0] ,v = edge[1];\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n            combine.push(u) ;\n            combine.push(v) ;\n        }\n        indegree.resize(n, 0);\n        outDegree.resize(n, 0);\n        helper1(0, -1);\n        helper2(0, -1);\n        int cnt=0 ;\n        while(combine.size()>0){\n            cnt++ ;\n            combine.pop() ;\n        }\n      \n        vector<int>ans(n, 0);\n        for (int i = 0; i < n; i++) {\n            ans[i] = max(indegree[i], outDegree[i]);\n        }\n         if(cnt>1e9){\n           combine.push(-1) ;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722700224",
    "subm_id": "1343235357"
}