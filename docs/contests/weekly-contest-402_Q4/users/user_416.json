{
    "username": "tiny-snow",
    "submission": "//\n//\n\n#include <iostream>\n#include <iso646.h>\n#include <vector>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <functional>\n#include <string>\n\nusing namespace std;\nusing LL = long long;\nconst int INF = 0x3f3f3f3f;\nconst LL LINF = 0x3f3f3f3f3f3f3f3f;\n\n// Segment Tree (sum)\n// single point update, range query\nclass SegmentTree\n{\nprivate:\n    vector<int> tree;\n    int n;\n\npublic:\n    SegmentTree(int n) : n(n), tree(4 * n, 0) {}\n\n    void update(int i, int val)\n    {\n        update(0, 0, n - 1, i, val);\n    }\n\n    int query(int l, int r)\n    {\n        return query(0, 0, n - 1, l, r);\n    }\n\nprivate:\n    void update(int u, int tl, int tr, int i, int val)\n    {\n        if (tl == tr)\n        {\n            tree[u] = val;\n            return;\n        }\n        int tm = (tl + tr) / 2;\n        if (i <= tm)\n            update(2 * u + 1, tl, tm, i, val);\n        else\n            update(2 * u + 2, tm + 1, tr, i, val);\n        tree[u] = tree[2 * u + 1] + tree[2 * u + 2];\n    }\n\n    int query(int u, int tl, int tr, int l, int r)\n    {\n        if (l > r)\n            return 0;\n        if (l == tl and r == tr)\n            return tree[u];\n        int tm = (tl + tr) / 2;\n        return query(2 * u + 1, tl, tm, l, min(r, tm)) + query(2 * u + 2, tm + 1, tr, max(l, tm + 1), r);\n    }\n};\n\nclass Solution\n{\npublic:\n    vector<int> countOfPeaks(vector<int> &nums, vector<vector<int>> &queries)\n    {\n        auto is_peak = [&](int i)\n        {\n            return i > 0 and i < nums.size() - 1 and nums[i] > nums[i - 1] and nums[i] > nums[i + 1];\n        };\n\n        vector<int> ans;\n        int n = nums.size();\n        SegmentTree st(n);\n        for (int i = 0; i < n; i++)\n            st.update(i, is_peak(i));\n        for (auto &q : queries)\n        {\n            int op = q[0];\n            if (op == 1)\n            {\n                int l = q[1], r = q[2]; // [l, r]\n                ans.push_back(st.query(l + 1, r - 1));\n            }\n            else\n            {\n                int idx = q[1], val = q[2];\n                nums[idx] = val;\n                for (int i = idx - 1; i <= idx + 1; i++)\n                    st.update(i, is_peak(i));\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718507796.0
}