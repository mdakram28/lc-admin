{
    "username": "superspazz",
    "submission": "class Solution {\n    public int minimumDifference(int[] nums, int k) {\n        final int N = nums.length;\n        \n        PrimitiveSparseTable st = new PrimitiveSparseTable(nums);\n        \n        int best = Integer.MAX_VALUE;\n        for (int i = 0; i < N; ++i) {\n            final int lo = i;\n            best = Math.min(best, Math.abs(k - nums[i]));\n            int curr = nums[i];\n            int hi = i;\n            while (hi < N) {\n                final int prev = curr;\n                int j = BinarySearch.firstThat(hi + 1, N, new BinarySearch.IntCheck() {\n                    @Override\n                    public boolean valid(int idx) {\n                        return st.get(lo, idx) != prev;\n                    }\n                });\n                curr = st.get(i, j);\n                best = Math.min(best, Math.abs(k - curr));\n                hi = j;\n            }\n        }\n        return best;\n    }\n\n\t/**\n\t * Sparse table initializes in O(N log N) time, but performs queries in O(1) time.\n\t * Queries must be performed on non-empty ranges within the table's range of [0, n).\n\t */\n\tpublic static class PrimitiveSparseTable {\n\t\t// Implement the value merge function.\n\t\tprivate static int merge(int a, int b) {\n            return a & b;\n\t\t}\n\n\t\tprivate int[][] table;\n\n\t\tpublic PrimitiveSparseTable(int[] a) {\n\t\t\tint n = a.length;\n\t\t\tint p = 1 + Math.max(1, Integer.SIZE - Integer.numberOfLeadingZeros(n));\n\n\t\t\tthis.table = new int[p][n];\n\t\t\tSystem.arraycopy(a, 0, this.table[0], 0, n);\n\t\t\tfor (int b = 1; b < p; b++) {\n\t\t\t\tint off = (1 << (b - 1));\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (i + off < n) {\n\t\t\t\t\t\tthis.table[b][i] = merge(this.table[b - 1][i], this.table[b - 1][i + off]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.table[b][i] = this.table[b - 1][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic int get(int lowerInclusive, int upperInclusive) {\n\t\t\tint k = 31 - Integer.numberOfLeadingZeros(upperInclusive - lowerInclusive + 1);\n\t\t\tint off = (1 << k);\n\t\t\treturn merge(table[k][lowerInclusive], table[k][upperInclusive - off + 1]);\n\t\t}\n\t}\n    \n\t/**\n\t * Generic binary search to find the first or last value resulting in a matching condition.\n\t */\n\t// EXAMPLE USAGE (find insertion index in sorted array `A`):\n\t/*\n\t\tint insertionIndex = BinarySearch.firstThat(0, A.length, new BinarySearch.IntCheck() {\n\t\t\t@Override\n\t\t\tpublic boolean valid(int index) {\n\t\t\t\treturn A[index] > mid;\n\t\t\t}\n\t\t});\n\t */\n\tpublic static class BinarySearch {\n\t\t// Finds the left-most value that satisfies the IntCheck in the range [L, R).\n\t\t// It will return R if the nothing in the range satisfies the check.\n\t\tpublic static int firstThat(int L, int R, IntCheck check) {\n\t\t\twhile (L < R) {\n\t\t\t\tint M = (L >> 1) + (R >> 1) + (L & R & 1);\n\t\t\t\tif (check.valid(M)) {\n\t\t\t\t\tR = M;\n\t\t\t\t} else {\n\t\t\t\t\tL = M + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn L;\n\t\t}\n\n\t\t// Finds the right-most value that satisfies the IntCheck in the range [L, R).\n\t\t// It will return L - 1 if nothing in the range satisfies the check.\n\t\tpublic static int lastThat(int L, int R, IntCheck check) {\n\t\t\tint firstValue = firstThat(L, R, new IntCheck() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean valid(int value) {\n\t\t\t\t\treturn !check.valid(value);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn firstValue - 1;\n\t\t}\n\n\t\t// Finds the left-most value that satisfies the LongCheck in the range [L, R).\n\t\tpublic static long firstThat(long L, long R, LongCheck check) {\n\t\t\twhile (L < R) {\n\t\t\t\tlong M = (L >> 1) + (R >> 1) + (L & R & 1);\n\t\t\t\tif (check.valid(M)) {\n\t\t\t\t\tR = M;\n\t\t\t\t} else {\n\t\t\t\t\tL = M + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn L;\n\t\t}\n\n\t\t// Finds the right-most value that satisfies the IntCheck in the range [L, R).\n\t\t// It will return L - 1 if nothing in the range satisfies the check.\n\t\tpublic static long lastThat(long L, long R, LongCheck check) {\n\t\t\tlong firstValue = firstThat(L, R, new LongCheck() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean valid(long value) {\n\t\t\t\t\treturn !check.valid(value);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn firstValue - 1;\n\t\t}\n\n\t\tpublic static interface LongCheck {\n\t\t\tpublic boolean valid(long value);\n\t\t}\n\n\t\tpublic static interface IntCheck {\n\t\t\tpublic boolean valid(int value);\n\t\t}\n\t}\n}",
    "submit_ts": 1717299784.0
}