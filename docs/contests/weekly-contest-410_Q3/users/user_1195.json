{
    "username": "_dipu",
    "submission": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\n\ntemplate<const int32_t MOD> struct modint {\n    int32_t value;\n    modint() = default;\n    modint(int32_t value_) : value(value_) {}\n    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.value; return modint<MOD>(c >= MOD ? c - MOD : c); }\n    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.value; return modint<MOD>(c <    0 ? c + MOD : c); }\n    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * other.value % MOD; return modint<MOD>(c < 0 ? c + MOD : c); }\n    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->value < 0) this->value += MOD; return *this; }\n    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * other.value % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : 0); }\n    modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k & 1) y *= x; x *= x; } return y; }\n    modint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n    inline modint<MOD> operator /  (modint<MOD> other) const { return *this *  other.inv(); }\n    inline modint<MOD> operator /= (modint<MOD> other)       { return *this *= other.inv(); }\n    inline bool operator == (modint<MOD> other) const { return value == other.value; }\n    inline bool operator != (modint<MOD> other) const { return value != other.value; }\n    inline bool operator < (modint<MOD> other) const { return value < other.value; }\n    inline bool operator > (modint<MOD> other) const { return value > other.value; }\n};\ntemplate<int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD>(value) * n; }\ntemplate<int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD>(value % MOD) * n; }\ntemplate<int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.value; }\ntemplate<int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.value; }\n\nconst int mod = 1e9 + 7;\nusing mint = modint<mod>;\n\nclass Solution {\nprivate:\n    static const int maxn = 2000 + 1;\n    static const int maxnum = 50 + 1;\n    mint dp[maxn][maxnum][maxnum];\n    int table[maxn][maxnum][maxnum];\n\n    mint solve(vector<int> &nums, int pos, int i, int j) {\n        if (pos >= nums.size()) {\n            return mint(1);\n        }\n        mint &ret = dp[pos][i][j];\n        int &tab = table[pos][i][j];\n        if (~tab) {\n            return ret;\n        }\n        tab = 1;\n        ret = 0;\n        for (int x = i; x <= 50; x++) {\n            int y = nums[pos] - x;\n            if (y >= 0 and y <= j) {\n                mint go = solve(nums, pos + 1, x, y);\n                ret += go;\n            }\n        }\n        return ret;\n    }\n\npublic:\n    int countOfPairs(vector<int>& nums) {\n        memset(table, -1, sizeof table);\n        mint ans = 0;\n        for (int i = 0; i <= 50; i++) {\n            int j = nums[0] - i;\n            if (j < 0) {\n                continue;\n            }\n            ans += solve(nums, 1, i, j);\n        }\n        return ans.value;\n    }\n};",
    "submit_ts": "1723345671",
    "subm_id": "1351560814"
}