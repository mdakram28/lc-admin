{
    "username": "Primqd",
    "submission": "class Solution:\n    def opsFromSeg(self, nums : List[int]) -> int:\n        # from deviations, return number of operations\n        moves : int = 0\n        curr : int = 0\n        for num in nums:\n            if num > curr: curr = num\n            elif num < curr:\n                moves += (curr - num)\n                curr = num\n        moves += curr\n        nums.clear()\n        return moves\n\n    def minimumOperations(self, nums: List[int], target: List[int]) -> int:\n        moves : int = 0\n        parity : bool = True # inc = True, dec = False\n        stack : List[int] = [] # current segement\n        for idx in range(len(nums)):\n            if nums[idx] == target[idx]:\n                if stack:\n                    moves += self.opsFromSeg(stack)\n            elif nums[idx] > target[idx]: # subtract from nums; parity = False\n                if parity:\n                    moves += self.opsFromSeg(stack)\n                parity = False\n                stack.append(nums[idx] - target[idx])\n            else: # nums[idx] < target[idx] -> add to nums; parity = True\n                if not parity:\n                    moves += self.opsFromSeg(stack)\n                parity = True\n                stack.append(target[idx] - nums[idx])\n        if stack: moves += self.opsFromSeg(stack)\n\n        return moves\n        \n",
    "submit_ts": "1721530595",
    "subm_id": "1327938225"
}