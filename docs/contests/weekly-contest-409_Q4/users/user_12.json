{
    "username": "ianwong1999",
    "submission": "class Solution {\npublic:\n    int dp[100055];\n    long long dat[200055];\n    long long cnt[200055];\n    \n    void build(int id, int x, int y) {\n        if (x == y) {\n            dat[id] = 0;\n            cnt[id] = 0;\n            return;\n        }\n        \n        int mid = (x + y) >> 1;\n        \n        build(id + id, x, mid);\n        build(id + id + 1, mid + 1, y);\n        \n        dat[id] = cnt[id] = 0;\n    }\n    void update(int id, int x, int y, int w, int mode) {\n        if (x == y) {\n            if (mode == 0) {\n                dat[id] -= w;\n                cnt[id]--;\n            } else {\n                dat[id] += w;\n                cnt[id]++;\n            }\n            return;\n        }\n        \n        int mid = (x + y) >> 1;\n        \n        if (w <= mid) update(id + id, x, mid, w, mode);\n        else update(id + id + 1, mid + 1, y, w, mode);\n        \n        dat[id] = dat[id + id] + dat[id + id + 1];\n        cnt[id] = cnt[id + id] + cnt[id + id + 1];\n    }\n    pair<long long, long long> query(int id, int x, int y, int l, int r) {\n        if (l > y || r < x) return {0, 0};\n        \n        if (l <= x && y <= r) return {dat[id], cnt[id]};\n        \n        int mid = (x + y) >> 1;\n        \n        auto xx = query(id + id, x, mid, l, r);\n        auto yy = query(id + id + 1, mid + 1, y, l, r);\n        \n        return {xx.first + yy.first, xx.second + yy.second};\n    }\n    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {\n        int n = colors.size();\n        \n        build(1, 0, n);\n        \n        set<pair<int, int>> s;\n        vector<int> res;\n        \n        auto rem = [&](set<pair<int, int>>::iterator ite) {\n            int p = ite->first;\n            int q = ite->second;\n            update(1, 0, n, q - p + 1, 0);\n            s.erase(ite);\n        };\n        auto add = [&](int p, int q) {\n            update(1, 0, n, q - p + 1, 1);\n            s.emplace(p, q);\n        };\n        \n        for (int i = 0; i < n; i++) {\n            int j = i + 1;\n            \n            while (j < n && colors[j] != colors[j - 1]) j++;\n            \n            add(i, j - 1);\n            \n            i = j - 1;\n        }\n        \n\n        for (const auto& vec : queries) {\n            int ope = vec[0];\n            \n            if (ope == 1) {\n                int x = vec[1];\n                long long have = 0;\n                \n                \n                \n                auto [sum, c] = query(1, 0, n, x, n);\n                \n                have += sum - c * (x - 1);\n                \n                if (colors[0] != colors[n - 1]) {\n                    int p = s.begin()->second - s.begin()->first + 1;\n                    int q = s.rbegin()->second - s.rbegin()->first + 1;\n                    \n                    q = min(q, x - 1);\n                    p = min(p, x - 1);\n                    \n                    have += max(0, p + q - x + 1);\n                }\n                \n                res.push_back(have);\n            } else {\n                int x = vec[1];\n                int y = vec[2];\n                \n                if (y == colors[x]) continue;\n                \n                colors[x] = y;\n                \n                \n                {\n                    auto self = --s.upper_bound({x + 1, -1});\n                \n                    {\n                        int x1 = self->first, y1 = x - 1;\n                        int x2 = x + 1, y2 = self->second;\n\n                        rem(self);\n\n                        if (x1 <= y1) add(x1, y1);\n                        if (x2 <= y2) add(x2, y2);\n                    }\n                }\n\n                \n                {\n                    auto prev = s.upper_bound({x + 1, -1});\n                    \n                    if (prev != s.begin()) {\n                        --prev;\n                        \n                        if (colors[prev->second] != colors[x]) {\n                            int p = prev->first, q = x;\n                            \n                            rem(prev);\n                            add(p, q);\n                        } else {\n                            add(x, x);\n                        }\n                    } else {\n                        add(x, x);\n                    }\n                }\n                \n                {\n                    auto self = --s.upper_bound({x + 1, -1});\n                    auto nxt = s.lower_bound({x + 1, -1});\n                    \n                    if (nxt != s.end()) {\n                        if (colors[x] != colors[x + 1]) {\n                            int p = self->first, q = nxt->second;\n                            \n                            rem(nxt);\n                            rem(self);\n                            add(p, q);\n                        }\n                    }\n                }\n            }\n        }\n        \n        return res;\n    }\n};",
    "submit_ts": "1722742354",
    "subm_id": "1343767021"
}