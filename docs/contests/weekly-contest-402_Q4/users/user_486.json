{
    "username": "Black_hatCoder",
    "submission": "class SegmentTree {\nprivate:\n    vector<int> tree;\n    int n;\n    \n    void buildTree(const vector<int>& nums, int start, int end, int node) {\n        if (start == end) {\n            tree[node] = 0;\n            return;\n        }\n        \n        int mid = (start + end) / 2;\n        buildTree(nums, start, mid, 2 * node + 1);\n        buildTree(nums, mid + 1, end, 2 * node + 2);\n        \n        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n    }\n\n    void updateTree(int start, int end, int idx, int node, const vector<int>& nums) {\n        if (start == end) {\n            tree[node] = 0;\n            if (idx > 0 && idx < nums.size() - 1) {\n                if (nums[idx] > nums[idx - 1] && nums[idx] > nums[idx + 1]) {\n                    tree[node] = 1;\n                }\n            }\n            return;\n        }\n        \n        int mid = (start + end) / 2;\n        if (idx <= mid) {\n            updateTree(start, mid, idx, 2 * node + 1, nums);\n        } else {\n            updateTree(mid + 1, end, idx, 2 * node + 2, nums);\n        }\n        \n        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n    }\n\n    int queryTree(int start, int end, int L, int R, int node) {\n        if (R < start || L > end) {\n            return 0;\n        }\n        \n        if (L <= start && end <= R) {\n            return tree[node];\n        }\n        \n        int mid = (start + end) / 2;\n        int left = queryTree(start, mid, L, R, 2 * node + 1);\n        int right = queryTree(mid + 1, end, L, R, 2 * node + 2);\n        \n        return left + right;\n    }\n\npublic:\n    SegmentTree(const vector<int>& nums) {\n        n = nums.size();\n        tree.resize(4 * n, 0);\n        buildTree(nums, 0, n - 1, 0);\n        \n        for (int i = 1; i < n - 1; ++i) {\n            updateTree(0, n - 1, i, 0, nums);\n        }\n    }\n\n    void update(int idx, const vector<int>& nums) {\n        updateTree(0, n - 1, idx, 0, nums);\n        if (idx > 0) {\n            updateTree(0, n - 1, idx - 1, 0, nums);\n        }\n        if (idx < n - 1) {\n            updateTree(0, n - 1, idx + 1, 0, nums);\n        }\n    }\n\n    int it(int L, int R) {\n        return queryTree(0, n - 1, L + 1, R - 1, 0);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> vect;\n        SegmentTree segTree(nums);\n        \n        for (auto it : queries) {\n            if (it[0] == 1) { \n                int x = it[1];\n                int y = it[2];\n                vect.push_back(segTree.it(x, y));\n            } \n            else if (it[0] == 2) { \n                int ind = it[1];\n                int val = it[2];\n                nums[ind] = val;\n                segTree.update(ind, nums);\n            }\n        }\n\n        return vect;\n    }\n};",
    "submit_ts": 1718507359.0
}