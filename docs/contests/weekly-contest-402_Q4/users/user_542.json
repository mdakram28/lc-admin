{
    "username": "hkhzzz",
    "submission": "class NumArray {\nprivate:\n    vector<int> segT; // value\n    vector<int> peakT; // number of peaks\n    vector<int> frontT;\n    vector<int> backT;\n    int n;\n    \n    void build(int node, int s, int e, vector<int>& nums) {\n        if (s == e) {\n            peakT[node] = 0;\n            frontT[node] = nums[s];\n            backT[node] = nums[s];\n            return;\n        }\n        int m = s + (e - s) / 2;\n        build(node * 2 + 1, s, m, nums);\n        build(node * 2 + 2, m + 1, e, nums);\n        // segT[node] = segT[node * 2 + 1] + segT[node * 2 + 2];\n        peakT[node] = peakT[node * 2 + 1] + peakT[node * 2 + 2];\n        frontT[node] = frontT[node * 2 + 1];\n        backT[node] = backT[node * 2 + 2];\n        \n        // cout << \"original: \" << s << \"--\" << e << \"=>\" << peakT[node] << endl;\n        \n        if (s + 1 < e) {\n            if (backT[node * 2 + 1] > frontT[node * 2 + 2] && m - 1 >= s && segT[m-1] < segT[m]) {\n                // cout << \">:\" << backT[node * 2 + 1] << \" > \" << frontT[node * 2 + 2] << endl;\n                peakT[node] += 1;\n            } else if (backT[node * 2 + 1] < frontT[node * 2 + 2] && m + 2 <= e && segT[m+1] > segT[m+2]) {\n                peakT[node] += 1;\n                // cout << \"<:\" << backT[node * 2 + 1] << \" < \" << frontT[node * 2 + 2] << endl;\n            }\n        }\n        // cout << s << \"--\" << e << \": \" << peakT[node] << endl;\n    }\n\n    void change(int index, int val, int node, int s, int e) {\n        if (s == e) {\n            // segT[index] = val;\n            peakT[node] = 0;\n            frontT[node] = val;\n            backT[node] = val;\n            return;\n        }\n        int m = s + (e - s) / 2;\n        if (index <= m) {\n            change(index, val, node * 2 + 1, s, m);\n        } else {\n            change(index, val, node * 2 + 2, m + 1, e);\n        }\n        peakT[node] = peakT[node * 2 + 1] + peakT[node * 2 + 2];\n        \n        frontT[node] = frontT[node * 2 + 1];\n        backT[node] = backT[node * 2 + 2];\n        \n        \n        if (s + 1 < e) {\n            if (backT[node * 2 + 1] > frontT[node * 2 + 2] && m - 1 >= s && segT[m-1] < segT[m]) {\n                // cout << \">:\" << backT[node * 2 + 1] << \" > \" << frontT[node * 2 + 2] << endl;\n                peakT[node] += 1;\n            } else if (backT[node * 2 + 1] < frontT[node * 2 + 2] && m + 2 <= e && segT[m+1] > segT[m+2]) {\n                peakT[node] += 1;\n                // cout << \"<:\" << backT[node * 2 + 1] << \" < \" << frontT[node * 2 + 2] << endl;\n            }\n        }\n        // cout << s << \"--\" << e << \" => \" << peakT[node] << endl;\n        // segT[node] = segT[node * 2 + 1] + segT[node * 2 + 2]\n    }\n\n    int range(int left, int right, int node, int s, int e) {\n        if (left == s && right == e) {\n            return peakT[node];\n        }\n        int m = s + (e - s) / 2;\n        if (right <= m) {\n            return range(left, right, node * 2 + 1, s, m);\n        } else if (left > m) {\n            return range(left, right, node * 2 + 2, m + 1, e);\n        } else {\n            int ret = range(left, m, node * 2 + 1, s, m) + range(m + 1, right, node * 2 + 2, m+1, e);\n            // add the connection point\n            if (s + 1 < e) {\n                if (backT[node * 2 + 1] > frontT[node * 2 + 2] && m - 1 >= left && m - 1 >= s && segT[m-1] < segT[m]) {\n                    // cout << \">:\" << backT[node * 2 + 1] << \" > \" << frontT[node * 2 + 2] << endl;\n                    ret += 1;\n                } else if (backT[node * 2 + 1] < frontT[node * 2 + 2] && m + 2 <= right && m + 2 <= e && segT[m+1] > segT[m+2]) {\n                    ret += 1;\n                    // cout << \"<:\" << backT[node * 2 + 1] << \" < \" << frontT[node * 2 + 2] << endl;\n                }\n            }\n            \n            return ret;\n        }\n    }\n\npublic:\n    NumArray(vector<int>& nums) {\n        n = nums.size();\n        segT = vector<int>(nums);\n        peakT = vector<int>(n * 4);\n        frontT = vector<int>(n * 4);\n        backT = vector<int>(n * 4);\n        build(0, 0, n-1, nums);\n    }\n    \n    void update(int index, int val) {\n        if (segT[index] == val) return;\n        segT[index] = val;\n        change(index, val, 0, 0, n-1);\n    }\n    \n    int count(int left, int right) {\n        if (right - left <= 1) return 0;\n        return range(left, right, 0, 0, n-1);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        NumArray A(nums);\n        int n = queries.size();\n        vector<int> ret;\n        for (int i = 0; i < queries.size(); i ++) {\n            if (queries[i][0] == 1) {\n                ret.push_back(A.count(queries[i][1], queries[i][2]));\n            } else {\n                A.update(queries[i][1], queries[i][2]);\n            }\n        }\n        return ret;\n    }\n};\n\n// [4,5,5]\n// [[1,2,2],[1,0,1],[1,1,2]] -> [0,0,0]\n// [8,5,9,3,5]\n// [[1,2,4],[1,0,1],[2,2,4]] -> [0,0]",
    "submit_ts": 1718507251.0
}