{
    "username": "YarosHarm",
    "submission": "class Solution {\n    /**\n    Lowest stair numbered 0.\n\n    Alice has an integer jump, with an initial value of 0. \n    She starts on stair 1 and wants to reach stair k using any number of operations. If she is on stair i, in one operation she can:\n\nGo down to stair i - 1. This operation cannot be used consecutively or on stair 0.\nGo up to stair i + 2jump. And then, jump becomes jump + 1.\nReturn the total number of ways Alice can reach stair k.\n\nNote that it is possible that Alice reaches the stair k, and performs some operations to reach the stair k again.\n    */\n    \n    Map<Long, Map<Integer, Map<Integer, Integer>>> dp; \n    public int waysToReachStair(int k) {\n        dp = new HashMap<>();\n        return dfs(k, 1, 1, 0);\n    }\n    \n    private int dfs(int k, long curr, int cons, int jump) {\n        if(curr > (1L << 30) || jump > 30) {\n            return 0;\n        }\n        if(dp.containsKey(curr) && dp.get(curr).containsKey(cons) && dp.get(curr).get(cons).containsKey(jump)) {\n            return dp.get(curr).get(cons).get(jump);\n        }\n        int s = curr == k ? 1 : 0;\n        if(curr > 0 && cons == 1) {\n            s += dfs(k, curr - 1, 0, jump);\n        }\n        s += dfs(k, curr + (1 << jump), 1, jump + 1);\n        \n        dp.computeIfAbsent(curr, z -> new HashMap<>());\n        dp.get(curr).computeIfAbsent(cons, z -> new HashMap<>());\n        dp.get(curr).get(cons).put(jump, s);\n        return s;\n    }\n}",
    "submit_ts": 1716088117.0
}