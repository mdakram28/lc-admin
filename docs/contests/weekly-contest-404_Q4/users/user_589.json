{
    "username": "TANDAV_007",
    "submission": "class Solution {\npublic:\n    int dfs(int node,int par,vector<vector<int>>& adj,vector<int>& depth){\n        for(int child : adj[node]){\n            if(child!=par)\n                depth[node]=max(depth[node],dfs(child,node,adj,depth)+1);\n        }\n        return depth[node];\n    }\n    void cal_max_path(int node,int par,int additional,vector<vector<int>>& adj,vector<int>& depth,vector<int>& max_dist){\n        max_dist[node]=max(depth[node],additional);\n     \n        vector<int>children;\n        for(int child : adj[node]){\n            if(child!=par)\n                children.push_back(child);\n        }\n     \n        int n=(int)children.size();\n     \n        if(n==1){\n            cal_max_path(children[0],node,additional+1,adj,depth,max_dist);\n            return;\n        }\n     \n        vector<int>pref(n),suff(n);\n        for(int i=0,current=0;i<n;++i){\n            pref[i]=current;\n            current=max(current,depth[children[i]]);\n        }\n        for(int i=n-1,current=0;i>=0;--i){\n            suff[i]=current;\n            current=max(current,depth[children[i]]);\n        }\n     \n        for(int i=0;i<n;++i)\n            cal_max_path(children[i],node,max(additional+1,max(pref[i],suff[i])+2),adj,depth,max_dist);\n     \n        return;\n    }\n    int get_min_max_dist(vector<vector<int>>& edges){\n        int n=(int)edges.size()+1;\n        vector<vector<int>>adj(n);\n        for(vector<int>& edge : edges){\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n        vector<int>depth(n),max_dist(n);\n        dfs(0,-1,adj,depth);\n        cal_max_path(0,-1,0,adj,depth,max_dist);\n        int res=max_dist[0];\n        for(int i=1;i<n;++i) res=min(res,max_dist[i]);\n        return res;\n    }\n    int get_max_dist(vector<vector<int>>& edges){\n        int n=(int)edges.size()+1;\n        vector<vector<int>>adj(n);\n        for(vector<int>& edge : edges){\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n        vector<int>depth(n),max_dist(n);\n        dfs(0,-1,adj,depth);\n        cal_max_path(0,-1,0,adj,depth,max_dist);\n        int res=*max_element(max_dist.begin(),max_dist.end());\n        return res;\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int res=max(get_max_dist(edges1),get_max_dist(edges2));\n        int op1=get_min_max_dist(edges1),op2=get_min_max_dist(edges2);\n        int temp_res=op1+op2+1;\n        res=max(res,temp_res);\n        return res;\n    }\n};\n/*\n[[0,1],[0,2],[2,3],[3,9],[3,6],[3,5],[5,4],[4,8],[8,7]]\n[[0,1],[0,2],[0,3]]\n*/",
    "submit_ts": "1719719203",
    "subm_id": "1304436219"
}