{
    "username": "zeromb",
    "submission": "class Solution {\n    fun minimumDiameterAfterMerge(edges1: Array<IntArray>, edges2: Array<IntArray>): Int {\n        val size1 = edges1.size + 1\n        val size2 = edges2.size + 1\n\n        val graph1 = List(size1) { mutableListOf<Int>() }\n        val graph2 = List(size2) { mutableListOf<Int>() }\n\n        for (edge in edges1) {\n            graph1[edge[0]].add(edge[1])\n            graph1[edge[1]].add(edge[0])\n        }\n        for (edge in edges2) {\n            graph2[edge[0]].add(edge[1])\n            graph2[edge[1]].add(edge[0])\n        }\n\n        fun dfs(graph: List<List<Int>>, startNode: Int): Pair<Int, Int> {\n            val nodes = graph.size\n            val distances = MutableList(nodes) { -1 }\n            var furthestNode = startNode\n\n            fun explore(node: Int, distance: Int) {\n                distances[node] = distance\n                if (distance > distances[furthestNode]) {\n                    furthestNode = node\n                }\n                for (neighbor in graph[node]) {\n                    if (distances[neighbor] == -1) {\n                        explore(neighbor, distance + 1)\n                    }\n                }\n            }\n\n            explore(startNode, 0)\n            return Pair(furthestNode, distances[furthestNode])\n        }\n\n        val (furthestNode1, _) = dfs(graph1, 0)\n        val (_, diameter1) = dfs(graph1, furthestNode1)\n\n        val (furthestNode2, _) = dfs(graph2, 0)\n        val (_, diameter2) = dfs(graph2, furthestNode2)\n\n        val maxDiameter = maxOf(diameter1, diameter2)\n        val half1 = (diameter1 + 1) / 2\n        val half2 = (diameter2 + 1) / 2\n        return maxOf(maxDiameter, half1 + half2 + 1)\n    }\n}\n",
    "submit_ts": "1719715766",
    "subm_id": "1304345739"
}