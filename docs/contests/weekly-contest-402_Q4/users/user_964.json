{
    "username": "nobody_dd",
    "submission": "class Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        //solution 1, iterative segment tree\n        //\n        int n = nums.size();\n        vector<int> segTree(n << 1);\n        vector<int> ret;\n\n        //update segment tree\n        auto updSegTree = [&segTree, &n](int idx, int val){\n            idx += n, segTree[idx] = val;\n\n            while(idx > 1) idx >>= 1, segTree[idx] = segTree[idx<<1] + segTree[(idx<<1)+1];\n        };\n\n        //range query segment tree\n        auto querySegTree = [&segTree, &n](int l, int r){\n            int cnt = 0;\n            l += n, r += n;\n\n            while(l < r){\n                //if left index is odd, add it, then make it even\n                if(l & 1) cnt += segTree[l++];\n                //if right index is odd, make it even, then add it\n                if(r & 1) cnt += segTree[--r];\n                //move to up level\n                l >>= 1, r >>= 1;\n            }\n\n            return cnt;\n        };\n\n        //init segment tree leaf node\n        segTree[n] = segTree[(n<<1)-1] = 0;\n        for(int i = 1; i < n - 1; ++i){\n            segTree[n + i] = nums[i] > nums[i-1] && nums[i] > nums[i+1] ? 1 : 0;\n        }\n        for(int i = 0; i < n; ++i) cout<<segTree[n+i]<<\", \";\n        cout<<endl;\n\n        //init segment tree middle node\n        for(int i = n - 1; i > 0; --i){\n            segTree[i] = segTree[i<<1] + segTree[(i<<1)+1];\n        }\n\n        //generate result\n        for(const auto &v: queries){\n            if(v[0] == 1){\n                //query peaks count\n                //note that it should not include the boundary element v[1] and v[2]\n                ret.emplace_back(querySegTree(v[1]+1, v[2]));\n            }else{\n                //update element in the array\n                int oldVal = nums[v[1]]; nums[v[1]] = v[2];\n                int i1 = v[1] - 1, i2 = v[1], i3 = v[1] + 1, oldFlag, newFlag;\n                //check if we need to update left neighbour, 0->1 or 1->0\n                if(i1 > 0){\n                    oldFlag = nums[i1] > nums[i1-1] && nums[i1] > oldVal;\n                    newFlag = nums[i1] > nums[i1-1] && nums[i1] > nums[i2];\n                    \n                    if(oldFlag != newFlag) updSegTree(i1, newFlag);\n                }\n                //check if we need to update current element\n                if(i2 > 0 && i2 < n - 1){\n                    oldFlag = oldVal > nums[i1] && oldVal > nums[i3];\n                    newFlag = nums[i2] > nums[i1] && nums[i2] > nums[i3];\n                    \n                    if(oldFlag != newFlag) updSegTree(i2, newFlag);\n                }\n                //check if we need to update right neighbour\n                if(i3 < n-1){\n                    oldFlag = nums[i3] > oldVal && nums[i3] > nums[i3+1];\n                    newFlag = nums[i3] > nums[i2] && nums[i3] > nums[i3+1];\n                    \n                    if(oldFlag != newFlag) updSegTree(i3, newFlag);\n                }\n            }\n        }\n\n        return ret;\n        //end of solution 1\n    }\n};",
    "submit_ts": "1718508905",
    "subm_id": "539790006"
}