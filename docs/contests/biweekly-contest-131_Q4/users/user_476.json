{
    "username": "aphend",
    "submission": "#define ll long long\n#define all(a) a.begin(), a.end()\n\nclass Solution {\n    template <typename Node, typename Update>\n    struct LazySGT\n    {\n        vector<Node> tree;\n        vector<bool> lazy;\n        vector<Update> updates;\n        vector<ll> arr; // type may change\n        int n;\n        int s;\n        LazySGT(int a_len, vector<ll> &a)\n        { // change if type updated\n            arr = a;\n            n = a_len;\n            s = 1;\n            while (s < 2 * n)\n            {\n                s = s << 1;\n            }\n            tree.resize(s);\n            fill(all(tree), Node());\n            lazy.resize(s);\n            fill(all(lazy), false);\n            updates.resize(s);\n            fill(all(updates), Update());\n            build(0, n - 1, 1);\n        }\n        void build(int start, int end, int index)\n        { // Never change this\n            if (start == end)\n            {\n                tree[index] = Node(arr[start]);\n                return;\n            }\n            int mid = (start + end) / 2;\n            build(start, mid, 2 * index);\n            build(mid + 1, end, 2 * index + 1);\n            tree[index].merge(tree[2 * index], tree[2 * index + 1]);\n        }\n        void pushdown(int index, int start, int end)\n        {\n            if (lazy[index])\n            {\n                int mid = (start + end) / 2;\n                apply(2 * index, start, mid, updates[index]);\n                apply(2 * index + 1, mid + 1, end, updates[index]);\n                updates[index] = Update();\n                lazy[index] = 0;\n            }\n        }\n        void apply(int index, int start, int end, Update &u)\n        {\n            if (start != end)\n            {\n                lazy[index] = 1;\n                updates[index].combine(u, start, end);\n            }\n            u.apply(tree[index], start, end);\n        }\n        void update(int start, int end, int index, int left, int right, Update &u)\n        { // Never Change this\n            if (start > right || end < left)\n                return;\n            if (start >= left && end <= right)\n            {\n                apply(index, start, end, u);\n                return;\n            }\n            pushdown(index, start, end);\n            int mid = (start + end) / 2;\n            update(start, mid, 2 * index, left, right, u);\n            update(mid + 1, end, 2 * index + 1, left, right, u);\n            tree[index].merge(tree[2 * index], tree[2 * index + 1]);\n        }\n        Node query(int start, int end, int index, int left, int right)\n        { // Never change this\n            if (start > right || end < left)\n                return Node();\n            if (start >= left && end <= right)\n            {\n                pushdown(index, start, end);\n                return tree[index];\n            }\n            pushdown(index, start, end);\n            int mid = (start + end) / 2;\n            Node l, r, ans;\n            l = query(start, mid, 2 * index, left, right);\n            r = query(mid + 1, end, 2 * index + 1, left, right);\n            ans.merge(l, r);\n            return ans;\n        }\n        void make_update(int left, int right, ll val)\n        {                                    // pass in as many parameters as required\n            Update new_update = Update(val); // may change\n            update(0, n - 1, 1, left, right, new_update);\n        }\n        Node make_query(int left, int right)\n        {\n            return query(0, n - 1, 1, left, right);\n        }\n    };\n\n    struct Node1\n    {\n        long long val, maxi, suf, pref; // may change\n        Node1()\n        {            // Identity element\n            val = 0; // may change\n            maxi = 0;\n            suf = 0;\n            pref = 0;\n        }\n        Node1(ll p1)\n        {             // Actual Node\n            val = p1; // may change\n            maxi = p1;\n            suf = p1;\n            pref = p1;\n        }\n        void merge(Node1 &l, Node1 &r)\n        {                        // Merge two child nodes\n            val = l.val + r.val; // may change\n            pref = max(l.pref, l.val + r.pref);\n            suf = max(r.suf, r.val + l.suf);\n            maxi = max(l.suf + r.pref, max(l.maxi, r.maxi));\n        }\n    };\n \n    struct Update1 {\n        ll val; // may change\n        Update1()\n        { // Identity update\n            val = 0;\n        }\n        Update1(ll val1)\n        { // Actual Update\n            val = val1;\n        }\n        void apply(Node1 &a, int start, int end) { // apply update to given node\n            if (val <= 0) {\n                a.val = val * (end - start + 1);\n                a.pref = a.suf = a.maxi = 0;\n            }\n            else {\n                a.val = a.pref = a.suf = a.maxi = val * (end - start + 1);\n            }\n        }\n        void combine(Update1 &new_update, int start, int end) {\n            val = new_update.val;\n        }\n    };\n\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        ll z = min(50010ll,3ll * (ll)(queries.size()) + 10);\n        vector<ll> a(z,1);\n        LazySGT<Node1,Update1> sg=LazySGT<Node1,Update1>(z,a);\n        \n        vector<bool> sa;\n        for(auto &q : queries) {\n            int x = q[0];\n            if(x == 1) {\n                sg.make_update(q[1],q[1],-1e9);\n            } else {\n                ll y = sg.make_query(1,q[1]-1).maxi;\n                \n                if(y+1>=q[2] && q[1]>=q[2]) {\n                    sa.push_back(true);\n                } else {\n                    sa.push_back(false);\n                }\n            }\n        }\n        return sa;\n    }\n};",
    "submit_ts": "1716651138",
    "subm_id": "1267633041"
}