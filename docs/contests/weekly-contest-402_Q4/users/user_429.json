{
    "username": "didwhddks",
    "submission": "template <typename Info>\nstruct SegTree {\n    int n;\n    vector<Info> info;\n \n    SegTree(int n = 0) {\n        init(n);\n    }\n \n    void init(int n) {\n        this->n = n;\n        info.assign(4 * n, Info());\n    }\n \n    void pull(int i) {\n        info[i] = info[2 * i] + info[2 * i + 1];\n    }\n \n    void set(int idx, Info _info, int i, int L, int R) {\n        if (L == R) {\n            info[i] = _info;\n            return;\n        }\n        int mid = (L + R) / 2;\n        if (idx <= mid) {\n            set(idx, _info, 2 * i, L, mid);\n        } else {\n            set(idx, _info, 2 * i + 1, mid + 1, R);\n        }\n        pull(i);\n    }\n\n    void set(int idx, Info _info) {\n        set(idx, _info, 1, 0, n - 1);\n    }\n \n    Info rangeQuery(int qL, int qR, int i, int L, int R) {\n        if (R < qL || qR < L) {\n            return Info();\n        }\n        if (qL <= L && R <= qR) {\n            return info[i];\n        }\n        int mid = (L + R) / 2;\n        Info a = rangeQuery(qL, qR, 2 * i, L, mid);\n        Info b = rangeQuery(qL, qR, 2 * i + 1, mid + 1, R);\n        return a + b;\n    }\n\n    Info rangeQuery(int qL, int qR) {\n        return rangeQuery(qL, qR, 1, 0, n - 1);\n    }\n};\n\nstruct Info {\n    int cnt;\n    Info(int x = 0) {\n        cnt = x;\n    }\n    Info operator+(const Info& b) {\n        Info c;\n        c.cnt = cnt + b.cnt;\n        return c;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        const int n = nums.size();\n        SegTree<Info> seg(n);\n        for (int i = 1; i < n - 1; ++i) {\n            if (nums[i - 1] < nums[i] && nums[i] > nums[i + 1]) {\n                seg.set(i, Info(1));\n            }\n        }\n        \n        vector<int> ans;\n        for (auto query : queries) {\n            int t = query.front();\n            if (t == 1) {\n                int L = query[1];\n                int R = query[2];\n                ans.push_back(seg.rangeQuery(L + 1, R - 1).cnt);\n            } else {\n                int idx = query[1];\n                int val = query[2];\n                nums[idx] = val;\n                if (idx - 1 > 0) {\n                    if (nums[idx - 2] < nums[idx - 1] && nums[idx - 1] > nums[idx]) {\n                        seg.set(idx - 1, Info(1));\n                    } else if (seg.rangeQuery(idx - 1, idx - 1).cnt == 1) {\n                        seg.set(idx - 1, Info(0));\n                    }\n                }\n                if (idx + 1 < n - 1) {\n                    if (nums[idx] < nums[idx + 1] && nums[idx + 1] > nums[idx + 2]) {\n                        seg.set(idx + 1, Info(1));\n                    } else if (seg.rangeQuery(idx + 1, idx + 1).cnt == 1) {\n                        seg.set(idx + 1, Info(0));\n                    }\n                }\n                if (idx == 0 || idx == n - 1) {\n                    continue;\n                }\n                if (nums[idx - 1] < nums[idx] && nums[idx] > nums[idx + 1]) {\n                    seg.set(idx, Info(1));\n                } else if (seg.rangeQuery(idx, idx).cnt == 1) {\n                    seg.set(idx, Info(0));\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1718507241",
    "subm_id": "1289645534"
}