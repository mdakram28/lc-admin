{
    "username": "Silken",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n\nauto init = []() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\n\nusing i64 = int64_t;\n\nstruct Tree {\n    int n, root;\n    vector<int> par, dep, siz;\n    vector<vector<int>> adj;\n\n    Tree(int n) : n(n), root(-1), par(n, -1), dep(n, -1), siz(n, -1), adj(n) {}\n\n    void addEdge(int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    void work(int root = 0) {\n        this->root = root;\n        dep[root] = 0;\n        par[root] = -1;\n        dfs1(root);\n    }\n\n    void dfs1(int node) {\n        siz[node] = 1;\n        if (par[node] != -1)  // adj[node] will not contain par[node]\n            adj[node].erase(find(begin(adj[node]), end(adj[node]), par[node]));\n        for (int i : adj[node]) {\n            par[i] = node;\n            dep[i] = dep[node] + 1;\n            dfs1(i);\n            siz[node] += siz[i];\n        }\n    }\n};\n\nclass Solution {\n   public:\n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n\n        Tree t(n);\n        for (auto& e : edges) {\n            t.addEdge(e[0], e[1]);\n        }\n        t.work();\n\n        vector<int> res(n);\n\n        auto dfs = [&](auto self, int node) -> void {\n            int mx = 0;\n            // cout<<\"dfs \"<<node<<endl;\n            for (int a : t.adj[node]) {\n                self(self, a);\n                mx = max(mx, res[a] + (a % 2 == 0 ? 2 : 1));\n                // cout<<\"a = \"<<a<<\", mx = \"<<mx<<endl;\n            }\n            res[node] = mx;\n        };\n\n        dfs(dfs, 0);\n        // for (int i : res) {\n        //     cout << i << ' ';\n        // }\n        // cout << endl;\n        vector<int> ans(n);\n\n        auto dfs2 = [&](auto self, int node, int add) -> void {\n            vector<int> v;\n            for (int i : t.adj[node]) {\n                v.push_back(res[i] + (i % 2 == 0 ? 2 : 1));\n            }\n            ranges::sort(v, greater<int>());\n            v.resize(2);\n            // cout<<\"node = \"<<node<<\", add = \"<<add<<endl;\n            // cout<<\"nearest: \"<<v[0]<<\", \"<<v[1]<<endl;\n            ans[node] = max(add, v[0]);\n            for (int i : t.adj[node]) {\n                if (res[i] + (i % 2 == 0 ? 2 : 1) == v[0]) {\n                    self(self, i, max(add, v[1]) + (node % 2 == 0 ? 2 : 1));\n                } else {\n                    self(self, i, max(add, v[0]) + (node % 2 == 0 ? 2 : 1));\n                }\n            }\n        };\n\n        dfs2(dfs2, 0, 0);\n\n        return ans;\n    }\n};",
    "submit_ts": "1722699002",
    "subm_id": "1343198514"
}