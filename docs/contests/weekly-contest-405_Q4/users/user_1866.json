{
    "username": "vijay_15",
    "submission": "#define LL int\nstruct NewNode {\n    unordered_map<char, NewNode*> ANS;\n    vector<pair<LL, LL>> endPositions; \n};\n\nclass Trie {\nprivate:\n    NewNode* root;\n\npublic:\n    Trie() {\n        root = new NewNode();\n    }\n\n    void getIn(const string& word, LL index, LL cost) {\n        NewNode* node = root;\n        for (char ch : word) {\n            if (!node->ANS.count(ch))\n                node->ANS[ch] = new NewNode();\n            node = node->ANS[ch];\n        }\n        node->endPositions.push_back({index, cost});\n    }\n\n    NewNode* GetNewroot() {\n        return root;\n    }\n};\n\nclass Solution {\npublic:\n    LL minimumCost(string target, vector<string>& wordList, vector<LL>& costList) {\n        LL targetLength = target.size();\n        vector<LL> minCost(targetLength + 1, INT_MAX); \n        minCost[0] = 0;\n\n        Trie trie;\n        for (LL i = 0; i < wordList.size(); ++i) {\n            trie.getIn(wordList[i], i, costList[i]);\n        }\n\n        for (LL i = 0; i < targetLength; ++i) {\n            if (minCost[i] == INT_MAX) continue; \n            NewNode* currentNode = trie.GetNewroot();\n            for (LL j = i; j < targetLength; ++j) {\n                char ch = target[j];\n                if (!currentNode->ANS.count(ch)) break;\n                currentNode = currentNode->ANS[ch];\n\n                for (auto& p : currentNode->endPositions) {\n                    LL wordIndex = p.first;\n                    LL wordCost = p.second;\n                    LL wordLength = wordList[wordIndex].size();\n\n                    if (i + wordLength <= targetLength) {\n                        minCost[i + wordLength] = min(minCost[i + wordLength], minCost[i] + wordCost);\n                    }\n                }\n            }\n        }\n        return minCost[targetLength] == INT_MAX ? -1 : minCost[targetLength];\n\n    }\n};\n\n",
    "submit_ts": "1720324515",
    "subm_id": "1312401396"
}