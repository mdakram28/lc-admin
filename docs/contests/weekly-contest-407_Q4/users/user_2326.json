{
    "username": "AlphaS",
    "submission": "#define pb push_back\n#define fs first\n#define mp make_pair\n#define sc second\n\nclass Solution {\npublic:\n    int val[100005];\n    pair<int,int> tree[4 * 100005];\n    vector<pair<int,int> > q; \n    int N;\n    \n    void build(int idx, int l, int r){\n        if(l == r){\n            tree[idx].fs = val[l];\n            tree[idx].sc = l;\n            return;\n        }\n        build(2 * idx, l, (l + r)/2);\n        build(2 * idx + 1, (l + r)/2 + 1, r);\n        \n        tree[idx].fs = min(tree[2 * idx].fs, tree[2 * idx + 1].fs);\n        if(tree[2 * idx].fs <= tree[2 * idx + 1].fs){\n            tree[idx].sc = tree[2 * idx].sc;\n        }else{\n            tree[idx].sc = tree[2 * idx + 1].sc;\n        }\n    }\n    \n    pair<int,int> cari(int idx, int l, int r, int kiri, int kanan){\n        if(kiri > r || kanan < l){\n            return mp(1e9, -1);\n        }\n        \n        if(l >= kiri && r <= kanan){\n            return tree[idx];\n        }\n        pair<int,int> satu = cari(2 * idx, l, (l + r)/2, kiri, kanan);\n        pair<int,int> dua = cari(2 * idx + 1, (l + r)/2 + 1, r, kiri, kanan);\n        // if(kiri == 2 && kanan == 4){\n        //     cout << satu.fs << \" \" << satu.sc << \" \" << dua.fs << \" \" << dua.sc << \"here\\n\";\n        // }\n        if(satu.fs <= dua.fs){\n            return satu;\n        }else{\n            return dua;\n        }\n    }\n    \n    long long solve(int l, int r, int bawa){\n        if(r < l) return 0;\n        // cout << l << \" \" << r << \" here\\n\";\n        \n        pair<int,int> now = cari(1, 1, N, l, r);\n        long long ret = now.fs - bawa;\n        ret = ret + solve(l, now.sc - 1, now.fs);\n        ret = ret + solve(now.sc + 1, r, now.fs);\n        return ret;\n    }\n    \n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n        N = nums.size();\n        vector<int> sel;\n        for(int i = 0; i < nums.size(); i++){\n            sel.pb(nums[i] - target[i]);\n        }\n        \n        int kiri = 0;\n        for(int i = 1; i < sel.size(); i++){\n            if(sel[i] > 0 && sel[i - 1] > 0){\n                continue;\n            }else if(sel[i] < 0 && sel[i - 1] < 0){\n                continue;\n            }else{\n                q.pb(mp(kiri, i - 1));\n                kiri = i;\n            }\n        }\n        q.pb(mp(kiri, sel.size() - 1));\n        \n        for(int i = 0; i < q.size(); i++){\n            q[i].fs++; q[i].sc++;\n        }\n        for(int i = 0; i < sel.size(); i++){\n            val[i + 1] = abs(sel[i]);\n        }\n        build(1, 1, nums.size());\n        \n        long long ans = 0;\n        for(int i = 0; i < q.size(); i++){\n            // cout << q[i].fs << \" \" << q[i].sc << \" query\\n\";\n            ans = ans + solve(q[i].fs, q[i].sc, 0);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1721533946",
    "subm_id": "1328020174"
}