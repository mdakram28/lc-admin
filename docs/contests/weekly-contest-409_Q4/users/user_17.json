{
    "username": "Andwerp",
    "submission": "template <typename T>\nstruct SegtreeLazy {\n    public:\n        int n;\n        T* t;    //stores product of range\n        T* d;    //lazy tree\n        bool* upd;  //marks whether or not a lazy change is here\n        T uneut, qneut;\n\n        //single element modify\n        function<T(T, T)> fmodify;\n\n        //k element modify\n        function<T(T, T, int)> fmodifyk;\n\n        //product of two elements for query\n        function<T(T, T)> fcombine;\n\n        SegtreeLazy(int maxSize, T updateNeutral, T queryNeutral, T initVal, function<T(T, T)> fmodify, function<T(T, T, int)> fmodifyk, function<T(T, T)> fcombine) {\n            n = maxSize;\n            uneut = updateNeutral;\n            qneut = queryNeutral;\n\n            this -> fmodify = fmodify;\n            this -> fmodifyk = fmodifyk;\n            this -> fcombine = fcombine;\n\n            //raise n to nearest pow 2\n            int x = 1;\n            while(x < n) {\n                x <<= 1;\n            }\n            n = x;\n\n            t = new T[n * 2];\n            d = new T[n * 2];\n            upd = new bool[n * 2];\n\n            //make sure to initialize values\n            for(int i = 0; i < n; i++){\n                t[i + n] = initVal;\n            }\n            build();\n        }\n\n        void assign(vector<T>& arr) {\n            for(int i = 0; i < min(n, (int) arr.size()); i++){\n                t[i + n] = arr[i];\n            }\n            build();\n        }\n\n        //build tree after manually assigning values\n        void build() {\n            for(int i = n - 1; i > 0; i--){\n                t[i] = fcombine(t[i * 2], t[i * 2 + 1]);\n            }\n            for(int i = 0; i < n * 2; i++){\n                d[i] = uneut;\n                upd[i] = false;\n            }\n        }\n\n        void modify(int l, int r, T val) {    //modifies the range [l, r)\n            _modify(l, r, val, 0, n, 1);\n        }\n\n        void modify(int ind, T val) { //modifies the range [ind, ind + 1)\n            _modify(ind, ind + 1, val, 0, n, 1);\n        }\n\n        T query(int l, int r) {   //queries the range [l, r)\n            return _query(l, r, 0, n, 1);\n        }\n\n        T query(int ind) {    //queries the range [ind, ind + 1)\n            return _query(ind, ind + 1, 0, n, 1);\n        }\n\n    private:\n        //calculates value of node based off of children\n        //k is the amount of values that this node represents. \n        void combine(int ind, int k) {\n            if(ind >= n){\n                return;\n            }\n            int l = ind * 2;\n            int r = ind * 2 + 1;\n            //make sure children are correct value before calculating\n            push(l, k / 2);\n            push(r, k / 2);\n            t[ind] = fcombine(t[l], t[r]);\n        }\n\n        //registers a lazy change llo this node\n        void apply(int ind, T val) {\n            upd[ind] = true;\n            d[ind] = fmodify(d[ind], val);\n        }\n\n        //applies lazy change to this node\n        //k is the amount of values that this node represents. \n        void push(int ind, int k) {\n            if(!upd[ind]) {\n                return;\n            }\n            t[ind] = fmodifyk(t[ind], d[ind], k);\n            if(ind < n) {\n                int l = ind * 2;\n                int r = ind * 2 + 1;\n                apply(l, d[ind]);\n                apply(r, d[ind]);\n            }\n            upd[ind] = false;\n            d[ind] = uneut;\n        }\n\n        void _modify(int l, int r, T val, int tl, int tr, int ind) {\n            if(l == r){\n                return;\n            }\n            if(upd[ind]) {\n                push(ind, tr - tl);\n            }\n            if(l == tl && r == tr) {\n                apply(ind, val);\n                push(ind, tr - tl);\n                return;\n            }\n            int mid = tl + (tr - tl) / 2;\n            if(l < mid) {\n                _modify(l, min(r, mid), val, tl, mid, ind * 2);\n            }\n            if(r > mid) {\n                _modify(max(l, mid), r, val, mid, tr, ind * 2 + 1);\n            }\n            combine(ind, tr - tl);\n        }\n\n        T _query(int l, int r, int tl, int tr, int ind) {\n            if(l == r){\n                return qneut;\n            }  \n            if(upd[ind]) {\n                push(ind, tr - tl);\n            }\n            if(l == tl && r == tr){\n                return t[ind];\n            }\n            int mid = tl + (tr - tl) / 2;\n            T lans = qneut;\n            T rans = qneut;\n            if(l < mid) {\n                lans = _query(l, min(r, mid), tl, mid, ind * 2);\n            }\n            if(r > mid) {\n                rans = _query(max(l, mid), r, mid, tr, ind * 2 + 1);\n            }\n            return fcombine(lans, rans);\n        }\n};\n\nclass Solution {\npublic:\n    void ins_b(set<int>& b, SegtreeLazy<int>& segt, int val, int n) {\n        // cout << \"INS : \" << val << endl;\n        if(b.size() == 0){\n            b.insert(val);\n            return;\n        }\n        int l, r;\n        if(val < *b.begin()) {\n            l = *b.rbegin();\n        }\n        else {\n            auto ptr = b.lower_bound(val);\n            ptr --;\n            l = *ptr;\n        }\n        if(val > *b.rbegin()) {\n            r = *b.begin();\n        }\n        else {\n            r = *b.lower_bound(val);\n        }\n        if(r <= l){\n            r += n;\n        }\n        b.insert(val);\n        if(val <= l){\n            val += n;\n        }\n        segt.modify(0, r - l, -1);\n        segt.modify(0, val - l, 1);\n        segt.modify(0, r - val, 1);\n    }\n\n    void del_b(set<int>& b, SegtreeLazy<int>& segt, int val, int n) {\n        // cout << \"DEL : \" << val << endl;\n        b.erase(val);\n        if(b.size() == 0){\n            return;\n        }\n        int l, r;\n        if(val < *b.begin()) {\n            l = *b.rbegin();\n        }\n        else {\n            auto ptr = b.lower_bound(val);\n            ptr --;\n            l = *ptr;\n        }\n        if(val > *b.rbegin()) {\n            r = *b.begin();\n        }\n        else {\n            r = *b.lower_bound(val);\n        }\n        if(r <= l){\n            r += n;\n        }\n        if(val <= l){\n            val += n;\n        }\n        // cout << \"DEL : \" << val - l << \" \" << r - val << \"\\n\";\n        segt.modify(0, r - l, 1);\n        segt.modify(0, val - l, -1);\n        segt.modify(0, r - val, -1);\n    }\n\n    vector<int> numberOfAlternatingGroups(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        function<int(int, int)> fmodify = [](const int src, const int val) -> int{return src + val;};\n        function<int(int, int, int)> fmodifyk = [](const int src, const int val, const int k) -> int{return src + val * k;};\n        function<int(int, int)> fcombine = [](const int a, const int b) -> int{return a + b;};\n        SegtreeLazy<int> segt(n, 0, 0, 1, fmodify, fmodifyk, fcombine);\n        set<int> b;\n        for(int i = 0; i < n; i++){\n            if(a[i] == a[(i + 1) % n]) {\n                ins_b(b, segt, i, n);\n            }\n        }\n        // cout << \"DONE INIT\" << endl;\n        vector<int> ans(0);\n        for(int i = 0; i < q.size(); i++){\n            int type = q[i][0];\n            if(type == 1){\n                int sz = q[i][1];\n                if(b.size() == 0){\n                    ans.push_back(n);\n                }\n                else {\n                    ans.push_back(segt.query(sz - 1, n));\n                }\n            }\n            else {\n                int ind = q[i][1];\n                int col = q[i][2];\n                if(a[ind] == col){\n                    continue;\n                }\n                // cout << \"IND : \" << ind << \" \" << col << \"\\n\";\n                // cout << (ind - 1 + n) % n << \"\\n\";\n                if(a[ind] == a[(ind - 1 + n) % n]) {\n                    del_b(b, segt, (ind - 1 + n) % n, n);\n                }\n                else {\n                    ins_b(b, segt, (ind - 1 + n) % n, n);\n                }\n                if(a[ind] == a[(ind + 1) % n]) {\n                    del_b(b, segt, ind, n);\n                }\n                else {\n                    ins_b(b, segt, ind, n);\n                }\n                a[ind] = col;\n            }\n            // cout << \"SEGT : \" << \"\\n\";\n            // for(int j = 0; j < n; j++){\n            //     cout << segt.query(j) << \" \";\n            // }\n            // cout << \"\\n\";\n            // cout << \"B : \" << \"\\n\";\n            // for(auto j = b.begin(); j != b.end(); j++){\n            //     cout << *j << \" \";\n            // }\n            // cout << \"\\n\";\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722741473",
    "subm_id": "1343745882"
}