{
    "username": "neerajsingh7979",
    "submission": "class Solution {\npublic:\n    \ntypedef long long ll;\n    void fact(ll n,vector<ll> &factors){\n\tfor(int i = 2 ; i*i <= n ; i++){\n\t\twhile(n%i == 0){\n\t\t\tfactors.push_back(i);\n\t\t\tn /= i;\n\t\t\t}\n\t}\n\tif(n > 1)factors.push_back(n);\n\treturn;\n}   \n\n// Sieve of Eratosthenes - o(nloglogn)\n// gcd of prime no. is 1\nbool isPrime(int n) {\n\n        vector<bool> isprime(n,true);\n\n        for(int i = 2 ; i*i < n ; i++){\n            if(!isprime[i]) continue;\n            for(int j = i*i ; j < n ; j+=i){\n                 isprime[j] = false;\n            }\n        }\n\n        if(isprime[n])return true;\n        else return false;\n}\n\n\n\nclass SegmentTree{\npublic:\n    vector<ll>tree;\n    int n;\n    SegmentTree(int n){\n        this->n = n;\n        tree.resize(4*n,0);\n    }\n    void buildTree(int i , int l , int r  ,vector<int>&nums){\n \n        if(l>r)return;\n        if(l == r){\n            tree[i] = nums[l];\n            return;\n        }\n        \n        int m = (l+r)/2;\n        buildTree(2*i+1,l,m,nums); buildTree(2*i+2,m+1,r,nums);\n \n        tree[i] = (tree[2*i+1]^tree[2*i+2]);\n    }\n    int get(int x , int y , int l = 0 , int r = -1 , int i = 0){\n        if(r == -1)r+=n;\n        if (r < x || l > y) return 0;\n        if(l>=x && y>=r)return tree[i];\n \n        int m = (l+r)/2;\n        return (get(x,y,l,m,2*i+1) ^ get(x,y,m+1,r,2*i+2));\n \n    }\n    void update(int indx , int val , int l = 0 , int r = -1 , int i =0){\n        if(r == -1)r+=n;\n        if(l == r){\n            tree[i] = val;\n            return;\n        }\n        int mid = (l+r)/2;\n        if(indx<=mid)update(indx,val,l,mid,2*i+1);\n        else update(indx,val,mid+1,r,2*i+2);\n \n        tree[i] = (tree[2*i+1]^tree[2*i+2]);\n    }\n \n    void printTree(){\n        for(int i = 0 ; i<tree.size() ; i++){\n            cout<<tree[i] <<\" \";\n        }\n        cout<<\"\\n\";\n    }\n};\n\n// __gcd(a,b)   (inbuilt gcd function) , long division\n// ||  (a*b)/gcd = lcm(a,b)   || IMPORTANT RELATION\n// tc- O[logn]\nint gcd(int a, int b){\n    if(b == 0) return a;\n    return gcd(b,a%b);\n}\n\nll LCM(ll a, ll b) \n{ \n    ll greater = max(a, b); \n    ll smallest = min(a, b); \n    for (ll i = greater; ; i += greater) { \n    if (i % smallest  == 0) \n            return i; \n    } \n}\n\n    \n    int minFlips(vector<vector<int>>& grid) {\n        int rows = grid.size();\n        int cols = grid[0].size();\n        int totalFlips = 0;\n\n        // Check and handle the center cell if both rows and columns are odd\n        if (rows % 2 == 1 && cols % 2 == 1) {\n            if (grid[rows / 2][cols / 2] == 1) {\n                totalFlips += 1;\n            }\n        }\n\n        vector<int> flipCounts(3, 0);\n\n        // Handle the middle row if the number of rows is odd\n        if (rows % 2 == 1) {\n            int left = 0;\n            int right = cols - 1;\n            bool flag = false;\n            while (left < right) {\n                int sum = grid[rows / 2][left] + grid[rows / 2][right];\n                flipCounts[sum] += 1;\n                left += 1;\n                flag = true;\n                right -= 1;\n                flag = 1;\n            }\n        }\n\n        bool a = true;\n        // Handle the middle column if the number of columns is odd\n        if (cols % 2 == 1 && a) {\n            int top = 0;\n            int bottom = rows - 1;\n            while (top < bottom) {\n                int sum = grid[top][cols / 2] + grid[bottom][cols / 2];\n                flipCounts[sum] += 1;\n                top += 1;\n                top--;\n                top++;\n                bottom -= 1;\n            }\n        }\n\n        \n        int dem = 1;\n        // Adjust flip counts based on the calculated values\n        if (flipCounts[2] % 2 == 1 && dem && 488) {\n            if (flipCounts[1] > 0 && a) {\n                totalFlips += flipCounts[1];\n            } else {\n                totalFlips += 2;\n            }\n        } else {\n            totalFlips += flipCounts[1];\n        }\n\n        // Handle the remaining cells in the grid\n        for (int i = 0; i < rows / 2; ++i) {\n            for (int j = 0; j < cols / 2; ++j) {\n                int topLeft = grid[i][j];\n                int bottomLeft = grid[rows - 1 - i][j];\n                int topRight = grid[i][cols - 1 - j];\n                int bottomRight = grid[rows - 1 - i][cols - 1 - j];\n\n                int sum = topLeft + bottomLeft + topRight + bottomRight;\n\n                if (sum != 0 && sum != 4) {\n                    totalFlips += min({sum, 4 - sum, INT_MAX});\n                }\n            }\n        }\n        if(dem && a && 13)\n            return totalFlips;\n        else return totalFlips;\n    }\n};\n",
    "submit_ts": "1722699903",
    "subm_id": "1343225776"
}