{
    "username": "apometta",
    "submission": "class Solution {\nprivate:\n    class Trie {\n    public:\n        class Node {\n        public:\n            int cost;\n            unordered_map<char, Node*> links;\n\n            Node() : cost(INT_MAX) {}\n        };\n\n        Node *head;\n        vector<int> cache;\n\n        Trie (int cache_len) : head(new Node()) {\n            cache = vector<int>(cache_len +  1, INT_MIN);\n            cache[cache_len] = 0;\n        }\n\n        void add_word(const string& s, int cost) {\n            Node *cur = head;\n            for (char c : s) {\n                if (!(cur->links.contains(c))) {\n                    cur->links[c] = new Node();\n                }\n                cur = cur->links[c];\n            }\n            cur->cost = min(cur->cost, cost);\n        }\n\n        int get_cost_from(const string& target, int start) {\n            if (cache[start] != INT_MIN) return cache[start];\n            int min_cost = INT_MAX, i = start;\n            Node *curr = head;\n\n            while (i < target.length() && curr->links.contains(target[i])) {\n                curr = curr->links[target[i]];\n                if (curr->cost != INT_MAX) {\n                    long long alt_cost = curr->cost + (long long) this->get_cost_from(target, i + 1);\n                    if (alt_cost < min_cost) min_cost = (int) alt_cost;\n                }\n                i++;\n            } \n\n            cache[start] = min_cost;\n            return min_cost;\n        }\n    };\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        Trie t(target.length());\n        for (int i = 0; i < words.size(); i++) {\n            t.add_word(words[i], costs[i]);\n        }\n\n        int best = t.get_cost_from(target, 0);\n        return best == INT_MAX ? -1 : best;\n    }\n};",
    "submit_ts": "1720322957",
    "subm_id": "1312363620"
}