{
    "username": "odinson776",
    "submission": "import java.util.*;\n\npublic class Solution {\n\n    private boolean bfs(List<List<Integer>> graph, int startNode, int target1, int target2, int totalNodes) {\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] visited = new boolean[totalNodes + 4];\n        \n        queue.add(startNode);\n        visited[startNode] = true;\n        \n        while (!queue.isEmpty()) {\n            int currentNode = queue.poll();\n            for (int neighbor : graph.get(currentNode)) {\n                if (!visited[neighbor]) {\n                    queue.add(neighbor);\n                    visited[neighbor] = true;\n                }\n            }\n        }\n        \n        return visited[target1] || visited[target2];\n    }\n\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        int circleCount = circles.length;\n        List<int[]> circleDataList = new ArrayList<>();\n        List<List<Integer>> adjacencyList = new ArrayList<>();\n        \n        for (int i = 0; i < circleCount + 4; i++) {\n            adjacencyList.add(new ArrayList<>());\n        }\n        \n        // Convert circles to a list of circle data\n        for (int i = 0; i < circleCount; i++) {\n            int[] circle = circles[i];\n            circleDataList.add(new int[]{circle[0], circle[1], circle[2]});\n        }\n        \n        for (int i = 0; i < circleCount; i++) {\n            int[] currentCircle = circleDataList.get(i);\n            int centerX = currentCircle[0], centerY = currentCircle[1], radius = currentCircle[2];\n            \n            if (centerX <= radius) {\n                adjacencyList.get(circleCount).add(i);\n                adjacencyList.get(i).add(circleCount);\n            }\n            if (X - centerX <= radius) {\n                adjacencyList.get(circleCount + 2).add(i);\n                adjacencyList.get(i).add(circleCount + 2);\n            }\n            if (centerY <= radius) {\n                adjacencyList.get(circleCount + 1).add(i);\n                adjacencyList.get(i).add(circleCount + 1);\n            }\n            if (Y - centerY <= radius) {\n                adjacencyList.get(circleCount + 3).add(i);\n                adjacencyList.get(i).add(circleCount + 3);\n            }\n            for (int j = i + 1; j < circleCount; j++) {\n                int[] otherCircle = circleDataList.get(j);\n                int centerX2 = otherCircle[0], centerY2 = otherCircle[1], radius2 = otherCircle[2];\n                double distance = Math.sqrt(Math.pow(centerX - centerX2, 2) + Math.pow(centerY - centerY2, 2));\n                int radiusSum = radius + radius2;\n                if (radiusSum >= distance) {\n                    adjacencyList.get(i).add(j);\n                    adjacencyList.get(j).add(i);\n                }\n            }\n        }\n        \n        boolean isPathBlocked = false;\n        isPathBlocked = bfs(adjacencyList, circleCount, circleCount + 1, circleCount + 2, circleCount + 4);\n        isPathBlocked = isPathBlocked || bfs(adjacencyList, circleCount + 3, circleCount + 2, circleCount + 1, circleCount + 4);\n        \n        return !isPathBlocked;\n    }\n}\n",
    "submit_ts": "1722136621",
    "subm_id": "1335740108"
}