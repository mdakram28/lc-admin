{
    "username": "NinjaSatish",
    "submission": "class Solution {\npublic:\n    #define ll long long\n    const int MOD = 1e9 + 9;\n    const int BASE = 31;\n    \n    ll mpow(ll a, ll b){\n        if(b == 0) return 1ll;\n        ll ans = 1 ;\n        while(b > 0){\n            if(b & 1) ans = ans * a % MOD ;\n            a = a * a % MOD ;\n            b /= 2;\n        }\n        return ans;\n    }\n    \n    ll computeHash(const string &s) {\n        long long hash = 0;\n        long long basePower = 1;\n        for (char c : s) {\n            hash = (hash + (c - 'a' + 1) * basePower) % MOD;\n            basePower = (basePower * BASE) % MOD;\n        }\n        return hash;\n    }\n    \n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        \n        ll n = target.size();\n        \n        unordered_map<ll, ll> wordMap; // hash -> cost\n        set<int> si ;\n        // Compute the hash for each word and store them in a map\n        for (ll i = 0; i < words.size(); ++i) {\n            si.insert(words[i].size());\n            ll hash = computeHash(words[i]);\n            if (wordMap.find(hash) == wordMap.end() || wordMap[hash] > costs[i]) {\n                wordMap[hash] = costs[i];\n                // cout << words[i] << ' '<< hash << endl;\n            }\n        }\n        \n        vector<int> sizes(si.begin(), si.end()) ;\n\n        // Precompute the hash for each prefix of the target\n        vector<long long> prefixHash(n + 1, 0);\n        vector<long long> basePowers(n + 1, 1), inv(n + 1, 1);\n\n        for (ll i = 1; i <= n; ++i) {\n            basePowers[i] = (basePowers[i - 1] * BASE) % MOD;\n            prefixHash[i] = (prefixHash[i - 1] + (target[i - 1] - 'a' + 1) * basePowers[i]) % MOD;\n            inv[i] = mpow(basePowers[i], MOD-2);\n            // cout << prefixHash[i] << ' ' ;\n        }\n        // cout << endl;\n        \n        vector<ll> dp(n + 1, INT_MAX);\n        dp[0] = 0 ;\n\n        for (ll i = 1; i <= n; ++i) {\n            for (ll j : sizes) {\n                j = i - j ;\n                if(j < 0) break;\n                long long currentHash = (prefixHash[i] - prefixHash[j] + MOD) % MOD;\n                currentHash = currentHash * inv[j + 1] % MOD;\n                // cout << i << ' ' << j << \" = \" << currentHash  << endl;\n                if (wordMap.count(currentHash)) {\n                    // cout << i << ' ' << j << endl;\n                    dp[i] = min(dp[i], dp[j] + wordMap[currentHash]);\n                }\n            }\n        }\n\n        return dp[n] == INT_MAX ? -1 : dp[n];\n    }\n};",
    "submit_ts": "1720322756",
    "subm_id": "1312358295"
}