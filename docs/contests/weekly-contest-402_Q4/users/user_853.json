{
    "username": "shchen527",
    "submission": "class Solution {\npublic:\n    void build(vector<int>& tree, int pos, int tl, int tr, vector<int>& nums) {\n        if (tl > tr)\n            return;\n\n        if (tl == tr) {\n            if (tl > 0 && tl < nums.size() - 1) {\n                if (nums[tl - 1] < nums[tl] && nums[tl] > nums[tl + 1]) {\n                    tree[pos] = 1;\n                }\n            }\n\n            return;\n        }\n\n        int tm = (tl + tr) / 2;\n        int left = 2 * pos;\n        int right = 2 * pos + 1;\n\n        build(tree, left, tl, tm, nums);\n        build(tree, right, tm + 1, tr, nums);\n\n        tree[pos] = tree[left] + tree[right];\n    }\n\n    void update(vector<int>& tree, int pos, int tl, int tr, vector<int>& nums, int idx, int val) {\n        if (tl > tr)\n            return;\n\n        if (tl == tr) {\n            nums[idx] = val;\n            // if (idx - 1 >= 0 && nums[idx - 1] <= nums[idx])\n            //     tree[pos - 1] = 0;\n            // if (idx  = 1 < nums.size() && nums[idx + 1] <= nums[idx])\n            //     tree[idx + 1] = 0;\n\n            if (idx > 0 && idx < nums.size() - 1) {\n                if (nums[idx - 1] < nums[idx] && nums[idx] > nums[idx + 1]) {\n                    tree[pos] = 1;\n                }\n                else {\n                    tree[pos] = 0;\n                }\n            }\n\n            return;\n        }\n\n        int tm = (tl + tr) / 2;\n        int left = 2 * pos;\n        int right = 2 * pos + 1;\n\n        if (idx <= tm) {\n            update(tree, left, tl, tm, nums, idx, val);\n        }\n        else {\n            update(tree, right, tm + 1, tr, nums, idx, val);\n        }\n\n        tree[pos] = tree[left] + tree[right];\n    }\n\n    int get(vector<int>& tree, int pos, int tl, int tr, int l, int r) {\n        if (tl > tr || r < tl || l > tr)\n            return 0;\n\n        if (tl == tr || (tl == l && tr == r))\n            return tree[pos];\n\n        int tm = (tl + tr) / 2;\n        int left = 2 * pos;\n        int right = left + 1;\n\n\n        int tmp1 = get(tree, left, tl, tm, l, min(tm, r));\n        int tmp2 = get(tree, right, tm + 1, tr, max(tm + 1, l), r);\n        return tmp1 + tmp2;\n    }\n\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> tree(4*n + 1, 0);\n\n        //vector<int> tnums(n, 0);\n        // for (int i = 0; i < n; ++i) {\n        //     update(tree, 1, 0, n - 1, nums, i, nums[i]);\n        // }\n\n        build(tree, 1, 0, n - 1, nums);\n\n        vector<int> ans;\n        for (const auto& q : queries) {\n            if (q[0] == 1) {\n                int tmp = get(tree, 1, 0, n - 1, q[1] + 1, q[2] - 1);\n                ans.push_back(tmp);\n            }\n            else {\n                update(tree, 1, 0, n - 1, nums, q[1], q[2]);\n                if (q[1] - 1 >= 0)\n                    update(tree, 1, 0, n - 1, nums, q[1] - 1, nums[q[1] - 1]);\n                if (q[1] + 1 < n)\n                    update(tree, 1, 0, n - 1, nums, q[1] + 1, nums[q[1] + 1]);\n            }\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": 1718508025.0
}