{
    "username": "Priyansh Sharma",
    "submission": "\n\n#include <vector>\n#include <string>\n#include <cstring>\n\nclass Solution {\n    int memo[100001][10];\n    int power[100001];\n\n    bool canForm(int left, int right, int currentMod, int divisor) {\n        if (left > right) return currentMod == 0;\n        currentMod %= divisor;\n        int &result = memo[left][currentMod];\n        if (result != -1) return result;\n        result = false;\n        for (int digit = 9; digit >= 0; digit--) {\n            int newMod = (1LL * power[left] * digit + 1LL * power[right] * digit + currentMod) % divisor;\n            if (left == right) newMod = (1LL * power[left] * digit + currentMod) % divisor;\n            if (canForm(left + 1, right - 1, newMod, divisor)) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    void buildPalindrome(int left, int right, int currentMod, int divisor, std::string &result) {\n        currentMod %= divisor;\n        while (left <= right) {\n            for (int digit = 9; digit >= 0; digit--) {\n                int newMod = (1LL * power[left] * digit + 1LL * power[right] * digit + currentMod) % divisor;\n                if (left == right) newMod = (1LL * power[left] * digit + currentMod) % divisor;\n                if (canForm(left + 1, right - 1, newMod, divisor)) {\n                    result[left] = result[right] = '0' + digit;\n                    left++;\n                    right--;\n                    currentMod = newMod;\n                    break;\n                }\n            }\n        }\n    }\n\npublic:\n    std::string largestPalindrome(int length, int divisor) {\n        memset(memo, -1, sizeof(memo));\n        power[length - 1] = 1;\n        for (int i = length - 2; i >= 0; i--) {\n            power[i] = (1LL * power[i + 1] * 10) % divisor;\n        }\n\n        int firstDigit = -1;\n        int initialMod;\n        for (int digit = 9; digit > 0; digit--) {\n            int newMod = (1LL * power[0] * digit + 1LL * power[length - 1] * digit) % divisor;\n            if (length == 1) newMod = (1LL * power[0] * digit) % divisor;\n            if (canForm(1, length - 2, newMod, divisor)) {\n                firstDigit = digit;\n                initialMod = newMod;\n                break;\n            }\n        }\n\n        if (firstDigit == -1) return \"-1\";\n\n        std::string result(length, ' ');\n        result[0] = result[length - 1] = '0' + firstDigit;\n        buildPalindrome(1, length - 2, initialMod, divisor, result);\n        return result;\n    }\n};\n",
    "submit_ts": "1723952622",
    "subm_id": "1359800604"
}