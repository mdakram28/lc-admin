{
    "username": "zanj0",
    "submission": "/*\n\tJAI JAGANNATH!\n*/\n//@Author : zanj0\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ff              first\n#define ss              second\n#define pb              push_back\n#define MOD             1000000007\n#define inf             1e18\n\ntypedef long long int lli;\n\ntemplate<class T>\nstruct Segtree {\n\tvector<T>st;\n\tint n;\n\tT identity_element;\n\tSegtree(int n, T identity_element)\n\t{\n\t\tthis->n = n;\n\t\tthis->identity_element = identity_element;\n\t\tst.assign(4 * n, identity_element);\n\t}\n\tT combine(T l, T r)\n\t{\n\t\t// change this function as required.\n\n\t\treturn l & r;\n\t}\n\tvoid buildUtil(int v, int tl, int tr, vector<T>&a)\n\t{\n\t\tif (tl == tr)\n\t\t{\n\t\t\tst[v] = a[tl];\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr) >> 1;\n\t\tbuildUtil(2 * v + 1, tl, tm, a);\n\t\tbuildUtil(2 * v + 2, tm + 1, tr, a);\n\t\tst[v] = combine(st[2 * v + 1], st[2 * v + 2]);\n\t}\n\tT queryUtil(int v, int tl, int tr, int l, int r)\n\t{\n\t\tif (l > r)return identity_element;\n\t\tif (r < tl or l > tr)\n\t\t{\n\t\t\treturn identity_element;\n\t\t}\n\t\tif (tl >= l and tr <= r)\n\t\t{\n\t\t\treturn st[v];\n\t\t}\n\t\tint tm = (tl + tr) >> 1;\n\t\treturn combine(queryUtil(2 * v + 1, tl, tm, l, r), queryUtil(2 * v + 2, tm + 1, tr, l, r));\n\t}\n\tT apply(T curr, T val)\n\t{\n\t\t// change this function if update is of some other kind.\n\t\tT ans = curr;\n\t\tans = val;\n\t\treturn ans;\n\t}\n\tvoid updateUtil(int v, int tl, int tr, int ind, T val)\n\t{\n\t\tif (tl == tr)\n\t\t{\n\t\t\tst[v] = apply(st[v], val);\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr) >> 1;\n\t\tif (ind <= tm)\n\t\t{\n\t\t\tupdateUtil(2 * v + 1, tl, tm, ind, val);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdateUtil(2 * v + 2, tm + 1, tr, ind, val);\n\t\t}\n\t\tst[v] = combine(st[2 * v + 1], st[2 * v + 2]);\n\t}\n\n\n\tvoid build(vector<T>a)\n\t{\n\n\t\tbuildUtil(0, 0, n - 1, a);\n\t}\n\tT query(int l, int r)\n\t{\n\t\treturn queryUtil(0, 0, n - 1, l, r);\n\t}\n\tvoid update(int ind, T val)\n\t{\n\t\tupdateUtil(0, 0, n - 1, ind, val);\n\t}\n};\n\nclass Solution {\npublic:\n\tlli F(lli x) {\n\t\treturn (x * (x + 1)) / 2;\n\t}\n\tlong long countSubarrays(vector<int>& nums, int k) {\n\t\tlli ret = 0;\n\t\tlli n = nums.size();\n\t\tSegtree segment_tree = Segtree<int>(n, (1 << 30) - 1);\n\t\tsegment_tree.build(nums);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif ((nums[i] & k) != k) continue;\n\t\t\tlli len = 0;\n\t\t\tlli low = i, high = n - 1;\n\t\t\tlli left_len = 0, right_len = INT_MIN;\n\t\t\twhile (low <= high) {\n\t\t\t\tlli mid = low + (high - low) / 2;\n\t\t\t\tlli value = segment_tree.query(i, mid);\n\t\t\t\t// cout << i << \" \" << mid << \" \" << value << endl;\n\t\t\t\tif (value > k) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else if (value < k) {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\tright_len = mid;\n\t\t\t\t\t\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlow = i, high = n - 1;\n\t\t\twhile (low <= high) {\n\t\t\t\tlli mid = low + (high - low) / 2;\n\t\t\t\tlli value = segment_tree.query(i, mid);\n\t\t\t\t// cout << i << \" \" << mid << \" \" << value << endl;\n\t\t\t\tif (value > k) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else if (value < k) {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\tleft_len = mid;\n\t\t\t\t\t\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cout << i << \" \" << left_len << \" \" << right_len  << endl;\n\t\t\tif (right_len >= left_len)\n\t\t\t\tret += right_len - left_len + 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n};\n\n\n#ifdef LOCAL\nint main() {\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tcout << \"Compiled!\" << endl;\n}\n#endif",
    "submit_ts": "1720278241",
    "subm_id": "1311700589"
}