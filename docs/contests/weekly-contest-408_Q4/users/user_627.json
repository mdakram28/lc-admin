{
    "username": "chentodd2012",
    "submission": "class Solution \n{\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) \n    {\n        int n = circles.size();\n        std::vector<std::vector<int>> adjList(n);\n        \n        for (int i = 0; i < n; ++i)\n        {\n            long long x1 = circles[i][0];\n            long long y1 = circles[i][1];\n            long long r1 = circles[i][2];\n            \n            for (int j = i + 1; j < n; ++j)\n            {\n                long long x2 = circles[j][0];\n                long long y2 = circles[j][1];\n                long long r2 = circles[j][2];\n                \n                long long dist = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n                long long radiusVal = (r1 + r2) * (r1 + r2);\n                if (dist <= radiusVal)\n                {\n                    adjList[i].push_back(j);\n                    adjList[j].push_back(i);\n                }\n            }\n        }\n        \n        for (int i = 0; i < n; ++i)\n        {\n            if (visited_.find(i) != visited_.end())\n                continue;\n            \n            connectedCircles_.clear();\n            dfs(adjList, i);\n            \n            visited_.insert(connectedCircles_.begin(), connectedCircles_.end());\n            if (isBlocking(circles, X, Y))\n                return false;\n        }\n        \n        return true;\n    }\n    \nprivate:\n    void dfs(std::vector<std::vector<int>>& adjList, int curr)\n    {\n        if (connectedCircles_.find(curr) != connectedCircles_.end())\n            return;\n        \n        connectedCircles_.insert(curr);\n        for (auto next : adjList[curr])\n            dfs(adjList, next);\n    }\n    \n    bool isBlocking(std::vector<std::vector<int>>& circles, int X, int Y)\n    {\n        int width = X;\n        int height = Y;\n        \n        int minLeft = INT_MAX, maxRight = INT_MIN;\n        int maxTop = INT_MIN, minBottom = INT_MAX;\n        for (auto circIndex : connectedCircles_)\n        {\n            int x = circles[circIndex][0];\n            int y = circles[circIndex][1];\n            int r = circles[circIndex][2];\n            \n            minLeft = std::min(minLeft, x - r);\n            maxRight = std::max(maxRight, x + r);\n            \n            maxTop = std::max(maxTop, y + r);\n            minBottom = std::min(minBottom, y - r);\n        }\n        \n        if (minLeft <= 0 && maxRight >= X)\n            return true;\n        \n        if (minBottom <= 0 && maxTop >= Y)\n            return true;\n        \n        if (maxRight >= X && maxTop >= Y)\n            return true;\n        \n        if (minLeft <= 0 && minBottom <= 0)\n            return true;\n        \n        return false;\n    }\n    \nprivate:\n    std::unordered_set<int> visited_;\n    std::unordered_set<int> connectedCircles_;\n};\n\n// 5\n// 11\n// [[2,2,2],[3,2,1],[4,8,1],[3,7,1],[3,7,1],[4,5,1],[4,8,1]]",
    "submit_ts": "1722137787",
    "subm_id": "1335773711"
}