{
    "username": "nyp00n",
    "submission": "class Solution {\npublic:\n\n\n    int minChanges(vector<int>& nums, int k) {\n      int n = nums.size();\n        unordered_map<int, int> freq;\n        vector<int> diffs(n / 2);\n\n        // Compute all differences and their frequencies\n        for (int i = 0; i < n / 2; ++i) {\n            diffs[i] = abs(nums[i] - nums[n - i - 1]);\n            freq[diffs[i]]++;\n        }\n\n        // Priority queue to keep top 100 frequent differences\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\n\n        for (auto& [diff, count] : freq) {\n            minHeap.push({count, diff});\n            if (minHeap.size() > 100) {\n                minHeap.pop(); // Maintain size at 100\n            }\n        }\n\n        // Convert heap to a more manageable form\n        vector<int> topDiffs;\n       topDiffs.push_back(0);\n        while (!minHeap.empty()) {\n            topDiffs.push_back(minHeap.top().second);\n            minHeap.pop();\n        }\n\n        int minChanges = INT_MAX;\n\n        // Process only the top 100 differences\n        for (auto& x: topDiffs) {\n            int changes = 0;\n\n            for (int i = 0; i < n / 2; ++i) {\n                if (diffs[i] != x) {\n                    if ((x + nums[i]) <= k || (nums[n - i - 1] + x) <= k ||\n                        (nums[i] - x) >= 0 || (nums[n - i - 1] - x) >= 0) {\n                        changes += 1; // Possible with one change\n                    } else {\n                        changes += 2; // Needs two changes\n                    }\n                }\n            }\n\n            minChanges = min(minChanges, changes);\n        }\n\n        return minChanges;\n    }\n};",
    "submit_ts": "1721489301",
    "subm_id": "1327449191"
}