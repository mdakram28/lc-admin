{
    "username": "Ir1descent",
    "submission": "import java.util.*;\nclass Solution {\n    public int[] shortestDistanceAfterQueries(int n, int[][] queries) {\n        TreeMap<Integer, Integer> intervalMap = new TreeMap<>();\n        intervalMap.put(0, n - 1);\n        int[] res = new int[queries.length];\n        int cur = n - 1;\n        for(int i = 0; i < queries.length; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            if(r - l <= 1) {\n                res[i] = cur;\n                continue;\n            }\n            int removedCount = remove(intervalMap, l + 1, r - 1);\n            cur -= removedCount;\n            res[i] = cur;\n            //System.out.println(\"Removed count: \" + removedCount);\n        }\n        return res;\n    }\n\n    public int remove(TreeMap<Integer, Integer> intervalMap, int l, int r) {\n        // Find the entry with the greatest key less than or equal to l\n        Map.Entry<Integer, Integer> entry = intervalMap.floorEntry(l);\n\n        // Start from the entry found or the first entry in the map\n        Iterator<Map.Entry<Integer, Integer>> iterator = (entry != null ? \n                                                          intervalMap.tailMap(entry.getKey()).entrySet().iterator() : \n                                                          intervalMap.entrySet().iterator());\n\n        List<Map.Entry<Integer, Integer>> toRemove = new ArrayList<>();\n        List<Map.Entry<Integer, Integer>> toAdd = new ArrayList<>();\n\n        int removedCount = 0;\n\n        while (iterator.hasNext()) {\n            Map.Entry<Integer, Integer> currentEntry = iterator.next();\n            int start = currentEntry.getKey();\n            int end = currentEntry.getValue();\n\n            if (start > r) {\n                // No further intervals can intersect [l, r]\n                break;\n            }\n\n            if (end >= l) {\n                // There is an intersection\n                toRemove.add(currentEntry);\n\n                // Calculate and accumulate the removed count\n                int removalStart = Math.max(start, l);\n                int removalEnd = Math.min(end, r);\n                removedCount += removalEnd - removalStart + 1;\n\n                // Add new intervals for non-overlapping parts\n                if (start < l) {\n                    toAdd.add(new AbstractMap.SimpleEntry<>(start, l - 1));\n                }\n                if (end > r) {\n                    toAdd.add(new AbstractMap.SimpleEntry<>(r + 1, end));\n                }\n            }\n        }\n\n        // Remove intersecting intervals\n        for (Map.Entry<Integer, Integer> e : toRemove) {\n            intervalMap.remove(e.getKey());\n        }\n\n        // Add new non-overlapping intervals\n        for (Map.Entry<Integer, Integer> e : toAdd) {\n            intervalMap.put(e.getKey(), e.getValue());\n        }\n\n        return removedCount;\n    }\n}",
    "submit_ts": "1722741285",
    "subm_id": "1343741220"
}