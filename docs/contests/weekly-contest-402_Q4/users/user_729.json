{
    "username": "_tim",
    "submission": "struct Mod {\n    int assign = -1;\n\n    bool operator==(const Mod&) const = default;\n};\n\nstruct Calc {\n    int cnt = 0;\n    int l1 = 0;\n    int l2 = 0;\n    int r2 = 0;\n    int r1 = 0;\n    int len = 0;\n};\n\nstruct Segtree {\n    int size;\n    vector<Mod> mods;\n    vector<Calc> calcs;\n    // Should not affect the result when merging with another Calc\n    Mod NEUTRAL_MOD = {-1};\n    // Should not affect the result when merging with another Calc\n    Calc NEUTRAL_CALC = {0, 0, 0, 0, 0, 0};\n\n    Calc mod_op(const Calc& a, const Mod& b) {\n        if (b == NEUTRAL_MOD) {\n            return Calc{a};\n        }\n        return {0, b.assign, b.assign, b.assign, b.assign, 1};\n    }\n\n    // Merge two segments\n    Calc calc_op(const Calc& a, const Calc& b) {\n        if (a.len == 0) return Calc{b};\n        if (b.len == 0) return Calc{a};\n        Calc answer = {a.cnt + b.cnt, a.l1, a.l2, b.r2, b.r1, a.len + b.len};\n        if (a.len <= 1) answer.l2 = b.l1;\n        else if (a.r1 > a.r2 && a.r1 > b.l1) {\n            answer.cnt++;\n        }\n        if (b.len <= 1) answer.r2 = a.r1;\n        else if (b.l1 > b.l2 && b.l1 > a.r1) {\n            answer.cnt++;\n        }\n        return answer;\n    }\n\n    void apply_mod_op(Calc& a, const Mod& b) {\n        a = mod_op(a, b); \n    }\n    \n    void apply_mod_op(Mod& a, const Mod& b) {\n        if (b != NEUTRAL_MOD) {\n            a.assign = b.assign;\n        }\n    }\n\n    void build(int x, int lx, int rx, const vector<Calc>& a) {\n        if (rx == lx + 1) {\n            if (lx < (int)a.size()) calcs[x] = a[lx];\n            return;\n        }\n        int m = midpoint(lx, rx);\n        build(2 * x + 1, lx, m, a);\n        build(2 * x + 2, m, rx, a);\n        calcs[x] = calc_op(calcs[2 * x + 1], calcs[2 * x + 2]);\n    }\n\n    void init(int n, const vector<Calc>& a) {\n        size = 1;\n        while (size < n) size *= 2;\n        mods.assign(2 * size, NEUTRAL_MOD);\n        calcs.resize(2 * size);\n        build(0, 0, size, a);\n    }\n\n    void modify(int l, int r, const Mod& v, int x, int lx, int rx) {\n        if (r <= lx || l >= rx) return;\n        if (lx >= l && rx <= r) {\n            apply_mod_op(mods[x], v);\n            apply_mod_op(calcs[x], v);\n            return;\n        }\n        int m = midpoint(lx, rx);\n        modify(l, r, v, 2 * x + 1, lx, m);\n        modify(l, r, v, 2 * x + 2, m, rx);\n        calcs[x] = calc_op(calcs[2 * x + 1], calcs[2 * x + 2]);\n        apply_mod_op(calcs[x], mods[x]);\n    }\n\n    void modify(int l, int r, const Mod& v) { modify(l, r, v, 0, 0, size); }\n\n    Calc calc(int l, int r, int x, int lx, int rx) {\n        if (r <= lx || l >= rx) return NEUTRAL_CALC;\n        if (lx >= l && rx <= r) {\n            return calcs[x];\n        }\n        int m = midpoint(lx, rx);\n        auto m1 = calc(l, r, 2 * x + 1, lx, m);\n        auto m2 = calc(l, r, 2 * x + 2, m, rx);\n        auto res = calc_op(m1, m2);\n        apply_mod_op(res, mods[x]);\n        return res;\n    }\n\n    Calc calc(int l, int r) { return calc(l, r, 0, 0, size); }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& qs) {\n        Segtree segtree;\n        int n = (int)a.size();\n        vector<Calc> vc(n);\n        for (int i = 0; i < n; i++) {\n            vc[i] = {0, a[i], a[i], a[i], a[i], 1};\n        }\n        segtree.init(n, vc); \n        int m = (int)qs.size();\n        vector<int> answer;\n        for (int i = 0; i < m; i++) {\n            if (qs[i][0] == 1) {\n                answer.push_back(segtree.calc(qs[i][1], qs[i][2] + 1).cnt);\n            } else {\n                segtree.modify(qs[i][1], qs[i][1] + 1, {qs[i][2]});\n            }\n        }\n        return answer;\n    }\n};",
    "submit_ts": 1718508636.0
}