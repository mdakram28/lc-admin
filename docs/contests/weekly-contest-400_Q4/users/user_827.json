{
    "username": "coder42032",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define lb long double\n#define ull unsigned long long\n#define pb push_back\n#define qq endl\n#define fori(i,k,n) for(int i=int(k);i<int(n);i++)\n#define revfor(i,n,k) for(int i=int(n);i>=int(k);i--)\n#define vi vector<int>\n#define vl vector<ll>\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define srt(arr) sort(arr.begin(),arr.end())\n#define rsrt(arr) sort(arr.rbegin(),arr.rend())\n#define print(arr) for(int i=0;i<arr.size();i++){cout<<arr[i]<<\" \";}\n#define pri(x) cout<<(int)x<<endl\nint mod = 1000000007;\nint N = 1000000;\n\nclass Solution {\npublic:\n    void build(int ind,int low,int high, vector<int>&arr,vector<int>&seg){\n            if(low==high){\n                seg[ind]=arr[low];\n                return;\n            }\n            int mid = (low+high)/2;\n            build(2*ind+1,low,mid,arr,seg);\n            build(2*ind+2,mid+1,high,arr,seg);\n            seg[ind] = (seg[2*ind+1]&seg[2*ind+2]);\n        }\n\n        int query(int ind,int low,int high,int l,int r,vector<int>&seg){\n            //no overlap\n            if(high<l || r<low){\n                return INT_MAX;\n            }\n            //complete overlap\n            if(low>=l && high<=r){\n                return seg[ind];\n            }\n            //partial overlap\n            int mid = (low+high)/2;\n            int left = query(2*ind+1,low,mid,l,r,seg);\n            int right = query(2*ind+2,mid+1,high,l,r,seg);\n            return (left&right);\n        }\n\n    int minimumDifference(vector<int>& arr, int k) {\n        int n = arr.size();\n        vector<int>seg(4*n);\n            build(0,0,n-1,arr,seg);\n            int ans = INT_MAX;\n            stack<int>st;\n            st.push(0);\n            if(st.size()==0)return 0;\n            if(st.size()==0)return 0;if(st.size()==0)return 0;\n            for (int i = 0; i < n; i++) {\n                int left = i - 1, right = n - 1, mid;\n                while (right - left > 1) {\n                    mid = left+(right-left) / 2;\n                    if (query(0,0,n-1,i, mid,seg) >= k){\n                            left = mid;\n                    }else{\n                            right = mid;\n                    }\n                }\n                if (left != i - 1)ans = min(ans, abs(query(0,0,n-1,i, left,seg) - k));\n                ans = min(ans, abs(k - query(0,0,n-1,i, right,seg)));\n            }\n            return ans;\n            if(st.size()==0)return 0;if(st.size()==0)return 0;if(st.size()==0)return 0;\n    }\n};",
    "submit_ts": 1717299747.0
}