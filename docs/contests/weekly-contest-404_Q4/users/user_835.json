{
    "username": "Ayush_goyal_nitkkr",
    "submission": "class Solution {\npublic:\n    vector<vector<int>> tree1, tree2;\n\n    pair<int, int> bfs(int startNode, const vector<vector<int>>& tree) {\n        auto bfsLambda = [](int startNode, const vector<vector<int>>& tree) {\n            int numNodes = tree.size();\n            vector<int> distances(numNodes, -1);\n            queue<int> nodeQueue;\n            nodeQueue.push(startNode);\n            distances[startNode] = 0;\n            int maxDistance = 0, farthestNode = startNode;\n\n            while (!nodeQueue.empty()) {\n                int currentNode = nodeQueue.front();\n                nodeQueue.pop();\n                for (int neighbor : tree[currentNode]) {\n                    if (distances[neighbor] == -1) {\n                        distances[neighbor] = distances[currentNode] + 1;\n                        if (distances[neighbor] > maxDistance) {\n                            maxDistance = distances[neighbor];\n                            farthestNode = neighbor;\n                        }\n                        nodeQueue.push(neighbor);\n                    }\n                }\n            }\n\n            return make_pair(farthestNode, maxDistance);\n        };\n\n        return bfsLambda(startNode, tree);\n    }\n\n    int calculateTreeDiameter(const vector<vector<int>>& tree) {\n        auto bfsLambda = [&](int startNode, const vector<vector<int>>& tree) {\n            return bfs(startNode, tree);\n        };\n\n        auto [farthestNode, _] = bfsLambda(0, tree);\n        auto [otherEndNode, diameter] = bfsLambda(farthestNode, tree);\n        return diameter;\n    }\n\n    void buildTree(const vector<vector<int>>& edges, vector<vector<int>>& tree) {\n        auto buildTreeLambda = [](const vector<vector<int>>& edges, vector<vector<int>>& tree) {\n            for (const auto& edge : edges) {\n                tree[edge[0]].push_back(edge[1]);\n                tree[edge[1]].push_back(edge[0]);\n            }\n        };\n\n        buildTreeLambda(edges, tree);\n    }\n\n    int calculateCombinedDiameter(int diameter1, int diameter2) {\n        auto halfDiameter = [](int diameter) { return (diameter + 1) / 2; };\n        return halfDiameter(diameter1) + halfDiameter(diameter2) + 1;\n    }\n\n    int minimumDiameterAfterMerge(const vector<vector<int>>& edges1, const vector<vector<int>>& edges2) {\n        int numNodes1 = edges1.size() + 1;\n        int numNodes2 = edges2.size() + 1;\n        tree1.resize(numNodes1);\n        tree2.resize(numNodes2);\n\n        buildTree(edges1, tree1);\n        buildTree(edges2, tree2);\n\n        int tree1Diameter = calculateTreeDiameter(tree1);\n        int tree2Diameter = calculateTreeDiameter(tree2);\n\n        int combinedDiameter = calculateCombinedDiameter(tree1Diameter, tree2Diameter);\n        return max({combinedDiameter, tree1Diameter, tree2Diameter});\n    }\n};\n",
    "submit_ts": 1719716743.0
}