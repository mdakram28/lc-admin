{
    "username": "sammochen",
    "submission": "\n#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef DEBUG\n#include \"debug.h\"\n#else\n#define debug(...) 1\n#endif\n\nusing ll = long long;\nusing db = long double;\nusing VS = vector<string>;\nusing VLL = vector<ll>;\nusing VVLL = vector<VLL>;\nusing VVVLL = vector<VVLL>;\nusing PLL = pair<ll, ll>;\nusing MLL = map<ll, ll>;\nusing SLL = set<ll>;\nusing QLL = queue<ll>;\nusing SS = stringstream;\n\n#define rep(x, l, u) for (ll x = l; x < u; x++)\n#define rrep(x, l, u) for (ll x = l; x >= u; x--)\n#define fe(x, a) for (auto x : a)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define mst(x, v) memset(x, v, sizeof(x))\n#define sz(x) (ll) x.size()\n\n#define umap unordered_map\n#define uset unordered_set\n#define mset multiset\n\n// clang-format off\n\nll ob(ll i, ll n) { return i < 0 || i >= n; }\nll tp(ll x) { return ( 1LL << x ); }\nll rup(ll a, ll b) { return a % b ? a/b + 1 : a/b; }\nll sign(ll x) {\treturn x == 0 ? 0 : x / abs(x); }\nvoid makemod(ll& x, ll m) { x %= m; if (x < 0) { x += m; } }\nll getmod(ll x, ll m) { makemod(x, m); return x; }\nll powmod(ll a, ll b, ll m) { if (b == 0) return 1; ll h = powmod(a, b/2, m); ll ans = h*h%m; return b%2 ? ans*a%m : ans; }\nll invmod(ll a, ll m) { return powmod(a, m - 2, m); }\nvoid inll(ll& x) { scanf(\"%lld\", &x); }\n\ntemplate <typename A, typename B> bool upmin(A& x, B v) { if (v >= x) return false; return x = v, true; }\ntemplate <typename A, typename B> bool upmax(A& x, B v) { if (v <= x) return false; return x = v, true; }\n// clang-format on\n\nconst VLL di = {0, 0, 1, -1, 1, -1, 1, -1}, dj = {1, -1, 0, 0, -1, -1, 1, 1};\nconst ll inf = 1e18;\nconst ll mod = 1e9 + 7;\nconst string vowels = \"aeiou\";\nll isvowel(char c) {\n    c = tolower(c);\n    return vowels.find(c) != string::npos;\n}\n\nclass Solution {\npublic:\n    ll ans = inf;\n    ll k;\n\n    void updateAns(ll cand) {\n        upmin(ans, abs(k - cand));\n    }\n\n    int minimumDifference(vector<int>& A, int k) {  // !\n        ll n = A.size();\n        this->k = k;\n\n        VVLL pre(n + 1, VLL(32));\n        rep(i, 0, n) {\n            rep(j, 0, 32) {\n                pre[i + 1][j] = pre[i][j] + ((A[i] & tp(j)) ? 1 : 0);\n            }\n        }\n\n        auto getAnd = [&](ll L, ll R) {\n            ll ans = 0;\n            rep(j, 0, 32) {\n                if (pre[R + 1][j] - pre[L][j] == (R - L + 1)) {\n                    ans |= tp(j);\n                }\n            }\n            return ans;\n        };\n\n        ll L = 0, curAnd = A[0];\n        updateAns(curAnd);\n\n        rep(R, 1, n) {\n            ll cur = getAnd(L, R);\n            updateAns(cur);\n\n            while (cur > k && L != R) {\n                L++;\n                cur = getAnd(L, R);\n                updateAns(cur);\n            }\n        }\n\n        L = 0;\n        curAnd = A[0];\n\n        rep(R, 1, n) {\n            ll cur = getAnd(L, R);\n            updateAns(cur);\n\n            while (cur < k && L != R) {\n                L++;\n                cur = getAnd(L, R);\n                updateAns(cur);\n            }\n        }\n        return ans;\n    }\n};\n",
    "submit_ts": 1717296450.0
}