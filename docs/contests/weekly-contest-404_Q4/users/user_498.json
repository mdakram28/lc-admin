{
    "username": "insomniacat",
    "submission": "const int N = 1e6;\nclass Solution {\n\n    vector<vector<int>> adj;\n    int v;\n    \n    int treeDiameter(vector<vector<int>>& edges)  {\n        // for(auto& e : edges) {\n        //     cout << e[0] << \"<->\" << e[1] << \" \";\n        // }\n        // cout << endl;\n        \n        adj.clear();\n        v = edges.size() + 1;\n        adj.resize(v);\n        for (auto edge:edges)\n        {\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n\n        auto t1 = BFS(0); \n        auto t2 = BFS(t1.first); \n        return t2.second;        \n    }\n\n    pair<int, int> BFS(int u) \n    { \n        vector<int> dis(v, -1);\n        queue<int> q; \n        q.push(u); \n\n        dis[u] = 0; \n\n        while (!q.empty()) \n        { \n            int t = q.front();       \n            q.pop(); \n\n            for (auto it = adj[t].begin(); it != adj[t].end(); it++) \n            { \n                int v = *it; \n                if (dis[v] == -1) \n                { \n                    q.push(v);   \n                    dis[v] = dis[t] + 1; \n                } \n            } \n        } \n\n        int maxDis = 0; \n        int nodeIdx; \n\n        for (int i = 0; i < v; i++) \n        { \n            if (dis[i] > maxDis) \n            { \n                maxDis = dis[i]; \n                nodeIdx = i; \n            } \n        } \n        return make_pair(nodeIdx, maxDis); \n    } \n    \n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& e) {\n        if(n == 1) {\n            return {0};\n        }\n        // cout << \" findMinHeightTrees n=\" << n << endl;\n        \n        vector<int> degree(n, 0);\n        vector<int> adj[n];\n        for(auto& v : e) {\n            degree[v[0]]++;\n            degree[v[1]]++;\n            adj[v[0]].push_back(v[1]);\n            adj[v[1]].push_back(v[0]);\n        }\n        queue<int> q;\n        vector<int> visited(n, 0);\n        int cnt = n;\n        for(int i = 0; i < n; ++i) {\n            if(degree[i] == 1) {\n                q.push(i);\n                visited[i] = 1;\n            }\n        }\n        while(q.size() && cnt > 2) {\n            cnt -= q.size();\n            for(int l = q.size(); l > 0; --l) {\n                auto f = q.front();\n                q.pop();\n                for(auto next : adj[f]) {\n                    if(!visited[next] && --degree[next] == 1) {\n                        visited[next] = 1;\n                        q.push(next);\n                    }\n                }\n            }\n        }\n        vector<int> ans;\n        while(q.size()) {\n            ans.push_back(q.front());\n            q.pop();\n        }\n        return ans;\n        \n    }\n    \n\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1, m = edges2.size() + 1;\n        auto v1 = findMinHeightTrees(n, edges1), v2 = findMinHeightTrees(m , edges2);\n        \n        // for(int i : v1) {cout << i << \" \";}\n        // for(int i : v2) {cout << i << \" \";}\n        // cout <<\"finish findMinHeightTrees\" << endl;\n        \n        vector<vector<int>> edges;\n        for(auto& v : edges1) {\n            edges.push_back(v);   \n        }\n        for(auto& v : edges2) {\n            int st = v[0] + n, en = v[1] + n;\n            edges.push_back({st, en});\n        }\n        int ans = 0;\n        for(auto st : v1) {\n            for(auto en : v2) {\n                int ren = en + n;\n                edges.push_back({st, ren});\n                int cur = treeDiameter(edges);\n                // cout << \"st=\" << st << \" en=\" << en << \" cur=\" << cur << endl;\n                ans = max(ans, cur);\n                edges.pop_back();\n            }\n        }\n        // cout << treeDiameter(edges1) << \" \" << treeDiameter(edges2) << endl;\n        return ans;\n    }\n};",
    "submit_ts": "1719719467",
    "subm_id": "1304442673"
}