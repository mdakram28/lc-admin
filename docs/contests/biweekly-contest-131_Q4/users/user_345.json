{
    "username": "athensclub",
    "submission": "class Solution {\n    \n//     private static class Node {\n        \n//         public boolean lObs = false;\n//         public boolean rObs = false;\n        \n//         public int from;\n//         public int to;\n        \n//         public Node left;\n//         public Node right;\n        \n//         public Node(int from, int to) {\n//             this.from = from;\n//             this.to = to;\n            \n//             if(from+1 == to) \n//                 return;\n            \n//             int mid = (from + to) / 2;\n//             left = new Node(from, mid);\n//             right = new Node(mid, to);\n//         }\n        \n// //         [0] = maxL, [1] = maxR, [2] = max, [3] lObs, [4] rObs\n//         public int[] findMax(int l, int r){\n//             if(from+1 == to) \n//                 if(from >= l && to <= r)\n//                     return new int[]{1, 1, 1, lObs ? 1 : 0, rObs ? 1 : 0};\n//                 else\n//                     return new int[]{0, 0, 0, 0, 0};\n            \n//            if(l <= left.to && r >= right.from){\n//                int[] a = left.findMax(l, r), b = right.findMax(l, r);\n               \n//            }\n//         }\n        \n//     }\n    \n    // [i] = min obstacle pos with gap i\n     private static class Node {\n        \n        public TreeSet<Integer> poses;\n        public int min;\n        \n        public int from;\n        public int to;\n        \n        public Node left;\n        public Node right;\n        \n        public Node(int from, int to) {\n            this.from = from;\n            this.to = to;\n            min = 1000000;\n            \n            if(from == to) {\n                poses = new TreeSet<>();\n                poses.add(1000000);\n                return;\n            }\n            \n            int mid = (from + to) / 2;\n            left = new Node(from, mid);\n            right = new Node(mid+1, to);\n        }\n        \n        public void update(int idx, int val, boolean add){\n            if(from == to && idx == from){\n                if(add)\n                    poses.add(val);\n                else\n                    poses.remove(val);\n                min = poses.isEmpty() ? 1000000 : poses.first();\n                return;\n            }\n            \n            if(idx <= left.to)\n                left.update(idx, val, add);\n            else\n                right.update(idx, val, add);\n            \n            min = Math.min(left.min, right.min);\n        }\n        \n        public int getMin(int l, int r){\n            if(from >= l && to <= r) return min;\n            else if(to < l || from > r) return 1000000;\n            else return Math.min(left.getMin(l, r), right.getMin(l, r));\n        }\n        \n    }\n    \n    public List<Boolean> getResults(int[][] queries) {\n        int maxN = queries[0][1];\n        for(int[] q : queries) maxN = Math.max(maxN, q[1]);\n        // System.out.println(maxN);\n        maxN++;\n        \n        Node root = new Node(0, maxN+1);\n        root.update(maxN, maxN, true);\n        \n        TreeSet<Integer> obs = new TreeSet<>();\n        obs.add(0);\n        obs.add(maxN);\n        \n        List<Boolean> ans = new ArrayList<>();\n        for(int[] q : queries){\n            if(q[0] == 1){\n                int l = obs.lower(q[1]), r = obs.higher(q[1]);\n                \n                root.update(r-l, r, false);\n                root.update(q[1]-l, q[1], true);\n                root.update(r-q[1], r, true);\n                \n                obs.add(q[1]);\n            }else{\n                int l = obs.lower(q[1]), r = obs.higher(q[1]);\n                if(!obs.contains(q[1])){\n                    root.update(r-l, r, false);\n                    root.update(q[1]-l, q[1], true);\n                    root.update(r-q[1], r, true);\n                }\n                \n                ans.add(root.getMin(q[2], maxN) <= q[1]);\n                \n                if(!obs.contains(q[1])){\n                    root.update(r-l, r, true);\n                    root.update(q[1]-l, q[1], false);\n                    root.update(r-q[1], r, false);\n                }\n            }\n        }\n        \n        return ans;\n    }\n}",
    "submit_ts": 1716651984.0
}