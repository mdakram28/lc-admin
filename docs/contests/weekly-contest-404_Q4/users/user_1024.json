{
    "username": "amuhak",
    "submission": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        // Find the diameter of each tree call them a and b. return a/2 + b/2 + 1\n        List<List<Integer>> tree1 = new ArrayList<>(edges1.length + 1);\n        List<List<Integer>> tree2 = new ArrayList<>(edges2.length + 1);\n        for (int i = 0; i < edges1.length + 1; i++) {\n            tree1.add(new ArrayList<>());\n        }\n        for (int i = 0; i < edges2.length + 1; i++) {\n            tree2.add(new ArrayList<>());\n        }\n        for (int[] ints : edges1) {\n            tree1.get(ints[0]).add(ints[1]);\n            tree1.get(ints[1]).add(ints[0]);\n        }\n        for (int[] ints : edges2) {\n            tree2.get(ints[0]).add(ints[1]);\n            tree2.get(ints[1]).add(ints[0]);\n        }\n        List<Integer> a = bfs(tree1, 0);\n        int diameterA = bfs(tree1, a.getFirst()).get(1);\n        List<Integer> b = bfs(tree2, 0);\n        int diameterB = bfs(tree2, b.getFirst()).get(1);\n        ArrayList<Integer> ans = new ArrayList<>();\n        ans.add(diameterA / 2 + diameterB / 2 + 1);\n        ans.add(diameterA - 1);\n        ans.add(diameterB - 1);\n        return ans.stream().max(Integer::compareTo).get();\n    }\n\n    public List<Integer> bfs(List<List<Integer>> tree, int start) {\n        // return farthest node from start\n        boolean[] visited = new boolean[tree.size()];\n        int depth = 0;\n        int farthest = start;\n        visited[start] = true;\n        List<Integer> queue = new ArrayList<>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            List<Integer> next = new ArrayList<>();\n            for (int node : queue) {\n                for (int neighbor : tree.get(node)) {\n                    if (!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        next.add(neighbor);\n                        farthest = neighbor;\n                    }\n                }\n            }\n            queue = next;\n            depth++;\n        }\n        return List.of(farthest, depth);\n    }\n}",
    "submit_ts": "1719718855",
    "subm_id": "1304427750"
}