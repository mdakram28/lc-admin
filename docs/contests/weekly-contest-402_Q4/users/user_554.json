{
    "username": "981377660LMT",
    "submission": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/bits\"\n\t\"strings\"\n)\n\nfunc countOfPeaks(nums []int, queries [][]int) []int {\n\tarr := NewAscendingSolver(int(len(nums)), func(i int) int { return nums[i] }, func(a, b int) bool { return a < b })\n\tvar res []int\n\tfor _, q := range queries {\n\t\tif q[0] == 1 {\n\t\t\tstart, end := q[1], q[2]+1\n\t\t\tres = append(res, arr.Count(start, end))\n\t\t} else {\n\t\t\tarr.Set(q[1], q[2])\n\t\t}\n\t}\n\treturn res\n}\n\n// \u52a8\u6001bitset\uff0c\u652f\u6301\u5207\u7247\u64cd\u4f5c.\ntype BitSetDynamic struct {\n\tn    int\n\tdata []uint64\n}\n\n// \u5efa\u7acb\u4e00\u4e2a\u5927\u5c0f\u4e3a n \u7684 bitset\uff0c\u521d\u59cb\u503c\u4e3a filledValue.\n// [0,n).\nfunc NewBitsetDynamic(n int, filledValue int) *BitSetDynamic {\n\tif !(filledValue == 0 || filledValue == 1) {\n\t\tpanic(\"filledValue should be 0 or 1\")\n\t}\n\tdata := make([]uint64, n>>6+1)\n\tif filledValue == 1 {\n\t\tfor i := range data {\n\t\t\tdata[i] = ^uint64(0)\n\t\t}\n\t\tif n != 0 {\n\t\t\tdata[len(data)-1] >>= (len(data) << 6) - n\n\t\t}\n\t}\n\treturn &BitSetDynamic{n: n, data: data}\n}\n\nfunc (bs *BitSetDynamic) Add(i int) *BitSetDynamic {\n\tbs.data[i>>6] |= 1 << (i & 63)\n\treturn bs\n}\n\nfunc (bs *BitSetDynamic) Has(i int) bool {\n\treturn bs.data[i>>6]>>(i&63)&1 == 1\n}\n\nfunc (bs *BitSetDynamic) Discard(i int) {\n\tbs.data[i>>6] &^= 1 << (i & 63)\n}\n\nfunc (bs *BitSetDynamic) Flip(i int) {\n\tbs.data[i>>6] ^= 1 << (i & 63)\n}\n\nfunc (bs *BitSetDynamic) AddRange(start, end int) {\n\tmaskL := ^uint64(0) << (start & 63)\n\tmaskR := ^uint64(0) << (end & 63)\n\ti := start >> 6\n\tif i == end>>6 {\n\t\tbs.data[i] |= maskL ^ maskR\n\t\treturn\n\t}\n\tbs.data[i] |= maskL\n\tfor i++; i < end>>6; i++ {\n\t\tbs.data[i] = ^uint64(0)\n\t}\n\tbs.data[i] |= ^maskR\n}\n\nfunc (bs *BitSetDynamic) DiscardRange(start, end int) {\n\tmaskL := ^uint64(0) << (start & 63)\n\tmaskR := ^uint64(0) << (end & 63)\n\ti := start >> 6\n\tif i == end>>6 {\n\t\tbs.data[i] &= ^maskL | maskR\n\t\treturn\n\t}\n\tbs.data[i] &= ^maskL\n\tfor i++; i < end>>6; i++ {\n\t\tbs.data[i] = 0\n\t}\n\tbs.data[i] &= maskR\n}\n\nfunc (bs *BitSetDynamic) FlipRange(start, end int) {\n\tmaskL := ^uint64(0) << (start & 63)\n\tmaskR := ^uint64(0) << (end & 63)\n\ti := start >> 6\n\tif i == end>>6 {\n\t\tbs.data[i] ^= maskL ^ maskR\n\t\treturn\n\t}\n\tbs.data[i] ^= maskL\n\tfor i++; i < end>>6; i++ {\n\t\tbs.data[i] = ^bs.data[i]\n\t}\n\tbs.data[i] ^= ^maskR\n}\n\n// \u5de6\u79fb k \u4f4d (<<k).\n// !\u4e0d\u80fd\u914d\u5408\u5207\u7247\u4f7f\u7528.\u5fc5\u987b\u4fdd\u8bc1lsh\u540e\u7684\u503c\u57df\u4e0d\u8d85\u8fc7\u539f\u503c\u57df.\nfunc (b *BitSetDynamic) Lsh(k int) {\n\tif k == 0 {\n\t\treturn\n\t}\n\tshift, offset := k>>6, k&63\n\tif shift >= len(b.data) {\n\t\tfor i := range b.data {\n\t\t\tb.data[i] = 0\n\t\t}\n\t\treturn\n\t}\n\n\tif offset == 0 {\n\t\tcopy(b.data[shift:], b.data)\n\t} else {\n\t\tfor i := len(b.data) - 1; i > shift; i-- {\n\t\t\tb.data[i] = b.data[i-shift]<<offset | b.data[i-shift-1]>>(64-offset)\n\t\t}\n\t\tb.data[shift] = b.data[0] << offset\n\t}\n\n\tfor i := 0; i < shift; i++ {\n\t\tb.data[i] = 0\n\t}\n}\n\n// \u53f3\u79fb k \u4f4d (>>k).\nfunc (b *BitSetDynamic) Rsh(k int) {\n\tif k == 0 {\n\t\treturn\n\t}\n\tshift, offset := k>>6, k&63\n\tif shift >= len(b.data) {\n\t\tfor i := range b.data {\n\t\t\tb.data[i] = 0\n\t\t}\n\t\treturn\n\t}\n\tlim := len(b.data) - 1 - shift\n\tif offset == 0 {\n\t\tcopy(b.data, b.data[shift:])\n\t} else {\n\t\tfor i := 0; i < lim; i++ {\n\t\t\tb.data[i] = b.data[i+shift]>>offset | b.data[i+shift+1]<<(64-offset)\n\t\t}\n\t\tb.data[lim] = b.data[len(b.data)-1] >> offset\n\t}\n\tfor i := lim + 1; i < len(b.data); i++ {\n\t\tb.data[i] = 0\n\t}\n}\n\nfunc (bs *BitSetDynamic) Fill(zeroOrOne int) {\n\tif zeroOrOne == 0 {\n\t\tfor i := range bs.data {\n\t\t\tbs.data[i] = 0\n\t\t}\n\t} else {\n\t\tfor i := range bs.data {\n\t\t\tbs.data[i] = ^uint64(0)\n\t\t}\n\t\tif bs.n != 0 {\n\t\t\tbs.data[len(bs.data)-1] >>= (len(bs.data) << 6) - bs.n\n\t\t}\n\t}\n}\n\nfunc (bs *BitSetDynamic) Clear() {\n\tfor i := range bs.data {\n\t\tbs.data[i] = 0\n\t}\n}\n\nfunc (bs *BitSetDynamic) OnesCount(start, end int) int {\n\tif start < 0 {\n\t\tstart = 0\n\t}\n\tif end > bs.n {\n\t\tend = bs.n\n\t}\n\tif start == 0 && end == bs.n {\n\t\tres := 0\n\t\tfor _, v := range bs.data {\n\t\t\tres += bits.OnesCount64(v)\n\t\t}\n\t\treturn res\n\t}\n\tpos1 := start >> 6\n\tpos2 := end >> 6\n\tif pos1 == pos2 {\n\t\treturn bits.OnesCount64(bs.data[pos1] & (^uint64(0) << (start & 63)) & ((1 << (end & 63)) - 1))\n\t}\n\tcount := 0\n\tif (start & 63) > 0 {\n\t\tcount += bits.OnesCount64(bs.data[pos1] & (^uint64(0) << (start & 63)))\n\t\tpos1++\n\t}\n\tfor i := pos1; i < pos2; i++ {\n\t\tcount += bits.OnesCount64(bs.data[i])\n\t}\n\tif (end & 63) > 0 {\n\t\tcount += bits.OnesCount64(bs.data[pos2] & ((1 << (end & 63)) - 1))\n\t}\n\treturn count\n}\n\nfunc (bs *BitSetDynamic) AllOne(start, end int) bool {\n\ti := start >> 6\n\tif i == end>>6 {\n\t\tmask := ^uint64(0)<<(start&63) ^ ^uint64(0)<<(end&63)\n\t\treturn (bs.data[i] & mask) == mask\n\t}\n\tmask := ^uint64(0) << (start & 63)\n\tif (bs.data[i] & mask) != mask {\n\t\treturn false\n\t}\n\tfor i++; i < end>>6; i++ {\n\t\tif bs.data[i] != ^uint64(0) {\n\t\t\treturn false\n\t\t}\n\t}\n\tmask = ^uint64(0) << (end & 63)\n\treturn ^(bs.data[end>>6] | mask) == 0\n}\n\nfunc (bs *BitSetDynamic) AllZero(start, end int) bool {\n\ti := start >> 6\n\tif i == end>>6 {\n\t\tmask := ^uint64(0)<<(start&63) ^ ^uint64(0)<<(end&63)\n\t\treturn (bs.data[i] & mask) == 0\n\t}\n\tif (bs.data[i] >> (start & 63)) != 0 {\n\t\treturn false\n\t}\n\tfor i++; i < end>>6; i++ {\n\t\tif bs.data[i] != 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\tmask := ^uint64(0) << (end & 63)\n\treturn (bs.data[end>>6] & ^mask) == 0\n}\n\n// \u8fd4\u56de\u7b2c\u4e00\u4e2a 1 \u7684\u4e0b\u6807\uff0c\u82e5\u4e0d\u5b58\u5728\u5219\u8fd4\u56de-1.\nfunc (bs *BitSetDynamic) IndexOfOne(position int) int {\n\tif position == 0 {\n\t\tfor i, v := range bs.data {\n\t\t\tif v != 0 {\n\t\t\t\treturn i<<6 | bs._lowbit(v)\n\t\t\t}\n\t\t}\n\t\treturn -1\n\t}\n\tfor i := position >> 6; i < len(bs.data); i++ {\n\t\tv := bs.data[i] & (^uint64(0) << (position & 63))\n\t\tif v != 0 {\n\t\t\treturn i<<6 | bs._lowbit(v)\n\t\t}\n\t\tfor i++; i < len(bs.data); i++ {\n\t\t\tif bs.data[i] != 0 {\n\t\t\t\treturn i<<6 | bs._lowbit(bs.data[i])\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n\n// \u8fd4\u56de\u7b2c\u4e00\u4e2a 0 \u7684\u4e0b\u6807\uff0c\u82e5\u4e0d\u5b58\u5728\u5219\u8fd4\u56de-1\u3002\nfunc (bs *BitSetDynamic) IndexOfZero(position int) int {\n\tif position == 0 {\n\t\tfor i, v := range bs.data {\n\t\t\tif v != ^uint64(0) {\n\t\t\t\treturn i<<6 | bs._lowbit(^v)\n\t\t\t}\n\t\t}\n\t\treturn -1\n\t}\n\ti := position >> 6\n\tif i < len(bs.data) {\n\t\tv := bs.data[i]\n\t\tif position&63 != 0 {\n\t\t\tv |= ^((^uint64(0)) << (position & 63))\n\t\t}\n\t\tif ^v != 0 {\n\t\t\tres := i<<6 | bs._lowbit(^v)\n\t\t\tif res < bs.n {\n\t\t\t\treturn res\n\t\t\t}\n\t\t\treturn -1\n\t\t}\n\t\tfor i++; i < len(bs.data); i++ {\n\t\t\tif ^bs.data[i] != 0 {\n\t\t\t\tres := i<<6 | bs._lowbit(^bs.data[i])\n\t\t\t\tif res < bs.n {\n\t\t\t\t\treturn res\n\t\t\t\t}\n\t\t\t\treturn -1\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n\n// \u8fd4\u56de\u53f3\u4fa7\u7b2c\u4e00\u4e2a 1 \u7684\u4f4d\u7f6e(`\u5305\u542b`\u5f53\u524d\u4f4d\u7f6e).\n//\n//\t\u5982\u679c\u4e0d\u5b58\u5728, \u8fd4\u56de n.\nfunc (bs *BitSetDynamic) Next(index int) int {\n\tif index < 0 {\n\t\tindex = 0\n\t}\n\tif index >= bs.n {\n\t\treturn bs.n\n\t}\n\tk := index >> 6\n\tx := bs.data[k]\n\ts := index & 63\n\tx = (x >> s) << s\n\tif x != 0 {\n\t\treturn (k << 6) | bs._lowbit(x)\n\t}\n\tfor i := k + 1; i < len(bs.data); i++ {\n\t\tif bs.data[i] == 0 {\n\t\t\tcontinue\n\t\t}\n\t\treturn (i << 6) | bs._lowbit(bs.data[i])\n\t}\n\treturn bs.n\n}\n\n// \u8fd4\u56de\u5de6\u4fa7\u7b2c\u4e00\u4e2a 1 \u7684\u4f4d\u7f6e(`\u5305\u542b`\u5f53\u524d\u4f4d\u7f6e).\n//\n//\t\u5982\u679c\u4e0d\u5b58\u5728, \u8fd4\u56de -1.\nfunc (bs *BitSetDynamic) Prev(index int) int {\n\tif index >= bs.n-1 {\n\t\tindex = bs.n - 1\n\t}\n\tif index < 0 {\n\t\treturn -1\n\t}\n\tk := index >> 6\n\tif (index & 63) < 63 {\n\t\tx := bs.data[k]\n\t\tx &= (1 << ((index & 63) + 1)) - 1\n\t\tif x != 0 {\n\t\t\treturn (k << 6) | bs._topbit(x)\n\t\t}\n\t\tk--\n\t}\n\tfor i := k; i >= 0; i-- {\n\t\tif bs.data[i] == 0 {\n\t\t\tcontinue\n\t\t}\n\t\treturn (i << 6) | bs._topbit(bs.data[i])\n\t}\n\treturn -1\n}\n\nfunc (bs *BitSetDynamic) Equals(other *BitSetDynamic) bool {\n\tif len(bs.data) != len(other.data) {\n\t\treturn false\n\t}\n\tfor i := range bs.data {\n\t\tif bs.data[i] != other.data[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (bs *BitSetDynamic) IsSubset(other *BitSetDynamic) bool {\n\tif bs.n > other.n {\n\t\treturn false\n\t}\n\tfor i, v := range bs.data {\n\t\tif (v & other.data[i]) != v {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (bs *BitSetDynamic) IsSuperset(other *BitSetDynamic) bool {\n\tif bs.n < other.n {\n\t\treturn false\n\t}\n\tfor i, v := range other.data {\n\t\tif (v & bs.data[i]) != v {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (bs *BitSetDynamic) IOr(other *BitSetDynamic) *BitSetDynamic {\n\tfor i, v := range other.data {\n\t\tbs.data[i] |= v\n\t}\n\treturn bs\n}\n\nfunc (bs *BitSetDynamic) IAnd(other *BitSetDynamic) *BitSetDynamic {\n\tfor i, v := range other.data {\n\t\tbs.data[i] &= v\n\t}\n\treturn bs\n}\n\nfunc (bs *BitSetDynamic) IXor(other *BitSetDynamic) *BitSetDynamic {\n\tfor i, v := range other.data {\n\t\tbs.data[i] ^= v\n\t}\n\treturn bs\n}\n\nfunc (bs *BitSetDynamic) Or(other *BitSetDynamic) *BitSetDynamic {\n\tres := NewBitsetDynamic(bs.n, 0)\n\tfor i, v := range other.data {\n\t\tres.data[i] = bs.data[i] | v\n\t}\n\treturn res\n}\n\nfunc (bs *BitSetDynamic) And(other *BitSetDynamic) *BitSetDynamic {\n\tres := NewBitsetDynamic(bs.n, 0)\n\tfor i, v := range other.data {\n\t\tres.data[i] = bs.data[i] & v\n\t}\n\treturn res\n}\n\nfunc (bs *BitSetDynamic) AndAndOnesCount(other *BitSetDynamic) int {\n\tones := 0\n\tfor i, v := range other.data {\n\t\t// res.data[i] = bs.data[i] & v\n\t\tones += bits.OnesCount64(bs.data[i] & v)\n\t}\n\treturn ones\n}\n\nfunc (bs *BitSetDynamic) Xor(other *BitSetDynamic) *BitSetDynamic {\n\tres := NewBitsetDynamic(bs.n, 0)\n\tfor i, v := range other.data {\n\t\tres.data[i] = bs.data[i] ^ v\n\t}\n\treturn res\n}\n\nfunc (bs *BitSetDynamic) IOrRange(start, end int, other *BitSetDynamic) {\n\tif other.n != end-start {\n\t\tpanic(\"length of other must equal to end-start\")\n\t}\n\ta, b := 0, other.n\n\tfor start < end && (start&63) != 0 {\n\t\tbs.data[start>>6] |= other._get(a) << (start & 63)\n\t\ta++\n\t\tstart++\n\t}\n\tfor start < end && (end&63) != 0 {\n\t\tend--\n\t\tb--\n\t\tbs.data[end>>6] |= other._get(b) << (end & 63)\n\t}\n\n\t// other[a:b] -> this[start:end]\n\tl, r := start>>6, end>>6\n\ts := a >> 6\n\tn := r - l\n\tif (a & 63) == 0 {\n\t\tfor i := 0; i < n; i++ {\n\t\t\tbs.data[l+i] |= other.data[s+i]\n\t\t}\n\t} else {\n\t\thi := a & 63\n\t\tlo := 64 - hi\n\t\tfor i := 0; i < n; i++ {\n\t\t\tbs.data[l+i] |= (other.data[s+i] >> hi) | (other.data[s+i+1] << lo)\n\t\t}\n\t}\n}\n\nfunc (bs *BitSetDynamic) IAndRange(start, end int, other *BitSetDynamic) {\n\tif other.n != end-start {\n\t\tpanic(\"length of other must equal to end-start\")\n\t}\n\ta, b := 0, other.n\n\tfor start < end && (start&63) != 0 {\n\t\tif other._get(a) == 0 {\n\t\t\tbs.data[start>>6] &^= 1 << (start & 63)\n\t\t}\n\t\ta++\n\t\tstart++\n\t}\n\tfor start < end && (end&63) != 0 {\n\t\tend--\n\t\tb--\n\t\tif other._get(b) == 0 {\n\t\t\tbs.data[end>>6] &^= 1 << (end & 63)\n\t\t}\n\t}\n\n\t// other[a:b] -> this[start:end]\n\tl, r := start>>6, end>>6\n\ts := a >> 6\n\tn := r - l\n\tif (a & 63) == 0 {\n\t\tfor i := 0; i < n; i++ {\n\t\t\tbs.data[l+i] &= other.data[s+i]\n\t\t}\n\t} else {\n\t\thi := a & 63\n\t\tlo := 64 - hi\n\t\tfor i := 0; i < n; i++ {\n\t\t\tbs.data[l+i] &= (other.data[s+i] >> hi) | (other.data[s+i+1] << lo)\n\t\t}\n\t}\n\n}\n\nfunc (bs *BitSetDynamic) IXorRange(start, end int, other *BitSetDynamic) {\n\tif other.n != end-start {\n\t\tpanic(\"length of other must equal to end-start\")\n\t}\n\ta, b := 0, other.n\n\tfor start < end && (start&63) != 0 {\n\t\tbs.data[start>>6] ^= other._get(a) << (start & 63)\n\t\ta++\n\t\tstart++\n\t}\n\tfor start < end && (end&63) != 0 {\n\t\tend--\n\t\tb--\n\t\tbs.data[end>>6] ^= other._get(b) << (end & 63)\n\t}\n\n\t// other[a:b] -> this[start:end]\n\tl, r := start>>6, end>>6\n\ts := a >> 6\n\tn := r - l\n\tif (a & 63) == 0 {\n\t\tfor i := 0; i < n; i++ {\n\t\t\tbs.data[l+i] ^= other.data[s+i]\n\t\t}\n\t} else {\n\t\thi := a & 63\n\t\tlo := 64 - hi\n\t\tfor i := 0; i < n; i++ {\n\t\t\tbs.data[l+i] ^= (other.data[s+i] >> hi) | (other.data[s+i+1] << lo)\n\t\t}\n\t}\n}\n\n// \u7c7b\u4f3cjs\u4e2d\u7c7b\u578b\u6570\u7ec4\u7684set\u64cd\u4f5c.\u5982\u679c\u8d85\u51fa\u8d4b\u503c\u8303\u56f4\uff0c\u629b\u51fa\u5f02\u5e38.\n//\n//\tother: \u8981\u8d4b\u503c\u7684bitset.\n//\toffset: \u8d4b\u503c\u7684\u8d77\u59cb\u5143\u7d20\u4e0b\u6807.\nfunc (bs *BitSetDynamic) Set(other *BitSetDynamic, offset int) {\n\tleft, right := offset, offset+other.n\n\tif right > bs.n {\n\t\tpanic(\"out of range\")\n\t}\n\ta, b := 0, other.n\n\tfor left < right && (left&63) != 0 {\n\t\tif other.Has(a) {\n\t\t\tbs.Add(left)\n\t\t} else {\n\t\t\tbs.Discard(left)\n\t\t}\n\t\ta++\n\t\tleft++\n\t}\n\tfor left < right && (right&63) != 0 {\n\t\tright--\n\t\tb--\n\t\tif other.Has(b) {\n\t\t\tbs.Add(right)\n\t\t} else {\n\t\t\tbs.Discard(right)\n\t\t}\n\t}\n\n\t// other[a:b] -> this[start:end]\n\tl, r := left>>6, right>>6\n\ts := a >> 6\n\tn := r - l\n\tif (a & 63) == 0 {\n\t\tfor i := 0; i < n; i++ {\n\t\t\tbs.data[l+i] = other.data[s+i]\n\t\t}\n\t} else {\n\t\thi := a & 63\n\t\tlo := 64 - hi\n\t\tfor i := 0; i < n; i++ {\n\t\t\tbs.data[l+i] = (other.data[s+i] >> hi) | (other.data[s+i+1] << lo)\n\t\t}\n\t}\n}\n\nfunc (bs *BitSetDynamic) Slice(start, end int) *BitSetDynamic {\n\tif start < 0 {\n\t\tstart += bs.n\n\t}\n\tif start < 0 {\n\t\tstart = 0\n\t}\n\tif end < 0 {\n\t\tend += bs.n\n\t}\n\tif end > bs.n {\n\t\tend = bs.n\n\t}\n\tif start >= end {\n\t\treturn NewBitsetDynamic(0, 0)\n\t}\n\tif start == 0 && end == bs.n {\n\t\treturn bs.Copy()\n\t}\n\n\tres := NewBitsetDynamic(end-start, 0)\n\tremain := (end - start) & 63\n\tfor i := 0; i < remain; i++ {\n\t\tif bs.Has(end - 1) {\n\t\t\tres.Add(end - start - 1)\n\t\t}\n\t\tend--\n\t}\n\n\tn := (end - start) >> 6\n\thi := start & 63\n\tlo := 64 - hi\n\ts := start >> 6\n\tif hi == 0 {\n\t\tfor i := 0; i < n; i++ {\n\t\t\tres.data[i] ^= bs.data[s+i]\n\t\t}\n\t} else {\n\t\tfor i := 0; i < n; i++ {\n\t\t\tres.data[i] ^= (bs.data[s+i] >> hi) ^ (bs.data[s+i+1] << lo)\n\t\t}\n\t}\n\n\treturn res\n}\n\nfunc (bs *BitSetDynamic) Copy() *BitSetDynamic {\n\tres := NewBitsetDynamic(bs.n, 0)\n\tcopy(res.data, bs.data)\n\treturn res\n}\n\nfunc (bs *BitSetDynamic) CopyAndResize(size int) *BitSetDynamic {\n\tnewBits := make([]uint64, (size+63)>>6)\n\tcopy(newBits, bs.data[:min(len(bs.data), len(newBits))])\n\tremainingBits := size & 63\n\tif remainingBits != 0 {\n\t\tmask := (1 << remainingBits) - 1\n\t\tnewBits[len(newBits)-1] &= uint64(mask)\n\t}\n\treturn &BitSetDynamic{data: newBits, n: size}\n}\n\nfunc (bs *BitSetDynamic) Resize(size int) {\n\tnewBits := make([]uint64, (size+63)>>6)\n\tcopy(newBits, bs.data[:min(len(bs.data), len(newBits))])\n\tremainingBits := size & 63\n\tif remainingBits != 0 {\n\t\tmask := (1 << remainingBits) - 1\n\t\tnewBits[len(newBits)-1] &= uint64(mask)\n\t}\n\tbs.data = newBits\n\tbs.n = size\n}\n\nfunc (bs *BitSetDynamic) Expand(size int) {\n\tif size <= bs.n {\n\t\treturn\n\t}\n\tbs.Resize(size)\n}\n\nfunc (bs *BitSetDynamic) BitLength() int {\n\treturn bs._lastIndexOfOne() + 1\n}\n\n// \u904d\u5386\u6240\u6709 1 \u7684\u4f4d\u7f6e.\nfunc (bs *BitSetDynamic) ForEach(f func(pos int) (shouldBreak bool)) {\n\tfor i, v := range bs.data {\n\t\tfor ; v != 0; v &= v - 1 {\n\t\t\tj := (i << 6) | bs._lowbit(v)\n\t\t\tif f(j) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (bs *BitSetDynamic) Size() int {\n\treturn bs.n\n}\n\nfunc (bs *BitSetDynamic) String() string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"BitSetDynamic{\")\n\tnums := []string{}\n\tbs.ForEach(func(pos int) bool {\n\t\tnums = append(nums, fmt.Sprintf(\"%d\", pos))\n\t\treturn false\n\t})\n\tsb.WriteString(strings.Join(nums, \",\"))\n\tsb.WriteString(\"}\")\n\treturn sb.String()\n}\n\n// (0, 1, 2, 3, 4) -> (-1, 0, 1, 1, 2)\nfunc (bs *BitSetDynamic) _topbit(x uint64) int {\n\tif x == 0 {\n\t\treturn -1\n\t}\n\treturn 63 - bits.LeadingZeros64(x)\n}\n\n// (0, 1, 2, 3, 4) -> (-1, 0, 1, 0, 2)\nfunc (bs *BitSetDynamic) _lowbit(x uint64) int {\n\tif x == 0 {\n\t\treturn -1\n\t}\n\treturn bits.TrailingZeros64(x)\n}\n\nfunc (bs *BitSetDynamic) _get(i int) uint64 {\n\treturn bs.data[i>>6] >> (i & 63) & 1\n}\n\nfunc (bs *BitSetDynamic) _lastIndexOfOne() int {\n\tfor i := len(bs.data) - 1; i >= 0; i-- {\n\t\tx := bs.data[i]\n\t\tif x != 0 {\n\t\t\treturn (i << 6) | (bs._topbit(x))\n\t\t}\n\t}\n\treturn -1\n}\n\ntype int32 = int\ntype AscendingSolver struct {\n\tn    int\n\tarr  []int\n\tless func(a, b int) bool\n\tdown *BitSetDynamic // down[i] = 1 \u8868\u793a arr[i-1] > arr[i]\n\tup   *BitSetDynamic // up[i] = 1 \u8868\u793a arr[i-1] < arr[i]\n}\n\nfunc NewAscendingSolver(\n\tn int32, f func(i int32) int, less func(a, b int) bool,\n) *AscendingSolver {\n\tarr := make([]int, n)\n\tfor i := int32(0); i < n; i++ {\n\t\tarr[i] = f(i)\n\t}\n\tsolver := &AscendingSolver{n: n, arr: arr, less: less}\n\tdown, up := NewBitsetDynamic(int(n), 0), NewBitsetDynamic(int(n), 0)\n\tfor i := int32(1); i < n; i++ {\n\t\tif less(arr[i-1], arr[i]) {\n\t\t\tup.Add(int(i))\n\t\t}\n\t\tif less(arr[i], arr[i-1]) {\n\t\t\tdown.Add(int(i))\n\t\t}\n\t}\n\tsolver.down, solver.up = down, up\n\treturn solver\n}\n\nfunc (solver *AscendingSolver) Set(i int, v int) {\n\tif solver.arr[i] == v {\n\t\treturn\n\t}\n\tif i > 0 {\n\t\tif solver.less(v, solver.arr[i-1]) {\n\t\t\tsolver.down.Add(i)\n\t\t} else {\n\t\t\tsolver.down.Discard(i)\n\t\t}\n\t\tif solver.less(solver.arr[i-1], v) {\n\t\t\tsolver.up.Add(i)\n\t\t} else {\n\t\t\tsolver.up.Discard(i)\n\t\t}\n\t}\n\tif i+1 < solver.n {\n\t\tif solver.less(solver.arr[i+1], v) {\n\t\t\tsolver.down.Add(i + 1)\n\t\t} else {\n\t\t\tsolver.down.Discard(i + 1)\n\t\t}\n\t\tif solver.less(v, solver.arr[i+1]) {\n\t\t\tsolver.up.Add(i + 1)\n\t\t} else {\n\t\t\tsolver.up.Discard(i + 1)\n\t\t}\n\t}\n\tsolver.arr[i] = v\n}\n\nfunc (solver *AscendingSolver) Get(i int32) int { return solver.arr[i] }\nfunc (solver *AscendingSolver) Count(start, end int32) int32 {\n\tif start < 0 {\n\t\tstart = 0\n\t}\n\tif end > solver.n {\n\t\tend = solver.n\n\t}\n\n\ta := solver.down.Slice(start+1, end)\n\tb := solver.up.Slice(start+1, end)\n\tb.Lsh(1)\n\treturn int32(a.AndAndOnesCount(b))\n}\n",
    "submit_ts": "1718507563",
    "subm_id": "539782137"
}