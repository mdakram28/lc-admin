{
    "username": "a29ok",
    "submission": "class Solution {\npublic:\n    pair<int, int> bfs(const vector<vector<int>>& tree, int start) {\n    int n = tree.size();\n    vector<int> distances(n, -1);\n    queue<int> q;\n    q.push(start);\n    distances[start] = 0;\n    int farthest_node = start;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        for (int neighbor : tree[node]) {\n            if (distances[neighbor] == -1) {\n                distances[neighbor] = distances[node] + 1;\n                q.push(neighbor);\n                if (distances[neighbor] > distances[farthest_node]) {\n                    farthest_node = neighbor;\n                }\n            }\n        }\n    }\n    return {farthest_node, distances[farthest_node]};\n}\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n=edges1.size(),m=edges2.size();\n        vector<vector<int>> tree1(n+1),tree2(m+2);\n        for(auto it:edges1){\n            tree1[it[0]].push_back(it[1]);\n            tree1[it[1]].push_back(it[0]);\n        }\n        for(auto it:edges2){\n            tree2[it[0]].push_back(it[1]);\n            tree2[it[1]].push_back(it[0]);\n        }\n        auto it1=bfs(tree1,0);\n        auto it2=bfs(tree1,it1.first);\n        auto it3=bfs(tree2,0);\n        auto it4=bfs(tree2,it3.first);\n        int x=it2.second+1,y=it4.second+1;\n        cout<<x<<\" \"<<y<<endl;\n        return max({x/2+y/2+1,x-1,y-1});\n    }\n};",
    "submit_ts": "1719717703",
    "subm_id": "1304398553"
}