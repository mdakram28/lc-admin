{
    "username": "saikat93ify",
    "submission": "class Solution \n{\n    public:\n\n    void remove(multiset <int> &M, int n)\n    {\n        M.erase(M.find(n));\n    }\n\n    void dfs(int v, int parent_v, vector <vector <int> >&tree, vector <int> &time_for_subtree)\n    {\n        for(int child_v : tree[v])\n        {\n            if(child_v == parent_v)\n            {\n                continue;\n            }\n\n            dfs(child_v, v, tree, time_for_subtree);\n\n            int time_for_this_child = (child_v%2 == 0 ? 2 : 1) + time_for_subtree[child_v];\n\n            time_for_subtree[v] = max(time_for_subtree[v], time_for_this_child);\n        }\n\n        //cout << \"Time for subtree \" << v << \" = \" << time_for_subtree[v] << \"\\n\";\n    }\n\n    void dfs_answer_every_root(\n        int v, \n        int parent_v, \n        int parent_time_without_this_child,\n        vector <vector <int>> &tree, \n        vector <int> &time_for_subtree,\n        vector <int> &time_for_root)\n    {\n        int time_for_parent = 0;\n        if(parent_v != -1)\n        {\n            time_for_parent = (parent_v%2 == 0 ? 2 : 1) + parent_time_without_this_child;\n        }\n        time_for_root[v] = max(time_for_subtree[v], time_for_parent);\n        /*cout << \"At \" << v << \" Parent time without this child = \" << parent_time_without_this_child\n            << \" Time for tree rooted here = \" << time_for_root[v] << \"\\n\";*/\n\n        multiset <int> child_times;\n        child_times.insert(time_for_parent);\n        for(int child_v : tree[v])\n        {\n            if(child_v == parent_v)\n            {\n                continue;\n            }\n\n            int time_for_this_child = (child_v%2 == 0 ? 2 : 1) + time_for_subtree[child_v];\n            child_times.insert(time_for_this_child);            \n        }\n\n        for(int child_v : tree[v])\n        {\n            if(child_v == parent_v)\n            {\n                continue;\n            }\n\n            int time_for_this_child = (child_v%2 == 0 ? 2 : 1) + time_for_subtree[child_v];\n            remove(child_times, time_for_this_child);\n            int time_without_this_child = (child_times.size() > 0 ? *child_times.rbegin() : 0);  \n\n            dfs_answer_every_root(child_v, v, time_without_this_child, tree, time_for_subtree, time_for_root);\n            child_times.insert(time_for_this_child);        \n        }\n    }\n\n    vector<int> timeTaken(vector<vector<int>>& edges) \n    {\n        int no_of_vertices = edges.size() + 1; \n        vector <vector <int> > tree(no_of_vertices + 1);\n        for(int i = 0; i < edges.size(); i++)\n        {\n            int u = edges[i][0], v = edges[i][1]; \n            tree[u].push_back(v); \n            tree[v].push_back(u);\n        }\n\n        vector <int> time_for_subtree(no_of_vertices + 1); \n        dfs(0, -1, tree, time_for_subtree);\n\n        vector <int> time_for_root(no_of_vertices);\n        dfs_answer_every_root(0, -1, 0, tree, time_for_subtree, time_for_root);\n\n        return time_for_root;\n    }\n};",
    "submit_ts": "1722698025",
    "subm_id": "1343167167"
}