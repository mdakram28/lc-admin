{
    "username": "6allant-coldenwyj",
    "submission": "const int MAXN = 100005; // \u8282\u70b9\u6570\u91cf\u7684\u4e0a\u9650\nclass SegmentTree {\nprivate:\n    int sz;\n    vector<int> tree; // \u7ebf\u6bb5\u6811\u6570\u7ec4\n\n    // \u66f4\u65b0\u533a\u95f4 [l, r] \u7684\u503c\n    void updateRange(int node, int start, int end, int l, int r, int value) {\n        if (start > r || end < l) return;\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u533a\u95f4\u5305\u542b\u5728\u66f4\u65b0\u533a\u95f4\u5185\uff0c\u66f4\u65b0\u5f53\u524d\u8282\u70b9\u7684\u503c\u5e76\u9012\u5f52\u66f4\u65b0\u5b50\u6811\n        // \u5206\u6cbb\u7684\u7ed3\u675f\uff0c\u53ea\u6709\u4e00\u4e2a\u8282\u70b9\u7684\u60c5\u51b5\uff0c\u5bf9\u5e94\u8fdb\u884c\u8282\u70b9\u503c\u7684\u66f4\u65b0\n        if (start == end) {\n            tree[node] = value;\n            return; \n        }\n\n        // \u66f4\u65b0\u5de6\u53f3\u5b50\u6811 \u5206\u6cbb\u7684\u8fc7\u7a0b\n        int mid = (start + end) >> 1;\n        updateRange(node * 2, start, mid, l, r, value);\n        updateRange(node * 2 + 1, mid + 1, end, l, r, value);\n\n        // \u66f4\u65b0\u7236\u8282\u70b9 \u5f52\u7684\u8fc7\u7a0b\n        tree[node] = tree[node * 2] + tree[node * 2 + 1];\n    }\n\n    // \u67e5\u8be2\u533a\u95f4 [l, r] \u7684\u548c\n    int queryRange(int node, int start, int end, int l, int r) {\n        // \u5982\u679c\u67e5\u8be2\u533a\u95f4\u4e0e\u5f53\u524d\u8282\u70b9\u533a\u95f4\u6ca1\u6709\u4ea4\u96c6\uff0c\u8fd4\u56de0\n        if (start > r || end < l) return 0;\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u533a\u95f4\u5305\u542b\u5728\u67e5\u8be2\u533a\u95f4\u5185\uff0c\u76f4\u63a5\u8fd4\u56de\u5f53\u524d\u8282\u70b9\u7684\u503c\n        // \u5206\u6cbb\u7684\u7ed3\u675f\n        if (l <= start && end <= r) {\n            return tree[node];\n        }\n        // \u67e5\u8be2\u5de6\u53f3\u5b50\u6811\u5e76\u8fd4\u56de\u7ed3\u679c \u5206\u6cbb\u7684\u8fc7\u7a0b\n        int mid = (start + end) / 2;\n        int left = queryRange(node * 2, start, mid, l, r);\n        int right = queryRange(node * 2 + 1, mid + 1, end, l, r);\n        // \u9012\u5f52\u4f20\u9012\u7ed3\u679c\u7d2f\u52a0\n        return left + right;\n    }\n\npublic:\n    // \u6784\u9020\u51fd\u6570\n    SegmentTree(int size) {\n        sz = size;\n        tree.resize(sz * 4 + 5, 0);  // \u7ebf\u6bb5\u6811\u6570\u7ec4\u5927\u5c0f\u4e3a\u539f\u6570\u7ec4\u76844\u500d\n    }\n\n    // \u66f4\u65b0\u533a\u95f4 [start, end] \u7684\u503c\u4e3a newValue\n    void update(int start, int end, int value) {\n        updateRange(1, 1, sz, start, end, value);\n    }\n\n    // \u67e5\u8be2\u533a\u95f4 [start, end] \u7684\u548c\n    int query(int start, int end) {\n        return queryRange(1, 1, sz, start, end);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        unordered_map<int, int> mp;\n        SegmentTree st(1e5 + 10);\n        int res = 0;\n        for(int i = 0; i < n; ++i) {\n            mp[i] = nums[i];\n            if(i != 0 && i != n - 1 && nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {\n                st.update(i + 1, i + 1, 1);\n            };\n        }\n        vector<int> result;\n        for(auto& q : queries) {\n           if(q[0] == 1) {\n                if(q[1] + 2 > q[2]) result.push_back(0);\n                else {\n                    auto val = st.query(q[1] + 2, q[2]);\n                    result.push_back(val);\n                }\n           } else {\n                int idx = q[1];\n                int nval = q[2];\n                int qval = st.query(idx + 1, idx + 1);\n                int lval = mp[idx - 1];\n                int rval = mp[idx + 1];\n                if(idx != 0 && idx != n - 1) {\n                    if(qval == 0 && nval > lval && nval > rval) st.update(idx + 1, idx + 1, 1);\n                    if(qval == 1 && (nval <= lval || nval <= rval)) st.update(idx + 1, idx + 1, 0);\n                } \n                // \u66f4\u65b0\u5de6\u533a\u95f4\n                if(idx > 1) {\n                    int lqval = st.query(idx, idx);\n                    int llval = mp[idx - 2];\n                    if(lqval == 0 && lval > llval && lval > nval) st.update(idx, idx, 1); \n                    if(lqval == 1 && (lval <= llval || lval <= nval)) st.update(idx, idx, 0); \n                }\n                // \u66f4\u65b0\u53f3\u533a\u95f4\n                if(idx < n - 2) {\n                    int rqval = st.query(idx + 2, idx + 2);\n                    int rrval = mp[idx + 2];\n                    if(rqval == 0 && rval > rrval && rval > nval) st.update(idx + 2, idx + 2, 1);\n                    if(rqval == 1 && (rval <= rrval || rval <= nval)) st.update(idx + 2, idx + 2, 0);\n                }\n                // \u66f4\u65b0\u54c8\u5e0c\n                mp[idx] = nval;\n           } \n        }\n        return result;\n    }\n};",
    "submit_ts": 1718507782.0
}