{
    "username": "jcoves",
    "submission": "\n#ifdef LOCAL_RUN\n#include \"debug_leet.h\"\n    #else\n    #define trace(...) ;\n    #define debug(x) ;\n    #define debuga(a, n) ;\n    #define debug2(x, y) ;\n    #define debug3(x, y, z) ;\n    #define debug4(x, y, z, w) ;\n    #define debug5(a,b,c,d,e) ;\n    #define ctime() ;\n    #define lassert(x) ;\n    #define dassert(x, ...) ;\n    int recur_depth = 0; bool rec_indent = true;\n    const bool isLocal = false;\n    template <typename Arg, typename... Args>\n    void display(TreeNode* root) {}\n    #endif\n\n    #define pb push_back\n    #define eb emplace_back\n    #define popb pop_back\n    #define all(v) begin(v), end(v)\n    #define rall(v) (v).rbegin(),(v).rend()\n    #define make_unique(v) (v).erase(unique(all(v)), (v).end())\n    #define sz(c) ((int) c.size())\n    #define forn(i,n) for(int i=0;i<(int)(n);i++)\n    #define fornn(i,s,n) for(int i=s;i<(int)(n);i++)\n    #define forb(i,n) for(int i=n-1;i>=0;i--)\n    #define forbn(i,s,n) for(int i=n-1;i>=(int)(s);i--)\n    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n    #define mem(a,b) memset(a,b,sizeof(a))\n    #define abs(x) (((x) < 0) ? -(x) : (x))\n    #define sqr(x) ((x) * (x))\n    #define sqrt(x) sqrt(abs(x))\n    #define has(c,x) (c.find(x) != c.end())\n    #define pw(x) (1LL << (x))\n    #define ibit(x,i) (((x) >> (i)) & 1)\n    #define data(v) v.data(), sz(v) // vi -> vai\n\n    typedef stringstream sstr;\n    typedef long long ll;\n    typedef long double ld;\n    typedef pair<int, int> pii;\n    typedef pair<ll,ll> pll;\n    typedef pair<ld,ld> pdd;\n    typedef vector<int> vi;\n    typedef vector<ll> vll;\n    typedef vector<pii> vpii;\n    typedef vector<vi> vvi;\n    typedef vector<vll> vvll;\n    typedef valarray<int> vai;\n    template <class T>\n    using min_pq = priority_queue<T, vector<T>, greater<T>>;\n    template <class T>\n    using vc = vector<T>;\n    template <class T>\n    using vvc = vector<vc<T>>;\n    template <class T>\n    using vvvc = vector<vvc<T>>;\n    template <class T>\n    using vvvvc = vector<vvvc<T>>;\n    template <class T>\n    using vvvvvc = vector<vvvvc<T>>;\n\n    template<class F>\n    struct y_comb{\n        F f;\n        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }\n        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }\n    };\n    template<class F>\n    decltype(auto) yf(F &&f){\n        return y_comb<decay_t<F>>(forward<F>(f));\n    }\n\n    inline int ni(){ int x; cin >> x;   return x; }\n    inline ll  nl() { ll  x; cin >> x; return x; }\n\n    template <class T> void mmin(T& a, const T& b) {\n        a = (a) < (b) ? (a) : (b);\n    }\n    template <class T> void mmax(T& a, const T& b) {\n        a = (a) > (b) ? (a) : (b);\n    }\n    template <class T> auto vv(int d1, T x){\n        return vc<T>(d1, x);\n    }\n    template <class T> auto vv(int d1, int d2, T x){\n        return vc<vc<T>>(d1, vc<T>(d2, x));\n    }\n    template <class T> auto vv(int d1, int d2, int d3, T x){\n        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));\n    }\n    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){\n        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));\n    }\n    void outv(auto &v){\n        for(auto &x: v) {cout<< x <<\" \";} cout<<endl;\n    }\n    void rvec(int &n, auto &v){\n        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);\n    }\n    template <typename Arg, typename... Args>\n    void read(Arg&& arg, Args&&... args){\n        cin >> std::forward<Arg>(arg); using expander = int[];\n        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};\n    }\n    template <typename Arg, typename... Args>\n    void out(Arg&& arg, Args&&... args){\n        cout << std::forward<Arg>(arg); using expander = int[];\n        (void)expander{0, (void(cout << \" \" << std::forward<Args>(args)),0)...};\n        cout << endl;\n    }\n    auto init = []() {\n        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';\n    }();\n\n    ll pwr(ll base, ll p, ll mod){\n        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;\n            base=(base*base)%mod; p/=2;}\n        return ans;\n    }\n    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }\n    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }\n\n    const long double PI = (long double)(3.1415926535897932384626433832795);\n    const ll  mx_ll   = numeric_limits<ll> :: max();\n    const int mx_int  = numeric_limits<int> :: max();\n\n    const int oo = 0x3f3f3f3f;\n    const ll  OO = 0x3f3f3f3f3f3f3f3fll;\n    const double eps = 1e-9;\n    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};\n    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};\n\nconst int maxn = 1e5 + 3;\nconst int mod = 1e9+7;\n\nstruct Node {\n    ll no_no, no_yes, yes_no, yes_yes;\n    bool empty;\n    int l, r;\n    Node() {\n        no_no = no_yes = yes_no = yes_yes = 0;\n        empty = true;\n    }\n    Node(int id, int x){\n        l = r = id;\n        no_no = no_yes = yes_no = 0;\n        yes_yes = max(x, 0);\n        empty = false;\n    }\n    pii range(){\n        return {l, r};\n    }\n    vll vals(){\n        return {no_no, no_yes, yes_no, yes_yes};\n    }\n};\n\n// ostream& operator<< (ostream& out, Node node) {\n//     out << node.no_no << node.no_yes << node.yes_no << node.yes_yes;\n//     return out;\n// }\n\nNode merge(Node a, Node b){\n    Node res;\n    if(a.empty) {\n        res = b;\n        return res;\n    }\n    if(b.empty) {\n        res = a;\n        return res;\n    }\n    if(a.l > b.r) {\n        res = merge(b, a);\n        return res;\n    }\n    if(a.l == b.l){\n        res = a;\n        return res;\n    }\n\n    res.no_no = max({\n        a.no_yes + b.no_no,\n        a.no_no + b.yes_no,\n        a.no_no + b.no_no\n    });\n    res.no_yes = max({\n        a.no_yes + b.no_yes,\n        a.no_no + b.no_yes,\n        a.no_no + b.yes_yes,\n    });\n    res.yes_no = max({\n        a.yes_no + b.no_no,\n        a.yes_no + b.yes_no,\n        a.yes_yes + b.no_no\n    });\n    res.yes_yes = max({\n        a.yes_no + b.yes_yes,\n        a.yes_no + b.no_yes,\n        a.yes_yes + b.no_yes\n    });\n    res.l = a.l; res.r = b.r;\n    debug2(a.range(), a.vals());\n    debug2(b.range(), b.vals());\n    debug2(res.range(), res.vals());\n    res.empty = false;\n    return res;\n}\n\ntemplate<class T>\n    struct SegCustom {\n        vector<T> t;\n        int n;\n        T neutral;\n        function<T(T,T)> merge;\n        int operator [] (int i) {\n            assert(t[i + n] == query(i, i));\n            return t[i + n];\n        }\n        void update(int i, T v) {\n            i += n; t[i] = v;\n            for (t[i] = merge(t[i], v); i >>= 1;) {\n                t[i] = merge(t[i << 1], t[i << 1 | 1]);\n            }\n        }\n        T query(int l, int r) {\n            T ansl = neutral;\n            T ansr = neutral;\n            for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {\n                if (l & 1) ansl = merge(ansl, t[l++]);\n                if (r & 1) ansr = merge(t[--r], ansr);\n            }\n            return merge(ansl, ansr);\n        }\n        SegCustom(vector<T> &a, T _neutral, function<T(T,T)>_merge) : n(sz(a)), neutral(_neutral), merge(_merge) {\n            t.assign(n << 1, neutral);\n            forn(i, n) t[i + n] = a[i];\n            forb(i, n) t[i] = merge(t[i << 1], t[i << 1 | 1]);\n        }\n        SegCustom(int _n, T _neutral, function<T(T,T)>_merge) : n(_n), neutral(_neutral), merge(_merge) {\n            t.assign(n << 1, neutral);\n        }\n        vector<T> vals(){\n            vector<T> ans;\n            forn(i, n) ans.pb(query(i, i));\n            return ans;\n        }\n        int right_most(int l, int r, auto pass){ // max id in [l,r]: func(query(id, r)) = true\n            if(l == n) return n;\n            int lo = l, hi = min(r, n-1);\n            if(!pass(query(lo, lo))) return -1; // entire range is bad\n            if(pass(query(lo, hi))) return hi;\n            while(lo < hi){\n                int mid = (lo + hi + 1) / 2;\n                // debug3(lo, mid, hi);\n                if(pass(query(l, mid))) lo = mid;\n                else hi = mid-1;\n            }\n            assert(pass(query(l, hi)));\n            assert(!pass(query(l, hi+1)));\n            return hi;\n        }\n        int left_most(int l, int r, auto pass){ // min id in [l,r]: func(query(l, id)) = true\n            if(l == n) return n;\n            int lo = l, hi = min(r, n-1);\n            if(pass(query(lo, lo))) return lo;\n            if(!pass(query(lo, hi))) return n; // entire range is bad\n            while(lo < hi){\n                int mid = (lo + hi + 0) / 2;\n                // debug3(lo, mid, hi);\n                if(pass(query(l, mid))) hi = mid;\n                else lo = mid+1;\n            }\n            assert(pass(query(l, lo)));\n            dassert(!pass(query(l, lo-1)), l, r, lo);\n            return lo;\n        }\n    };\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = sz(nums);\n        vc<Node> t; forn(i, n) t.pb(Node(i, nums[i]));\n        SegCustom<Node> seg(t, Node(), [&](Node a, Node b){ return merge(a, b);});\n        ll ans = 0;\n        for(auto &q: queries){\n            int id = q[0], x = q[1];\n            nums[id] = x;\n            seg.update(id, Node(id, x));\n            Node node = seg.query(0, n-1);\n            ll val = max({\n                node.no_yes,\n                node.no_no,\n                node.yes_no,\n                node.yes_yes\n            });\n            trace(node.no_yes,\n                node.no_no,\n                node.yes_no,\n                node.yes_yes);\n            debug2(val, nums);\n            ans += val; ans %= mod;\n        }\n        return int(ans % mod);\n    }\n};\n",
    "submit_ts": 1716694593.0
}