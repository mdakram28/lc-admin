{
    "username": "WKelvinson",
    "submission": "class Solution {\n    // Helper class to store BFS result\n    static class BFSResult {\n        int farthestNode;\n        int maxDistance;\n        \n        BFSResult(int farthestNode, int maxDistance) {\n            this.farthestNode = farthestNode;\n            this.maxDistance = maxDistance;\n        }\n    }\n\n    // Perform BFS to find the farthest node and its distance\n    private BFSResult bfs(int s, Map<Integer, List<Integer>> g) {\n        Queue<Integer> q = new LinkedList<>();\n        q.add(s);\n        Map<Integer, Integer> d = new HashMap<>();\n        d.put(s, 0);\n        int fn = s;\n        int md = 0;\n\n        while (!q.isEmpty()) {\n            int n = q.poll();\n            for (int nei : g.get(n)) {\n                if (!d.containsKey(nei)) {\n                    d.put(nei, d.get(n) + 1);\n                    q.add(nei);\n                    if (d.get(nei) > md) {\n                        md = d.get(nei);\n                        fn = nei;\n                    }\n                }\n            }\n        }\n        return new BFSResult(fn, md);\n    }\n\n    // Find the diameter of a tree\n    private int treeDiameter(Map<Integer, List<Integer>> g) {\n        int sn = 0;\n        BFSResult bfsResult1 = bfs(sn, g);\n        BFSResult bfsResult2 = bfs(bfsResult1.farthestNode, g);\n        return bfsResult2.maxDistance;\n    }\n\n    // Build graph from edges\n    private Map<Integer, List<Integer>> buildGraph(int[][] e, int n) {\n        Map<Integer, List<Integer>> g = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            g.put(i, new ArrayList<>());\n        }\n        for (int[] edge : e) {\n            int u = edge[0];\n            int v = edge[1];\n            g.get(u).add(v);\n            g.get(v).add(u);\n        }\n        return g;\n    }\n\n    // Main method to find the minimum diameter after merge\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        // Calculate the number of nodes\n        int n1 = edges1.length + 1;\n        int n2 = edges2.length + 1;\n\n        // Build the graphs\n        Map<Integer, List<Integer>> g1 = buildGraph(edges1, n1);\n        Map<Integer, List<Integer>> g2 = buildGraph(edges2, n2);\n\n        // Calculate diameters\n        int d1 = treeDiameter(g1);\n        int d2 = treeDiameter(g2);\n\n        // Return the minimum diameter after merge\n        return Math.max(d1, Math.max(d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1));\n    }\n}",
    "submit_ts": "1719717772",
    "subm_id": "1304400352"
}