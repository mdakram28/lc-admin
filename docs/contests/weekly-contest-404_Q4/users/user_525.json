{
    "username": "cokefan",
    "submission": "class Solution:\n    def FindMin(self, tree):\n        n = len(tree)\n        \n        if n <= 2:\n            return [n, n]\n        \n        dgr = [0] * n\n        for k, v in enumerate(tree):\n            dgr[k] = len(v)\n        \n        q = deque([x for x in range(n) if dgr[x] == 1])\n        \n        dist = 0\n        remain = n\n        \n        while remain > 2:\n            size = len(q)\n            remain -= size\n            \n            # print(\"size==\", size)\n            \n            for _ in range(size):\n                cur = q.popleft()\n                for child in tree[cur]:\n                    dgr[child]-=1\n                    if dgr[child] == 1:\n                        q.append(child)\n            dist += 1\n        \n        result = dist * 2 + remain\n        dist += remain\n        \n        return [result, dist]\n                \n            \n            \n        \n        \n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        m = len(edges1) + 1\n        n = len(edges2) + 1\n        \n        def BuildTree(edges, size):\n            result = [set() for _ in range(size)]\n            \n            for u, v in edges:\n                result[u].add(v)\n                result[v].add(u)\n            \n            return result\n        \n        tree1 = BuildTree(edges1, m)\n        tree2 = BuildTree(edges2, n)\n        \n        r1, min1 = self.FindMin(tree1)\n        # print(\"min1==\",min1)\n        r2, min2 = self.FindMin(tree2)\n        # print(\"min2==\",min2)\n        \n        \n        return max([min1+min2, r1, r2]) - 1\n        \n        \n        \n            ",
    "submit_ts": 1719719287.0
}