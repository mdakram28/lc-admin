{
    "username": "Emily",
    "submission": "\"\"\"\nbacktracking?\n- go row by row\nbacktrack(row, invalid_cols={1: 2, 3: 4}, rooks_left)\n- either place a rook (in a valid col) or don't\n- at the end check to see if we've placed 3 rooks\n\"\"\"\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        n = len(board)\n        m = len(board[0])\n\n        # find the top 3 cells in each row\n        best_in_row = []\n        for r in range(n):\n            heap = []\n            for c in range(m):\n                heapq.heappush(heap, (-board[r][c], c))\n            rowresult = []\n            for i in range(3):\n                rowresult.append(heapq.heappop(heap)[1])\n            best_in_row.append(rowresult)\n        # find the top 3 cells in each col\n        best_in_col = []\n        for c in range(m):\n            heap = []\n            for r in range(n):\n                heapq.heappush(heap, (-board[r][c], r))\n            colresult = []\n            for i in range(3):\n                colresult.append(heapq.heappop(heap)[1])\n            best_in_col.append(colresult)\n\n        # backtracking?\n        def backtrack(r, placed_cols, rooks, score):\n            # placed 3 rooks\n            if rooks == 3:\n                return score\n            # got to end\n            if r == n:\n                return float('-inf')\n            \n            # don't place a rook\n            ans = backtrack(r+1, placed_cols, rooks, score)\n\n            # try placing a rook\n            for c in best_in_row[r]:\n                # good cell and not already conflicting\n                if r in best_in_col[c] and c not in placed_cols:\n                    placed_cols.add(c)\n                    ans = max(ans, backtrack(r+1, placed_cols, rooks+1, score + board[r][c]))\n                    placed_cols.remove(c)\n            return ans\n        \n        return int(backtrack(0, set(), 0, 0))",
    "submit_ts": "1723908750",
    "subm_id": "1359165622"
}