{
    "username": "vigneshwar44",
    "submission": "class Solution {\npublic:\n    struct Circle {\n        int x, y, r;\n        Circle(int x, int y, int r) : x(x), y(y), r(r) {}\n    };\n\n    bool intersect(const Circle& c1, const Circle& c2) {\n        long long dx = c1.x - c2.x;\n        long long  dy = c1.y - c2.y;\n        long long  distanceSquared = dx * dx + dy * dy;\n        long long  radiusSum = c1.r + c2.r;\n        return distanceSquared <= radiusSum * radiusSum;\n    }\n\n    vector<vector<int>> buildGraph(const vector<Circle>& circles) {\n        int n = circles.size();\n        vector<vector<int>> graph(n);\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (intersect(circles[i], circles[j])) {\n                    graph[i].push_back(j);\n                    graph[j].push_back(i);\n                }\n            }\n        }\n        return graph;\n    }\n\n    bool isBlocked(int X, int Y, const vector<Circle>& circles) {\n        vector<vector<int>> graph = buildGraph(circles);\n\n        unordered_set<int> leftSideCircles;\n        unordered_set<int> rightSideCircles;\n        unordered_set<int> topSideCircles;\n        unordered_set<int> bottomSideCircles;\n\n        for (int i = 0; i < circles.size(); ++i) {\n            if (circles[i].x - circles[i].r <= 0) {\n                leftSideCircles.insert(i);\n            }\n            if (circles[i].x + circles[i].r >= X) {\n                rightSideCircles.insert(i);\n            }\n            if (circles[i].y + circles[i].r >= Y) {\n                topSideCircles.insert(i);\n            }\n            if (circles[i].y - circles[i].r <= 0) {\n                bottomSideCircles.insert(i);\n            }\n        }\n        auto checkConnection = [&](const unordered_set<int>& side1, const unordered_set<int>& side2) -> bool {\n            unordered_set<int> visited;\n            queue<int> q;\n            for (int circle : side1) {\n                q.push(circle);\n                visited.insert(circle);\n            } \n            while (!q.empty()) {\n                int circle = q.front();\n                q.pop();\n                if (side2.count(circle)) {\n                    return true;\n                }\n                for (int neighbor : graph[circle]) {\n                    if (!visited.count(neighbor)) {\n                        visited.insert(neighbor);\n                        q.push(neighbor);\n                    }\n                }\n            }\n            return false;\n        };\n        return checkConnection(leftSideCircles, rightSideCircles) ||\n               checkConnection(topSideCircles, bottomSideCircles) ||\n               checkConnection(topSideCircles, rightSideCircles) ||\n               checkConnection(leftSideCircles, bottomSideCircles);\n    }\n\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circlesInput) {\n        vector<Circle> circleObjects;\n        for (const auto& c : circlesInput) {\n            circleObjects.emplace_back(c[0], c[1], c[2]);\n        }\n        return !isBlocked(X, Y, circleObjects);\n    }\n};",
    "submit_ts": "1722137488",
    "subm_id": "1335765242"
}