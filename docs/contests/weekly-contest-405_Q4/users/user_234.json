{
    "username": "xymabinogi",
    "submission": "using namespace std;\nusing i64 = long long;\nusing u32 = unsigned int;\nusing u64 = unsigned long long;\n\n\n//modular 2^61 - 1, from maspy\nstruct modint61 {\n  static constexpr u64 mod = (1ULL << 61) - 1;\n  u64 val;\n  constexpr modint61() : val(0ULL) {}\n  constexpr modint61(u32 x) : val(x) {}\n  constexpr modint61(u64 x) : val(x % mod) {}\n  constexpr modint61(int x) : val((x < 0) ? (x + static_cast<i64>(mod)) : x) {}\n  constexpr modint61(i64 x)\n      : val(((x %= static_cast<i64>(mod)) < 0) ? (x + static_cast<i64>(mod))\n                                              : x) {}\n  static constexpr u64 get_mod() { return mod; }\n  modint61 &operator+=(const modint61 &a) {\n    val = ((val += a.val) >= mod) ? (val - mod) : val;\n    return *this;\n  }\n  modint61 &operator-=(const modint61 &a) {\n    val = ((val -= a.val) >= mod) ? (val + mod) : val;\n    return *this;\n  }\n  modint61 &operator*=(const modint61 &a) {\n    const unsigned __int128 y = static_cast<unsigned __int128>(val) * a.val;\n    val = (y >> 61) + (y & mod);\n    val = (val >= mod) ? (val - mod) : val;\n    return *this;\n  }\n  modint61 operator-() const { return modint61(val ? mod - val : u64(0)); }\n  modint61 &operator/=(const modint61 &a) { return (*this *= a.inverse()); }\n  modint61 operator+(const modint61 &p) const { return modint61(*this) += p; }\n  modint61 operator-(const modint61 &p) const { return modint61(*this) -= p; }\n  modint61 operator*(const modint61 &p) const { return modint61(*this) *= p; }\n  modint61 operator/(const modint61 &p) const { return modint61(*this) /= p; }\n  bool operator==(const modint61 &p) const { return val == p.val; }\n  bool operator!=(const modint61 &p) const { return val != p.val; }\n     bool operator<(const modint61 &p) const { return val < p.val; }\n  modint61 inverse() const {\n    i64 a = val, b = mod, u = 1, v = 0, t;\n    while (b > 0) {\n      t = a / b;\n      swap(a -= t * b, b), swap(u -= t * v, v);\n    }\n    return modint61(u);\n  }\n  modint61 pow(i64 n) const {\n    assert(n >= 0);\n    modint61 ret(1), mul(val);\n    while (n > 0) {\n      if (n & 1) ret *= mul;\n      mul *= mul, n >>= 1;\n    }\n    return ret;\n  }\n};\n\n// rng\nu64 RNG_64() {\n  static uint64_t x_\n      = uint64_t(chrono::duration_cast<chrono::nanoseconds>(\n                     chrono::high_resolution_clock::now().time_since_epoch())\n                     .count())\n        * 10150724397891781847ULL;\n  x_ ^= x_ << 7;\n  return x_ ^= x_ >> 9;\n}\n\nu64 RNG(u64 lim) { return RNG_64() % lim; }\ni64 RNG(i64 l, i64 r) { return l + RNG_64() % (r - l); }\n\n\nstruct RollingHash {\n  using mint = modint61;\n  static constexpr u64 mod = mint::get_mod();\n  const mint base;\n  vector<mint> power;\n\n  static inline mint generate_base() { return RNG(mod); }\n\n  inline void expand(size_t sz) {\n    if (power.size() < sz + 1) {\n      int pre_sz = (int)power.size();\n      power.resize(sz + 1);\n      for (size_t i = pre_sz - 1; i < sz; i++){\n      \tpower[i + 1] = power[i] * base;\n      }\n    }\n  }\n\n  explicit RollingHash(mint base = generate_base()) : base(base), power{1} {}\n\n  template <typename STRING>\n  vector<mint> build(const STRING& s) const {\n    int sz = s.size();\n    vector<mint> hashed(sz + 1, mint(0));\n    for (int i = 0; i < sz; i++) { hashed[i + 1] = hashed[i] * base + s[i]; }\n    return hashed;\n  }\n\n  template <typename STRING>\n  mint eval(STRING& s) {\n    mint x = 0;\n    for (auto& ch: s) x = base * x + ch;\n    return x;\n  }\n\n  mint query(const vector<mint>& s, int l, int r) {\n    assert(0 <= l && l <= r && r < (int)s.size());\n    expand(r - l);\n    return (s[r] - s[l] * power[r - l]);\n  }\n\n  mint combine(mint h1, mint h2, int h2len) {\n    expand(h2len);\n    return h1 * power[h2len] + h2;\n  }\n\n  mint add_char(mint h, int x) { return h * base + mint(x); }\n\n  int lcp(const vector<mint>& a, int l1, int r1, const vector<mint>& b, int l2,\n          int r2) {\n    int len = min(r1 - l1, r2 - l2);\n    int low = 0, high = len + 1;\n    while (high - low > 1) {\n      int mid = (low + high) / 2;\n      if (query(a, l1, l1 + mid) == query(b, l2, l2 + mid))\n        low = mid;\n      else\n        high = mid;\n    }\n    return low;\n  }\n};\nconst i64 INF = 1LL << 50; \n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int n = target.length();\n        RollingHash RH;\n        \n        map<modint61, int> mp;\n        int m = words.size();\n        vector<int> len;\n        for (int i = 0; i < m; i++){\n            len.push_back((int) words[i].length());\n            \n            auto val = RH.eval(words[i]);\n            if (mp.count(val)){\n                mp[val] = min(mp[val], costs[i]);\n            }\n            else mp[val] = costs[i];\n        }\n        sort(len.begin(), len.end());\n        len.erase(unique(len.begin(), len.end()), len.end());\n        \n        vector<i64> cost(n + 1, INF);\n        cost[0] = 0;\n        \n        \n        auto a = RH.build(target);\n        \n        for (int i = 0; i < n; i++){\n            for (auto v : len){\n                if (v > i + 1) break;\n                auto V = RH.query(a, i - v + 1, i + 1);\n                if (mp.count(V)){\n                    cost[i + 1] = min(cost[i + 1], mp[V] + cost[i - v + 1]);\n                }\n            }\n            \n        }\n        if (cost[n] > 1E9) return -1;\n        return cost[n];\n        \n        \n        return 0;\n    }\n};",
    "submit_ts": "1720321549",
    "subm_id": "1312325822"
}