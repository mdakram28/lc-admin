{
    "username": "scotchtape",
    "submission": "#pragma GCC optimize(\"O3\",\"unroll-loops\")\n\nclass Solution {\npublic:\n    array<vector<vector<int>>, 2> g;\n    array<vector<int>, 4> dist;\n\n    pair<int, int> dfs(int n, int p, int G, int D) {\n        pair<int, int> mx = {0, n};\n        for (int i : g[G][n]) {\n            if (i == p) continue;\n            dist[D][i] = 1+dist[D][n];\n            auto p = dfs(i, n, G, D); p.first++;\n            mx = max(mx, p);\n            \n        }\n        return mx;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& e1, vector<vector<int>>& e2) {\n\n        int n = e1.size()+1, m = e2.size()+1;\n        \n        g[0] = vector<vector<int>>(n);\n        g[1] = vector<vector<int>>(m);\n        for (auto v : e1) {\n            g[0][v[0]].push_back(v[1]);\n            g[0][v[1]].push_back(v[0]);\n        }\n\n        for (auto v : e2) {\n            g[1][v[0]].push_back(v[1]);\n            g[1][v[1]].push_back(v[0]);\n        }\n\n        \n        dist[0] = vector<int>(n, 0);\n        dist[1] = vector<int>(n, 0);\n        dist[2] = vector<int>(m, 0);\n        dist[3] = vector<int>(m, 0);\n\n        \n\n        int v11 = dfs(0, -1, 0, 0).second;\n        dist[0] = vector<int>(n, 0);\n        int v12 = dfs(v11, -1, 0, 0).second;\n        int D1 = dfs(v12, -1, 0, 1).first;\n\n\n        int v21 = dfs(0, -1, 1, 2).second;\n        dist[2] = vector<int>(m, 0);\n        int v22 = dfs(v21, -1, 1, 2).second;\n        int D2 = dfs(v22, -1, 1, 3).first;\n\n        int MIN_DIST1 = n;\n        for (int i = 0; i < n; ++i) MIN_DIST1 = min(MIN_DIST1, max(dist[0][i], dist[1][i]));\n        int MIN_DIST2 = m;\n        for (int i = 0; i < m; ++i) MIN_DIST2 = min(MIN_DIST2, max(dist[2][i], dist[3][i]));\n\n        return max(max(D1, D2), MIN_DIST1+MIN_DIST2+1);\n    }\n};",
    "submit_ts": "1719717841",
    "subm_id": "1304402123"
}