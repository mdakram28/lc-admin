{
    "username": "b10507102",
    "submission": "class Solution {\npublic:\n    long long minimumCost(int m, int n, vector<int>& horizontalCut, vector<int>& verticalCut) {\n        //The cnt for hor need to count at one cur;\n        long long hor_cnt = 1;\n        long long hor_idx = 0;\n        long long hor_cut = m - 1;\n        //The cnt for ver need to count at one cur;\n        long long ver_cnt = 1;\n        long long ver_idx = 0;\n        long long ver_cut = n - 1;\n        long long res = 0;\n        sort(horizontalCut.begin(), horizontalCut.end(), std::greater<int>());\n        sort(verticalCut.begin(), verticalCut.end(), std::greater<int>());\n        \n        while (hor_idx < hor_cut && ver_idx < ver_cut) {\n            if (horizontalCut[hor_idx] > verticalCut[ver_idx]) {\n                res += (horizontalCut[hor_idx] * hor_cnt);\n                //Evert cut in hor will make the need of cut in ver more.\n                ++ver_cnt;\n                ++hor_idx;\n            } else {\n                res += (verticalCut[ver_idx] * ver_cnt);\n                //The same reason in hor.\n                ++hor_cnt;\n                ++ver_idx;\n            }\n        }\n        \n        while (hor_idx < hor_cut) {\n            res += (horizontalCut[hor_idx] * hor_cnt);\n            ++hor_idx;\n        }\n        \n        while (ver_idx < ver_cut) {\n            res += (verticalCut[ver_idx] * ver_cnt);\n            ++ver_idx;\n        }\n        \n        \n        return res;\n    }\n};",
    "submit_ts": "1720925877",
    "subm_id": "1320269122"
}