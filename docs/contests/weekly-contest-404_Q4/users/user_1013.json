{
    "username": "chaitanyaarora30",
    "submission": "class Solution {\npublic:\n   vector<vector<int>> buildGraph(int num, vector<vector<int>> &edges)\n    {\n        vector<vector<int>> adjacencyList(num);\n        for ( auto &edge : edges)\n        {\n            adjacencyList[edge[0]].push_back(edge[1]);\n            adjacencyList[edge[1]].push_back(edge[0]);\n        }\n        return adjacencyList;\n    }\n\n    \n    \npair<int, int> bfsFarthest(int start, vector<vector<int>> &graph)\n{\n    vector<int> dist(graph.size(), -1);\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n    int farthest = start;\n\n    while (!q.empty())\n    {\n        int current = q.front();\n        q.pop();\n\n        for (int nebor : graph[current])\n        {\n            if (dist[nebor] == -1)\n            {\n                dist[nebor] = dist[current] + 1;\n                if (dist[nebor] > dist[farthest])\n                {\n                    farthest = nebor;\n                }\n                q.push(nebor);\n            }\n        }\n    }\n\n    vector<int> dist2(graph.size(), -1);\n    queue<int> q2;\n    q2.push(farthest);\n    dist2[farthest] = 0;\n\n    while (!q2.empty())\n    {\n        int current = q2.front();\n        q2.pop();\n\n        for (int nebor : graph[current])\n        {\n            if (dist2[nebor] == -1)\n            {\n                dist2[nebor] = dist2[current] + 1;\n                if (dist2[nebor] > dist2[farthest])\n                {\n                    farthest = nebor;\n                }\n                q2.push(nebor);\n            }\n        }\n    }\n\n\n    return {farthest, dist2[farthest]};\n}\n    \n    int computeDiameter(vector<vector<int>> & graph)\n    {\n        int diam = bfsFarthest(0, graph).second;\n        return diam;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>> & edges1, vector<vector<int>> & edges2)\n    {\n        vector<vector<int>> graphTree1 = buildGraph(edges1.size() + 1, edges1);\n        vector<vector<int>> graphTree2 = buildGraph(edges2.size() + 1, edges2);\n\n        int diam1 = computeDiameter(graphTree1);\n        int diam2 = computeDiameter(graphTree2);\n\n        int half1 = (diam1 + 1) / 2;\n        int half2 = (diam2 + 1) / 2;\n        int mergemin = max({diam1, diam2, half1 + half2 + 1});\n\n        return mergemin;\n    }\n};",
    "submit_ts": "1719718556",
    "subm_id": "1304420194"
}