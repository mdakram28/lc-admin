{
    "username": "pinaki_basu",
    "submission": "#define vi vector<int>\n#define vvi vector<vi>\n\nclass Solution {\n\n\n    void updateTree (vi& sTree, vi& lazy, int idx, int start, int end, int qs, int qe, int num) {\n        if (lazy[idx] != 0) {\n            if (start != end) {\n                lazy[2*idx+1] = lazy[2*idx+1] + lazy[idx];\n                lazy[2*idx+2] = lazy[2*idx+2] + lazy[idx];\n            }\n            sTree[idx] = sTree[idx] + lazy[idx];\n            lazy[idx] = 0;\n        }\n        if (qs>end || qe<start) return;\n        if (start>=qs && end<=qe) {\n            sTree[idx] = num + sTree[idx];\n            if (start != end) {\n                lazy[2*idx+1] = lazy[2*idx+1] + num;\n                lazy[2*idx+2] = lazy[2*idx+2] + num;\n            }\n            return;\n        }\n        int mid = (start+end)/2;\n        updateTree (sTree, lazy, 2*idx+1, start, mid, qs, qe, num);\n        updateTree (sTree, lazy, 2*idx+2, mid+1, end, qs, qe, num);\n    }\n\n    int queryTree (vi& sTree, vi& lazy, int idx, int start, int end, int k) {\n        if (lazy[idx] != 0) {\n            if (start != end) {\n                lazy[2*idx+1] = lazy[2*idx+1] + lazy[idx];\n                lazy[2*idx+2] = lazy[2*idx+2] + lazy[idx];\n            }\n            sTree[idx] = sTree[idx] + lazy[idx];\n            lazy[idx] = 0;\n        }\n        if (start==k && end==k) {\n            return sTree[idx];\n        }\n        int mid = (start+end)/2;\n        if (k<=mid) return queryTree(sTree, lazy, 2*idx+1, start, mid, k);\n        else return queryTree(sTree, lazy, 2*idx+2, mid+1, end, k);\n    }\n\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vi sTree(4*n+5, 0), lazy(4*n+5, 0);\n        vi ans;\n        //sTree[idx] keeps min skip in region l to r\n        \n        set<pair<int,int>> overlap;\n\n        for (auto& query : queries) {\n            pair<int,int> currQuery = {query[0], query[1]};\n            bool compute = true;\n            \n            auto it = overlap.upper_bound(currQuery);\n            if (it != overlap.end() && it->first == query[0]) compute = false;\n            else {\n                if (it != overlap.begin()) it--;    \n                if (it->first<=query[0] && it->second>=query[1]) compute = false;\n                else {\n                    if (it!=overlap.end() && it->first < query[0]) it++;\n                    //cout<<currQuery.first<<\", \"<<currQuery.second<<\" starts from \"<<it->first<<\", \"<<it->second<<endl;\n                    while (it!=overlap.end() && it->second <= query[1]) {\n                        //cout<<currQuery.first<<\", \"<<currQuery.second<<\" deletes \"<<it->first<<\", \"<<it->second<<endl;\n                        int negativeUpdate = it->second - it->first - 1;\n                        updateTree (sTree, lazy, 0, 0, n-1, 0, it->first, -1*negativeUpdate);\n                        auto it2 = it;\n                        it++;\n                        overlap.erase(it2);\n                    }\n                }\n            }\n            \n                \n            \n            if (!compute) {\n                int prev = ans.back();\n                ans.push_back(prev);\n                continue;\n            }\n            overlap.insert(currQuery);\n            int skip = query[1] - query[0] - 1;\n            //cout<<query[0]<<\" -> \"<<lastSkip<<\" :: \"<<skip<<endl;\n            updateTree(sTree, lazy, 0, 0, n-1, 0, query[0], skip);\n            int shortAns = queryTree(sTree, lazy, 0, 0, n-1, 0);\n            ans.push_back(n-1-shortAns);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722743300",
    "subm_id": "1343788824"
}