{
    "username": "XAXAEBATb",
    "submission": "class Solution {\npublic:\n    \n/*\nAPI\nALL IN LONG\n\nconstruction - SegTreeInitMany t(size, func) (func can be one of {\"max\", \"min\", \"sum\"})\ninit(l, r, new_val) - set all values of a[l..r] to new_val (1 - index)\nDepends on func:\nsum(l, r)  - calc sum of elements with positions [l; r] (1 - index)\nmax(l, r)  - calc max of elements with positions [l; r] (1 - index)\nmin(l, r)  - calc min of elements with positions [l; r] (1 - index)\n*/\n\n/*\nAPI\nALL IN LONG\n\nconstruction - SegTreeChangeOne t(size, func) (func can be one of {\"max\", \"min\", \"sum\", \"gcd\"})\nadd(pos, val) - add val to a[pos] (1 - index)\ninit(pos, new_val) - set a[pos] = new_val (1 - index)\nDepends on func:\nsum(l, r)  - calc sum of elements with positions [l; r] (1 - index)\nmax(l, r)  - calc max of elements with positions [l; r] (1 - index)\nmin(l, r)  - calc min of elements with positions [l; r] (1 - index)\ngcd(l, r)  - calc gcd of elements with positions [l; r] (1 - index)\n*/\n\nstruct SegTreeChangeOne {\n    int myGcd(int a, int b) {\n        if (a==-1) return b;\n        if (b==-1) return a;\n        return std::gcd(a,b);\n    }\n\n    SegTreeChangeOne(int sz, string function) {\n        localSz = sz;\n        t.resize(4 * sz + 5);\n        func = function;\n    }\n\n    int localMin (int v, int tl, int tr, int l, int r) {\n    \tif (l > r)\n    \t\treturn INF;\n    \tif (l == tl && r == tr)\n    \t\treturn t[v];\n    \tint tm = (tl + tr) / 2;\n    \treturn std::min(localMin (v*2, tl, tm, l, std::min(r,tm)), localMin (v*2+1, tm+1, tr, std::max(l,tm+1), r));\n    }\n\n    int localMax (int v, int tl, int tr, int l, int r) {\n    \tif (l > r)\n    \t\treturn -INF;\n    \tif (l == tl && r == tr)\n    \t\treturn t[v];\n    \tint tm = (tl + tr) / 2;\n    \treturn std::max(localMax (v*2, tl, tm, l, std::min(r,tm)), localMax (v*2+1, tm+1, tr, std::max(l,tm+1), r));\n    }\n\n    int it = 0;\n\n    int localSum (int v, int tl, int tr, int l, int r) {\n    \tif (l > r)\n    \t\treturn 0;\n    \tif (l == tl && r == tr)\n    \t\treturn t[v];\n    \tint tm = (tl + tr) / 2;\n    \treturn localSum (v*2, tl, tm, l, std::min(r,tm)) + localSum (v*2+1, tm+1, tr, std::max(l,tm+1), r);\n    }\n\n    int localGcd (int v, int tl, int tr, int l, int r) {\n    \tif (l > r)\n    \t\treturn -1;\n    \tif (l == tl && r == tr)\n    \t\treturn t[v];\n    \tint tm = (tl + tr) / 2;\n    \treturn myGcd(localGcd (v*2, tl, tm, l, std::min(r,tm)), localGcd (v*2+1, tm+1, tr, std::max(l,tm+1), r));\n    }\n\n    void localAdd (int v, int tl, int tr, int pos, int val) {\n    \tif (tl == tr)\n    \t\tt[v] += val;\n    \telse {\n    \t\tint tm = (tl + tr) / 2;\n    \t\tif (pos <= tm)\n    \t\t\tlocalAdd (v*2, tl, tm, pos, val);\n    \t\telse\n    \t\t\tlocalAdd (v*2+1, tm+1, tr, pos, val);\n    \t\tif (func == \"sum\") {\n    \t\t    t[v] = t[v*2] + t[v*2+1];\n    \t\t}\n    \t\tif (func == \"max\") {\n    \t\t    t[v] = std::max(t[v*2], t[v*2+1]);\n    \t\t}\n    \t\tif (func == \"min\") {\n    \t\t    t[v] = std::min(t[v*2], t[v*2+1]);\n    \t\t}\n    \t\tif (func == \"gcd\") {\n    \t\t    t[v] = myGcd(t[v*2], t[v*2+1]);\n    \t\t}\n    \t}\n    }\n\n    void localInit (int v, int tl, int tr, int pos, int new_val) {\n    \tif (tl == tr)\n    \t\tt[v] = new_val;\n    \telse {\n    \t\tint tm = (tl + tr) / 2;\n    \t\tif (pos <= tm)\n    \t\t\tlocalInit (v*2, tl, tm, pos, new_val);\n    \t\telse\n    \t\t\tlocalInit (v*2+1, tm+1, tr, pos, new_val);\n    \t\tif (func == \"sum\") {\n    \t\t    t[v] = t[v*2] + t[v*2+1];\n    \t\t}\n    \t\tif (func == \"max\") {\n    \t\t    t[v] = std::max(t[v*2], t[v*2+1]);\n    \t\t}\n    \t\tif (func == \"min\") {\n    \t\t    t[v] = std::min(t[v*2], t[v*2+1]);\n    \t\t}\n    \t\tif (func == \"gcd\") {\n    \t\t    t[v] = myGcd(t[v*2], t[v*2+1]);\n    \t\t}\n    \t}\n    }\n\n\n\n    int min(int l, int r) {\n        return localMin(1, 1, localSz, l,r);\n    }\n\n    int max(int l, int r) {\n        return localMax(1, 1, localSz, l,r);\n    }\n\n    int sum(int l, int r) {\n        return localSum(1, 1, localSz, l,r);\n    }\n\n    int gcd(int l, int r) {\n        return localGcd(1, 1, localSz, l,r);\n    }\n\n    void add(int pos, int val) {\n        localAdd(1, 1, localSz, pos, val);\n    }\n\n    void init(int pos, int new_val) {\n        localInit(1, 1, localSz, pos, new_val);\n    }\n\n    vector <int> t;\n    int localSz;\n    const int INF = 1000000000;\n    string func;\n};\n    \n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector <bool> ans;\n        vector <int> pepega;\n        pepega.push_back(0);\n        pepega.push_back(1000000);\n        for (auto& q:queries) {\n            if (q[0]==1) {\n                pepega.push_back(q[1]);\n            }\n        }\n        sort(pepega.begin(), pepega.end());\n        SegTreeChangeOne t(100001, \"max\");\n        SegTreeChangeOne t2(100001, \"max\");\n        for (int i=0;i+1<pepega.size();i++) {\n            t.init(pepega[i]+1,  pepega[i+1]-pepega[i]);\n            t2.init(pepega[i]+1, pepega[i]);\n        }\n        for (int i=queries.size()-1;i>=0;i--) {\n            auto q = queries[i];\n            if (q[0]==2) {\n                \n                auto pp = t.max(1, q[1]-q[2]+1);\n                // cout<<pp<<\"\\n\";\n                ans.push_back(pp>=q[2]);\n            } else {\n                auto pp = q[1];\n                auto prev_value = t.max(pp+1, pp+1);\n                t2.init(pp+1, 0);\n                auto prev_pp = t2.max(1, pp+1);\n                t.init(prev_pp+1,  t.max(prev_pp+1, prev_pp+1) + prev_value);\n            }\n        }\n        \n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};",
    "submit_ts": "1716649922",
    "subm_id": "1267601485"
}