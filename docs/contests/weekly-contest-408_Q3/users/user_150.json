{
    "username": "PyIsTheBestLang",
    "submission": "from collections import defaultdict\n\n\n# sys.set_int_max_str_digits(0)  # for big number in leet code\n\n\ndef max(a, b):\n    return a if a > b else b\n\n\ndef min(a, b):\n    return a if a < b else b\n\n\nclass UnionFind:\n    def __init__(self, n: int) -> None:\n        self.root_or_size = [-1] * n\n        self.part = n\n        self.n = n\n        return\n\n    def initialize(self):\n        for i in range(self.n):\n            self.root_or_size[i] = -1\n        self.part = self.n\n        return\n\n    def find(self, x):\n        y = x\n        while self.root_or_size[x] >= 0:\n            # range_merge_to_disjoint to the direct root node after query\n            x = self.root_or_size[x]\n        while y != x:\n            self.root_or_size[y], y = x, self.root_or_size[y]\n        return x\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        if self.root_or_size[root_x] < self.root_or_size[root_y]:\n            root_x, root_y = root_y, root_x\n        self.root_or_size[root_y] += self.root_or_size[root_x]\n        self.root_or_size[root_x] = root_y\n        self.part -= 1\n        return True\n\n    def union_left(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        self.root_or_size[root_x] += self.root_or_size[root_y]\n        self.root_or_size[root_y] = root_x\n        self.part -= 1\n        return True\n\n    def union_right(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        self.root_or_size[root_y] += self.root_or_size[root_x]\n        self.root_or_size[root_x] = root_y\n        self.part -= 1\n        return True\n\n    def union_max(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        if root_x > root_y:\n            root_x, root_y = root_y, root_x\n        self.root_or_size[root_y] += self.root_or_size[root_x]\n        self.root_or_size[root_x] = root_y\n        self.part -= 1\n        return\n\n    def union_min(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        if root_x < root_y:\n            root_x, root_y = root_y, root_x\n        self.root_or_size[root_y] += self.root_or_size[root_x]\n        self.root_or_size[root_x] = root_y\n        self.part -= 1\n        return\n\n    def is_connected(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return -self.root_or_size[self.find(x)]\n\n    def get_root_part(self):\n        # get the nodes list of every root\n        part = defaultdict(list)\n        n = len(self.root_or_size)\n        for i in range(n):\n            part[self.find(i)].append(i)\n        return part\n\n    def get_root_size(self):\n        # get the size of every root\n        size = defaultdict(int)\n        n = len(self.root_or_size)\n        for i in range(n):\n            if self.find(i) == i:\n                size[i] = -self.root_or_size[i]\n        return size\n\n\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        # s = [str(random.randint(0, 1)) for _ in range(40000)]\n        n = len(s)\n        uf2 = UnionFind(n)\n        for i in range(n - 2, -1, -1):\n            if s[i] == s[i + 1] == \"1\":\n                uf2.union_right(i, i + 1)\n\n        uf1 = UnionFind(n)\n        for i in range(n - 2, -1, -1):\n            if s[i] == s[i + 1] == \"1\":\n                uf1.union_left(i, i + 1)\n\n        ans = 0\n        one = 0\n        for w in s:\n            if w == \"1\":\n                one += 1\n            else:\n                if one:\n                    ans += one * (one + 1) // 2\n                one = 0\n        ans += one * (one + 1) // 2\n        lst = [i for i in range(n) if s[i] == \"0\"]\n        k = len(lst)\n        for x in range(1, k + 1):\n            if x * x > n:\n                break\n            for i in range(k - x + 1):\n                ll = lst[i]\n                rr = lst[i + x - 1]\n                zero = x\n                one = rr - ll + 1 - zero\n                if ll and s[ll - 1] == \"1\":\n                    left = ll - uf1.find(ll - 1)\n                else:\n                    left = 0\n\n                if rr + 1 < n and s[rr + 1] == \"1\":\n                    right = uf2.find(rr + 1) - rr\n                else:\n                    right = 0\n                if left + right + one < x * x:\n                    continue\n                if one >= x * x:\n                    ans += (left + 1) * (right + 1)\n                    continue\n                # ans += (left + 1) * (right + 1)\n                # if not left:\n                #     ans -= x * x - one\n                #     continue\n                # if left +one>=x*x:\n\n                # ceil = min(left, x * x - one)\n                # end = x * x - one\n                # start = x * x - one - ceil\n                # ans -= (start + end) * (end - start + 1) // 2\n\n                for y in range(left+1):\n                    if y+one+right>=x*x:\n                        low = max(0, x*x-y-one)\n                        ans += right-low+1\n                # print(ans)\n        return ans\n\n\n# assert Solution().numberOfSubstrings(\"00011\") == 5\n# assert Solution().numberOfSubstrings(\"101101\") == 16\n# assert Solution().numberOfSubstrings(\"000110011\") == 13\n",
    "submit_ts": "1722136760",
    "subm_id": "1335744162"
}