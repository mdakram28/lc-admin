{
    "username": "dingmingcheng1",
    "submission": "class Solution {\n        static class NumberTheory {\n        long x, y, q;\n\n        long mod = 1000000007L;\n        long fab[];\n\n        long Pow(long a, long n, long p) {\n            long x = a;\n            long res = 1;\n            while (n > 0) {\n                if ((n & 1) != 0) {\n                    res = ((long) res * (long) x) % p;\n                }\n                n >>= 1;\n                x = ((long) x * (long) x) % p;\n            }\n            return res;\n        }\n\n        long Cm(long n, long m, long p) {\n            long a = 1, b = 1;\n            if (m > n) {\n                return 0;\n            }\n            //\u5b9e\u73b0(a!/(a-b)!) * (b!)^(p-2)) mod p,\u7531\u4e8en\u6bd4\u8f83\u5927\uff0c\u6240\u4ee5\uff0c\u6b64\u5904\u4e0d\u77e5\u9053\u6709\u4ec0\u4e48\u597d\u7684\u4f18\u5316\n            while (m > 0) {\n                a = (a * n) % p;\n                b = (b * m) % p;\n                m--;\n                n--;\n            }\n            return ((long) a * (long) Pow(b, p - 2, p)) % p;\n        }\n\n        long Lucas(long n, long m, long p) {\n            if (m == 0) {\n                return 1;\n            }\n            return ((long) Cm(n % p, m % p, p) * (long) Lucas(n / p, m / p, p)) % p;\n        }\n\n        //\u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\n        void ExEuclid(long a, long b) {\n            if (b == 0) {\n                x = 1;\n                y = 0;\n                q = a;\n                return;\n            }\n            ExEuclid(b, a % b);\n            long tmp = x;\n            x = y;\n            y = tmp - y * (a / b);\n        }\n\n        //\u4e58\u6cd5\u9006\u5143\n        long inv(long num, long mo1d) {\n            mod = mo1d;\n            ExEuclid(num, mod);\n            return (x + mod) % mod;\n        }\n\n        //\u4e58\u6cd5\u9006\u5143\n        long inv(long num) {\n            ExEuclid(num, mod);\n            return (x + mod) % mod;\n        }\n        long tempInv(int n) {\n\n            long a1 = CRT(3, new int[]{0, 1, (int) inv(n, 5), (int) inv(n, 823)}, new int[]{0, 1,5,823});\n            return a1;\n        }\n\n        long CRT(int k, int[] a, int[] r) {\n            long n = 12345, ans = 0;\n            for (int i = 1; i <= k; i++) {\n                long m = n / r[i];\n                ExEuclid(m, r[i]);  // b * m mod r[i] = 1\n                ans = (ans + n + (a[i] * m * x + n) % n) % n;\n            }\n            return (ans % n + n) % n;\n        }\n\n        //\u7ec4\u5408\u6570\n        long C(int n, int k) {\n            long res = fab[n] * inv(fab[k]);\n            res %= mod;\n            res *= inv(fab[n - k]);\n            res %= mod;\n            return res;\n        }\n\n        void init(int n) {\n            fab = new long[n + 1];\n            fab[0] = 1;\n            for (int i = 1; i <= n; i++) {\n                fab[i] = fab[i - 1] * i;\n                fab[i] %= mod;\n            }\n        }\n\n\n        boolean[] isPrime;\n        int[] prime;\n        int primeCnt;\n        int[] phi;\n\n        //\u7b5b\u6cd5\u6c42\u7d20\u6570,maxN\u4e3a\u7d20\u6570\u4e0a\u9650\uff0cprime\u4ee3\u8868\u5b58\u7684\u7d20\u6570\uff0cisPrime\u5224\u65ad\u662f\u5426\u4e3a\u7d20\u6570\n        public void prime(int maxN) {\n            primeCnt = 0;\n            isPrime = new boolean[maxN + 5];\n            prime = new int[1000000];\n            Arrays.fill(isPrime, true);\n            isPrime[0] = false;\n            isPrime[1] = false;\n            for (int i = 2; i <= maxN; i++) {\n                if (isPrime[i]) {//\u5982\u679c\u662f\u7d20\u6570\uff0c\u628a\u5b83\u5b58\u5230\u6570\u7ec4\u91cc\uff0c\u540c\u65f6\u4e2a\u6570+1\n                    prime[primeCnt++] = i;\n                }\n                for (int j = 1; j <= primeCnt; j++) {\n                    isPrime[i * prime[j]] = false;\n                    if (i % prime[j] == 0) {//\u8fd9\u4e00\u53e5\u662f\u6574\u4e2a\u7b97\u6cd5\u7684\u6838\u5fc3\uff0c\u4e0b\u9762\u4f1a\u8bf4\u5230\n                        break;\n                    }\n                }\n            }\n        }\n\n        //\u7b5b\u6cd5\u6c42\u6b27\u62c9\u51fd\u6570\n        public void eularPre(int maxN) {\n            primeCnt = 0;\n            isPrime = new boolean[maxN + 5];\n            Arrays.fill(isPrime, true);\n            phi = new int[maxN + 5];\n            prime = new int[1000000];\n            isPrime[0] = false;\n            isPrime[1] = false;\n            phi[1] = 1;\n            for (int i = 2; i <= maxN; i++) {\n                if (isPrime[i]) {\n                    prime[++primeCnt] = i;\n                    phi[i] = i - 1;\n                }\n                for (int j = 1; j <= primeCnt && i * prime[j] <= maxN; j++) {\n                    isPrime[i * prime[j]] = false;\n                    if (i % prime[j] > 0)\n                        phi[i * prime[j]] = phi[i] * phi[prime[j]];\n                    else {\n                        phi[i * prime[j]] = phi[i] * prime[j];\n                        break;\n                    }\n                }\n            }\n        }\n\n        // \u6c42\u67d0\u4e2a\u6570\u7684\u6b27\u62c9\u51fd\u6570\u503c\n        int eulerPhi(int n) {\n            int ans = n;\n            for (int i = 2; i * i <= n; i++)\n                if (n % i == 0) {\n                    ans = ans / i * (i - 1);\n                    while (n % i == 0) n /= i;\n                }\n            if (n > 1) ans = ans / n * (n - 1);\n            return ans;\n        }\n\n        // \u5206\u89e3\u8d28\u56e0\u5b50\n        public List<Integer> primeFactor(int n) {\n            List<Integer> ans = new ArrayList<>();\n            for (int i = 2; i * i <= n; i++) {\n                if (n % i == 0) {\n                    ans.add(i);\n                    while (n % i == 0) {\n                        n /= i;\n                    }\n                }\n            }\n            if (n > 1) {\n                ans.add(n);\n            }\n            return ans;\n        }\n\n        // \u5206\u89e3\u56e0\u5b50\n        public List<Integer> factor(int n) {\n            List<Integer> ans = new ArrayList<>();\n            for (int i = 1; i * i <= n; i++) {\n                if (n % i == 0) {\n                    ans.add(i);\n                    ans.add(n / i);\n                }\n            }\n            return ans;\n        }\n    }\n\n        public int lowerBound2(List<Integer> arr, int v) {\n        int l = 0;\n        int r = arr.size() - 1;\n        int ans = -1;\n        while (l <= r) {\n            int mid = (l + r) >> 1;\n            boolean check = arr.get(mid) >= v;\n            if (check) {\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n    public int waysToReachStair(int k) {\n        if (k == 1) {\n            return 4;\n        } else if (k == 2) {\n            return 4;\n        } else if (k == 4) {\n            return 2;\n        } else if (k == 0) {\n            return 2;\n        }\n        List<Integer> l = new ArrayList<>();\n        int t = 2;\n        for (int i = 0; i < 30; i++) {\n            l.add(t);\n            t *= 2;\n        }\n        int kt = lowerBound2(l, k);\n        int idx = kt + 1;\n        NumberTheory n = new NumberTheory();\n        int nt = idx + 1;\n        int mt = l.get(kt) - k;\n        if (mt > nt) return 0;\n        n.init(50);\n        long ans = n.C(nt, mt);\n        return (int) ans;\n    }\n\n}",
    "submit_ts": 1716089123.0
}