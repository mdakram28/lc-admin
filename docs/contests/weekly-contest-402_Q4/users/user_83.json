{
    "username": "JeffreyLC",
    "submission": "class SegmentTree {\n public:\n    explicit SegmentTree(const vector<int>& nums, const function<int(int, int)>& func, int init) : func_(func), init_(init) {\n        n_ = nums.size();\n        segs_.resize(n_ << 2, 0);\n        Build(nums, 0, n_ - 1, 1);\n    }\n    \n    int Query(int lq, int rq) {\n        if (lq > rq) return 0;\n        return QueryUtil(0, n_ - 1, 1, lq, rq);\n    }\n    \n    void Update(int k, int v) {\n        UpdateUtil(0, n_ - 1, 1, k, v);\n    }\n    \n private:\n    int n_;\n    function<int(int, int)> func_;\n    int init_;\n    vector<int> segs_;\n    \n    void Build(const vector<int>& nums, int l, int r, int id) {\n        if (l == r) {\n            segs_[id] = nums[l];\n        } else {\n            int mid = (l + r) >> 1;\n            Build(nums, l, mid, id * 2);\n            Build(nums, mid + 1, r, id * 2 + 1);\n            segs_[id] = func_(segs_[id * 2], segs_[id * 2 + 1]);\n        }\n    }\n    \n    int QueryUtil(int l, int r, int id, int lq, int rq) {\n        if (r < lq || l > rq) return init_;\n        if (lq <= l && r <= rq) return segs_[id];\n        int mid = (l + r) >> 1;\n        return func_(QueryUtil(l, mid, id * 2, lq, rq), QueryUtil(mid + 1, r, id * 2 + 1, lq, rq));\n    }\n    \n    void UpdateUtil(int l, int r, int id, int k, int v) {\n        if (l == r) {\n            segs_[id] = v;\n        } else {\n            int mid = (l + r) >> 1;\n            if (k <= mid) {\n                UpdateUtil(l, mid, id * 2, k, v);\n            } else { \n                UpdateUtil(mid + 1, r, id * 2 + 1, k, v);\n            }\n            segs_[id] = func_(segs_[id * 2], segs_[id * 2 + 1]);\n        }\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        const int n = nums.size();\n        vector<int> v(n);\n        for (int i = 1; i < n - 1; ++i) {\n            if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {\n                v[i] = 1;\n            }\n        }\n        SegmentTree seg_tree = SegmentTree(v, [](int x, int y) -> int {\n            return x + y;\n        }, 0);\n        vector<int> ans;\n        for (const vector<int>& q : queries) {\n            if (q[0] == 1) {\n                ans.push_back(seg_tree.Query(q[1] + 1, q[2] - 1));\n            } else {\n                nums[q[1]] = q[2];\n                for (int i = q[1] - 1; i <= q[1] + 1; ++i) {\n                    if (i > 0 && i < n - 1) {\n                        v[i] = (nums[i] > nums[i - 1] && nums[i] > nums[i + 1] ? 1 : 0);\n                        seg_tree.Update(i, v[i]);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718506483.0
}