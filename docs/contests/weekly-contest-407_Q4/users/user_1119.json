{
    "username": "aishwarykesarwani",
    "submission": "#include <vector>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <unordered_set>\n\nusing namespace std;\n\nclass SegmentTree {\npublic:\n    struct Node {\n        int value;\n        int index;\n        Node(int v = INT_MAX, int i = -1) : value(v), index(i) {}\n    };\n\n    SegmentTree(const vector<int>& array) {\n        n = array.size();\n        int height = (int)ceil(log2(n));\n        int maxSize = 2 * (int)pow(2, height) - 1;\n        tree.resize(maxSize, Node());\n        lazy.resize(maxSize, 0);\n        buildTree(array, 0, n - 1, 0);\n    }\n\n    Node getMin(int qs, int qe) {\n        if (qs < 0 || qe > n - 1 || qs > qe) {\n            throw invalid_argument(\"Invalid range\");\n        }\n        return getMinUtil(0, n - 1, qs, qe, 0);\n    }\n\n    void updateRange(int l, int r, int value) {\n        updateRangeUtil(0, n - 1, l, r, value, 0);\n    }\n\nprivate:\n    int n;\n    vector<Node> tree;\n    vector<int> lazy;\n\n    void buildTree(const vector<int>& array, int start, int end, int node) {\n        if (start == end) {\n            tree[node] = Node(array[start], start);\n        } else {\n            int mid = start + (end - start) / 2;\n            buildTree(array, start, mid, 2 * node + 1);\n            buildTree(array, mid + 1, end, 2 * node + 2);\n            tree[node] = minNode(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    Node getMinUtil(int start, int end, int qs, int qe, int node) {\n        if (lazy[node] != 0) {\n            tree[node].value -= lazy[node];\n            if (start != end) {\n                lazy[2 * node + 1] += lazy[node];\n                lazy[2 * node + 2] += lazy[node];\n            }\n            lazy[node] = 0;\n        }\n\n        if (qs <= start && qe >= end) {\n            return tree[node];\n        }\n        if (end < qs || start > qe) {\n            return Node(INT_MAX, -1);\n        }\n        int mid = start + (end - start) / 2;\n        Node leftMin = getMinUtil(start, mid, qs, qe, 2 * node + 1);\n        Node rightMin = getMinUtil(mid + 1, end, qs, qe, 2 * node + 2);\n        return minNode(leftMin, rightMin);\n    }\n\n    void updateRangeUtil(int start, int end, int l, int r, int value, int node) {\n        if (lazy[node] != 0) {\n            tree[node].value -= lazy[node];\n            if (start != end) {\n                lazy[2 * node + 1] += lazy[node];\n                lazy[2 * node + 2] += lazy[node];\n            }\n            lazy[node] = 0;\n        }\n\n        if (start > end || start > r || end < l) {\n            return;\n        }\n\n        if (start >= l && end <= r) {\n            tree[node].value -= value;\n            if (start != end) {\n                lazy[2 * node + 1] += value;\n                lazy[2 * node + 2] += value;\n            }\n            return;\n        }\n\n        int mid = start + (end - start) / 2;\n        updateRangeUtil(start, mid, l, r, value, 2 * node + 1);\n        updateRangeUtil(mid + 1, end, l, r, value, 2 * node + 2);\n        tree[node] = minNode(tree[2 * node + 1], tree[2 * node + 2]);\n    }\n\n    Node minNode(const Node& a, const Node& b) {\n        if (a.value < b.value) {\n            return a;\n        } else if (a.value > b.value) {\n            return b;\n        } else {\n            return a.index < b.index ? a : b;\n        }\n    }\n};\n\nclass Pair {\npublic:\n    int a, b;\n    Pair(int x, int y) : a(x), b(y) {}\n    bool operator<(const Pair& other) const {\n        return a < other.a || (a == other.a && b < other.b);\n    }\n    friend ostream& operator<<(ostream& os, const Pair& p) {\n        os << p.a << \" \" << p.b;\n        return os;\n    }\n};\n\nclass Solution {\npublic:\n    long long minimumOperations(vector<int>& a, vector<int>& b) {\n        int n = a.size();\n        vector<int> d(n);\n        for (int i = 0; i < n; ++i) {\n            d[i] = a[i] - b[i];\n        }\n        vector<int> abs_d(n);\n        for (int i = 0; i < n; ++i) {\n            abs_d[i] = abs(d[i]);\n        }\n        SegmentTree st(abs_d);\n        set<Pair> h;\n        int k = 0; // -ve\n        if (d[0] >= 0) k = 1;\n        int last = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i == 0) continue;\n            if (d[i] >= 0) {\n                if (k == 1) {\n\n                } else {\n                    h.insert(Pair(last, i - 1));\n                    last = i;\n                    k = 1;\n                }\n            } else {\n                if (k == 1) {\n                    h.insert(Pair(last, i - 1));\n                    last = i;\n                    k = 0;\n                }\n            }\n        }\n        h.insert(Pair(last, n - 1));\n        long long ans = 0;\n        while (!h.empty()) {\n            auto it = h.begin();\n            Pair pp = *it;\n            if (pp.a == pp.b || pp.a > pp.b) {\n                if (pp.a == pp.b) ans += st.getMin(pp.a, pp.b).value;\n                h.erase(it);\n                continue;\n            }\n\n            SegmentTree::Node dd = st.getMin(pp.a, pp.b);\n\n            int x = pp.a;\n            int y = pp.b;\n            int min = dd.value;\n            int ind = dd.index;\n            ans += min;\n            st.updateRange(x, y, min);\n\n            h.erase(it);\n            if (x <= ind - 1) h.insert(Pair(x, ind - 1));\n            if (ind + 1 <= y) h.insert(Pair(ind + 1, y));\n        }\n        return ans;\n    }\n};\n",
    "submit_ts": "1721532114",
    "subm_id": "1327977989"
}