{
    "username": "piyush_razz",
    "submission": "class Solution\n{\npublic:\n#define pii pair<int, int>\n#define fi first\n#define se second\n#define pb push_back\n    int findMinHeightTrees(int n, vector<int>&degree, vector<vector<int>> &graph)\n    {\n        if (n == 1)\n            return 0; // Special case with only one node\n        \n        queue<int> leafQueue;\n        for (int i = 0; i < n; i++)\n        {\n            if (degree[i] == 1)\n                leafQueue.push(i);\n        }\n\n        int remainingNodes = n;\n        while (remainingNodes > 2)\n        {\n            int leafCount = leafQueue.size();\n            remainingNodes -= leafCount;\n            for (int i = 0; i < leafCount; i++)\n            {\n                int leaf = leafQueue.front();\n                leafQueue.pop();\n                for (int neighbor : graph[leaf])\n                {\n                    if (--degree[neighbor] == 1)\n                    {\n                        leafQueue.push(neighbor);\n                    }\n                }\n            }\n        }\n\n        vector<int> minHeightTrees;\n        while (!leafQueue.empty())\n        {\n            minHeightTrees.push_back(leafQueue.front());\n            leafQueue.pop();\n        }\n        int x = minHeightTrees[0];\n        vector<int>vis(n);\n        vector<int>dis(n);\n        dis[x]=0;\n        vis[x]=1;\n        queue<int>q;\n        q.push(x);\n        int ans=0;\n        while(!q.empty())\n        {\n            int x = q.front();\n            q.pop();\n            for(auto y : graph[x]){\n                if(vis[y]==0){\n                    q.push(y);\n                    dis[y] = 1 + dis[x];\n                    vis[y] = 1;\n                }\n            }\n        }\n        for(int i=0;i<n; i++){\n            ans = max(ans, dis[i]);\n        }\n        return ans;\n    }\n// Function to perform BFS and return the farthest node and its distance\npair<int, int> bfs(int start_node, const vector<vector<int>>& graph) {\n    int n = graph.size();\n    vector<bool> visited(n, false);\n    vector<int> distance(n, 0);\n    \n    queue<int> q;\n    q.push(start_node);\n    visited[start_node] = true;\n    \n    int farthest_node = start_node;\n    int max_distance = 0;\n    \n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        \n        for (int neighbor : graph[node]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                distance[neighbor] = distance[node] + 1;\n                q.push(neighbor);\n                \n                if (distance[neighbor] > max_distance) {\n                    max_distance = distance[neighbor];\n                    farthest_node = neighbor;\n                }\n            }\n        }\n    }\n    \n    return {farthest_node, max_distance};\n}\n\n// Function to find the diameter of the tree\nint tree_diameter(vector<vector<int>>& graph) {\n    // Step 1: Perform BFS from an arbitrary node (node 0)\n    pair<int, int> result = bfs(0, graph);\n    int farthest_node = result.first;\n    \n    // Step 2: Perform BFS from the farthest node found in step 1\n    result = bfs(farthest_node, graph);\n    \n    return result.second;\n}\n    int f(vector<vector<int>> &e1)\n    {\n        int n = e1.size();\n        n++;\n        vector<int> degree(n);\n        vector<vector<int>>adj(n);\n        for (int i = 0; i < e1.size(); i++)\n        {\n            int u = e1[i][0];\n            int v = e1[i][1];\n            degree[u]++;\n            degree[v]++;\n            adj[u].pb(v);\n            adj[v].pb(u);\n        }\n        int ans =findMinHeightTrees(n, degree, adj);\n        //int ans=0;\n        return ans;\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>> &e1, vector<vector<int>> &e2)\n    {\n        int ans = f(e1);\n        ans++;\n        ans += f(e2);\n        int n = e1.size()+1;\n        int m = e2.size()+1;\n        vector<vector<int>>adj(n);\n        for (int i = 0; i < e1.size(); i++)\n        {\n            int u = e1[i][0];\n            int v = e1[i][1];\n            adj[u].pb(v);\n            adj[v].pb(u);\n        }\n        ans = max(ans, tree_diameter(adj));\n        vector<vector<int>>adj1(m);\n        for (int i = 0; i < e2.size(); i++)\n        {\n            int u = e2[i][0];\n            int v = e2[i][1];\n            adj1[u].pb(v);\n            adj1[v].pb(u);\n        }\n        ans = max(ans, tree_diameter(adj1));\n        //cout << f(e1) << \" \" << f(e2) << endl;\n        return ans;\n    }\n};",
    "submit_ts": "1719719490",
    "subm_id": "1304443201"
}