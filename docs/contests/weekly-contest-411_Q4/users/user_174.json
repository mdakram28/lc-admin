{
    "username": "trchen",
    "submission": "using ll = long long;\n\nnamespace segment_tree_impl {\n\ntemplate <typename DataType, class Operator, bool LazyAssignment>\nstruct LazyAssignmentComponent {};\n\ntemplate <typename DataType, class Operator>\nstruct LazyAssignmentComponent<DataType, Operator, true> {\n  bool has_lazy_assignment = false;\n  DataType lazy_assignment = Operator::IncrementalIdentity();\n};\n\ntemplate <typename DataType, class Operator, bool LazyIncrement>\nstruct LazyIncrementComponent {};\n\ntemplate <typename DataType, class Operator>\nstruct LazyIncrementComponent<DataType, Operator, true> {\n  DataType lazy_increment = Operator::IncrementalIdentity();\n};\n\ntemplate <bool Persistent>\nstruct PersistentComponent {};\n\ntemplate <>\nstruct PersistentComponent<true> {\n  int left_child;\n  int right_child;\n};\n\ntemplate <typename DataType, class Operator, bool LazyAssignment, bool LazyIncrement,\n          bool Persistent>\nstruct SegmentTreeNode : public LazyAssignmentComponent<DataType, Operator, LazyAssignment>,\n                         public LazyIncrementComponent<DataType, Operator, LazyIncrement>,\n                         public PersistentComponent<Persistent> {\n  DataType value;\n};\n\n}  // namespace segment_tree_impl\n\ntemplate <typename DataType, class Operator, bool LazyAssignment = false,\n          bool LazyIncrement = false, bool Persistent = false>\nclass SegmentTree {\n  using Node = segment_tree_impl::SegmentTreeNode<DataType, Operator, LazyAssignment, LazyIncrement,\n                                                  Persistent>;\n\n public:\n  template <class RawContainer>\n  inline void Build(const RawContainer& raw_container) noexcept\n    requires (!Persistent) {\n    data_size_ = static_cast<int>(raw_container.size());\n    tree_.clear();\n    tree_.resize(4 * data_size_);\n    BuildRecursive(raw_container, 1, 0, data_size_ - 1);\n  }\n\n  template <class RawContainer>\n  inline int Build(const RawContainer& raw_container, int number_of_future_operations) noexcept\n    requires (Persistent) {\n    data_size_ = static_cast<int>(raw_container.size());\n    int size = data_size_;\n    int height = 1;\n    while (size > 1) {\n      ++height;\n      size /= 2;\n    }\n    tree_.clear();\n    tree_.resize(2 * data_size_ + 4 * height * number_of_future_operations);\n    next_valid_index_ = 1;\n    BuildRecursive(raw_container, 0, 0, data_size_ - 1);\n    return 0;\n  }\n\n  inline DataType Query(int left, int right) noexcept\n    requires (!Persistent) {\n    if (left > right) {\n      return Operator::Identity();\n    }\n    return QueryRecursive(1, 0, data_size_ - 1, left, right);\n  }\n\n  inline std::pair<DataType, int> Query(int left, int right, int root) noexcept\n    requires (Persistent) {\n    if (left > right) {\n      return { Operator::Identity(), root };\n    }\n    int new_root;\n    if constexpr (LazyAssignment || LazyIncrement) {\n      new_root = CopyRoot(root);\n    } else {\n      new_root = root;\n    }\n    return { QueryRecursive(new_root, 0, data_size_ - 1, left, right), new_root };\n  }\n\n private:\n  template <class RawContainer>\n  inline void BuildRecursive(const RawContainer& raw_container, int vertex, int segment_left,\n                             int segment_right) noexcept {\n    if (segment_left == segment_right) {\n      tree_[vertex].value = raw_container[segment_left];\n    } else {\n      if constexpr (Persistent) {\n        tree_[vertex].left_child = next_valid_index_;\n        ++next_valid_index_;\n        tree_[vertex].right_child = next_valid_index_;\n        ++next_valid_index_;\n      }\n      const int segment_middle = (segment_left + segment_right) / 2;\n      BuildRecursive(raw_container, LeftChild(vertex), segment_left, segment_middle);\n      BuildRecursive(raw_container, RightChild(vertex), segment_middle + 1, segment_right);\n      PushUp(vertex);\n    }\n  }\n\n  inline DataType QueryRecursive(int vertex, int segment_left, int segment_right, int left,\n                                 int right) noexcept {\n    if (segment_left == left && segment_right == right) {\n      return tree_[vertex].value;\n    }\n    PushDown(vertex, segment_left, segment_right);\n    const int segment_middle = (segment_left + segment_right) / 2;\n    if (right <= segment_middle) {\n      return QueryRecursive(LeftChild(vertex), segment_left, segment_middle, left, right);\n    }\n    if (left >= segment_middle + 1) {\n      return QueryRecursive(RightChild(vertex), segment_middle + 1, segment_right, left, right);\n    }\n    return Operator::Combine(\n        QueryRecursive(LeftChild(vertex), segment_left, segment_middle, left, segment_middle),\n        QueryRecursive(RightChild(vertex), segment_middle + 1, segment_right, segment_middle + 1,\n                       right));\n  }\n\n  [[nodiscard]] inline int LeftChild(int vertex) const noexcept {\n    if constexpr (Persistent) {\n      return tree_[vertex].left_child;\n    } else {\n      return 2 * vertex;\n    }\n  }\n\n  [[nodiscard]] inline int RightChild(int vertex) const noexcept {\n    if constexpr (Persistent) {\n      return tree_[vertex].right_child;\n    } else {\n      return 2 * vertex + 1;\n    }\n  }\n\n  [[nodiscard]] inline int CopyRoot(int root) noexcept {\n    const int new_root = next_valid_index_;\n    tree_[new_root] = tree_[root];\n    ++next_valid_index_;\n    return new_root;\n  }\n\n  template <bool BeforePushDown>\n  inline void CopyLeftChild(int vertex) noexcept {\n    if constexpr (Persistent && (BeforePushDown == (LazyAssignment || LazyIncrement))) {\n      tree_[next_valid_index_] = tree_[LeftChild(vertex)];\n      tree_[vertex].left_child = next_valid_index_;\n      ++next_valid_index_;\n    }\n  }\n\n  template <bool BeforePushDown>\n  inline void CopyRightChild(int vertex) noexcept {\n    if constexpr (Persistent && (BeforePushDown == (LazyAssignment || LazyIncrement))) {\n      tree_[next_valid_index_] = tree_[RightChild(vertex)];\n      tree_[vertex].right_child = next_valid_index_;\n      ++next_valid_index_;\n    }\n  }\n\n  inline void PushUp(int vertex) noexcept {\n    tree_[vertex].value =\n        Operator::Combine(tree_[LeftChild(vertex)].value, tree_[RightChild(vertex)].value);\n  }\n\n  inline void PushDown(int vertex, int segment_left, int segment_right) noexcept {\n    if constexpr (!LazyAssignment && !LazyIncrement) {\n      return;\n    } else {\n      CopyLeftChild<true>(vertex);\n      CopyRightChild<true>(vertex);\n      const int segment_middle = (segment_left + segment_right) / 2;\n      if constexpr (LazyAssignment) {\n        if (tree_[vertex].has_lazy_assignment) {\n          ReceiveLazyAssignment(LeftChild(vertex), segment_left, segment_middle,\n                                tree_[vertex].lazy_assignment);\n          ReceiveLazyAssignment(RightChild(vertex), segment_middle + 1, segment_right,\n                                tree_[vertex].lazy_assignment);\n          tree_[vertex].has_lazy_assignment = false;\n          tree_[vertex].lazy_assignment = Operator::IncrementalIdentity();\n          return;\n        }\n      }\n      if constexpr (LazyIncrement) {\n        if (tree_[vertex].lazy_increment != Operator::IncrementalIdentity()) {\n          ReceiveLazyIncrement(LeftChild(vertex), segment_left, segment_middle,\n                               tree_[vertex].lazy_increment);\n          ReceiveLazyIncrement(RightChild(vertex), segment_middle + 1, segment_right,\n                               tree_[vertex].lazy_increment);\n          tree_[vertex].lazy_increment = Operator::IncrementalIdentity();\n        }\n      }\n    }\n  }\n\n  inline void ReceiveLazyAssignment(int vertex, int segment_left, int segment_right,\n                                    const DataType& lazy_assignment) noexcept {\n    tree_[vertex].has_lazy_assignment = true;\n    tree_[vertex].lazy_assignment = lazy_assignment;\n    tree_[vertex].value =\n        Operator::CombineMultipleAssignments(lazy_assignment, segment_right - segment_left + 1);\n    if constexpr (LazyIncrement) {\n      tree_[vertex].lazy_increment = Operator::IncrementalIdentity();\n    }\n  }\n\n  inline void ReceiveLazyIncrement(int vertex, int segment_left, int segment_right,\n                                   const DataType& lazy_increment) noexcept {\n    if constexpr (LazyAssignment) {\n      if (!tree_[vertex].has_lazy_assignment) {\n        tree_[vertex].lazy_increment =\n            Operator::Increment(tree_[vertex].lazy_increment, lazy_increment);\n      } else {\n        tree_[vertex].lazy_assignment =\n            Operator::Increment(tree_[vertex].lazy_assignment, lazy_increment);\n        tree_[vertex].lazy_increment = Operator::IncrementalIdentity();\n      }\n    } else {\n      tree_[vertex].lazy_increment =\n          Operator::Increment(tree_[vertex].lazy_increment, lazy_increment);\n    }\n    tree_[vertex].value = Operator::CombineMultipleIncrements(tree_[vertex].value, lazy_increment,\n                                                              segment_right - segment_left + 1);\n  }\n\n  int next_valid_index_{};\n  int data_size_{};\n  std::vector<Node> tree_{};\n};\n\ntemplate <typename Scalar>\nstruct SummationOperator {\n  static inline constexpr Scalar Identity() noexcept {\n    return Scalar(0);\n  }\n\n  static inline constexpr Scalar Combine(const Scalar& lhs, const Scalar& rhs) noexcept {\n    return lhs + rhs;\n  }\n\n  static inline constexpr Scalar IncrementalIdentity() noexcept {\n    return Scalar(0);\n  }\n\n  static inline constexpr Scalar Increment(const Scalar& lhs, const Scalar& rhs) noexcept {\n    return lhs + rhs;\n  }\n\n  static inline constexpr Scalar CombineMultipleAssignments(const Scalar& assignment,\n                                                            int length) noexcept {\n    return assignment * Scalar(length);\n  }\n\n  static inline constexpr Scalar CombineMultipleIncrements(const Scalar& original_value,\n                                                           const Scalar& increment,\n                                                           int length) noexcept {\n    return original_value + increment * Scalar(length);\n  }\n};\n\nusing ST = SegmentTree<ll, SummationOperator<ll>>;\n\nclass Solution {\n public:\n  vector<ll> findRights(const string& s, int k, char c) {\n    int n = s.size();\n    deque<int> dq;\n    vector<ll> ret(n, n - 1);\n    for (int i = n - 1; i >= 0; --i) {\n      if (i < n - 1) {\n        ret[i] = ret[i + 1];\n      }\n      if (s[i] == c) {\n        dq.push_front(i);\n      }\n      if (dq.size() > k) {\n        ret[i] = dq.back() - 1;\n        dq.pop_back();\n      }\n    }\n    return ret;\n  }\n\n  vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n    int n = s.size();\n    vector<ll> right0 = findRights(s, k, '0');\n    vector<ll> right1 = findRights(s, k, '1');\n    vector<ll> right(n);\n    for (int i = 0; i < n; ++i) {\n      right[i] = max(right0[i], right1[i]);\n    }\n    // for (int i = 0; i < n; ++i) {\n    //   cout << right[i] << ' ';\n    // }\n    // cout << endl;\n    ST st;\n    st.Build(right);\n    vector<ll> ret;\n    for (auto& q : queries) {\n      ll l = q[0];\n      ll r = q[1];\n      int mid = lower_bound(right.begin() + l, right.begin() + r + 1, r) - right.begin();\n      // std::cout << mid << std::endl;\n      ll sum = st.Query(l, mid - 1);\n      // std::cout << sum << std::endl;\n      sum += r * (r - mid + 1);\n      // std::cout << sum << std::endl;\n      sum += (r - l + 1);\n      sum -= (r - l + 1) * (r + l) / 2;\n      ret.push_back(sum);\n    }\n    return ret;\n  }\n};",
    "submit_ts": "1723952296",
    "subm_id": "1359792840"
}