{
    "username": "weiguanchong123",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size()+1;\n        int m = edges2.size()+1;\n        vector<vector<int>> adjList1(n);\n        vector<vector<int>> adjList2(m);\n        \n        for (auto& edge : edges1) {\n            adjList1[edge[0]].push_back(edge[1]);\n            adjList1[edge[1]].push_back(edge[0]);\n        }\n        \n        for (auto& edge : edges2) {\n            adjList2[edge[0]].push_back(edge[1]);\n            adjList2[edge[1]].push_back(edge[0]);\n        }\n        \n        int node1 = find_furthest_node(adjList1, 0);\n        int node2 = find_furthest_node(adjList1, node1);\n        \n        int node3 = find_furthest_node(adjList2, 0);\n        int node4 = find_furthest_node(adjList2, node3);\n        \n        vector<int> v1(n);\n        vector<int> v2(m);\n        \n        \n        dfs(v1, node1, adjList1);\n        dfs(v1, node2, adjList1);\n        dfs(v2, node3, adjList2);\n        dfs(v2, node4, adjList2);\n\n        \n        int r3 = 0;\n        \n        int r1 = INT_MAX;\n        int r2 = INT_MAX;\n        \n        for (int i : v1) {\n            r1 = min(r1, i);\n            r3 = max(r3, i);\n        }\n        for (int i : v2) {\n            r2 = min(r2, i);\n            r3 = max(r3, i);\n        }\n        \n\n        \n        return max(r3, r1 + r2 + 1);\n    }\n    \n    int find_furthest_node(vector<vector<int>>& adjList, int node) {\n        queue<int> q;\n        q.push(node);\n        int res = node;\n        unordered_set<int> visited;\n        visited.insert(node);\n        \n        while (!q.empty()) {\n            int n = q.front();\n            q.pop();\n            res = n;\n            for (int next : adjList[n]) {\n                if (visited.find(next) == visited.end()) {\n                    visited.insert(next);\n                    q.push(next);\n                }\n            }\n        }\n        \n        return res;\n    }\n    \n    void dfs(vector<int>& distances, int node, vector<vector<int>>& adjList) {\n        queue<int> q;\n        q.push(node);\n        int res = node;\n        unordered_set<int> visited;\n        visited.insert(node);\n        int dst = 0;\n        \n        while (!q.empty()) {\n            int size = q.size();\n            for (int i = 0; i < size; ++i) {\n                int n = q.front();\n                q.pop();\n                distances[n] = max(distances[n], dst);\n                \n                for (int next : adjList[n]) {\n                    if (visited.find(next) == visited.end()) {\n                        visited.insert(next);\n                        q.push(next);\n                    }\n                }\n            }\n            ++dst;\n        }\n    }\n};",
    "submit_ts": "1719719546",
    "subm_id": "1304444636"
}