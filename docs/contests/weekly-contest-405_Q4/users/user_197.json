{
    "username": "LCalGaib",
    "submission": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#pragma region\ntemplate <typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ll long long\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define ins insert\n\nvoid __print(int x) { cout << x; }\nvoid __print(long x) { cout << x; }\nvoid __print(long long x) { cout << x; }\nvoid __print(unsigned x) { cout << x; }\nvoid __print(unsigned long x) { cout << x; }\nvoid __print(unsigned long long x) { cout << x; }\nvoid __print(float x) { cout << x; }\nvoid __print(double x) { cout << x; }\nvoid __print(long double x) { cout << x; }\nvoid __print(char x) { cout << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cout << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cout << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cout << (x ? \"true\" : \"false\"); }\ntemplate <size_t N>\nvoid __print(const bitset<N>& x) { cout << x; };\n\ntemplate <typename T>\nvoid __print(const T &x);\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x);\ntemplate <typename T>\nvoid __print(const T &x);\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v);\n\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n    cout << '{';\n    __print(x.first);\n    cout << \", \";\n    __print(x.second);\n    cout << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n    int f = 0;\n    cout << '{';\n    for (auto &i : x) cout << (f++ ? \", \" : \"\"), __print(i);\n    cout << \"}\";\n}\nvoid _print() { cout << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n    __print(t);\n    if (sizeof...(v)) cout << \", \";\n    _print(v...);\n}\n\ntemplate<class T> bool ckmin(T&a, const T& b) { bool B = a > b; a = min(a,b); return B; }\ntemplate<class T> bool ckmax(T&a, const T& b) { bool B = a < b; a = max(a,b); return B; }\n#pragma endregion\n\n#define dbg(x...)                                                            \\\n    cout << \"[\" << __func__ << \":\" << __LINE__ - 9 << \" [\" << #x << \"] = [\"; \\\n    _print(x);                                                               \\\n    cout << endl;\n// #define dbg(x...)\n\ntemplate<typename T, bool R = true, bool LEFT_HASH = true>\nstruct hashes {\n    mt19937 rng;\n    const static int MOD = 1e9 + 7;\n    static int global_base1, global_base2;\n    static vector<long long> powers1, inv_powers1, powers2, inv_powers2;\n    vector<long long> psa;\n\n    hashes(T& s, int b = 131) : rng(chrono::steady_clock::now().time_since_epoch().count()), psa{0} {\n        int& chosen_base = LEFT_HASH ? global_base1 : global_base2;\n        vector<long long> &powers = LEFT_HASH ? powers1 : powers2,\n            &inv_powers = LEFT_HASH ? inv_powers1 : inv_powers2;\n        if (!chosen_base) {\n            chosen_base = R ? uniform_int_distribution<int>(200, MOD - 1)(rng) : b;\n            long long cur = chosen_base, inv = 1;\n            for (int exp = MOD - 2; exp; exp >>= 1) {\n                if (exp & 1) inv = inv * cur % MOD;\n                cur = cur * cur % MOD;\n            }\n            powers.push_back(chosen_base);\n            inv_powers.push_back(inv);\n        }\n        while (powers.size() < s.size()) {\n            powers.push_back(powers.back() * chosen_base % MOD);\n            inv_powers.push_back(inv_powers.back() * inv_powers[1] % MOD);\n        }\n        for (int i = 0; i < s.size(); i++) psa.push_back((psa.back() + s[i] * (LEFT_HASH ? powers1 : powers2)[i]) % MOD);\n    }\n\n    hashes() {}\n\n    long long get(int l, int r) {\n        return (psa[r + 1] - psa[l] + MOD) * (LEFT_HASH ? inv_powers1 : inv_powers2)[l] % MOD;\n    }\n};\n\ntemplate<typename T, bool R, bool LEFT_HASH> int hashes<T, R, LEFT_HASH>::global_base1 = 0;\ntemplate<typename T, bool R, bool LEFT_HASH> int hashes<T, R, LEFT_HASH>::global_base2 = 0;\ntemplate<typename T, bool R, bool LEFT_HASH> vector<long long> hashes<T, R, LEFT_HASH>::powers1 = {1};\ntemplate<typename T, bool R, bool LEFT_HASH> vector<long long> hashes<T, R, LEFT_HASH>::powers2 = {1};\ntemplate<typename T, bool R, bool LEFT_HASH> vector<long long> hashes<T, R, LEFT_HASH>::inv_powers1 = {1};\ntemplate<typename T, bool R, bool LEFT_HASH> vector<long long> hashes<T, R, LEFT_HASH>::inv_powers2 = {1};\n\ntemplate<typename T, bool R = true> \nstruct double_hash {\n    hashes<T, R, true> hash1;\n    hashes<T, R, false> hash2;\n\n    double_hash(T& s, int base1 = 131, int base2 = 173) : hash1(hashes<T, R, true>(s, base1)),\n                                                                             hash2(hashes<T, R, false>(s, base2)) {}\n    double_hash() {}\n\n    long long get(int l, int r) {\n        return (hash1.get(l, r) << 32) | hash2.get(l, r);\n    }\n};\n\nclass Solution {\npublic:\n    int minimumCost(string T, vector<string>& words, vector<int>& costs) {\n        auto T_hs = double_hash(T);\n        int MX_LEN = 0;\n        int m = costs.size();\n        for (int i = 0; i < m; ++i) MX_LEN = max(MX_LEN, int(words[i].size()));\n        \n        unordered_map<int, unordered_map<long long, int>> ws(MX_LEN + 1);\n        for (int i = 0; i < m; ++i) {\n            int l = words[i].size();\n            auto [iter, inserted] = ws[l].emplace(double_hash(words[i]).get(0, l - 1), costs[i]);\n            if (!inserted) {\n                iter->second = min(iter->second, costs[i]);\n            }\n        }\n        \n        int n = T.size();\n        vector dp(n + 1, INT_MAX);\n        dp[0] = 0;\n        \n        for (int i = 1; i <= n; ++i) {\n            for (const auto& [l, wsl] : ws) {\n                if (i < l || dp[i - l] == INT_MAX) continue;\n                const auto iter = wsl.find(T_hs.get(i - l, i - 1));\n                if (iter != wsl.end()) {\n                    dp[i] = min(dp[i], iter->second + dp[i - l]);\n                }\n            }\n        }\n        \n        return dp[n] == INT_MAX ? -1 : dp[n];\n    }\n};\n",
    "submit_ts": "1720321642",
    "subm_id": "1312328378"
}