{
    "username": "alwayssmile99",
    "submission": "class Node:\n    def __init__(self, l, r, count=0):\n        self.left = l\n        self.right = r\n        self.count = count\n\n\nclass SegmentTree:\n\n    def __init__(self, array):\n        self.n = len(array)\n        self.array = array\n        self.tree = [None] * (2 ** math.ceil(math.log2(len(array)) + 1) - 1)\n        self.build(array)\n\n    # function applied on individual values\n    def createNode(self, l, r, val):\n        return Node(l, r)\n\n    # identity for merge function, merger(value, basev) = value\n    def defaultNode(self):\n        return None\n\n    # merge(left, right): function used to merge the two halve\n    def merge(self, leftNode, rightNode):\n        if not leftNode:\n            return rightNode\n        if not rightNode:\n            return leftNode\n\n        res = Node(leftNode.left, rightNode.right)\n        count = leftNode.count + rightNode.count\n        m1 = leftNode.right\n        m2 = rightNode.left\n        if ((leftNode.left < m1 < rightNode.right and self.array[m1 - 1] < self.array[m1] > self.array[m2])\n                or (leftNode.left < m2 < rightNode.right and self.array[m1] < self.array[m2] > self.array[m2 + 1])):\n            count += 1\n        res.count = count\n        return res\n\n    def __str__(self):\n        return ' '.join([str(x) for x in self.tree])\n\n    def _build_util(self, l, r, i, array):\n        if (l == r):\n            self.tree[i] = self.createNode(l, r, array[l])\n            return self.tree[i]\n        mid = (l + r) // 2\n        self.tree[i] = self.merge(self._build_util(l, mid, 2 * i + 1, array),\n                                  self._build_util(mid + 1, r, 2 * i + 2, array))\n        return self.tree[i]\n\n    def build(self, arr):\n        self._build_util(0, len(arr) - 1, 0, arr)\n\n    def _query_util(self, rootIndex, l, r, ql, qr):\n        if l >= ql and r <= qr:\n            return self.tree[rootIndex]\n        if l > qr or r < ql:\n            return self.defaultNode()\n        return self.merge(self._query_util(2 * rootIndex + 1, l, (l + r) // 2, ql, qr),\n                          self._query_util(2 * rootIndex + 2, (l + r) // 2 + 1, r, ql, qr))\n\n    def query(self, ql, qr):\n        return self._query_util(0, 0, self.n - 1, ql, qr)\n\n    def _update_util(self, rootIndex, l, r, index, val):\n        if index >= l and index <= r:\n            if l != r:\n                self._update_util(2 * rootIndex + 1, l, (l + r) // 2, index, val)\n                self._update_util(2 * rootIndex + 2, (l + r) // 2 + 1, r, index, val)\n                self.tree[rootIndex] = self.merge(self.tree[2 * rootIndex + 1], self.tree[2 * rootIndex + 2])\n            else:\n                self.tree[rootIndex] = self.createNode(index, index, val)\n\n    def update(self, index, val):\n        self.array[index] = val\n        self._update_util(0, 0, self.n - 1, index, val)\n\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        seg = SegmentTree(nums)\n        ans = []\n        for type_, p1, p2 in queries:\n            if type_ == 1:\n                ans.append(seg.query(p1, p2).count)\n            else:\n                seg.update(p1, p2)\n        return ans",
    "submit_ts": 1718507585.0
}