{
    "username": "Ninym",
    "submission": "class Solution:\n\n    def get_minimum_costs(self, words, costs):\n        word_cost_map = {}\n\n        # Populate the dictionary with minimum costs for each word\n        for word, cost in zip(words, costs):\n            if word not in word_cost_map:\n                word_cost_map[word] = cost\n            else:\n                if cost < word_cost_map[word]:\n                    word_cost_map[word] = cost\n\n        # Create two separate lists for words and minimum costs\n        unique_words = []\n        minimum_costs = []\n        for word, cost in word_cost_map.items():\n            unique_words.append(word)\n            minimum_costs.append(cost)\n\n        return unique_words, minimum_costs\n\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n\n        words, costs = self.get_minimum_costs(words, costs)\n\n        # [i] is the min cost to make the first i (inclusive) characters of target\n        INF = 10**9\n        cost_partial = [INF] * (len(target) + 1)\n\n        # base case of length 0\n        cost_partial[0] = 0\n\n        for i in range(0, len(target) + 1):\n            if cost_partial == INF:\n                continue\n\n            for j, word in enumerate(words):\n                total_len = i + len(word)\n\n                if total_len > len(target):\n                    continue\n\n                if word == target[i:total_len]:\n                    new_cost = cost_partial[i] + costs[j]\n                    if new_cost < cost_partial[total_len]:\n                        cost_partial[total_len] = new_cost\n                    # cost_partial[total_len] = min(\n                    #     cost_partial[total_len], cost_partial[i] + costs[j]\n                    # )\n\n        # return the answer or -1 if not exists\n        return -1 if cost_partial[len(target)] == INF else cost_partial[len(target)]",
    "submit_ts": "1720324611",
    "subm_id": "1312403758"
}