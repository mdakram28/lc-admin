{
    "username": "amreshky_lm998",
    "submission": "void SieveOfEratosthenes(int n)\n{\n    // Create a boolean array \"prime[0..n]\" and initialize\n    // all entries it as true. A value in prime[i] will\n    // finally be false if i is Not a prime, else true.\n    bool prime[n + 1];\n    memset(prime, true, sizeof(prime));\n \n    for (int p = 2; p * p <= n; p++) {\n        // If prime[p] is not changed, then it is a prime\n        if (prime[p] == true) {\n            // Update all multiples of p greater than or\n            // equal to the square of it numbers which are\n            // multiple of p and are less than p^2 are\n            // already been marked.\n            for (int i = p * p; i <= n; i += p)\n                prime[i] = false;\n        }\n    }\n \n    // Print all prime numbers\n    for (int p = 2; p <= n; p++)\n        if (prime[p])\n            cout << p << \" \";\n}\n\nclass Solution {\n    unordered_map<int, vector<vector<int>>> memo; \npublic:\n    int waysToReachStair(int destination) { // Changed k to destination\n        function<int(int,int,int,bool)> solve = [&](int dest, int pos, int jump, bool canJump) -> int {\n\n            if(memo.count(pos) && memo[pos][jump][canJump] != -1)\n                return memo[pos][jump][canJump];\n            \n            int result = (pos == dest); \n            if (canJump)\n                result += solve(dest, pos - 1, jump, 0);\n            \n            \n            if (pos + (1 << jump) <= dest + 1)\n                result += solve(dest, pos + (1 << jump), jump + 1, 1);\n\n            memo[pos].resize(32, vector<int>(2, -1)); \n\n            return memo[pos][jump][canJump] = result;\n            \n            if(jump > 31)\n                return 0;\n            else if(pos > dest + 5)\n                return 0;\n        };\n\n        return solve(destination, 1, 0, 1);\n    } \n};\n\n",
    "submit_ts": 1716090243.0
}