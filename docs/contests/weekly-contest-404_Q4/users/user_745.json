{
    "username": "jsegaran3",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        tree1 = collections.defaultdict(list)\n        for f, t in edges1:\n            tree1[f].append(t)\n            tree1[t].append(f)\n            \n        tree2 = collections.defaultdict(list)\n        for f, t in edges2:\n            tree2[f].append(t)\n            tree2[t].append(f)\n            \n        if edges1:\n            last_vertex1 = None\n            queue = [edges1[0][0]]\n\n            visited = {edges1[0][0]}\n            while queue:\n                node = queue.pop(0)\n                for neighbor in tree1[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n                last_vertex1 = node\n\n            queue = [(last_vertex1, 0)]\n\n            visited = {last_vertex1}\n            diameter1 = 0\n            while queue:\n                node, path_len = queue.pop(0)\n                diameter1 = max(diameter1, path_len)\n                for neighbor in tree1[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, path_len + 1))\n                # last_vertex2 = node\n        else:\n            diameter1 = 0\n        print(diameter1)\n        \n            \n        if edges2:\n            last_vertex1 = None\n            queue = [edges2[0][0]]\n\n            visited = {edges2[0][0]}\n            while queue:\n                node = queue.pop(0)\n                for neighbor in tree2[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n                last_vertex1 = node\n\n            queue = [(last_vertex1, 0)]\n\n            visited = {last_vertex1}\n            diameter2 = 0\n            while queue:\n                node, path_len = queue.pop(0)\n                diameter2 = max(diameter2, path_len)\n                for neighbor in tree2[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, path_len + 1))\n                # last_vertex2 = node\n        else:\n            diameter2 = 0\n        print(diameter2)\n\n        return max([math.ceil(diameter1 / 2) + math.ceil(diameter2 / 2) + 1, diameter1, diameter2, 1])\n\n        ",
    "submit_ts": 1719718838.0
}