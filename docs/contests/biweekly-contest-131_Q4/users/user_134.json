{
    "username": "Ani_S",
    "submission": "class SegmentTree {\n    int tree[];\n    int n;\n    \n    public SegmentTree(int n) {\n        this.tree = new int[(4 * n) + 1];\n        this.n = n;\n    }\n    \n    public void set(int i, int v) {\n        set(i, v, 0, n - 1, 0);\n    }\n\n    private void set(int i, int v, int l, int r, int x) {\n        if(l == r) {\n            tree[x] = v;\n            return;\n        }\n\n        int mid = l + (r - l) / 2;\n\n        if(i <= mid) {\n            set(i, v, l, mid, (2 * x) + 1);\n        }\n        else {\n            set(i, v, mid + 1, r, (2 * x) + 2);\n        }\n\n        tree[x] = Math.max(tree[(2 * x) + 1], tree[(2 * x) + 2]);\n    }\n    \n    public int max(int lx, int rx) {\n        return max(lx, rx, 0, n, 0);\n    }\n\n    private int max(int lx, int rx, int l, int r, int x) {\n        if(rx <= l || lx >= r) {\n            return 0;\n        }\n\n        if(l >= lx && r <= rx) {\n            return tree[x];\n        }\n\n        int mid = l + (r - l) / 2;\n\n        int left = max(lx, rx, l, mid, (2 * x) + 1);\n        int right = max(lx, rx, mid, r, (2 * x) + 2);\n\n        return Math.max(left, right);\n    }\n}\nclass Solution {\n    public List<Boolean> getResults(int[][] queries) {\n        TreeSet<Integer> obstacle = new TreeSet<>();\n        obstacle.add(0);\n        obstacle.add(50001);\n        \n        SegmentTree st = new SegmentTree(50002);\n        st.set(50001, 50001);\n        \n        int n = queries.length;\n        \n        List<Boolean> ans = new ArrayList<>();\n        \n        for(int i = 0; i < n; i++) {\n            \n            if(queries[i][0] == 1) {\n                int val = queries[i][1];\n                Integer lower = obstacle.lower(val);\n                Integer higher = obstacle.higher(val);\n                \n                st.set(val, val - lower);\n                st.set(higher, higher - val);\n                \n                obstacle.add(val);\n                \n            } else {\n                Integer lower = obstacle.lower(queries[i][1]);\n                \n                int val = st.max(0, lower);\n                val = Math.max(val, queries[i][1] - lower);\n                \n                if(val >= queries[i][2])\n                    ans.add(true);\n                else\n                    ans.add(false);\n            }\n        }\n        \n        return ans;\n    }\n}",
    "submit_ts": 1716650068.0
}