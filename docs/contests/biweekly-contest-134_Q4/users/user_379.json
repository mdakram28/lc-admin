{
    "username": "Semi__colon",
    "submission": "#define ll long long\nclass Solution {\npublic:\n\n   struct SegTree{\n    public:\n\n        SegTree (int _n, vector<int> &arr) : n(_n){\n            tree.resize(4*n, 0);\n            build(0, n-1, 0, arr);\n        }\n        \n        ll query (int x, int y){\n            if(x > y) return 0;\n            return query (x, y, 0, n-1, 0);\n        }\n        \n        void update (int ind, int val){\n            update (ind, val, 0, n-1, 0);\n        }\n\n            void print_tree(){\n            for(int i=0; i<2*n-1; i++) cout<< tree[i]<<\" \";\n            cout<<endl;\n        }\n        \n    private:\n\n        vector<ll> tree;\n        int n;\n        \n        void build (int l, int r, int i, const vector<int>& arr){\n            if(l==r) {\n                tree[i] = arr[l];\n                return;\n            }\n            int m = (l+r) >> 1;\n            build (l, m, i*2+1, arr);\n            build (m+1, r, i*2+2, arr);\n            \n            tree[i] = (tree[i*2+1] & tree[i*2+2]);\n        }\n        \n        ll query (int x, int y, int l, int r, int i){\n            if(r < x || l > y) return INT_MAX;\n            if(l >= x && r<=y) return tree[i];\n            \n            int m = (l+r) >> 1;\n            return  (\n                query (x, y, l, m, i*2+1) &\n                query (x, y, m+1, r, i*2+2)\n            );\n        }\n        \n        void update (int ind, int val, int l, int r, int i){\n            if (l==r) {\n                tree[i] = val;\n                return;\n            }\n            \n            int m = (l+r) >> 1;\n            if (m >= ind) update (ind, val, l, m, i*2+1);\n            else update (ind, val, m+1, r, i*2+2);\n            \n            tree[i] = (tree[2*i+1] & tree[2*i+2]);\n        }\n    };\n\n    int findLastIndex( SegTree& st, int n, int i, int K) {\n        int left = i, right = n - 1, result = -1;\n        bool ms = 0;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            int x = st.query(i, mid);\n\n            if ( x >= K) {\n                result = mid;\n                if( x == K ) ms = 1;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return ms ==  1 ? result : -1;\n    }\n\n    int ankit( SegTree& st, int n, int i, int K) {\n        int left = i, right = n - 1, result = -1;\n        bool ms = 0;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            int x = st.query(i, mid);\n\n            if ( x > K) {\n                result = mid;\n                left = mid + 1;\n                if(x==K) ms = 1;\n            } else {\n                \n                right = mid - 1;\n            }\n        }\n        \n        return  result;\n    }\n\n    long long countSubarrays(vector<int>& nums, int kk) {\n        \n        int n = nums.size();\n        long long count = 0;\n        int j=0, ms=0;\n        SegTree st(n,nums);\n\n        for (int i = 0; i < n; ++i) {\n\n            \n            int l1 = findLastIndex(st, n, i, kk);\n        \n\n            int l2 = ankit(st, n, i, kk);\n\n            // cout<<l1<<\" \"<<l2<<endl;\n\n            if (l1 != -1 && l2 != -1) {\n                count += (l1 - l2 );\n            }\n            else if (l1 != -1) {\n                count += l1-i+1;\n            }\n\n           \n            \n        }\n\n        return count;\n\n    }\n};",
    "submit_ts": "1720278962",
    "subm_id": "1311731586"
}