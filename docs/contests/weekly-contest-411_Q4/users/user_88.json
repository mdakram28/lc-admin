{
    "username": "Priyansh Sharma",
    "submission": "\nclass Solution {\npublic:\n    // Separate function definition for calculateRightBound\n    int calculateRightBound(int index, int length, int k, const vector<int>& countZeros, const vector<int>& countOnes) {\n        int left = index, right = length - 1;\n        int result = index;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            int zeroCount = countZeros[mid] - (index > 0 ? countZeros[index - 1] : 0);\n            int oneCount = countOnes[mid] - (index > 0 ? countOnes[index - 1] : 0);\n            if (zeroCount <= k || oneCount <= k) {\n                result = mid;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return result;\n    }\n\n    // Separate function definition for calculateLeftBound\n    int calculateLeftBound(int index, int k, const vector<int>& countZeros, const vector<int>& countOnes) {\n        int left = 0, right = index;\n        int result = index;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            int zeroCount = countZeros[index] - (mid > 0 ? countZeros[mid - 1] : 0);\n            int oneCount = countOnes[index] - (mid > 0 ? countOnes[mid - 1] : 0);\n            if (zeroCount <= k || oneCount <= k) {\n                result = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return result;\n    }\n\n    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n        int length = s.size();\n        vector<int> countZeros(length, 0), countOnes(length, 0);\n\n        for (int i = 0; i < length; i++) {\n            if (s[i] == '0') countZeros[i]++;\n            else countOnes[i]++;\n            if (i + 1 < length) {\n                countZeros[i + 1] = countZeros[i];\n                countOnes[i + 1] = countOnes[i];\n            }\n        }\n\n        vector<long long> prefixSum(length + 1, 0);\n        for (int i = 1; i <= length; i++) {\n            prefixSum[i] = prefixSum[i - 1] + i;\n        }\n\n        vector<long long> subarraySums(length, 0);\n        for (int i = 0; i < length; i++) {\n            int rightBound = calculateRightBound(i, length, k, countZeros, countOnes);\n            subarraySums[i] += (rightBound - i + 1);\n            if (i + 1 < length) {\n                subarraySums[i + 1] = subarraySums[i];\n            }\n        }\n\n        vector<long long> result;\n        for (const auto& query : queries) {\n            int start = query[0], end = query[1];\n            int leftBound = calculateLeftBound(end, k, countZeros, countOnes);\n            if (leftBound <= start) leftBound = start;\n            long long validLength = (end - leftBound + 1);\n            long long currentSum = 0;\n            if (leftBound > start) {\n                currentSum += (subarraySums[leftBound - 1] - (start > 0 ? subarraySums[start - 1] : 0));\n            }\n            currentSum += prefixSum[validLength];\n            result.push_back(currentSum);\n        }\n\n        return result;\n    }\n};\n",
    "submit_ts": "1723952942",
    "subm_id": "1359808458"
}