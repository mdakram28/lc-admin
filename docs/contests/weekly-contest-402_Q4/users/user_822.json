{
    "username": "brianchan-2",
    "submission": "struct SegmentTree {\n    vector<int> tree;\n    int n;\n    SegmentTree(int n) : n(n), tree(n * 4) {}\n    void build(int p, int l, int r, vector<int>& nums) {\n        if (l == r) {\n            tree[p] = nums[l];\n            return;\n        }\n        int m = l + (r - l) / 2;\n        build(p * 2, l, m, nums);\n        build(p * 2 + 1, m + 1, r, nums);\n        tree[p] = tree[p * 2] + tree[p * 2 + 1];\n    }\n    void build(vector<int>& nums) {\n        build(1, 0, n - 1, nums);\n    }\n    void set(int p, int l, int r, int i, int v) {\n        if (l == r) {\n            tree[p] = v;\n            return;\n        }\n        int m = l + (r - l) / 2;\n        if (i <= m) {\n            set(p * 2, l, m, i, v);\n        } else {\n            set(p * 2 + 1, m + 1, r, i, v);\n        }\n        tree[p] = tree[p * 2] + tree[p * 2 + 1];\n    }\n    void set(int i, int v) {\n        set(1, 0, n - 1, i, v);\n    }\n    int query(int p, int l, int r, int i, int j) {\n        if (l >= i && r <= j) {\n            return tree[p];\n        }\n        int m = l + (r - l) / 2;\n        int sum = 0;\n        if (i <= m) {\n            sum += query(p * 2, l, m, i, j);\n        }\n        if (j > m) {\n            sum += query(p * 2 + 1, m + 1, r, i, j);\n        }\n        return sum;\n    }\n    int query(int i, int j) {\n        return query(1, 0, n - 1, i, j);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        SegmentTree tree(nums.size());\n        vector<int> cnt(nums.size());\n        for(int i = 1; i < n - 1; ++i) {\n            cnt[i] = nums[i] > nums[i-1] && nums[i] > nums[i + 1];\n        }\n        \n        tree.build(cnt);\n        vector<int> ans; ans.reserve(queries.size());\n        \n        auto f = [&](int idx) {\n            if(idx > 0 && idx < n - 1) {\n                tree.set(idx, nums[idx] > nums[idx-1] && nums[idx] > nums[idx+1]);\n            }\n        };\n        // for(int i = 0; i < n; ++i) {\n        //     cout << i << \" \" << tree.query(i, i) << endl;\n        // }\n        for(auto& q : queries) {\n            if(q[0] == 1) {\n                ans.push_back(tree.query(q[1] + 1, q[2] - 1));\n            } else {\n                int idx = q[1], v = q[2];\n                nums[idx] = v;\n                \n                f(idx-1);\n                f(idx);\n                f(idx+1);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718508247.0
}