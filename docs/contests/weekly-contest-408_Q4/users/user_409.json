{
    "username": "wangkekekexili",
    "submission": "class Solution {\n    static class Status {\n        boolean cutTop;\n        boolean cutLeft;\n        boolean cutBottom;\n        boolean cutRight;\n        public String toString() {\n            return String.format(\"%b %b %b %b\", cutTop, cutLeft, cutBottom, cutRight);\n        }\n    }\n    static class UF {\n        Map<Integer, Status> componentStatus = new HashMap<>();\n        int[] parent;\n        UF(int n) {\n            this.parent = new int[n];\n            for (int i = 0;i != n; i++) this.parent[i] = i;\n        }\n        int findRoot(int i) {\n            if (parent[i] != i) {\n                parent[i] = findRoot(parent[i]);\n            }\n            return parent[i];\n        }\n        void union(int i, int j, int[][] circles, int X, int Y) {\n            int iRoot = findRoot(i);\n            int jRoot = findRoot(j);\n            updateStatus(iRoot, jRoot);\n        }\n\n        void updateStatus(int i, int j) {\n            Status s1 = componentStatus.get(i);\n            Status s2 = componentStatus.get(j);\n            Status newS = new Status();\n            newS.cutLeft = s1.cutLeft || s2.cutLeft;\n            newS.cutBottom = s1.cutBottom || s2.cutBottom;\n            newS.cutRight = s1.cutRight || s2.cutRight;\n            newS.cutTop = s1.cutTop || s2.cutTop;\n            componentStatus.put(i, newS);\n            componentStatus.put(j, newS);\n        }\n\n        void updateStatus(int i, int[][] circle, int X, int Y) {\n            Status s = new Status();\n            s.cutLeft = isCutLeft(circle[i]);\n            s.cutBottom = isCutBottom(circle[i]);\n            s.cutRight = isCutRight(circle[i], X);\n            s.cutTop = isCutTop(circle[i], Y);\n            componentStatus.put(i, s);\n        }\n    }\n\n    static boolean isCutLeft(int[] circle) {\n        int x= circle[0];\n        int y = circle[1];\n        int r = circle[2];\n        return x-r <= 0 && x+r >= 0;\n    }\n\n    static boolean isCutBottom(int[] circle) {\n        int x= circle[0];\n        int y = circle[1];\n        int r = circle[2];\n        return y-r <= 0 && y+r >= 0;\n    }\n\n\n    static boolean isCutRight(int[] circle, int X) {\n        int x= circle[0];\n        int y = circle[1];\n        int r = circle[2];\n        return x-r <= X && x+r >= X;\n    }\n\n    static boolean isCutTop(int[] circle, int Y) {\n        int x= circle[0];\n        int y = circle[1];\n        int r = circle[2];\n        return y-r <= Y && y+r >= Y;\n    }\n\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        int nCircle = circles.length;\n        UF uf = new UF(nCircle);\n        for (int i = 0; i != nCircle; i++) {\n            uf.updateStatus(i, circles, X, Y);\n        }\n        for (int i = 0;i != circles.length-1; i++) {\n            for (int j = i+1; j != circles.length; j++) {\n                if (hasIntersection(circles, i, j)) {\n                    // System.out.println(\"hasinter\");\n                    uf.union(i, j, circles, X, Y);\n                }\n            }\n        }\n        // System.out.println(uf.componentStatus);\n        for (Map.Entry<Integer, Status> s : uf.componentStatus.entrySet()) {\n            Status status = s.getValue();\n            if (status.cutBottom && (status.cutLeft || status.cutTop)) return false;\n            if (status.cutLeft && status.cutRight) return false;\n            if (status.cutTop && status.cutRight) return false;\n        }\n        return true;\n    }\n\n    boolean hasIntersection(int[][] circles, int i, int j) {\n        double dist = Math.sqrt(Math.pow(circles[i][0]-circles[j][0], 2)  + Math.pow(circles[i][1]-circles[j][1], 2));\n        return dist <= circles[i][2] + circles[j][2];\n    }\n}",
    "submit_ts": "1722137640",
    "subm_id": "1335769547"
}