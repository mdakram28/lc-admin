{
    "username": "giantcheeseguy2",
    "submission": "#pragma GCC optimize(\"O3,unroll-loops\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC target(\"sse4,popcnt,abm,mmx,tune=native\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define pb push_back\n#define ff first\n#define ss second\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pld;\n\nconst int INF = 1e9;\nconst ll LLINF = 1e18;\nconst int MOD = 1e9 + 7;\n\ntemplate<class K> using sset =  tree<K, null_type, less<K>, rb_tree_tag, tree_order_statistics_node_update>;\n\ninline ll ceil0(ll a, ll b) {\n    return a / b + ((a ^ b) > 0 && a % b);\n}\n\nstruct Segtree {\n\n    using T = int;\n    using L = int;\n\n    static T merge(T a, T b){\n        return a + b;\n    }\n\n    static void apply(T &a, L v, int x){\n        a += v;\n    }\n\n    int n;\n    vector<T> seg;\n\n    void build(const vector<T> &v, int l, int r, int cur){\n        if(l == r){\n            seg[cur] = v[l];\n            return;\n        }\n        int mid = (l + r)/2;\n        build(v, l, mid, cur*2 + 1);\n        build(v, mid + 1, r, cur*2 + 2);\n        seg[cur] = merge(seg[cur*2 + 1], seg[cur*2 + 2]);\n    }\n\n    void update(int x, L v, int l, int r, int cur){\n        if(l == x && x == r){\n            apply(seg[cur], v, x);\n            return;\n        }\n        int mid = (l + r)/2;\n        if(x <= mid) update(x, v, l, mid, cur*2 + 1);\n        else update(x, v, mid + 1, r, cur*2 + 2);\n        seg[cur] = merge(seg[cur*2 + 1], seg[cur*2 + 2]);\n    }\n\n    T query(int l, int r, int ul, int ur, int cur){\n        if(l <= ul && ur <= r) return seg[cur];\n        int mid = (ul + ur)/2;\n        if(r <= mid) return query(l, r, ul, mid, cur*2 + 1);\n        if(l > mid) return query(l, r, mid + 1, ur, cur*2 + 2);\n        return merge(query(l, r, ul, mid, cur*2 + 1), query(l, r, mid + 1, ur, cur*2 + 2));\n    }\n\n    Segtree(){\n\n    }\n\n    Segtree(const vector<T> &v){\n        n = v.size();\n        int sz = 1;\n        while(sz < n) sz *= 2;\n        seg.resize(2*sz);\n        build(v, 0, n - 1, 0);\n    } \n\n    Segtree(int _n, T v){\n        n = _n;\n        int sz = 1;\n        while(sz < n) sz *= 2;\n        seg.resize(2*sz);\n        vector<T> tmp(n, v);\n        build(tmp, 0, n - 1, 0);\n    }\n\n    T query(int l, int r){\n        assert(l <= r && 0 <= l && r < n);\n        return query(l, r, 0, n - 1, 0);\n    }\n\n    void update(int x, L v){\n        assert(0 <= x && x < n);\n        update(x, v, 0, n - 1, 0);\n    }\n\n};\n\nvoid ins(pii i, Segtree &sum, Segtree &cnt, int n, vector<int> &colors){\n    int len;\n    if(i.ff <= i.ss) len = i.ss - i.ff + 1;\n    else len = n - i.ff + i.ss + 1;\n    sum.update(len, len);\n    cnt.update(len, 1);\n}\n\nvoid rem(pii i, Segtree &sum, Segtree &cnt, int n, vector<int> &colors){\n    int len;\n    if(i.ff <= i.ss) len = i.ss - i.ff + 1;\n    else len = n - i.ff + i.ss + 1;\n    sum.update(len, -len);\n    cnt.update(len, -1);\n}\n\nclass Solution {\npublic:\n    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {\n        set<pii> s;\n        int n = colors.size();\n        for(int i = 0; i < n; i++){\n            s.insert({i, i});\n        }\n        set<pii>::iterator it = s.begin();\n        while(s.size() > 1){\n            set<pii>::iterator nxt = next(it);\n            bool fin = false;\n            if(nxt == s.end()){\n                nxt = s.begin();\n                fin = true;\n            }\n            if(colors[nxt->ff] != colors[it->ss]){\n                pii nw = {it->ff, nxt->ss};\n                pii a = *it, b = *nxt;\n                s.erase(a);\n                s.erase(b);\n                s.insert(nw);\n                it = s.find(nw);\n            } else {\n                it = nxt;\n            }\n            if(fin) break;\n        }\n        Segtree sum(n + 2, 0);\n        Segtree cnt(n + 2, 0);\n        for(pii i : s){\n            ins(i, sum, cnt, n, colors); \n        }\n        vector<int> ans;\n        for(auto i : queries){\n            if(i[0] == 1){\n                if(s.size() == 1 && colors[s.begin()->ff] != colors[s.begin()->ss]){\n                    if(i[1] == n) ans.pb(1);\n                    else ans.pb(n);\n                } else {\n                    ans.pb(sum.query(i[1], n + 1) - cnt.query(i[1], n + 1)*(i[1] - 1));\n                }\n            } else {\n                set<pii>::iterator it = s.lower_bound({i[1], INF});\n                if(it == s.begin()){\n                    it = prev(s.end());\n                } else {\n                    it--;\n                }\n                pii x = *it;\n                s.erase(x);\n                colors[i[1]] = i[2];\n                rem(x, sum, cnt, n, colors);\n                if(x.ff != i[1]){\n                    s.insert({x.ff, (i[1] + n - 1)%n});\n                    ins({x.ff, (i[1] + n - 1)%n}, sum, cnt, n, colors);\n                }\n                if(i[1] != x.ss){\n                    s.insert({(i[1] + 1)%n, x.ss});\n                    ins({(i[1] + 1)%n, x.ss}, sum, cnt, n, colors);\n                }\n                s.insert({i[1], i[1]});\n                ins({i[1], i[1]}, sum, cnt, n, colors);\n                it = s.lower_bound({i[1], INF});\n                for(int t = 0; t < 2; t++){\n                    if(it == s.begin()){\n                        it = prev(s.end());\n                    } else {\n                        it--;\n                    }\n                }\n                int lim = 4;\n                while(s.size() > 1){\n                    lim--;\n                    if(lim == 0) break;\n                    set<pii>::iterator nxt = next(it);\n                    if(nxt == s.end()){\n                        nxt = s.begin();\n                    }\n                    if(colors[nxt->ff] != colors[it->ss]){\n                        pii nw = {it->ff, nxt->ss};\n                        pii a = *it, b = *nxt;\n                        s.erase(a);\n                        s.erase(b);\n                        rem(a, sum, cnt, n, colors);\n                        rem(b, sum, cnt, n, colors);\n                        s.insert(nw);\n                        ins(nw, sum, cnt, n, colors);\n                        it = s.find(nw);\n                    } else {\n                        it = nxt;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722741615",
    "subm_id": "1343749275"
}