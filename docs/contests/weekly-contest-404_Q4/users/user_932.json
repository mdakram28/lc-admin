{
    "username": "SamChen856",
    "submission": "class Solution:\n    # bfs, time O(n+m), space O(n+m)\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def get_diameter_and_max_height(edges):\n            n = len(edges) + 1\n            adj = [[] for _ in range(n)]\n            for u, v in edges:\n                adj[u].append(v)\n                adj[v].append(u)\n\n            def bfs(start):\n                d = [-1] * n\n                d[start] = 0\n                q = deque([start])\n                far_node = start\n                while q:\n                    cur = q.popleft()\n                    for nei in adj[cur]:\n                        if d[nei] == -1:\n                            d[nei] = d[cur] + 1\n                            q.append(nei)\n                            far_node = nei\n                return far_node, max(d)\n\n            far_node, max_height = bfs(0)\n            _, diameter = bfs(far_node)\n            return diameter, max_height\n\n        diameter1, max_height1 = get_diameter_and_max_height(edges1)\n        diameter2, max_height2 = get_diameter_and_max_height(edges2)\n        # print(diameter1, diameter2, max_height1, max_height2)\n\n        if diameter1 == diameter2 == 0:\n            return 1\n        if diameter1 == 0:\n            if diameter2 == 1:\n                return 2\n            return diameter2\n        if diameter2 == 0:\n            if diameter1 == 1:\n                return 2\n            return diameter1\n        return max(diameter1, diameter2, (diameter1 + 1) // 2 +  (diameter2 + 1) // 2 + 1)\n",
    "submit_ts": "1719718684",
    "subm_id": "1304423497"
}