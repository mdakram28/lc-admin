{
    "username": "aashishnimcet2022",
    "submission": "#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isPrime(int assn) {\n        if (assn <= 1) return false;\n        if (assn <= 3) return true;\n        if (assn % 2 == 0 || assn % 3 == 0) return false;\n        int assi = 5;\n        while (assi * assi <= assn) {\n            if (assn % assi == 0 || assn % (assi + 2) == 0) return false;\n            assi += 6;\n        }\n        return true;\n    }\n\n    int bfs(vector<vector<int>> &assgraph, int assstart, int asstarget1, int asstarget2, int assnodes) {\n        queue<int> assq;\n        vector<int> assvisited(assnodes + 4, 0);\n        assq.push(assstart);\n        assvisited[assstart] = 1;\n\n        while (!assq.empty()) {\n            int assu = assq.front();\n            assq.pop();\n            for (int assv : assgraph[assu]) {\n                if (!assvisited[assv]) {\n                    assq.push(assv);\n                    assvisited[assv] = 1;\n                }\n            }\n        }\n        return assvisited[asstarget1] || assvisited[asstarget2];\n    }\n\n    bool canReachCorner(int assX, int assY, vector<vector<int>>& asscircles2) {\n        vector<pair<pair<int, int>, int>> asscircles(asscircles2.size());\n        vector<vector<int>> assgraph(asscircles2.size() + 4);\n        int assnum_circles = asscircles2.size();\n\n        int assi = 0;\n        while (assi < assnum_circles) {\n            asscircles[assi].first.first = asscircles2[assi][0];\n            asscircles[assi].first.second = asscircles2[assi][1];\n            asscircles[assi].second = asscircles2[assi][2];\n            assi++;\n        }\n\n        assi = 0;\n        while (assi < assnum_circles) {\n            asscircles[assi].first.first <= asscircles[assi].second ? (assgraph[assnum_circles].push_back(assi), assgraph[assi].push_back(assnum_circles)) : void();\n            assX - asscircles[assi].first.first <= asscircles[assi].second ? (assgraph[assnum_circles + 2].push_back(assi), assgraph[assi].push_back(assnum_circles + 2)) : void();\n            asscircles[assi].first.second <= asscircles[assi].second ? (assgraph[assnum_circles + 1].push_back(assi), assgraph[assi].push_back(assnum_circles + 1)) : void();\n            assY - asscircles[assi].first.second <= asscircles[assi].second ? (assgraph[assnum_circles + 3].push_back(assi), assgraph[assi].push_back(assnum_circles + 3)) : void();\n            int assj = assi + 1;\n            while (assj < assnum_circles) {\n                double assdistance = sqrt(pow(asscircles[assi].first.first - asscircles[assj].first.first, 2) +\n                                          pow(asscircles[assi].first.second - asscircles[assj].first.second, 2));\n                int assradius_sum = asscircles[assi].second + asscircles[assj].second;\n                assradius_sum >= assdistance ? (assgraph[assi].push_back(assj), assgraph[assj].push_back(assi)) : void();\n                assj++;\n            }\n            assi++;\n        }\n\n        int assis_blocked = 0;\n        assi = 0;\n        while (assi < 4) {\n            int assstart = (assi < 2) ? assnum_circles : assnum_circles + 3;\n            int asstarget1 = (assi % 2 == 0) ? assnum_circles + 1 : assnum_circles + 2;\n            int asstarget2 = (assi % 2 == 0) ? assnum_circles + 2 : assnum_circles + 1;\n            assis_blocked = max(assis_blocked, bfs(assgraph, assstart, asstarget1, asstarget2, assnum_circles + 4));\n            assi++;\n        }\n        return !assis_blocked;\n    }\n};\n",
    "submit_ts": "1722137124",
    "subm_id": "1335754869"
}