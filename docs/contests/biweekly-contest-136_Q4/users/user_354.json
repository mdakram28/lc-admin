{
    "username": "eatfood",
    "submission": "\"\"\"\n2 way dp\n\ndp1[i] = max delay for this subtree rooted at i\ndp2[i] = max delay for subtree of everything above i\n\ndp1[i] = max dp1[child] + d_child for all child\ndp2[i] = delay from i to par[i], max of dp2[par[i]] and dp1[par[i]] for a childs != i\n\"\"\"\n\nclass Solution:\n    def timeTaken(self, edges: List[List[int]]) -> List[int]:\n        def delay(x):\n            if x % 2 == 0:\n                return 2\n            return 1\n\n        n = len(edges) + 1\n        root = 0\n        g = [[] for i in range(n)]\n        p = [-1] * n\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        \n        dp1 = [0] * n\n        dp2 = [0] * n\n        def dfs1(cur, par):\n            p[cur] = par\n            mx = 0\n            for v in g[cur]:\n                if v == par:\n                    continue\n                dfs1(v, cur)\n                mx = max(mx, dp1[v] + delay(v))\n            # get dp\n            dp1[cur] = mx\n\n        def dfs2(cur, par):\n            # dp2[i] = delay from i to par[i], max of dp2[par[i]] and dp1[par[i]] for a childs != i\n            # calc dp2 here\n            if par == -1:\n                pd = 0\n            else:\n                pd = dp2[cur]\n\n            # calc the upwards subtrees for cur\n            childs = [x for x in g[cur] if x != par]\n            nc = len(childs)\n            if nc > 0:\n                arr = [0] * nc\n                for i in range(nc):\n                    child = childs[i]\n                    arr[i] = delay(child) + dp1[child]\n                # pref and suff max\n                pref = [0] * nc\n                suff = [0] * nc\n                pref[0] = arr[0]\n                for i in range(1, nc):\n                    pref[i] = max(pref[i-1], arr[i])\n                suff[nc-1] = arr[nc-1]\n                for i in range(nc-2, -1, -1):\n                    suff[i] = max(suff[i+1], arr[i])\n                \n                # print('dfs2 cur', cur)\n                # print('pref', pref)\n                # print('suff', suff)\n                # push down to children\n                for i in range(nc):\n                    others = 0\n                    if i > 0:\n                        others = max(others, pref[i-1])\n                    if i < nc-1:\n                        others = max(others, suff[i+1])\n                    here = max(others, pd)\n                    # print(\"here\", here, pd)\n                    dp2[childs[i]] = here + delay(cur)\n                    \n            for v in g[cur]:\n                if v == par:\n                    continue\n                dfs2(v, cur)\n        \n        dfs1(0, -1)\n        dfs2(0, -1)\n\n        print('dp1', dp1)\n        print('dp2', dp2)\n\n        ans = [max(dp1[i], 0 if p[i] == -1 else dp2[i]) for i in range(n)]\n        print(ans)\n        return ans\n",
    "submit_ts": "1722700736",
    "subm_id": "1343251192"
}