{
    "username": "bingyan2",
    "submission": "import numpy as np\nclass Solution:\n    def minimumSum(self, grid: list[list[int]]) -> int:\n        self.grid = np.array(grid)\n        n_rows, n_cols = self.grid.shape\n        # havent taken edge cases into consideration\n        best = n_rows * n_cols\n        for r_cut in range(n_rows+1):\n            for c_cut in range(n_cols+1):\n                for direction in range(4):\n                    regions = self.get_regions(n_rows,n_cols,r_cut,c_cut,direction)\n                    temp = sum([self.area(*region) for region in regions])\n                    best = min(best,temp)\n        for a in range(1,n_rows-1):\n            for b in range(a+1,n_rows):\n                regions = self.get_regions2(a,b,n_rows,n_cols,0)\n                temp = sum([self.area(*region) for region in regions])\n                best = min(best,temp)         \n        for a in range(1,n_cols-1):\n            for b in range(a+1,n_cols):\n                regions = self.get_regions2(a,b,n_rows,n_cols,1)\n                temp = sum([self.area(*region) for region in regions])\n                best = min(best,temp)         \n        return best\n    \n    def get_regions(self,n_rows,n_cols,r_cut,c_cut,direction):\n        if direction == 0:\n            return [(0,r_cut,0,c_cut),\n                    (0,r_cut,c_cut,n_cols),\n                    (r_cut,n_rows,0,n_cols)]\n        if direction == 1:\n            return [(0,r_cut,0,n_cols),\n                    (r_cut,n_rows,0,c_cut),\n                    (r_cut,n_rows,c_cut,n_cols)]\n        if direction == 2:\n            return [(0,r_cut,0,c_cut),\n                    (r_cut,n_rows,0,c_cut),\n                    (0,n_rows,c_cut,n_cols)]\n        if direction == 3:\n            return [(0,n_rows,0,c_cut),\n                    (0,r_cut,c_cut,n_cols),\n                    (r_cut,n_rows,c_cut,n_cols)]\n        \n    def get_regions2(self, a,b,n,m,d):\n        if d == 0:\n            return [(0,a,0,m), (a,b,0,m),(b,n,0,m)]\n        if d == 1:\n            return [(0,n,0,a), (0,n,a,b), (0,n,b,m)]\n    \n    def area(self,a,b,c,d):\n        if b==a or c==d:\n            return 0\n        arr = self.grid[a:b,c:d]\n        r_idx = np.where(arr.any(axis=1))[0]\n        height = r_idx[-1] - r_idx[0] + 1 if r_idx.size > 0 else 0\n        c_idx = np.where(arr.any(axis=0))[0]\n        width = c_idx[-1] - c_idx[0] + 1 if c_idx.size > 0 else 0\n        return height * width",
    "submit_ts": "1719114398",
    "subm_id": "1297345973"
}