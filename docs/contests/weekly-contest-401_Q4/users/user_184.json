{
    "username": "gaoran",
    "submission": "class Solution {\nprivate:\n    int dfs(vector<int>& r, int left, int ceil, unordered_map<int, unordered_map<int, int>>& memo, int cur, int& best) {\n        if (left >= r.size() || ceil < 1) return 0;\n        if (cur + ceil <= best) return 0;\n        if (memo.find(left) != memo.end() && memo[left].find(ceil) != memo[left].end()) return memo[left][ceil];\n        \n        int res = 0;\n        if (r[left] > ceil) {\n            int pivot = lower_bound(r.begin() + left, r.end(), ceil, greater<int>()) - r.begin();\n            res = dfs(r, pivot, ceil, memo, cur, best);\n            best = max(best, cur + res);\n            memo[left][ceil] = res;\n            return res;\n        }\n        if (r[left] <= ceil) {\n            res = max(r[left] + dfs(r, left + 1, min(ceil - r[left], r[left] - 1), memo, cur + r[left], best), dfs(r, left + 1, ceil, memo, cur, best));\n            memo[left][ceil] = res;\n            best = max(best, cur + res);\n            return res;\n        }\n        return res;\n    }\npublic:\n    int maxTotalReward(vector<int>& r) {\n        int n = r.size();\n        sort(r.begin(), r.end(), greater<>());\n        int ceil = r[0] - 1;\n        int best = 0;\n        unordered_map<int, unordered_map<int, int>> memo;\n        return r[0] + dfs(r, 1, ceil, memo, 0, best);\n    }\n};",
    "submit_ts": 1717905315.0
}