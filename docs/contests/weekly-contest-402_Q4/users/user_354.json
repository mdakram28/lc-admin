{
    "username": "8188adarsh",
    "submission": "class Solution {\npublic:\n    \nclass SGTree{\n    vector<int> seg;\n    public:\n    // segment tree constructor for defining the size\n    SGTree(int n){\n        seg.assign(4 * n + 1, -1);\n    }\n    // operation function\n    int comp(int a, int b){\n        return a + b;\n    }\n    // for building the segment tree\n    void build(int ind, int left, int right, vector<int>& arr){\n        // when on the leaf node, add the value to the segment\n        if(left == right){\n            seg[ind] = arr[left];\n            return;\n        }\n        // now go on the build the left and right subtree\n        int mid = left + (right - left) / 2;\n        // left subtree\n        build(2 * ind + 1, left, mid, arr);\n        // right subtree\n        build(2 * ind + 2, mid + 1, right, arr);\n        // operation which you need to perform on the subtree\n        seg[ind] = comp(seg[2 * ind + 1], seg[2 * ind + 2]);\n    }\n    // for the query of the data\n    int query(int ind, int left, int right, int l, int r){\n        // when the segment is not in the range (disjoint)\n        if(r < left || l > right) return 0;\n        // when fully in the range \n        if(l <= left && right <= r){\n            return seg[ind];\n        }\n        // partial overlapping\n        int mid = left + (right - left) / 2;\n        int leftC = query(2 * ind + 1, left, mid, l, r);\n        int rightC = query(2 * ind + 2, mid + 1, right, l, r);\n        // operation which you need to perform on the subtree\n        return comp(leftC , rightC);\n    }\n    // point update for the tree\n    void update(int ind, int left, int right, int pos, int val){\n        // when on the leaf node, update the value\n        if(left == right){\n            seg[ind] = val;\n            return;\n        }\n        // now check on the left and right\n        int mid = left + (right - left) / 2;\n        // when the position which need to be update is in left\n        if(left <= pos && pos <= mid){\n            update(2 * ind + 1, left, mid, pos, val);\n        }else update(2 * ind + 2, mid + 1, right, pos, val);\n        // operation which you need to perform on the tree\n        seg[ind] = comp(seg[2 * ind + 1], seg[2 * ind + 2]);\n    }\n \n};\n\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> peak(n, 0);\n        for(int i=1; i<n-1; i++){\n            if(nums[i] > nums[i-1] && nums[i] > nums[i+1]) peak[i] = 1;\n        }\n        SGTree seg(n);\n        seg.build(0, 0, n-1, peak);\n        vector<int> ans;\n        for(auto &q: queries){\n            if(q[0] == 1){\n                ans.push_back(seg.query(0, 0, n-1, q[1] + 1, q[2] - 1));\n            }else{\n                nums[q[1]] = q[2];\n                if(q[1] > 0 && q[1] < n-1){\n                    if(nums[q[1]] > nums[q[1] - 1] && nums[q[1]] > nums[q[1] + 1]) peak[q[1]] = 1;\n                    else peak[q[1]] = 0;\n                    seg.update(0, 0, n-1, q[1], peak[q[1]]);\n                }\n                int prev = q[1] - 1;\n                if(prev > 0 && prev < n-1){\n                    if(nums[prev] > nums[prev-1] && nums[prev] > nums[prev+1]) peak[prev] = 1;\n                    else peak[prev] = 0;\n                    seg.update(0, 0, n-1, prev, peak[prev]);\n                }\n                int next = q[1] + 1;\n                if(next > 0 && next < n-1){\n                    if(nums[next] > nums[next-1] && nums[next] > nums[next+1]) peak[next] = 1;\n                    else peak[next] = 0;\n                    seg.update(0, 0, n-1, next, peak[next]);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1718505961",
    "subm_id": "1289601749"
}