{
    "username": "chroniclesofcode",
    "submission": "class SegtreePNode {\npublic:\n    using LL = long long;\n    LL n = 0;\n    \n    struct node {\n        LL ans = 0;\n        LL lisp = 0, risp = 0, lval = 0, rval = 0, amt = 0;\n        node() : lval(INT_MAX), rval(INT_MAX) {}\n        node(int e) {\n            ans = 0;\n            amt = 1;\n            lisp = 1; risp = 1;\n            lval = e; rval = e;\n        }\n\n        friend node operator+(const node &a, const node &b) {\n            node ret;\n            ret.ans = a.ans + b.ans;\n            ret.amt = a.amt + b.amt;\n            ret.lisp = a.lisp;\n            ret.risp = b.risp;\n            ret.lval = a.lval; ret.rval = b.rval;\n            if (a.amt == 1 && a.rval <= b.lval) {\n                ret.lisp = 0;\n            }\n            if (b.amt == 1 && b.lval <= a.rval) {\n                ret.risp = 0;\n            }\n            if (a.risp && a.rval > b.lval) {\n                ret.ans++;\n                if (b.amt == 1) {\n                    ret.risp = 0;\n                }\n                if (a.amt == 1) {\n                    ret.ans--;\n                }\n            }\n            if (b.lisp && b.lval > a.rval) {\n                ret.ans++;\n                if (a.amt == 1) {\n                    ret.lisp = 0;\n                }\n                if (b.amt == 1) {\n                    ret.ans--;\n                }\n            }\n            \n            return ret;\n        }\n    };\n\n    vector<node> t;\n\n    SegtreePNode(LL sz) : n(sz), t(4 * sz + 1) {}\n\n    node query(LL l, LL r, LL v = 1, LL tl = 0, LL tr = -1) {\n        if (tr == -1) tr = n - 1;\n        if (l > r) \n            return node();\n        if (l == tl && r == tr) {\n            return t[v];\n        }\n        LL tm = (tl + tr) / 2;\n        return query(l, min(r, tm), v * 2, tl, tm) +\n               query(max(l, tm + 1), r, v * 2 + 1, tm + 1, tr);\n    }\n\n    void update(LL pos, LL new_val, LL v = 1, LL tl = 0, LL tr = -1) {\n        if (tr == -1) tr = n - 1;\n        if (tl == tr) {\n            t[v] = new_val;\n        } else {\n            LL tm = (tl + tr) / 2;\n            if (pos <= tm)\n                update(pos, new_val, v * 2, tl, tm);\n            else\n                update(pos, new_val, v * 2 + 1, tm + 1, tr);\n            t[v] = t[v * 2] + t[v * 2 + 1];\n        }\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        SegtreePNode s(n);\n        for (int i = 0; i < n; i++) {\n            s.update(i, nums[i]);\n        }\n        vector<int> ans;\n        for (int i = 0; i < queries.size(); i++) {\n            if (queries[i][0] == 1) {\n                int l = queries[i][1], r = queries[i][2];\n                int res = s.query(l, r).ans;\n                if (l == r) res = 0;\n                ans.push_back(res);\n            } else if (queries[i][0] == 2) {\n                s.update(queries[i][1], queries[i][2]);\n                nums[queries[i][1]] = queries[i][2];\n            }\n        }\n        /*\n        using SN = SegtreePNode::node;\n        SN inter = SN(4) + SN(4);\n        cout << inter.ans << ' ' << inter.lval << ' ' << inter.rval << ' ' << inter.lisp << ' ' << inter.risp  << '\\n';\n        SN tmp = inter + SN(1);\n        cout << tmp.ans << ' ' << tmp.lval << ' ' << tmp.rval << ' ' << tmp.lisp << ' ' << tmp.risp  << '\\n';\n        */\n        return ans;\n    }\n};",
    "submit_ts": 1718509110.0
}