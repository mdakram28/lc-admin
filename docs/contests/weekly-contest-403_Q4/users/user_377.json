{
    "username": "981377660LMT",
    "submission": "INF = int(1e20)\n\n\ndef max2(a: int, b: int) -> int:\n    return a if a > b else b\n\n\ndef min2(a: int, b: int) -> int:\n    return a if a < b else b\n\n\nclass Solution:\n    def minimumSum(self, grid: List[List[int]]) -> int:\n        top, bottom, left, right = self._minimumBounding(grid)\n        newGrid = self._fromBounding(top, bottom, left, right, grid)\n        res = len(newGrid) * len(newGrid[0])\n        for _ in range(4):\n            newGrid = self._rotate(newGrid)\n            res = min2(res, self._solve1(newGrid))\n            res = min2(res, self._solve2(newGrid))\n        return res\n\n    def _solve1(self, grid: List[List[int]]) -> int:\n        \"\"\"\u7ad6\u7740\u5207\u4e24\u5200.\"\"\"\n        row, col = len(grid), len(grid[0])\n        xs = []\n        for r in range(row):\n            for c in range(col):\n                if grid[r][c] == 1:\n                    xs.append(c)\n\n        xs = sorted(set(xs))\n        res = INF\n        for split1 in range(len(xs)):\n            for split2 in range(split1, len(xs)):\n                grid1 = self._fromBounding(0, row - 1, 0, xs[split1], grid)\n                area1 = self._minimumBoundingArea(grid1)\n                grid2 = self._fromBounding(0, row - 1, xs[split1] + 1, xs[split2], grid)\n                area2 = self._minimumBoundingArea(grid2)\n                grid3 = self._fromBounding(0, row - 1, xs[split2] + 1, col - 1, grid)\n                area3 = self._minimumBoundingArea(grid3)\n                res = min2(res, area1 + area2 + area3)\n\n        return res\n\n    def _solve2(self, grid: List[List[int]]) -> int:\n        \"\"\"\u6a2a\u4e00\u5200\u7ad6\u4e00\u5200(\u5de6\u4e0a\u3001\u53f3\u4e0a\u3001\u4e0b.)\"\"\"\n        row, col = len(grid), len(grid[0])\n        xs, ys = [], []\n        for r in range(row):\n            for c in range(col):\n                if grid[r][c] == 1:\n                    xs.append(c)\n                    ys.append(r)\n\n        xs = sorted(set(xs))\n        ys = sorted(set(ys))\n        res = INF\n        for ySplit in range(len(ys)):\n            for xSplit1 in range(len(xs)):\n                # \u5de6\u4e0a\n                grid1 = self._fromBounding(0, ys[ySplit], 0, xs[xSplit1], grid)\n                area1 = self._minimumBoundingArea(grid1)\n                # \u53f3\u4e0a\n                grid2 = self._fromBounding(0, ys[ySplit], xs[xSplit1] + 1, col - 1, grid)\n                area2 = self._minimumBoundingArea(grid2)\n                # \u4e0b\n                grid3 = self._fromBounding(ys[ySplit] + 1, row - 1, 0, col - 1, grid)\n                area3 = self._minimumBoundingArea(grid3)\n                res = min2(res, area1 + area2 + area3)\n        return res\n\n    def _fromBounding(\n        self, top: int, bottom: int, left: int, right: int, grid: List[List[int]]\n    ) -> List[List[int]]:\n        if top > bottom or left > right:\n            return []\n        res = [[0] * (right - left + 1) for _ in range(bottom - top + 1)]\n        for r in range(top, bottom + 1):\n            for c in range(left, right + 1):\n                res[r - top][c - left] = grid[r][c]\n        return res\n\n    def _minimumBounding(self, grid: List[List[int]]) -> Tuple[int, int, int, int]:\n        minTop, maxBottom, minLeft, maxRight = INF, -INF, INF, -INF\n        for r, row in enumerate(grid):\n            for c, v in enumerate(row):\n                if v == 1:\n                    minTop = min2(minTop, r)\n                    maxBottom = max2(maxBottom, r)\n                    minLeft = min2(minLeft, c)\n                    maxRight = max2(maxRight, c)\n        return minTop, maxBottom, minLeft, maxRight\n\n    def _minimumBoundingArea(self, grid: List[List[int]]) -> int:\n        top, bottom, left, right = self._minimumBounding(grid)\n        if top == INF or bottom == -INF or left == INF or right == -INF:\n            return 0\n        return (right - left + 1) * (bottom - top + 1)\n\n    def _rotate(self, grid: List[List[int]]) -> List[List[int]]:\n        return [list(col[::-1]) for col in zip(*grid)]\n",
    "submit_ts": "1719113537",
    "subm_id": "541397893"
}