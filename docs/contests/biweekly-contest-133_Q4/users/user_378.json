{
    "username": "EmZie",
    "submission": "/*\n    30 September 2023\n    Others leetcode\n*/\n\n#ifndef __DEBUG__\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#endif\n\n#undef __INTERACTIVE__\n\n#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n#define pyes cout << \"YES\" //\"Yes\"\n#define pno cout << \"NO\"   //\"No\"\n#define fastio ios_base::sync_with_stdio(0)\n#define untie cin.tie(0)\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repe(i, n) for (int i = 1; i <= (n); i++)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define rrepe(i, n) for (int i = (n); i > 0; i--)\n#define ms(a, b) memset(a, b, sizeof a)\n#define a2z(x) (x).begin(), (x).end()\n#define z2a(x) (x).rbegin(), (x).rend()\n#define gsz(v) ((int)(v).size())\n#define MOD 1000000007 // 998244353\n#define MAX 1000005\n\n#if !defined(__INTERACTIVE__) && !defined(__DEBUG__)\n#define endl \"\\n\"\n#endif\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nusing vb = vector<bool>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vpii = vector<pair<int, int>>;\n\nusing vvb = vector<vector<bool>>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\nusing vvpii = vector<vector<pair<int, int>>>;\n\nusing mii = map<int, int>;\nusing umii = unordered_map<int, int>;\nusing seti = set<int>;\nusing useti = unordered_set<int>;\n\ntemplate <int mod>\nstruct Mod\n{\n    long long x;\n    Mod() : x(0) {}\n    Mod(long long xx) : x(xx)\n    {\n        if (abs(x) >= mod)\n            x %= mod;\n        if (x < 0)\n            x += mod;\n    }\n    operator int() const { return x; }\n    operator long long() const { return x; }\n    Mod operator+(const Mod &a) const\n    {\n        Mod n;\n        n.x = x + a.x;\n        if (n.x >= mod)\n            n.x -= mod;\n        return n;\n    }\n    Mod operator-(const Mod &a) const\n    {\n        Mod n;\n        n.x = x - a.x;\n        if (n.x < 0)\n            n.x += mod;\n        return n;\n    }\n    Mod operator*(const Mod &a) const\n    {\n        return x * a.x;\n    }\n    Mod operator+=(const Mod &a)\n    {\n        x += a.x;\n        if (x >= mod)\n            x -= mod;\n        return *this;\n    }\n    Mod operator-=(const Mod &a)\n    {\n        x -= a.x;\n        if (x < 0)\n            x += mod;\n        return *this;\n    }\n    Mod operator++()\n    {\n        *this += 1;\n        return *this;\n    }\n    Mod operator++(int) // postfix\n    {\n        Mod temp = *this;\n        *this += 1;\n        return temp;\n    }\n    Mod operator--()\n    {\n        *this -= 1;\n        return *this;\n    }\n    Mod operator--(int) // postfix\n    {\n        Mod temp = *this;\n        *this -= 1;\n        return temp;\n    }\n    Mod operator*=(const Mod &a)\n    {\n        x = (x * a.x) % mod;\n        return *this;\n    }\n    Mod pow(long long b) const\n    {\n        Mod ans = 1;\n        Mod a = *this;\n        while (b > 0)\n        {\n            if (b & 1)\n                ans *= a;\n            a *= a;\n            b /= 2;\n        }\n        return ans;\n    }\n    Mod inv() const\n    {\n        return pow(mod - 2);\n    }\n    Mod operator/(const Mod &a) const\n    {\n        return (*this) * a.inv();\n    }\n    Mod operator/=(const Mod &a)\n    {\n        return (*this) *= a.inv();\n    }\n    bool operator==(const Mod &o) const\n    {\n        return x == o.x;\n    }\n    bool operator!=(const Mod &o) const\n    {\n        return x != o.x;\n    }\n    long long operator()() const\n    {\n        return x;\n    }\n    template <int _mod>\n    friend ostream &operator<<(ostream &os, const Mod<_mod> &num)\n    {\n        os << num.x;\n        return os;\n    }\n    template <int _mod>\n    friend istream &operator>>(istream &is, Mod<_mod> &num)\n    {\n        is >> num.x;\n        if (abs(num.x) >= mod)\n            num.x %= mod;\n        if (num.x < 0)\n            num.x += mod;\n        return is;\n    }\n};\nusing base = Mod<MOD>;\nusing vbase = vector<base>;\nusing vvbase = vector<vector<base>>;\nbase two = 2;\n\nnamespace std\n{\n\n    template <class Fun>\n    class y_combinator_result\n    {\n        Fun fun_;\n\n    public:\n        template <class T>\n        explicit y_combinator_result(T &&fun) : fun_(std::forward<T>(fun)) {}\n\n        template <class... Args>\n        decltype(auto) operator()(Args &&...args)\n        {\n            return fun_(std::ref(*this), std::forward<Args>(args)...);\n        }\n    };\n\n    template <class Fun>\n    decltype(auto) y_combinator(Fun &&fun)\n    {\n        return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n    }\n\n}\n\nclass Solution\n{\npublic:\n    int numberOfPermutations(int n, vector<vector<int>> &requirements)\n    {\n        int m = gsz(requirements);\n        int gg = 1;\n        mii t;\n        rep(i, m)\n        {\n            t[requirements[i][0]] = requirements[i][1];\n            gg = max(gg, requirements[i][1]);\n        }\n\n        if (t.find(0) != t.end() && t[0] != 0)\n            return 0;\n\n        vvbase memo(n + 1, vbase(gg + 1));\n        rep(i, gg + 1)\n            memo[0][i] = 1;\n        repe(i, n) rep(j, gg + 1)\n        {\n            base res = 0;\n            if ((t.find(i) != t.end() && t[i] == j) || t.find(i) == t.end())\n            {\n                base lower = 0;\n                if (j > i)\n                    lower = memo[i - 1][j - i - 1];\n                res = memo[i - 1][j] - lower;\n            }\n\n            memo[i][j] = ((j > 0) ? memo[i][j - 1] : base(0)) + base(res);\n            // cout << memo[i][j] << \" \";\n            // if (j == gg)\n            //     cout << endl;\n        }\n\n        return memo[n - 1][gg].x;\n    }\n};\n",
    "submit_ts": 1719070380.0
}