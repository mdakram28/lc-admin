{
    "username": "BennyWu1210",
    "submission": "class Solution {\npublic:\n    long long compute_hash(const string& word, int base, int mod) {\n        long long h = 0;\n        for (char c : word) {\n            h = (h * base + c) % mod;\n        }\n        return h;\n    }\n\n    vector<long long> precompute_powers(int length, int base, int mod) {\n        vector<long long> powers(length + 1, 1);\n        for (int i = 1; i <= length; ++i) {\n            powers[i] = (powers[i - 1] * base) % mod;\n        }\n        return powers;\n    }\n\n    unordered_map<int, vector<pair<int, int>>> rolling_hash_search(const string& S, const vector<string>& words) {\n        // Constants\n        const int base = 257;  // A prime number larger than any character value (assuming ASCII characters)\n        const int mod = 1e9 + 7;  // A large prime number for modulus to avoid overflow\n        \n        // Initialize the result dictionary\n        unordered_map<int, vector<pair<int, int>>> result;\n\n        // Compute hash for all words and store their lengths\n        unordered_map<int, vector<pair<long long, int>>> words_by_length;\n        for (int i = 0; i < words.size(); ++i) {\n            const string& word = words[i];\n            long long word_hash = compute_hash(word, base, mod);\n            words_by_length[word.length()].emplace_back(word_hash, i);\n        }\n\n        // Precompute powers of base\n        int max_word_len = 0;\n        for (const string& word : words) {\n            max_word_len = max(max_word_len, static_cast<int>(word.length()));\n        }\n        vector<long long> powers = precompute_powers(max_word_len, base, mod);\n\n        // Compute rolling hash for string S\n        vector<long long> S_hash(S.length() + 1, 0);\n        for (int i = 1; i <= S.length(); ++i) {\n            S_hash[i] = (S_hash[i - 1] * base + S[i - 1]) % mod;\n        }\n\n        // Check for each word length in words\n        for (const auto& entry : words_by_length) {\n            int word_len = entry.first;\n            if (word_len > S.length()) {\n                continue;\n            }\n            for (int i = 0; i <= S.length() - word_len; ++i) {\n                long long current_hash = (S_hash[i + word_len] - S_hash[i] * powers[word_len] % mod + mod) % mod;\n                for (const auto& word_pair : entry.second) {\n                    long long word_hash = word_pair.first;\n                    int word_index = word_pair.second;\n                    if (current_hash == word_hash) {\n                        int end_index = i + word_len - 1;\n                        result[end_index].emplace_back(words[word_index].size(), word_index);\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n       // Remove duplicates from the words array\n        unordered_map<string, int> word_to_cost;\n        for (int i = 0; i < words.size(); ++i) {\n            if (word_to_cost.find(words[i]) == word_to_cost.end() || word_to_cost[words[i]] > costs[i]) {\n                word_to_cost[words[i]] = costs[i];\n            }\n        }\n\n        // Create a new words and costs array without duplicates\n        vector<string> unique_words;\n        vector<int> unique_costs;\n        for (const auto& entry : word_to_cost) {\n            unique_words.push_back(entry.first);\n            unique_costs.push_back(entry.second);\n        }\n\n        vector<long long> dp(target.size() + 1, INT_MAX);\n        dp[0] = 0;\n\n        unordered_map<int, vector<pair<int, int>>> result = rolling_hash_search(target, unique_words);\n\n        for (int i = 1; i <= target.size(); ++i) {\n            if (result.find(i - 1) != result.end()) {\n                for (const auto& p : result[i - 1]) {\n                    int word_index = p.second;\n                    int start_index = i - p.first;\n                    if (start_index >= 0 && dp[start_index] != INT_MAX) {\n                        dp[i] = min(dp[i], dp[start_index] + unique_costs[word_index]);\n                    }\n                }\n            }\n        }\n\n        return dp[target.size()] == INT_MAX ? -1 : dp[target.size()];\n    }\n\n\n\n};",
    "submit_ts": "1720323278",
    "subm_id": "1312371690"
}