{
    "username": "UrbanTurban",
    "submission": "class Solution {\n    fun countSubarrays(arr: IntArray, k: Int): Long {\n        val n = arr.size\n        val st = SegmentTree(arr)\n        var ans: Long = 0\n\n        for (i in 0 until n) {\n            // 0......i\n            var low = 0\n            var high = i\n            var minIdx = -1\n            while (low <= high) {\n                val mid = low + (high - low) / 2\n                val `and` = st.rangeMinimumQueryLazy(mid, i)\n                if (`and` < k) {\n                    low = mid + 1\n                } else if (`and` > k) {\n                    high = mid - 1\n                } else {\n                    minIdx = mid\n                    high = mid - 1\n                }\n            }\n\n            if (minIdx == -1) {\n                // nothing\n                continue\n            }\n\n            // 0......i\n            low = 0\n            high = i\n            var maxIdx = -1\n            while (low <= high) {\n                val mid = low + (high - low) / 2\n                val `and` = st.rangeMinimumQueryLazy(mid, i)\n                if (`and` < k) {\n                    low = mid + 1\n                } else if (`and` > k) {\n                    high = mid - 1\n                } else {\n                    maxIdx = mid\n                    low = mid + 1\n                }\n            }\n            ans += maxIdx - minIdx + 1\n        }\n        return ans\n    }\n}\n\nclass SegmentTree(arr: IntArray) {\n    private val segmentTree: IntArray\n    private val lazy: IntArray\n    private val n: Int\n\n    init {\n        n = arr.size\n        segmentTree = IntArray(4 * arr.size)\n        lazy = IntArray(4 * arr.size)\n        for (i in segmentTree.indices) {\n            segmentTree[i] = 0\n        }\n        build(arr, 0, arr.size - 1, 0)\n    }\n\n    private fun build(input: IntArray, low: Int, high: Int, pos: Int) {\n        if (low == high) {\n            segmentTree[pos] = input[low]\n            return\n        }\n        val mid = (low + high) / 2\n        build(input, low, mid, 2 * pos + 1)\n        build(input, mid + 1, high, 2 * pos + 2)\n        segmentTree[pos] = segmentTree[2 * pos + 1] and segmentTree[2 * pos + 2]\n    }\n\n    /**\n     * Queries given range lazily\n     */\n    fun rangeMinimumQueryLazy(qlow: Int, qhigh: Int): Int {\n        return rangeMinimumQueryLazy(qlow, qhigh, 0, n - 1, 0)\n    }\n\n    private fun rangeMinimumQueryLazy(qlow: Int, qhigh: Int, low: Int, high: Int, pos: Int): Int {\n        if (low > high) {\n            return Int.MAX_VALUE\n        }\n\n        // make sure all propagation is done at pos. If not update tree\n        // at pos and mark its children for lazy propagation.\n        if (lazy[pos] != 0) {\n            segmentTree[pos] = segmentTree[pos] and lazy[pos]\n            if (low != high) { // not a leaf node\n                lazy[2 * pos + 1] = lazy[2 * pos + 1] and lazy[pos]\n                lazy[2 * pos + 2] = lazy[2 * pos + 2] and lazy[pos]\n            }\n            lazy[pos] = 0\n        }\n\n        // no overlap\n        if (qlow > high || qhigh < low) {\n            return Int.MAX_VALUE\n        }\n\n        // total overlap\n        if (qlow <= low && qhigh >= high) {\n            return segmentTree[pos]\n        }\n\n        // partial overlap\n        val mid = (low + high) / 2\n        return rangeMinimumQueryLazy(qlow, qhigh, low, mid, 2 * pos + 1) and rangeMinimumQueryLazy(qlow, qhigh, mid + 1, high, 2 * pos + 2)\n    }\n}\n\n",
    "submit_ts": "1720280373",
    "subm_id": "1311786935"
}