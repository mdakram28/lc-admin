{
    "username": "GuyEternal",
    "submission": "class Solution {\npublic:\n    enum { TOP, BOTTOM, LEFT, RIGHT };\n\n    void add_connection(vector<vector<long long>> &graph, long long u, long long v) {\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    long long calculate_distance_squared(long long x1, long long y1, long long x2, long long y2) {\n        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n    }\n\n    vector<bool> perform_bfs(long long start, vector<vector<long long>> &graph) {\n        long long node_count = graph.size();\n        vector<bool> visited(node_count, false);\n        queue<long long> bfs_queue;\n        bfs_queue.push(start);\n        visited[start] = true;\n        while (!bfs_queue.empty()) {\n            long long current = bfs_queue.front();\n            bfs_queue.pop();\n            for (long long neighbor : graph[current]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    bfs_queue.push(neighbor);\n                }\n            }\n        }\n        return visited;\n    }\n\nbool solve(int x, int y, vector<vector<int>>& c) {\n    long long width = x, height = y, circle_count = c.size();\n    vector<vector<long long>> circles(circle_count, vector<long long> (3, 0));\n    vector<vector<long long>> graph(circle_count + 4);\n    for (long long i = 0; i < circle_count; ++i) {\n        for (long long j = 0; j < 3; ++j) {\n            circles[i][j] = c[i][j];\n        }\n    }\n\n    for (long long i = 0; i < circle_count; ++i) {\n        long long index = i + 4;\n\n        if (circles[i][0] - circles[i][2] <= 0)\n            add_connection(graph, LEFT, index);\n        if (circles[i][0] + circles[i][2] >= width)\n            add_connection(graph, RIGHT, index);\n        if (circles[i][1] - circles[i][2] <= 0)\n            add_connection(graph, BOTTOM, index);\n        if (circles[i][1] + circles[i][2] >= height)\n            add_connection(graph, TOP, index);\n    }\n\n    for (long long i = 0; i < circle_count; ++i) {\n        long long idx_i = i + 4;\n        for (long long j = i + 1; j < circle_count; ++j) {\n            long long idx_j = j + 4;\n            if (calculate_distance_squared(circles[i][0], circles[i][1], circles[j][0], circles[j][1]) \n                <= (circles[i][2] + circles[j][2]) * (circles[i][2] + circles[j][2])) {\n                add_connection(graph, idx_i, idx_j);\n            }\n        }\n    }\n\n    vector<bool> left_visited = perform_bfs(LEFT, graph);\n    vector<bool> right_visited = perform_bfs(RIGHT, graph);\n    vector<bool> top_visited = perform_bfs(TOP, graph);\n    vector<bool> bottom_visited = perform_bfs(BOTTOM, graph);\n\n    bool answer = !left_visited[BOTTOM] && !bottom_visited[LEFT] && \n                  !top_visited[BOTTOM] && !bottom_visited[TOP] && \n                  !top_visited[RIGHT] && !right_visited[TOP] && \n                  !left_visited[RIGHT] && !right_visited[LEFT];\n\n    // cout << (answer ? \"YES\" : \"NO\") << endl;\n    return answer;\n}\n\n\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        return solve(X, Y, circles);\n    }\n};",
    "submit_ts": "1722136443",
    "subm_id": "1335734640"
}