{
    "username": "swapnesh-khemariya",
    "submission": "#define ll long long int\n ll mod = 1e9+7;\nstruct Item{\npublic:\n    ll leftVal;\n    ll leftSum;  // without including right value\n    ll rightVal;\n    ll rightSum; // without including left value\n    ll midSum;   // not considering left and right\n    ll sum;  // considering whole sequence\n};\n \nclass segTree\n{\npublic:\n    vector<Item> values;\n    int sizz;\n    segTree(int n)\n    {\n        sizz = 1;\n        while (sizz < n)\n            sizz *= 2;\n        values.resize(2 * sizz);\n    }\n \n    Item single(int m){\n        Item c;\n        // ll leftVal;\n        // ll leftSum;  // without including right value\n        // ll rightVal;\n        // ll rightSum; // without including left value\n        // ll sum;\n\n        c.leftVal = m;\n        c.leftSum = 0;\n        c.rightVal = m;\n        c.rightSum = 0;\n        c.midSum = 0;\n        c.sum = max(0, m);\n        return c;\n    }\n    Item merge(Item a, Item b){\n        Item c;\n        c.leftVal = a.leftVal;\n        c.leftSum = max(a.leftSum + b.leftSum, a.sum + b.midSum);\n        c.rightVal = b.rightVal;\n        c.rightSum = max(a.rightSum + b.rightSum, a.midSum + b.sum);\n        c.midSum = max({a.rightSum + b.midSum, a.midSum + b.leftSum, a.rightSum + b.midSum});\n        c.sum = max({a.sum, b.sum, c.leftSum, c.rightSum, c.midSum, a.sum + b.rightSum, a.leftSum + b.sum});\n        return c;\n    }\n \n    void build(int x, int lx, int rx, vector<int> &arr)\n    {\n        if (rx - lx == 1)\n        {\n            if (lx < arr.size())\n                values[x] = single(arr[lx]);\n            return;\n        }\n        int m = (lx + rx) / 2;\n        build(2 * x + 1, lx, m, arr);\n        build(2 * x + 2, m, rx, arr);\n        values[x] = merge(values[2 * x + 1], values[2 * x + 2]);\n    }\n \n    void build(vector<int> &arr)\n    {\n        build(0, 0, sizz, arr);\n    }\n \n    void set(int x, int lx, int rx, int i, int v)\n    {\n        if (rx - lx == 1)\n        {\n            values[x] = single(v);\n            return;\n        }\n        int m = (lx + rx) / 2;\n        if (i < m)\n            set(2 * x + 1, lx, m, i, v);\n        else\n            set(2 * x + 2, m, rx, i, v);\n        values[x] = merge(values[2 * x + 1], values[2 * x + 2]);\n    }\n \n    void set(int i, int v)\n    {\n        set(0, 0, sizz, i, v);\n    }\n \n    Item calc()\n    {\n        return values[0];\n    }\n};\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        nums.push_back(0);\n        int n = nums.size();\n        segTree *T = new segTree(n);\n        T->build(nums);\n\n        ll ans = 0;\n        for(auto &q:queries){\n            T->set(q[0], q[1]);\n            ans += max(0ll, T->calc().sum);\n            ans%=mod;\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716695040.0
}