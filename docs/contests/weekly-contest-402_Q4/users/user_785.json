{
    "username": "inversionpeter",
    "submission": "int counts[400005];\n\nvoid BuildSegmentTree(int left, int right, int index, vector <int> &numbers) {\n    if (left == right) {\n        counts[index] = 0;\n        return;\n    }\n    int middle = (left + right) >> 1;\n    BuildSegmentTree(left, middle, index << 1, numbers);\n    BuildSegmentTree(middle + 1, right, (index << 1) + 1, numbers);\n    counts[index] = counts[index << 1] + counts[(index << 1) + 1];\n    if (left < middle && numbers[middle - 1] < numbers[middle] && numbers[middle] > numbers[middle + 1]) {\n        ++counts[index];\n    }\n    if (middle + 1 < right && numbers[middle] < numbers[middle + 1] && numbers[middle + 1] > numbers[middle + 2]) {\n        ++counts[index];\n    }\n    //cout << left << ' ' << right << ' ' << counts[index] << '\\n';\n}\n\nvoid Update(int targetIndex, int left, int right, int index, vector <int> &numbers) {\n    if (left == right) {\n        return;\n    }\n    int middle = (left + right) >> 1;\n    if (targetIndex <= middle) {\n        Update(targetIndex, left, middle, index << 1, numbers);\n    }\n    if (middle < targetIndex) {\n        Update(targetIndex, middle + 1, right, (index << 1) + 1, numbers);\n    }\n    counts[index] = counts[index << 1] + counts[(index << 1) + 1];\n    if (left < middle && numbers[middle - 1] < numbers[middle] && numbers[middle] > numbers[middle + 1]) {\n        ++counts[index];\n    }\n    if (middle + 1 < right && numbers[middle] < numbers[middle + 1] && numbers[middle + 1] > numbers[middle + 2]) {\n        ++counts[index];\n    }\n}\n\nint Query(int intervalLeft, int intervalRight, int left, int right, int index, vector <int> &numbers) {\n    if (intervalLeft <= left && right <= intervalRight) {\n        return counts[index];\n    }\n    int middle = (left + right) >> 1, total = 0;\n    if (intervalLeft <= middle) {\n        total += Query(intervalLeft, intervalRight, left, middle, index << 1, numbers);\n    }\n    if (middle < intervalRight) {\n        total += Query(intervalLeft, intervalRight, middle + 1, right, (index << 1) + 1, numbers);\n    }\n    //cout << left << ' ' << right << ' ' << total << '\\n';\n    if (intervalLeft <= middle && middle < intervalRight) {\n        //cout << \"   \" << left << ' ' << middle << ' ' << right << '\\n';\n        if (max(left, intervalLeft) < middle && numbers[middle - 1] < numbers[middle] && numbers[middle] > numbers[middle + 1]) {\n            ++total;\n        }\n        else if (middle + 1 < min(right, intervalRight) && numbers[middle] < numbers[middle + 1] && numbers[middle + 1] > numbers[middle + 2]) {\n            ++total;\n        }\n    }\n    //cout << \" -> \" << left << ' ' << right << ' ' << total << '\\n';\n    return total;\n}\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        vector <int> answer;\n        BuildSegmentTree(0, nums.size() - 1, 1, nums);\n        for (vector <int> &query : queries) {\n            if (query[0] == 1) {\n                answer.push_back(Query(query[1], query[2], 0, nums.size() - 1, 1, nums));\n                //cout << '\\n';\n            }\n            else {\n                nums[query[1]] = query[2];\n                Update(query[1], 0, nums.size() - 1, 1, nums);\n            }\n        }\n        return answer;\n    }\n};\n\n/*\n[10,5,10,3,7]\n[[2,4,2],[1,1,4],[1,1,3],[1,2,2]]\n*/",
    "submit_ts": 1718508173.0
}