{
    "username": "deepli",
    "submission": "class Solution {\n    \n     \n    public int treeDiameter(int[][] edges) {\n\n         \n        List<Set<Integer>> graph = new ArrayList<Set<Integer>>();\n        for (int i = 0; i < edges.length + 1; ++i) {\n            graph.add(new HashSet<Integer>());\n        }\n        for (int[] edge : edges) {\n            Integer u = edge[0], v = edge[1];\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n\n        // find the outer most nodes, i.e. leaf nodes\n        LinkedList<Integer> leaves = new LinkedList<Integer>();\n        for (int vertex = 0; vertex < graph.size(); ++vertex) {\n            if (graph.get(vertex).size() == 1)\n                leaves.add(vertex);\n        }\n\n        // \"peel\" the graph layer by layer,\n        // until we have the centroids left.\n        int layers = 0;\n        int vertexLeft = edges.length + 1;\n        while (vertexLeft > 2) {\n            vertexLeft -= leaves.size();\n\n            LinkedList<Integer> nextLeaves = new LinkedList<Integer>();\n\n            for (int leaf : leaves) {\n                // the only neighbor left on the leaf node.\n                int neighbor = graph.get(leaf).iterator().next();\n                graph.get(neighbor).remove(leaf);\n                if (graph.get(neighbor).size() == 1)\n                    nextLeaves.add(neighbor);\n            }\n\n            layers += 1;\n            leaves = nextLeaves;\n        }\n\n        if (vertexLeft == 1)\n            return layers * 2;\n        else\n            return layers * 2 + 1;\n    }\n\n    public int minimumDiameterAfterMerge(int[][] e1, int[][] e2) {\n    // public static int minDiameter(int n, int[][] edges1, int m, int[][] edges2) {\n  \n        \n        int n = e1.length;\n        int m = e2.length;\n        \n        \n        int x = treeDiameter(e1);\n        int y = treeDiameter(e2);\n                System.out.println(\"n = \"+ n + \", m = \" + m);\n        System.out.println(\"x = \"+ x + \", yu = \" + y);       \n        \n        \n        if(n == 0 && m == 0) return 1;\n        \n        // if(n == 0 && y ==2) return 2;\n        // if(m == 0 && x ==2) return 2;\n        \n//         if(n == 0) return y - 1;\n//         if(m == 0) return x - 1;\n        if(x == 2 && y==2) return 3;\n        \n        int res = x;\n \n        \n        res = Math.max(res, y);\n        // System.out.println(\"res = \"+ res);\n        //  System.out.println(\"x = \"+ x + \", yu = \" + y);    \n        res = Math.max(res, (x + 1)/2 + (y + 1)/2 + 1);\n         // System.out.println(\"res2 = \"+ res);       \n        \n        return res;\n        \n//         \n//         if(x%2 == 0 && y %2 == 0){\n//             return x/2 + y/2 + 1;\n//         }\n        \n\n//          if(x%2 == 1 && y %2 == 1){\n//             return x/2 + 1 + y/2 + 1 + 1;\n//         }\n        \n//          if(x%2 == 0 && y %2 == 1){\n//             return x/2 + y/2 + 1 + 1;\n//         }\n        \n//          if(x%2 == 1 && y %2 == 0){\n//             return x/2 + y/2 + 1 + 1;\n//         }\n//         return -1;\n    }\n        \n        \n        \n}",
    "submit_ts": "1719719572",
    "subm_id": "1304445236"
}