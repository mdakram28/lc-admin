{
    "username": "NeoClear",
    "submission": "class Grid:\n    @cache\n    def min_area(self, l, r, t, b) -> int:\n        left, right = l, r\n        top, bottom = t, b\n\n        while left <= right and sum(self.grid[i][left] for i in range(t, b + 1)) == 0:\n            left += 1\n\n        while left <= right and sum(self.grid[i][right] for i in range(t, b + 1)) == 0:\n            right -= 1\n\n        while top <= bottom and sum(self.grid[top][i] for i in range(l, r + 1)) == 0:\n            top += 1\n\n        while top <= bottom and sum(self.grid[bottom][i] for i in range(l, r + 1)) == 0:\n            bottom -= 1\n\n        return (right - left + 1) * (bottom - top + 1)\n\n    def __init__(self, grid: List[List[int]]):\n        rows, cols = len(grid), len(grid[0])\n        \n        left, right = 0, cols - 1\n        top, bottom = 0, rows - 1\n        \n        while sum(grid[i][left] for i in range(rows)) == 0:\n            left += 1\n        \n        while sum(grid[i][right] for i in range(rows)) == 0:\n            right -= 1\n        \n        while sum(grid[top]) == 0:\n            top += 1\n        \n        while sum(grid[bottom]) == 0:\n            bottom -= 1\n        \n        self.grid = grid\n        self.left = left\n        self.right = right\n        self.top = top\n        self.bottom = bottom\n        \n    def vertical(self):\n        if self.left == self.right:\n            return self.min_area(self.left, self.right, self.top, self.bottom)\n        \n        if self.left + 1 == self.right:\n            return self.min_area(self.left, self.left, self.top, self.bottom) + self.min_area(self.right, self.right, self.top, self.bottom)\n        \n        ans = 1000\n        \n        for left in range(self.left, self.right + 1):\n            for right in range(left + 1, self.right):\n                ans = min(ans, (self.min_area(self.left, left, self.top, self.bottom)\n                              + self.min_area(left + 1, right, self.top, self.bottom)\n                              + self.min_area(right + 1, self.right, self.top, self.bottom)))\n        return ans\n    \n    def horizontal(self):\n        if self.top == self.bottom:\n            return self.min_area(self.left, self.right, self.top, self.bottom)\n        if self.top + 1 == self.bottom:\n            return (self.min_area(self.left, self.right, self.top, self.top)\n                  + self.min_area(self.left, self.right, self.bottom, self.bottom))\n        \n        ans = 1000\n        \n        for top in range(self.top, self.bottom + 1):\n            for bottom in range(top + 1, self.bottom):\n                ans = min(ans, (self.min_area(self.left, self.right, self.top, top)\n                              + self.min_area(self.left, self.right, top + 1, bottom)\n                              + self.min_area(self.left, self.right, bottom + 1, self.bottom)))\n        \n        return ans\n    \n    def cross(self):\n        # already covered by the other two solution method, no need to calculate\n        if self.top == self.bottom or self.left == self.right:\n            return 1000\n        \n        ans = 1000\n        \n        for horizontal in range(self.top, self.bottom):\n            for vertical in range(self.left, self.right):\n                areas = [\n                    self.min_area(self.left, vertical, self.top, horizontal),\n                    self.min_area(vertical + 1, self.right, self.top, horizontal),\n                    self.min_area(self.left, vertical, horizontal + 1, self.bottom),\n                    self.min_area(vertical + 1, self.right, horizontal + 1, self.bottom)\n                ]\n                \n                ans = min([\n                    ans,\n                    (self.min_area(self.left, vertical, self.top, horizontal) +\n                     self.min_area(vertical + 1, self.right, self.top, horizontal) +\n                     self.min_area(self.left, self.right, horizontal + 1, self.bottom)),\n                    (self.min_area(self.left, vertical, self.top, horizontal) +\n                     self.min_area(self.left, vertical, horizontal + 1, self.bottom) +\n                     self.min_area(vertical + 1, self.right, self.top, self.bottom)),\n                    (self.min_area(self.left, vertical, horizontal + 1, self.bottom) +\n                     self.min_area(vertical + 1, self.right, horizontal + 1, self.bottom) +\n                     self.min_area(self.left, self.right, self.top, horizontal)),\n                    (self.min_area(vertical + 1, self.right, self.top, horizontal) +\n                     self.min_area(vertical + 1, self.right, horizontal + 1, self.bottom) +\n                     self.min_area(self.left, vertical, self.top, self.bottom))\n                ])\n\n        return ans\n        \n                \n\n\nclass Solution:\n    def minimumSum(self, grid: List[List[int]]) -> int:\n        grid = Grid(grid)\n        return min([grid.vertical(), grid.horizontal(), grid.cross()])",
    "submit_ts": 1719114842.0
}