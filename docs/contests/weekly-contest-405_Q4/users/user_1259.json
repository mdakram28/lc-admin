{
    "username": "mehulparihar",
    "submission": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n// #pragma GCC optimize(\"O3\")\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate < typename T_container, typename T = typename enable_if < !is_same<T_container, string>::value, typename T_container::value_type >::type > ostream & operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << '[' << __FILE__ << ':' << __LINE__ << \"] (\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n// #define int long long int\n#define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n#define endl '\\n'\n#define INF LLONG_MAX\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((int)(x).size())\n#define forn(i, n) for (int i = 0; i < n; i++)\n#define forr(i, a, b) for (int i = a; i <= b; i++)\n#define trav(x, v) for (auto &x : v)\nconst int mod = 1e9 + 7;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef tree<int, null_type, less<int>, rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\ninline void debugMode() {\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif // ONLINE_JUDGE\n}\n\ntemplate<typename T>\nT gcd(T a, T b) { return (b == 0) ? a : gcd(b, a % b); }\n\ntemplate<typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\nclass SegmentTree {\npublic:\n    SegmentTree(int n) : n(n) {\n        seg.resize(4 * n, INT_MAX);\n    }\n\n    void update(int idx, int value) {\n        update(0, 0, n - 1, idx, value);\n    }\n\n    int query(int l, int r) {\n        return query(0, 0, n - 1, l, r);\n    }\n\nprivate:\n    int n;\n    vector<int> seg;\n\n    void update(int node, int start, int end, int idx, int value) {\n        if (start == end) {\n            seg[node] = value;\n        } else {\n            int mid = (start + end) / 2;\n            if (idx <= mid) {\n                update(2 * node + 1, start, mid, idx, value);\n            } else {\n                update(2 * node + 2, mid + 1, end, idx, value);\n            }\n            seg[node] = min(seg[2 * node + 1], seg[2 * node + 2]);\n        }\n    }\n\n    int query(int node, int start, int end, int l, int r) {\n        if (r < start || l > end) {\n            return INT_MAX;\n        }\n        if (l <= start && r >= end) {\n            return seg[node];\n        }\n        int mid = (start + end) / 2;\n        int leftPart = query(2 * node + 1, start, mid, l, r);\n        int rightPart = query(2 * node + 2, mid + 1, end, l, r);\n        return min(leftPart, rightPart);\n    }\n};\n\n\nclass Solution {\npublic:\n    struct TrieNode {\n        unordered_map<char, TrieNode*> child;\n        vector<pair<int, int>> WE;\n    };\n\n    class Trie {\n    public:\n        TrieNode* root;\n        Trie() { root = new TrieNode(); }\n\n        void insert(string& word, int index, int cost) {\n            TrieNode* node = root;\n            for (char c : word) {\n                if (!node->child.count(c))\n                    node->child[c] = new TrieNode();\n                node = node->child[c];\n            }\n            node->WE.push_back({index, cost});\n        }\n    };\n\n    vector<int> Store;\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int n = target.size();\n        Store.resize(n+1, INT_MAX);\n        Store[0] = 0;\n\n        Trie mp;\n        for (int i = 0; i < words.size(); ++i) \n        {\n            string temp_word = words[i];\n            int total = costs[i];\n            mp.insert(temp_word, i, total);\n        }\n        \n\n        for (int i = 0; i < n; ++i) {\n           \n            if(Store[i] != INT_MAX)\n            {\n                TrieNode* node = mp.root;\n                for (int j = i; j < n; ++j) {\n                    if (!node->child.count(target[j])) break;\n                    node = node->child[target[j]];\n                    for (auto p : node->WE) {\n                       \n                        int size = words[p.first].size() + i;\n                        if (size <= n) {\n                            Store[size] = min(Store[size], Store[i] + p.second);\n                        }\n                    }\n                }\n            }\n        }\n        int final_ans = Store[n];\n        if(final_ans == INT_MAX)\n        {\n            return -1;\n        }\n        return final_ans;\n    }\n};",
    "submit_ts": "1720323194",
    "subm_id": "1312369636"
}