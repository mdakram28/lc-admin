{
    "username": "Technical_Guruji",
    "submission": "#include<bits/stdc++.h>\n#include <queue>\n#include <algorithm>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"inline\")\n\n\n#define ff              first\n#define ss              second\n#define all(x)          begin(x), end(x)\n#define pb              push_back\n#define MOD             1000000007\n#define mod             1000000007\n#define INF             1e18\n#define rev(x)          reverse(all(x));\n#define nextP(v)        next_permutation(all(v))\n#define Vmax(x)         (*max_element(all(x)))\n#define Vmin(x)         (*min_element(all(x)))\n#define Vsum(x)         accumulate(all(x),0ll)\n#define lowB(v,x)       (lower_bound(all(v),x)-v.begin())\n#define upB(v,x)        (upper_bound(all(v),x)-v.begin())\n#define cntB(x)         (__builtin_popcountll(x))\n#define cntC(s,x)       ll(count(all(s),x))\n//#define mp              make_pair\n#define nl              cout << \"\\n\";\n#define Yes             cout << \"Yes\\n\"\n#define No              cout << \"No\\n\"\n#define prs(n)          fixed << setprecision(n)\n#define dbg(x)          cout << #x << \" = \" << x << endl;\n#define inpt(v)         For(sz(v)) cin >> v[i];\n#define prt(v)          {for(auto &x:v) cout << x << ' '; nl}\n#define BIG             200005\n#define For(n)          for (ll i = 0; i < n ;i++)\n#define ForR(n)         for (ll i = n; i >= 0; i--)\n#define Forj(n)         for (ll j = 0; j < n; j++)\n#define For1(n)         for (ll i = 1; i < n; ++i)\n#define For2(n)         for (ll i = 2; i < n; i++)\n#define Forl(x,y,z)     for (ll x = y; x < z; x++)\n#define go(i,n)         for (ll i = 0; i <=n; ++i)\n#define rep(i,a,n)      for (ll i = a; i <=n; i++)\n#define loop(j, i, n)   for (ll j = i; j < n; j++)\n\nusing namespace std;\n\n\n\n\ntemplate <class T> using v = vector<T>;\nusing lli = long long int;\nusing ll = long long;\nusing ld = long double;\nusing vl = vector<long long>;\nusing vs  = vector<string>;\nusing vpl = vector<pair<ll,ll>>;\nusing sll = set<ll>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<ld, ld>;\nusing mll = map<ll,ll>;\nusing vvl = vector<vector<ll>>;\nusing vpll = vector<pll>;\n\nconst int alphabet = 'z' - 'a' + 1;\n\n\n\nll lcm(ll a, ll b) { return (a / __gcd(a, b)) * b; }\n\n\nll power(ll a,ll b) {ll r=1; while(b) {if(b&1) r=(r*a)%MOD; a=(a*a)%MOD; b/=2;} return r;}\n\n// we have to add condition that number position where a[i]=1 we have to consider position not number 1\nvl sieve(ll n) {vl a(n+1,1),v; a[0]=a[1]=0; Forl(i,2,n+1) if(a[i]) {v.push_back(i); for(ll j=2*i; j <=n; j+=i) a[j]=0;} return a;}\n\nvl divsr(ll n) {vl a(n+1,1); For(n+1) a[i]=i; Forl(i,2,n+1) if(a[i]==i) {for(ll j=2*i; j<=n; j+=i) a[j]=i;} return a;}\n\n// factorial 0 to n\nvl factorial(ll n) {vl v(n+1,1); Forl(i,2,n+1) v[i] = (v[i-1]*i)%MOD; return v;}\n\n// template function added\n\ntemplate <typename T> bool chkMax(T &x, T y) { return (y > x) ? x = y, 1 : 0; }\n\ntemplate <typename T> bool chkMin(T &x, T y) { return (y < x) ? x = y, 1 : 0; }\n\n// put the class functiion insdie it\n\n\n\nclass Solution {\n\npublic:\n\n\n\n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n\n\n\n        vector<int> differences(nums.size());\n\n\n\n        size_t index = 0;\n\n\n\n        while (index < nums.size()) {\n\n\n            differences[index] = target[index] - nums[index];\n\n\n            index++;\n\n\n\n        }\n\n        \n        \n        \n        \n        long long totalOps = 0;\n        \n        \n        \n        long long currSegDiff = 0;\n\n        \n        \n        \n        index = 0;\n        \n        \n        \n        while (index < differences.size()) {\n        \n        \n        \n        \n            if (index == 0 || (differences[index - 1] > 0 && differences[index] > 0) || (differences[index - 1] < 0 && differences[index] < 0)) {\n        \n        \n        \n        \n        \n                int addOps = abs(differences[index]) - abs(currSegDiff);\n        \n        \n        \n        \n        \n                if (addOps > 0) {\n        \n        \n        \n        \n                    totalOps += addOps;\n        \n        \n        \n        \n                }\n        \n        \n        \n        \n        \n                currSegDiff = differences[index];\n        \n        \n        \n            } else {\n        \n        \n        \n        \n        \n                totalOps += abs(differences[index]);\n        \n        \n        \n        \n                currSegDiff = differences[index];\n        \n        \n        \n        \n        \n            }\n        \n        \n        \n        \n            index++;\n        \n        \n        \n        \n        }\n\n        \n        \n        \n        \n        return totalOps;\n    \n    \n    \n    \n    \n    }\n\n\n\n\n\n\n\n\n\n};\n\n\n\n\n\n\n\n\n\n\n\n#ifdef LOCAL\nint main() {\n\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tcout << \"Compiled!\" << endl;\n}\n#endif\n",
    "submit_ts": "1721533240",
    "subm_id": "1328004547"
}