{
    "username": "LxRBS",
    "submission": "struct FenwickTree{ // \u6811\u72b6\u6570\u7ec4\n\nusing value_type = long long int;\nusing vec_type = vector<value_type>;\n\nint n;\nvec_type c;\n\nFenwickTree() = default;\n\nstatic int lowbit(int x){return x & -x;}\n\nvoid init(int nn){this->c.assign((this->n=nn) + 1, 0);}\n\nvoid modify(int pos, value_type delta){\n    for(int i=pos;i<=this->n;i+=lowbit(i)) this->c[i] += delta;\n}\n\nvalue_type query(int pos)const{\n    value_type ans = 0;\n    for(int i=pos;i;i-=lowbit(i)) ans += this->c[i];\n    return ans;\n}\n\nvalue_type query(int s, int e)const{return this->query(e) - this->query(s - 1);}\n\n};\n\nclass Solution {\n\nint N;\nFenwickTree Bt;\n\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        nums.insert(nums.begin(), 0x3F4F5F6F);        \n        int n = nums.size() - 1;\n        N = n;\n        Bt.init(n);\n        for(int i=1;i<n;++i){\n            if(nums[i - 1] < nums[i] and nums[i + 1] < nums[i]){\n                Bt.modify(i, 1);\n            }\n        }\n        \n        vector<int> ans;\n        for(const auto & q : queries){\n            int cmd = q[0];\n            int s = q[1] + 1;            \n            if(1 == cmd){\n                int e = q[2] + 1;\n                auto tmp = 0;\n                if(s + 1 <= e - 1){\n                    tmp = Bt.query(s + 1, e - 1);\n                }\n                ans.emplace_back(tmp);\n            }else if(2 == cmd){\n                int v = q[2];                \n                this->check(nums, s, v);\n            }else{\n                assert(0);\n            }\n        }\n        return ans;\n    }\n\n    void check(vector<int>& a, int pos, int v){\n        bool pre, cur;\n        if(pos > 2){\n            pre = a[pos - 2] < a[pos - 1] and a[pos] < a[pos - 1];\n            cur = a[pos - 2] < a[pos - 1] and v < a[pos - 1];\n            if(pre != cur){\n                if(pre){\n                    Bt.modify(pos - 1, -1);\n                }else{\n                    Bt.modify(pos - 1, 1);\n                }\n            }\n        }\n        if(pos + 1 < N){\n            pre = a[pos + 2] < a[pos + 1] and a[pos] < a[pos + 1];\n            cur = a[pos + 2] < a[pos + 1] and v < a[pos + 1];\n            if(pre != cur){\n                if(pre){\n                    Bt.modify(pos + 1, -1);\n                }else{\n                    Bt.modify(pos + 1, 1);\n                }\n            }\n        }\n\n        if(1 < pos and pos < N){\n            pre = a[pos - 1] < a[pos] and a[pos + 1] < a[pos];\n            cur = a[pos - 1] < v and a[pos + 1] < v;\n            if(pre != cur){\n                if(pre){\n                    Bt.modify(pos, -1);\n                }else{\n                    Bt.modify(pos, 1);\n                }\n            }\n        }\n\n        a[pos] = v;\n        return;\n    }\n};",
    "submit_ts": 1718508234.0
}