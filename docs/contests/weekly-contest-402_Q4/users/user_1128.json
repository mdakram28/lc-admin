{
    "username": "Luffy-1111",
    "submission": "class Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        st = SegmentTree(nums)\n        results = []\n        for q in queries:\n            if q[0] == 1:\n                results.append(st.query_range(q[1], q[2]))\n            elif q[0] == 2:\n                st.update_seg_tree(q[1], q[2])\n        return results\n        \n        \nclass SegmentTree:\n    def __init__(self, data):\n        self.n = len(data)\n        self.data = data\n        self.tree = [None] * (4 * self.n)\n        self.build(0, 0, self.n - 1)\n        \n    def build(self, node, start, end):\n        if start == end:\n            if start == 0 or start == self.n - 1 or self.data[start] <= self.data[start - 1] or self.data[start] <= self.data[start + 1]:\n                self.tree[node] = (0, self.data[start], self.data[start])\n            else:\n                # print(start)\n                self.tree[node] = (1, self.data[start], self.data[start])\n        else:\n            mid = (start + end) // 2\n            self.build(2 * node + 1, start, mid)\n            self.build(2 * node + 2, mid + 1, end)\n            self.tree[node] = self.merge(self.tree[2 * node + 1], self.tree[2 * node + 2])\n            \n    def merge(self, left, right):\n        peak_count = left[0] + right[0]\n        return (peak_count, left[1], right[2])\n    \n    def update_seg_tree(self, idx, value):\n        self.data[idx] = value\n        start = max(0, idx - 1)\n        end = min(self.n - 1, idx + 1)\n        for i in range(start, end + 1):\n            if i > 0 and i < self.n - 1:\n                if self.data[i] > self.data[i - 1] and self.data[i] > self.data[i + 1]:\n                    self.update(0, 0, self.n - 1, i, 1)\n                else:\n                    self.update(0, 0, self.n - 1, i, 0)\n    \n    def update(self, node, start, end, idx, is_peak):\n            if start == end:\n                self.tree[node] = (is_peak, self.data[start], self.data[start])\n            else:\n                mid = (start + end) // 2\n                if start <= idx <= mid:\n                    self.update(2 * node + 1, start, mid, idx, is_peak)\n                else:\n                    self.update(2 * node + 2, mid + 1, end, idx, is_peak)\n                self.tree[node] = self.merge(self.tree[2 * node + 1], self.tree[2 * node + 2])\n\n    def query(self, L, R, node, start, end):\n        if R < start or end < L:\n            return None\n        if L <= start and end <= R:\n            return self.tree[node]\n        mid = (start + end) // 2\n        left_res = self.query(L, R, 2 * node + 1, start, mid)\n        right_res = self.query(L, R, 2 * node + 2, mid + 1, end)\n        if not left_res:\n            return right_res\n        if not right_res:\n            return left_res\n        return self.merge(left_res, right_res)\n\n    def query_range(self, l, r):\n        if r <= l + 1:\n            return 0\n        result = self.query(l + 1, r - 1, 0, 0, self.n - 1)\n        return result[0] if result else 0",
    "submit_ts": "1718509612",
    "subm_id": "1289712746"
}