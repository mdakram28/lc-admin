{
    "username": "ayukumi",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        if (edges1.empty() && edges2.empty()) {\n            return 1;\n        }\n        if (edges1.empty() || edges2.empty()) {\n            return 2;\n        }\n\n        int diameter1 = calculateDiameter(edges1);\n        int diameter2 = calculateDiameter(edges2);\n\n        vector<int> centers1 = findCenters(edges1);\n        vector<int> centers2 = findCenters(edges2);\n\n        int minDiameter = INT_MAX;\n        for (int center1 : centers1) {\n            for (int center2 : centers2) {\n                int newDiameter = max({diameter1, diameter2, (diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1});\n                minDiameter = min(minDiameter, newDiameter);\n            }\n        }\n\n        return minDiameter;\n    }\n\nprivate:\n    int calculateDiameter(const vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vector<vector<int>> adjacency(n);\n        for (const auto& edge : edges) {\n            adjacency[edge[0]].push_back(edge[1]);\n            adjacency[edge[1]].push_back(edge[0]);\n        }\n\n        auto [farthestNode, maxDistance] = performBFS(adjacency, 0);\n        auto [_, diameter] = performBFS(adjacency, farthestNode);\n        return diameter;\n    }\n\n    vector<int> findCenters(const vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vector<vector<int>> adjacency(n);\n        vector<int> degree(n, 0);\n        for (const auto& edge : edges) {\n            adjacency[edge[0]].push_back(edge[1]);\n            adjacency[edge[1]].push_back(edge[0]);\n            degree[edge[0]]++;\n            degree[edge[1]]++;\n        }\n\n        queue<int> leaves;\n        for (int i = 0; i < n; ++i) {\n            if (degree[i] == 1) {\n                leaves.push(i);\n            }\n        }\n\n        int remainingNodes = n;\n        while (remainingNodes > 2) {\n            int leavesCount = leaves.size();\n            remainingNodes -= leavesCount;\n            for (int i = 0; i < leavesCount; ++i) {\n                int leaf = leaves.front();\n                leaves.pop();\n                for (int neighbor : adjacency[leaf]) {\n                    if (--degree[neighbor] == 1) {\n                        leaves.push(neighbor);\n                    }\n                }\n            }\n        }\n\n        vector<int> centers;\n        while (!leaves.empty()) {\n            centers.push_back(leaves.front());\n            leaves.pop();\n        }\n        return centers;\n    }\n\n    pair<int, int> performBFS(const vector<vector<int>>& adjacency, int start) {\n        int n = adjacency.size();\n        vector<int> distance(n, -1);\n        queue<int> q;\n        q.push(start);\n        distance[start] = 0;\n        int farthestNode = start;\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            for (int neighbor : adjacency[node]) {\n                if (distance[neighbor] == -1) {\n                    distance[neighbor] = distance[node] + 1;\n                    q.push(neighbor);\n                    if (distance[neighbor] > distance[farthestNode]) {\n                        farthestNode = neighbor;\n                    }\n                }\n            }\n        }\n\n        return {farthestNode, distance[farthestNode]};\n    }\n};",
    "submit_ts": "1719719956",
    "subm_id": "1304455085"
}