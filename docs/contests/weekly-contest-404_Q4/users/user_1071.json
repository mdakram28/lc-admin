{
    "username": "anmol_iiita",
    "submission": "class Solution {\npublic:\n    int bfs(const vector<vector<int>>& adj, int a, int& b) {\n        int c = adj.size();\n        vector<int> d(c, -1);\n        queue<int> q;\n        \n        q.push(a);\n        d[a] = 0;\n        b = a;\n        \n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            for (auto it = adj[node].begin(); it != adj[node].end(); ++it) {\n                int neighbor = *it;\n                if (d[neighbor] == -1) {\n                    d[neighbor] = d[node] + 1;\n                    q.push(neighbor);\n                    if (d[neighbor] > d[b]) {\n                        b = neighbor;\n                    }\n                }\n            }\n        }\n        \n        return d[b];\n    }\n\n    int solve(const vector<vector<int>>& adj, int a, int& b) {\n        int c = adj.size();\n        vector<int> d(c, -1);\n\n        // Inner DFS function using while loop\n        function<void(int, int)> e = [&](int node, int f) {\n            stack<int> g;\n            d[node] = f;\n            if (f > d[b]) {\n                b = node;\n            }\n            g.push(node);\n            while (!g.empty()) {\n                int curr = g.top();\n                g.pop();\n                for (auto it = adj[curr].begin(); it != adj[curr].end(); ++it) {\n                    int neighbor = *it;\n                    if (d[neighbor] == -1) {\n                        d[neighbor] = d[curr] + 1;\n                        g.push(neighbor);\n                        if (d[neighbor] > d[b]) {\n                            b = neighbor;\n                        }\n                    }\n                }\n            }\n        };\n\n        b = a;\n        e(a, 0);\n\n        return d[b];\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int a = edges1.size() + 1;\n        int b = edges2.size() + 1;\n        \n        vector<vector<int>> c(a);\n        vector<vector<int>> d(b);\n        \n        for (const auto& e : edges1) {\n            int f = e[0];\n            int g = e[1];\n            c[f].push_back(g);\n            c[g].push_back(f);\n        }\n        for (const auto& e : edges2) {\n            int f = e[0];\n            int g = e[1];\n            d[f].push_back(g);\n            d[g].push_back(f);\n        }\n\n        auto h = [](const vector<vector<int>>& adj, int a, int& b) {\n            int c = adj.size();\n            vector<int> d(c, -1);\n            function<void(int, int)> e = [&](int node, int f) {\n                stack<int> g;\n                d[node] = f;\n                if (f > d[b]) {\n                    b = node;\n                }\n                g.push(node);\n                while (!g.empty()) {\n                    int curr = g.top();\n                    g.pop();\n                    for (auto it = adj[curr].begin(); it != adj[curr].end(); ++it) {\n                        int neighbor = *it;\n                        if (d[neighbor] == -1) {\n                            d[neighbor] = d[curr] + 1;\n                            g.push(neighbor);\n                            if (d[neighbor] > d[b]) {\n                                b = neighbor;\n                            }\n                        }\n                    }\n                }\n            };\n\n            b = a;\n            e(a, 0);\n            return d[b];\n        };\n\n        int a1 = 0;\n        solve(c, 0, a1);\n        int b1 = bfs(c, a1, a1);\n\n        int a2 = 0;\n        solve(d, 0, a2);\n        int b2 = bfs(d, a2, a2);\n        \n        int e = max(b1, b2);\n        int f = (b1 + 1) / 2;\n        int g = (b2 + 1) / 2;\n        int h1=e;\n        int h2=f+g+1;\n        if(h1>h2) return h1;\n        else return h2;\n        \n    }\n};\n",
    "submit_ts": 1719717475.0
}