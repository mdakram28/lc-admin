{
    "username": "danieljkeyes",
    "submission": "class Solution {\npublic:\n\n    int dfs(int cur, int parent, const vector<vector<int>>& adj_list, vector<int>& heights, vector<int>&max_diameter) {\n        int num_children = 0;\n        int child = -1;\n        for (int adj : adj_list[cur]) {\n            if (adj != parent) {\n                dfs(adj, cur, adj_list, heights, max_diameter);\n                ++num_children;\n                child = adj;\n            }\n        }\n        if (num_children == 0) {\n            // leaf\n            //cout << \"cur=\" << cur << \", leaf, height=0\" << endl;\n            return 0;\n        }\n        if (num_children == 1) {\n            heights[cur] = heights[child] + 1;\n            max_diameter[cur] = max(max_diameter[child], heights[cur]);\n            \n            //cout << \"cur=\" << cur << \", one child, height=\" << heights[cur] << \", maxd=\" << max_diameter[cur] << endl;\n            return max_diameter[cur];\n        }\n\n        int highest_child =-1;\n        int second_highest_child = -1;\n        for (int adj : adj_list[cur]) {\n            if (adj == parent) {\n                continue;\n            }\n            int h = heights[adj];\n            max_diameter[cur] = max(max_diameter[cur], max_diameter[adj]);\n            if (h >= highest_child) {\n                second_highest_child = highest_child;\n                highest_child = h;\n            } else if (h > second_highest_child) {\n                second_highest_child = h;\n            }\n        }\n        int d = highest_child + second_highest_child + 2;\n        max_diameter[cur] = max(max_diameter[cur], heights[cur]);\n        max_diameter[cur] = max(max_diameter[cur], d);\n        heights[cur] = highest_child + 1;\n        //cout << \"cur=\" << cur << \", \" << num_children << \" children, height=\" << heights[cur] << \", maxd=\" << max_diameter[cur] << endl;\n        return max_diameter[cur];\n    }\n    int solve(const vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        if (n == 1) {\n            return 0;\n        }\n\n        vector<vector<int>> adj_list(n);\n        for (const auto e : edges) {\n            adj_list[e[0]].emplace_back(e[1]);\n            adj_list[e[1]].emplace_back(e[0]);\n        }\n\n        vector<int> heights(n, 0);\n        vector<int> max_diameter(n, 0);\n\n        //cout << \"dfsing...\" << endl;\n        return dfs(0, -1, adj_list, heights, max_diameter);\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        if (edges1.size() == 0 && edges2.size() == 0) {\n            return 1;\n        }\n        if (edges1.size() + edges2.size() == 1) {\n            return 2;\n        }\n        int d1 = solve(edges1);\n        int half_d1 = (d1+1) / 2;\n        int short_half_d1 = d1 - half_d1;\n        int d2 = solve(edges2);\n        int half_d2 = (d2+1) / 2;\n        int short_half_d2 = d2 - half_d2;\n\n        //cout << \"d1=\" << d1 << endl;\n        //cout << \"d2=\" << d2 << endl;\n\n        int x = half_d1 + max(half_d2 + 1, short_half_d1);\n        int y = half_d2 + max(half_d1 + 1, short_half_d2);\n        return max(x, y);\n    }\n};",
    "submit_ts": 1719718885.0
}