{
    "username": "AdityaCoding_it",
    "submission": "#include <iostream>\nusing namespace std;\n#include <bits/stdc++.h>\n#include <immintrin.h>\n \n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cfenv>\n#include <cfloat>\n#include <chrono>\n#include <cinttypes>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <initializer_list>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <streambuf>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <typeinfo>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing ll=long long;\nusing ld=long double;\nconst ll ILL=2167167167167167167;\nconst int INF=2100000000;\nconst int mod=998244353;\n#define rep(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define all(p) p.begin(),p.end()\ntemplate<class T> using _pq = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> ll LB(vector<T> &v,T a){return lower_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> ll UB(vector<T> &v,T a){return upper_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> bool chmin(T &a,T b){if(a>b){a=b;return 1;}else return 0;}\ntemplate<class T> bool chmax(T &a,T b){if(a<b){a=b;return 1;}else return 0;}\ntemplate<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}\ntemplate<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}\nbool yneos(bool a,bool upp=0){if(a){cout<<(upp?\"YES\\n\":\"Yes\\n\");}else{cout<<(upp?\"NO\\n\":\"No\\n\");}return a;}\ntemplate<class T> void vec_out(vector<T> &p,int ty=0){\nif(ty==2){cout<<'{';for(int i=0;i<(int)p.size();i++){if(i){cout<<\",\";}cout<<'\"'<<p[i]<<'\"';}cout<<\"}\\n\";}\nelse{if(ty==1){cout<<p.size()<<\"\\n\";}for(int i=0;i<(int)(p.size());i++){if(i) cout<<\" \";cout<<p[i];}cout<<\"\\n\";}}\ntemplate<class T> T vec_min(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmin(ans,x);return ans;}\ntemplate<class T> T vec_max(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmax(ans,x);return ans;}\ntemplate<class T> T vec_sum(vector<T> &a){T ans=T(0);for(auto &x:a) ans+=x;return ans;}\nint pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}\ntemplate<class T> bool inside(T l,T x,T r){return l<=x&&x<r;}\n\nusing namespace std;\nclass DisjointSet {\n    vector<int> rank, parent, size;\npublic:\n    DisjointSet(int n) {\n        rank.resize(n + 1, 0);\n        parent.resize(n + 1);\n        size.resize(n + 1);\n        for (int i = 0; i <= n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    int findUPar(int node) {\n        if (node == parent[node])\n            return node;\n        return parent[node] = findUPar(parent[node]);\n    }\n\n    void unionByRank(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (rank[ulp_u] < rank[ulp_v]) {\n            parent[ulp_u] = ulp_v;\n        }\n        else if (rank[ulp_v] < rank[ulp_u]) {\n            parent[ulp_v] = ulp_u;\n        }\n        else {\n            parent[ulp_v] = ulp_u;\n            rank[ulp_u]++;\n        }\n    }\n\n    void unionBySize(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (size[ulp_u] < size[ulp_v]) {\n            parent[ulp_u] = ulp_v;\n            size[ulp_v] += size[ulp_u];\n        }\n        else {\n            parent[ulp_v] = ulp_u;\n            size[ulp_u] += size[ulp_v];\n        }\n    }\n};\n#define rd(x) \\\n    int x;    \\\n    cin >> x;\n#define rs(s) \\\n    string s; \\\n    cin >> s;\n#define INF 1e9 + 10;\n\n#define setbitsll(x) __builtin_popcountll(x)\n#define setbits(x) __builtin_popcount(x)\n#define rt return 0\n\nint lcm(int a, int b)\n{\n    return (a * b) / (__gcd(a, b));\n}\n\nint min(int a, int b)\n{\n    return (a < b) ? a : b;\n}\n\nint max(int a, int b)\n{\n    return (a > b) ? a : b;\n}\n\nint BinExpItr(int a, int b)\n{\n    int ans = 1;\n    while (b)\n    {\n        if (b & 1)\n        {\n            ans = (ans * 1ll * a) % mod;\n        }\n        a = (a * 1ll * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n// int dx[] = { -1 , 1 ,  0  , 0 , -1  , -1  ,  1  , 1  };\n// int dy[] = { 0  , 0 , -1  , 1 , -1  ,  1  , -1  , 1  };\n//            { U  , D ,  L  , R , UL  , UR  , DL  , DR }\n\nclass Solution {\npublic:\n    \n    \n    const int MODULO_VALUE_FOR_RESULT = 1e9 + 7;\n\nint RecursiveDepthFirstSearchFunction(\n    int currentIndex, \n    int previousValue, \n    const vector<int>& inputArray, \n    vector<vector<int>>& memoizationTable\n) {\n    if (currentIndex == inputArray.size()) {\n        return 1;\n    }\n\n    if (memoizationTable[currentIndex][previousValue] != -1) {\n        return memoizationTable[currentIndex][previousValue];\n    }\n\n    int numberOfValidPairs = 0;\n    for (int possibleValueForArr1 = previousValue; possibleValueForArr1 <= inputArray[currentIndex]; ++possibleValueForArr1) {\n        int correspondingValueForArr2 = inputArray[currentIndex] - possibleValueForArr1;\n        if (currentIndex == 0 || correspondingValueForArr2 <= inputArray[currentIndex - 1] - previousValue) {\n            numberOfValidPairs = (numberOfValidPairs + RecursiveDepthFirstSearchFunction(\n                currentIndex + 1, \n                possibleValueForArr1, \n                inputArray, \n                memoizationTable\n            )) % MODULO_VALUE_FOR_RESULT;\n        }\n    }\n\n    memoizationTable[currentIndex][previousValue] = numberOfValidPairs;\n    return numberOfValidPairs;\n}\n\n    int countOfPairs(vector<int>& inputArray) {\n         int sizeOfArray = inputArray.size();\n    vector<vector<int>> memoizationTable(sizeOfArray, vector<int>(51, -1));\n    return RecursiveDepthFirstSearchFunction(0, 0, inputArray, memoizationTable);\n        \n    }\n};",
    "submit_ts": "1723345075",
    "subm_id": "1351548085"
}