{
    "username": "raararaara",
    "submission": "using lint = long long;\nusing ii = pair<int, int>;\nusing il = pair<int, lint>;\nusing li = pair<lint, int>;\nusing ll = pair<lint, lint>;\n\nconst int mxn = 1000100, mxp = 1000001;\nconst int MOD = 998244353, inf = -1e9 - 7, INF = 1e9 + 1;\nconst lint lnf = -4e18, LNF = 5e18;\nconst double eps = 1e-10;\nconst int sqrtN = 200;\n\n#define all(x) (x).begin(),(x).end()\n#define compress(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())\n#define lb(x, v) (lower_bound(all(x), v) - (x).begin())\n#define ub(x, v) (upper_bound(all(x), v) - (x).begin())\n#define eb emplace_back\n#define pb push_back\n#define getName(var)  #var\nvector<lint> xl, yl;\n\n#define Yes \"Yes\\n\"\n#define No \"No\\n\"\n\nconst int dr[] = {-1, 0, 1, 0};\nconst int dc[] = {0, -1, 0, 1};\n\ninline int inRange(int r, int c, int R, int C) {\n    return 0 <= r && r < R && 0 <= c && c < C;\n}\n\nint N, M, Q, R, C, H, K, T;\n\nvoid init() {\n\n}\n// 1 x: x\ub9c9\uae30\n// 2 x sz: \ud06c\uae30\uac00 sz\uc778 \ube14\ub85d\uc744 [0,x] \uc5b4\ub514\ub4e0 \ub193\uc744 \uc218 \uc788\ub294\uac00\n// v[i] := i\ub85c \uc2dc\uc791\ud558\ub294 \uac00\uc7a5 \ud070 \uac12\n\n\nstruct P {\n    lint v, sz;\n    P() { v = sz = 0; }\n    P(lint v, lint sz): v(v), sz(sz) {}\n    P operator + (const P&rhs) const {\n        P ret;\n        ret.v += v + rhs.v;\n        ret.sz += sz + rhs.sz;\n\n        return ret;\n    }\n    bool operator == (const P&rhs) const {\n        return v == rhs.v && sz == rhs.sz;\n    }\n};\n\nP max(P a, P b) {\n    return P(max(a.v, b.v), 0);\n}\n\ntemplate<typename T_Node,\n        typename T_Lazy,\n        typename F_Merge,\n        typename F_Update,\n        typename F_Prop>\nstruct LazySegTree {\n    int N{}, base{};\n    vector<T_Node> tree;\n    vector<T_Lazy> lz;\n\n    const F_Merge m;\n    const F_Update u;\n    const F_Prop p;\n    const T_Node I;\n    const T_Lazy lzI;\n\n    LazySegTree() = default;\n\n    LazySegTree(int n,\n                F_Merge _m, F_Update _u, F_Prop _p,\n                const T_Node &I, const T_Lazy &lzI)\n            : N(n), m(_m), u(_u), p(_p), I(I), lzI(lzI) {\n        for (base = 1; base < N; base <<= 1);\n        tree.resize(base * 2 + 1, I);\n        lz.resize(base * 2 + 1, lzI);\n    }\n\n    void lazy(int n) {\n        if(lz[n] == lzI) return;\n        tree[n] = u(tree[n], lz[n]);\n        if (n < base) {\n            lz[n<<1] = p(lz[n<<1], lz[n]);\n            lz[n<<1|1] = p(lz[n<<1|1], lz[n]);\n        }\n        lz[n] = lzI;\n    }\n\n    void build() {\n        for (int i = base - 1; i; i--) {\n            tree[i] = m(tree[i << 1], tree[i << 1 | 1]);\n        }\n    }\n\n    T_Node get(int i) { return tree[i + base]; }\n\n    void set(int i, T_Node v) { tree[i + base] = v; }\n\n    void upd(int l, int r, T_Lazy v) {\n        upd(l, r, 1, 0, base - 1, v);\n    }\n    void upd(int l, int r, int n, int nl, int nr, T_Lazy v) {\n        lazy(n);\n        if (r < nl || nr < l) return;\n        if (l <= nl && nr <= r) {\n            lz[n] = p(lz[n], v);\n            lazy(n);\n            return;\n        }\n        int mid = (nl + nr) >> 1;\n        upd(l, r, n<<1, nl, mid, v);\n        upd(l, r, n<<1|1, mid+1, nr, v);\n\n        tree[n] = m(tree[n<<1], tree[n<<1|1]);\n    }\n\n    T_Node qry(int l, int r) {\n        return qry(l, r, 1, 0, base - 1);\n    }\n    T_Node qry(int l, int r, int n, int nl, int nr) {\n        lazy(n);\n        if (r < nl || nr < l) return I;\n        if (l <= nl && nr <= r) return tree[n];\n        int mid = (nl + nr) >> 1;\n        return m(qry(l, r, n<<1, nl, mid), qry(l, r, n<<1|1, mid+1, nr));\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        N = -1;\n        for(auto &q: queries) {\n            N = max(N, q[1]);\n        }\n        auto m = [](P a, P b) { return max(a, b); };\n        auto u = [](P a, P b) { return P(a.v + b.v, a.sz); };\n        auto p = [](P a, P b) { return a + b; };\n        const P I(inf,0), lzI(0,0);\n        LazySegTree<P, P, decltype(m), decltype(u), decltype(p)> seg(N+1, m, u, p, I, lzI);\n        for(int i = 0; i <= N; i++) {\n            seg.set(i, P(N-i, 1));\n        }\n        seg.build();\n        set<int> st;\n        st.emplace(0);\n        st.emplace(N+1);\n        vector<bool> ret;\n        for(auto &q: queries) {\n            if(q[0] == 1) {\n                int x = q[1];\n                auto r = st.lower_bound(x);\n                auto sub = seg.qry(x,x).v;\n                r--;\n                seg.upd(*r, x-1, P(-sub, 0));\n                st.emplace(x);\n            } else {\n                int x = q[1], t = q[2];\n                auto r = st.lower_bound(x);\n                if(x != *r) r--;\n                auto v = seg.qry(0, *r-1).v;\n                auto rest = seg.qry(*r, x).v - seg.qry(x,x).v;\n                v = max(v, rest);\n                if(v >= t) {\n                    ret.eb(true);\n                } else ret.eb(false);\n            }\n        }\n        return ret;\n    }\n\n};",
    "submit_ts": 1716650922.0
}