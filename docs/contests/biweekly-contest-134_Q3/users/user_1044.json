{
    "username": "daksh_4103",
    "submission": "class Solution {\npublic:\n    int numberOfAlternatingGroups(vector<int>& colors, int threshold) {\n        bool hasSameColor = false;\n        vector<int> groupSizes;\n        int prevColor = colors[0];\n        int currGroupSize = 1;\n\n        for (int i = 1; i < colors.size(); ++i) {\n            if (colors[i] == prevColor) {\n                groupSizes.push_back(currGroupSize);\n                currGroupSize = 1;\n                hasSameColor = true;\n            } else {\n                ++currGroupSize;\n            }\n            prevColor = colors[i];\n        }\n        groupSizes.push_back(currGroupSize);\n\n        if (checkSingleGroup(colors, groupSizes, hasSameColor)) {\n            return colors.size();\n        } else {\n            adjustGroups(colors, groupSizes);\n        }\n\n        long long totalGroups = 0;\n        for (int group : groupSizes) {\n            totalGroups += max(0, group - (threshold - 1));\n        }\n\n        return static_cast<int>(totalGroups);\n    }\n\nprivate:\n    bool checkSingleGroup(const vector<int>& colors, const vector<int>& groupSizes, bool hasSameColor) {\n        return (groupSizes.size() == 1 && groupSizes.front() == colors.size() && colors[0] != colors.back() && !hasSameColor);\n    }\n\n    void adjustGroups(const vector<int>& colors, vector<int>& groupSizes) {\n        if (colors[0] != colors.back() && groupSizes.size() > 1) {\n            int lastGroup = groupSizes.back();\n            groupSizes.pop_back();\n            groupSizes.front() += lastGroup;\n        }\n    }\n};\n",
    "submit_ts": "1720280305",
    "subm_id": "1311784410"
}