{
    "username": "A107",
    "submission": "#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nconst int MODULO = 1000000007;\n\nclass Solution {\npublic:\n    int numberOfPermutations(int n, vector<vector<int>>& requirements) {\n        int maxInversions = n * (n - 1) / 2;\n\n        vector<int> currentDP(maxInversions + 1, 0), previousDP(maxInversions + 1, 0);\n        previousDP[0] = 1;\n\n        for (int length = 1; length <= n; ++length) {\n            fill(currentDP.begin(), currentDP.end(), 0);\n\n            vector<int> cumulativeSum(maxInversions + 1, 0);\n            cumulativeSum[0] = previousDP[0];\n            for (int inv = 1; inv <= maxInversions; ++inv) {\n                cumulativeSum[inv] = (cumulativeSum[inv - 1] + previousDP[inv]) % MODULO;\n            }\n\n            for (int inv = 0; inv <= maxInversions; ++inv) {\n                if (inv >= length) {\n                    currentDP[inv] = (cumulativeSum[inv] - cumulativeSum[inv - length] + MODULO) % MODULO;\n                } else {\n                    currentDP[inv] = cumulativeSum[inv];\n                }\n            }\n\n            swap(currentDP, previousDP);\n        }\n\n        vector<int> inversionCount(n + 1, -1);\n        for (const auto& requirement : requirements) {\n            int endIndex = requirement[0];\n            int requiredInversions = requirement[1];\n            inversionCount[endIndex + 1] = requiredInversions;\n        }\n\n        fill(currentDP.begin(), currentDP.end(), 0);\n        previousDP[0] = 1;\n        for (int i = 1; i <= maxInversions; ++i) {\n            previousDP[i] = 0;\n        }\n\n        for (int length = 1; length <= n; ++length) {\n            fill(currentDP.begin(), currentDP.end(), 0);\n\n            vector<int> cumulativeSum(maxInversions + 1, 0);\n            cumulativeSum[0] = previousDP[0];\n            for (int inv = 1; inv <= maxInversions; ++inv) {\n                cumulativeSum[inv] = (cumulativeSum[inv - 1] + previousDP[inv]) % MODULO;\n            }\n\n            for (int inv = 0; inv <= maxInversions; ++inv) {\n                if (inv >= length) {\n                    currentDP[inv] = (cumulativeSum[inv] - cumulativeSum[inv - length] + MODULO) % MODULO;\n                } else {\n                    currentDP[inv] = cumulativeSum[inv];\n                }\n            }\n\n            swap(currentDP, previousDP);\n\n            if (inversionCount[length] != -1) {\n                for (int inv = 0; inv <= maxInversions; ++inv) {\n                    if (inv != inversionCount[length]) {\n                        previousDP[inv] = 0;\n                    }\n                }\n            }\n        }\n\n        int totalPermutations = 0;\n        for (int inv = 0; inv <= maxInversions; ++inv) {\n            totalPermutations = (totalPermutations + previousDP[inv]) % MODULO;\n        }\n\n        return totalPermutations;\n    }\n};\n",
    "submit_ts": 1719069099.0
}