{
    "username": "ayushkumar135",
    "submission": "class PeakSegTree {\npublic:\n    int len;\n    vector<int> t; // Segment tree array\n\n    PeakSegTree() {}\n    PeakSegTree(int l) {\n        len = l;\n        t.resize(4 * len);\n    }\n\n    // Function to determine if an element is a peak\n    bool isPeak(vector<int>& a, int index) {\n        if (index == 0) return false; // First element\n        if (index == len - 1) return false; // Last element\n        return a[index] > a[index - 1] && a[index] > a[index + 1];\n    }\n\n    // Build the segment tree\n    void build(vector<int>& a, int v, int tl, int tr) {\n        if (tl == tr) {\n            t[v] = isPeak(a, tl) ? 1 : 0;\n            return;\n        }\n        int tm = (tl + tr) / 2;\n        build(a, 2 * v, tl, tm);\n        build(a, 2 * v + 1, tm + 1, tr);\n        t[v] = t[2 * v] + t[2 * v + 1];\n    }\n\n    // Query the segment tree for the number of peaks up to index r\n    int query(int v, int tl, int tr, int l, int r) {\n        if (l > r) return 0;\n        if (l == tl && r == tr) return t[v];\n        int tm = (tl + tr) / 2;\n        return query(2 * v, tl, tm, l, min(r, tm))\n             + query(2 * v + 1, tm + 1, tr, max(l, tm + 1), r);\n    }\n\n    // Update the segment tree when a value at index id changes\n    void update(vector<int>& a, int v, int tl, int tr, int id) {\n        if (tl == tr) {\n            t[v] = isPeak(a, tl) ? 1 : 0;\n            return;\n        }\n        int tm = (tl + tr) / 2;\n        if (id <= tm) {\n            update(a, 2 * v, tl, tm, id);\n        } else {\n            update(a, 2 * v + 1, tm + 1, tr, id);\n        }\n        t[v] = t[2 * v] + t[2 * v + 1];\n    }\n\n    // Overridden functions\n    void build(vector<int>& a) {\n        build(a, 1, 0, len - 1);\n    }\n\n    int query(int l,int r) {\n        return query(1, 0, len - 1, l, r);\n    }\n\n    void update(vector<int>& a, int id,int val) {\n        a[id]=val;\n        update(a, 1, 0, len - 1, id);\n        if (id >= 0) update(a, 1, 0, len - 1, id - 1); // Check the previous element\n        if (id <= len - 1) update(a, 1, 0, len - 1, id + 1); // Check the next element\n    }\n};\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> a = nums;\n        PeakSegTree segTree(n);\n        segTree.build(a);\n        vector<int> ans;\n        for(int i=0;i<queries.size();i++){\n            int type=queries[i][0];\n            if(type==1){\n                int l=queries[i][1];\n                int r=queries[i][2];\n                int sum = segTree.query(l+1, r-1);\n                ans.push_back(sum);\n            }\n            else{\n                int idx=queries[i][1];\n                int val=queries[i][2];\n                segTree.update(a,idx,val); \n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718508292.0
}