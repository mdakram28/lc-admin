{
    "username": "non_deterministic",
    "submission": "#define lld long long\n#define rep(i,a,n) for(lld i = (a); i <= (n); ++i)\n#define repI(i,a,n) for(int i = (a); i <= (n); ++i)\n#define repD(i,a,n) for(lld i = (a); i >= (n); --i)\n#define repDI(i,a,n) for(int i = (a); i >= (n); --i)\n#define all(c) (c).begin(), (c).end()\n#define sz(a) ((int)a.size())\n\n#define Error(x...) { cout << \"(\" << #x << \")\" << \" = ( \"; printIt(x); }\ntemplate <typename T1> void printIt(T1 t1) { cout << t1 << \" )\" << endl; }\ntemplate <typename T1, typename... T2>\nvoid printIt(T1 t1, T2... t2) { cout << t1 << \" , \"; printIt(t2...); }\n#define errorpair(a) cout<<#a<<\" = ( \"<<((a).first)<<\" , \"<<((a).second)<<\" )\\n\";\n\nusing ll = long long;\nusing ull = unsigned long long;\ntypedef unsigned int uint;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n    return (ull)rng() % B;\n}\n\nconst uint MOD = 1000000007;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n    uint x;\n \n    mint() : x(0) {}\n    mint(ll _x) {\n        _x %= mod;\n        if (_x < 0) _x += mod;\n        x = _x;\n    }\n \n    mint& operator += (const mint &a) {\n        x += a.x;\n        if (x >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator -= (const mint &a) {\n        x += mod - a.x;\n        if (x >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator *= (const mint &a) {\n        x = (ull)x * a.x % mod;\n        return *this;\n    }\n    mint pow(ll pw) const {\n        mint res = 1;\n        mint cur = *this;\n        while(pw) {\n            if (pw & 1) res *= cur;\n            cur *= cur;\n            pw >>= 1;\n        }\n        return res;\n    }\n    mint inv() const {\n        assert(x != 0);\n        uint t = x;\n        uint res = 1;\n        while(t != 1) {\n            uint z = mod / t;\n            res = (ull)res * (mod - z) % mod;\n            t = mod - t * z;\n        }\n        return res;\n    }\n    mint& operator /= (const mint &a) {\n        return *this *= a.inv();\n    }\n    mint operator + (const mint &a) const {\n        return mint(*this) += a;\n    }\n    mint operator - (const mint &a) const {\n        return mint(*this) -= a;\n    }\n    mint operator * (const mint &a) const {\n        return mint(*this) *= a;\n    }\n    mint operator / (const mint &a) const {\n        return mint(*this) /= a;\n    }\n \n    bool sqrt(mint &res) const {\n        if (mod == 2 || x == 0) {\n            res = *this;\n            return true;\n        }\n        if (pow((mod - 1) / 2) != 1) return false;\n        if (mod % 4 == 3) {\n            res = pow((mod + 1) / 4);\n            return true;\n        }\n        int pw = (mod - 1) / 2;\n        int K = 30;\n        while((1 << K) > pw) K--;\n        while(true) {\n            mint t = myRand(mod);\n            mint a = 0, b = 0, c = 1;\n            for (int k = K; k >= 0; k--) {\n                a = b * b;\n                b = b * c * 2;\n                c = c * c + a * *this;\n                if (((pw >> k) & 1) == 0) continue;\n                a = b;\n                b = b * t + c;\n                c = c * t + a * *this;\n            }\n            if (b == 0) continue;\n            c -= 1;\n            c *= mint() - b.inv();\n            if (c * c == *this) {\n                res = c;\n                return true;\n            }\n        }\n        assert(false);\n    }\n \n    bool operator == (const mint &a) const {\n        return x == a.x;\n    }\n    bool operator != (const mint &a) const {\n        return x != a.x;\n    }\n    bool operator < (const mint &a) const {\n        return x < a.x;\n    }\n};\nusing Mint = mint<>;\n\nMint dp[2003][53];\n\nclass Solution {\npublic:\n    int countOfPairs(vector<int>& nums) {\n        int n = nums.size();\n        int m = 50;\n        repI(i, 0, n) repI(j, 0, m) dp[i][j] = 0;\n        repI(j, 0, nums[0]) dp[1][j] = 1;\n        repI(i, 2, n) {\n            repI(j, 0, nums[i - 1]) {\n                int other = nums[i - 1] - j;\n                dp[i][j] = 0;\n                int limit = min(j, nums[i - 2]);\n                repI(k, 0, limit) {\n                    int otherPrev = nums[i - 2] - k;\n                    if (otherPrev >= other) {\n                        dp[i][j] += dp[i - 1][k];\n                    }\n                }\n            }\n        }\n        Mint res = 0;\n        repI(j, 0, m) res += dp[n][j];\n        return res.x;\n    }\n};",
    "submit_ts": "1723344335",
    "subm_id": "1351532081"
}