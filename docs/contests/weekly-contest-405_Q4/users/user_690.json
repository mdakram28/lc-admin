{
    "username": "saurav0_0",
    "submission": "class Solution {\nprivate:\n    struct Node {\n        unordered_map<char, Node*> next;\n        vector<int> wordPos;\n    };\n    \n    Node* origin;\n    vector<long long> cache;\n    \n    void constructTree(const vector<string>& dict) {\n        origin = new Node();\n        for (int i = 0; i < dict.size(); i++) {\n            Node* current = origin;\n            for (char letter : dict[i]) {\n                if (!current->next.count(letter)) {\n                    current->next[letter] = new Node();\n                }\n                current = current->next[letter];\n            }\n            current->wordPos.push_back(i);\n        }\n    }\n    \n    long long findMinCost(const string& goal, int start, const vector<int>& prices) {\n        if (start == goal.length()) return 0;\n        if (cache[start] != -1) return cache[start];\n        \n        Node* current = origin;\n        long long minExpense = LLONG_MAX;\n        \n        for (int i = start; i < goal.length(); i++) {\n            if (!current->next.count(goal[i])) break;\n            current = current->next[goal[i]];\n            \n            for (int wordIdx : current->wordPos) {\n                long long subCost = findMinCost(goal, i + 1, prices);\n                if (subCost != LLONG_MAX) {\n                    minExpense = min(minExpense, subCost + prices[wordIdx]);\n                }\n            }\n        }\n        \n        return cache[start] = minExpense;\n    }\n    \npublic:\n    int minimumCost(string goal, vector<string>& dict, vector<int>& prices) {\n        constructTree(dict);\n        cache.assign(goal.length(), -1);\n        \n        long long totalCost = findMinCost(goal, 0, prices);\n        return totalCost == LLONG_MAX ? -1 : static_cast<int>(totalCost);\n    }\n};",
    "submit_ts": "1720322689",
    "subm_id": "1312356521"
}