{
    "username": "little-rookie-at-ujs",
    "submission": " \n\nclass Solution {\n\npublic:\n    // \u61d2\u6807\u8bb0\u7ebf\u6bb5\u6811\n    // \u533a\u95f4\u65390\uff0c\u533a\u95f4\u6c42\u548c\n    class STG {\n    public:\n        struct node {\n            int l, r;\n            int sum;\n            int lazy;\n        };\n        vector<node> stg;\n\n        void pushup(int q) {\n            stg[q].sum = stg[q << 1].sum + stg[q << 1 | 1].sum;\n        }\n\n        void modify(int q) {\n            stg[q].sum = 0;\n            stg[q].lazy = 1;\n        }\n\n        void pushdown(int q) {\n            if (stg[q].lazy) {\n                modify(q << 1);\n                modify(q << 1 | 1);\n                stg[q].lazy = 0;\n            }\n        }\n\n        void update(int q, int l, int r, int L, int R) {\n            if (l > r) return;\n            if (L <= l && r <= R) {\n                modify(q);\n                return;\n            }\n            pushdown(q);\n            int mid = (l + r) / 2;\n            if (L <= mid) update(q << 1, l, mid, L, R);\n            if (R > mid) update(q << 1 | 1, mid + 1, r, L, R);\n            pushup(q);\n//            cerr << l << \" \" << r << \" \" << stg[q].sum << endl;\n        }\n\n        int query(int q, int l, int r, int L, int R) {\n            if (L <= l && r <= R) {\n                return stg[q].sum;\n            }\n            pushdown(q);\n            int mid = (l + r) / 2;\n            int ans = 0;\n            if (L <= mid) ans += query(q << 1, l, mid, L, R);\n            if (R > mid) ans += query(q << 1 | 1, mid + 1, r, L, R);\n            return ans;\n        }\n\n        void build(int q, int l, int r) {\n            stg[q].l = l;\n            stg[q].r = r;\n            stg[q].lazy = 0;\n            if (l == r) {\n                stg[q].sum = 1;\n                return;\n            }\n            int mid = (l + r) / 2;\n            build(q << 1, l, mid);\n            build(q << 1 | 1, mid + 1, r);\n\n            pushup(q);\n//            cerr << l << \" \" << r << \" \" << stg[q].sum << endl;\n        }\n\n        STG(int n) {\n            stg.resize(n * 4);\n            build(1, 1, n);\n        }\n    };\n\n\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>> &queries) {\n        vector<int> ans;\n        n--;\n        STG stg(n  );\n//        cerr << n << endl;\n//        cerr << stg.query(1, 1, n, 1, n) << endl;\n        for (auto &i: queries) {\n            int x = i[0];\n            int y = i[1];\n//            cerr << x << \" \" << y << endl;\n            stg.update(1, 1, n, x + 1, y - 1);\n            int sum = stg.query(1, 1, n, 1, n  );\n            ans.emplace_back(sum);\n        }\n        return ans;\n    }\n};\n\n/**\n * Your neighborSum object will be instantiated and called as such:\n * neighborSum* obj = new neighborSum(grid);\n * int param_1 = obj->adjacentSum(value);\n * int param_2 = obj->diagonalSum(value);\n */\n \n ",
    "submit_ts": "1722740302",
    "subm_id": "552330577"
}