{
    "username": "MichaelWheeler202",
    "submission": "from operator import itemgetter\nfrom typing import List\nimport bisect\n\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n\n        distanceToEnd = n-1\n        ans = []\n\n        removedBounds = []\n\n        for q in queries:\n            if q[1] == q[0] + 1:\n                continue\n\n            removedArea = (q[1] - q[0]) - 1\n            engulfed = False\n            b = max(0, bisect.bisect_left(removedBounds, q[0], key=itemgetter(0)) - 1)\n            if b >= len(removedBounds) and len(removedBounds) != 0:\n                if q[1] <= removedBounds[-1][1]:\n                    engulfed = True\n                    removedArea = 0\n            while b < len(removedBounds):\n\n                if removedBounds[b][0] > q[1]:\n                    break\n                elif removedBounds[b][0] <= q[0] and removedBounds[b][1] >= q[1]:\n                    engulfed = True\n                    removedArea = 0\n                    break\n                elif removedBounds[b][0] >= q[0] and removedBounds[b][1] <= q[1]:\n                    removedArea -= (removedBounds[b][1] - removedBounds[b][0]) - 1\n                    del removedBounds[b]\n                    b -= 1\n                else:\n                    pass\n\n                b += 1\n\n            if not engulfed:\n                bisect.insort(removedBounds, q)\n\n            distanceToEnd -= removedArea\n            ans.append(distanceToEnd)\n\n        return ans\n\n",
    "submit_ts": "1722743360",
    "subm_id": "1343790203"
}