{
    "username": "OkamiWang",
    "submission": "constexpr long long mod = 1000000000 + 7;\n\n#define LEFT_CHILD (o << 1)\n#define RIGHT_CHILD (o << 1 | 1)\n\nstruct SegmentTree {\n  struct Node {\n    long long sumWithL = 0, sumWithR = 0, sumWithLR = 0, sumWithoutLR = 0;\n  };\n\n  std::vector<Node> nodes;\n  int n;\n\n  Node pushUp(Node l, Node r){\n    Node ret;\n    ret.sumWithL = max({\n      l.sumWithL + r.sumWithL,\n      l.sumWithLR + r.sumWithoutLR,\n      l.sumWithoutLR + r.sumWithL,\n      l.sumWithoutLR + r.sumWithoutLR\n    });\n    ret.sumWithR = max({\n      l.sumWithR + r.sumWithR,\n      l.sumWithoutLR + r.sumWithLR,\n      l.sumWithR + r.sumWithoutLR,\n      l.sumWithoutLR + r.sumWithoutLR\n    });\n    ret.sumWithLR = max({\n      ret.sumWithL,\n      ret.sumWithR,\n      l.sumWithL + r.sumWithR,\n      l.sumWithLR + r.sumWithR,\n      l.sumWithL + r.sumWithLR,\n    });\n    ret.sumWithoutLR = max({\n      l.sumWithoutLR + r.sumWithL,\n      l.sumWithR + r.sumWithoutLR,\n      l.sumWithoutLR + r.sumWithoutLR\n    });\n    return ret;\n  }\n\n  void pushUp(int o) {\n    nodes[o] = pushUp(nodes[LEFT_CHILD], nodes[RIGHT_CHILD]);\n  }\n\n  void build(int o, int l, int r) {\n    if (l == r) {\n      nodes[o].sumWithL\n        = nodes[o].sumWithR\n        = nodes[o].sumWithLR\n        = nodes[o].sumWithoutLR\n        = 0;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    build(LEFT_CHILD, l, mid);\n    build(RIGHT_CHILD, mid + 1, r);\n    pushUp(o);\n  }\n\n  void update(int o, int l, int r, int L, int R, int d) {\n    if (r < L || l > R) return;\n    if (L <= l && r <= R) {\n      nodes[o].sumWithL\n        = nodes[o].sumWithR\n        = nodes[o].sumWithoutLR\n        = 0;\n      nodes[o].sumWithLR = max(d, 0);\n      return;\n    }\n    int mid = (l + r) >> 1;\n    update(LEFT_CHILD, l, mid, L, R, d);\n    update(RIGHT_CHILD, mid + 1, r, L, R, d);\n    pushUp(o);\n  }\n\n  void update(int L, int R, int d) {\n    update(1, 1, n, L, R, d);\n  }\n\n  Node query(int o, int l, int r, int L, int R) {\n    Node ret;\n    if (r < L || l > R) return ret;\n    if (L <= l && r <= R) return nodes[o];\n    int mid = (l + r) >> 1;\n    Node leftResult = query(LEFT_CHILD, l, mid, L, R);\n    Node rightResult = query(RIGHT_CHILD, mid + 1, r, L, R);\n    ret = pushUp(leftResult, rightResult);\n    return ret;\n  }\n\n  long long query(int L, int R) {\n    Node result = query(1, 1, n, L, R);\n    return max({\n      result.sumWithL,\n      result.sumWithR,\n      result.sumWithLR,\n      result.sumWithoutLR\n    });\n  }\n\n  SegmentTree(int n) {\n    this->n = n;\n    nodes.resize(n << 2);\n    build(1, 1, n);\n  }\n};\n\nclass Solution {\n  public:\n  int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n    SegmentTree st(nums.size());\n    for (int i = 0; i < nums.size(); i++) {\n      st.update(i + 1, i + 1, nums[i]);\n    }\n    long long ans = 0;\n    for (auto query : queries){\n      st.update(query[0] + 1, query[0] + 1, query[1]);\n      ans = (ans + st.query(1, nums.size())) % mod;\n    }\n    return ans;\n  }\n};\n",
    "submit_ts": "1716693157",
    "subm_id": "1268077230"
}