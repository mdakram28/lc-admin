{
    "username": "ow3nL",
    "submission": "\nclass DisjointSetUnion:\n    \n    # Maintains disjoint sets of integers 1 to n (technically 0 to n)\n    def __init__(self, circles):\n        n = len(circles)\n        self.n = n\n        self.link = [i for i in range(self.n+1)]\n        self.size = [1 for _ in range(self.n+1)]\n        self.min_x = [c[0] - c[2] for c in circles]\n        self.min_y = [c[1] - c[2] for c in circles]\n        self.max_x = [c[0] + c[2] for c in circles]\n        self.max_y = [c[1] + c[2] for c in circles]\n\n    \n    # Find the representative of the set containing [elem]\n    def find(self, elem):\n        \"\"\"Returns the top node in the tree containing elem\"\"\"\n        if self.link[elem] == elem:\n            return elem\n        self.link[elem] = self.find(self.link[elem])\n        return self.link[elem]\n\n    # Check if [a] and [b] belong to the same set\n    def same(self, a, b):\n        \"\"\"Check if [a] and [b] belong to the same tree\"\"\"\n        return self.find(a) == self.find(b)\n\n    # Join the sets containing [a] and [b]\n    def unite(self, a, b):\n        \"\"\"Join the smaller tree to the larger tree\"\"\"\n        a = self.find(a)\n        b = self.find(b)\n        if a != b:\n            if self.size[a] < self.size[b]:\n                a, b = b, a\n            self.size[a] += self.size[b]\n            self.min_x[a] = min(self.min_x[a], self.min_x[b])\n            self.min_y[a] = min(self.min_y[a], self.min_y[b])\n            self.max_x[a] = max(self.max_x[a], self.max_x[b])\n            self.max_y[a] = max(self.max_y[a], self.max_y[b])\n            self.link[b] = a\n\n\ndef touch(c1, c2):\n    dist = (c1[0] - c2[0]) ** 2 + (c1[1] - c2[1]) ** 2\n    return (c1[2] + c2[2]) ** 2 >= dist\n\n\nclass Solution(object):\n    def canReachCorner(self, X, Y, circles):\n        \"\"\"\n        :type X: int\n        :type Y: int\n        :type circles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        D = DisjointSetUnion(circles)\n        for i in range(len(circles)-1):\n            for j in range(i+1, len(circles)):\n                if touch(circles[i], circles[j]):\n                    D.unite(i, j)\n        \n        for i in range(len(circles)):\n            if D.link[i] == i:\n                a, b, c, d = D.min_x[i] <= 0, D.max_x[i] >= X, \\\n                    D.min_y[i] <= 0, D.max_y[i] >= Y\n                if (a and b) or (c and d) or (a and c) or (b and d):\n                    return False\n        \n        return True\n\n        ",
    "submit_ts": "1722137368",
    "subm_id": "1335761762"
}