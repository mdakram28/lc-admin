{
    "username": "Hardik_Aswal1303",
    "submission": "/*This is a boiler plate template created by Hardik Aswal*/\n\n/* Including all the libraries*/\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<unordered_map>\n#include<set>\n#include<cmath>\n#include<algorithm>\n#include<climits>\n#include<deque>\n#include<unordered_set>\n#include<map>\n\n\n/*<----------------------------------end of libraries-------------------------------------->*/\n\nusing namespace std;\n/*Defining helper items*/\n\n#define pb push_back\n#define ll long long\n#define mod 1000000007\n//#define mod2 998244353\n#define vi vector<int>\n#define mii map<int, int> \n#define mci map<char, int>\n#define pii pair<int, int>\n#define f(i,s,e)   for(int i=s;i<e;i++)\n\n#define rf(i,s,e)     for(int i=s;i>=e;i--)\n#define desc(vec) sort(vec.begin(), vec.end(), greater<int>());  \n#define asc(vec)  sort(vec.begin(),vec.end());\n#define maxo(x) *max_element((x).begin(), (x).end())\n#define mino(x) *min_element((x).begin(), (x).end())\n#define maxheap(type) priority_queue<type>\n#define minheap(type) priority_queue<type, vector<type>, greater<type>>\n\n#define sz(x) (int)(x.size())\n#define all(x) x.begin(),x.end()\n#define print(x) {for(auto v: x) {cout << v<< ' ';} cout << endl;}\n#define printmap(x) {for(auto v: x) {cout << v.first << ':' << v.second << ' ';} cout << endl;}\n#define printv(x) { for (auto v: x){ print(v) }}\n#define print2d(vec,n,m) for(int i=0;i<=n;i++){for(int j=0;j<=m;j++)cout<<vec[i][j]<<\" \";cout<<\"\\n\";}\n\n\n\n\n\n\n\n\n\n// /*<---------------------------end of helper items-------------------------------------->*/\n// /*Defining Helper Functions*/\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\nint lcm(int a, int b) {\n    return (a / gcd(a, b)) * b;\n}\nint power(int a, int b) {\n    int result = 1;\n    while (b > 0) {\n        \n        if (b % 2 == 1) {\n            result *= a;\n        }\n        a *= a;\n        b /= 2;\n    }\n    return result;\n}\n\n\n\nclass DSU {\nprivate:\n    vector<int> parent, rank, shortestPath;\n    \npublic:\n    DSU(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        shortestPath.resize(n);\n        iota(parent.begin(), parent.end(), 0);\n        for (int i = 0; i < n; ++i) {\n            shortestPath[i] = i; \n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSets(int u, int v) {\n        int pu = find(u);\n        int pv = find(v);\n        \n        if (pu != pv) {\n            if (rank[pu] > rank[pv]) {\n                parent[pv] = pu;\n                \n                shortestPath[pu] = min(shortestPath[pu], shortestPath[pv]);\n            } else if (rank[pu] < rank[pv]) {\n                parent[pu] = pv;\n                shortestPath[pv] = min(shortestPath[pu], shortestPath[pv]);\n            } else {\n                parent[pv] = pu;\n                rank[pu]++;\n                shortestPath[pu] = min(shortestPath[pu], shortestPath[pv]);\n            }\n        }\n    }\n\n    int getShortestPath(int x) {\n        return shortestPath[find(x)];\n    }\n};\n\nclass ST {\nprivate:\n    struct Node {\n        int lazy;\n        int sum;\n        Node() : lazy(-1), sum(0) {}\n    };\n\n    vector<Node> tree;\n    int n;\n\n    void build(const vector<int>& arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node].sum = arr[start];\n            return;\n        }\n        int mid = (start + end) / 2;\n        build(arr, node * 2, start, mid);\n        build(arr, node * 2 + 1, mid + 1, end);\n        tree[node] = merge(tree[node * 2], tree[node * 2 + 1]);\n    }\n\n    Node merge(const Node& left, const Node& right) {\n        Node result;\n        result.sum = left.sum + right.sum;\n        return result;\n    }\n\n    void applyLazy(int node, int start, int end) {\n        if (tree[node].lazy != -1) {\n            tree[node].sum = (end - start + 1) * tree[node].lazy;\n            if (start != end) { \n                tree[node * 2].lazy = tree[node].lazy;\n                tree[node * 2 + 1].lazy = tree[node].lazy;\n            }\n            tree[node].lazy = -1;\n        }\n    }\n\n    void updateRange(int node, int start, int end, int l, int r, int value) {\n        applyLazy(node, start, end);\n        if (r < start || l > end)\n            return;\n        if (l <= start && end <= r) {\n            tree[node].lazy = value;\n            applyLazy(node, start, end);\n            return;\n        }\n        int mid = (start + end) / 2;\n        updateRange(node * 2, start, mid, l, r, value);\n        updateRange(node * 2 + 1, mid + 1, end, l, r, value);\n        tree[node] = merge(tree[node * 2], tree[node * 2 + 1]);\n    }\n\n    int queryRange(int node, int start, int end, int l, int r) {\n        applyLazy(node, start, end);\n        if (r < start || l > end)\n            return 0;\n        if (l <= start && end <= r)\n            return tree[node].sum;\n        int mid = (start + end) / 2;\n        int leftSum = queryRange(node * 2, start, mid, l, r);\n        int rightSum = queryRange(node * 2 + 1, mid + 1, end, l, r);\n        return leftSum + rightSum;\n    }\n\npublic:\n    ST(const vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        build(arr, 1, 0, n - 1);\n    }\n\n    void update(int l, int r, int value) {\n        updateRange(1, 0, n - 1, l, r, value);\n    }\n\n    int query(int l, int r) {\n        return queryRange(1, 0, n - 1, l, r);\n    }\n};\n\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int> result;\n        vector<int> ans;\n    DSU dsu(n);\n\n    for (const auto& query : queries) {\n        int u = query[0];\n        int v = query[1];\n        dsu.unionSets(u, v);\n\n        if (dsu.find(0) == dsu.find(n - 1)) {\n            result.push_back(dsu.getShortestPath(n - 1));\n        } else {\n            result.push_back(-1); \n        }\n    }\n\n//     return result;\n\n        vector<int> path(n - 1, 1); \n        ST kam(path);\n\n        \n        for (const auto& it : queries) {\n            int har = it[0];\n            int bhu = it[1];\n            \n            if (har + 1 <= bhu - 1) {\n                kam.update(har + 1, bhu - 1, 0);  \n            }\n\n            int d = kam.query(0, n - 2);\n            ans.push_back(d);  \n        }\n\n        return ans;\n       \n        \n    }\n};",
    "submit_ts": "1722742775",
    "subm_id": "1343776874"
}