{
    "username": "PrasHanT766",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst ll N = 1e5 + 7;\nconst ll M = 1e7 + 7;\nll mod = 1e9 + 7;\nll fact[1000004];\nll modinv[1000004];\nll arr[N];\nll P[M];\n#define PI 3.141592653589793238462\n#define set_bits(x) __builtin_popcountll(x)\n#define all(v) sort(v.begin(),v.end())\n#define rall(v) sort(v.rbegin(),v.rend())\n#define ar(a) a.begin(),a.end()\n#define bs binary_search\n#define lb lower_bound\n#define ub upper_bound\n#define rev(a) reverse(a.begin(),a.end())\n#define f0(i,a,n) for(ll i=a;i<n;i++)\n#define f1(i,b,a) for(ll i=b;i>=a;i--)\n#define bbl(a) __builtin_popcountll(a)\n#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define aaja(v)         \\\n    for (auto &x : v) \\\n        cin >> x;\n#define cout1(v)             \\\n    for (auto &x : v)      \\\n    {                      \\\n        cout << x << endl; \\\n    }                      \\\n    nxt;\n#define zout1(v)                                     \\\n    for (auto &x : v)                               \\\n    {                                               \\\n        cout << x.first << \" \" << x.second << endl; \\\n    }      \n\n\nbool sorting(const pair<ll, ll> &a, const pair<ll, ll> &b){if (a.first>b.first){return (a.second <= b.second);}return 0;}\nbool isprime(ll n){ if(n==1) return false;if(n==2) return true;\nfor(ll i=2;i*i<=n;i++){if(n%i==0) return false;}return true;}\nvoid xorprop(ll n){if (n % 4 == 1){cout<<1<<endl;}else if (n % 4 == 2){ cout<<n+1<<endl;}if (n % 4 == 3){cout<<0<<endl;}if (n % 4 == 0){cout<<n<<endl;}}\n//ll kthNonDivisible(ll N, ll K){   ll L = 1;ll H = LLONG_MAX;ll ans = 0;while (L <= H){ll mid = (L + H) / 2;ll sol = mid - mid / N;if (sol > K){H = mid - 1;}else if (sol < K){ L = mid + 1;}else{ans = mid;H = mid - 1;}}return ans;}\nvoid printbinary(ll n){for (ll i = 10; i >=0; i--){cout<<((n>>i)&1)<<\" \";}cout<<endl;}\nbool isSubstring(string s1, string s2){if (s2.find(s1) != string::npos) return true;return false;}\nll digitsum(ll n){ll sum = 0;while (n != 0) { sum = sum + n % 10;n = n / 10;}return sum;}\nll mmi(ll a, ll b, ll m){ll ans=1; while (b>0){if (b&1){ans = (ans*a)%m;}a*=a; a%=m;b/=2;}return ans;   }\nll multiply(ll a, ll b, ll m){ll ans = 0;while (b>0){if (b&1){ ans = (ans+a)%m;}a = (a+a)%m; b/=2;}return ans;}\n//vector<ll>primefactorsof(ll n)\nll mminvprime(ll a, ll b) {return mmi(a, b - 2, b);}\nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\nll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m\nvoid khatam(auto n){cout<<n<<endl;}\nll power(ll base, ll x){if(x < 0){ return 0;} ll ans = 1;while(x){if(x % 2 == 0){base = (base * base) % mod;x = x / 2;}else{ans = (ans * base) % mod;x--; } }return ans;}\nvoid precomp(){modinv[0] = 1;fact[0] = 1;for(ll i = 1; i <= 1000000; i++){fact[i] = (fact[i-1]*i)%mod;modinv[i] = power(fact[i], mod-2); }}\nll ncr(ll n, ll r){if(n < 0 || r < 0 || r > n){    return 0;}return (((fact[n] * modinv[r])%mod)*modinv[n-r]) % mod;}\nvoid khatamsab(vector<ll>v){f0(i, 0, v.size()){cout<<v[i]<<\" \";}cout<<endl;}\nvector<ll> identifier(vector<ll>v){all(v);ll m=0;v.resize(m = unique(v.begin(), v.end()) - v.begin());return v;}\nll phin(ll n) {ll number = n; if (n % 2 == 0) {number /= 2; while (n % 2 == 0) n /= 2;} for (ll i = 3; i <= sqrt(n); i += 2) {if (n % i == 0) {while (n % i == 0)n /= i; number = (number / i * (i - 1));}} if (n > 1)number = (number / n * (n - 1)) ; return number;} //O(sqrt(N))\nll xmodn(string str, ll n) {ll len = str.length();ll num, rem = 0;f0(i, 0, len) { num = rem * 10 + (str[i] - '0');rem = num % n;}return rem;   }\n\n#define INF INT32_MAX\n\nclass SegmentTree {\npublic:\n    vector<int> ct1;\n    int ct2;\n\n    SegmentTree(vector<int>& ct3) {\n        ct2 = ct3.size();\n        ct1.resize(4 * ct2);\n        build(ct3, 0, 0, ct2 - 1);\n    }\n\n    void build(vector<int>& ct3, int node, int st, int end) {\n        if (st == end) {\n            ct1[node] = ct3[st];\n        } else {\n            int ct7 = (st + end) / 2;\n            build(ct3, 2 * node + 1, st, ct7);\n            build(ct3, 2 * node + 2, ct7 + 1, end);\n            ct1[node] = ct1[2 * node + 1] & ct1[2 * node + 2];\n        }\n    }\n\n    int query(int ct8, int ct9) {\n        return query(0, 0, ct2 - 1, ct8, ct9);\n    }\n\n    int query(int node, int st, int end, int ct8, int ct9) {\n        if (ct9 < st || end < ct8) {\n            return INF;\n        }\n        if (ct8 <= st && end <= ct9) {\n            return ct1[node];\n        }\n        int ct7 = (st + end) / 2;\n        int ct10 = query(2 * node + 1, st, ct7, ct8, ct9);\n        int ct11 = query(2 * node + 2, ct7 + 1, end, ct8, ct9);\n        return ct10 & ct11;\n    }\n};\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& v, int k) {\n        int tx = v.size();\n        SegmentTree ttxtr(v);\n        int rtyz = INF;\n        set<int>qq;\n        for(auto it:v){\n            qq.insert(it);\n        }\n        for (int i = 0; i < tx; ++i) {\n            int zt = i - 1, yt = tx - 1, ct20;\n\n            while (yt - zt > 1) {\n                ct20 = (zt + yt) / 2;\n                if (ttxtr.query(i, ct20) >= k)\n                    zt = ct20;\n                else\n                    yt = ct20;\n            }\n\n            if (zt != i - 1)\n                rtyz = min(rtyz, abs(ttxtr.query(i, zt) - k));\n            rtyz = min(rtyz, abs(k - ttxtr.query(i, yt)));\n        }\n        \n\n        return rtyz;\n    }\n};\n\n",
    "submit_ts": 1717300118.0
}