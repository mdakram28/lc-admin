{
    "username": "dadas08",
    "submission": "#include <bits/stdc++.h>\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing vi = std::vector<int>;\nusing vvi = std::vector<vi>;\nusing vl = std::vector<ll>;\nusing vii = std::vector<pair<int, int> >;\nusing vvl = std::vector<vl>;\nusing vll = std::vector<pair<ll , ll> >;\nusing vd = std::vector<double>;\nusing vvd = std::vector<vd>;\nusing vs = std::vector<std::string>;\nusing vvs = std::vector<vs>;\nusing vb = std::vector<bool>;\nusing vvb = std::vector<vb>;\nusing vc = std::vector<char>;\nusing vvc = std::vector<vc>;\nusing pii = std::pair<int, int>;\nusing pll = std::pair<ll, ll>;\nusing piil = std::pair<pair<int, int>, ll>;\nusing mii = std::map<int, int>;\nusing mll = std::map<ll, ll>;\nusing pql = std::priority_queue<ll>;\nusing pqi = std::priority_queue<int>;\nusing pqiil = std::priority_queue<pair<pair<int, int>, ll> >;\nusing pqii = std::priority_queue<pair<int, int> >;\n\n#define pb push_back\n#define ps push\n#define eb emplace_back\n#define is insert\n#define er erase\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define sf(i) sizeof(i)\n#define endl \"\\n\"\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\n#define rep(i, L, R) for(ll i = L;i<=R;i++)\n#define pcis precision\n\nclass Solution {\npublic:\nll tree[100001 * 4];\nll lazy[100001 * 4];\n\nll init(ll A[], int node, int start, int end) {\n\tif(start == end) return tree[node] = A[start];\n\tint mid = (start + end) / 2;\n\treturn tree[node] = init(A, node*2, start, mid) + init(A, node*2+1, mid+1, end);\n}\n\nvoid update_lazy(int node, int start, int end) {\n\tif(lazy[node]) {\n\t\ttree[node] = (lazy[node] * (end - start +1));\n\t\tif(start != end) {\n\t\t\tlazy[node*2] = lazy[node];\n\t\t\tlazy[node*2+1] = lazy[node];\n\t\t}\n\t\tlazy[node] = 0;\n\t}\n}\n\nll get(int node, int start, int end, int left, int right) {\n\tupdate_lazy(node, start, end);\n\tif(right < start || left > end) return 0;\n\tif(left <= start && end <= right) return tree[node];\n\tint mid = (start + end) / 2;\n\treturn get(node*2, start, mid, left, right) + get(node*2+1, mid+1, end, left, right);\n}\n\nvoid update(int node, int start, int end, int left, int right, ll diff) {\n\tupdate_lazy(node, start, end);\n\tif(right < start || left > end) return;\n\tif(left <= start && end <= right) {\n\t\ttree[node] = (diff * (end - start + 1));\n\t\tif(start != end) {\n\t\t\tlazy[node*2] = diff;\n\t\t\tlazy[node*2+1] = diff;\n\t\t}\n\t\treturn;\n\t}\n\n\tint mid = (start + end) / 2;\n\tupdate(node*2, start, mid, left, right, diff);\n\tupdate(node*2+1, mid+1, end, left, right, diff);\n\ttree[node] = tree[node*2] + tree[node*2+1];\n}\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        ll N = n;\n        ll dist = N-1;\n        // i+1\ubd80\ud130 i\uae4c\uc9c0 \ucc44\uc6b0\ub294\uac78\ub85c \ud558\uc790\n        vi lst;\n        for (auto ii : queries) {\n            ll a = ii[0];\n            ll b=ii[1];\n            if (b-a >= 2) {\n                dist += get(1, 1, N, a+1, b-1);\n            update(1, 1, N, a+1, b-1, 1);\n            dist -= get(1, 1, N, a+1, b-1);\n            }\n            lst.pb(dist);\n        }\n        return lst;\n    }\n};",
    "submit_ts": "1722739713",
    "subm_id": "1343701324"
}