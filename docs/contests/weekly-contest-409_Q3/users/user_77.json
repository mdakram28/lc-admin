{
    "username": "Lilbud_314",
    "submission": "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define sz(x) (int)x.size()\n#define pb(...) push_back(__VA_ARGS__)\n#define mp(x, y) make_pair(x, y)\n#define all(x) (x).begin(), (x).end()\n#define sort(x) sort(all(x))\n#define reverse(x) reverse(all(x))\n#define MIN(x) *min_element(all(x))\n#define MAX(x) *max_element(all(x))\n#define SUM(x) accumulate(all(x), 0)\n#define FOR(i, a, b, c) for(int i = a; i < b; i+=c)\n#define I(x) for(auto&i:x)cin>>i\n#define umap unordered_map\n#define uset unordered_set\n#define F first\n#define S second\n#define vll vector<ll>\n#define vvll vector<vector<ll>>\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define lb(x) lower_bound(x) // First element NOT LESS than val\n#define ub(x) upper_bound(x) // First element GREATER than val\n#define PI 3.1415926535897932384626433832795\n#define MOD 1000000007\n#define mod 998244353\n\ntemplate<typename T> using ordered_set=tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\n// s.order_of_key(val) : Number of elements strictly smaller than X\n// *s.find_by_order(idx) : iterator pointing to the kth element (0 order)\ntemplate<class T> void pv(vector<T> &v){cout<<'{';for(auto&x:v)cout<<x<<',';cout<<\"\\b}\"<<endl;}\ntemplate<class T> void pvv(vector<vector<T>> &v){cout << \"---\\n\";for(auto&x:v){pv(x);}cout << \"---\"<<endl;}\ntemplate<class T> void pvp(vector<T> &v){cout<<'{';for(auto&x:v)cout<<'('<<x.F<<','<<x.S<<')';cout<<\"}\"<<endl;}\ntemplate<class T> T gcd(vector<T> &v){T ans = 0;for(auto&i:v)ans = gcd(i, ans);return ans;}\ntemplate<class T> void pset(set<T> &s){cout<<'{';for(auto&x:s)cout<<x<<',';cout<<\"\\b}\"<<endl;}\ntemplate<class T> void pmset(multiset<T> &m){cout<<'{';for(auto&x:m)cout<<x<<',';cout<<\"\\b}\"<<endl;}\ntemplate<class T> void pmap(map<T, T> &m){cout<<'{';for(auto&x:m)pvp(x);cout<<\"}\"<<endl;}\n\n/* Matrix Class, default MOD */\ntemplate<class T> struct matrix{\n    vector<vector<T>> a;\n    int n;\n    matrix(int n): n(n){ a.resize(n, vector<T>(n, 0)); }\n    matrix operator*(const matrix &b){ matrix c(n); for(int i=0; i<n; i++) for(int j=0; j<n; j++) for(int k=0; k<n; k++) c.a[i][j] = (c.a[i][j] + a[i][k]*b.a[k][j])%MOD; return c; }\n    matrix operator^(T p){ matrix c(n); for(int i=0; i<n; i++) c.a[i][i] = 1; matrix b = *this; while(p){ if(p&1) c = c*b; b = b*b; p >>= 1; } return c; }\n};\n\n/* Point Update Range Query */\ntemplate<class T> struct SegTree{\n    int n; vector<T> tree, v;\n    SegTree(int n) : n(n), tree(4*n){ v.resize(n);}\n    SegTree(vector<T> &v) : v(v), n(sz(v)), tree(4*n){build(1, 0, n-1);}\n    T combine(T a, T b){return a+b;}\n    void build(int node, int l, int r){\n        if(l==r){tree[node] = v[l]; return;} \n        int m = (l+r)/2;\n        build(2*node, l, m); build(2*node+1, m+1, r);\n        tree[node] = combine(tree[2*node], tree[2*node+1]);\n    }\n    void update(int node, int l, int r, int idx, T val){\n        if(l==r){tree[node] = val; return;}\n        int m = (l+r)/2;\n        if(idx<=m) update(2*node, l, m, idx, val);\n        else update(2*node+1, m+1, r, idx, val);\n        tree[node] = combine(tree[2*node], tree[2*node+1]);\n    }\n    void update(int idx, T val){update(1, 0, n-1, idx, val);}\n    T query(int node, int l, int r, int ql, int qr){\n        if(ql>r || qr<l) return 0;\n        if(ql<=l && qr>=r) return tree[node];\n        int m = (l+r)/2;\n        return combine(query(2*node, l, m, ql, qr), query(2*node+1, m+1, r, ql, qr));\n    }\n    T query(int l, int r){return query(1, 0, n-1, l, r);}\n};\n\n/* Range Update Point Query */\ntemplate<class T> struct LazySegTree{\n    int n; vector<T> tree, lazy;\n    LazySegTree(vector<T> &v) : n(sz(v)), tree(4*n), lazy(4*n){build(1, 0, n-1, v);}\n    T combine(T a, T b){return a+b;}\n    void build(int node, int l, int r, vector<T> &v){\n        if(l==r){tree[node] = v[l]; return;}\n        int m = (l+r)/2;\n        build(2*node, l, m, v); build(2*node+1, m+1, r, v);\n        tree[node] = combine(tree[2*node], tree[2*node+1]);\n    }\n    void push(int node, int l, int r){\n        tree[node] += (r-l+1)*lazy[node];\n        if(l!=r) lazy[2*node] += lazy[node], lazy[2*node+1] += lazy[node];\n        lazy[node] = 0;\n    }\n    void update(int node, int l, int r, int ql, int qr, T val){\n        push(node, l, r);\n        if(ql>r || qr<l) return;\n        if(ql<=l && qr>=r){ lazy[node] += val; push(node, l, r); return; }\n        int m = (l+r)/2;\n        update(2*node, l, m, ql, qr, val); update(2*node+1, m+1, r, ql, qr, val);\n        tree[node] = combine(tree[2*node], tree[2*node+1]);\n    }\n    void update(int l, int r, T val){ update(1, 0, n-1, l, r, val); }\n    T query(int node, int l, int r, int ql, int qr){\n        push(node, l, r);\n        if(ql>r || qr<l) return 0;\n        if(ql<=l && qr>=r) return tree[node];\n        int m = (l+r)/2;\n        return combine(query(2*node, l, m, ql, qr), query(2*node+1, m+1, r, ql, qr));\n    }\n    T query(int l, int r){ return query(1, 0, n-1, l, r); }\n};\n\n/* Range Update Range Query, 1-idx */\ntemplate<class T> struct BIT{\n    T n; vector<T> bit1, bit2;\n    BIT(T n):n(n), bit1(n+1), bit2(n+1){}\n    void update(vector<T> &bit, T i, T x){ for(; i <= n; i += i & -i) bit[i] += x; }\n    void update(T l, T r, T x){ if(l > r) return; update(bit1, l, x); update(bit1, r+1, -x); update(bit2, l, x*(l-1)); update(bit2, r+1, -x*r); }\n    T query(vector<T> &bit, T i){ T sum = 0; for(; i; i -= i & -i) sum += bit[i]; return sum; }\n    T query(T i){ return query(bit1, i)*i - query(bit2, i); }\n    T query(T l, T r){ return query(r) - query(l-1); }\n    T value(T i){ return query(i, i); }\n};\n\n/* RURS, Set & Sum, 0->upd 1->set */\ntemplate<class T> struct Lazy_RURS{\n    int n; vector<T> tree, lazy_sum, lazy_set;\n    Lazy_RURS(vector<T> &v) : n(sz(v)), tree(4*n), lazy_sum(4*n), lazy_set(4*n){build(1, 0, n-1, v);}\n    T combine(T a, T b){return a+b;}\n    void build(int node, int l, int r, vector<T> &v){\n        if(l==r){ tree[node] = v[l]; return; }\n        int m = (l+r)/2;\n        build(2*node, l, m, v); build(2*node+1, m+1, r, v);\n        tree[node] = combine(tree[2*node], tree[2*node+1]);\n    }\n    void push(int node, int l, int r){\n        if(lazy_set[node]){\n            tree[node] = lazy_set[node] * (r-l+1);\n            if(l!=r){\n                lazy_set[2*node] = lazy_set[node], lazy_set[2*node+1] = lazy_set[node];\n                lazy_sum[2*node] = 0, lazy_sum[2*node+1] = 0;\n            } lazy_set[node] = 0;\n        }\n        if(lazy_sum[node]){\n            tree[node] += lazy_sum[node] * (r-l+1);\n            if(l!=r) lazy_sum[2*node] += lazy_sum[node], lazy_sum[2*node+1] += lazy_sum[node];\n            lazy_sum[node] = 0;\n        }\n    }\n    void update(int node, int l, int r, int ql, int qr, T val, bool type){\n        push(node, l, r);\n        if(ql>r || qr<l) return;\n        if(ql<=l && qr>=r){\n            if(type) lazy_set[node] = val, lazy_sum[node] = 0;\n            else lazy_sum[node] += val;\n            push(node, l, r); return;\n        }\n        int m = (l+r)/2;\n        update(2*node, l, m, ql, qr, val, type); update(2*node+1, m+1, r, ql, qr, val, type);\n        tree[node] = combine(tree[2*node], tree[2*node+1]);\n    }\n    void update(int l, int r, T val, bool type){ update(1, 0, n-1, l, r, val, type); }\n    T query(int node, int l, int r, int ql, int qr){\n        push(node, l, r);\n        if(ql<=l && qr>=r) return tree[node];\n        if(ql>r || qr<l) return 0;\n        int m = (l+r)/2;\n        return combine(query(2*node, l, m, ql, qr), query(2*node+1, m+1, r, ql, qr));\n    }\n    T query(int l, int r){ return query(1, 0, n-1, l, r); }\n};\n\n/* 2D BIT, 1-idx*/\ntemplate<class T> struct BIT_2D{\n    T n, m; vector<vector<T>> bit;\n    BIT_2D(T n, T m):n(n), m(m), bit(n+1, vector<T>(m+1)){}\n    void update(T x, T y, T val){ for(T i = x; i <= n; i += i & -i) for(T j = y; j <= m; j += j & -j) bit[i][j] += val; }\n    T query(T x, T y){ T sum = 0; for(T i = x; i; i -= i & -i) for(T j = y; j; j -= j & -j) sum += bit[i][j]; return sum; }\n    T query(T x1, T y1, T x2, T y2){ return query(x2, y2) - query(x1-1, y2) - query(x2, y1-1) + query(x1-1, y1-1); }\n};\n\n/* Disjoin Set Union */\ntemplate<class T> struct DSU{\n    vector<T> p, s;\n    DSU(T n) : p(n), s(n, 1){ iota(all(p), 0); }\n    T find(T x){ return (x==p[x]) ? x : (p[x] = find(p[x])); }\n    void unite(T x, T y){ x = find(x); y = find(y); if(x!=y){ if(s[x] < s[y]) swap(x, y); p[y] = x; s[x] += s[y]; } }\n    bool con(T x, T y){ return find(x) == find(y); }\n};\n\n/* Sparse Table */\ntemplate<class T> struct SparseTable{\n    int n; vector<vector<T>> st;\n    SparseTable(vector<T> &v) : n(sz(v)), st(25, vector<T>(n)){\n        for(int i = 0; i < n; i++) st[0][i] = v[i];\n        for(int j = 1; j < 25; j++) for(int i = 0; i+(1<<j) <= n; i++) st[j][i] = min(st[j-1][i], st[j-1][i+(1<<(j-1))]);\n    }\n    T query(int l, int r){\n        int j = 31-__builtin_clz(r-l+1);\n        return min(st[j][l], st[j][r-(1<<j)+1]);\n    }\n};\n\n/* LCA */\ntemplate<class T> struct LCA{\n    int n, l; vector<vector<T>> adj, up; vector<int> tin, tout;\n    LCA(vector<vector<T>> &adj, int root = 0) : adj(adj), n(sz(adj)), l(31-__builtin_clz(n)), up(l, vector<T>(n)), tin(n), tout(n){ dfs(root); }\n    void dfs(int v, int p = 0){\n        static int t = 0; tin[v] = t++; up[0][v] = p;\n        for(int i = 1; i < l; i++) up[i][v] = up[i-1][up[i-1][v]];\n        for(auto& u : adj[v]) if(u != p) dfs(u, v);\n        tout[v] = t++;\n    }\n    bool is_ancestor(int u, int v){ return tin[u] <= tin[v] && tout[u] >= tout[v]; }\n    int lca(int u, int v){ \n        if(is_ancestor(u, v)) return u;\n        if(is_ancestor(v, u)) return v;\n        for(int i = l-1; i >= 0; i--) if(!is_ancestor(up[i][u], v)) u = up[i][u];\n        return up[0][u];\n    }\n    int dist(int u, int v){ return tin[u] + tout[u] - 2*tin[lca(u, v)]; }\n    int U(int u, int d){\n        for(int i = l-1; i >= 0; i--) if(d & (1<<i)) u = up[i][u];\n        return u;\n    }\n};\n\n/* Euler Tour */\ntemplate<class T> struct EulerTour{\n    int n, l; vector<vector<T>> adj; vector<int> tin, tout, tour;\n    EulerTour(vector<vector<T>> &adj, int root = 0) : adj(adj), n(sz(adj)), l(31-__builtin_clz(n)), tin(n), tout(n){ dfs(root); }\n    void dfs(int v, int p = -1){ static int t = 0; tin[v] = t++; for(int i = 1; i < l; i++) if(adj[v][i] != -1) dfs(adj[v][i], v); tout[v] = t++; }\n    bool is_ancestor(int u, int v){ return tin[u] <= tin[v] && tout[u] >= tout[v]; }\n    void tour_dfs(int v, int p = -1){ tour.push_back(v); for(int i = 1; i < l; i++) if(adj[v][i] != -1) tour_dfs(adj[v][i], v); }\n};\n\n/* Centroid Decomposition */\ntemplate<class t> struct centroid_decomoposition{\n    int n;\n    vector<vector<int>> e;\n    vector<int> SZ, par, vis;\n    centroid_decomoposition(int n, vector<vector<int>> &e) : n(n), e(e), SZ(n), par(n), vis(n){}\n    int dfs(int u, int p){\n        SZ[u] = 1;\n        for(auto i : e[u]) if(i != p && !vis[i]) SZ[u] += dfs(i, u);\n        return SZ[u];\n    }\n    int centroid(int u, int p, int S){\n        for(auto i : e[u]) if(i != p && !vis[i] && SZ[i] > S/2) return centroid(i, u, S);\n        return u;\n    }\n    void decompose(int u, int p){\n        int S = dfs(u, p);\n        int C = centroid(u, p, S);\n        vis[C] = 1; par[C] = p;\n        for(auto i : e[C]) if(!vis[i]) decompose(i, C);\n    }\n    vector<int> get_centroids(){\n        decompose(0, -1);\n        return par;\n    }\n};\n\n/* Mo's Algorithm */\n\n/* Dijkstra */\n\n/* Floyd Warshall */\n\n/* Kruskal */\n\n/* Prim */\n\n/* Bellman Ford */\n\n/* Topological Sort */\n\n/* Prime Sieve */\ntemplate<class T> struct PrimeSieve{\n    vector<int> primes;\n    PrimeSieve(int n){\n        vector<bool> is_prime(n+1, 1);\n        for(int i = 2; i*i <= n; i++) if(is_prime[i]) for(int j = i*i; j <= n; j += i) is_prime[j] = 0;\n        for(int i = 2; i <= n; i++) if(is_prime[i]) primes.push_back(i);\n    \n    }\n};\n\nll gcd(ll a, ll b){if(b==0)return a; return gcd(b, a%b);}\nll lcm(ll a, ll b){return a/gcd(a,b)*b;}\nll pow(ll a, ll b, ll m){if(b==0){return 1LL;}else if(b==1){return a%m;}else{ll x=pow(a,b/2,m);x=(x*x)%m;if(b%2)x=(x*a)%m;return x;}}\nll inv(ll a, ll m){return pow(a, m-2, m);}\nll factorial(ll a, ll m){if(a==0)return 1;return (a*factorial(a-1, m))%m;}\nll choose(ll n, ll r, ll m){return (factorial(n, m) * ((inv(factorial(r, m), m) * inv(factorial(n-r, m), m))%m))%m;}\nstring to_upper(string a){for (int i=0;i<(int)a.size();++i) if (a[i]>='a' && a[i]<='z') a[i]-='a'-'A'; return a;}\nstring to_lower(string a){for (int i=0;i<(int)a.size();++i) if (a[i]>='A' && a[i]<='Z') a[i]+='a'-'A'; return a;}\nbool prime(ll a) { if (a==1) return 0; for (int i=2;i<=round(sqrt(a));++i) if (a%i==0) return 0; return 1; }\nvoid test(int i = -1e9) { cout<<\"TEST\"<<((i==-1e9) ? (\"\") : (\" \"+to_string(i)))<<endl; }\nvoid yes() { cout<<\"YES\"<<endl; }\nvoid no() { cout<<\"NO\"<<endl; }\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        set<int> s; s.insert(1e9);\n        for(int i = 0; i < n; ++i) s.insert(i);\n        vi ans;\n        for(auto&q:queries){\n            int idx = q[0];\n            while(*s.upper_bound(idx) < q[1]){\n                idx = *s.upper_bound(idx);\n                s.erase(idx);\n            }\n            ans.pb(sz(s)-2);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722739646",
    "subm_id": "1343699629"
}