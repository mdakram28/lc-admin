{
    "username": "Govind_Singh_2003",
    "submission": "class Solution {\npublic:\n    pair<int, int> bfs(int s, vector<vector<int>>& edges)\n    {\n        int n = edges.size() + 1;\n        vector<int> adj[n];\n        for(auto e : edges)\n        {\n            adj[e[0]].push_back(e[1]);\n            adj[e[1]].push_back(e[0]);\n        }\n        queue<int> q;\n        vector<bool> used(n);\n        vector<int> d(n), p(n);\n        int mx = 0, res = 0;\n        q.push(s);\n        used[s] = true;\n        p[s] = -1;\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int u : adj[v]) {\n                if (!used[u]) {\n                    used[u] = true;\n                    q.push(u);\n                    d[u] = d[v] + 1;\n                    if(d[u] > mx)\n                    {\n                        mx = d[u];\n                        res = u;\n                    }\n                    p[u] = v;\n                }\n            }\n        }\n        return {res, mx};\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        auto [x, _] = bfs(0, edges2);\n        auto [s, d1] = bfs(x, edges2);\n        auto [y, p] = bfs(0, edges1);\n        auto [t, d2] = bfs(y, edges1);\n        return max({d1, d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1});\n    }\n};",
    "submit_ts": 1719718149.0
}