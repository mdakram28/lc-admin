{
    "username": "Skywarrior2000",
    "submission": "\ntemplate<typename T>\nclass segTree {\nprivate:\n    int n;\n    vector<T> t;\n    T zero;\npublic:\n    segTree() : n(0) {}\n    segTree(int n, T zero) : n(n), zero(zero), t(2 * n - 1, zero) {}\n\n    T merge(T x, T y) {\n        return x+y;\n    }\n\nprivate:\n    void merge(int me, int lc, int rc) {\n        t[me] = merge(t[lc], t[rc]);\n    }\n    void point_update(int idx, int l, int r, int i, T v) {\n        if (l == r) {\n            t[idx] = v;\n        } else {\n            int mid = l + (r - l) / 2;\n            int left_size = (mid - l + 1) * 2 - 1;\n            int left = idx + 1, right = idx + 1 + left_size;\n            if (i <= mid) point_update(left, l, mid, i, v);\n            else point_update(right, mid + 1, r, i, v);\n            merge(idx, left, right);\n        }\n    }\n    T range_query(int idx, int l, int r, int ql, int qr, T out_of_bound) {\n        if (l > r || ql > qr || l > qr || ql > r) return out_of_bound;\n        if (ql <= l && r <= qr) return t[idx];\n        int mid = l + (r - l) / 2;\n        int left_size = (mid - l + 1) * 2 - 1;\n        int left = idx + 1, right = idx + 1 + left_size;\n        auto x = range_query(left, l, mid, ql, qr, out_of_bound);\n        auto y = range_query(right, mid + 1, r, ql, qr, out_of_bound);\n        return merge(x, y);\n    }\npublic:\n    void point_update(int i, T v) {\n        point_update(0, 0, n - 1, i, v);\n    }\n    T range_query(int l, int r, T out_of_bound) {\n        return range_query(0, 0, n - 1, l, r, out_of_bound);\n    }\n};\n\n\nclass Solution {\npublic:\n    bool is_peak(vector<int> &a, int i){\n        if(i<=0 || i>=a.size()-1)return false;\n        return a[i] > a[i-1] && a[i] > a[i+1];\n    }\n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& Q) {\n        int n = a.size();\n        segTree<int> t(n, 0);\n        for(int i = 0; i < n; i++){\n            t.point_update(i, (is_peak(a, i) ? 1 : 0));\n        }\n        vector<int> ans;\n        for(int i = 0; i < Q.size(); i++){\n            auto q = Q[i];\n            if(q[0]==1){\n                int l = q[1], r = q[2];\n                int res = t.range_query(l+1, r-1, (int)0);\n                ans.push_back(res);\n            }else{\n                int idx = q[1], val = q[2];\n                a[idx] = val;\n                for(int j = - 1; j <= 1; j++)\n                    if(idx+j>=0 && idx+j<n)t.point_update(idx+j, (is_peak(a, idx+j) ? 1 : 0));\n            }\n            \n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718506937.0
}