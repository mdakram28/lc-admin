{
    "username": "ataturhan",
    "submission": "class Solution:\n    def waysToReachStair(self, k: int) -> int:\n        # Special case for k = 0\n        if k == 0:\n            return 2\n\n        @functools.lru_cache(None)\n        def dp(stair, jump, prev_down):\n                        # If we go below 0 or beyond k + some reasonable upper limit, return 0 ways\n            if stair < 0 or stair > k + 1:\n                return 0\n            # If we reach the k-th stair, return 1 way\n            ways = 0\n\n            if stair == k:\n                ways = 1\n\n            \n            # Option 1: Go down to stair - 1 (if not on stair 1)\n            if stair >= 1 and not prev_down:\n                ways += dp(stair - 1, jump, True)\n            \n            # Option 2: Go up to stair + 2^jump\n            ways += dp(stair + (1 << jump), jump + 1, False)\n            \n            return ways\n\n        # Start from stair 1 with initial jump value of 0\n        result = dp(1, 0, False)\n        \n        return result\n\n\n\n\n        @cache\n        def dp(i, k, down_used, jump):\n            if i > k + 1:\n                return 0\n            if i == k + 1:\n                return 1 - bool(down_used)\n            if i == k:\n                return 1\n            if down_used or i == 0:\n                return dp(i+2**jump, k, False, jump+1)\n            res1 = dp(i-1, k, True, jump)\n            res2 = dp(i+2**jump, k, False, jump+1)\n            return res1 + res2\n        return dp(1, k, False, 0)\n",
    "submit_ts": 1716089564.0
}