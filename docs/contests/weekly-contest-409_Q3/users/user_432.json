{
    "username": "st019",
    "submission": "class LazySegmentTree {\nprivate:\n    std::vector<int> tree;\n    std::vector<int> lazy;\n    int n;\n\n    void build(int node, int start, int end) {\n        if (start == end - 1) {\n            tree[node] = 1;\n        } else {\n            int mid = (start + end) / 2;\n            build(2 * node + 1, start, mid);\n            build(2 * node + 2, mid, end);\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n        }\n    }\n\n    void propagate(int node, int start, int end) {\n        if (lazy[node] != 0) {\n            tree[node] = 0;\n\n            if (start != end - 1) {\n                lazy[2 * node + 1] = 1;\n                lazy[2 * node + 2] = 1;\n            }\n            lazy[node] = 0;\n        }\n    }\n\n    // Update the segment tree in the range [l, r)\n    void update_range(int node, int start, int end, int l, int r) {\n        propagate(node, start, end);\n\n        if (start >= r || end <= l) {\n            return;\n        }\n\n        if (start >= l && end <= r) {\n            tree[node] = 0;\n            if (start != end - 1) {\n                lazy[2 * node + 1] = 1;\n                lazy[2 * node + 2] = 1;\n            }\n            return;\n        }\n\n        int mid = (start + end) / 2;\n        update_range(2 * node + 1, start, mid, l, r);\n        update_range(2 * node + 2, mid, end, l, r);\n        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n    }\n\n    int query_range(int node, int start, int end, int l, int r) {\n        propagate(node, start, end);\n\n        if (start >= r || end <= l) {\n            return 0;\n        }\n\n        if (start >= l && end <= r) {\n            return tree[node];\n        }\n\n        int mid = (start + end) / 2;\n        int left_query = query_range(2 * node + 1, start, mid, l, r);\n        int right_query = query_range(2 * node + 2, mid, end, l, r);\n        return left_query + right_query;\n    }\npublic:\n    LazySegmentTree(int size) {\n        n = size;\n        tree.resize(4 * n, 0);\n        lazy.resize(4 * n, 0);\n        build(0, 0, n);\n    }\n\n    // Update range [l, r) to set elements to zero\n    void update(int l, int r) {\n        update_range(0, 0, n, l, r);\n    }\n\n    // Query the number of ones in range [l, r)\n    int query(int l, int r) {\n        return query_range(0, 0, n, l, r);\n    }\n};\n\n\nclass Solution {\npublic:\n    //we want the earliest one that is the longest\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        LazySegmentTree l(n);\n        vector<int> result;\n        for(auto& query : queries)\n        {\n            l.update(query[0] + 1, query[1]);\n            result.push_back(l.query(0, n-1));\n        }\n        return result;\n    }\n};",
    "submit_ts": "1722741732",
    "subm_id": "1343752151"
}