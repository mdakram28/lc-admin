{
    "username": "techie-arpit",
    "submission": "\nclass PeakSegmentTree {\nprivate:\n    vector<int> segTree;\n    vector<int>& arr;\n    int size;\n\n    int buildTree(int nodeIdx, int start, int end) {\n        if (start == end) {\n            return segTree[nodeIdx] = isPeak(start) ? 1 : 0;\n        }\n        int mid = (start + end) / 2;\n        int leftChild = buildTree(2 * nodeIdx + 1, start, mid);\n        int rightChild = buildTree(2 * nodeIdx + 2, mid + 1, end);\n        return segTree[nodeIdx] = leftChild + rightChild;\n    }\n\n    int queryTree(int nodeIdx, int start, int end, int left, int right) {\n        if (right < start || end < left) {\n            return 0;\n        }\n        if (left <= start && end <= right) {\n            return segTree[nodeIdx];\n        }\n        int mid = (start + end) / 2;\n        int leftChild = queryTree(2 * nodeIdx + 1, start, mid, left, right);\n        int rightChild = queryTree(2 * nodeIdx + 2, mid + 1, end, left, right);\n        return leftChild + rightChild;\n    }\n\n    void updateTree(int nodeIdx, int start, int end, int idx) {\n        if (start == end) {\n            segTree[nodeIdx] = isPeak(start) ? 1 : 0;\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid) {\n                updateTree(2 * nodeIdx + 1, start, mid, idx);\n            } else {\n                updateTree(2 * nodeIdx + 2, mid + 1, end, idx);\n            }\n            segTree[nodeIdx] = segTree[2 * nodeIdx + 1] + segTree[2 * nodeIdx + 2];\n        }\n    }\n\n    bool isPeak(int idx) {\n        return idx > 0 && idx < size - 1 && arr[idx] > arr[idx - 1] && arr[idx] > arr[idx + 1];\n    }\n\npublic:\n    PeakSegmentTree(vector<int>& arr) : arr(arr) {\n        size = arr.size();\n        segTree.resize(4 * size);\n        buildTree(0, 0, size - 1);\n    }\n\n    int query(int left, int right) {\n        return queryTree(0, 0, size - 1, left + 1, right - 1); // Avoid edges\n    }\n\n    void update(int idx, int val) {\n        arr[idx] = val;\n        updateTree(0, 0, size - 1, idx);\n        if (idx > 0) updateTree(0, 0, size - 1, idx - 1); // Check left neighbor\n        if (idx < size - 1) updateTree(0, 0, size - 1, idx + 1); // Check right neighbor\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        PeakSegmentTree peakSegTree(nums);\n        vector<int> result;\n        \n        for (const auto& query : queries) {\n            if (query[0] == 1) {  // Count peaks in subarray\n                int li = query[1], ri = query[2];\n                result.push_back(peakSegTree.query(li, ri));\n            } else if (query[0] == 2) {  // Update value in nums\n                int index = query[1], value = query[2];\n                peakSegTree.update(index, value);\n            }\n        }\n        \n        return result;\n    }\n};\n",
    "submit_ts": 1718507207.0
}