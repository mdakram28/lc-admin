{
    "username": "mathcruncher",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        const auto [heights1, diam1] = GetHeights(edges1);\n        const auto [heights2, diam2] = GetHeights(edges2);\n        int result = max(diam1, diam2);\n        int min_height_one = *std::min_element(heights1.begin(), heights1.end());\n        int min_height_two = *std::min_element(heights2.begin(), heights2.end());\n        result = max(result, 1 + min_height_one + min_height_two);\n        return result;\n    }\n\n    pair<vector<int>, int> GetHeights(const vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vector<vector<int>> adj(n);\n        for (const auto& edge : edges) {\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n        int last_node = 0;\n        queue<int> nodes;\n        vector<bool> visited(n, false);\n        visited[0] = true;\n        nodes.push(last_node);\n        while (!nodes.empty()) {\n            last_node = nodes.front();\n            nodes.pop();\n            for (int neighbor : adj[last_node]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    nodes.push(neighbor);\n                }\n            }\n        }\n        int first_endpoint = last_node;\n        // last_node is on a longest path\n        int diameter = -1;\n        nodes.push(last_node);\n        visited = vector<bool>(n, false);\n        visited[last_node] = true;\n        vector<int> heights(n, 0);\n        while (!nodes.empty()) {\n            ++diameter;\n            int q_size = nodes.size();\n            for (int i = 0; i < q_size; ++i) {\n                last_node = nodes.front();\n                nodes.pop();\n                heights[last_node] = max(heights[last_node], diameter);\n                for (int neighbor : adj[last_node]) {\n                    if (!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        nodes.push(neighbor);\n                    }\n                }\n            }\n        }\n        int second_endpoint = last_node;\n        nodes.push(last_node);\n        visited = vector<bool>(n, false);\n        visited[last_node] = true;\n        diameter = -1;\n        while (!nodes.empty()) {\n            ++diameter;\n            int q_size = nodes.size();\n            for (int i = 0; i < q_size; ++i) {\n                last_node = nodes.front();\n                nodes.pop();\n                heights[last_node] = max(heights[last_node], diameter);\n                for (int neighbor : adj[last_node]) {\n                    if (!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        nodes.push(neighbor);\n                    }\n                }\n            }\n        }\n        return {heights, diameter};\n    }\n};\n",
    "submit_ts": "1719717513",
    "subm_id": "1304393568"
}