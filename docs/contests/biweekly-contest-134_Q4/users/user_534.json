{
    "username": "RohanKadam",
    "submission": "#include<bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\nstatic const auto fast = []()\n{ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0;} ();\n \n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate <typename num_t>\nusing ordered_set = tree<num_t, null_type, less<num_t>, rb_tree_tag, tree_order_statistics_node_update>;  // find_by_order(*) , order_of_key\n \n \n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//\n#define mod 1000000007\n#define mod2 998244353\n#define INF  1e18\n//counting number of set bits\n#define bitsi(n) __builtin_popcount(n)\n#define bitsl(n) __builtin_popcount(n)\n#define bitsll(n) __builtin_popcountll(n)\n#define endl \"\\n\" \n#define f first\n#define s second\n#define rep(i,begin,end) for(__typeof(end) i=(begin)-((begin)>(end));i!=(end)-((begin)>(end)); i+=1-2*((begin)>(end)))\n#define pb push_back\n#define read(a,n) for(ll i=0;i<n;i++){cin>>a[i];}\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n//string to int stoi(s) to long long int stoll(s)\ntypedef long long ll;\ntypedef long  double lld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ull,ull> puu;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef vector<pll> vpll;\n \n// #ifndef ONLINE_JUDGE\n// #include \"dbg.cpp\"\n// #else\n// #define debug(...)\n// #define debugArr(arr, n)\n// #endif\n\n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//\nll binexp(ll a,ll x,ll m){\n    ll ans=1;\n    a%=m;\n    while(x){\n    if(x&1){ ans=(ans*a)%m;}\n     a=(a*a)%m;\n     x>>=1;\n}\nreturn ans;\n}\n//return {x,y,gcd} ; a*x + b*y = gcd\nvoid extendgcd(ll a, ll b, ll*v) {if (b == 0) {v[0] = 1; v[1] = 0; v[2] = a; return ;} extendgcd(b, a % b, v); ll x = v[1]; v[1] = v[0] - v[1] * (a / b); v[0] = x; return;} //pass an arry of size1 3\n\nll mod_inverse(ll b,ll m){return binexp(b,m-2,m);}\nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\nll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mod_inverse(b, m), m) + m) % m;}  //only for prime m\n \nvoid sieveOfEratosthenes(int n){\nvector<bool> primes(n+1,1);\n primes[0]=0; primes[1]=0;\n     for(int i=2;i*i<=n;i++){\n     if(primes[i]==1){\n          for(int j=i*i;j<=n;j+=i){\n         primes[j]=0;\n       }}}\n}\n\n     // Segment Tree with Point Updates and Range Queries\n     // Supports multiple Segment Trees with just a change in the Node and Update\n     // Very few changes required everytime\n     \n     template<typename Node, typename Update>\n     struct SegTree {\n        vector<Node> tree;\n        vector<ll> arr; // type may change\n        int n;\n        int s;\n        SegTree(int a_len, vector<ll> &a) { // change if type updated\n            arr = a;\n            n = a_len;\n            s = 1;\n            while(s < 2 * n){\n                s = s << 1;\n            }\n            tree.resize(s); fill(all(tree), Node());\n            build(0, n - 1, 1);\n        }\n        void build(int start, int end, int index)  // Never change this\n        {\n            if (start == end)\t{\n                tree[index] = Node(arr[start]);\n                return;\n            }\n            int mid = (start + end) / 2;\n            build(start, mid, 2 * index);\n            build(mid + 1, end, 2 * index + 1);\n            tree[index].merge(tree[2 * index], tree[2 * index + 1]);\n        }\n        void update(int start, int end, int index, int query_index, Update &u)  // Never Change this\n        {\n            if (start == end) {\n                u.apply(tree[index]);\n                return;\n            }\n            int mid = (start + end) / 2;\n            if (mid >= query_index)\n                update(start, mid, 2 * index, query_index, u);\n            else\n                update(mid + 1, end, 2 * index + 1, query_index, u);\n            tree[index].merge(tree[2 * index], tree[2 * index + 1]);\n        }\n        Node query(int start, int end, int index, int left, int right) { // Never change this\n            if (start > right || end < left)\n                return Node();\n            if (start >= left && end <= right)\n                return tree[index];\n            int mid = (start + end) / 2;\n            Node l, r, ans;\n            l = query(start, mid, 2 * index, left, right);\n            r = query(mid + 1, end, 2 * index + 1, left, right);\n            ans.merge(l, r);\n            return ans;\n        }\n        void make_update(int index, ll val) {  // pass in as many parameters as required\n            Update new_update = Update(val); // may change\n            update(0, n - 1, 1, index, new_update);\n        }\n        Node make_query(int left, int right) {\n            return query(0, n - 1, 1, left, right);\n        }\n     };\n     \n     struct Node1 {\n        ll val; // may change\n        Node1() { // Identity element\n            val = INT_MAX;\t// may change\n        }\n        Node1(ll p1) {  // Actual Node\n            val = p1; // may change\n        }\n        void merge(Node1 &l, Node1 &r) { // Merge two child nodes\n            val = (l.val & r.val);  // may change\n        }\n     };\n     \n     struct Update1 {\n        ll val; // may change\n        Update1(ll p1) { // Actual Update\n            val = p1; // may change\n        }\n        void apply(Node1 &a) { // apply update to given node\n            a.val = val; // may change\n        }\n     };\n     \n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//,\n    \n class Solution {\npublic:\n    long long solve(vector<long long> a){\n        long long ans = 0;\n        int n = a.size(); \n        SegTree<Node1, Update1> sg(n, a);\n        for(int i = 0; i < n; i++){\ncout << a[i] << \" \";}\n        cout << endl;\n        // find first index where and is zero\n        for(int i = 0; i < n; i++){\n            int l = i, r = n - 1;\n            int j = n;\n            while(l <= r){\n                int mid = (l + r) / 2;\n                if(sg.make_query(i, mid).val == 0){\n                    j = mid; r = mid - 1;\n                }\n                else{\n                    l = mid + 1;\n                }\n            }\n            cout << i << \" \" << j << endl;\n            ans = ans + (n - j);\n}\n            return ans;\n}\n    long long countSubarrays(vector<int>& a, int k) {\n        int n = a.size();\n        long long ans = 0; \n        // bitwise and is k \n        // number of subarrays whose and is zero \n        vector<vector<long long >> arr;arr.push_back({});\n        int ii = 0; \n        for(int i = 0; i < n; i++){\n            if((a[i] & k) != k){\n                ii++; arr.push_back({});\n            }\n            else{\n                arr[ii].push_back(a[i]-k);\n}\n        }\n        \n        for(auto x:arr){\n            if(x.size() == 0) continue;\n            // no. of subarrays having zero and \n            ans = ans + solve(x);\n            \n}\n        return ans;\n    }\n};\n//-------------------------------------------------------------------------------------------------------------------------------",
    "submit_ts": "1720278545",
    "subm_id": "1311713833"
}