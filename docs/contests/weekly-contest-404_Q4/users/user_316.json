{
    "username": "Rad0miR",
    "submission": "public class Solution {\n    public int MinimumDiameterAfterMerge(int[][] edges1, int[][] edges2) \n    {   \n        (int r1, int d1) = Radius(edges1);\n        (int r2, int d2) = Radius(edges2);\n        \n        Console.WriteLine($\"{r1} {d1}\");\n        Console.WriteLine($\"{r2} {d2}\");\n        \n        return new int[] { d1, d2, r1 + r2 + 1 }.Max();\n        \n        static (int r, int d) Radius(int[][] edges) \n        {\n            int n = edges.Length + 1;\n            List<int>[] gr = Enumerable.Range(0, n).Select(_ => new List<int>()).ToArray();\n            foreach (var edge in edges) \n            {\n                gr[edge[0]].Add(edge[1]);\n                gr[edge[1]].Add(edge[0]);\n            }\n            \n            int[] r = new int[n];\n            int[] d = new int[n];\n            int D = 0;\n            Dfs1(0);\n            Dfs2(0);\n            \n            \n            return (r.Min(), D);\n            \n            int Dfs1(int v, int p = -1) \n            {\n                int max = -1;\n                foreach (int u in gr[v].Where(u => u != p)) max = Math.Max(max, Dfs1(u, v));\n                return d[v] = max + 1;\n            }\n            \n            void Dfs2(int v, int p = -1, int l = 0) \n            {\n                int[] best2 = gr[v]\n                    .Where(u => u != p)\n                    .Select(u => d[u])\n                    .Append(-2).Append(-2)\n                    .OrderByDescending(_ => _)\n                    .Take(2)\n                    .ToArray();\n                \n                foreach (int u in gr[v].Where(u => u != p)) \n                {\n                    int b = d[u] == best2[0] ? best2[1] : best2[0];\n                    Dfs2(u, v, Math.Max(l + 1, b + 2));\n                }\n                \n                r[v] = Math.Max(d[v], l);\n                \n                int[] B = best2.Append(l).Order().ToArray();\n                \n                D = Math.Max(D, Math.Max(B[^1], 0) + Math.Max(B[^2], 0));\n            }\n            \n            \n            /*Queue<int> q = new(gr.Select((row, i) => (row, i)).Where(p => p.row.Count == 1).Select(p => p.i));\n            \n            bool[] used = new bool[n];\n            List<int> last = new(n); \n            int r = 0;\n            \n            for (; q.Any();) \n            {\n                bool isOld = true;\n                for (int cnt = q.Count; cnt > 0; --cnt) \n                {\n                    int v = q.Dequeue();\n                    if (used[v]) continue;\n                    \n                    used[v] = true;\n                    \n                    if (isOld) \n                    {\n                        isOld = false;\n                        last.Clear();\n                        ++r;\n                    }\n                    \n                    last.Add(v);\n                    \n                    foreach (int u in gr[v]) q.Enqueue(u);\n                }\n            }\n            return (r - 1 + (last.Count == 1 ? 0 : 1), (r - 1) * 2 + (last.Count == 1 ? 0 : 1));*/\n        }\n    }\n}",
    "submit_ts": "1719718756",
    "subm_id": "1304425307"
}