{
    "username": "Maulik_Thakkar",
    "submission": "\n#define lli long long\n\nclass sgTree\n{\n    vector<lli> tree;\n    lli size;\n    public:\n\n    void build(vector<lli> &arr , lli low , lli high , lli ind)\n    {\n        if(low==high)\n        {\n            lli n = arr.size();\n            if(low ==0 || low==n-1) tree[ind] = 0;\n            else if(arr[low] > arr[low+1] && arr[low] > arr[low-1]) tree[ind] = 1;\n            else tree[ind] = 0;\n            return;\n        }\n        lli mid = low + (high-low)/2;\n        build(arr , low , mid , 2*ind+1);\n        build(arr , mid+1 , high , 2*ind+2);\n        tree[ind] = tree[2*ind+1] + tree[2*ind+2];\n    }\n\n    sgTree(vector<lli> &arr)    // constructor\n    {\n        lli n = arr.size();\n        tree.resize(4*n+1 , 0);\n        size = n;\n        build(arr , 0 , n-1 , 0);\n    }\n\n    lli qrHelp(lli low , lli high , lli left , lli right , lli ind)\n    {\n        // No Overlap\n        if(low > right || high < left)\n        {\n            return 0;\n        }\n        // Complete Overlap\n        if(low>=left && high<=right)\n        {\n            return tree[ind];\n        } \n\n        // Partial Overlap\n\n        lli mid = low + (high-low)/2;\n        lli ll = qrHelp(low , mid , left , right , 2*ind+1);\n        lli rr = qrHelp(mid+1 , high , left , right , 2*ind+2);\n        return ll + rr;\n    }\n\n    lli qr(lli l , lli r)  // return minimum in [l , r]\n    {\n        return qrHelp(0 , size-1 , l , r , 0);\n    }\n\n    void update(lli i, lli val , vector<lli>&arr)   // update arr[i] = val;\n    {\n        updateHelp(0 , size-1 , 0 , i , val , arr);\n        lli n = arr.size();\n        if(i+1 < n)\n        {\n            updateHelp(0 , size-1 , 0 , i+1 , arr[i+1] , arr);\n        }\n        if(i-1>=0)\n        {\n            updateHelp(0 , size-1 , 0 , i-1 , arr[i-1] , arr);\n        }\n    }\n\n    void updateHelp(lli low , lli high ,lli ind , lli i , lli val , vector<lli>&arr)\n    {\n        if(low==high)\n        {\n            \n            if(i==size-1||i==0) tree[ind] = 0;\n            else if(val > arr[i-1] && val > arr[i+1]) tree[ind] = 1;\n            else tree[ind] = 0;\n            arr[low] = val;\n            return;\n        }\n\n        lli mid = low + (high-low)/2;\n        if(i<=mid)\n        {\n            updateHelp(low , mid , 2*ind+1 , i , val , arr);\n        }\n        else{\n            updateHelp(mid+1 , high , 2*ind+2 , i , val , arr);\n        }\n\n        tree[ind] = tree[2*ind+1] + tree[2*ind+2];\n    }\n};\n\n\n\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> ans;\n        vector<lli> arr;\n        for(auto it : nums) arr.push_back(it);\n        sgTree seg(arr);\n        for(auto it : queries)\n        {\n            int type = it[0];\n            if(type==1)\n            {\n                int l = it[1] , r = it[2];\n                \n                lli temp = seg.qr(l , r) - seg.qr(l , l) - seg.qr(r , r);\n                ans.push_back(max(temp , 0LL));\n            }\n            else{\n                lli ind = it[1] , val = it[2];\n                \n                seg.update(ind , val , arr);\n            }\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": "1718506996",
    "subm_id": "1289637771"
}