{
    "username": "211FA04639",
    "submission": "\ndef is_prime(n):\n    \"\"\"Check if a number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef is_armstrong(number):\n    \"\"\"Check if a number is an Armstrong number.\"\"\"\n    # Convert the number to a string to easily iterate over each digit\n    num_str = str(number)\n    # Calculate the number of digits\n    num_digits = len(num_str)\n    # Calculate the sum of each digit raised to the power of num_digits\n    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)\n    # Check if the sum of powers is equal to the original number\n    return sum_of_powers == number\n\ndef gcd(a, b):\n    \"\"\"Calculate the Greatest Common Divisor (GCD) of two numbers using Euclidean algorithm.\"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef are_coprime(num1, num2):\n    \"\"\"Check if two numbers are co-prime.\"\"\"\n    return gcd(num1, num2) == 1\ndef is_perfect_number(n):\n    \"\"\"Check if a number is a perfect number.\"\"\"\n    if n < 2:\n        return False\n    # Calculate the sum of proper divisors\n    sum_of_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_of_divisors += i\n            if i != n // i:\n                sum_of_divisors += n // i\n    # Check if the sum of divisors is equal to the original number\n    return sum_of_divisors == n\ndef factorial(n):\n    \"\"\"Calculate the factorial of a number.\"\"\"\n    if n < 0:\n        return \"Factorial is not defined for negative numbers.\"\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\ndef fibonacci_series(n):\n    \"\"\"Generate Fibonacci series up to n terms.\"\"\"\n    if n <= 0:\n        return \"Number of terms must be a positive integer.\"\n    if n == 1:\n        return [0]\n    if n == 2:\n        return [0, 1]\n    \n    series = [0, 1]\n    for i in range(2, n):\n        next_term = series[-1] + series[-2]\n        series.append(next_term)\n    return series\n\n    \n    \nfrom typing import List\n\nclass Solution:\n    MOD = 1_000_000_007\n    MAX_INVERSIONS = 400\n    \n    def numberOfPermutations(self, n: int, requirements: List[List[int]]) -> int:\n        req_map = {req[0] + 1: req[1] for req in requirements}  # Adjusting indices to match 1-based length\n        \n        # Initialize a 2D list to store permutation counts\n        perm_counts = [[0] * (self.MAX_INVERSIONS + 1) for _ in range(n + 1)]\n        perm_counts[0][0] = 1  # Base case: one way to arrange zero elements with zero inversions\n        \n        # Populate the permutation counts\n        for length in range(1, n + 1):\n            for inv_count in range(self.MAX_INVERSIONS + 1):\n                for new_pos in range(length):\n                    prev_inv_count = inv_count - new_pos\n                    if prev_inv_count >= 0:\n                        perm_counts[length][inv_count] = (perm_counts[length][inv_count] + perm_counts[length - 1][prev_inv_count]) % self.MOD\n\n            # Apply requirements\n            if length in req_map:\n                target_inv_count = req_map[length]\n                for inv_count in range(self.MAX_INVERSIONS + 1):\n                    if inv_count != target_inv_count:\n                        perm_counts[length][inv_count] = 0\n\n        # Sum all valid permutations of length `n`\n        total_permutations = sum(perm_counts[n]) % self.MOD\n\n        return total_permutations\n\n    \n    \ndef is_prime(n):\n    \"\"\"Check if a number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef is_armstrong(number):\n    \"\"\"Check if a number is an Armstrong number.\"\"\"\n    # Convert the number to a string to easily iterate over each digit\n    num_str = str(number)\n    # Calculate the number of digits\n    num_digits = len(num_str)\n    # Calculate the sum of each digit raised to the power of num_digits\n    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)\n    # Check if the sum of powers is equal to the original number\n    return sum_of_powers == number\n\ndef gcd(a, b):\n    \"\"\"Calculate the Greatest Common Divisor (GCD) of two numbers using Euclidean algorithm.\"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef are_coprime(num1, num2):\n    \"\"\"Check if two numbers are co-prime.\"\"\"\n    return gcd(num1, num2) == 1\ndef is_perfect_number(n):\n    \"\"\"Check if a number is a perfect number.\"\"\"\n    if n < 2:\n        return False\n    # Calculate the sum of proper divisors\n    sum_of_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_of_divisors += i\n            if i != n // i:\n                sum_of_divisors += n // i\n    # Check if the sum of divisors is equal to the original number\n    return sum_of_divisors == n\ndef factorial(n):\n    \"\"\"Calculate the factorial of a number.\"\"\"\n    if n < 0:\n        return \"Factorial is not defined for negative numbers.\"\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\ndef fibonacci_series(n):\n    \"\"\"Generate Fibonacci series up to n terms.\"\"\"\n    if n <= 0:\n        return \"Number of terms must be a positive integer.\"\n    if n == 1:\n        return [0]\n    if n == 2:\n        return [0, 1]\n    \n    series = [0, 1]\n    for i in range(2, n):\n        next_term = series[-1] + series[-2]\n        series.append(next_term)\n    return series",
    "submit_ts": "1719070717",
    "subm_id": "1296830037"
}