{
    "username": "DylanSmith",
    "submission": "typedef long long ll;\n \n#define pb push_back\n#define sz(x) (int)x.size()\n#define all(x) begin(x),end(x)\n#define lb(x,y) lower_bound(all(x),y)-begin(x)\n\ntypedef struct Node {\n    int adj[26], par; int cost = INT_MAX;\n    Node(int p = -1) {\n        par = p;\n        fill(adj, adj + 26, -1);\n    }\n} node;\n\nvector<node> tree;\n\nint add(string &s, int k) {\n    int cur = 0;\n    for (char c : s) {\n        if (tree[cur].adj[c - 'a'] == -1) {\n            tree[cur].adj[c - 'a'] = sz(tree);\n            tree.emplace_back(cur);\n        }\n        cur = tree[cur].adj[c - 'a'];\n    }\n    tree[cur].cost = min(tree[cur].cost, k);\n    return cur;\n}\n\nvector<int> prefix(string s) {\n    vector<int> res(sz(s)); res[0] = 0;\n    for (int i = 1; i < sz(s); i++) {\n        int j = res[i - 1];\n        while (j > 0 && s[j] != s[i])\n            j = res[j - 1];\n        if (s[j] == s[i]) j++;\n        res[i] = j;\n    }\n    return res;\n}\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        tree = vector<node>(1);\n        int SQRT = 1; while (SQRT * SQRT < sz(target)) SQRT++;\n        vector<vector<int>> v(sz(target));\n        for (int i = 0; i < sz(words); i++) {\n            string s = words[i];\n            reverse(all(s));\n            add(s, costs[i]);\n            if (sz(words[i]) >= SQRT) {\n                string t = words[i] + \"#\" + target;\n                vector<int> p = prefix(t);\n                for (int j = 0; j < sz(target); j++) {\n                    if (p[j + sz(words[i]) + 1] == sz(words[i])) {\n                        v[j].pb(i);\n                    }\n                }\n            }\n        }\n        vector<int> dp(sz(target) + 1, INT_MAX);\n        dp[0] = 0;\n        for (int i = 0; i < sz(target); i++) {\n            int cur = 0;\n            for (int j = i; j >= 0 && i - j + 1 <= SQRT; j--) {\n                if (tree[cur].adj[target[j] - 'a'] == -1) break;\n                cur = tree[cur].adj[target[j] - 'a'];\n                if (tree[cur].cost < INT_MAX && dp[j] != INT_MAX) dp[i + 1] = min(dp[i + 1], dp[j] + tree[cur].cost);\n            }\n            for (int j : v[i]) {\n                if (dp[i - sz(words[j]) + 1] != INT_MAX) dp[i + 1] = min(dp[i + 1], dp[i - sz(words[j]) + 1] + costs[j]);\n            }\n        }\n        return dp[sz(dp) - 1] == INT_MAX ? -1 : dp[sz(dp) - 1];\n    }\n};",
    "submit_ts": "1720321087",
    "subm_id": "1312313110"
}