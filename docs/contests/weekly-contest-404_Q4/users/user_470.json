{
    "username": "2022_grad",
    "submission": "class Solution {\npublic:\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        if(edges.empty())return {0};\n        vector<unordered_set<int>>g(n);\n        for(auto &i:edges){\n            int from  = i[0];\n            int to = i[1];\n            g[from].insert(to);\n            g[to].insert(from);\n        }\n        queue<int>leaves;\n        for(int i=0;i<n;i++){\n            // leaf node\n            if(g[i].size()==1)leaves.push(i);\n        }\n        int cnt = n;\n        while(cnt>2){\n            // cout<<leaves.size()<<\" \";\n            int sz = leaves.size();\n            cnt-=sz;\n            while(sz--){\n                int leaf = leaves.front();\n                leaves.pop();\n                int from = *g[leaf].begin();\n                g[from].erase(leaf);\n                if(g[from].size()==1){\n                    leaves.push(from);\n                }\n            }\n        }\n        vector<int>ans;\n        while(!leaves.empty()){\n            ans.push_back(leaves.front());\n            leaves.pop();\n        }\n        return ans;\n    }\n    void dfs(int node,int par,vector<int>&depth,int &maxDepthNode,vector<vector<int>>&g){\n        if(par!=-1)depth[node] = 1 + depth[par];\n        else depth[node]=1;\n        if(depth[node]>depth[maxDepthNode]){\n            maxDepthNode = node;\n        }\n        for(auto &to:g[node]){\n            if(to==par)continue;\n            dfs(to,node,depth,maxDepthNode,g);\n        }\n    };\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size()+1;\n        int m = edges2.size()+1;\n        auto a = findMinHeightTrees(n,edges1);\n        auto b = findMinHeightTrees(m,edges2);\n        vector<vector<int>>g(n+m+1);\n        for(auto &i:edges1){\n            int u = i[0];\n            int v = i[1];\n            g[u].push_back(v);\n            g[v].push_back(u);\n        }\n        for(auto &i:edges2){\n            int u = i[0]+n;\n            int v = i[1]+n;\n            g[u].push_back(v);\n            g[v].push_back(u);\n        }\n        int u = a[0];\n        int v = b[0]+n;\n        g[u].push_back(v);\n        g[v].push_back(u);\n        vector<int>depth(n+m+1,0);\n        int maxDepthNode = 0;\n        dfs(0,-1,depth,maxDepthNode,g);\n        depth.clear();\n        depth.resize(n+m+1);\n        int startNodeOfDiameter = maxDepthNode;\n        maxDepthNode=0;\n        dfs(startNodeOfDiameter,-1,depth,maxDepthNode,g);\n        return depth[maxDepthNode]-1;\n    }\n};\n\nstatic const auto speedup = []() {\n    std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return 0;\n}();\n",
    "submit_ts": 1719718750.0
}