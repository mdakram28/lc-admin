{
    "username": "Wilsano",
    "submission": "class Solution {\npublic:\n    vector<vector<int>> prefix_top_left;\n    vector<vector<int>> prefix_top_right;\n    vector<vector<int>> prefix_bottom_left;\n    vector<vector<int>> prefix_bottom_right;\n    vector<vector<int>> prefix_max;\n    vector<vector<int>> suffix_max;\n    vector<vector<vector<int>>> prefix_col;\n    vector<vector<vector<int>>> suffix_col;\n\n    long long find(int i, int j, vector<vector<int>>& board){\n        long long val = LLONG_MIN;\n        int m = board.size(), n = board[0].size();\n        if(i != 0 && i != m - 1 && j != 0 && j != n - 1){\n            val = max(val, (long long)board[i][j] + prefix_top_left[i - 1][j - 1] + prefix_bottom_right[i + 1][j + 1]);\n            val = max(val, (long long)board[i][j] + prefix_top_right[i - 1][j + 1] + prefix_bottom_left[i + 1][j - 1]);\n        }\n        \n        // take (i, j) as the center cell, try all possible combimation\n        if(1 <= j && j <= n - 2){\n            vector<vector<int>> pair_1 = prefix_col[j - 1];\n            vector<vector<int>> pair_2 = suffix_col[j + 1];\n            for(int a = 0; a < 3; ++a){\n                for(int b = 0; b < 3; ++b){\n                    int idx_1 = pair_1[a][1];\n                    int idx_2 = pair_2[b][1];\n                    if(idx_1 != idx_2 && idx_1 != i && idx_2 != i){\n                        val = max(val, (long long)board[i][j] + pair_1[a][0] + pair_2[b][0]);\n                    }\n                }\n            }\n        }\n\n        return val;\n    }\n\n    void initialize_2(int m, int n, vector<vector<int>>& board){\n        prefix_max.resize(m, vector<int>(n, -1e9));\n        suffix_max.resize(m, vector<int>(n, -1e9));\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                prefix_max[i][j] = max(prefix_max[i][max(0, j - 1)], board[i][j]);\n            }\n            for(int j = n - 1; j >= 0; --j){\n                suffix_max[i][j] = max(suffix_max[i][min(n - 1, j + 1)], board[i][j]);\n            }\n        }\n        \n        prefix_col.resize(n);\n        suffix_col.resize(n);\n        for(int c = 0; c < n; ++c){\n            vector<vector<int>> arr;\n            for(int r = 0; r < m; ++r){\n                arr.push_back({prefix_max[r][c], r});\n            }\n            sort(arr.rbegin(), arr.rend());\n            \n            for(int i = 0; i < 3; ++i){\n                prefix_col[c].push_back(arr[i]);\n            }\n        }\n        for(int c = 0; c < n; ++c){\n            vector<vector<int>> arr;\n            for(int r = 0; r < m; ++r){\n                arr.push_back({suffix_max[r][c], r});\n            }\n            sort(arr.rbegin(), arr.rend());\n            \n            for(int i = 0; i < 3; ++i){\n                suffix_col[c].push_back(arr[i]);\n            }\n        }\n    }\n    \n    void initialize(int m, int n, vector<vector<int>>& board){\n        prefix_top_left.resize(m, vector<int>(n, -1e9));\n        prefix_top_right.resize(m, vector<int>(n, -1e9));\n        prefix_bottom_left.resize(m, vector<int>(n, -1e9));\n        prefix_bottom_right.resize(m, vector<int>(n, -1e9));\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                prefix_top_left[i][j] = board[i][j];\n                if(i >= 1)      prefix_top_left[i][j] = max(prefix_top_left[i][j], prefix_top_left[i - 1][j]);\n                if(j >= 1)      prefix_top_left[i][j] = max(prefix_top_left[i][j], prefix_top_left[i][j - 1]);\n            }\n        }\n        \n        for(int i = 0; i < m; ++i){\n            for(int j = n - 1; j >= 0; --j){\n                prefix_top_right[i][j] = board[i][j];\n                if(i >= 1)       prefix_top_right[i][j] = max(prefix_top_right[i][j], prefix_top_right[i - 1][j]);\n                if(j + 1 < n)    prefix_top_right[i][j] = max(prefix_top_right[i][j], prefix_top_right[i][j + 1]);\n            }\n        }\n        \n        for(int i = m - 1; i >= 0; --i){\n            for(int j = 0; j < n; ++j){\n                prefix_bottom_left[i][j] = board[i][j];\n                if(i + 1 < m)    prefix_bottom_left[i][j] = max(prefix_bottom_left[i][j], prefix_bottom_left[i + 1][j]);\n                if(j >= 1)       prefix_bottom_left[i][j] = max(prefix_bottom_left[i][j], prefix_bottom_left[i][j - 1]);\n            }\n        }\n        \n        for(int i = m - 1; i >= 0; --i){\n            for(int j = n - 1; j >= 0; --j){\n                prefix_bottom_right[i][j] = board[i][j];\n                if(i + 1 < m)    prefix_bottom_right[i][j] = max(prefix_bottom_right[i][j], prefix_bottom_right[i + 1][j]);\n                if(j + 1 < n)    prefix_bottom_right[i][j] = max(prefix_bottom_right[i][j], prefix_bottom_right[i][j + 1]);\n            }\n        }\n    }\n\n    long long maximumValueSum(vector<vector<int>>& board) {\n        // find prefix max for [0:0] ~ [i:j]\n        int m = board.size();\n        int n = board[0].size();\n        initialize(m, n, board);\n        initialize_2(m, n, board);\n\n        long long max_val = LLONG_MIN;\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                long long val = find(i, j, board);\n                max_val = max(max_val, val);\n            }\n        }\n\n        return max_val;\n    }\n};",
    "submit_ts": "1723909935",
    "subm_id": "1359211183"
}