{
    "username": "sheepforever",
    "submission": "const int N = 100007;\n\nvector<int> e[N];\n\nclass Solution {\npublic:\n    pair<int, int> bfs(int x, int n) {\n        queue<int> q;\n        vector<int> dis(n, -1);\n        dis[x] = 0;\n        q.push(x);\n        \n        int last = -1;\n        while (!q.empty()) {\n            int x = q.front();\n            q.pop();\n            last = x;\n            for (int to : e[x]) {\n                if (dis[to] == -1) {\n                    dis[to] = dis[x] + 1;\n                    q.push(to);\n                }\n            }\n        }\n        return make_pair(dis[last], last);\n    }\n    \n    int getDia(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        for (int i = 0; i < n; ++i) {\n            e[i].clear();\n        }\n        for (int i = 0; i < n - 1; ++i) {\n            int u = edges[i][0];\n            int v = edges[i][1];\n            \n            e[u].push_back(v);\n            e[v].push_back(u);\n        }\n        \n        auto it1 = bfs(0, n);\n        auto it2 = bfs(it1.second, n);\n        return it2.first;\n        \n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int d1 = getDia(edges1);\n        int d2 = getDia(edges2);\n        \n        return max(d1, max(d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1));\n    }\n};",
    "submit_ts": "1719715094",
    "subm_id": "1304327939"
}