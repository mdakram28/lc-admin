{
    "username": "tanuj_123",
    "submission": "class Solution {\npublic:\n    \n    int getMid(int s, int e) { return s + (e -s)/2; } \n \n  \n    int getSumUtil(int *st, int ss, int se, int qs, int qe, int si) \n    { \n        // If segment of this node is a part of given range, then return \n        // the sum of the segment \n        if (qs <= ss && qe >= se) \n            return st[si]; \n\n        // If segment of this node is outside the given range \n        if (se < qs || ss > qe) \n            return 0; \n\n        // If a part of this segment overlaps with the given range \n        int mid = getMid(ss, se); \n        return getSumUtil(st, ss, mid, qs, qe, 2*si+1) + \n            getSumUtil(st, mid+1, se, qs, qe, 2*si+2); \n    } \n\n   \n    void updateValueUtil(int *st, int ss, int se, int i, int diff, int si) \n    { \n        // Base Case: If the input index lies outside the range of \n        // this segment \n        if (i < ss || i > se) \n            return; \n\n        // If the input index is in range of this node, then update \n        // the value of the node and its children \n        st[si] = st[si] + diff; \n        if (se != ss) \n        { \n            int mid = getMid(ss, se); \n            updateValueUtil(st, ss, mid, i, diff, 2*si + 1); \n            updateValueUtil(st, mid+1, se, i, diff, 2*si + 2); \n        } \n    } \n\n  \n    void updateValue(int arr[], int *st, int n, int i, int new_val) \n    { \n        // Check for erroneous input index \n        if (i < 0 || i > n-1) \n        { \n            return; \n        } \n\n        // Get the difference between new value and old value \n        int diff = new_val - arr[i]; \n\n        // Update the value in array \n        arr[i] = new_val; \n\n        // Update the values of nodes in segment tree \n        updateValueUtil(st, 0, n-1, i, diff, 0); \n    } \n\n    // Return sum of elements in range from index qs (query start) \n    // to qe (query end). It mainly uses getSumUtil() \n    int getSum(int *st, int n, int qs, int qe) \n    { \n        // Check for erroneous input values \n        if (qs < 0 || qe > n-1 || qs > qe) \n        { \n            \n            return 0; \n        } \n\n        return getSumUtil(st, 0, n-1, qs, qe, 0); \n    } \n\n   \n    int constructSTUtil(int arr[], int ss, int se, int *st, int si) \n    { \n        // If there is one element in array, store it in current node of \n        // segment tree and return \n        if (ss == se) \n        { \n            st[si] = arr[ss]; \n            return arr[ss]; \n        } \n\n        // If there are more than one elements, then recur for left and \n        // right subtrees and store the sum of values in this node \n        int mid = getMid(ss, se); \n        st[si] = constructSTUtil(arr, ss, mid, st, si*2+1) + \n                constructSTUtil(arr, mid+1, se, st, si*2+2); \n        return st[si]; \n    } \n\n    \n    int *constructST(int arr[], int n) \n    { \n       \n        int x = (int)(ceil(log2(n))); \n\n       \n        int max_size = 2*(int)pow(2, x) - 1; \n\n       \n        int *st = new int[max_size]; \n\n        // Fill the allocated memory st \n        constructSTUtil(arr, 0, n-1, st, 0); \n\n        // Return the constructed segment tree \n        return st; \n    } \n    \n    \n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& q) {\n        int n=nums.size();\n        int is[n];\n        memset(is,0,sizeof(is));\n        \n      \n       \n        for(int i=1;i<n-1;i++){\n            if(nums[i]>nums[i-1] && nums[i]>nums[i+1]){\n                is[i]=1;\n            }\n        }\n         int *st = constructST(is, n); \n        vector<int> ans;\n        \n        for(int i=0;i<q.size();i++){\n            if(q[i][0]==1){\n                int res=getSum(st, n, q[i][1]+1, q[i][2]-1);\n                if(res==-1){\n                    res=0;\n                }\n                ans.push_back(res);\n            }\n            else{\n                int index=q[i][1];\n                nums[index]=q[i][2];\n                if(index>0 && index<n-1){\n                    if(nums[index]>nums[index-1] && nums[index]>nums[index+1]){\n                         updateValue(is, st, n, index, 1); \n                    }\n                    else{\n                         updateValue(is, st, n, index, 0); \n                    }\n                }\n                index=index-1;\n                if(index>0 && index<n-1){\n                    if(nums[index]>nums[index-1] && nums[index]>nums[index+1]){\n                         updateValue(is, st, n, index, 1); \n                    }\n                    else{\n                         updateValue(is, st, n, index, 0); \n                    }\n                }\n                index=q[i][1]+1;\n                if(index>0 && index<n-1){\n                    if(nums[index]>nums[index-1] && nums[index]>nums[index+1]){\n                         updateValue(is, st, n, index, 1); \n                    }\n                    else{\n                         updateValue(is, st, n, index, 0); \n                    }\n                }\n            }\n        }\n        \n        return ans;\n        \n    }\n};",
    "submit_ts": "1718507132",
    "subm_id": "1289642187"
}