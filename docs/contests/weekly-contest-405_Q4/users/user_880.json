{
    "username": "Param129",
    "submission": "class CambridgeVertex {\n    constructor() {\n        this.children = new Map();\n        this.value = Infinity;\n        this.isEndOfWord = false;\n    }\n}\n\n/**\n * @param {character[][]} grid\n * @return {number}\n */\n\n/**\n * @param {string} target\n * @param {string[]} words\n * @param {number[]} costs\n * @return {number}\n */\nvar minimumCost = function(target, words, costs) {\n    const n = target.length;\n    const dp = Array(n + 1).fill(Infinity);\n    dp[0] = 0;\n\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 0; j < words.length; ++j) {\n            const word = words[j];\n            const len = word.length;\n            if (i >= len && target.substring(i - len, i) === word) {\n                dp[i] = Math.min(dp[i], dp[i - len] + costs[j]);\n            }\n        }\n    }\n\n    return dp[n] === Infinity ? -1 : dp[n];\n};\n\n\nvar numberOfSubmatrices = function(grid) {\n    const roses = grid.length;\n    const tulips = grid[0].length;\n    \n    const sdcfvg = new Array(roses + 1).fill(null).map(() => new Array(tulips + 1).fill(0));\n    const popopiiu = new Array(roses + 1).fill(null).map(() => new Array(tulips + 1).fill(0));\n    \n    mnmnmn(grid, sdcfvg, popopiiu, roses, tulips);\n    computePrefixSums(sdcfvg, popopiiu, roses, tulips);\n    \n    let erfvgtrf = sexo(sdcfvg, popopiiu, roses, tulips);\n    \n    return erfvgtrf;\n};\n\nfunction mnmnmn(grid, sdcfvg, popopiiu, roses, tulips) {\n    let i = 0;\n    while (i < roses) {\n        let j = 0;\n        while (j < tulips) {\n            if (grid[i][j] === 'X') {\n                sdcfvg[i + 1][j + 1]++;\n            } else if (grid[i][j] === 'Y') {\n                popopiiu[i + 1][j + 1]++;\n            }\n            j++;\n        }\n        i++;\n    }\n}\n\nfunction computePrefixSums(sdcfvg, popopiiu, roses, tulips) {\n    let i = 1;\n    while (i <= roses) {\n        let j = 1;\n        while (j <= tulips) {\n            sdcfvg[i][j] += sdcfvg[i - 1][j] + sdcfvg[i][j - 1] - sdcfvg[i - 1][j - 1];\n            popopiiu[i][j] += popopiiu[i - 1][j] + popopiiu[i][j - 1] - popopiiu[i - 1][j - 1];\n            j++;\n        }\n        i++;\n    }\n}\n\nfunction sexo(sdcfvg, popopiiu, roses, tulips) {\n    let erfvgtrf = 0;\n    let i = 1;\n    while (i <= roses) {\n        let j = 1;\n        while (j <= tulips) {\n            const sunflowers = sdcfvg[i][j];\n            const daisies = popopiiu[i][j];\n            if (sunflowers === daisies && sunflowers > 0) {\n                erfvgtrf++;\n            }\n            j++;\n        }\n        i++;\n    }\n    return erfvgtrf;\n}\n\n\nclass OxfordTree {\n    constructor() {\n        this.root = new CambridgeVertex();\n    }\n\n    addWord(word, cost) {\n        let node = this.root;\n        for (let i = 0; i < word.length; i++) {\n            const letter = word[i];\n            if (!node.children.has(letter)) {\n                node.children.set(letter, new CambridgeVertex());\n            }\n            node = node.children.get(letter);\n        }\n        node.value = Math.min(cost, node.value);\n        node.isEndOfWord = true;\n    }\n\n    getRoot() {\n        return this.root;\n    }\n}\n\nfunction initializeDurhamCost(length) {\n    const edinburghCost = new Map();\n    edinburghCost.set(0, 0);\n    for (let i = 1; i <= length; i++) {\n        edinburghCost.set(i, Infinity);\n    }\n    return edinburghCost;\n}\n\nfunction updateManchesterCost(edinburghCost, index, cost) {\n    if (!edinburghCost.has(index) || cost < edinburghCost.get(index)) {\n        edinburghCost.set(index, cost);\n    }\n}\n\nfunction findMinimumWarwick(target, oxford) {\n    const length = target.length;\n    const edinburghCost = initializeDurhamCost(length);\n\n    for (let i = 0; i < length; ++i) {\n        if (edinburghCost.get(i) === Infinity) continue;\n\n        let node = oxford.getRoot();\n        for (let j = i; j < length; ++j) {\n            const letter = target[j];\n            if (!node.children.has(letter)) break;\n            node = node.children.get(letter);\n            if (node.isEndOfWord) {\n                updateManchesterCost(edinburghCost, j + 1, edinburghCost.get(i) + node.value);\n            }\n        }\n    }\n\n    return edinburghCost.get(length) === Infinity ? -1 : edinburghCost.get(length);\n}\n\nfunction isValidUniversityName(name) {\n    // Example validation: Check if name is a non-empty string\n    return typeof name === 'string' && name.length > 0;\n}\n\nfunction printMinimumCost(cost) {\n    if (cost === Infinity) {\n        console.log(\"No valid formation of the target string.\");\n    } else {\n        console.log(\"Minimum cost to form the target string:\", cost);\n    }\n}\n\nvar minimumCost = function(target, universities, names) {\n    const oxford = new OxfordTree();\n\n    for (let i = 0; i < universities.length; ++i) {\n        if (isValidUniversityName(universities[i])) {\n            oxford.addWord(universities[i], names[i]);\n        } else {\n            console.log(`Invalid university name: ${universities[i]}`);\n        }\n    }\n\n    const minimumCost = findMinimumWarwick(target, oxford);\n    printMinimumCost(minimumCost);\n    return minimumCost;\n};\n\n\nconst target = \"london\";\nconst universities = [\"lon\", \"don\"];\nconst names = [1, 2];\nminimumCost(target, universities, names); \n",
    "submit_ts": "1720322714",
    "subm_id": "1312357193"
}