{
    "username": "guddusingh123",
    "submission": "const int INF = 1e9;\n\n// DEBUGGING TEMPLATE\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\nenable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cout << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifndef ONLINE_JUDGE\n~debug() { cout << endl; }\neni(!=) cout << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\nris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n*this << \"[\";\nfor (auto it = d.b; it != d.e; ++it)\n*this << \", \" + 2 * (it == d.b) << *it;\nris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n\n\nstruct S{\n    int n;\n    vector<int> t, lazy;\n    S(int N){\n        n = N;\n        t.resize(n<<2, INF);\n        lazy.resize(n<<2);\n    }\n \n    void push(int v, int tl, int tr){\n        if(!lazy[v]) return;\n        t[v] += lazy[v];\n        if(tl != tr){\n            lazy[v*2] += lazy[v];\n            lazy[v*2+1] += lazy[v];\n        }\n        lazy[v] = 0;\n    }\n \n    void updateRange(int v, int tl, int tr, int l, int r, int x){\n        push(v, tl, tr);\n        if(tl > r || tr < l) return;\n        if(tl >= l && tr <= r){\n            t[v] += x;\n            if(tl != tr){\n                lazy[v*2] += x;\n                lazy[v*2+1] += x;\n            }\n            return; \n        }\n        int tm = (tl + tr)>>1;\n        updateRange(v*2, tl, tm, l, r, x);\n        updateRange(v*2+1, tm+1, tr, l, r, x);\n        t[v] = min(t[v*2], t[v*2+1]);\n    }\n    void updateRange(int l, int r, int x){\n        updateRange(1, 1, n, l, r, x);\n    }\n \n    int query(int v, int tl, int tr, int l, int r){\n        push(v, tl, tr);\n        if(tl > r || tr < l) return INF;\n        if(tl >= l && tr <= r){\n            return t[v];\n        }\n        int tm = (tl + tr)>>1;\n        return min(query(v*2, tl, tm, l, r), query(v*2+1, tm+1, tr, l, r));\n    }\n    \n    int query(int l, int r){\n        return query(1, 1, n, l, r);\n    }\n \n    void updateInd(int v, int tl, int tr, int i, int x){\n        if(tl == tr){\n            t[v] = x;\n            return;\n        }\n        int tm = (tl + tr)>>1;\n        if(i <= tm) updateInd(v*2, tl, tm, i, x);\n        else updateInd(v*2+1, tm+1, tr, i, x);\n        t[v] = min(t[v*2], t[v*2+1]);\n    }\n \n    void updateInd(int i, int x){\n        updateInd(1, 1, n, i, x);\n    }\n};\n\nstruct SegTreeMax{\n    int n;\n    vector<int> t, lazy;\n    SegTreeMax(int N){\n        n = N;\n        t.resize(n<<2, -INF);\n        lazy.resize(n<<2);\n    }\n \n    void push(int v, int tl, int tr){\n        if(!lazy[v]) return;\n        t[v] += lazy[v];\n        if(tl != tr){\n            lazy[v*2] += lazy[v];\n            lazy[v*2+1] += lazy[v];\n        }\n        lazy[v] = 0;\n    }\n \n    void updateRange(int v, int tl, int tr, int l, int r, int x){\n        push(v, tl, tr);\n        if(tl > r || tr < l) return;\n        if(tl >= l && tr <= r){\n            t[v] += x;\n            if(tl != tr){\n                lazy[v*2] += x;\n                lazy[v*2+1] += x;\n            }\n            return; \n        }\n        int tm = (tl + tr)>>1;\n        updateRange(v*2, tl, tm, l, r, x);\n        updateRange(v*2+1, tm+1, tr, l, r, x);\n        t[v] = max(t[v*2], t[v*2+1]);\n    }\n    void updateRange(int l, int r, int x){\n        updateRange(1, 1, n, l, r, x);\n    }\n \n    int query(int v, int tl, int tr, int l, int r){\n        push(v, tl, tr);\n        if(tl > r || tr < l) return -INF;\n        if(tl >= l && tr <= r){\n            return t[v];\n        }\n        int tm = (tl + tr)>>1;\n        return max(query(v*2, tl, tm, l, r), query(v*2+1, tm+1, tr, l, r));\n    }\n    \n    int query(int l, int r){\n        return query(1, 1, n, l, r);\n    }\n \n    void updateInd(int v, int tl, int tr, int i, int x){\n        push(v, tl, tr);\n        if(tl == tr){\n            t[v] = x;\n            return;\n        }\n        int tm = (tl + tr)>>1;\n        if(i <= tm) updateInd(v*2, tl, tm, i, x);\n        else updateInd(v*2+1, tm+1, tr, i, x);\n        t[v] = max(t[v*2], t[v*2+1]);\n    }\n \n    void updateInd(int i, int x){\n        updateInd(1, 1, n, i, x);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& q) {\n        S dist(n);\n        for(int i = 1; i <= n; i++){\n            dist.updateInd(i, i-1);\n        }\n        \n        SegTreeMax t(n);\n        \n        vector<int> res;\n        vector<int> st(n+1, 0), en(n+1, n);\n        for(auto & vec : q){\n            int u = vec[0] + 1, v = vec[1] + 1;\n            int du = dist.query(u, u);\n            int dv = dist.query(v, v);\n            \n            int mx = t.query(1, u);\n            if(mx > v){\n                res.push_back(dist.query(n, n));\n                continue;\n            }\n            \n            if(du < dv){\n                int d = dv - du - 1;\n                dist.updateRange(v, n, -d);\n            }\n            res.push_back(dist.query(n, n));\n            t.updateInd(u, v);\n        }\n        \n        return res;\n    }\n};",
    "submit_ts": "1722741397",
    "subm_id": "1343744031"
}