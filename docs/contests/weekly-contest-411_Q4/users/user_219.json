{
    "username": "Xiaoyu Wang",
    "submission": "class Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        left = [0] * len(s) # left[j] = i means i is the leftmost position where s[i:j] satisfy k-constraint.\n        values = []\n        \n        n = len(s)\n        count_zeros = 0\n        count_ones = 0\n        i = 0\n\n        for j in range(n):\n            if s[j] == '0':\n                count_zeros += 1\n            else:\n                count_ones += 1\n\n            while count_zeros > k and count_ones > k:\n                if s[i] == '0':\n                    count_zeros -= 1\n                else:\n                    count_ones -= 1\n                i += 1\n\n            # All substrings ending at `j` and starting from any `i` to `j` are valid.\n            left[j] = i\n            cnt = j - i + 1\n            values.append(cnt)\n        \n        # left must be monolitically increasing.\n        #print(left)\n        \n        # calculate presum of left\n        ps = [0]\n        for i in range(len(values)):\n            ps.append(ps[-1] + values[i])\n            \n        #print(values)\n            \n        #print(ps)\n        \n        # for every query, find the position k in [l:r) where left[k] >= l\n        # then for [l:k), every index starts from l\n        # for [k+1:r), every index remain unchanged and thus can calculate from ps.\n        \n        res = []\n        \n        for l, r in queries:\n            r += 1 # realized the problem was right inclusive\n            k = min(r, bisect.bisect(left, l))\n            pre = k - l\n            presum = pre * (pre+1) // 2\n            aftersum = ps[r] - ps[k]\n            \n            #print(k, pre, presum, ps[r], ps[k], aftersum)\n            \n            res.append(presum + aftersum)\n        \n        return res\n    ",
    "submit_ts": "1723951289",
    "subm_id": "1359767906"
}