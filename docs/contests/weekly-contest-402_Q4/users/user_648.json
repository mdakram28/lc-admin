{
    "username": "AyushDixit21",
    "submission": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define ff first\n#define ss second\n#define mp make_pair\n#define ll long long\n#define ld long double\n#define rep(i, n) for (ll i = 0; i < n; i++)\n#define rev(i, n) for (ll i = n; i >= 0; i--)\n#define rep_a(i, a, n) for (ll i = a; i < n; i++)\n#define pb push_back\n#define all(_obj) _obj.begin(), _obj.end()\n#define pll pair<ll, ll>\n#define vll vector<int>\n#define vvll vector<vll>\n#define vpll vector<pll>\n#define yes cout << \"YES\" << endl\n#define no cout << \"NO\" << endl\n#define pc(n) __builtin_popcountll(n)\n#define endl \"\\n\"\ntemplate <class T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <class T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\nconst ll mod = 1e9 + 7, inf = LONG_LONG_MAX;\n\n// code generated by ChatGPT\n//  Segment Tree class to find the number of peak elements in a given range\n\nclass SegmentTree\n{\npublic:\n    vector<int> tree;\n    vector<int> nums;\n    int n;\n\n    bool isPeak(int i)\n    {\n        if (i <= 0 || i >= n - 1)\n            return false;\n        return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    }\n\n    void build(int node, int start, int end)\n    {\n        if (start == end)\n        {\n            tree[node] = isPeak(start) ? 1 : 0;\n        }\n        else\n        {\n            int mid = (start + end) / 2;\n            build(2 * node + 1, start, mid);\n            build(2 * node + 2, mid + 1, end);\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n        }\n    }\n\n    void update(int node, int start, int end, int idx)\n    {\n        if (start == end)\n        {\n            tree[node] = isPeak(start) ? 1 : 0;\n        }\n        else\n        {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid)\n            {\n                update(2 * node + 1, start, mid, idx);\n            }\n            else\n            {\n                update(2 * node + 2, mid + 1, end, idx);\n            }\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n        }\n    }\n\n    int query(int node, int start, int end, int l, int r)\n    {\n        if (r < start || end < l)\n        {\n            return 0;\n        }\n        if (l <= start && end <= r)\n        {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int leftQuery = query(2 * node + 1, start, mid, l, r);\n        int rightQuery = query(2 * node + 2, mid + 1, end, l, r);\n        return leftQuery + rightQuery;\n    }\n\n    SegmentTree(const vector<int> &nums) : nums(nums)\n    {\n        n = nums.size();\n        tree.resize(4 * n);\n        build(0, 0, n - 1);\n    }\n\n    void update(int idx, int val)\n    {\n        nums[idx] = val;\n        if (idx > 0)\n            update(0, 0, n - 1, idx - 1);\n        update(0, 0, n - 1, idx);\n        if (idx < n - 1)\n            update(0, 0, n - 1, idx + 1);\n    }\n\n    int query(int l, int r)\n    {\n        if (l >= r)\n            return 0;\n        return query(0, 0, n - 1, l + 1, r - 1);\n    }\n};\n\nclass Solution\n{\npublic:\n    vector<int> countOfPeaks(vector<int> &a, vector<vector<int>> &q)\n    {\n        SegmentTree st(a);\n        vector<int> ans;\n        rep(i, q.size())\n        {\n            if (q[i][0] == 2)\n                st.update(q[i][1], q[i][2]);\n            else\n                ans.push_back(st.query(q[i][1], q[i][2]));\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718506372.0
}