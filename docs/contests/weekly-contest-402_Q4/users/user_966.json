{
    "username": "JJZin",
    "submission": "\nclass Node:\n    def __init__(self, left = None, right = None, peaks = 0, leftIndex = None, rightIndex = None):\n        self.left = left\n        self.right = right\n        self.peaks = peaks\n        self.leftIndex = leftIndex\n        self.rightIndex = rightIndex\n    \n    \n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        \n        def printNodes(thee):\n            if not thee.left and not thee.right:\n                return\n            \n            print(f'{thee.leftIndex}-{thee.rightIndex} val {thee.peaks}')\n            \n            printNodes(thee.left)\n            printNodes(thee.right)\n        def refactorTree(idx, val, thee):\n            \n\n            \n            if not thee:\n                return \n            if thee.leftIndex > idx or thee.rightIndex < idx:\n                return \n            # print(f'{thee.leftIndex}-{thee.rightIndex} val {thee.peaks}', idx, val)\n\n            \n            \n            thee.peaks += val\n            refactorTree(idx, val, thee.left)\n            refactorTree(idx, val, thee.right)\n            \n            \n            \n            \n            \n            \n        def generateTree(left, right):\n            \n            if left == right:\n                ans = 0\n                if left >= 1 and right < len(nums) - 1:\n                    if nums[left] > nums[left - 1] and nums[left] > nums[left + 1]:\n                        ans += 1\n                        \n                anz = Node(None, None, ans, left, right)\n                \n                return anz\n            if left > right:\n                return None\n            basis = Node()\n            basis.leftIndex = left\n            basis.rightIndex = right\n            \n            mid = 1 + ((left + right) >> 1)\n            left = generateTree(left, mid - 1)\n            right = generateTree(mid, right)\n            basis.left = left\n            basis.right = right\n            basis.peaks = left.peaks + right.peaks\n            \n            \n            return basis\n        thee = generateTree(0, len(nums) - 1)\n        ans = []\n        \n        def queer(left, right, thee):\n            mid = 1 + ((left + right) >> 1)\n            \n            if not thee:\n                return 0\n            \n            if thee.leftIndex > right:\n                return 0\n            \n            if thee.rightIndex < left:\n                return 0\n            \n            if thee.leftIndex >= left and thee.rightIndex <= right:\n                return thee.peaks\n            \n            return queer(left, right, thee.left) + queer(left, right, thee.right)\n            \n            \n    \n            \n            \n            \n        def isPeak(idx):\n            if idx == 0 or idx >= len(nums) - 1:\n                return False\n            return nums[idx] > nums[idx - 1] and nums[idx] > nums[idx + 1]\n        for ea in queries:\n            # printNodes(thee)\n            \n            if ea[0] == 1:\n                ans.append(queer(ea[1] + 1, ea[2] - 1, thee))\n            else:\n                pre = [int(isPeak(ea[1] - 1)), int(isPeak(ea[1])),int(isPeak(ea[1] + 1))]\n                nums[ea[1]] = ea[2]\n                post = [int(isPeak(ea[1] - 1)),int(isPeak(ea[1])), int(isPeak(ea[1] + 1))]\n                \n              \n                    \n                base = ea[1]\n                for ean in range(-1, 2):\n                    refactorTree(base + ean, post[ean + 1] - pre[ean + 1], thee)\n                    \n               \n                \n        return ans\n        \n        \n        \n        \n        \n        \n        \n        \n        ",
    "submit_ts": 1718508607.0
}