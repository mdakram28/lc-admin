{
    "username": "sgdfbahjbhbaisdufg",
    "submission": "#define ll long long\n#define MOD 1000000007\n\nstruct SegTreeNode {\n    int l, r;\n    array<ll, 4> dp { 0, 0, 0, 0 };\n    // int val = 0;\n    SegTreeNode *lnode, *rnode;\n    \n    SegTreeNode(int l, int r) : l(l), r(r), lnode(nullptr), rnode(nullptr) {\n        assert( l <= r );\n        int mid = l + (r - l) / 2;\n        if (l != r) {\n            lnode = new SegTreeNode(l, mid);\n            rnode = new SegTreeNode(mid + 1, r);\n        }\n    }\n    \n    array<ll, 4> Query(int qleft, int qright) {\n        assert( qleft <= qright );\n        \n        if (qright < l || r < qleft) {\n            return { 0, 0, 0, 0 };\n        }\n        \n        if (qleft <= l && r <= qright) {\n            return dp;\n        }\n        \n        assert( l < r );\n        array<ll, 4> left = lnode->Query(qleft, qright), right = rnode->Query(qleft, qright);\n        array<ll, 4> res;\n        for (int mask = 0; mask < 4; ++mask) {\n            res[mask] = max(left[mask | 0b01] + right[mask], left[mask] + right[mask | 0b10]);\n        }\n        // int ret = lnode->Query(qleft, qright) + rnode->Query(qleft, qright);\n        return res;\n    }\n    \n    void Update(int q, ll newval) {\n        assert( l <= q && q <= r );\n        // sum += delta;\n        if (l != r) {\n            if (q <= lnode->r) {\n                lnode->Update(q, newval);\n            } else {\n                rnode->Update(q, newval);\n            }\n            dp[0b00] = max({ 0LL, lnode->dp[0b01] + rnode->dp[0b00], lnode->dp[0b00] + rnode->dp[0b10] });\n            dp[0b01] = max({ 0LL, lnode->dp[0b01] + rnode->dp[0b01], lnode->dp[0b00] + rnode->dp[0b11] });\n            dp[0b10] = max({ 0LL, lnode->dp[0b11] + rnode->dp[0b00], lnode->dp[0b10] + rnode->dp[0b10] });\n            dp[0b11] = max({ 0LL, lnode->dp[0b11] + rnode->dp[0b01], lnode->dp[0b10] + rnode->dp[0b11] });\n            // for (int mask = 0; mask < 4; ++mask) {\n            //     dp[mask] = max({ 0LL, lnode->dp[mask | 0b01] + rnode->dp[mask], lnode->dp[mask] + rnode->dp[mask | 0b10] });\n            // }\n        } else {\n            dp[0b00] = max(0LL, newval);\n            dp[0b01] = 0;\n            dp[0b10] = 0;\n            dp[0b11] = 0;\n        }\n        // printf(\"Update result [%d %d] %ld %ld %ld %ld\\n\", l, r, dp[0], dp[1], dp[2], dp[3]);\n    }\n    \n    void Print() {\n        if (l == r) {\n            printf(\"%d: %ld %ld %ld %ld\\n\", l, dp[0], dp[1], dp[2], dp[3]);\n        } else {\n            lnode->Print();\n            rnode->Print();\n        }\n    }\n};\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        SegTreeNode st(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            st.Update(i, nums[i]);\n        }\n        // st.Print();\n        // printf(\"\\n\");\n        ll ans = 0;\n        for (vector<int>& q : queries) {\n            st.Update(q[0], q[1]);\n        //     st.Print();\n        // printf(\"\\n\");\n            ll curr = st.dp[0];\n            ans = (ans + (curr % MOD)) % MOD;\n\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716694236.0
}