{
    "username": "iusecookies64",
    "submission": "void build(int node, int l, int r, vector<int> &tree, vector<int> &arr)\n{\n    // base case\n    if (l == r)\n    {\n        tree[node] = arr[l];\n        return;\n    }\n\n    int mid = (l + r) / 2;\n\n    int left = 2 * node + 1, right = 2 * node + 2;\n\n    // calling for left child\n    build(left, l, mid, tree, arr);\n\n    // calling for right child\n    build(right, mid + 1, r, tree, arr);\n\n    // calculating value for current node\n    tree[node] = tree[left] + tree[right];\n}\n\nvoid update(int node, int l, int r, int updateIndx, int newValue, vector<int> &tree, vector<int>& arr)\n{\n    // base case\n    if (l == r)\n    {\n        tree[node] = newValue;\n        arr[l] = newValue;\n        return;\n    }\n\n    int mid = (l + r) / 2;\n\n    int left = 2*node+1, right = 2*node+2;\n\n    // calling for left child if it is on the path\n    if (updateIndx <= mid)\n        update(left, l, mid, updateIndx, newValue, tree, arr);\n\n    // calling for right child if it is on the path\n    if (updateIndx > mid)\n        update(right, mid + 1, r, updateIndx, newValue, tree, arr);\n\n    // updating value for current node\n    tree[node] = tree[left] + tree[right];\n}\n\nint rangeQuery(int node, int l, int r, int qs, int qe, vector<int> &tree)\n{\n    if (qs <= l && r <= qe)\n        return tree[node]; // full overlap\n\n    if (r < qs || qe < l)\n        return 0; // not overlap\n\n    // case of partial overlap\n    int mid = (l + r) / 2;\n\n    int left = 2*node + 1, right = 2 * node+2;\n\n    return rangeQuery(left, l, mid, qs, qe, tree) + rangeQuery(right, mid + 1, r, qs, qe, tree);\n}\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> arr(n);\n        for(int i = 1; i < n-1; i++)\n        {\n            if(nums[i-1] < nums[i] && nums[i] > nums[i+1]) arr[i] = 1;\n        }\n        vector<int> tree(4 * n);\n        build(0, 0, n-1, tree, arr);\n        vector<int> res;\n        // for(int i = 0; i < n; i++) cout << arr[i] << ' ';\n        // cout << endl;\n        for(auto &v : queries)\n        {\n            if(v[0] == 1)\n            {\n                int l = v[1], r = v[2];\n                if(r - l - 1 > 0)\n                {\n                    res.push_back(rangeQuery(0, 0, n-1, l+1, r-1, tree));   \n                }\n                else\n                {\n                    res.push_back(0);\n                }\n            }\n            else\n            {\n                int indx = v[1], val = v[2];\n                nums[indx] = val;\n                for(int i = max(indx - 1, 1); i <= min(indx+1, n-2); i++)\n                {\n                    int ispeak = 1;\n                    if(nums[i-1] >= nums[i]) ispeak = 0;\n                    if(nums[i+1] >= nums[i]) ispeak = 0;\n                    if(ispeak == arr[i]) continue;\n                    update(0, 0, n-1, i, ispeak, tree, arr);\n                }\n            }\n            // for(int i = 0; i < n; i++) cout << arr[i] << ' ';\n            // cout << endl;\n        }\n        return res;\n    }\n};",
    "submit_ts": 1718508452.0
}