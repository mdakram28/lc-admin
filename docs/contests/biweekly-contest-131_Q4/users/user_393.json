{
    "username": "TragicBytes",
    "submission": "struct SegmentTreeNode {\n    long long total, maxPrefix, maxSuffix, maxSum;\n};\n\nclass SegmentTree {\npublic:\n    SegmentTree(const vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        build(arr, 0, 0, n - 1);\n    }\n\n    SegmentTreeNode query(int l, int r) {\n        return query(0, 0, n - 1, l, r);\n    }\n\n    void update(int index, int value) {\n        update(0, 0, n - 1, index, value);\n    }\n\nprivate:\n    int n;\n    vector<SegmentTreeNode> tree;\n\n    void build(const vector<int>& arr, int node, int start, int end) {\n        if (start == end) {\n            long long val = arr[start];\n            tree[node] = {val, val, val, val};\n        } else {\n            int mid = (start + end) / 2;\n            build(arr, 2 * node + 1, start, mid);\n            build(arr, 2 * node + 2, mid + 1, end);\n            tree[node] = merge(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    SegmentTreeNode query(int node, int start, int end, int l, int r) {\n        if (r < start || end < l) {\n            return {0, INT_MIN, INT_MIN, INT_MIN};\n        }\n        if (l <= start && end <= r) {\n            return tree[node];\n        }\n\n        int mid = (start + end) / 2;\n        SegmentTreeNode left = query(2 * node + 1, start, mid, l, r);\n        SegmentTreeNode right = query(2 * node + 2, mid + 1, end, l, r);\n        return merge(left, right);\n    }\n\n    void update(int node, int start, int end, int index, int value) {\n        if (start == end) {\n            tree[node] = {value, value, value, value};\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= index && index <= mid) {\n                update(2 * node + 1, start, mid, index, value);\n            } else {\n                update(2 * node + 2, mid + 1, end, index, value);\n            }\n            tree[node] = merge(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    SegmentTreeNode merge(SegmentTreeNode left, SegmentTreeNode right) {\n        SegmentTreeNode result;\n        result.total = left.total + right.total;\n        result.maxPrefix = max(left.maxPrefix, left.total + right.maxPrefix);\n        result.maxSuffix = max(right.maxSuffix, right.total + left.maxSuffix);\n        result.maxSum = max(max(left.maxSum, right.maxSum), left.maxSuffix + right.maxPrefix);\n        return result;\n    }\n};\n\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int q=queries.size();\n        q=min((int)5e4,3*q)+1;\n        vector<int> arr(q,1);\n        arr[0]=0;\n        vector<bool> ans;\n        SegmentTree st(arr);\n        for(auto it:queries){\n            if(it[0]==1){\n                st.update(it[1],-5e5);\n            }else{\n                SegmentTreeNode maxi=st.query(0,it[1]-1);\n                cout<<maxi.maxSum+1<<endl;\n                if(maxi.maxSum+1<it[2])ans.push_back(false);\n                else ans.push_back(true);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1716652640",
    "subm_id": "1267668233"
}