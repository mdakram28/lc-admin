{
    "username": "bhaskar_op",
    "submission": "#define INF INT_MAX\n\nclass SegmentTree {\npublic:\n    vector<int> tree;\n    int n;\n\n    SegmentTree(vector<int>& arr){\n        n=arr.size();\n        tree.resize(4*n);\n        build(arr,0,0,n-1);\n    }\n\n\n    void build(vector<int>& arr, int node, int start, int end){\n        if (start==end) {\n            tree[node]=arr[start];\n        }else {\n            int mid=(start+end)/2;\n            build(arr,2*node+1,start,mid);\n            build(arr,2*node+2,mid+1,end);\n\n            tree[node]=(tree[2*node+1] & tree[2*node+2]);\n        }\n    }\n\n    int get_ans(int l, int r){\n        return query(0,0,n-1,l,r);\n    }\n\n    int query(int node, int start, int end, int l, int r)\n    {\n        if(r<start || end<l) return INF;\n\n        if(l<=start && end<=r) {\n            return tree[node];\n        }\n        \n        int mid=(start+end)/2;\n        int and_left=query(2*node+1,start,mid,l,r);\n        int and_right=query(2*node+2,mid+1,end,l,r);\n\n        return (and_left & and_right);\n    }\n};\n\nint closestAND(vector<int> arr, int k){\n    int n=arr.size();\n    SegmentTree st(arr);\n    int ans=INF;\n    \n    for (int i=0; i<n; i++) {\n        int l=i-1, r=n-1;\n        while(r-l>1) {\n            int mid=(l+r)/2;\n            if(st.get_ans(i, mid)>=k) l=mid;\n            else r=mid;\n        }\n        if(l!=i-1) ans=min(ans,abs(st.get_ans(i,l) -k));\n        ans=min(ans,abs(k-st.get_ans(i,r)));\n    }\n    \n    return ans;\n}\n\nclass Solution {\nint n, k;\nvector<int> v;\nunordered_map<int,unordered_map<int,int>> dp;\n    \nprivate:\n    int ex(int i, int AND){\n        if(i==n){\n            if(AND==-1) return 1e9+1;\n            return abs(AND-k);\n        }\n        \n        if(dp.find(i)!=dp.end() && dp[i].find(AND)!=dp[i].end()){\n            return dp[i][AND];\n        }\n        \n        int take=1e9+1, skip=1e9+1, start_from_there=1e9+1;\n        if(AND==-1){\n            take=ex(i+1,v[i]);\n        }else{\n            take=ex(i+1,(v[i]&AND));\n        }\n        \n        if(AND==-1){\n            skip=ex(i+1,-1);\n        }else{\n            skip=min(abs(AND-k),ex(i+1,-1));\n        }\n        \n        if(AND==-1){\n            start_from_there=ex(i+1,v[i]);\n        }else{\n            start_from_there=min(abs(AND-k),ex(i+1,v[i]));\n        }\n        \n        return dp[i][AND]=min({take,skip,start_from_there});\n    }\n    \npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        this->n=nums.size();\n        this->v=nums;\n        this->k=k;\n        \n        return closestAND(nums,k);\n    }\n};",
    "submit_ts": "1717298283",
    "subm_id": "1274773550"
}