{
    "username": "pratik_8696",
    "submission": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <complex>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <list>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <iomanip>\n#include <fstream>\n \nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\n// use less_equal to make it multiset\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> p32;\ntypedef pair<ll, ll> p64;\ntypedef pair<double, double> pdd;\ntypedef vector<ll> v64;\ntypedef vector<int> v32;\ntypedef vector<vector<int>> vv32;\ntypedef vector<vector<ll>> vv64;\ntypedef vector<vector<p64>> vvp64;\ntypedef vector<p64> vp64;\ntypedef vector<p32> vp32;\ntypedef vector<pair<p64, ll>> vpp64;\ntypedef set<ll> s64;\ntypedef set<p64> sp64;\ntypedef multiset<ll> ms64;\ntypedef multiset<p64> msp64;\ntypedef map<ll, ll> m64;\ntypedef map<ll, v64> mv64;\ntypedef unordered_map<ll, v64> uv64;\ntypedef unordered_map<ll, ll> u64;\ntypedef unordered_map<p64, ll> up64;\ntypedef unordered_map<ll, vp64> uvp64;\ntypedef priority_queue<ll> pq64;\ntypedef priority_queue<ll, v64, greater<ll>> pqs64;\nconst int MOD = 1000000007;\ndouble eps = 1e-12;\n#define forn(i, n) for (ll i = 0; i < n; i++)\n#define forsn(i, s, e) for (ll i = s; i < e; i++)\n#define rforn(i, s) for (ll i = s; i >= 0; i--)\n#define rforsn(i, s, e) for (ll i = s; i >= e; i--)\nstruct custom_hash\n{\n    static uint64_t splitmix64(uint64_t x)\n    {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n \n    size_t operator()(p64 x) const\n    {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x.first + FIXED_RANDOM) ^ splitmix64(x.second + FIXED_RANDOM);\n    }\n    size_t operator()(ll x) const\n    {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\ntypedef gp_hash_table<ll, ll, custom_hash> fm64;\ntypedef gp_hash_table<p64, ll, custom_hash> fmp64;\n \n#define ln \"\\n\"\n#define mp make_pair\n#define ie insert\n#define pb push_back\n#define fi first\n#define se second\n#define INF 2e14\n#define fast_cin()                    \\\n    ios_base::sync_with_stdio(false); \\\n    cin.tie(NULL);                    \\\n    cout.tie(NULL)\n#define all(x) (x).begin(), (x).end()\n#define al(arr, n) arr, arr + n\n#define sz(x) ((ll)(x).size())\n#define dbg(a) cout << a << endl;\n#define dbg2(a) cout << a << ' ';\nusing ld = long double;\nusing db = double;\nusing str = string; // yay python!\n// INPUT\n#define tcT template <class T\n#define tcTU tcT, class U\n#define tcTUU tcT, class... U\ntcT > void re(T &x)\n{\n    cin >> x;\n}\ntcTUU > void re(T &t, U &...u)\n{\n    re(t);\n    re(u...);\n}\n \nint find_set(int v, v64 &parent)\n{\n    if (-1 == parent[v])\n        return v;\n    return parent[v] = find_set(parent[v], parent);\n}\n \nvoid union_sets(int a, int b, v64 &parent)\n{\n    a = find_set(a, parent);\n    b = find_set(b, parent);\n    if (a != b)\n        parent[b] = a;\n}\n \n// function for prime factorization\nvector<pair<ll, ll>> pf(ll n)\n{\n    vector<pair<ll, ll>> prime;\n    for (int i = 2; i <= sqrt(n); i++)\n    {\n        if (n % i == 0)\n        {\n            int count = 0;\n            while (n % i == 0)\n            {\n                count++;\n                n = n / i;\n            }\n            prime.pb(mp(i, count));\n        }\n    }\n    if (n > 1)\n    {\n        prime.pb(mp(n, 1));\n    }\n    return prime;\n}\n \n// sum of digits of a number\nll sumofno(ll n)\n{\n    ll sum = 0;\n    while (n != 0)\n    {\n        sum += n % 10;\n        n = n / 10;\n    }\n    return sum;\n}\n \n// modular exponentiation\nlong long modpow(long long x, long long n, long long p)\n{\n \n    if (n == 0)\n        return 1 % p;\n \n    ll ans = 1, base = x;\n    while (n > 0)\n    {\n        if (n % 2 == 1)\n        {\n            ans = (ans * base) % p;\n            n--;\n        }\n        else\n        {\n            base = (base * base) % p;\n            n /= 2;\n        }\n    }\n    if (ans < 0)\n        ans = (ans + p) % p;\n    return ans;\n}\n \n// const int N = 1e6 + 100;\n// long long fact[N];\n//  initialise the factorial\n// void initfact(){\n// fact[0] = 1;\n// for (int i = 1; i < N; i++)\n//{\n// fact[i] = (fact[i - 1] * i);\n// fact[i] %= MOD;\n// }}\n \n// formula for c\n// ll C(ll n, ll i)\n//{\n// ll res = fact[n];\n// ll div = fact[n - i] * fact[i];\n// div %= MOD;\n// div = modpow(div, MOD - 2, MOD);\n// return (res * div) % MOD;\n// }\n \nlong long CW(ll n, ll m)\n{\n    if (m > n - m)\n        m = n - m;\n    long long ans = 1;\n    for (int i = 0; i < m; i++)\n    {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n \n// function for fast expo\nll fastexpo(ll a, ll b)\n{\n    if (b == 0)\n    {\n        return 1;\n    }\n    if (a == 0)\n    {\n        return 0;\n    }\n    ll y = fastexpo(a, b / 2);\n    if (b % 2 == 0)\n    {\n        return y * y;\n    }\n    else\n    {\n        return a * y * y;\n    }\n}\n \nll popcount(ll n)\n{\n    ll c = 0;\n    for (; n; ++c)\n        n &= n - 1;\n    return c;\n}\n \nll ce(ll x, ll y)\n{\n    ll res = x / y;\n    if (x % y != 0)\n    {\n        res++;\n    }\n    return res;\n}\n \nbool pow2(ll x)\n{\n    ll res = x & (x - 1);\n    if (res == 0)\n    {\n        return true;\n    }\n    return false;\n}\n \nbool isPrime(int x)\n{\n    for (int d = 2; d * d <= x; d++)\n    {\n        if (x % d == 0)\n            return false;\n    }\n    return true;\n}\n \nstruct node\n{\n    ll maxx_seg;\n    ll sum;\n    ll prefix;\n    ll suffix;\n    node operator+(node b)\n    {\n        node a;\n        a.maxx_seg = max({this->maxx_seg, b.maxx_seg, this->suffix + b.prefix});\n        a.prefix = max(this->prefix, this->sum + b.prefix);\n        a.suffix = max(this->suffix + b.sum, b.suffix);\n        a.sum = this->sum + b.sum;\n        return a;\n    }\n};\n \nvoid build(int arr[], node tree[], ll s, ll e, ll tn)\n{\n    if (s == e)\n    {\n        tree[tn].sum = arr[s];\n        tree[tn].suffix = arr[s];\n        tree[tn].prefix = arr[s];\n        tree[tn].maxx_seg = arr[s];\n        return;\n    }\n    int mid = (s + e) / 2;\n    build(arr, tree, s, mid, 2 * tn);\n    build(arr, tree, mid + 1, e, (2 * tn) + 1);\n    tree[tn] = tree[2 * tn] + tree[(2 * tn) + 1];\n}\n \nnode query(int arr[], node tree[], ll s, ll e, ll tn, ll l, ll r)\n{\n    int mid = (s + e) / 2;\n    // out\n    if (s > r || l > e)\n    {\n        node a;\n        a.maxx_seg = -1e5, a.prefix = -1e5, a.suffix = -1e5, a.sum = -1e5;\n        return a;\n    }\n    // in\n    if (s >= l && r >= e)\n    {\n        return tree[tn];\n    }\n \n    node ans1 = query(arr, tree, s, mid, 2 * tn, l, r);\n    node ans2 = query(arr, tree, mid + 1, e, (2 * tn) + 1, l, r);\n    return ans1 + ans2;\n}\n \nvoid update(int arr[], node tree[], ll s, ll e, ll tn, ll idx, ll val)\n{\n    if (s == e)\n    {\n        arr[idx] = val;\n        tree[tn].sum = arr[idx];\n        tree[tn].suffix = arr[idx];\n        tree[tn].prefix = arr[idx];\n        tree[tn].maxx_seg = arr[idx];\n        return;\n    }\n    ll mid = (s + e) / 2;\n    if (idx > mid)\n    {\n        update(arr, tree, mid + 1, e, (2 * tn) + 1, idx, val);\n    }\n    else\n    {\n        update(arr, tree, s, mid, 2 * tn, idx, val);\n    }\n    tree[tn] = tree[2 * tn] + tree[(2 * tn) + 1];\n}\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int n=0;\n        for(auto t:queries)\n        {\n            n=max(t[1],n);   \n        }\n        n+=10;\n        int arr[n];\n        node tree[4*n];\n        for(int i=0;i<n;i++)\n        {\n            arr[i]=1;\n        }\n        // arr[0]=0;\n        build(arr,tree,0,n-1,1);\n        vector<bool> ans;\n        for(auto t:queries)\n        {\n            int type=t[0];\n            if(type==1)\n            {\n                update(arr,tree,0,n-1,1,t[1],-1e5);\n            }\n            else\n            {\n                int sizee=t[2];\n                int index=t[1];\n                // agr zero se start hokr aa rha hai then \n                int largest_with_noends = 0;\n                int largest_with_origin = query(arr,tree,0,n-1,1,0,index-1).maxx_seg;\n                int largest_with_ends = query(arr,tree,0,n-1,1,1,index).maxx_seg;\n                if(index>=2) {\n                    largest_with_noends = query(arr,tree,0,n-1,1,1,index-1).maxx_seg + 1;\n                }\n                int largest = max({largest_with_noends,largest_with_ends,largest_with_origin});\n                ans.push_back((largest>=sizee?1:0));\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716650280.0
}