{
    "username": "James Lew",
    "submission": "class SegmentTree {\nprivate:\n    int n;\n    vector<long long> tree, lazy;\n\n    void build(vector<int>& arr, int v, int tl, int tr) {\n        if (tl == tr) {\n            tree[v] = arr[tl];\n        } else {\n            int tm = (tl + tr) / 2;\n            build(arr, v * 2, tl, tm);\n            build(arr, v * 2 + 1, tm + 1, tr);\n            tree[v] = tree[v * 2] + tree[v * 2 + 1];\n        }\n    }\n\n    void push(int v, int tl, int tr) {\n        if (lazy[v] != 0) {\n            tree[v] += lazy[v] * (tr - tl + 1);\n            if (tl != tr) {\n                lazy[v * 2] += lazy[v];\n                lazy[v * 2 + 1] += lazy[v];\n            }\n            lazy[v] = 0;\n        }\n    }\n\n    void update(int v, int tl, int tr, int l, int r, int addend) {\n        push(v, tl, tr);\n        if (l > r)\n            return;\n        if (l == tl && r == tr) {\n            lazy[v] += addend;\n            push(v, tl, tr);\n        } else {\n            int tm = (tl + tr) / 2;\n            update(v * 2, tl, tm, l, min(r, tm), addend);\n            update(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, addend);\n            tree[v] = tree[v * 2] + tree[v * 2 + 1];\n        }\n    }\n\n    long long query(int v, int tl, int tr, int l, int r) {\n        push(v, tl, tr);\n        if (l > r)\n            return 0;\n        if (l == tl && r == tr) {\n            return tree[v];\n        } else {\n            int tm = (tl + tr) / 2;\n            return query(v * 2, tl, tm, l, min(r, tm))\n                 + query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);\n        }\n    }\n\npublic:\n    SegmentTree(vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n, 0);\n        lazy.resize(4 * n, 0);\n        build(arr, 1, 0, n - 1);\n    }\n\n    void update(int l, int r, int addend) {\n        update(1, 0, n - 1, l, r, addend);\n    }\n\n    long long query(int l, int r) {\n        return query(1, 0, n - 1, l, r);\n    }\n};\n\n// int main() {\n//     vector<int> arr = {1, 3, 5, 7, 9, 11};\n//     SegmentTree st(arr);\n\n//     cout << \"Sum of range (0, 2): \" << st.sumRange(0, 2) << endl;\n//     st.updateRange(1, 3, 10);\n//     cout << \"Sum of range (0, 2) after update: \" << st.sumRange(0, 2) << endl;\n//     cout << \"Sum of range (0, 5): \" << st.sumRange(0, 5) << endl;\n\n//     return 0;\n// }\n\nclass Solution {\npublic:\n    vector<long long> countKConstraintSubstrings(string s, int K, vector<vector<int>>& qs) {\n        const int n = s.size();\n        vector<array<int, 3>> queries;\n        for (int i=0; i<qs.size(); ++i) {\n            auto& x = qs[i];\n            queries.push_back({x[0], x[1], i});\n        }\n        sort(queries.begin(), queries.end(), [&](auto& a, auto& b) {\n            return a[1] < b[1];\n        });\n        vector<int> temp(n + 1);\n        SegmentTree st(temp);\n        vector<long long> ans(queries.size());\n        int k = 0;\n        int j1 = 0, ones1 = 0, zeros1 = 0;\n        int j2 = 0, ones2 = 0, zeros2 = 0;\n        for (int i=0; i<n; ++i) {\n            if (s[i] == '1') ++ones1, ++ones2;\n            else ++zeros1, ++zeros2;\n\n            while (j1 <= i && ones1 > K) {\n                if (s[j1] == '1') --ones1;\n                else --zeros1;\n                ++j1;\n            }\n\n            while (j2 <= i && zeros2 > K) {\n                if (s[j2] == '1') --ones2;\n                else --zeros2;\n                ++j2;\n            }\n            if (min(j1, j2) <= i) {\n                st.update(min(j1, j2), i, 1);\n            }\n            while (k < queries.size() && queries[k][1] <= i) {\n                ans[queries[k][2]] = st.query(queries[k][0], queries[k][1]);\n                ++k;\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1723950649",
    "subm_id": "1359751473"
}