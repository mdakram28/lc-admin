{
    "username": "TheCleanser",
    "submission": "typedef long long int ll; \ntypedef long double ld;\ntypedef pair<ll, ll> pl;\n\n#define N 200069 // 2e5 \n#define L 20\n//#define MOD 1000000007\n//#define MOD 998244353\n#define LLMX LONG_LONG_MAX\n#define LLMN LONG_LONG_MIN\n\n#define pb(i) push_back((i))\n#define mp(i, j) make_pair((i), (j))\n\n#define f(i, s, e, inc) for(ll i = (s); i < (e); i += (inc)) \n#define fd(i, s, e, dec) for(ll i = (s); i >= (e); i -= (dec))\n\n#define p(x) cout << x << '\\n'\n#define tf(x) cout << ((x) ? \"Yes\" : \"No\") << '\\n'\n\nclass Solution {\npublic:\nvector<ll> adj[N];\nbool vis[N];\nll activateTime[N];\nll dpDown[N];\nll dpUp[N];\n\nvoid dfs1(ll curr, ll parent)\n{\n    vis[curr] = true; \n\n    if(curr == 0) activateTime[curr] = 0;\n    else if(curr % 2 == 0) activateTime[curr] = activateTime[parent] + 2;\n    else activateTime[curr] = activateTime[parent] + 1;\n\n    dpDown[curr] = activateTime[curr];\n\n    for(auto it: adj[curr]){\n        if(!vis[it]){\n            dfs1(it, curr);\n            dpDown[curr] = max(dpDown[curr], dpDown[it]);\n        }\n    }\n}\n\nvoid dfs2(ll curr, ll parent)\n{\n    vis[curr] = true; \n\n    vector<pl> children;\n    // pair<dp[child], child>\n    for(auto it: adj[curr]){\n        if(it != parent){\n            children.pb(mp(dpDown[it], it));\n        }\n    }\n\n    sort(children.begin(), children.end());\n\n    for(auto it: children){\n        ll child = it.second;\n        ll highest = (children.size() == 1) \n            ? activateTime[curr]\n            : (\n                (child == children.back().second) \n                ? children[children.size() - 2].first: \n                children.back().first\n            );\n        \n        ll maxOtherChildTime = highest - activateTime[curr]; \n        ll actualTime = dpUp[curr]; // value assuming rooted at curr\n\n        ll mxTime = max(actualTime, maxOtherChildTime);\n        mxTime += (curr % 2 == 0) ? 2 : 1;\n        dpUp[child] = mxTime;\n    }\n\n    for(auto it: adj[curr]){\n        if(!vis[it]){\n            dfs2(it, curr);\n        }\n    }\n}\n    \nvoid pa(ll arr[], ll size)\n{ for(ll i = 0; i < size; i++) cout << arr[i] << \" \"; cout << '\\n'; }\n\n\n\nvector<int> timeTaken(vector<vector<int>>& edges) {\n    int n = edges.size() + 1;\n    for(auto it: edges){\n        int u = it[0];\n        int v = it[1];\n        adj[u].pb(v);\n        adj[v].pb(u);\n    }\n\n    dfs1(0, 0); fill(vis, vis + n, false);\n    dfs2(0, 0); fill(vis, vis + n, false);\n\n    vector<int> ans(n);\n\n    for(int i = 0; i < n; i++){\n        ans[i] = max(dpDown[i] - activateTime[i], dpUp[i]);\n    }\n    \n\n    for(int i = 0; i < n; i++){\n        dpDown[i] = 0;\n        dpUp[i] = 0;\n        adj[i].clear();\n        activateTime[i] = 0;\n    }\n\n    return ans;\n}\n\n};",
    "submit_ts": "1722699578",
    "subm_id": "1343215938"
}