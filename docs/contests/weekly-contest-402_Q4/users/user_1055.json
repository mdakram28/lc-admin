{
    "username": "vedant_laddha",
    "submission": "package main\n\nimport \"fmt\"\n\n// SegmentTree struct to manage peak counts\ntype SegmentTree struct {\n\ttree []int\n\tn    int\n}\n\n// NewSegmentTree creates a new SegmentTree\nfunc NewSegmentTree(nums []int) *SegmentTree {\n\tn := len(nums)\n\tsegTree := &SegmentTree{\n\t\ttree: make([]int, 4*n),\n\t\tn:    n,\n\t}\n\tsegTree.build(nums, 0, 0, n-1)\n\treturn segTree\n}\n\n// isPeak checks if a given index is a peak\nfunc isPeak(nums []int, i int) bool {\n\tif i <= 0 || i >= len(nums)-1 {\n\t\treturn false\n\t}\n\treturn nums[i] > nums[i-1] && nums[i] > nums[i+1]\n}\n\n// build constructs the SegmentTree\nfunc (st *SegmentTree) build(nums []int, node, start, end int) {\n\tif start == end {\n\t\tif isPeak(nums, start) {\n\t\t\tst.tree[node] = 1\n\t\t} else {\n\t\t\tst.tree[node] = 0\n\t\t}\n\t} else {\n\t\tmid := (start + end) / 2\n\t\tst.build(nums, 2*node+1, start, mid)\n\t\tst.build(nums, 2*node+2, mid+1, end)\n\t\tst.tree[node] = st.tree[2*node+1] + st.tree[2*node+2]\n\t}\n}\n\n// update updates the SegmentTree\nfunc (st *SegmentTree) update(nums []int, node, start, end, idx int) {\n\tif start == end {\n\t\tif isPeak(nums, idx) {\n\t\t\tst.tree[node] = 1\n\t\t} else {\n\t\t\tst.tree[node] = 0\n\t\t}\n\t} else {\n\t\tmid := (start + end) / 2\n\t\tif start <= idx && idx <= mid {\n\t\t\tst.update(nums, 2*node+1, start, mid, idx)\n\t\t} else {\n\t\t\tst.update(nums, 2*node+2, mid+1, end, idx)\n\t\t}\n\t\tst.tree[node] = st.tree[2*node+1] + st.tree[2*node+2]\n\t}\n}\n\n// query performs a range query in the SegmentTree\nfunc (st *SegmentTree) query(node, start, end, l, r int) int {\n\tif r < start || end < l {\n\t\treturn 0\n\t}\n\tif l <= start && end <= r {\n\t\treturn st.tree[node]\n\t}\n\tmid := (start + end) / 2\n\tleftQuery := st.query(2*node+1, start, mid, l, r)\n\trightQuery := st.query(2*node+2, mid+1, end, l, r)\n\treturn leftQuery + rightQuery\n}\n\n// Update updates the SegmentTree\nfunc (st *SegmentTree) Update(nums []int, idx int) {\n\tst.update(nums, 0, 0, st.n-1, idx)\n}\n\n// QueryCount performs a range query in the SegmentTree\nfunc (st *SegmentTree) QueryCount(l, r int) int {\n\treturn st.query(0, 0, st.n-1, l, r)\n}\n\nfunc countOfPeaks(nums []int, queries [][]int) []int {\n\tn := len(nums)\n\tresults := make([]int, 0)\n\tsegTree := NewSegmentTree(nums)\n\n\tfor _, query := range queries {\n\t\tif query[0] == 1 {\n\t\t\tl, r := query[1], query[2]\n\t\t\tresults = append(results, segTree.QueryCount(l+1, r-1))\n\t\t} else if query[0] == 2 {\n\t\t\tindex, val := query[1], query[2]\n\t\t\tnums[index] = val\n\t\t\tif index > 0 {\n\t\t\t\tsegTree.Update(nums, index-1)\n\t\t\t}\n\t\t\tsegTree.Update(nums, index)\n\t\t\tif index < n-1 {\n\t\t\t\tsegTree.Update(nums, index+1)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn results\n}",
    "submit_ts": "1718508512",
    "subm_id": "1289683405"
}