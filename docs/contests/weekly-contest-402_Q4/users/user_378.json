{
    "username": "sayakaFan",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n/**\n * author : daydayUppp\n *\n * \u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\uff08\u7ef4\u62a4\u6027\u8d28\u4e3a\u533a\u95f4 sum\uff09\n * \n * \u529f\u80fd :\n * 1. \u533a\u95f4\u66f4\u65b0 (Add) : [l,r,v] , \u533a\u95f4 val([l:r]) += v\n * 2. \u533a\u95f4\u67e5\u8be2 : [l,r] , \u533a\u95f4 [l:r] \u7684\u67d0\u79cd\u6027\u8d28\n * \n * \u6ce8\u610f\uff1a\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\u5982\u679c\u5b58\u5728\u8d1f\u533a\u95f4\uff0c\u5219\u9700\u8981\u91cd\u65b0\u505a\u6620\u5c04 (l, r) -> (l + N, r + N)\n *\n * */\nconst static int SZ = (int) 7e6;\nusing SMT = long long; // \u6ce8\u610f\u9700\u8981\u4e0e MT \u5bf9\u5e94\n// \u5206\u914d\u7684\u8282\u70b9\u7a7a\u95f4\nstruct Node {\n    int l, r; // \u8868\u793a [l:r] \u533a\u95f4\n    bool lazy; // \u61d2\u6807\u8bb0\n    SMT val; // \u5f53\u524d\u533a\u95f4\u7684\u61d2\u6807\u8bb0\u5bf9\u5e94\u7684\u503c\n    SMT tree; // \u5f53\u524d\u533a\u95f4\u67d0\u4e00\u79cd\u6027\u8d28\n    int lson, rson; // \u5de6\u53f3\u5b50\u6811\u7684\u5e8f\u53f7 0 \u8868\u793a\u7a7a\n} tn[SZ]; // tree node\ntemplate<typename MT>\nclass DST_ADD_SUM {\npublic:\n    int root_id; // \u6839\u8282\u70b9ID\n    int ori_l, ori_r; // [] \u539f\u59cb\u533a\u95f4\n    int cur_idx; // \u6bcf\u6b21\u4ece cur_idx \u5f00\u59cb\u5206\u914d\u5b50\u6811\u5e8f\u53f7\n\n    int build_subTree(int l_, int r_, bool lazy_ = false, MT val_ = 0) { // \u5206\u914d\u4e00\u4e2a\u5b50\u6811\n        tn[cur_idx].l = l_ , tn[cur_idx].r = r_;\n        tn[cur_idx].lson = 0 , tn[cur_idx].rson = 0;\n        tn[cur_idx].lazy = lazy_;\n        tn[cur_idx].val = val_;\n        tn[cur_idx].tree = (MT) (r_ - l_ + 1) * val_;\n        return cur_idx ++;\n    }\n\n    bool is_intersect(const int cl, const int cr, const int& tl, const int&  tr) { \n        // \u5224\u65ad [cl,cr] \u4e0e [tl,tr] \u662f\u5426\u6709\u91cd\u5408\n        if (cl > tr || cr < tl) return false;\n        return true;\n    }\n\n    void push_down(Node& root) { // \u4ece\u5f53\u524d\u8282\u70b9\u5f80\u4e0b\u4f20\u9012\u4fe1\u606f\n        root.lazy = false;\n        if (!root.lson) {\n            root.lson = build_subTree(root.l, (root.l + root.r) / 2, true, root.val);\n        } else {\n            tn[root.lson].val += root.val;\n            tn[root.lson].tree += (MT) root.val * ((root.l + root.r) / 2 - root.l + 1);\n            tn[root.lson].lazy = true;\n        }\n        if (!root.rson) {\n            root.rson = build_subTree((root.l + root.r) / 2 + 1, root.r, true, root.val);\n        } else {\n            tn[root.rson].val += root.val;\n            tn[root.rson].tree += (MT) root.val * (root.r - (root.l + root.r) / 2);\n            tn[root.rson].lazy = true;\n        }\n        root.val = 0;\n    }\n\n    void push_up(Node& root) { // \u4e24\u68f5\u5b50\u6811\u5f80\u4e0a\u4f20\u9012\u4fe1\u606f\n        root.tree = 0;\n        if (root.lson) root.tree += tn[root.lson].tree;\n        else root.tree += (MT) ((root.l + root.r) / 2 - root.l + 1) * root.val;\n        if (root.rson) root.tree += tn[root.rson].tree;\n        else root.tree += (MT) (root.r - (root.l + root.r) / 2) * root.val;\n    }\n\n    void update(int l, int r, int v = 1) { // \u5bf9\u533a\u95f4 [l, r] \u4e2d\u7684\u6570\u5168\u90e8\u52a0\u4e0a v\uff08\u9ed8\u8ba4\u4e3a 1\uff09\n        dst_update(root_id, l, r, v);\n    }\n\n    MT query(int l, int r) { // \u67e5\u8be2\u533a\u95f4 [l, r]\n        if (l > r) {\n            return 0;\n        }\n        return dst_query(root_id, l, r);\n    }\n\n    void dst_update(int root, const int tl, const int tr, const int v) { // \u66f4\u65b0\u533a\u95f4 [tl,tr] -> v\n        Node& temp = tn[root];\n        if (temp.l > tr || temp.r < tl) return ;// \u65e0\u4ea4\u96c6\n        if (temp.l >= tl && temp.r <= tr) { // \u88ab\u5305\u542b\n            temp.val += v;\n            temp.tree += (MT) (temp.r - temp.l + 1) * v;\n            if (temp.r > temp.l) temp.lazy = true;\n            return ;\n        }\n        int mid = (temp.l + temp.r) / 2;\n        if (temp.lazy) {\n            push_down(temp);\n        } else {\n            if (!temp.lson && is_intersect(temp.l, mid, tl, tr)) {\n                temp.lson = build_subTree(temp.l, mid, true, temp.val);\n            }\n            if (!temp.rson && is_intersect(mid + 1, temp.r, tl, tr)) {\n                temp.rson = build_subTree(mid + 1, temp.r, true, temp.val);\n            }\n        }\n        if (temp.lson) dst_update(temp.lson, tl, tr, v);\n        if (temp.rson) dst_update(temp.rson, tl, tr, v);\n        push_up(temp);\n    }\n\n    MT dst_query(int root, const int tl, const int tr) { // \u67e5\u8be2 [tl,tr] \u533a\u95f4\u6027\u8d28\n        Node& temp = tn[root];\n        if (temp.l > tr || temp.r < tl) return 0;// \u65e0\u4ea4\u96c6\n        if (temp.l >= tl && temp.r <= tr) { // \u88ab\u5305\u542b\n            return temp.tree;\n        }\n        if (temp.lazy) push_down(temp);\n        MT res = 0;\n        if (temp.lson) res += dst_query(temp.lson, tl, tr);\n        if (temp.rson) res += dst_query(temp.rson, tl, tr);\n        return res;\n    }\n\n    DST_ADD_SUM(int l_, int r_) : ori_l(l_), ori_r(r_), cur_idx(1) {\n        root_id = this->build_subTree(l_, r_); // \u521b\u5efa\u521d\u59cb\u8282\u70b9\n    }\n    ~DST_ADD_SUM() {}\n};\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> res;\n        DST_ADD_SUM<int> qq(0, n);\n        vector<int> h(n, 0);\n        for (int i = 1; i < n - 1; ++i) {\n            if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {\n                h[i] = 1;\n                qq.update(i, i);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            cout<<i<<\" , \"<<h[i]<<\"\\n\";\n        }\n        for (auto& q : queries) {\n            int f = q[0];\n            if (f == 1) {\n                int l = q[1], r = q[2];\n                res.push_back(qq.query(l + 1, r - 1));\n            } else {\n                int ind = q[1], val = q[2];\n                if (nums[ind] == val) {\n                    continue;\n                }\n                if (ind == 0) {\n                    if (val >= nums[1]) {\n                        if (h[1]) {\n                            h[1] = 0;\n                            qq.update(1, 1, -1);\n                        }\n                    } else if (nums[1] > nums[2] && !h[1]) {\n                        h[1] = 1;\n                        qq.update(1, 1);\n                    }\n                } else if (ind == n - 1) {\n                    if (val >= nums[n - 2]) {\n                        if (h[n - 2]) {\n                            h[n - 2] = 0;\n                            qq.update(n - 2, n - 2, -1);\n                        }\n                    } else if (nums[n - 2] > nums[n - 3] && !h[n - 2]) {\n                        h[n - 2] = 1;\n                        qq.update(n - 2, n - 2);\n                    }\n                } else {\n                    int l = ind - 1, r = ind + 1;\n                    if (val >= nums[l] && h[l]) {\n                        h[l] = 0;\n                        qq.update(l, l, -1);\n                    } else if (l - 1 >= 0 && val < nums[l] && nums[l - 1] < nums[l] && !h[l]) {\n                        h[l] = 1;\n                        qq.update(l, l);\n                    }\n                    if (val >= nums[r] && h[r]) {\n                        h[r] = 0;\n                        qq.update(r, r, -1);\n                    } else if (r + 1 < nums.size() && val < nums[r] && nums[r + 1] < nums[r] && !h[r]) {\n                        h[r] = 1;\n                        qq.update(r, r);\n                    }\n                    if (val > nums[l] && val > nums[r] && !h[ind]) {\n                        h[ind] = 1;\n                        qq.update(ind, ind);\n                    } else if (h[ind] && (val <= nums[l] || val <= nums[r])) {\n                        h[ind] = 0;\n                        qq.update(ind, ind, -1);\n                    }\n                }\n                nums[ind] = val;\n                // for (int i = 0; i < n; ++i) {\n                //     cout<<h[i]<<\" \";\n                // }\n                // cout<<\"\\n\";\n                // for (int i = 0; i < n; ++i) {\n                //     cout<<nums[i]<<\" \";\n                // }\n                // cout<<\"\\n\";\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1718507355.0
}