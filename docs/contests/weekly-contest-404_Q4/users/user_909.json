{
    "username": "omuraisu",
    "submission": "template <typename T>\nstruct Edge {\n    int to;\n    T cost;\n};\nusing Graph = vector<vector<Edge<long long>>>;  // cost \u306e\u578b\u3092 long long \u306b\u6307\u5b9a\n/* tree_diamiter : dfs \u3092\u7528\u3044\u3066\u91cd\u307f\u4ed8\u304d\u6728 T \u306e\u76f4\u5f84\u3092\u6c42\u3081\u308b\n    \u8a08\u7b97\u91cf: O(N)\n*/\ntemplate <typename T>\npair<T, int> dfs(const Graph &G, int u, int par) {  // \u6700\u9060\u70b9\u9593\u8ddd\u96e2\u3068\u6700\u9060\u70b9\u3092\u6c42\u3081\u308b\n    pair<T, int> ret = make_pair((T)0, u);\n    for (auto e : G[u]) {\n        if (e.to == par) continue;\n        auto next = dfs<T>(G, e.to, u);\n        next.first += e.cost;\n        ret = max(ret, next);\n    }\n    return ret;\n}\ntemplate <typename T>\nT tree_diamiter(const Graph &G) {\n    pair<T, int> p = dfs<T>(G, 0, -1);\n    pair<T, int> q = dfs<T>(G, p.second, -1);\n    return q.first;\n}\n\n/* Rerooting: \u5168\u65b9\u4f4d\u6728 DP\n    \u554f\u984c\u3054\u3068\u306b\u4ee5\u4e0b\u3092\u66f8\u304d\u63db\u3048\u308b\n    - \u578bDP\u3068\u5358\u4f4d\u5143\n    - \u578bDP\u306b\u5bfe\u3059\u308b\u4e8c\u9805\u6f14\u7b97 merge\n    - \u307e\u3068\u3081\u305fDP\u3092\u7528\u3044\u3066\u65b0\u305f\u306a\u90e8\u5206\u6728\u306eDP\u3092\u8a08\u7b97\u3059\u308b add_root\n    \u8a08\u7b97\u91cf: O(N)\n*/\nstruct Rerooting {\n    /* start \u554f\u984c\u3054\u3068\u306b\u66f8\u304d\u63db\u3048 */\n    struct DP {  // DP \u306e\u578b\n        long long dp;\n        DP(long long dp_) : dp(dp_) {}\n    };\n    const DP identity = DP(-1);  // \u5358\u4f4d\u5143(\u672b\u7aef\u306e\u5024\u306f add_root(identity) \u306b\u306a\u308b\u306e\u3067\u6ce8\u610f)\n    function<DP(DP, DP)> merge = [](DP dp_cum, DP d) -> DP {\n        return DP(max(dp_cum.dp, d.dp));\n    };\n    function<DP(DP)> add_root = [](DP d) -> DP {\n        return DP(d.dp + 1);\n    };\n    /* end \u554f\u984c\u3054\u3068\u306b\u66f8\u304d\u63db\u3048 */\n\n    // \u30b0\u30e9\u30d5\u306e\u5b9a\u7fa9\n    struct Edge {\n        int to;\n    };\n    using Graph = vector<vector<Edge>>;\n\n    vector<vector<DP>> dp;  // dp[v][i]: v\u304b\u3089\u51fa\u308bi\u756a\u76ee\u306e\u6709\u5411\u8fba\u306b\u5bfe\u5fdc\u3059\u308b\u90e8\u5206\u6728\u306eDP\n    vector<DP> ans;         // ans[v]: \u9802\u70b9v\u3092\u6839\u3068\u3059\u308b\u6728\u306e\u7b54\u3048\n    Graph G;\n\n    Rerooting(int N) : G(N) {\n        dp.resize(N);\n        ans.assign(N, identity);\n    }\n\n    void add_edge(int a, int b) {\n        G[a].push_back({b});\n    }\n    void build() {\n        dfs(0);            // \u666e\u901a\u306b\u6728DP\n        bfs(0, identity);  // \u6b8b\u308a\u306e\u90e8\u5206\u6728\u306b\u5bfe\u5fdc\u3059\u308bDP\u3092\u8a08\u7b97\n    }\n\n    DP dfs(int v, int p = -1) {  // \u9802\u70b9v, \u89aap\n        DP dp_cum = identity;\n        int deg = G[v].size();\n        dp[v] = vector<DP>(deg, identity);\n        for (int i = 0; i < deg; i++) {\n            int u = G[v][i].to;\n            if (u == p) continue;\n            dp[v][i] = dfs(u, v);\n            dp_cum = merge(dp_cum, dp[v][i]);\n        }\n        return add_root(dp_cum);\n    }\n    void bfs(int v, const DP& dp_p, int p = -1) {  // bfs \u3060\u304c\u3001\u5b9f\u88c5\u304c\u697d\u306a\u306e\u3067\u4e2d\u8eab\u306f dfs \u306b\u306a\u3063\u3066\u3044\u308b\n        int deg = G[v].size();\n        for (int i = 0; i < deg; i++) {  // \u524d\u306ebfs\u3067\u8a08\u7b97\u3057\u305f\u6709\u5411\u8fba\u306b\u5bfe\u5fdc\u3059\u308b\u90e8\u5206\u6728\u306eDP\u3092\u4fdd\u5b58\n            if (G[v][i].to == p) dp[v][i] = dp_p;\n        }\n        vector<DP> dp_l(deg + 1, identity), dp_r(deg + 1, identity);  // \u7d2f\u7a4dmerge\n        for (int i = 0; i < deg; i++) {\n            dp_l[i + 1] = merge(dp_l[i], dp[v][i]);\n        }\n        for (int i = deg - 1; i >= 0; i--) {\n            dp_r[i] = merge(dp_r[i + 1], dp[v][i]);\n        }\n\n        ans[v] = add_root(dp_l[deg]);  // \u9802\u70b9 v \u306e\u7b54\u3048\n\n        for (int i = 0; i < deg; i++) {  // \u4e00\u3064\u96a3\u306e\u9802\u70b9\u306b\u5bfe\u3057\u3066\u3082\u540c\u69d8\u306b\u8a08\u7b97\n            int u = G[v][i].to;\n            if (u == p) continue;\n            bfs(u, add_root(merge(dp_l[i], dp_r[i + 1])), v);\n        }\n    }\n};\n\n    \nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        const int n1 = edges1.size() + 1;\n        const int n2 = edges2.size() + 1;\n        auto g1 = Graph(n1);\n        auto g2 = Graph(n2);\n     \n        Rerooting reroot1(n1), reroot2(n2);\n\n\n        for (const auto & e : edges1) {\n            int u = e[0], v = e[1];\n            g1[u].emplace_back(v, 1);\n            g1[v].emplace_back(u, 1);\n            reroot1.add_edge(u, v);             reroot1.add_edge(v, u);\n        }\n        \n        for (const auto & e : edges2) {\n            int u = e[0], v = e[1];\n            g2[u].emplace_back(v, 1);\n            g2[v].emplace_back(u, 1);\n            reroot2.add_edge(u, v);             reroot2.add_edge(v, u);\n        }\n\n        auto res1 = tree_diamiter<long long>(g1);\n        auto res2 = tree_diamiter<long long>(g2);\n        \n        reroot1.build();\n        reroot2.build();\n        \n        long long min1 = n1 + 10, min2 = n2 + 10; \n        for (int i = 0; i < n1; i++) {\n            min1 = min<long long>(min1, reroot1.ans[i].dp );\n        }\n        for (int i = 0; i < n2; i++) {\n            min2 = min<long long>(min2, reroot2.ans[i].dp );\n        }   \n        \n        long long answer = max(res1, res2);\n        return max(answer, min1 + min2 + 1);\n    }\n};\n\n\n",
    "submit_ts": "1719719334",
    "subm_id": "1304439377"
}