{
    "username": "nicholasfoocl",
    "submission": "class Solution {\npublic:\n    \n    // dfs(u) -> longest path with this as root\n    int dfs(int u, vector<vector<int>>&al, vector<int>&vis, int&ans){\n        vis[u] = 1;\n        int a = -1, b = -1;\n        for(auto&v:al[u]){\n            if(!vis[v]){\n                int val = dfs(v,al,vis,ans);\n                if(val >= a){\n                    b = a;\n                    a = val;\n                } else {\n                    if(val>=b){\n                        b = val;\n                    }\n                }\n            }\n        }\n        if(a>-1 && b>-1) ans = max(ans, 2 + a + b);\n        if(a>-1) ans = max(ans, 1 + a);\n        return a > -1 ? 1 + a : 0;\n    }\n    \n    int diam(vector<vector<int>>& edges) {\n        int n = edges.size()+1;\n        vector<vector<int>> al(n);\n        vector<int> vis(n,0);\n        for(auto&e:edges){\n            al[e[0]].push_back(e[1]);\n            al[e[1]].push_back(e[0]);\n        }\n        int ans = 0;\n        dfs(0,al,vis,ans);\n        \n        return ans;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int a = diam(edges1), b = diam(edges2);\n        return max({a,b,1+(a+1)/2 + (b+1)/2});\n    }\n};",
    "submit_ts": 1719716815.0
}