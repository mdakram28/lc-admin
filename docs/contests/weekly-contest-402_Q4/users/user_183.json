{
    "username": "wkingyu",
    "submission": "template<class Info>\nstruct SegmentTree {\n    int n;\n    vector<Info> info;\n    SegmentTree() : n(0) {}\n    SegmentTree(int n_, Info v_ = Info()) {\n        init(n_, v_);\n    }\n    template<class T>\n    SegmentTree(vector<T> init_) {\n        init(init_);\n    }\n    void init(int n_, Info v_ = Info()) {\n        init(vector(n_, v_));\n    }\n    template<class T>\n    void init(vector<T> init_) {\n        n = init_.size();\n        info.assign(4 << __lg(n), Info());\n        function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init_[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = info[2 * p] + info[2 * p + 1];\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);\n    }\n    // \u67e5\u8be2\u533a\u95f4 [l, r) \u5de6\u95ed\u53f3\u5f00\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n    template<class F>\n    int findFirst(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        int res = findFirst(2 * p, l, m, x, y, pred);\n        if (res == -1) {\n            res = findFirst(2 * p + 1, m, r, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int findFirst(int l, int r, F pred) {\n        return findFirst(1, 0, n, l, r, pred);\n    }\n    template<class F>\n    int findLast(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        int res = findLast(2 * p + 1, m, r, x, y, pred);\n        if (res == -1) {\n            res = findLast(2 * p, l, m, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int findLast(int l, int r, F pred) {\n        return findLast(1, 0, n, l, r, pred);\n    }\n};\n\nstruct Info {\n    // \u5b9a\u4e49\u8981\u5b58\u7684\u53d8\u91cf\uff0c\u6bd4\u5982\u533a\u95f4\u548c sum \u6216\u8005\u6700\u5927\u516c\u7ea6\u6570 d \u7b49\u7b49\uff0c\u81f3\u4e8e\u4e0b\u6807\u5c31\u4e0d\u7528\u5b58\u4e86\n    int v = 0;\n};\n\nInfo operator+(Info a, Info b) {\n    Info c;\n    // \u5bf9 a\uff08\u5de6\u513f\u5b50\uff09 \u548c b\uff08\u53f3\u513f\u5b50\uff09 \u4e00\u901a\u64cd\u4f5c\u5408\u6210 c\uff08\u7236\u7ed3\u70b9\uff09\n    c.v = a.v + b.v;\n    return c;\n}\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        SegmentTree<Info> smt(n + 1);\n        for (int idx = 0; idx < n; idx ++) {\n            if (idx + 1 < n and idx - 1 >= 0) {\n                int t = nums[idx] > nums[idx - 1] and nums[idx] > nums[idx + 1];\n                smt.modify(idx, {t});\n            }\n        }\n        vector<int> ans;\n        for (auto q : queries) {\n            int t = q[0];\n            if (t == 1) {\n                int l = q[1];\n                int r = q[2];\n                l += 1;\n                r -= 1;\n                Info t = smt.rangeQuery(l, r + 1);\n                ans.push_back(t.v);\n            }\n            else {\n                int idx = q[1];\n                int val = q[2];\n                if (idx + 1 < n and idx - 1 >= 0) {\n                    int t = val > nums[idx - 1] and val > nums[idx + 1];\n                    smt.modify(idx, {t});\n                }\n                if (idx + 2 < n) {\n                    int t = nums[idx + 1] > val and nums[idx + 1] > nums[idx + 2];\n                    smt.modify(idx + 1, {t});\n                }\n                if (idx - 2 >= 0) {\n                    int t = nums[idx - 1] > val and nums[idx - 1] > nums[idx - 2];\n                    smt.modify(idx - 1, {t});\n                }\n                nums[idx] = val;\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718506685.0
}