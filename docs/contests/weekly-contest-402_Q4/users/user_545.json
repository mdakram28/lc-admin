{
    "username": "snamy520",
    "submission": "impl Solution {\n        pub fn count_of_peaks(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n            fn is_peak(an: &Vec<i32>, i1: usize) -> bool {\n                // i1 = i + 1\n                i1 > 1 && i1 < an.len() && an[i1 - 1] > an[i1 - 2].max(an[i1])\n            }\n            let mut an = nums;\n            let n = an.len();\n            let mut bs = BinaryIndexedTree::<CountBitBucket>::new(n);\n            for i in 1..n - 1 {\n                if is_peak(&an, i + 1) {\n                    // println!(\"add {i} 1\");\n                    bs.add(i + 1, 1);\n                }\n            }\n            let mut res = Vec::new();\n            for q in queries {\n                if q[0] == 1 {\n                    let (l, r) = (q[1] as usize, q[2] as usize);\n                    let cur = if l + 1 < r {\n                        // get peaks in range (l, r), with l and r excluded\n                        bs.get(r) - bs.get(l + 1)\n                    } else {\n                        0\n                    };\n                    res.push(cur as i32);\n                } else {\n                    let (x, v) = (q[1] as usize, q[2]);\n                    let was_peak = [is_peak(&an, x), is_peak(&an, x + 1), is_peak(&an, x + 2)];\n                    an[x] = v;\n                    let is_peak = [is_peak(&an, x), is_peak(&an, x + 1), is_peak(&an, x + 2)];\n                    // println!(\"[{x}] {v} | {was_peak:?} => {is_peak:?}\");\n                    for (i, (&pp, &p)) in was_peak.iter().zip(is_peak.iter()).enumerate() {\n                        if pp != p {\n                            let i1 = x + i;\n                            // println!(\"add {} {}\", i1 - 1, if pp { -1 } else { 1 });\n                            bs.add(i1, if pp { -1 } else { 1 });\n                        }\n                    }\n                }\n            }\n            res\n        }\n}\n\n// data unit for binary-indexed tree\npub trait BitBucket {\n    type Item: Copy;\n\n    fn get_default() -> Self::Item;\n\n    fn combine(left: Self::Item, right: Self::Item) -> Self::Item;\n}\n\n#[derive(Debug)]\npub struct BinaryIndexedTree<T: BitBucket> {\n    size: usize,\n    data: Vec<T::Item>,\n}\n\nimpl<T: BitBucket> BinaryIndexedTree<T> {\n    pub fn new(size: usize) -> Self {\n        Self {\n            size,\n            data: vec![T::get_default(); size + 1],\n        }\n    }\n\n    pub fn add(&mut self, index: usize, value: T::Item) {\n        assert!(0 < index, \"positive index\");\n        let mut x = index;\n        while x <= self.size {\n            self.data[x] = T::combine(self.data[x], value);\n            x += Self::get_last_bit(x);\n        }\n    }\n\n    pub fn get(&self, index: usize) -> T::Item {\n        let mut result = T::get_default();\n        let mut x = index;\n        while 0 < x {\n            let v = if x <= self.size {\n                self.data[x]\n            } else {\n                T::get_default()\n            };\n            result = T::combine(result, v);\n            x -= Self::get_last_bit(x);\n        }\n        result\n    }\n\n    #[inline]\n    fn get_last_bit(d: usize) -> usize {\n        d & (!d + 1)\n    }\n}\n\n#[derive(Debug)]\npub struct CountBitBucket {}\n\nimpl BitBucket for CountBitBucket {\n    type Item = isize;\n\n    fn get_default() -> Self::Item {\n        0\n    }\n\n    fn combine(left: Self::Item, right: Self::Item) -> Self::Item {\n        left + right\n    }\n}",
    "submit_ts": 1718508151.0
}