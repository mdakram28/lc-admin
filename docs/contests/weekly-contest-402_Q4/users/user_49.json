{
    "username": "liouzhou_101",
    "submission": "#ifndef FENWICKTREE_H_\n#define FENWICKTREE_H_\n\n#include <cassert>\n\n#include <algorithm>\n#include <functional>\n#include <type_traits>\n#include <vector>\n\nnamespace data_structure\n{\n\ttemplate<typename T>\n\tconstexpr auto lowbit(T x)\n\t{\n\t\treturn x & -x;\n\t}\n\t// 0-indexed fenwick tree.\n\t// Operation can be:\n\t//     std::plus, std::bit_xor, decltype(std::min), decltype(std::max).\n\t// The corresponding init_value can be\n\t//     0, 0, INF, -INF\n\t// Currently only std::plus is checked.\n\ttemplate<typename ValueType, typename Operation = std::plus<ValueType>>\n\tclass FenwickTree\n\t{\n\tprivate:\n\t\tValueType init_value;\n\t\tOperation operation;\n\t\tstd::vector<ValueType> values;\n\t\t// Build in linear time.\n\t\tvoid Build()\n\t\t{\n\t\t\tfor (int i = 1; i <= (int)values.size(); ++i)\n\t\t\t\tfor (int j = lowbit(i) >> 1, pos = i ^ lowbit(i); j; j >>= 1)\n\t\t\t\t\tvalues[i - 1] = operation(std::move(values[i - 1]), values[(pos += j) - 1]);\n\t\t}\n\tpublic:\n\t\texplicit FenwickTree(int size, const Operation& operation = Operation(), const ValueType& init_value = 0) :\n\t\t\tvalues(size, init_value), operation(operation), init_value(init_value) { }\n\t\ttemplate<typename InputIt>\n\t\texplicit FenwickTree(InputIt first, InputIt last, const Operation& operation = Operation(), const ValueType& init_value = ValueType()) :\n\t\t\tvalues(first, last), operation(operation), init_value(init_value)\n\t\t{\n\t\t\tBuild();\n\t\t}\n\t\tValueType Get(int pos)\n\t\t{\n\t\t\tif (!(0 <= pos && pos < (int)values.size())) return init_value;\n\t\t\tValueType res(init_value);\n\t\t\tfor (pos += 1; pos; pos ^= lowbit(pos))\n\t\t\t\tres = operation(std::move(res), values[pos - 1]);\n\t\t\treturn res;\n\t\t}\n\t\tvoid Add(int pos, ValueType value)\n\t\t{\n\t\t\tassert(0 <= pos && pos < (int)values.size());\n\t\t\tfor (pos += 1; pos <= values.size(); pos += lowbit(pos))\n\t\t\t\tvalues[pos - 1] = operation(std::move(values[pos - 1]), value);\n\t\t}\n\t\t\n\t\ttemplate<typename T = ValueType>\n\t\tstd::enable_if_t<std::is_same_v<Operation, std::plus<T>>, std::vector<T>> GetPlain()\n\t\t{\n\t\t\tstd::vector<ValueType> res = values;\n\t\t\tfor (int i = (int)values.size(); i >= 1; --i)\n\t\t\t{\n\t\t\t\tint k = lowbit(i);\n\t\t\t\tfor (int j = 1, pos = i - 1; j < k; pos ^= j, j <<= 1)\n\t\t\t\t\tres[i - 1] -= res[pos - 1];\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\ttemplate<typename T = ValueType>\n\t\tstd::enable_if_t<std::is_same_v<Operation, std::bit_xor<T>>, std::vector<T>> GetPlain()\n\t\t{\n\t\t\tstd::vector<ValueType> res = values;\n\t\t\tfor (int i = (int)values.size(); i >= 1; --i)\n\t\t\t{\n\t\t\t\tint k = lowbit(i);\n\t\t\t\tfor (int j = 1, pos = i - 1; j < k; pos ^= j, j <<= 1)\n\t\t\t\t\tres[i - 1] ^= res[pos - 1];\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t};\n}\n\n#endif\n\n\nnamespace algorithm {}\nnamespace data_structure {}\n\nusing namespace algorithm;\nusing namespace data_structure;\n\nclass Solution {\npublic:\n\tvector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n\t\tint n = nums.size();\n\t\tvector<int> a(n);\n\t\tfor (int i = 1; i < n - 1; ++i)\n\t\t{\n\t\t\tif (nums[i] > max(nums[i - 1], nums[i + 1]))\n\t\t\t\ta[i] = 1;\n\t\t}\n\n\t\tFenwickTree<int> g(n);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tg.Add(i, a[i]);\n\n\t\tvector<int> res;\n\t\tfor (auto& e : queries)\n\t\t{\n\t\t\tint t = e[0], x = e[1], y = e[2];\n\t\t\tif (t == 1)\n\t\t\t{\n\t\t\t\tif (x + 1 <= y - 1)\n\t\t\t\t{\n\t\t\t\t\tres.push_back(g.Get(y - 1) - g.Get(x));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tres.push_back(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int i = max(0, x - 1); i <= min(x + 1, n - 1); ++i)\n\t\t\t\t{\n\t\t\t\t\tg.Add(i, -a[i]);\n\t\t\t\t}\n\t\t\t\tnums[x] = y;\n\t\t\t\tfor (int i = max(0, x - 1); i <= min(x + 1, n - 1); ++i)\n\t\t\t\t{\n\t\t\t\t\tif (0 < i && i < n - 1 && nums[i] > max(nums[i - 1], nums[i + 1]))\n\t\t\t\t\t\ta[i] = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\ta[i] = 0;\n\t\t\t\t}\n\t\t\t\tfor (int i = max(0, x - 1); i <= min(x + 1, n - 1); ++i)\n\t\t\t\t{\n\t\t\t\t\tg.Add(i, a[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};",
    "submit_ts": 1718506286.0
}