{
    "username": "cf2",
    "submission": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\n\nclass SegmentNode {\n    constructor(a, b) {\n        this.start = a;\n        this.end = b;\n        //select / select\n        this.info1 = 0;\n        // select / no select\n        this.info2 = 0;\n        //no select / select\n        this.info3 = 0;\n        //no select / no select\n        this.info4 = 0;\n        this.info = 0;\n        this.left = null;\n        this.right = null;\n    }\n}\n//1 + 3 => 1\n//2 + 1 => 1\n//2 + 3 => 1\n\n//1 + 4 => 2\n//2 + 2 => 2\n//2 + 4 => 2\n\n\n//3 + 3 => 3\n//4 + 1 => 3\n//4 + 3 => 3\n\n\n//3 + 4 => 4\n//4 + 2 => 4\n//4 + 4 => 4\nlet max = (a, b) => a >= b ? a : b;\nlet helper = (node1, node2) => {\n    let a = max(max(node1.info1 + node2.info3, node1.info2 + node2.info1), node1.info2 + node2.info3);\n    let b = max(max(node1.info1 + node2.info4, node1.info2 + node2.info2), node1.info2 + node2.info4);\n    let c = max(max(node1.info3 + node2.info3, node1.info4 + node2.info1), node1.info4 + node2.info3);\n    let d = max(max(node1.info3 + node2.info4, node1.info4 + node2.info2), node1.info4 + node2.info4);\n    return [a, b, c, d];\n}\n\n\nclass SegmentTree {\n    constructor(root, nums) {\n        this.root = root;\n        this.nums = nums;\n    }\n\n    constructTree(node, a, b) {\n        let nums = this.nums;\n        if (a === b) {\n            node.info1 = BigInt(this.nums[a]);\n            node.info2 = BigInt(-Number.MAX_VALUE);\n            node.info3 = BigInt(-Number.MAX_VALUE);\n            node.info4 = 0n;\n            node.info = max(max(node.info1, node.info2), max(node.info3, node.info4));\n            return;\n        }\n        let mid = a + Math.floor((b - a) / 2);\n        node.left = new SegmentNode(a, mid);\n        node.right = new SegmentNode(mid + 1, b);\n        this.constructTree(node.left, a, mid);\n        this.constructTree(node.right, mid + 1, b);\n        let [e, f, g, h] = helper(node.left, node.right);\n        node.info1 = e;\n        node.info2 = f;\n        node.info3 = g;\n        node.info4 = h;\n        node.info = max(max(e, f), max(g, h));\n    }\n\n    update(node, index, val) {\n\t\tif (!node) return;\n        if (node.start > index || node.end < index) return;\n        if (node.start === index && node.end === index) {\n            node.info1 = BigInt(val);\n            node.info2 = BigInt(-Number.MAX_VALUE);\n            node.info3 = BigInt(-Number.MAX_VALUE);\n            node.info4 = 0n;\n            node.info = max(max(node.info1, node.info2), max(node.info3, node.info4));\n            return;\n        }\n        this.update(node.left, index, val);\n        this.update(node.right, index, val);\n        \n        let [a, b, c, d] = helper(node.left, node.right);\n        node.info1 = a;\n        node.info2 = b;\n        node.info3 = c;\n        node.info4 = d;\n        node.info = max(max(a, b), max(c, d));\n    }\n\n    query(node, a, b) {\n\t\t\tif (!node) return 0n;\n        if (a > node.end || b < node.start) {\n            return BigInt(-Number.MAX_VALUE);\n        }\n        if (a <= node.start && b >= node.end) {\n            return node.info;\n        }\n        return max(this.query(node.left, a, b), this.query(node.right, a, b));\n    }\n}\nlet mod = BigInt(10 ** 9 + 7);\nvar maximumSumSubsequence = function(nums, queries) {\n    let n = nums.length;\n    let root = new SegmentNode(0, n - 1);\n    let tree = new SegmentTree(root, nums);\n    tree.constructTree(root, 0, n - 1);\n    let res = 0n;\n    // console.log(root)\n    for (let i = 0; i < queries.length; i++) {\n        let [pos, x] = queries[i];\n        tree.update(root, pos, x);\n        let val = tree.query(root, 0, n - 1);\n        res += val;\n        res %= mod;\n        res += mod;\n        res %= mod;\n    }\n    // console.log(root)\n    return Number(res);\n    \n};",
    "submit_ts": 1716693109.0
}