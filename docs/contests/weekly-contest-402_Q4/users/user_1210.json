{
    "username": "Z3ROsum",
    "submission": "\nclass give(private val arr: IntArray) {\n    private val n: Int = arr.size\n    private val `try`: IntArray = IntArray(4 * n)\n    \n    init {\n        build(0, 0, n - 1)\n    }\n    \n    private fun build(node: Int, start: Int, end: Int) {\n        if (start == end) {\n            `try`[node] = arr[start]\n        } else {\n            val mid = (start + end) / 2\n            build(2 * node + 1, start, mid); build(2 * node + 2, mid + 1, end); `try`[node] = `try`[2 * node + 1] + `try`[2 * node + 2]\n        }\n    }\n    \n    fun update(index: Int, value: Int) {\n        update(0, 0, n - 1, index, value)\n    }\n    \n    private fun update(node: Int, start: Int, end: Int, index: Int, value: Int) {\n        if (start == end) {\n            arr[index] = value; `try`[node] = value\n        } else {\n            val mid = (start + end) / 2\n            if (index <= mid) {\n                update(2 * node + 1, start, mid, index, value)\n            } else {\n                update(2 * node + 2, mid + 1, end, index, value)\n            }\n            `try`[node] = `try`[2 * node + 1] + `try`[2 * node + 2]\n        }\n    }\n    \n    fun sumRange(left: Int, right: Int): Int {\n        return sumRange(0, 0, n - 1, left, right)\n    }\n    \n    private fun sumRange(node: Int, start: Int, end: Int, left: Int, right: Int): Int {\n        if (start > right || end < left) {\n            return 0\n        }\n        if (start >= left && end <= right) {\n            return `try`[node]\n        }\n        val mid = (start + end) / 2\n        val leftSum = sumRange(2 * node + 1, start, mid, left, right)\n        val rightSum = sumRange(2 * node + 2, mid + 1, end, left, right)\n        return leftSum + rightSum\n    }\n}\n\nclass Solution {\n    fun countOfPeaks(nums: IntArray, queries: Array<IntArray>): List<Int> {\n        val answer = nums.size\n        val prime = IntArray(answer)\n        \n        for (i in 1 until answer - 1) if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) prime[i] = 1\n        val segmentTree = give(prime)\n        \n        val res = mutableListOf<Int>()\n        \n        \n        fun rev(i: Int) {\n            if (i > 0 && i < answer - 1) {\n                prime[i] = if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) 1 else 0\n                segmentTree.update(i, prime[i])\n            }\n            if (i > 1) {\n                prime[i - 1] = if (nums[i - 1] > nums[i - 2] && nums[i - 1] > nums[i]) 1 else 0\n                segmentTree.update(i - 1, prime[i - 1])\n            }\n            if (i < answer - 2) {\n                prime[i + 1] = if (nums[i + 1] > nums[i] && nums[i + 1] > nums[i + 2]) 1 else 0\n                segmentTree.update(i + 1, prime[i + 1])\n            }\n        }; for (i in 0 until answer) rev(i)\n        for (query in queries) {\n            if (query[0] == 1) {\n                var count = 0\n                if (query[1] <= query[2]) {\n                    count += segmentTree.sumRange(query[1], query[2])\n                    if (prime[query[1]] == 1) count--\n                    if (prime[query[2]] == 1 && query[2] != query[1]) count--\n                }\n                res.add(count)\n            }\n            else if (query[0] == 2) {\n                val idx = query[1]\n                val value = query[2]\n                nums[idx] = value\n                rev(idx)\n            }\n        }\n        \n        return res\n    }\n}",
    "submit_ts": 1718509331.0
}