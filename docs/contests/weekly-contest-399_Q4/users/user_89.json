{
    "username": "DrunkTemplar",
    "submission": "class Solution:\n    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:\n        modulo = 10**9 + 7\n        \n        ans = 0\n        \n        \n#         left_graph = {}\n#         right_graph = {}\n        \n#         def recur_fn(i):\n#             if i >= len(nums):\n#                 return 0\n#             elif i in left_graph:\n#                 return left_graph[i]\n#             else:\n#                 left_graph[i] = max(nums[i] + recur_fn(i+2),recur_fn(i+1))\n#                 return left_graph[i]\n        \n#         def recur_fn_right(i):\n#             if i < 0:\n#                 return 0\n#             elif i in right_graph:\n#                 return right_graph[i]\n#             else:\n#                 right_graph[i] = max(nums[i] + recur_fn_right(i-2),recur_fn_right(i-1))\n#                 return right_graph[i]\n            \n        \n#         res = recur_fn(0)\n#         res1 = recur_fn_right(len(nums)-1)\n        class SegmentTree:\n            def __init__(self, data):\n                self.n = len(data)\n                self.data = data\n                self.tree = [None] * (4 * self.n)\n                self.build(0, 0, self.n - 1)\n\n            def build(self, node, start, end):\n                if start == end:\n                    # Leaf node, only one element\n                    val = self.data[start]\n                    self.tree[node] = (\n                        val,  # f(l, r) \n                        0,    # f(l+1, r)\n                        0,    # f(l, r-1)\n                        0     # f(l+1, r-1)\n                    )\n                else:\n                    mid = (start + end) // 2\n                    left_child = 2 * node + 1\n                    right_child = 2 * node + 2\n                    self.build(left_child, start, mid)\n                    self.build(right_child, mid + 1, end)\n                    self.tree[node] = self._merge(self.tree[left_child], self.tree[right_child])\n\n            def _merge(self, left, right):\n                f_lr = max(left[2] + right[1], left[0] + right[1], left[2] + right[0])\n                f_l1r = max(left[3] + right[1], left[1] + right[1], left[3] + right[0])\n                f_lr1 = max(left[2] + right[3], left[0] + right[3], left[2] + right[2])\n                f_l1r1 = max(left[3] + right[3], left[1] + right[3], left[3] + right[2])\n                return (f_lr, f_l1r, f_lr1, f_l1r1)\n\n            def query(self, L, R):\n                result = self._query(0, 0, self.n - 1, L, R)\n                return max(result)\n\n            def _query(self, node, start, end, L, R):\n                if R < start or end < L:\n                    return (0, 0, 0, 0)\n                if L <= start and end <= R:\n                    return self.tree[node]\n                mid = (start + end) // 2\n                left_child = 2 * node + 1\n                right_child = 2 * node + 2\n                left_result = self._query(left_child, start, mid, L, R)\n                right_result = self._query(right_child, mid + 1, end, L, R)\n                return self._merge(left_result, right_result)\n\n            def update(self, idx, value):\n                self._update(0, 0, self.n - 1, idx, value)\n\n            def _update(self, node, start, end, idx, value):\n                if start == end:\n                    self.data[idx] = value\n                    val = self.data[start]\n                    self.tree[node] = (\n                        val,  # f(l, r)\n                        0,    # f(l+1, r)\n                        0,    # f(l, r-1)\n                        0     # f(l+1, r-1)\n                    )\n                else:\n                    mid = (start + end) // 2\n                    left_child = 2 * node + 1\n                    right_child = 2 * node + 2\n                    if start <= idx <= mid:\n                        self._update(left_child, start, mid, idx, value)\n                    else:\n                        self._update(right_child, mid + 1, end, idx, value)\n                    self.tree[node] = self._merge(self.tree[left_child], self.tree[right_child])\n\n        seg_tree = SegmentTree(nums)\n        for pos,x in queries:\n            seg_tree.update(pos,x)\n            ans += seg_tree.query(0,len(nums)-1)\n            if ans >= modulo:\n                ans %= modulo\n        return ans\n        \n            \n            \n        \n                \n            \n        \n#         def findMaxSum(arr, N):\n#             dp = [[0 for i in range(2)] for j in range(N)]\n\n#             if (N == 1): \n#                 return arr[0]\n\n#             dp[0][0] = 0\n#             dp[0][1] = arr[0]\n\n#             for i in range(1,N):\n#                 dp[i][1] = dp[i - 1][0] + arr[i]\n#                 dp[i][0] = max(dp[i - 1][1], dp[i - 1][0])\n#             return dp\n\n#             #return max(dp[N - 1][0], dp[N - 1][1])\n        \n#         left_dp = findMaxSum(nums,len(nums))\n#         right_dp = findMaxSum(nums[::-1],len(nums))[::-1]\n        \n#         print(left_dp)\n#         print(right_dp)",
    "submit_ts": 1716694432.0
}