{
    "username": "_dipu",
    "submission": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\n\nconst int maxn = 2e5 + 5;\nconst int mod = 1e9 + 123;\nconst int INF = 5e9;\n\nint gen_base(const int before, const int after) {\n    auto seed = chrono::high_resolution_clock::now().time_since_epoch().count();\n    mt19937 mt_rand(seed);\n    int base = uniform_int_distribution <int> (before, after)(mt_rand);\n    return base % 2 == 0 ? base - 1 : base;\n}\n\nlong long pow32[maxn];\nunsigned long long pow64[maxn];\nint base;\n\nvoid preCalc() {\n    assert(base < mod);\n    pow32[0] = 1;\n    pow64[0] = 1;\n    for (int i = 1; i < maxn; i++) {\n        pow32[i] = (pow32[i - 1] * base) % mod;\n        pow64[i] = (pow64[i - 1] * base);\n    }\n}\n\ntemplate<typename T>\nstruct Hash {\n    vector<long long> pref32;\n    vector<unsigned long long> pref64;\n\n    Hash() {}\n    Hash(const T &s) : pref32(s.size() + 1u, 0), pref64(s.size() + 1u, 0) {\n        assert(base < mod);\n        int n = s.size();\n        for (int i = 0; i < n; i++) {\n            assert(base > s[i]);\n            pref32[i + 1] = (pref32[i] + s[i] * pow32[i]) % mod;\n            pref64[i + 1] = pref64[i] + s[i] * pow64[i];\n        }\n    }\n    pair<long long, unsigned long long> getHash(const int pos, const int len, const int mxPow) {\n        long long hash32 = (pref32[pos + len] - pref32[pos] + mod) % mod;\n        unsigned long long hash64 = pref64[pos + len] - pref64[pos];\n        if (mxPow != 0) {\n            hash32 = (hash32 * pow32[mxPow - (pos + len - 1)]) % mod;\n            hash64 = hash64 * pow64[mxPow - (pos + len - 1)];\n        }\n        return make_pair(hash32, hash64);\n    }\n};\n\n/**\n  * USAGE (0-Indexed)\n  * base = gen_base(256, mod);\n  * preCalc();\n  * Hash<string> hsh = Hash<string>(s);\n  * auto rangeHash = hsh.getHash(0, i + 1, mxPow);\n  * mxPow = maximum length among all strings\n  *\n**/\n\nvector<ll> dp;\nvector<int> table;\nHash<string> strHash;\nvector<Hash<string>> patHashes;\nbool found;\n\nll solve(string &target, vector<string> &words, vector<int> &costs, int pos) {\n    if (pos >= target.size()) {\n        found = true;\n        return 0;\n    }\n    ll &ret = dp[pos];\n    int &tab = table[pos];\n    if (tab) {\n        return ret;\n    }\n    ret = INF;\n    tab = 1;\n    int remLen = target.size() - pos;\n    for (int i = 0; i < words.size(); i++) {\n        if (words[i].size() > remLen) {\n            continue;\n        }\n        int minLen = min((int)words[i].size(), remLen);\n        auto hsh1 = strHash.getHash(pos, minLen, target.size());\n        auto hsh2 = patHashes[i].getHash(0, minLen, target.size());\n        if (hsh1 == hsh2) {\n            ll go = costs[i] + solve(target, words, costs, pos + minLen);\n            ret = min(ret, go);\n        }\n    }\n    return ret;\n}\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int n = target.size();\n        dp = vector<ll>(n, -1);\n        table = vector<int>(n, 0);\n\n        map<string, int> cache;\n        for (int i = 0; i < words.size(); i++) {\n            if (cache.count(words[i]) == 0) {\n                cache[ words[i] ] = costs[i];\n            } else {\n                cache[ words[i] ] = min(cache[ words[i] ], costs[i]);\n            }\n        }\n\n        words.clear(); costs.clear();\n        for (auto it : cache) {\n            words.push_back(it.first);\n            costs.push_back(it.second);\n        }\n\n        base = gen_base(256, mod);\n        preCalc();\n        strHash = Hash<string>(target);\n        patHashes.clear();\n        for (string word : words) {\n            patHashes.push_back(Hash<string>(word));\n        }\n        found = false;\n        ll res = solve(target, words, costs, 0);\n        if (found == false) {\n            return -1;\n        }\n        return res;\n    }\n};",
    "submit_ts": "1720320989",
    "subm_id": "1312310330"
}