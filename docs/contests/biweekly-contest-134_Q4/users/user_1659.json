{
    "username": "horiseun",
    "submission": "class Solution {\npublic:\n  struct Node {\n    int l, r, sm;\n    Node *lft, *rht;\n    Node(int tl, int tr, vector<int> &v): l(tl), r(tr), sm(0) {\n      if (l + 1 != r) {\n        lft = new Node(l, (l + r) / 2, v);\n        rht = new Node((l + r) / 2, r, v);\n        sm = lft->sm & rht->sm;\n      } else {\n        lft = rht = NULL;\n        sm = v[l];\n      }\n    }\n  };\n  \n  int query(Node *x, int l, int r) {\n    if (r <= x->l || x->r <= l) {\n      return INT_MAX;\n    }\n    if (l <= x->l && x->r <= r) {\n      return x->sm;\n    }\n    return query(x->lft, l, r) & query(x->rht, l, r);\n  }\n  \n  long long countSubarrays(vector<int>& nums, int k) {\n    vector<vector<int>> actual;\n    bool prv = false;\n    for (int i = 0; i < nums.size(); i++) {\n      bool good = true;\n      for (int j = 0; j < 30; j++) {\n        if ((((1 << j) & k) && ((1 << j) & nums[i])) || !((1 << j) & k)) {\n        } else {\n          good = false;\n        }\n      }\n      if (good) {\n        if (!prv) {\n          actual.push_back(vector<int>(0));\n        }\n        prv = true;\n        actual.back().push_back(nums[i] - k);\n      } else {\n        prv = false;\n      }\n    }\n    long long ans = 0;\n    for (auto v : actual) {\n      Node *root = new Node(0, v.size(), v);\n      int l = 0;\n      for (int r = 0; r < v.size(); r++) {\n        while (l <= r && query(root, l, r + 1) == 0) {\n          ans += v.size() - r;\n          l++;\n        }\n      }\n    }\n    return ans;\n  }\n};",
    "submit_ts": "1720279952",
    "subm_id": "1311771513"
}