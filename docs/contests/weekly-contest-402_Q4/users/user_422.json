{
    "username": "andyliang223",
    "submission": "class SegTree:\n\n    def __init__(self , n , function = max , bound = 0):\n        self.st = [bound] * (2 * n)\n        self.size = n\n        self.function = function\n        self.bound = bound\n    def update(self , x , value):\n        x += self.size\n        self.st[x] = value\n        while(x > 1):\n            x >>= 1\n            self.st[x] = self.function(self.st[2 * x] , self.st[2 * x + 1])\n\n    def query(self , x , y):\n        x += self.size\n        y += self.size + 1\n        ans = self.bound\n        while(x < y):\n            if(x & 1):\n                ans = self.function(ans , self.st[x])\n                x += 1\n            if(y & 1):\n                y -= 1\n                ans = self.function(ans , self.st[y])\n            x //= 2\n            y //= 2\n        return ans\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        \n        n = len(nums)\n        seg = SegTree(n, lambda x, y: x + y)\n        \n        def isPeak(nums, index):\n            return index > 0 and index < n - 1 and nums[index] > nums[index - 1] and nums[index] > nums[index + 1]\n        \n        vals = [0] * n\n        for i in range(1, n - 1):\n            if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]:\n                vals[i] = 1\n                seg.update(i, 1)\n        ans = []\n        for q in queries:\n            if q[0] == 1:  # QUERY [L, R]\n                op, l, r = q\n                # print(f'currently we at {vals}')\n                # for i in range(1, n):\n                #     print(f\"seg[0:{i}] is {seg.query(0, i)}\")\n                if r - l <= 1:\n                    ans.append(0)\n                else:\n                    ans.append(seg.query(l + 1, r - 1))\n            else:  # UPDATE index, val\n                op, index, val = q\n                if vals[index] == 1:    # CURRENTLY PEAK\n                    nums[index] = val\n                    if isPeak(nums, index):\n                        # STILL PEAK\n                        pass\n                    else:\n                        # NO LONGER PEAK\n                        vals[index] = 0\n                        seg.update(index, 0)\n                        if isPeak(nums, index - 1):\n                            vals[index - 1] = 1\n                            seg.update(index - 1, 1)\n                        if isPeak(nums, index + 1):\n                            vals[index + 1] = 1\n                            seg.update(index + 1, 1)\n                        \n                else:     # CURRENTLY NOT PEAK\n                    nums[index] = val\n                    if isPeak(nums, index):   # WE HAVE BECOME PEAK\n                        seg.update(index, 1)\n                        vals[index] = 1\n                    if index > 0:\n                        left = isPeak(nums, index - 1)\n                        vals[index - 1] = left\n                        seg.update(index - 1, left)\n                    \n                    if index < n - 1:\n                        right = isPeak(nums, index + 1)\n                        vals[index + 1] = right\n                        seg.update(index + 1, right)\n        return ans\n                        \n                    \n        \n        ",
    "submit_ts": 1718507227.0
}