{
    "username": "Cipher_07",
    "submission": "class Solution {\n    int find(vector<int> adj[], int n) {\n        vector<bool> vis(n);\n        int last = 0;\n        queue<int> q;\n        q.push(0);\n        vis[0] = 1;\n\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n\n            last = u;\n\n            for (int v : adj[u])\n                if (!vis[v]) {\n                    vis[v] = 1;\n                    q.push(v);\n                }\n        }\n\n        int d = 0;\n        q.push(last);\n        fill(vis.begin(), vis.end(), false);\n        vis[last] = 1;\n\n        while (!q.empty()) {\n            int size = q.size();\n            while (size--) {\n                int u = q.front();\n                q.pop();\n\n                for (int v : adj[u])\n                    if (!vis[v]) {\n                        vis[v] = 1;\n                        q.push(v);\n                    }\n            }\n            d++;\n        }\n\n        return d - 1;\n    }\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        vector<int> adj1[n];\n        for (auto & e : edges1) {\n            adj1[e[0]].push_back(e[1]);\n            adj1[e[1]].push_back(e[0]);\n        }\n\n        int m = edges2.size() + 1;\n        vector<int> adj2[m];\n        for (auto & e : edges2) {\n            adj2[e[0]].push_back(e[1]);\n            adj2[e[1]].push_back(e[0]);\n        }\n\n        int d1 = find(adj1, n);\n        int d2 = find(adj2, m);\n\n        return max({d1, d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1});\n    }\n};",
    "submit_ts": 1719718692.0
}