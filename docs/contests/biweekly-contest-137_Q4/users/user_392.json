{
    "username": "leetgoat_dot_dev",
    "submission": "import heapq\nfrom functools import cache\n\nclass SegmentTree2D:\n    def __init__(self, matrix):\n        if not matrix:\n            return\n        \n        self.n = len(matrix)\n        self.m = len(matrix[0])\n        self.tree = [[(float('-inf'), -1)] * (2 * self.m) for _ in range(2 * self.n)]\n        self._build(matrix)\n\n    def _build(self, matrix):\n        for i in range(self.n):\n            row_offset = i + self.n\n            for j in range(self.m):\n                col_offset = j + self.m\n                self.tree[row_offset][col_offset] = (matrix[i][j], i)\n        \n        for i in range(self.n):\n            row_offset = i + self.n\n            for j in range(self.m - 1, 0, -1):\n                left_child = self.tree[row_offset][j * 2]\n                right_child = self.tree[row_offset][j * 2 + 1]\n                self.tree[row_offset][j] = max(left_child, right_child, key=lambda x: x[0])\n        \n        for i in range(self.n - 1, 0, -1):\n            for j in range(2 * self.m):\n                top_child = self.tree[i * 2][j]\n                bottom_child = self.tree[i * 2 + 1][j]\n                self.tree[i][j] = max(top_child, bottom_child, key=lambda x: x[0])\n\n    def query(self, row1, col1, row2, col2):\n        row1 += self.n\n        row2 += self.n\n        col1 += self.m\n        col2 += self.m\n        result = (float('-inf'), -1)\n        \n        while row1 <= row2:\n            if row1 % 2 == 1:\n                c1, c2 = col1, col2\n                while c1 <= c2:\n                    if c1 % 2 == 1:\n                        result = max(result, self.tree[row1][c1], key=lambda x: x[0])\n                        c1 += 1\n                    if c2 % 2 == 0:\n                        result = max(result, self.tree[row1][c2], key=lambda x: x[0])\n                        c2 -= 1\n                    c1 //= 2\n                    c2 //= 2\n                row1 += 1\n            if row2 % 2 == 0:\n                c1, c2 = col1, col2\n                while c1 <= c2:\n                    if c1 % 2 == 1:\n                        result = max(result, self.tree[row2][c1], key=lambda x: x[0])\n                        c1 += 1\n                    if c2 % 2 == 0:\n                        result = max(result, self.tree[row2][c2], key=lambda x: x[0])\n                        c2 -= 1\n                    c1 //= 2\n                    c2 //= 2\n                row2 -= 1\n            row1 //= 2\n            row2 //= 2\n        \n        return result\n    \nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        st = SegmentTree2D(board)\n        height = len(board)\n        width = len(board[0])\n        \n        res = -float('inf')\n        \n        def constructSegments(height, blockedRows):\n            blockedRows.sort()\n            segments = []\n            prev = 0\n\n            for b in blockedRows:\n                if b > prev:\n                    segments.append([prev, b - 1])\n                prev = b + 1\n\n            if prev <= height - 1:\n                segments.append([prev, height - 1])\n\n            return segments\n\n        @cache\n        def wrapper(r1, c1, r2, c2):\n            return st.query(r1, c1, r2, c2)\n        \n        for r in range(height):\n            if width > 3:\n                largest_three = heapq.nlargest(3, range(width), key=lambda c: board[r][c])\n            else:\n                largest_three = range(width)\n            \n            for c in largest_three:\n                center = board[r][c]\n                \n                regions = []\n                if r > 0:\n                    regions.append((0, c + 1, r - 1, width - 1))\n                \n                if r != height - 1:\n                    regions.append((r + 1, c + 1, height - 1, width - 1))\n                \n                maxRightScore = -float('inf')\n                rowOccurence = None\n                for region in regions:\n                    q = wrapper(region[0], region[1], region[2], region[3])\n                    maxRightScoreHere = q[0]\n                    if maxRightScoreHere > maxRightScore:\n                        maxRightScore = maxRightScoreHere\n                        rowOccurence = q[1]\n                \n                if rowOccurence == r:\n                    blockedRows = [r]\n                else:\n                    if rowOccurence != None:\n                        blockedRows = [r, rowOccurence]\n                    else:\n                        blockedRows = [r]\n                rowSegments = constructSegments(height, blockedRows)\n                \n                leftC1 = 0\n                leftC2 = c - 1\n                bigLeft = -float('inf')\n                for r1, r2 in rowSegments:\n                    q = wrapper(r1, leftC1, r2, leftC2)\n                    bigLeft = max(bigLeft, q[0])\n                \n                score = center + maxRightScore + bigLeft\n                res = max(score, res)\n                \n                regions = []\n                \n                if r > 0:\n                    regions.append((0, 0, r - 1, c - 1))\n                if r != height - 1:\n                    regions.append((r + 1, 0, height - 1, c - 1))\n                \n                maxLeftScore = -float('inf')\n                rowOcc = None\n                for region in regions:\n                    q = wrapper(region[0], region[1], region[2], region[3])\n                    maxLeftScoreHere = q[0]\n                    if maxLeftScoreHere > maxLeftScore:\n                        maxLeftScore = maxLeftScoreHere\n                        rowOcc = q[1]\n                \n                if rowOcc == r:\n                    blockedRows = [r]\n                else:\n                    if rowOcc != None:\n                        blockedRows = [r, rowOcc]\n                    else:\n                        blockedRows = [r]\n                rowSegments = constructSegments(height, blockedRows)\n                \n                rightC1 = c + 1\n                rightC2 = width - 1\n                bigRight = -float('inf')\n                for r1, r2 in rowSegments:\n                    q = wrapper(r1, rightC1, r2, rightC2)\n                    bigRight = max(bigRight, q[0])\n                \n                score = center + maxLeftScore + bigRight\n                res = max(score, res)\n        \n        return res",
    "submit_ts": "1723910274",
    "subm_id": "1359223900"
}