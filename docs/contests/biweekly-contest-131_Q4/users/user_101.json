{
    "username": "rezero123",
    "submission": "class Solution {\n    public List<Boolean> getResults(int[][] queries) {\n        TreeSet<Integer>block=new TreeSet<>();\n        block.add(0);\n        List<Boolean>res=new ArrayList<>();\n        for(int i=0;i<queries.length;i++){\n            if(queries[i][0]==1){\n                block.add(queries[i][1]);\n            }\n        }\n        int[]dict=new int[50001];\n        int pre=-1;\n        for(Integer cur:block){\n            if(pre!=-1){\n                dict[pre]=cur-pre;\n            }\n            pre=cur;\n        }\n        SegmentTree segmentTree = new SegmentTree(dict) {\n            @Override\n            int queryMerge(int leftRes, int rightRes) {\n                return Math.max(leftRes,rightRes);\n            }\n\n            @Override\n            void doUpdate(int nodeIndex, int value) {\n                segmentTree[nodeIndex]=value;\n            }\n        };\n        for(int i=queries.length-1;i>=0;i--){\n            if(queries[i][0]==1){\n                int preBlock=block.floor(queries[i][1]-1);\n                if(block.last()==queries[i][1]){\n                    segmentTree.update(preBlock, 0);\n                }else {\n                    int newLen = segmentTree.queryRange(preBlock, preBlock) + segmentTree.queryRange(queries[i][1], queries[i][1]);\n                    segmentTree.update(preBlock, newLen);\n                    segmentTree.update(queries[i][1], 0);\n                }\n                block.remove(queries[i][1]);\n            }else {\n                int end=queries[i][1];\n                int sz=queries[i][2];\n                if(block.last()+sz<=end){\n                    res.add(true);\n                }else if(end<sz){\n                    res.add(false);\n                }else {\n                    res.add(segmentTree.queryRange(0,end-sz)>=sz);\n                }\n            }\n        }\n        Collections.reverse(res);\n        return res;\n    }\n\n    abstract class SegmentTree {\n        protected int n;\n        protected int[] segmentTree;\n\n        public SegmentTree(int[] origin) {\n            this.n = origin.length;\n            //\u4f7f\u75284\u500d\u7684\u6570\u636e\u957f\u5ea6\u7684\u7a7a\u95f4\u6765\u786e\u4fdd\u6811\u7684\u8282\u70b9\u4fe1\u606f\u53ef\u4ee5\u88ab\u653e\u4e0b\u3002\u5b9e\u9645\u4e0a\u9700\u8981\u7684\u7a7a\u95f4 =\uff08n\u5411\u4e0a\u6269\u5145\u5230\u6700\u8fd1\u76842\u7684\u67d0\u4e2a\u6b21\u65b9\uff09\u7684\u4e24\u500d\n            this.segmentTree = new int[n * 4];\n            build(origin, 0, n - 1, 0);\n        }\n\n        /**\n         * \u5efa\u6811 \u590d\u6742\u5ea6O(n) n+1/2n+1/4n+...=2n\n         */\n        public void build(int[] origin, int start, int end, int nodeIndex) {\n            if (start == end) {\n                segmentTree[nodeIndex] = origin[start];\n                return;\n            }\n            int mid = (start + end) / 2;\n            build(origin, start, mid, nodeIndex * 2 + 1);\n            build(origin, mid + 1, end, nodeIndex * 2 + 2);\n            segmentTree[nodeIndex] = queryMerge(segmentTree[nodeIndex * 2 + 1], segmentTree[nodeIndex * 2 + 2]);\n        }\n\n        /**\n         * origin[targetIndex]+=value:\n         * \u5355\u70b9\u66f4\u65b0 \u590d\u6742\u5ea6log2n\n         */\n        public void update(int targetIndex, int value) {\n            update(0, n - 1, targetIndex, value, 0);\n        }\n\n        /**\n         * \u8303\u56f4\u67e5\u8be2 \u590d\u6742\u5ea6log2n\n         */\n        public int queryRange(int rangeStart, int rangeEnd) {\n            return doQueryRange(0, n - 1, rangeStart, rangeEnd, 0);\n        }\n\n        private int doQueryRange(int start, int end, int rangeStart, int rangeEnd, int nodeIndex) {\n            if (start == rangeStart && end == rangeEnd) {\n                return segmentTree[nodeIndex];\n            }\n            int mid = (start + end) / 2;\n            boolean includeLeft = mid >= rangeStart && rangeEnd >= start;\n            boolean includeRight = end >= rangeStart && rangeEnd >= (mid + 1);\n            if (includeLeft && includeRight) {\n                return queryMerge(\n                        doQueryRange(start, mid, rangeStart, mid, nodeIndex * 2 + 1),\n                        doQueryRange(mid + 1, end, mid + 1, rangeEnd, nodeIndex * 2 + 2)\n                );\n            }\n            return includeLeft ? doQueryRange(start, mid, rangeStart, rangeEnd, nodeIndex * 2 + 1) :\n                    doQueryRange(mid + 1, end, rangeStart, rangeEnd, nodeIndex * 2 + 2);\n        }\n\n        private void update(int start, int end, int targetIndex, int value, int nodeIndex) {\n            if (start == end) {\n                doUpdate(nodeIndex, value);\n                return;\n            }\n            int mid = (start + end) / 2;\n            if (targetIndex <= mid) {\n                update(start, mid, targetIndex, value, nodeIndex * 2 + 1);\n            } else {\n                update(mid + 1, end, targetIndex, value, nodeIndex * 2 + 2);\n            }\n            segmentTree[nodeIndex] = queryMerge(segmentTree[nodeIndex * 2 + 1], segmentTree[nodeIndex * 2 + 2]);\n        }\n\n        abstract int queryMerge(int leftRes, int rightRes);\n\n        abstract void doUpdate(int nodeIndex, int value);\n    }\n}",
    "submit_ts": "1716649983",
    "subm_id": "534768968"
}