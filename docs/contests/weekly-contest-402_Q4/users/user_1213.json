{
    "username": "alex321",
    "submission": "class Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        q = len(queries)\n        \n        st = SegmentTree(nums)\n        \n        ans = []\n        \n        for t, a, b in queries:\n            if t == 1:\n                val = st.query(a + 1, b + 1)\n                if a > 0 and a + 1 < len(nums) and st.nums[a] > st.nums[a + 1] and st.nums[a] > st.nums[a - 1]:\n                    val -= 1\n                if a != b and b < n - 1 and b - 1 >= 0 and st.nums[b] > st.nums[b - 1] and st.nums[b] > st.nums[b + 1]:\n                    val -= 1\n                    \n                ans.append(val)\n            else:\n                st.update(a + 1, b)\n        \n        return ans\n        \nclass SegmentTree:\n    def __init__(self, nums: List[int]) -> None:\n        n = len(nums)\n        \n        new_n = 2 ** math.ceil(math.log(n, 2))\n        \n        total_n = new_n * 2\n        \n        arr = [0] * (total_n + 1)\n        \n        for i in range(1, n - 1):\n            arr[new_n + i] = 1 if nums[i - 1] < nums[i] and nums[i] > nums[i + 1] else 0\n            \n        for i in range(new_n - 1, 0, -1):\n            arr[i] = arr[i * 2] + arr[i * 2 + 1]\n            \n        # print(n, new_n, total_n, arr)\n            \n        self.arr = arr\n        self.nums = nums\n        self.n = n\n        self.new_n = new_n\n        self.total_n = total_n\n        \n    def query(self, q_left: int, q_right: int, left: int = -1, right: int = -1, node: int = 1) -> int:\n        if node == 1:\n            left = 1\n            right = self.new_n\n            # print(\"query\", self.nums, self.arr)\n            \n        # print(\"e\", node, left, right, q_left, q_right)\n            \n        if q_left > right or q_right < left:\n            return 0\n            \n        if q_left <= left and q_right >= right:\n            return self.arr[node]\n        \n        mid = left + (right - left + 1) // 2\n        \n        from_left = self.query(q_left, q_right, left, mid - 1, node * 2)\n        from_right = self.query(q_left, q_right, mid, right, node * 2 + 1)\n        \n        return from_left + from_right\n    \n    def update(self, idx: int, new_val: int) -> None:\n        self.nums[idx - 1] = new_val\n        \n        diffs = [-1, 0, 1]\n        \n        if idx == 1:\n            diffs = [0, 1]\n            \n        if idx == self.n:\n            diffs = [-1, 0]\n            \n        # print(\"update\", idx, diffs)\n        \n        for i in diffs:\n            cur_idx = idx + i\n            \n            is_peak = 0\n            if cur_idx == 1:\n                continue\n            elif cur_idx == self.n:\n                continue\n            else:\n                if self.nums[cur_idx - 1] > self.nums[cur_idx - 2] and self.nums[cur_idx - 1] > self.nums[cur_idx]:\n                    is_peak = 1\n                    \n            # print(cur_idx, is_peak, self.new_n + cur_idx)\n            \n            self.arr[self.new_n + cur_idx - 1] = is_peak\n        \n            cur = (self.new_n + cur_idx - 1) // 2\n\n            while cur != 0:\n                self.arr[cur] = self.arr[cur * 2] + self.arr[cur * 2 + 1]\n                cur //= 2\n",
    "submit_ts": "1718509799",
    "subm_id": "1289717600"
}