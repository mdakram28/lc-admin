{
    "username": "Sundae2608",
    "submission": "class Tree:\n    def __init__(self):\n        self.graph = defaultdict(list)\n        \n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        \n    def bfs(self, start_node):\n        visited = {start_node}\n        queue = deque([(start_node, 0)])\n        farthest_node = start_node\n        max_distance = 0\n        \n        while queue:\n            node, distance = queue.popleft()\n            if distance > max_distance:\n                max_distance = distance\n                farthest_node = node\n                \n            for neighbor in self.graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, distance + 1))\n                    \n        return farthest_node, max_distance\n\n    def find_longest_path(self):\n        # Step 1: Perform BFS from any node (let's pick node 0)\n        farthest_node, _ = self.bfs(0)\n        \n        # Step 2: Perform BFS from the farthest node found in step 1\n        _, max_distance = self.bfs(farthest_node)\n        \n        return max_distance\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        # Construct the tree graph\n        tree1 = Tree()\n        for u, v in edges1:\n            tree1.add_edge(u, v)\n\n        tree2 = Tree()\n        for u, v in edges2:\n            tree2.add_edge(u, v)\n\n        max1 = tree1.find_longest_path()\n        max2 = tree2.find_longest_path()\n        return max(max1, max2, (max1 + 1) // 2 + (max2 + 1) // 2 + 1)",
    "submit_ts": "1719717949",
    "subm_id": "1304404887"
}