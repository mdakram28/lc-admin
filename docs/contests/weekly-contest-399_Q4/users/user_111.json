{
    "username": "JeffreyLC",
    "submission": "class SegmentTree {\n public:\n    explicit SegmentTree(const vector<int>& nums) {\n        n_ = nums.size();\n        segs_.resize(n_ << 2);\n        Build(nums, 0, n_ - 1, 1);\n    }\n    \n    pair<pair<long long, long long>, pair<long long, long long>> Query(int lq, int rq) {\n        return QueryUtil(0, n_ - 1, 1, lq, rq);\n    }\n    \n    void Update(int k, int v) {\n        UpdateUtil(0, n_ - 1, 1, k, v);\n    }\n    \n private:\n    int n_;\n    vector<pair<pair<long long, long long>, pair<long long, long long>>> segs_;\n    \n    void Build(const vector<int>& nums, int l, int r, int id) {\n        if (l == r) {\n            segs_[id].first.first = max(0, nums[l]);\n            segs_[id].first.second = 0;\n            segs_[id].second.first = 0;\n            segs_[id].second.second = 0;\n        } else {\n            int mid = (l + r) >> 1;\n            Build(nums, l, mid, id * 2);\n            Build(nums, mid + 1, r, id * 2 + 1);\n            segs_[id].first.first = max(segs_[id * 2].first.first + segs_[id * 2 + 1].second.first,\n                                        segs_[id * 2].second.second + segs_[id * 2 + 1].first.first);\n            segs_[id].first.second = max(segs_[id * 2].second.first + segs_[id * 2 + 1].first.second,\n                                        segs_[id * 2].first.second + segs_[id * 2 + 1].second.second);\n            segs_[id].second.first = max(segs_[id * 2].second.first + segs_[id * 2 + 1].second.first,\n                                         segs_[id * 2].first.second + segs_[id * 2 + 1].first.first);\n            segs_[id].second.second = max(segs_[id * 2].second.second + segs_[id * 2 + 1].second.second,\n                                          segs_[id * 2].first.first + segs_[id * 2 + 1].first.second);\n        }\n    }\n    \n    pair<pair<long long, long long>, pair<long long, long long>> QueryUtil(int l, int r, int id, int lq, int rq) {\n        if (r < lq || l > rq) return {{INT_MIN, 0}, {0, 0}};\n        if (lq <= l && r <= rq) return segs_[id];\n        int mid = (l + r) >> 1;\n        auto lhs = QueryUtil(l, mid, id * 2, lq, rq);\n        auto rhs = QueryUtil(mid + 1, r, id * 2 + 1, lq, rq);\n        if (lhs.first.first != INT_MIN && rhs.first.first != INT_MIN) {\n            return {{max(lhs.first.first + rhs.second.first,\n                        lhs.second.second + rhs.first.first),\n                    max(lhs.second.first + rhs.first.second,\n                        lhs.first.second + rhs.second.second)},\n                    {max(lhs.second.first + rhs.second.first,\n                        lhs.first.second + rhs.first.first),\n                    max(lhs.second.second + rhs.second.second,\n                        lhs.first.first + rhs.first.second)}};\n        } else if (lhs.first.first != INT_MIN) {\n            return lhs;\n        } else if (rhs.first.first != INT_MIN) {\n            return rhs;\n        } else {\n            return {{INT_MIN, 0}, {0, 0}};\n        }\n    }\n    \n    void UpdateUtil(int l, int r, int id, int k, int v) {\n        if (l == r) {\n            segs_[id].first.first = max(0, v);\n            segs_[id].first.second = 0;\n            segs_[id].second.first = 0;\n            segs_[id].second.second = 0;\n        } else {\n            int mid = (l + r) >> 1;\n            if (k <= mid) {\n                UpdateUtil(l, mid, id * 2, k, v);\n            } else { \n                UpdateUtil(mid + 1, r, id * 2 + 1, k, v);\n            }\n            segs_[id].first.first = max(segs_[id * 2].first.first + segs_[id * 2 + 1].second.first,\n                                        segs_[id * 2].second.second + segs_[id * 2 + 1].first.first);\n            segs_[id].first.second = max(segs_[id * 2].second.first + segs_[id * 2 + 1].first.second,\n                                        segs_[id * 2].first.second + segs_[id * 2 + 1].second.second);\n            segs_[id].second.first = max(segs_[id * 2].second.first + segs_[id * 2 + 1].second.first,\n                                         segs_[id * 2].first.second + segs_[id * 2 + 1].first.first);\n            segs_[id].second.second = max(segs_[id * 2].second.second + segs_[id * 2 + 1].second.second,\n                                          segs_[id * 2].first.first + segs_[id * 2 + 1].first.second);\n        }\n    }\n};\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        constexpr int kMod = 1e9 + 7;\n        const int n = nums.size();\n        const int m = queries.size();\n        SegmentTree seg_tree = SegmentTree(nums);\n        long long ans = 0;\n        for (const vector<int>& q : queries) {\n            seg_tree.Update(q[0], q[1]);\n            auto ret = seg_tree.Query(0, n - 1);\n            long long to_add = max({ret.first.first, ret.first.second, ret.second.first, ret.second.second});\n            ans += to_add;\n            ans %= kMod;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1716694915",
    "subm_id": "1268128318"
}