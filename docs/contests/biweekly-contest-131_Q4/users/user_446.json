{
    "username": "wisdompeak",
    "submission": "class SegTreeNode\n{\n    public:\n    SegTreeNode* left = NULL;\n    SegTreeNode* right = NULL;\n    int start, end;\n    int info;  // the maximum value of the range\n    int v;\n    bool tag; \n        \n    SegTreeNode(int a, int b, int val)  // init for range [a,b] with val\n    {                 \n        tag = 0;\n        start = a, end = b;\n        if (a==b)\n        {\n            info = a-val;\n            v = val;\n            return;\n        }        \n        int mid = (a+b)/2;\n        if (left==NULL)\n        {\n            left = new SegTreeNode(a, mid, val);\n            right = new SegTreeNode(mid+1, b, val);            \n            info = max(left->info, right->info); \n        }        \n    }    \n    \n    SegTreeNode(int a, int b, vector<int>& val)  // init for range [a,b] with the same-size array val\n    {                 \n        tag = 0;\n        info = 0;\n        start = a, end = b;\n        if (a==b)\n        {\n            info = a - val[a];            \n            v = val[a];\n            return;\n        }        \n        int mid = (a+b)/2;\n        if (left==NULL)\n        {\n            left = new SegTreeNode(a, mid, val);\n            right = new SegTreeNode(mid+1, b, val);            \n            info = max(left->info, right->info);  // check with your own logic\n        }\n    } \n    \n    void pushDown()\n    {\n        if (tag==1 && left)\n        {\n            left->info = left->end - v;\n            left->v = v;\n            right->info = right->end - v;\n            right->v = v;\n            left->tag = 1;\n            right->tag = 1;\n            tag = 0;\n        }        \n    } \n    \n    void updateRange(int a, int b, int val)     // set range [a,b] with val\n    {        \n        if (b < start || a > end ) // not covered by [a,b] at all\n            return;        \n        if (a <= start && end <=b)  // completely covered within [a,b]\n        {\n            v = val;\n            info = end - val;\n            tag = 1;\n            return;\n        }\n\n        if (left)\n        {\n            pushDown();        \n            left->updateRange(a, b, val);\n            right->updateRange(a, b, val);\n            v = val;\n            info = max(left->info, right->info);  // write your own logic            \n        }        \n    }\n    \n    int queryRange(int a, int b)     // query the maximum value within range [a,b]\n    {\n        if (b < start || a > end )\n        {\n            return INT_MIN/2;  // check with your own logic\n        }\n        if (a <= start && end <=b)\n        {\n            return info;  // check with your own logic\n        }          \n        \n        if (left)\n        {\n            pushDown();     \n            int ret = max(left->queryRange(a, b), right->queryRange(a, b));        \n            info = max(left->info, right->info);    // check with your own logic\n            return ret;\n        }\n        \n        return info;   // should not reach here\n    }  \n\n};\n\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) \n    {\n        set<int>Set;\n        int n = min(50000, (int)queries.size()*3)+5;\n        SegTreeNode* root = new SegTreeNode(0, n, 0);  // Set the leaf nodes with initVals.\n        vector<bool>rets;\n        \n        // cout<<n<<endl;\n        \n        for (auto q: queries)\n        {\n            if (q[0]==1)\n            {\n                int x = q[1];\n                Set.insert(x);\n                auto iter = Set.lower_bound(x);\n                int y = n;\n                if (next(iter)!=Set.end())\n                    y = *next(iter)-1;\n                root->updateRange(x, y, x);\n            }\n            else\n            {\n                int x = q[1], sz = q[2];\n                int len = root->queryRange(0, x-1)+1;\n                len = max(len, root->queryRange(x, x));\n                \n                \n                           \n                rets.push_back(len>=sz);\n            }\n            \n            // for (int i=0; i<=16; i++)\n            // {\n            //     cout<<i<<\":\"<<root->queryRange(i,i)<<\"; \";                \n            // }\n            // cout<<endl;\n            \n//             cout<<\"OK\"<<endl;\n        }\n        return rets;\n        \n    }\n};",
    "submit_ts": 1716652524.0
}