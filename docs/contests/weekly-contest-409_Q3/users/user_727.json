{
    "username": "choon_hean",
    "submission": "typedef vector<int> vi;\n\nstruct ST {\n    int n;                                         // n = (int)A.size()\n    vi A, st, lazy;                                // the arrays\n\n    inline int l(int p) { return p << 1; }                 // go to left child\n    inline int r(int p) { return (p << 1) + 1; }              // go to right child\n\n    inline int conquer(int a, int b) {\n        if (a == -1) return b;                       // corner case\n        if (b == -1) return a;\n        return a+b;                            // RMQ\n    }\n\n    void build(int p, int L, int R) {              // O(n)\n        if (L == R)\n            st[p] = A[L];                              // base case\n        else {\n            int m = (L + R) / 2;\n            build(l(p), L, m);\n            build(r(p), m + 1, R);\n            st[p] = conquer(st[l(p)], st[r(p)]);\n        }\n    }\n\n    inline void propagate(int p, int L, int R) {\n        if (lazy[p] != -1) {                         // has a lazy flag\n            st[p] = lazy[p];                           // [L..R] has same value\n            if (L != R)                                // not a leaf\n                lazy[l(p)] = lazy[r(p)] = lazy[p];       // propagate downwards\n            else                                       // L == R, a single index\n                A[L] = lazy[p];                          // time to update this\n            lazy[p] = -1;                              // erase lazy flag\n        }\n    }\n\n    int RMQ(int p, int L, int R, int i, int j) {   // O(log n)\n        propagate(p, L, R);                          // lazy propagation\n        if (i > j) return -1;                        // infeasible\n        if ((L >= i) && (R <= j)) return st[p];      // found the segment\n        int m = (L + R) / 2;\n        return conquer(RMQ(l(p), L, m, i, min(m, j)),\n                       RMQ(r(p), m + 1, R, max(i, m + 1), j));\n    }\n\n    void update(int p, int L, int R, int i, int j, int val) { // O(log n)\n        propagate(p, L, R);                          // lazy propagation\n        if (i > j) return;\n        if ((L >= i) && (R <= j)) {                  // found the segment\n            lazy[p] = val;                             // update this\n            propagate(p, L, R);                        // lazy propagation\n        } else {\n            int m = (L + R) / 2;\n            update(l(p), L, m, i, min(m, j), val);\n            update(r(p), m + 1, R, max(i, m + 1), j, val);\n            int lsubtree = (lazy[l(p)] != -1) ? lazy[l(p)] : st[l(p)];\n            int rsubtree = (lazy[r(p)] != -1) ? lazy[r(p)] : st[r(p)];\n            st[p] = conquer(lsubtree, rsubtree);\n        }\n    }\n\n    ST(int sz) : n(sz), A(n), st(4 * n), lazy(4 * n, -1) {}\n\n    ST(const vi &initialA) : ST((int) initialA.size()) {\n        A = initialA;\n        build(1, 0, n - 1);\n    }\n\n    inline void update(int i, int j, int val) { update(1, 0, n - 1, i, j, val); }\n\n    inline int RMQ(int i, int j) { return RMQ(1, 0, n - 1, i, j); }\n};\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int>ans(queries.size());\n        vector<int>a(n-1,1);\n        ST st(a);\n        for(int i=0;i<queries.size();i++){\n            //p(st.st);\n            st.update(queries[i][0]+1,queries[i][1]-1,0);\n            ans[i]=st.RMQ(0,n-1);\n        }\n        //p(st.st);\n        return ans;\n    }\n};",
    "submit_ts": "1722740991",
    "subm_id": "1343733858"
}