{
    "username": "hughstudy-n",
    "submission": "class Solution {\n    private int m, n;\n\n    public int minimumSum(int[][] grid) {\n        m = grid.length;\n        n = grid[0].length;\n        List<int[]> list = new ArrayList<>();\n        for (int i = 0; i < grid.length; ++i) {\n            for (int j = 0; j < grid[i].length; ++j) {\n                if (grid[i][j] == 1) {\n                    list.add(new int[]{i, j});\n                }\n            }\n        }\n\n        int res = Integer.MAX_VALUE;\n        // Horizon cut first\n        for (int i = 0; i < m; ++i) {\n            List<int[]> left = new ArrayList<>(), right = new ArrayList<>();\n            for (int[] t : list) {\n                if (t[0] <= i) {\n                    left.add(t);\n                } else {\n                    right.add(t);\n                }\n            }\n            {\n                int l1 = findBestTwo(left), l2 = findBestOne(right);\n                if (l1 != Integer.MAX_VALUE && l2 != Integer.MAX_VALUE) {\n                    res = Math.min(l1 + l2, res);\n                }\n            }\n            {\n                int l1 = findBestTwo(right), l2 = findBestOne(left);\n                if (l1 != Integer.MAX_VALUE && l2 != Integer.MAX_VALUE) {\n                    res = Math.min(l1 + l2, res);\n                }\n            }\n        }\n\n        // Vertical cut first\n        for (int i = 0; i < n; ++i) {\n            List<int[]> left = new ArrayList<>(), right = new ArrayList<>();\n            for (int[] t : list) {\n                if (t[1] <= i) {\n                    left.add(t);\n                } else {\n                    right.add(t);\n                }\n            }\n            {\n                int l1 = findBestTwo(left), l2 = findBestOne(right);\n                if (l1 != Integer.MAX_VALUE && l2 != Integer.MAX_VALUE) {\n                    res = Math.min(l1 + l2, res);\n                }\n            }\n            {\n                int l1 = findBestTwo(right), l2 = findBestOne(left);\n                if (l1 != Integer.MAX_VALUE && l2 != Integer.MAX_VALUE) {\n                    res = Math.min(l1 + l2, res);\n                }\n            }\n        }\n        return res;\n    }\n\n    private int findBestTwo(List<int[]> list) {\n        if (list.size() <= 1) return Integer.MAX_VALUE;\n        int res = Integer.MAX_VALUE;\n        {\n            for (int i = 0; i < m; ++i) {\n                int[] n1 = initialArr(), n2 = initialArr();\n                for (int[] t : list) {\n                    if (t[0] <= i) {\n                        update(t, n1);\n                    } else {\n                        update(t, n2);\n                    }\n                }\n                if (n1[1] != Integer.MAX_VALUE && n2[1] != Integer.MAX_VALUE) {\n                    res = Math.min(res, cal(n1) + cal(n2));\n                }\n            }\n        }\n        {\n            for (int i = 0; i < n; ++i) {\n                int[] n1 = initialArr(), n2 = initialArr();\n                for (int[] t : list) {\n                    if (t[1] <= i) {\n                        update(t, n1);\n                    } else {\n                        update(t, n2);\n                    }\n                }\n                if (n1[1] != Integer.MAX_VALUE && n2[1] != Integer.MAX_VALUE) {\n                    res = Math.min(res, cal(n1) + cal(n2));\n                }\n            }\n        }\n        return res;\n    }\n\n    private int findBestOne(List<int[]> grid) {\n        if (grid == null || grid.isEmpty()) return Integer.MAX_VALUE;\n        int[] nums = initialArr();\n        for (int[] l : grid) {\n            update(l, nums);\n        }\n        return cal(nums);\n    }\n\n    private void update(int[] l, int[] nums) {\n        int i = l[0], j = l[1];\n        nums[0] = Math.max(i, nums[0]);\n        nums[1] = Math.min(i, nums[1]);\n        nums[2] = Math.max(j, nums[2]);\n        nums[3] = Math.min(j, nums[3]);\n    }\n\n    private int[] initialArr() {\n        int[] nums = {0, Integer.MAX_VALUE, 0, Integer.MAX_VALUE};\n        return nums;\n    }\n\n    private int cal(int[] nums) {\n        return (nums[0] - nums[1] + 1) * (nums[2] - nums[3] + 1);\n    }\n}",
    "submit_ts": 1719115133.0
}