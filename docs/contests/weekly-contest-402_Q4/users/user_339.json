{
    "username": "mhwg",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n/*\nA peak in an array arr is an element that is greater than its previous and next element in arr.\n\nYou are given an integer array nums and a 2D integer array queries.\n\nYou have to process queries of two types:\n\n    queries[i] = [1, li, ri], determine the count of peak elements in the subarray nums[li..ri].\n    queries[i] = [2, indexi, vali], change nums[indexi] to vali.\n\nReturn an array answer containing the results of the queries of the first type in order.\n\nNotes:\n\n    The first and the last element of an array or a subarray cannot be a peak.\n\n*/\n\n// A segment tree for counting peaks\nstruct segtree {\n    int n;\n    vector<int> t, a;\n    segtree(int n) : n(n) {\n        t.assign(4*n, 0);\n        a.assign(n, 0);\n    }\n    void build(vector<int>& a, int v, int tl, int tr) {\n        if (tl == tr) {\n            t[v] = 0;\n        } else {\n            int tm = (tl + tr) / 2;\n            build(a, v*2, tl, tm);\n            build(a, v*2+1, tm+1, tr);\n            t[v] = t[v*2] + t[v*2+1];\n            // peaks crossing the boundary\n            if (tm-1 >= tl && a[tm] > a[tm-1] && a[tm] > a[tm+1]) t[v]++;\n            if (tm+2 <= tr && a[tm+1] > a[tm] && a[tm+1] > a[tm+2]) t[v]++;\n            // cout << v << \" \" << tl << \" \" << tr << \" \" << t[v] << '\\n';\n        }\n    }\n    void build(vector<int>& a) {\n        this->a = a;\n        build(a, 1, 0, n-1);\n    }\n\n    bool in(int i, int l, int r) {\n        return l <= i && i <= r;\n    }\n    int query(int v, int tl, int tr, int l, int r) {\n        if (l > r) return 0;\n        if (l == tl && r == tr) return t[v];\n        int tm = (tl + tr) / 2;\n        int ql = query(v*2, tl, tm, l, min(r, tm));\n        int qr = query(v*2+1, tm+1, tr, max(l, tm+1), r);\n        int ans = ql + qr;\n        // peaks crossing the boundary\n        if (in(tm,l,r) && in(tm-1,l,r) && in(tm+1,l,r) && a[tm] > a[tm-1] && a[tm] > a[tm+1]) ans++;\n        if (in(tm,l,r) && in(tm+1, l, r) && in(tm+2,l,r) && a[tm+1] > a[tm] && a[tm+1] > a[tm+2]) ans++;\n        // cout << \"q \" << v << \" \" << tl << \" \" << tr << \" \" << ans << '\\n';\n        return ans;\n    }\n    int query(int l, int r) {\n        return query(1, 0, n-1, l, r);\n    }\n    void update(int v, int tl, int tr, int pos) {\n        if (tl == tr) {\n            t[v] = 0;\n        } else {\n            int tm = (tl + tr) / 2;\n            if (pos <= tm) {\n                update(v*2, tl, tm, pos);\n            } else {\n                update(v*2+1, tm+1, tr, pos);\n            }\n            t[v] = t[v*2] + t[v*2+1];\n            // peaks crossing the boundary\n            // cout << \"ree \" << tm << \" \" << tl << \" \" << tr << '\\n';\n            // cout << \"a[tm]: \" << a[tm] << \" a[tm-1]: \" << a[tm-1] << \" a[tm+1]: \" << a[tm+1] << '\\n';\n            if (tm-1 >= tl && a[tm] > a[tm-1] && a[tm] > a[tm+1]) t[v]++;\n            if (tm+2 <= tr && a[tm+1] > a[tm] && a[tm+1] > a[tm+2]) t[v]++;\n            // cout << \"u \" << v << \" \" << tl << \" \" << tr << \" \" << t[v] << '\\n';\n        }\n    }\n    void update(int pos, int new_val) {\n        a[pos] = new_val;\n        update(1, 0, n-1, pos);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        segtree st(n);\n        st.build(nums);\n        vector<int> ans;\n        for (auto& q : queries) {\n            if (q[0] == 1) {\n                ans.push_back(st.query(q[1], q[2]));\n            } else {\n                st.update(q[1], q[2]);\n            }\n        }\n        return ans;\n        \n    }\n};",
    "submit_ts": 1718507555.0
}