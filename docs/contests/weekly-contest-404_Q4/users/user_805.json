{
    "username": "atm314",
    "submission": "using i8 = int8_t;\nusing u8 = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\n\nusing f32 = float;\nusing f64 = double;\n\n#define all(x) (x).begin(), (x).end()\n#define ll long long int\n#define VI vector<ll>\n#define VVI vector<VI>\n\n#define ISD true\n#define debug(x) \\\n    if (ISD)     \\\n    cout << #x << \": \" << x << endl\n#define DEBUG(x) cout << #x << \": \" << x << endl\n\ntemplate <typename C>\ni64 SIZE(const C &c)\n{\n    return static_cast<i64>(c.size());\n}\n\ntemplate <typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\ntemplate <typename T, typename U, typename Comp = less<>>\nbool chmax(T &xmax, const U &x, Comp comp = {})\n{\n    if (comp(xmax, x))\n    {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T, typename U, typename Comp = less<>>\nbool chmin(T &xmin, const U &x, Comp comp = {})\n{\n    if (comp(x, xmin))\n    {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x, y) CPP_CAT_I(x, y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x, y) x##y\n\n#define ASSERT(expr...) assert((expr))\n\n// }}}\n\nconstexpr i64 INF = 1'010'000'000'000'000'017LL;\n\nconstexpr i64 MOD = 998244353LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n#define M5 100007\n#define M9 1000000000\n\n#define F first\n#define S second\n\n// util {{{\n#define FOR(i, start, end) for (i64 i = (start), CPP_CAT(i, xxxx_end) = (end); i < CPP_CAT(i, xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\ntemplate <typename T>\nstruct Edge\n{\n    int to;\n    T cost;\n};\nusing Graph = vector<vector<Edge<long long>>>; // cost \u306e\u578b\u3092 long long \u306b\u6307\u5b9a\n/* tree_diamiter : dfs \u3092\u7528\u3044\u3066\u91cd\u307f\u4ed8\u304d\u6728 T \u306e\u76f4\u5f84\u3092\u6c42\u3081\u308b\n    \u8a08\u7b97\u91cf: O(N)\n*/\ntemplate <typename T>\npair<T, int> dfs(const Graph &G, int u, int par)\n{ // \u6700\u9060\u70b9\u9593\u8ddd\u96e2\u3068\u6700\u9060\u70b9\u3092\u6c42\u3081\u308b\n    pair<T, int> ret = make_pair((T)0, u);\n    for (auto e : G[u])\n    {\n        if (e.to == par)\n            continue;\n        auto next = dfs<T>(G, e.to, u);\n        next.first += e.cost;\n        ret = max(ret, next);\n    }\n    return ret;\n}\ntemplate <typename T>\nT tree_diamiter(const Graph &G)\n{\n    pair<T, int> p = dfs<T>(G, 0, -1);\n    pair<T, int> q = dfs<T>(G, p.second, -1);\n    return q.first;\n}\n\nclass Solution\n{\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>> &edges1, vector<vector<int>> &edges2)\n    {\n        int M1 = edges1.size();\n        int M2 = edges2.size();\n        int N1 = M1 + 1;\n        int N2 = M2 + 1;\n\n        Graph G1(N1), G2(N2);\n        REP(i, M1)\n        {\n            int from = edges1[i][0];\n            int to = edges1[i][1];\n            G1[from].push_back({to, 1});\n            G1[to].push_back({from, 1});\n        }\n        REP(i, M2)\n        {\n            int from = edges2[i][0];\n            int to = edges2[i][1];\n            G2[from].push_back({to, 1});\n            G2[to].push_back({from, 1});\n        }\n        ll c1 = tree_diamiter<ll>(G1);\n        ll c2 = tree_diamiter<ll>(G2);\n        return max((c1 + 1) / 2 + (c2 + 1) / 2 + 1, max(c1, c2));\n    }\n};",
    "submit_ts": 1719719203.0
}