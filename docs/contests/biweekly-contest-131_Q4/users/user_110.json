{
    "username": "omipus",
    "submission": "#include <bits/stdc++.h>\nusing namespace ::std;\n\n    #define  TOstringITEMS_( ...)  \"\"\n    #define  DE_( ...)\n    #define  ASSERT_( _op, ...)   assert(_op)\n    #define  ASSERTsystem_( _op, ...)   assert(_op)\n\n#define  ASSERTregion_( ...)  __VA_ARGS__\n#define  ASSERTsentence_( _sentence)\n#define  EXIT_  std::cerr<< \"\\nExit(2267): Line(\"<< __LINE__<< \")\\n\";  std::exit(2267);\n#define  EXITcounter_( _max)  { static int cont = 0; ++ cont; if( cont == _max){ string str = \"Exit_Counter(\" + std::to_string(_max) + \")\"; DE_(str); EXIT_;}}\n#define  FOR_( _i, _l, _r)  for( int _i=int(_l); _i<=int(_r); ++_i)\n#define  FORrev_( _i, _l, _r)  for( int _i=int(_l); _i>=int(_r); --_i)\n\nusing Int64_ = long long;\n\n\n//{ ___SegmentTree_\nstruct ___SegmentTree_{\nusing UnderlyingArray_ = char; // \u7ebf\u6bb5\u6811\u7ef4\u62a4\u7684\u5e95\u5c42\u6570\u7ec4\u662f`underlyingARRAY[0,1,...,__Range)`;\nfriend ostream& operator<<( ostream & _cout, ___SegmentTree_ const& _a){\n    _cout<< \"___SegmentTree-Debug-Begin\\n\";\n    auto dfs = [&]( auto _dfs, Node_ * _cur)->void{\n        if( _cur->Info.Interval.first != _cur->Info.Interval.second){ _dfs( _dfs, _cur->sonPtr[0]);  _dfs( _dfs, _cur->sonPtr[1]);}\n        _cout<< _cur->Info<< \"\\n\";\n    };\n    if( _a.__RootNode != nullptr){ dfs( dfs, _a.__RootNode);}\n    _cout<< \"___SegmentTree-Debug-End\\n\";\n    return _cout;\n}\nstruct Node_{\n    struct Info_{ // \u5bf9\u4e8e*\u975e\u53f6\u5b50\u8282\u70b9* \u5176\u6240\u6709\u4fe1\u606f \u5fc5\u987b\u53ef\u4ee5\u7531*\u5176\u4e24\u4e2a\u513f\u5b50*\u7684\u4fe1\u606f \u6765\u63a8\u5bfc\u51fa;\n    friend ostream& operator<<( ostream & _cout, Info_ const& _a){\n        return _cout<< TOstringITEMS_( _a.Interval, _a.Ma, _a.MaPre, _a.MaSuf);\n    }\n\n    std::pair<int,int> Interval;\n    int Ma, MaPre, MaSuf;\n\n    int Length() const{ return Interval.second - Interval.first + 1;}\n    void Merge( Info_ const& _lef, Info_ const& _rig){ // `lef=[0-1];  rig=[2-3]`  \u5219\u5f53\u524d\u533a\u95f4\u662f`[0-3]`, \u4f60\u9700\u8981\u6839\u636e`lef,rig`\u7684\u4fe1\u606f \u6765\u63a8\u5bfc\u51fa`[0-3]`\u533a\u95f4\u7684\u4fe1\u606f;\n        Interval = {_lef.Interval.first, _rig.Interval.second};\n        Ma = std::max( {_lef.Ma, _rig.Ma, _lef.MaSuf + _rig.MaPre});\n        MaPre = (_lef.MaPre==_lef.Length() ? _lef.Length()+_rig.MaPre : _lef.MaPre);\n        MaSuf = (_rig.MaSuf==_rig.Length() ? _rig.Length()+_lef.MaSuf : _rig.MaSuf);\n    }\n};\n\n    Info_ Info;\n    Node_ * sonPtr[2];\n};\n\n    std::vector< Node_> __Nodes;\n    int __Range; // \u7ebf\u6bb5\u6811\u533a\u95f4`[0...__Range)`;\n    Node_ * __RootNode;\n\n    void Initialize( UnderlyingArray_ const* _arr, int _length){\n        ASSERTsystem_( _length > 0);\n        __Range = _length;\n        __Nodes.resize( __Range*2); // The maximum of nodesCount is `Range*2`;\n        int usedNodes = 0;\n        auto dfs = [&]( auto _dfs, int _l, int _r)->Node_*{\n            auto cur = &__Nodes[ usedNodes ++];\n            if( _l == _r){ // `cur`\u662f\u53f6\u5b50\u8282\u70b9\n                auto & info = cur->Info;  info.Interval = {_l,_l};\n                //>> \u4f7f\u7528`_arr[_l]`\u6765\u66f4\u65b0`info`;\n                info.Ma = info.MaPre = info.MaSuf = 1;\n            }\n            else{\n                int mid = (_l+_r)>>1;  cur->sonPtr[0] = _dfs( _dfs, _l, mid);  cur->sonPtr[1] = _dfs( _dfs, mid+1, _r);\n                cur->Info.Merge( cur->sonPtr[0]->Info, cur->sonPtr[1]->Info);\n            }\n            return cur;\n        };\n        __RootNode = dfs( dfs, 0, __Range-1);\n    }\n    void Modify_index( int _ind, UnderlyingArray_ const& _modVal){ // \u5bf9`underlyingARRAY[ _ind]`\u6267\u884c`modVal`\u7684\u4fee\u6539\u64cd\u4f5c (\u81f3\u4e8e\u5177\u4f53\u5979\u662f\u600e\u4e48\u7684\u4fee\u6539\u64cd\u4f5c(\u8d4b\u503c/\u7d2f\u52a0)? \u81ea\u5df1\u51b3\u5b9a);\n        ASSERTsystem_( 0<=_ind && _ind<__Range);\n        auto Dfs = [&]( auto _dfs, Node_ * _cur)->void{\n            if( _cur->Info.Interval.first == _cur->Info.Interval.second){ // `cur`\u662f\u53f6\u5b50\u8282\u70b9\n                auto & info = _cur->Info;\n                //>> \u4f7f\u7528`_modVal`\u6765\u66f4\u65b0`info`;\n                if( _modVal == 0){\n                    info.MaSuf = 0;\n                }\n                else{\n                    info.MaPre = 0;\n                }\n                return;\n            }\n            if( _ind <= _cur->sonPtr[0]->Info.Interval.second){ _dfs( _dfs, _cur->sonPtr[0]);} else{ _dfs( _dfs, _cur->sonPtr[1]);} _cur->Info.Merge( _cur->sonPtr[0]->Info, _cur->sonPtr[1]->Info);\n        };\n        Dfs( Dfs, __RootNode);\n    }\n    Node_::Info_ Query_interval( int _l, int _r){\n        ASSERTsystem_( 0<=_l && _l<=_r && _r<__Range);\n        auto Dfs = [&]( auto _dfs, Node_ * _cur)->Node_::Info_{\n            if( _l<=_cur->Info.Interval.first && _r>=_cur->Info.Interval.second){ return _cur->Info;}\n            int mid = (_cur->Info.Interval.first + _cur->Info.Interval.second)/2;  if( _r <= mid){ return _dfs( _dfs, _cur->sonPtr[0]);} else if( _l > mid){ return _dfs( _dfs, _cur->sonPtr[1]);}\n            Node_::Info_ ANS;  ANS.Merge( _dfs( _dfs, _cur->sonPtr[0]), _dfs( _dfs, _cur->sonPtr[1]));\n            return ANS;\n        };\n        return Dfs( Dfs, __RootNode);\n    }\n};\n//} ___SegmentTree_\nvoid ___GlobalInitialize(){\n    static bool ___ISfirst = true;  if( !___ISfirst){ return;}  ___ISfirst = false;\n}\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& Q) {\n        static vector<bool> ANS;\n        static ___SegmentTree_ Seg;\n        int N = 0;\n        for( auto & q : Q){\n            if( q[0] == 1){ N = max( N, q[1]);}\n            else{ N = max( N, q[1]);}\n        }\n        Seg.Initialize( nullptr, N + 10);\n        \n        ANS.clear();\n        for( auto & q : Q){\n            if( q[0] == 1){\n                Seg.Modify_index( q[1] - 1, 0);\n                Seg.Modify_index( q[1], 1);\n//                DE_( Seg);\n////                FOR_( r, 0, 10){\n////                    DE_( r, Seg.Query_interval( 0, r));\n////                }\n//                EXIT_;\n            }\n            else if( q[0] == 2){\n                auto ma = Seg.Query_interval( 0, q[1] - 1).Ma;\n                ANS.emplace_back( ma >= q[2]);\n            }\n        }\n        return ANS;\n    }\n};\n\n// @DELI;",
    "submit_ts": 1716650107.0
}