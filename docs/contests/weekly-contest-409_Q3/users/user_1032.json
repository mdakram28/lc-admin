{
    "username": "saketw",
    "submission": "#include <bits/stdc++.h>\n#define ll long long int\n#define FASTIO std::ios::sync_with_stdio(false);\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define inf 1e18\n#define g(x) cout<<x<<endl\n#define all(x) x.begin(),x.end()\n#define input_from_file  freopen(\"input.txt\", \"r\", stdin);\n#define mod 1000000007ll\n#define sz 400005\n#define bitcnt(x) __builtin_popcountll(x)\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\nusing namespace std;\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n    cout << name << \" : \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n    const char* comma = strchr(names + 1, ',');cout.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\nstruct SegmentTreeRange {\n    std::vector<ll> tree;\n    std::vector<ll> lazy;\n\n    SegmentTreeRange() {\n        tree.resize(2 * sz);\n        lazy.resize(2 * sz);\n    }\n\n    // Function to update the segment tree lazily\n    void updateRange(ll qlow, ll qhigh, ll delta, ll node, ll start, ll end) {\n        if (lazy[node] != 0) {\n            // Apply the lazy update to the current node\n            tree[node] += lazy[node] * (end - start + 1);\n\n            // Propagate the lazy update to the children if it's not a leaf node\n            if (start != end) {\n                lazy[2 * node + 1] += lazy[node];\n                lazy[2 * node + 2] += lazy[node];\n            }\n\n            // Reset the lazy value for the current node\n            lazy[node] = 0;\n        }\n\n        // If the query range is completely outside the current segment\n        if (qlow > end || qhigh < start)\n            return;\n\n        // If the query range is completely inside the current segment\n        if (qlow <= start && qhigh >= end) {\n            // Apply the update to the current node\n            tree[node] += delta * (end-start+1);\n\n            // Propagate the update to the children if it's not a leaf node\n            if (start != end) {\n                lazy[2 * node + 1] += delta;\n                lazy[2 * node + 2] += delta;\n            }\n            return;\n        }\n\n        ll mid = (start + end) / 2;\n\n        // Update the left and right subtrees recursively\n        updateRange(qlow, qhigh, delta, 2 * node + 1, start, mid);\n        updateRange(qlow, qhigh, delta, 2 * node + 2, mid + 1, end);\n\n        tree[node] = (tree[2 * node + 1] + tree[2 * node + 2]);\n    }\n\n    // Function to update a single element in the segment tree\n    void updatePoll(ll index, ll newValue, ll node, ll start, ll end) {\n        if (start == end) {\n            // Leaf node, update the value\n            tree[node] = newValue;\n            return;\n        }\n\n        ll mid = (start + end) / 2;\n\n        if (index <= mid) {\n            // Update in the left subtree\n            updatePoll(index, newValue, 2 * node + 1, start, mid);\n        } else {\n            // Update in the right subtree\n            updatePoll(index, newValue, 2 * node + 2, mid + 1, end);\n        }\n\n        tree[node] = (tree[2 * node + 1] + tree[2 * node + 2]);\n    }\n\n\n    // Function to query the segment tree for a given range\n    ll queryRange(ll qlow, ll qhigh, ll node, ll start, ll end) {\n        if (lazy[node] != 0) {\n            // Apply the lazy update to the current node\n            tree[node] += lazy[node] * (end-start+1);\n\n            // Propagate the lazy update to the children if it's not a leaf node\n            if (start != end) {\n                lazy[2 * node + 1] += lazy[node];\n                lazy[2 * node + 2] += lazy[node];\n            }\n\n            // Reset the lazy value for the current node\n            lazy[node] = 0;\n        }\n\n        // If the query range is completely outside the current segment\n        if (qlow > end || qhigh < start)\n            return 0;\n\n        // If the query range is completely inside the current segment\n        if (qlow <= start && qhigh >= end)\n            return tree[node];\n\n        ll mid = (start + end) / 2;\n\n        // Query the left and right subtrees recursively\n        ll left = queryRange(qlow, qhigh, 2 * node + 1, start, mid);\n        ll right = queryRange(qlow, qhigh, 2 * node + 2, mid + 1, end);\n\n        return (left + right);\n    }\n};\n\nclass Solution {\npublic:\n    SegmentTreeRange st;\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector <ll> ve[n+1];\n        vector <ll> prev(n+1);\n        for(ll i=1;i<=n;i++)prev[i] = i;\n        for(ll i=1;i<=n-1;i++){\n            ve[i].pb(i+1);\n        }\n        ll q = queries.size();\n        ll idx = 0;\n        vector <int> ans;\n        vector <ll> dp(n+1,inf);\n        dp[n] = 0;\n        for(ll i=n-1;i>=1;i--){\n            for(auto x:ve[i]){\n                dp[i] = min(dp[i], dp[x]+1);\n            }\n            // trace(i,dp[i]);\n            st.updatePoll(i,dp[i],1,1,n);\n        }        \n        while(q--){\n            auto vec = queries[idx++];\n            ll u = vec[0]+1;\n            ll v = vec[1]+1;\n            // trace(u,v);\n            ll worthy = st.queryRange(u,u,1,1,n);\n            if(worthy < 1e9){\n\n        \n            ll old = st.queryRange(u,u,1,1,n);\n            ll destn = st.queryRange(v,v,1,1,n);\n            ll newval = min(old, destn+1);\n            ll diff = 0;\n            if(newval < old){\n            dp[u] = newval;\n            diff = newval- old;\n            }\n                // trace(u,v,diff);\n            st.updateRange(1,u,diff,1,1,n);\n            st.updateRange(u+1,v-1,1e9,1,1,n);\n            }\n            ans.push_back(st.queryRange(1,1,1,1,n));\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722742640",
    "subm_id": "1343773706"
}