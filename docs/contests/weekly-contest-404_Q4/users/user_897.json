{
    "username": "Kode4Fun",
    "submission": "class Solution:\n\n    def findMinHeightTrees(self, edges):\n        n = 0\n        for [a, b] in edges:\n            n = max(n, a + 1)\n            n = max(n, b + 1)\n        \n        if n == 1: return [0] \n        adj = [set() for _ in range(n)]\n        for i, j in edges:\n            adj[i].add(j)\n            adj[j].add(i)\n\n        leaves = [i for i in range(n) if len(adj[i]) == 1]\n\n        while n > 2:\n            n -= len(leaves)\n            newLeaves = []\n            for i in leaves:\n                j = adj[i].pop()\n                adj[j].remove(i)\n                if len(adj[j]) == 1: newLeaves.append(j)\n            leaves = newLeaves\n        return leaves\n\n    def findHeight(self, n, edges):\n        neighbors = collections.defaultdict(set)\n        for v, w in edges:\n            neighbors[v].add(w)\n            neighbors[w].add(v)\n        def maxpath(v, visited):\n            visited.add(v)\n            paths = [maxpath(w, visited) for w in neighbors[v] if w not in visited]\n            path = max(paths or [[]], key=len)\n            path.append(v)\n            return path\n        path = maxpath(0, set())\n        path = maxpath(path[0], set())\n        m = len(path)\n        return m\n\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        if len(edges1) == 0 and len(edges2) == 0:\n            return 1\n\n        n = 0\n        for [a, b] in edges1:\n            n = max(n, a + 1)\n            n = max(n, b + 1)\n        if len(edges2) == 0:\n            ret = 1e9\n            l1 = self.findMinHeightTrees(edges1)\n            for c1 in l1:\n                e = list(edges1)\n                e.append([c1, n])\n                ret = min(ret, self.findHeight(n + 1, e) - 1)\n            return ret\n        m = 0\n        for [a, b] in edges2:\n            m = max(m, a + 1)\n            m = max(m, b + 1)\n        if len(edges1) == 0:\n            ret = 1e9\n            l2 = self.findMinHeightTrees(edges2)\n            for c2 in l2:\n                e = list(edges2)\n                e.append([c2, m])\n                ret = min(ret, self.findHeight(m + 1, e) - 1)\n            return ret\n        \n        l1 = self.findMinHeightTrees(edges1)\n        l2 = self.findMinHeightTrees(edges2)\n\n        def connect(c1, c2):\n            e1 = list(edges1)\n            e2 = list(edges2)\n            # \n            for i in range(len(e2)):\n                e2[i] = [e2[i][0] + n, e2[i][1] + n]\n            e = []\n            for i in range(len(e1)):\n                e.append(e1[i])\n            for i in range(len(e2)):\n                e.append(e2[i])\n            e.append([c1, c2 + n])\n            return self.findHeight(n + m, e)\n\n\n\n        ret = 1e9\n        for c1 in l1:\n            for c2 in l2:\n                ret = min(ret, connect(c1, c2))\n        return ret - 1\n",
    "submit_ts": 1719719367.0
}