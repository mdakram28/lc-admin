{
    "username": "gradesking",
    "submission": "struct node {\n    int l, r, s;\n};\n\nnode T[400100];\nint A[100000];\n\nnode merge(node l, node r)\n{\n    node p;\n    p.l = l.l;\n    p.r = r.r;\n    p.s = l.s + r.s;\n    if(l.l!=l.r && A[l.r]>A[l.r-1] && A[l.r]>A[r.l]) p.s++;\n    if(r.l!=r.r && A[r.l]>A[l.r] && A[r.l]>A[r.l+1]) p.s++;\n    return p;\n}\n\nvoid build_tree(int p, int l, int r)\n{\n    if(l==r)\n    {\n        T[p].l = l;\n        T[p].r = r;\n        T[p].s = 0;\n        return;\n    }\n    int mid = (l+r) / 2;\n    build_tree(2*p, l, mid);\n    build_tree(2*p+1, mid+1, r);\n    T[p] = merge(T[2*p], T[2*p+1]);\n}\n\nvoid change(int p, int x, int k) {\n    if(T[p].l == T[p].r) {\n        A[x] = k;\n        return;\n    }\n    int mid = (T[p].l + T[p].r) / 2;\n    if(x<=mid) change(2*p, x, k);\n    else change(2*p+1, x, k);\n    T[p] = merge(T[2*p], T[2*p+1]);\n}\n\nnode query(int p, int l, int r)\n{\n    if(T[p].l == l && T[p].r == r) return T[p];\n    int mid = (T[p].l + T[p].r) / 2;\n    if(r<=mid) return query(2*p, l, r);\n    if(l>mid) return query(2*p+1, l, r);\n    return merge(query(2*p, l, mid), query(2*p+1, mid+1, r));\n}\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        for(int i=0;i<n;++i) A[i] = nums[i];\n        \n        build_tree(1, 0, n-1);\n        vector<int> ans;\n\n        for(const auto& p:queries){\n            int a=p[0], b=p[1], c=p[2];\n            if(a==1) ans.push_back(query(1, b, c).s);\n            else change(1, b, c);\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": "1718506119",
    "subm_id": "539772919"
}