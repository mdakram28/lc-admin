{
    "username": "uwi",
    "submission": "\tclass Solution {\n\t\tpublic int maximumSumSubsequence(int[] nums, int[][] queries) {\n\t\t\tint n = nums.length;\n\t\t\tSegmentTreeNode st = new SegmentTreeNode(\n\t\t\t\t\tn,\n\t\t\t\t\ti -> {\n\t\t\t\t\t\tNode ret = new Node();\n\t\t\t\t\t\tret.lr = Math.max(0, nums[i]);\n\t\t\t\t\t\tret.l = 0;\n\t\t\t\t\t\tret.r = 0;\n\t\t\t\t\t\tret.non = 0;\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t},\n\t\t\t\t\t(l, r, p) -> {\n\t\t\t\t\t\tp.lr = Math.max(Math.max(l.lr + r.r, l.l + r.lr), Math.max(l.lr + r.non, r.lr + l.non));\n\t\t\t\t\t\tp.l = Math.max(l.l + r.l, l.lr + r.non);\n\t\t\t\t\t\tp.r = Math.max(r.r + l.r, r.lr + l.non);\n\t\t\t\t\t\tp.non = Math.max(0, Math.max(l.r + r.non, l.non + r.l));\n\t\t\t\t\t\tp.r = Math.max(p.r, p.non);\n\t\t\t\t\t\tp.l = Math.max(p.l, p.non);\n\t\t\t\t\t\tp.lr = Math.max(p.lr, Math.max(p.l, p.r));\n//\t\t\t\t\t\ttr(l.lr, r.lr, p.lr, p.l, p.r, p.non);\n\t\t\t\t\t}\n\t\t\t);\n\t\t\tlong ans = 0;\n\t\t\tfor(int[] q : queries){\n\t\t\t\tst.update(q[0], q[0]+1, node -> {\n\t\t\t\t\tnode.non = 0;\n\t\t\t\t\tnode.lr = Math.max(0, q[1]);\n\t\t\t\t\tnode.l = 0;\n\t\t\t\t\tnode.r = 0;\n\t\t\t\t});\n//\t\t\t\ttr(st.nodes[1].lr);\n\t\t\t\tans += st.nodes[1].lr;\n\t\t\t}\n\t\t\treturn (int)(ans % 1000000007);\n\t\t}\n\n\t\tprivate class Node\n\t\t{\n\t\t\tlong lr;\n\t\t\tlong l;\n\t\t\tlong r;\n\t\t\tlong non;\n\n\t\t\tpublic Node()\n\t\t\t{\n\t\t\t}\n\t\t}\n\n\t\tpublic class SegmentTreeNode {\n\t\t\tpublic int M, H, N;\n\t\t\tpublic Node[] nodes;\n\n\n\t\t\t@FunctionalInterface\n\t\t\tpublic interface Propagator<T> {\n\t\t\t\tvoid accept(T c0, T c1, T p);\n\t\t\t}\n\n\t\t\tpublic Propagator<Node> prop2;\n\n\t\t\tpublic SegmentTreeNode(int n, IntFunction<Node> nodeSupplier, Propagator<Node> prop2)\n\t\t\t{\n\t\t\t\tN = n;\n\t\t\t\tM = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n\t\t\t\tH = M>>>1;\n\t\t\t\tthis.prop2 = prop2;\n\n\t\t\t\tnodes = new Node[M];\n\t\t\t\tfor(int i = 0;i < N;i++){\n\t\t\t\t\tnodes[H+i] = nodeSupplier.apply(i);\n\t\t\t\t}\n\t\t\t\tfor(int i = H-1;i >= 1;i--)propagate(i);\n\t\t\t}\n\n\t\t\tprivate void propagate(int cur)\n\t\t\t{\n\t\t\t\tif(2*cur >= M)return;\n\t\t\t\tnodes[cur] = prop2(nodes[2*cur], nodes[2*cur+1], nodes[cur]);\n\t\t\t}\n\n\t\t\tprivate Node prop2(Node L, Node R, Node C)\n\t\t\t{\n\t\t\t\tif(L != null && R != null){\n\t\t\t\t\tif(C == null)C = new Node();\n\t\t\t\t\tprop2.accept(L, R, C);\n\t\t\t\t\treturn C;\n\t\t\t\t}else{\n\t\t\t\t\treturn L != null ? L : R;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void update1(int x, Consumer<Node> operate) {\n\t\t\t\toperate.accept(nodes[H+x]);\n\t\t\t\tfor(int i = H+x>>>1;i >= 1;i>>>=1)propagate(i);\n\t\t\t}\n\n\t\t\tpublic void update(int l, int r, Consumer<Node> operate) { if(l < r)update(l, r, 0, H, 1, operate); }\n\n\t\t\tprotected void update(int l, int r, int cl, int cr, int cur, Consumer<Node> operate)\n\t\t\t{\n\t\t\t\tif(l <= cl && cr <= r){\n\t\t\t\t\toperate.accept(nodes[cur]);\n\t\t\t\t\tpropagate(cur);\n\t\t\t\t}else{\n\t\t\t\t\tint mid = cl+cr>>>1;\n\t\t\t\t\tif(cl < r && l < mid){\n\t\t\t\t\t\tupdate(l, r, cl, mid, 2*cur, operate);\n\t\t\t\t\t}\n\t\t\t\t\tif(mid < r && l < cr){\n\t\t\t\t\t\tupdate(l, r, mid, cr, 2*cur+1, operate);\n\t\t\t\t\t}\n\t\t\t\t\tpropagate(cur);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void operate(int l, int r, Consumer<Node> con) {\n\t\t\t\toperate(l, r, 0, H, 1, con);\n\t\t\t}\n\n\t\t\tprotected void operate(int l, int r, int cl, int cr, int cur, Consumer<Node> con) {\n\t\t\t\tif (l <= cl && cr <= r) {\n\t\t\t\t\tcon.accept(nodes[cur]);\n\t\t\t\t} else {\n\t\t\t\t\tint mid = cl + cr >>> 1;\n\t\t\t\t\tif (cl < r && l < mid) {\n\t\t\t\t\t\toperate(l, r, cl, mid, 2 * cur, con);\n\t\t\t\t\t}\n\t\t\t\t\tif (mid < r && l < cr) {\n\t\t\t\t\t\toperate(l, r, mid, cr, 2 * cur + 1, con);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic Node sum(int l, int r) {\n\t\t\t\treturn sum(l, r, 0, H, 1);\n\t\t\t}\n\n\t\t\tprotected Node sum(int l, int r, int cl, int cr, int cur)\n\t\t\t{\n\t\t\t\tif(l <= cl && cr <= r){\n\t\t\t\t\treturn nodes[cur];\n\t\t\t\t}else{\n\t\t\t\t\tNode L = null, R = null;\n\t\t\t\t\tint mid = cl+cr>>>1;\n\t\t\t\t\tif(cl < r && l < mid){\n\t\t\t\t\t\tL = sum(l, r, cl, mid, 2*cur);\n\t\t\t\t\t}\n\t\t\t\t\tif(mid < r && l < cr){\n\t\t\t\t\t\tR = sum(l, r, mid, cr, 2*cur+1);\n\t\t\t\t\t}\n\t\t\t\t\treturn prop2(L, R, null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString()\n\t\t\t{\n\t\t\t\treturn dfsToString(1, \"\");\n\t\t\t}\n\n\t\t\tprivate String dfsToString(int cur, String indent)\n\t\t\t{\n\t\t\t\tif(cur >= M || nodes[cur] == null)return \"\";\n\t\t\t\treturn dfsToString(2*cur, indent + \"  \")\n\t\t\t\t\t\t+ indent + nodes[cur].toString() + \"\\n\"\n\t\t\t\t\t\t+ dfsToString(2*cur+1, indent + \"  \");\n\t\t\t}\n\t\t}\n\n\t}\n",
    "submit_ts": "1716692366",
    "subm_id": "1268051450"
}