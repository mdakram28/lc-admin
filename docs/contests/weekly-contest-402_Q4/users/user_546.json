{
    "username": "Positron23",
    "submission": "\ntemplate<typename T>\nclass SegmentTree {\nprivate:\n    std::vector<T> tree;\n    int n;\n    std::function<T(T, T)> operation;\n\n    void buildTree(const std::vector<T>& arr, int treeIndex, int lo, int hi) {\n        if (lo == hi) {\n            tree[treeIndex] = arr[lo];\n            return;\n        }\n        int mid = lo + (hi - lo) / 2;\n        buildTree(arr, 2 * treeIndex + 1, lo, mid);\n        buildTree(arr, 2 * treeIndex + 2, mid + 1, hi);\n        tree[treeIndex] = operation(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n    }\n\n    void updateTree(int treeIndex, int lo, int hi, int arrIndex, T val) {\n        if (lo == hi) {\n            tree[treeIndex] = val;\n            return;\n        }\n        int mid = lo + (hi - lo) / 2;\n        if (arrIndex <= mid)\n            updateTree(2 * treeIndex + 1, lo, mid, arrIndex, val);\n        else\n            updateTree(2 * treeIndex + 2, mid + 1, hi, arrIndex, val);\n        tree[treeIndex] = operation(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n    }\n\n    T query(int treeIndex, int lo, int hi, int i, int j) {\n        if (lo >= i && hi <= j)\n            return tree[treeIndex];\n        if (hi < i || lo > j)\n            return 0; // return identity element for the operation\n        int mid = lo + (hi - lo) / 2;\n        T left = query(2 * treeIndex + 1, lo, mid, i, j);\n        T right = query(2 * treeIndex + 2, mid + 1, hi, i, j);\n        return operation(left, right);\n    }\n\npublic:\n    SegmentTree(const std::vector<T>& arr, std::function<T(T, T)> op) : n(arr.size()), operation(op) {\n        if (n > 0) {\n            int x = (int)std::ceil(std::log2(n));\n            int maxSize = 2 * (int)std::pow(2, x) - 1;\n            tree.resize(maxSize);\n            buildTree(arr, 0, 0, n - 1);\n        }\n    }\n\n    void update(int arrIndex, T val) {\n        updateTree(0, 0, n - 1, arrIndex, val);\n    }\n\n    T query(int i, int j) {\n        return query(0, 0, n - 1, i, j);\n    }\n};\n\nstd::function<int(int, int)> myAdd = [](int a, int b) {\n    return a + b;\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> peaks(n, 0);\n\n        const auto isPeakIdx = [&](int idx) {\n            return (idx > 0 && idx < n - 1 && nums[idx] > nums[idx - 1] && nums[idx] > nums[idx + 1]);\n        };\n\n        for (int i = 1; i < n - 1; ++i) {\n            if (isPeakIdx(i)) {\n                peaks[i] = 1;\n            }\n        }\n\n        SegmentTree<int> segTree(peaks, myAdd);\n        vector<int> answer;\n\n        for (auto query : queries) {\n            if (query[0] == 1) {\n                int li = query[1]; int ri = query[2];\n                int ans = segTree.query(li, ri) - peaks[li] - peaks[ri];\n                ans = max(ans, 0);\n                answer.push_back(ans);\n            } else {\n                int idx = query[1]; int val = query[2];\n                nums[idx] = val;\n                for (int i = idx - 1; i <= idx + 1; ++i) {\n                    if (i < 0 || i >= n) {\n                        continue;\n                    }\n                    if (isPeakIdx(i)) {\n                        segTree.update(i, 1);\n                        peaks[i] = 1;\n                    } else {\n                        segTree.update(i, 0);\n                        peaks[i] = 0;\n                    }\n                }\n            }\n        }\n\n        return answer;\n    }\n};",
    "submit_ts": 1718507255.0
}