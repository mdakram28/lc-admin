{
    "username": "BeruboIV",
    "submission": "// CLASS BASED Fenwick Tree\n// NOTE: 0 Based indexing is followed here --> [0, r] range is supported\ntemplate<typename T = long long>\nclass Fenwick{\npublic:\n    int N;\n    vector<T> tree[2];\n    Fenwick(){}\n\n    Fenwick(int n)\n        : N(n){\n            tree[0].resize(N + 1, 0);\n            tree[1].resize(N + 1, 0);\n        }\n\n    void init(int n){\n        N = n;\n        tree[0].resize(N + 1, 0);\n        tree[1].resize(N + 1, 0);\n    }\n\n    T query(int idx, int flag = 0){\n        assert(idx <= N);\n        T sum = 0;\n        while(idx >= 0){\n            sum += tree[flag][idx];\n            idx = (idx & (idx + 1)) - 1;\n        }\n        return sum;\n    }\n\n    void update(int idx, T val, int flag = 0){\n        while(idx <= N){\n            tree[flag][idx] += val;\n            idx = (idx | (idx + 1));\n        }\n    }\n\n    // [l, r]\n    T rangeQuery(int l, int r, int flag = 0){\n        assert(r <= N && \"R Out of bound\");\n        assert(l >= 0 && \"L Must be positive\");\n        if(l > r)\n            return 0;\n        if(l == 0)\n            return query(r, flag);\n        T leftSum = query(l - 1, flag);\n        T rightSum = query(r, flag);\n        return (rightSum - leftSum);\n    }\n\n    int getKth(T k){\n        int ans = 0;\n        T cnt = 0;\n\n        for(int i = 20; i >= 0; i--){\n            if((ans | (1 << i)) <= N && cnt + tree[0][(ans | (1 << i))] < k){\n                ans |= (1 << i);\n                cnt += tree[0][ans];\n            }\n        }\n\n        if(ans == N)\n            return -1;\n        return ans + 1; // +1 because 'ans' will have position of largest value less than k\n    }\n\n    // Insert x into BIT. We basically increment\n    // rank of all elements greater than x.\n    void insert(int x){\n        update(x, 1);\n    }\n\n    // Delete x from BIT. We basically decreases\n    // rank of all elements greater than x.\n    void erase(int x){\n        update(x, -1);\n    }\n\n    T findRank(int x){\n        return query(x);\n    }\n\n    // Use the below only in case of range update and range query\n    // Call update_range() instead of update()\n    // Point update -> update_range(i, i, val);\n    // void update_range(int l, int r, T val){\n    //     if(l > r)\n    //         return;\n    //     update(l, val, 0);\n    //     update(r + 1, -val, 0);\n    //     update(l, val * (l - 1), 1);\n    //     update(r + 1, -val * r, 1);\n    // }\n\n    // T prefix_sum(int idx){\n    //     return query(idx, 0) * idx - query(idx, 1);\n    // }\n\n    // T range_sum(int l, int r){\n    //     if(l > r)\n    //         return 0;\n    //     return prefix_sum(r) - prefix_sum(l - 1);\n    // }\n\n};\n\nclass Solution {\npublic:\n    int minChanges(vector<int>& nums, int k) {\n        int N = nums.size();\n        \n        Fenwick prefBIT(k + 2), suffBIT(k + 2);\n        \n        vector<vector<int>> diff;\n        for(int i = 0, j = N - 1; i < j; i++, j--) {\n            if(nums[i] > nums[j])\n                swap(nums[i], nums[j]);\n            \n            int currDiff = abs(nums[i] - nums[j]);\n            int mxRange = max(k - nums[i], nums[j]);\n            \n            diff.push_back({mxRange, currDiff});\n        }\n        \n        sort(diff.begin(), diff.end());\n        \n        int M = diff.size();\n        vector<int> pref(M, 0), suff(M, 0);\n        \n        map<int, int> diffFre;\n        \n        for(int i = 0; i < M; i++) {\n            int currDiff = diff[i][1];\n            int zeroOp = diffFre[currDiff];\n            int oneOp = prefBIT.query(currDiff) - zeroOp;\n            // oneOp -= zeroOp;\n            int twoOps = i - zeroOp - oneOp;\n            pref[i] = oneOp + 2 * twoOps;\n            prefBIT.update(0, 1);\n            prefBIT.update(diff[i][0] + 1, -1);\n            diffFre[currDiff]++;\n        }\n        \n        diffFre.clear();\n        \n        for(int i = M - 1; i >= 0; i--) {\n            int currDiff = diff[i][1];\n            int zeroOp = diffFre[currDiff];\n            int oneOp = suffBIT.query(currDiff) - zeroOp;\n            // oneOp -= zeroOp;\n            int twoOps = M - (i + 1) - zeroOp - oneOp;\n            // cout << M << \", \" << i +\n            // cout << zeroOp << \" \" << oneOp << \" \" << twoOps << \"\\n\";\n            suff[i] = oneOp + 2 * twoOps;\n            suffBIT.update(0, 1);\n            suffBIT.update(diff[i][0] + 1, -1);\n            diffFre[currDiff]++;\n        }\n        \n        // for(int i = 0; i < M; i++)\n        //         cout << pref[i] << \" \";\n        // cout << \"\\n\";\n        // for(int i = 0; i < M; i++)\n        //         cout << suff[i] << \" \";\n        // cout << \"\\n\";\n        \n        \n        int ans = N;\n        \n        for(int i = 0; i < M; i++)\n            ans = min(ans, pref[i] + suff[i]);\n        \n        return ans;\n    }\n};",
    "submit_ts": "1721489854",
    "subm_id": "1327465816"
}