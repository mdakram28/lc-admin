{
    "username": "lm105013",
    "submission": "class SegmentTree:\n    def __init__(self, size):\n        self.tree = [0] * (2 * size);  \n        self.size = size\n\n    # function to build the tree  \n    def build(self, arr): \n\n        # insert leaf nodes in tree  \n        for i in range(self.size):  \n            self.tree[self.size + i] = arr[i]\n\n        # build the tree by calculating parents  \n        for i in range(self.size - 1, 0, -1):  \n            self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1];  \n\n    # function to update a tree node  \n    def updateTreeNode(self, p, value):  \n        # set value at position p  \n        self.tree[p + self.size] = value\n        p = p + self.size\n\n        # move upward and update parents  \n        i = p\n\n        while i > 1:\n            self.tree[i >> 1] = self.tree[i] + self.tree[i ^ 1]\n            i >>= 1\n            \n    # function to get sum on interval [l, r)  \n    def query(self, l, r):  \n        res = 0\n        # loop to find the sum in the range  \n        l += self.size\n        r += self.size\n\n        while l < r: \n            if (l & 1): \n                res += self.tree[l]\n                l += 1\n\n            if (r & 1): \n                r -= 1\n                res += self.tree[r]\n\n            l >>= 1\n            r >>= 1\n\n        return res  \n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        A = [0] * n\n        \n        for i in range(1, len(nums) - 1):\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:\n                A[i] = 1\n        sg = SegmentTree(n)\n        sg.build(A)\n        \n        res = []\n        for tp, x, y in queries:\n            if tp == 1:\n                res.append(sg.query(x, y+1) - A[x] - A[y] + int(x==y and A[x] == 1))\n            else:\n                if nums[x] == y: continue\n                nums[x] = y\n                #check left\n                if x-1 > 0:\n                    if A[x-1] == 1 and nums[x-1] <= y:\n                        A[x-1] = 0\n                        sg.updateTreeNode(x-1, 0)\n                    elif A[x-1] == 0 and nums[x-1] > y and nums[x-1] > nums[x-2]:\n                        A[x-1] = 1\n                        sg.updateTreeNode(x-1, 1)\n                #check right\n                if x+1 < n-1:\n                    if A[x+1] == 1 and nums[x+1] <= y:\n                        A[x+1] = 0\n                        sg.updateTreeNode(x+1, 0)\n                    elif A[x+1] == 0 and nums[x+1] > y and nums[x+1] > nums[x+2]:\n                        A[x+1] = 1\n                        sg.updateTreeNode(x+1, 1)\n                #check mid\n                if 0 < x < n - 1:\n                    if A[x] == 1 and y <= max(nums[x-1], nums[x+1]):\n                        A[x] = 0\n                        sg.updateTreeNode(x, 0)\n                    elif A[x] == 0 and y > max(nums[x-1], nums[x+1]):\n                        A[x] = 1\n                        sg.updateTreeNode(x, 1)\n        return res",
    "submit_ts": 1718507799.0
}