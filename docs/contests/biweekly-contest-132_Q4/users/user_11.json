{
    "username": "zanj0",
    "submission": "/*\n\tJAI JAGANNATH!\n*/\n//@Author : zanj0\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ff              first\n#define ss              second\n#define pb              push_back\n#define MOD             1000000007\n#define inf             1e18\n\ntypedef long long int lli;\nclass SegmentTree {\npublic:\n\tlli* tree;\n\tSegmentTree() {}\n\tSegmentTree(lli n) {\n\t\ttree = new lli[4 * n + 5]();\n\t\tfor (lli i = 0; i < (4 * n + 5); i++ ) tree[i] = -inf;\n\n\t}\n\tlli left(lli x) {\n\t\treturn 2 * x + 1;\n\t}\n\tlli right(lli x) {\n\t\treturn 2 * x + 2;\n\t}\n\tlli operate(lli a, lli b) {\n\t\treturn max(a, b);\n\t}\n\tvoid pull(lli node) {\n\t\ttree[node] = operate(tree[left(node)], tree[right(node)]);\n\t}\n\tvoid buildTree(lli low, lli high, lli node, vector <lli>& arr) {\n\t\tif (low == high) {\n\t\t\ttree[node] = arr[low];\n\t\t\treturn;\n\t\t}\n\t\tlli mid = low + (high - low) / 2;\n\t\tbuildTree(low, mid, left(node), arr);\n\t\tbuildTree(mid + 1, high, right(node), arr);\n\t\tpull(node);\n\t}\n\tlli query(lli low, lli high, lli node, lli qlow, lli qhigh) {\n\t\tif (qlow > qhigh) return -inf;\n\t\tif (qlow > high || qhigh < low) return -inf;\n\t\tif (qlow <= low && qhigh >= high) {\n\t\t\treturn tree[node];\n\t\t}\n\t\tlli mid = low + (high - low) / 2;\n\t\tlli l = query(low, mid, left(node), qlow, qhigh);\n\t\tlli r = query(mid + 1, high, right(node), qlow, qhigh);\n\t\treturn operate(l, r);\n\t}\n\tvoid update(lli low, lli high, lli node, lli idx, lli val) {\n\t\tif (low == high) {\n\t\t\ttree[node] = max(val, tree[node]);\n\t\t\treturn;\n\t\t}\n\t\tlli mid = low + (high - low) / 2;\n\t\tif (mid >= idx)update(low, mid, left(node), idx, val);\n\t\telse update(mid + 1, high, right(node), idx, val);\n\t\tpull(node);\n\n\t}\n\n};\n\nclass Solution {\npublic:\n\tmap<int, int> Compress(vector<int>& v) {\n\t\tmap<int, int> ret;\n\t\tint curr = 0;\n\t\tfor (auto& it : v) {\n\t\t\tret[it] = curr;\n\t\t\tcurr++;\n\t\t}\n\t\treturn ret;\n\t}\n\tint maximumLength(vector<int>& nums, int k) {\n\t\tint n = nums.size();\n\t\tmap<int, int> idx = Compress(nums);\n\t\tvector<SegmentTree> dp(k + 1);\n\t\tfor (auto& it : dp) {\n\t\t\tit = SegmentTree(n + 5);\n\t\t}\n\n\n\t\tlli ret = 0;\n\n\t\tfor (auto& it : nums) {\n\t\t\tlli id = idx[it];\n\t\t\tfor (int j = k; j >= 0; j--) {\n\t\t\t\tlli previous_value = dp[j].query(0, n, 0, id, id);\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tprevious_value = max(previous_value, (lli)0);\n\t\t\t\t\tdp[j].update(0, n, 0, id, previous_value + 1);\n\t\t\t\t\tret = max(ret, previous_value + 1);\n\t\t\t\t} else {\n\t\t\t\t\tlli other_previous_value = \tmax(dp[j - 1].query(0, n, 0, 0, id - 1), dp[j - 1].query(0, n, 0, id + 1, n));\n\t\t\t\t\tif (other_previous_value != inf) {\n\t\t\t\t\t\tdp[j].update(0, n, 0, id, other_previous_value + 1);\n\t\t\t\t\t\tret = max(ret, other_previous_value + 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (previous_value != inf) {\n\t\t\t\t\t\tdp[j].update(0, n, 0, id, previous_value + 1);\n\t\t\t\t\t\tret = max(ret, previous_value + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n};\n\n\n#ifdef LOCAL\nint main() {\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tcout << \"Compiled!\" << endl;\n}\n#endif",
    "submit_ts": 1717858183.0
}