{
    "username": "andy-lc",
    "submission": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass UnionFind {\n    int[] pa;\n    int[] size;\n\n    UnionFind(int size) {\n        this.pa = new int[size];\n        this.size = new int[size];\n        for (int i = 0; i < size; i++) {\n            this.pa[i] = i;\n            this.size[i] = 1;\n        }\n    }\n\n    int find(int x) {\n        if (pa[x] == x) {\n            return x;\n        } else {\n            return (pa[x] = find(pa[x]));\n        }\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            return;\n        }\n        if (size[x] < size[y]) {\n            int t = x;\n            x = y;\n            y = t;\n        }\n        pa[y] = x;\n        size[x] += size[y];\n    }\n}\n\n;\n\nclass Solution {\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        UnionFind union = new UnionFind(circles.length);\n        for (int i = 0; i < circles.length; i++) {\n            for (int j = i + 1; j < circles.length; j++) {\n                long dx = circles[i][0] - circles[j][0];\n                long dy = circles[i][1] - circles[j][1];\n                long r = circles[i][2] + circles[j][2];\n                if (dx * dx + dy * dy <= r * r) {\n                    union.unite(i, j);\n                }\n            }\n        }\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < circles.length; i++) {\n            map.computeIfAbsent(union.find(i), k -> new ArrayList<>()).add(i);\n        }\n        for (List<Integer> cls : map.values()) {\n            boolean left = false;\n            boolean right = false;\n            boolean up = false;\n            boolean down = false;\n            boolean src = false;\n            boolean dst = false;\n            for (int i : cls) {\n                long x = circles[i][0];\n                long y = circles[i][1];\n                long r = circles[i][2];\n                left = left || overlap_x(x, y, r, 0, Y, 0);\n                right = right || overlap_x(x, y, r, 0, Y, X);\n                up = up || overlap_y(x, y, r, 0, X, Y);\n                down = down || overlap_y(x, y, r, 0, X, 0);\n                src = src || x * x + y * y <= r * r;\n                dst = dst || (x - X) * (x - X) + (y - Y) * (y - Y) <= r * r;\n            }\n            if (src || dst) {\n                return false;\n            }\n            if((left || up) && (right || down)){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    boolean overlap_x(long x, long y, long r, long y1, long y2, long x0) {\n        return overlap_y(y, x, r, y1, y2, x0);\n    }\n\n    boolean overlap_y(long x, long y, long r, long x1, long x2, long y0) {\n        if (Math.abs(y - y0) > r) {\n            return false;\n        }\n        if (Math.min(x1, x2) <= x && x <= Math.max(x1, x2)) {\n            return true;\n        }\n        long d2 = r * r - (y - y0) * (y - y0);\n        if ((x1 - x) * (x1 - x) <= d2) {\n            return true;\n        }\n        return (x2 - x) * (x2 - x) <= d2;\n    }\n}",
    "submit_ts": "1722138259",
    "subm_id": "1335786187"
}