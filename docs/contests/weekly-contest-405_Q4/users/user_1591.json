{
    "username": "trungtrn",
    "submission": "class TrieNode {\n    children;\n    endIndex;\n    constructor() {\n        this.children = {};\n        this.endIndex = new Set(); // Stores indices of words in the words array if this node marks the end of a word\n    }\n}\n\nclass Trie {\n    root;\n    constructor() {\n        this.root = new TrieNode();\n    }\n\n    insert(word, index) {\n        let node = this.root;\n        for (let char of word) {\n            if (!node.children[char]) {\n                node.children[char] = new TrieNode();\n            }\n            node = node.children[char];\n        }\n        node.endIndex.add(index);\n    }\n\n    findWordsStartingHere(target, start, dp, costs) {\n        let node = this.root;\n        let n = target.length;\n        let results = [];\n        for (let i = start; i < n && node; i++) {\n            node = node.children[target[i]];\n            if (node && node.endIndex.size > 0) {\n                for (let index of node.endIndex) {\n                    results.push([i + 1, index]); // end position of the word, and index of the word in original array\n                }\n            }\n        }\n        return results;\n    }\n}\n\nfunction minimumCost(target: string, words: string[], costs: number[]): number {\n    const n = target.length;\n    const dp = new Array(n + 1).fill(Infinity);\n    dp[0] = 0;\n    const trie = new Trie();\n\n    for (let i = 0; i < words.length; i++) {\n        trie.insert(words[i], i);\n    }\n\n    for (let i = 0; i < n; i++) {\n        if (dp[i] === Infinity) continue;\n        const matches = trie.findWordsStartingHere(target, i, dp, costs);\n        for (const [end, idx] of matches) {\n            dp[end] = Math.min(dp[end], dp[i] + costs[idx]);\n        }\n    }\n\n    return dp[n] === Infinity ? -1 : dp[n];\n}\n\nfunction minimumCost2(target: string, words: string[], costs: number[]): number {\n    const n = target.length;\n    const dp = new Array(n + 1).fill(Infinity);\n    dp[0] = 0; // Base case: no cost to build the empty string\n\n    for (let i = 0; i < n; i++) {\n        if (dp[i] === Infinity) continue; // No need to process this state if it's unreachable\n        for (let j = 0; j < words.length; j++) {\n            const word = words[j];\n            const cost = costs[j];\n            if (target.substr(i, word.length) === word) { // Check if the word can fit starting from index i\n                const nextIndex = i + word.length;\n                dp[nextIndex] = Math.min(dp[nextIndex], dp[i] + cost);\n            }\n        }\n    }\n\n    // If dp[n] is still Infinity, it means we cannot form the target string\n    return dp[n] === Infinity ? -1 : dp[n];\n};",
    "submit_ts": "1720321455",
    "subm_id": "1312323311"
}