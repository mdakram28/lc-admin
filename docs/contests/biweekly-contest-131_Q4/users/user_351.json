{
    "username": "bayartsogt",
    "submission": "# Python3 code for range maximum query and updates\nfrom math import ceil, log\nfrom sortedcontainers import SortedList\n \n# A utility function to get the\n# middle index of given range. \ndef getMid(s, e):\n    return s + (e - s) // 2\n \n# /* A recursive function to get the sum of\n    # values in given range of the array.\n    # The following are parameters for this\n    # function.\n    #\n    # st     -> Pointer to segment tree\n    # node     -> Index of current node in\n    #             the segment tree .\n    # ss & se -> Starting and ending indexes\n    #             of the segment represented\n    #             by current node, i.e., st[node]\n    # l & r -> Starting and ending indexes\n    #             of range query */\n \n \ndef MaxUtil(st, ss, se, l, r, node):\n \n    # If segment of this node is completely\n    # part of given range, then return\n    # the max of segment\n    if (l <= ss and r >= se):\n        return st[node]\n \n    # If segment of this node does not\n    # belong to given range\n    if (se < l or ss > r):\n        return -1\n \n    # If segment of this node is partially\n    # the part of given range\n    mid = getMid(ss, se)\n \n    return max(MaxUtil(st, ss, mid, l, r,\n                       2 * node + 1),\n               MaxUtil(st, mid + 1, se, l,\n                       r, 2 * node + 2))\n \n#\n# /* A recursive function to update the nodes which\n# have the given index in their range. The following\n# are parameters st, ss and se are same as defined\n# above index -> index of the element to be updated.*/\n\ndef updateValue(arr, st, ss, se, index, value, node):\n    if (index < ss or index > se):\n        print(\"Invalid Input\")\n        return\n \n    if (ss == se):\n \n        # update value in array and in segment tree\n        arr[index] = value\n        st[node] = value\n    else:\n        mid = getMid(ss, se)\n \n        if (index >= ss and index <= mid):\n            updateValue(arr, st, ss, mid, index,\n                        value, 2 * node + 1)\n        else:\n            updateValue(arr, st, mid + 1, se,\n                        index, value, 2 * node + 2)\n \n        st[node] = max(st[2 * node + 1],\n                       st[2 * node + 2])\n    return\n \n# Return max of elements in range from\n# index l (query start) to r (query end).\n\ndef getMax(st, n, l, r):\n \n    # Check for erroneous input values\n    if (l < 0 or r > n - 1 or l > r):\n        printf(\"Invalid Input\")\n        return -1\n \n    return MaxUtil(st, 0, n - 1, l, r, 0)\n \n# A recursive function that constructs Segment\n# Tree for array[ss..se]. si is index of\n# current node in segment tree st\n\ndef constructSTUtil(arr, ss, se, st, si):\n \n    # If there is one element in array, store\n    # it in current node of segment tree and return\n    if (ss == se):\n        st[si] = arr[ss]\n        return arr[ss]\n \n    # If there are more than one elements, then\n    # recur for left and right subtrees and\n    # store the max of values in this node\n    mid = getMid(ss, se)\n \n    st[si] = max(constructSTUtil(arr, ss, mid, st,\n                                 si * 2 + 1),\n                 constructSTUtil(arr, mid + 1, se,\n                                 st, si * 2 + 2))\n \n    return st[si]\n#\n# /* Function to construct segment tree from given array.\n# This function allocates memory for segment tree.*/\n\ndef constructST(arr, n):\n \n    # Height of segment tree\n    x = ceil(log(n, 2))\n \n    # Maximum size of segment tree\n    max_size = 2 * pow(2, x) - 1\n \n    # Allocate memory\n    st = [0]*max_size\n \n    # Fill the allocated memory st\n    constructSTUtil(arr, 0, n - 1, st, 0)\n \n    # Return the constructed segment tree\n    return st\n\n\n# # Driver code\n# if __name__ == '__main__':\n#     arr = [1, 3, 5, 7, 9, 11]\n#     n = len(arr)\n \n#     # Build segment tree from given array\n#     st = constructST(arr, n)\n \n#     # Prmax of values in array\n#     # from index 1 to 3\n#     print(\"Max of values= \", getMax(st, n, 1, 3))\n \n#     # Update: set arr[1] = 8 and update\n#     # corresponding segment tree nodes.\n#     updateValue(arr, st, 0, n - 1, 1, 8, 0)\n \n#     # Find max after the value is updated\n#     print(\"Updated values = \", getMax(st, n, 1, 3))\n\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        n = min(5 * (10 ** 4), 3 * len(queries)) + 1\n\n        arr = [-1] * n\n\n        st = constructST(arr, n)\n        \n        obstacles = SortedList([0])\n        ans = []\n        for query in queries:\n            if query[0] == 1:  # obstacle\n                x = query[1]  # distance\n                i = obstacles.bisect_left(x)\n                \n                prev_x = obstacles[i-1]\n                updateValue(arr, st, 0, n - 1, x, x - prev_x, 0)\n\n                if i < len(obstacles):\n                    next_x = obstacles[i]\n                    updateValue(arr, st, 0, n - 1, next_x, next_x - x, 0)\n        \n                obstacles.add(x)\n            \n        \n            if query[0] == 2:\n                _, x, size = query\n                i = obstacles.bisect_left(x)\n                prev_x = obstacles[i-1]\n                last_block_sz = x - prev_x\n                \n                global_max_sz = getMax(st, n, 0, x)\n                \n                # print(\"query =\", query)\n                # print(\"last_block_sz =\", last_block_sz)\n                # print(\"global_max_sz =\", global_max_sz)\n                # print(\"obstacles =\", obstacles)\n                # print(\"arr =\", arr)\n                \n                ans.append(size <= last_block_sz or size <= global_max_sz)\n                \n                    \n                \n                \n                \n                \n                \n        \n        \n        return ans",
    "submit_ts": "1716652015",
    "subm_id": "1267653999"
}