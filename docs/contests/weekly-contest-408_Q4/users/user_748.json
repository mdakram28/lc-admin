{
    "username": "Anonymous_235940",
    "submission": "class Solution {\npublic:\n    bool distLeq(long x1, long x2, long y1, long y2, long t)\n    {\n        return ((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) <= t * t;\n    }\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        std::cout << \"\\n\\n\\n\\n\\n\";\n        int l = circles.size();\n        int r = l + 1;\n        int t = r + 1;\n        int b = t + 1;\n        vector<vector<int>> adj{(size_t)(b + 1), vector<int>{}};\n        for(int c_i = 0; c_i < circles.size(); ++c_i)\n        {\n            auto &c = circles[c_i];\n            for(int j = 0; j < circles.size(); ++j)\n            {\n                if(j == c_i) continue;\n                auto &c1 = circles[j];\n                if(distLeq(c[0], c1[0], c[1], c1[1], c[2] + c1[2]))\n                {\n                    adj[c_i].push_back(j);\n                    //std::cout << c_i << \" -> \" << j << \"\\n\";\n                }\n            }\n            bool x_l = false;\n            bool x_r = false;\n            int x_b = false;\n            int x_t = false;\n            if(distLeq(c[0], 0, c[1], 0, c[2]))\n            {\n                x_l = true;\n                x_b = true;\n            }\n            if(distLeq(c[0], X, c[1], Y, c[2]))\n            {\n                x_t = true;\n                x_r = true;\n            }\n            if(distLeq(c[0], X, c[1], 0, c[2]))\n            {\n                x_b = true;\n                x_r = true;\n            }\n            if(distLeq(c[0], 0, c[1], Y, c[2]))\n            {\n                x_l = true;\n                x_t = true;\n            }\n            if(c[0] >= 0 && c[0] <= X && distLeq(0, 0, c[1], 0, c[2]))\n            {\n                x_b = true;\n            }\n            if(c[0] >= 0 && c[0] <= X && distLeq(0, 0, c[1], Y, c[2]))\n            {\n                x_t = true;\n            }\n            if(c[1] >= 0 && c[1] <= Y && distLeq(0, c[0], 0, 0, c[2]))\n            {\n                x_l = true;\n            }\n            if(c[1] >= 0 && c[1] <= Y && distLeq(X, c[0], 0, 0, c[2]))\n            {\n                x_r = true;\n            }\n            if(x_r)\n            {\n                //cout << c_i << \" touches right\\n\";\n                adj[c_i].push_back(r);\n                adj[r].push_back(c_i);\n            }\n            if(x_l)\n            {\n                //cout << c_i << \" touches left\\n\";\n                adj[c_i].push_back(l);\n                adj[l].push_back(c_i);\n            }\n            if(x_t)\n            {\n                //cout << c_i << \" touches top\\n\";\n                adj[c_i].push_back(t);\n                adj[t].push_back(c_i);\n            }\n            if(x_b)\n            {\n                //cout << c_i << \" touches bottom\\n\";\n                adj[c_i].push_back(b);\n                adj[b].push_back(c_i);\n            }\n        }\n        auto canReach = [&adj](int s, unordered_set<int> t)\n        {\n            vector<bool> visited{adj.size(), allocator<bool>{}};\n            deque<int> q{};\n            q.push_back(s);\n            while(q.size())\n            {\n                int i = q.front();\n                q.pop_front();\n                if(visited[i]) continue;\n                if(t.count(i)) return true;\n                visited[i] = true;\n                for(int n : adj[i])\n                {\n                    q.push_back(n);\n                }\n            }\n            return false;\n        };\n        return !canReach(l, unordered_set<int>{b, r}) && !canReach(t, unordered_set<int>{r, b});\n    }\n};",
    "submit_ts": "1722138202",
    "subm_id": "1335784784"
}