{
    "username": "ch365",
    "submission": "#pragma region template\n\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n#include <array>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; --i)\n#define forab(i, a, b) for(int i=(a);i<(b);++i)\n#define fore(v, a) for(auto &v: a)\n#define sqr(x) ((x)*(x))\n#define clr(a, b) memset(a, b, sizeof(a))\n#define sz(a) ((int)a.size())\n#define all(a) (a).begin(),(a).end()\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef map<int,int> mii;\ntypedef map<int,string> mis;\ntypedef map<string,int> msi;\ntemplate <class T> using max_heap = priority_queue<T>;\ntemplate <class T> using min_heap = priority_queue<T, vector<T>, greater<>>;\nconst double eps = 1e-8;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / 2;\nint dcmp(double x) { if (x < -eps) return -1; else return x > eps;}\ntemplate <typename T> bool chmax(T &m, const T q) { return m < q ? (m = q, true) : false; }\ntemplate <typename T> bool chmin(T &m, const T q) { return m > q ? (m = q, true) : false; }\nconstexpr pii dx4[4] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\nconstexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\ntemplate <class T> using vc = vector<T>;\ntemplate <class T> using vvc = vector<vc<T>>;\ntemplate <class T> using vvvc = vector<vvc<T>>;\n#define minall(v) *min_element(all(v))\n#define maxall(v) *max_element(all(v))\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\n#define unq(x) sort(all(x)), x.erase(unique(all(x)), x.end())\nint popcnt(unsigned int x) { return __builtin_popcount(x); }\nint popcntll(unsigned long long x) { return __builtin_popcountll(x); }\ntemplate <class T, class U> ostream& operator<<(ostream& os, const pair<T, U>& p){ return os<<\"(\"<<p.fi<<\",\"<<p.se<<\")\"; }\nvoid see0(){ cout<<endl; }\ntemplate<class H, class ...T> void see0(H && h, T && ...t) { cout<<h<<\",\"; see0(t...); }\n\n#pragma endregion template\n\n#ifdef CHEN_PC\n#include \"lc-struct.h\"\n#define see(...) {cout<<__LINE__<<\": \"<<#__VA_ARGS__<<\" = \";see0(__VA_ARGS__);}\n#define seev(a) {cout<<__LINE__<<\": \"<<#a<<\" = [\"; fore(v, a)cout<<(v)<<\",\"; cout<<\"]\"<<endl;}\n#else\n#define see(...)\n#define seev(...)\n#endif\n\nconst int N = 30010;\nconst int mod = 1000000007; // 10^9+7\n\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n}\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    explicit lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\nusing F = int;\nstruct S { int v; int size; };\nS op(S x, S y) { return S{x.v + y.v, x.size + y.size}; }\nS e() { return S{0, 1}; }\nS mapping(F lz, S x) {\n\tS z = x;\n\tif (lz == 0) z.v = 0;\n\treturn z;\n}\nF composition(F lz2, F lz1) {\n\tF lz = 1;\n\tif (lz1 == 0 || lz2 == 0) lz = 0;\n\treturn lz; \n}\nF id() { return 1; }\nusing ST = atcoder::lazy_segtree<S, op, e, F, mapping, composition, id>;\n\n\n\nclass Solution {\npublic:\n\tvector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& q) {\n\t\tint m = sz(q);\n\t\tvc<S> a(n-1, S{1, 1});\n\t\tST seg(a);\n\t\tvi ans(m);\n\t\tforn (i, m) {\n\t\t\tint u = q[i][0];\n\t\t\tint v = q[i][1];\n\t\t\tsee(u, v);\n\t\t\tseg.apply(u+1, v, 0);\n\t\t\tauto val = seg.all_prod();\n\t\t\tans[i] = val.v;\n\t\t\tforn (j, n-1) see(j,seg.get(j).v);\n\t\t}\n\t\treturn ans;\n\t}\n};",
    "submit_ts": "1722740118",
    "subm_id": "552329366"
}