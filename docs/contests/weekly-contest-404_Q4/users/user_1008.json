{
    "username": "Cauxtic",
    "submission": "class Solution {\npublic:\n    pair<int, int> bfs(int start, const vector<vector<int>>& adj) {\n    int n = adj.size();\n    vector<int> dist(n, -1);\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n    int farthestNode = start;\n    \n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        \n        for (int neighbor : adj[node]) {\n            if (dist[neighbor] == -1) {\n                dist[neighbor] = dist[node] + 1;\n                q.push(neighbor);\n                if (dist[neighbor] > dist[farthestNode]) {\n                    farthestNode = neighbor;\n                }\n            }\n        }\n    }\n    return {dist[farthestNode], farthestNode};\n}\n\n// Function to find the diameter of the tree\nint findDiameter(const vector<vector<int>>& adj) {\n    auto [_, farthestNode] = bfs(0, adj);\n    auto [diameter, __] = bfs(farthestNode, adj);\n    return diameter;\n}\n\n// Function to find the central node of the tree\nint findCentralNode(const vector<vector<int>>& adj) {\n    int n = adj.size();\n    vector<int> degree(n, 0);\n    queue<int> q;\n    \n    // Calculate the degree of each node\n    for (int i = 0; i < n; ++i) {\n        degree[i] = adj[i].size();\n        if (degree[i] == 1) {\n            q.push(i);\n        }\n    }\n    \n    int remainingNodes = n;\n    int as = 0;\n    while (remainingNodes > 2) {\n        as++;\n        int leafCount = q.size();\n        remainingNodes -= leafCount;\n        for (int i = 0; i < leafCount; ++i) {\n            int leaf = q.front();\n            q.pop();\n            for (int neighbor : adj[leaf]) {\n                if (--degree[neighbor] == 1) {\n                    q.push(neighbor);\n                }\n            }\n        }\n    }\n    \n    // The remaining nodes in the queue are the central nodes\n    if(remainingNodes==2)\n        as++;\n    return as;\n}\n\nint minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n    int n = edges1.size() + 1;\n    int m = edges2.size() + 1;\n    \n    vector<vector<int>> adj1(n), adj2(m);\n    for (const auto& edge : edges1) {\n        adj1[edge[0]].push_back(edge[1]);\n        adj1[edge[1]].push_back(edge[0]);\n    }\n    for (const auto& edge : edges2) {\n        adj2[edge[0]].push_back(edge[1]);\n        adj2[edge[1]].push_back(edge[0]);\n    }\n    \n    int d1 = findDiameter(adj1);\n    int d2 = findDiameter(adj2);\n    \n    int c1 = findCentralNode(adj1);\n    int c2 = findCentralNode(adj2);\n   // cout << c1 << \" \" << c2 << endl;\n    int newDiameter = c1+c2 + 1;\n    return max({d1, d2, newDiameter});\n}\n};",
    "submit_ts": "1719718383",
    "subm_id": "1304415861"
}