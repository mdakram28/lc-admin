{
    "username": "OuterRidgeSavage",
    "submission": "class Solution {\npublic:\n    inline void fmin(int& x, int y) { if (x > y) x = y; }\n    int minimumCost(string t, vector<string>& w, vector<int>& c) {\n        int m = t.size();\n        int n = w.size();\n        \n        // construct a trie.\n        struct TrieNode {\n            int j = -1;\n            vector<TrieNode*> next = vector<TrieNode*>(26, nullptr);\n            TrieNode() {}\n        };\n        TrieNode trie;\n        for (int j = 0; j < n; ++j) {\n            TrieNode* p = &trie;\n            for (int c : w[j]) {\n                int ch = c - 'a';\n                if (p->next[ch] == nullptr) {\n                    p->next[ch] = new TrieNode();\n                }\n                p = p->next[ch];\n            }\n            if (p->j == -1 || c[j] < c[p->j]) {\n                p->j = j;\n            }\n        }\n        \n        // Dijkstra\n        vector<int> best(m, 1e9);\n        struct Node {\n            int i, cost;\n            Node(int _i, int _cost) : i(_i), cost(_cost) {}\n        };\n        vector<bool> done(m, false);\n        auto cmp = [](const Node& x, const Node& y) {\n            return x.cost > y.cost;\n        };\n        priority_queue<Node, vector<Node>, decltype(cmp)> q;\n        q.emplace(-1, 0);\n        while (!q.empty()) {\n            Node f = q.top();\n            q.pop();\n            // cout << \"f.i = \" << f.i << \", f.cost = \" << f.cost << endl;\n            if (f.i >= 0 && done[f.i]) continue;\n            if (f.i >= 0) done[f.i] = true;\n            if (f.i == m - 1) {\n                return f.cost;\n            }\n            TrieNode* p = &trie;\n            for (int i = f.i + 1; i < m; ++i) {\n                // cout << \"i = \" << i << endl;\n                int ch = t[i] - 'a';\n                if (p->next[ch] == nullptr) break;\n                p = p->next[ch];\n                // if (p->j != -1) {\n                //     cout << \"p->j = \" << p->j << \", \" << w[p->j] << endl;\n                // }\n                if (p->j != -1 && best[i] > f.cost + c[p->j]) {\n                    best[i] = f.cost + c[p->j];\n                    q.emplace(i, best[i]);\n                }\n            }\n        }\n        return -1;\n    }\n};",
    "submit_ts": "1720321906",
    "subm_id": "1312335448"
}