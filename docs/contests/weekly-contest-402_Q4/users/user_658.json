{
    "username": "warks",
    "submission": "class Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        PurqBiTree bit = new PurqBiTree(nums.length);\n        for (int i = 0; i < nums.length; i++) {\n            boolean isPeak = (i == 0 || nums[i] > nums[i - 1])\n                && (i == nums.length - 1 || nums[i] > nums[i + 1]);\n            \n            bit.add(i, isPeak ? 1 : 0);\n        }\n        \n        List<Integer> countOfPeaks = new ArrayList<>();\n        for (int[] query : queries) {\n            if (query[0] == 1) {\n                if (query[2] - query[1] < 2) {\n                    countOfPeaks.add(0);\n                } else {\n                    countOfPeaks.add(bit.rangeSum(query[1] + 1, query[2] - 1));\n                }\n            } else {\n                int i = query[1];\n                int newValue = query[2];\n                \n                boolean[] wasPeak = checkNeighbourhoodPeaks(nums, i);\n                nums[i] = newValue;\n                boolean[] isPeak = checkNeighbourhoodPeaks(nums, i);\n\n                if (i - 1 >= 0) {\n                    int delta = (wasPeak[0] ? -1 : 0) + (isPeak[0] ? 1 : 0);\n                    bit.add(i - 1, delta);\n                }\n\n                if (i + 1 <= nums.length - 1) {\n                    int delta = (wasPeak[2] ? -1 : 0) + (isPeak[2] ? 1 : 0);\n                    bit.add(i + 1, delta);\n                }\n\n                int delta = (wasPeak[1] ? -1 : 0) + (isPeak[1] ? 1 : 0);\n                bit.add(i, delta);\n            }\n        }\n\n        return countOfPeaks;\n    }\n    \n    private boolean[] checkNeighbourhoodPeaks(int[] nums, int i) {\n        return new boolean[] {\n            checkPeak(nums, i - 1),\n            checkPeak(nums, i),\n            checkPeak(nums, i + 1)\n        };\n    }\n    \n    private boolean checkPeak(int[] nums, int i) {\n        if (i < 0 || i == nums.length) {\n            return false;\n        } else {\n            return (i == 0 || nums[i] > nums[i - 1])\n                && (i == nums.length - 1 || nums[i] > nums[i + 1]);\n        }\n    }\n}\n\nclass PurqBiTree {\n    int arrayLength;\n    int[] tree;\n\n    PurqBiTree(int arrayLength) {\n        this.arrayLength = arrayLength;\n        tree = new int[arrayLength];\n    }\n\n    // returns sum over slice [0, right]\n    int rangeSum(int right) {\n        int sum = 0;\n        for (; right >= 0; right = (right & (right + 1)) - 1) {\n            sum += tree[right];\n        }\n        return sum;\n    }\n\n    // returns sum over slice [left, right]\n    int rangeSum(int left, int right) {\n        return rangeSum(right) - rangeSum(left - 1);\n    }\n\n    void add(int pos, int delta) {\n        for (; pos < arrayLength; pos = pos | (pos + 1)) {\n            tree[pos] += delta;\n        }\n    }\n}",
    "submit_ts": 1718508162.0
}