{
    "username": "heal",
    "submission": "template <class S>\nstruct SegTree {\n  static S op(const S& a, const S& b) { return a + b; }\n  static S e() { return S(); }\n\n  int n;\n  vector<S> seg;\n\n  SegTree(int n): n(n) {\n    seg.assign(n * 4, e());\n  }\n\n  SegTree(const vector<S> &a): SegTree(a.size() - 1) {\n    auto build = [&](auto build, int u, int l, int r) {\n      if (l == r) {\n        seg[u] = a[l];\n        return;\n      }\n      int mid = (l + r) / 2;\n      build(build, u << 1, l, mid);\n      build(build, u << 1 | 1, mid + 1, r);\n      seg[u] = op(seg[u<<1], seg[u<<1|1]);\n    };\n    build(build, 1, 1, n);\n  }\n\n  void set(int p, S x) {\n    auto update = [&](auto update, int u, int l, int r) {\n      if (l == r) {\n        seg[u] = x;\n        return;\n      }\n      int mid = (l + r) / 2;\n      if (p <= mid) update(update, u << 1, l, mid);\n      else update(update, u << 1 | 1, mid + 1, r);\n      seg[u] = op(seg[u<<1], seg[u<<1|1]);\n    };\n    update(update, 1, 1, n);\n  }\n\n  S get(int p) const {\n    auto query = [&](auto query, int u, int l, int r) {\n      if (l == r) return seg[u];\n      int mid = (l + r) / 2;\n      return p <= mid?\n        query(query, u << 1, l, mid): query(query, u << 1 | 1, mid + 1, r);\n    };\n    return query(query, 1, 1, n);\n  }\n\n  S prod(int s, int t) const {\n    auto query = [&](auto query, int u, int l, int r) {\n      if (s <= l && r <= t) return seg[u];\n      int mid = (l + r) / 2;\n      if (t <= mid) return query(query, u << 1, l, mid);\n      if (s > mid) return query(query, u << 1 | 1, mid + 1, r);\n      return op(query(query, u << 1, l, mid), query(query, u << 1 | 1, mid + 1, r));\n    };\n    return query(query, 1, 1, n);\n  }\n\n  int max_right(int s, function<bool(S)> f) const {\n    S pre = e();\n    auto query = [&](auto query, int u, int l, int r) {\n      if (s <= l && f(op(pre, seg[u]))) {\n        pre = op(pre, seg[u]);\n        return r;\n      }\n      if (l == r) return l - 1;\n      int mid = (l + r) / 2;\n      if (s <= mid) {\n        int t = query(query, u << 1, l, mid);\n        if (t < mid) return t;\n      }\n      return query(query, u << 1 | 1, mid + 1, r);\n    };\n    return query(query, 1, 1, n);\n  }\n\n  int min_left(int t, function<bool(S)> f) const {\n    S suf = e();\n    auto query = [&](auto query, int u, int l, int r) {\n      if (r <= t && f(op(seg[u], suf))) {\n        suf = op(seg[u], suf);\n        return l;\n      }\n      if (l == r) return r + 1;\n      int mid = (l + r) / 2;\n      if (t > mid) {\n        int s = query(query, u << 1 | 1, mid + 1, r);\n        if (s > mid + 1) return s;\n      }\n      return query(query, u << 1, l, mid);\n    };\n    return query(query, 1, 1, n);\n  }\n};\n\nstruct Info {\n    int cnt;\n    long long sum;\n    Info(int c = 0, long long s = 0): cnt(c), sum(s) {};\n    Info operator+(const Info &o) const {\n        return Info{cnt + o.cnt, sum + o.sum};\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {\n        int n = colors.size();\n        map<int, int> mp;\n        SegTree<Info> sgt(n);\n        auto add = [&](int l, int r) {\n            mp[l] = r;\n            int w = r - l + 1;\n            auto s = sgt.get(w);\n            s.cnt++, s.sum += w;\n            sgt.set(w, s);\n        };\n        auto del = [&](int l, int r) {\n            int w = r - l + 1;\n            auto s = sgt.get(w);\n            s.cnt--, s.sum -= w;\n            sgt.set(w, s);\n        };\n        for (int i = 0; i < n; i++) {\n            int j = i + 1;\n            while (j < n && colors[j] != colors[j-1]) j++;\n            add(i, j - 1);\n            i = j - 1;\n        }\n        vector<int> ret;\n        for (auto &q: queries) {\n            if (q[0] == 1) {\n                int w = q[1];\n                auto s = sgt.prod(w, n);\n                int tot = s.sum - (w - 1LL) * s.cnt;\n                if (colors[n-1] != colors[0]) {\n                    int x = mp.rbegin()->second - mp.rbegin()->first + 1;\n                    int y = mp.begin()->second - mp.begin()->first + 1;\n                    if (x + y >= w) {\n                        tot += min(w - 1, y) - max(w - x, 1) + 1;\n                    }\n                }\n                ret.emplace_back(tot);\n            } else {\n                int i = q[1], c = q[2];\n                if (c == colors[i]) continue;\n                colors[i] = c;\n                auto it = mp.lower_bound(i);\n                if (it != mp.begin()) it--;\n                while (it != mp.end()) {\n                    if (it->second < i - 1) {\n                        it++;\n                        continue;\n                    }\n                    if (it->second == i - 1) {\n                        int s = it->first;\n                        del(it->first, it->second);\n                        mp.erase(it++);\n                        int t = it->second;\n                        del(it->first, it->second);\n                        mp.erase(it++);\n                        if (it == mp.end() || it->first != i + 1) {\n                            add(s, i);\n                            if (t > i) add(i + 1, t);\n                        } else {\n                            t = it->second;\n                            del(it->first, it->second);\n                            mp.erase(it++);\n                            add(s, t);\n                        }\n                        break;\n                    }\n                    if (it->second == i) {\n                        int s = it->first;\n                        del(it->first, it->second);\n                        mp.erase(it++);\n                        if (it != mp.end()) {\n                            int t = it->second;\n                            del(it->first, it->second);\n                            mp.erase(it++);\n                            add(i, t);\n                        } else {\n                            add(i, i);\n                        }\n                        if (s < i) add(s, i - 1);\n                        break;\n                    }\n                    if (it->first > i) break;\n                    if (it->first == i) {\n                        assert(i == 0);\n                        int t = it->second;\n                        del(it->first, it->second);\n                        mp.erase(it++);\n                        add(i, i);\n                        if (t > i) add(i + 1, t);\n                        break;\n                    }\n                    assert(it->first < i && it->second > i);\n                    int s = it->first,  t = it->second;\n                    del(it->first, it->second);\n                    add(s, i - 1), add(i, i), add(i + 1, t);\n                    break;\n                }\n            }\n        }\n        return ret;\n    }\n};",
    "submit_ts": "1722742949",
    "subm_id": "552347873"
}