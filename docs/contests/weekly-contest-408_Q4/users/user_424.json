{
    "username": "ajsingh176",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n#define repi(i, a, b) for(int i=a; i<b; i++)\n#define rrepi(i, a, b) for(int i=a; i>=b; i--)\ntypedef vector<ll> vl;\ntypedef pair<ll,ll> pl;\n#define pb push_back\n#define eb emplace_back\n#define all(o) (o).begin(), (o).end()\n#define repl(i, a, b) for(ll i=a; i<b; i++)\n#define rrepl(i, a, b) for(ll i=a; i>=b; i--)\n#define srt(a) sort(a.begin(), a.end());\n#define rsrt(a) sort(a.rbegin(), a.rend());\n#define rev(a) reverse(a.begin(), a.end());\n#define ub(a,b) upper_bound(a.begin(), a.end(), b);\n#define lb(a,b) lower_bound(a.begin(), a.end(), b);\n#define mod(n) (((ll)n%1000000007+1000000007)%1000000007)\nconst int Z=998244353;\nconst int N=5e5+10;\n\nclass Solution {\npublic:\n    int bfs(vector<vector<int>> &g, int source, int X, int Y, int nodes) {\n        queue<int> q;\n        vector<int> vis(nodes + 4, 0);\n        q.push(source);\n        vis[source]=1;\n        \n        while(!q.empty()){\n            int u=q.front();\n            q.pop();\n            for(int v: g[u]){\n                if(!vis[v]){\n                    q.push(v);\n                    vis[v]=1;\n                }\n            }\n        }\n        return vis[X] || vis[Y];\n    }\n        \n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n=circles.size();\n        vector<pair<pi, int>> nc(n);\n        vector<vi> g(n+4);\n        int m=n;\n        repi(i,0,m){\n            nc[i].first.first=circles[i][0];\n            nc[i].first.second=circles[i][1];\n            nc[i].second=circles[i][2];\n        }\n        repi(i,0,m){ \n            if(nc[i].first.first<=nc[i].second){\n                g[m].push_back(i);\n                g[i].push_back(m);\n            }\n            if(X-nc[i].first.first<=nc[i].second) {\n                g[m+2].push_back(i);\n                g[i].push_back(m+2);\n            }\n            if(nc[i].first.second<=nc[i].second){\n                g[m+1].push_back(i);\n                g[i].push_back(m+1);\n            }\n            if(Y-nc[i].first.second<=nc[i].second){\n                g[m+3].push_back(i);\n                g[i].push_back(m+3);\n            }\n            repi(j,i+1,m){\n                double distance=sqrt(pow(nc[i].first.first-nc[j].first.first, 2)+\n                                        pow(nc[i].first.second-nc[j].first.second, 2));\n                int radius_sum=nc[i].second+nc[j].second;\n                if (radius_sum>=distance){\n                    g[i].push_back(j);\n                    g[j].push_back(i);\n                }\n            }\n        }\n        \n        int flag=0;\n        flag=max(flag, bfs(g, m, m+1, m+2, m+4)); \n        flag=max(flag, bfs(g, m+3, m+2, m+1, m+4));\n        if(flag) return false;\n        return true; \n    }\n};",
    "submit_ts": "1722137084",
    "subm_id": "1335753689"
}