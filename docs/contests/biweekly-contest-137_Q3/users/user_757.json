{
    "username": "nullie",
    "submission": "impl Solution {\n    pub fn maximum_value_sum(board: Vec<Vec<i32>>) -> i64 {\n        let width = board[0].len();\n\n        let mut memo = vec![vec![vec![None; width + 1]; width + 1]; board.len()];\n        recurse(&mut memo, 0, None, None, &board)\n    }\n}\n\nfn recurse(memo: &mut [Vec<Vec<Option<i64>>>], r: usize, first: Option<usize>, second: Option<usize>, board: &[Vec<i32>]) -> i64 {\n    if r == board.len() {\n        return i64::MIN;\n    }\n    \n    let a = first.map_or(0, |first| first + 1);\n    let b = second.map_or(0, |second| second + 1);\n    \n    let stored = memo[r][a][b];\n    \n    if let Some(stored) = stored.as_ref().copied() {\n        return stored\n    }\n    \n    let mut result = recurse(memo, r + 1, first, second, board);\n\n    for (col, &val) in board[r].iter().enumerate() {\n        let val = val as i64;\n\n        if let Some(second) = second {\n            if first.unwrap() != col && second != col {\n                result = result.max(val);\n            }\n        } else if let Some(first) = first {\n            if first != col {\n                let next = recurse(memo, r + 1, Some(first), Some(col), board);\n                if next != i64::MIN {\n                    result = result.max(val + next);\n                }\n            }\n        } else {\n            let next = recurse(memo, r + 1, Some(col), None, board);\n            if next != i64::MIN {\n                result = result.max(val + next);\n            }\n        }\n    }\n    \n    memo[r][a][b] = Some(result);\n    \n    result\n}",
    "submit_ts": "1723908187",
    "subm_id": "1359141902"
}