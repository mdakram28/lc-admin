{
    "username": "winterwarmth",
    "submission": "#include <bits/stdc++.h>\n#define fastIO                      \\\n  ios_base::sync_with_stdio(false); \\\n  cin.tie(nullptr)\nusing namespace std;\n#pragma GCC optimize(\"O3,unroll-loops\")\n#define ll long long\n#define ld long double\n#define pii pair<ll, ll>\n#define mp make_pair\n#define f first\n#define s second\n#define pb push_back\n#define rep(i, a, b) for (int i = a; i < b; i++)\nclass Solution {\npublic:\n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vector<vector<int>> adj(n);\n        for (auto& edge: edges) {\n            int u = edge[0], v = edge[1];\n            adj[u].pb(v);\n            adj[v].pb(u);\n        }\n        vector<int> times(n), first(n), second(n), child(n);\n            int mx = 0;\n             function<void(int, int)> dfs = [&](int node, int par) {\n                first[node] = 0;\n                second[node] = 0;\n                for (auto nei : adj[node]) {\n                  if (nei == par) continue;\n                  dfs(nei, node);\n                    int k = (nei % 2 == 0) ?  2 :  1;\n                  if (first[nei] + k > first[node]) {  // f[x]\n                    second[node] = first[node];\n                    first[node] = first[nei] + k;\n                    child[node] = nei;\n                  } else if (first[nei] + k > second[node])\n                    second[node] = first[nei] + k;\n                }\n              };\n        \n        dfs(0, -1);\n\n        vector<int> ans(n);\n        ans[0] = first[0];\n        function<void(int, int)> dfs2 = [&](int node, int par) {\n            int k = (node % 2 == 0 ? 2 : 1);\n        for (auto nei : adj[node]) {\n          if (nei == par) continue;\n          if (nei == child[node]) {               // reroot to this max nei\n            if (first[nei] < second[node] + k) {  // g(4) = g(3) + 1\n              second[nei] = first[nei];\n              first[nei] = second[node] + k;\n              child[nei] = node;  // node is now max nei of the new nei\n            } else {              // g(4) = h(3) + 1\n              second[nei] = max(second[nei], second[node] + k);\n            }\n          } else {  // reroot to non-max nei\n            second[nei] = first[nei];\n            first[nei] = first[node] + k;  // g(4) = f(3) + k\n            child[nei] = node;\n          }\n            dfs2(nei, node);\n            }\n        };\n\n        dfs2(0, -1);\n        \n        return first;\n    }\n};",
    "submit_ts": "1722700318",
    "subm_id": "1343238223"
}