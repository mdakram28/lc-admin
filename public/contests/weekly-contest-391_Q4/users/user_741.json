{
    "username": "legobridge",
    "submission": "def find_pe(points):\n    possible_extremes = [(points[0][0], points[0][1])] * 4\n    for x, y in points:\n        if x + y > possible_extremes[0][0] + possible_extremes[0][1]:\n            possible_extremes[0] = (x, y)\n        if x - y > possible_extremes[1][0] - possible_extremes[1][1]:\n            possible_extremes[1] = (x, y)\n        if -x + y > -possible_extremes[2][0] + possible_extremes[2][1]:\n            possible_extremes[2] = (x, y)\n        if -x - y > -possible_extremes[3][0] - possible_extremes[3][1]:\n            possible_extremes[3] = (x, y)\n    print(possible_extremes)\n    return possible_extremes\n\ndef create_list_except(points, to_rem):\n    nl = []\n    for x, y in points:\n        if (x, y) != to_rem:\n            nl.append([x, y])\n        else:\n            to_rem = None\n    return nl\n\ndef diam(points):\n    possible_extremes = find_pe(points)\n    mmd = 0 \n    for i in range(4):\n        for x, y in points:\n            new_mmd = abs(possible_extremes[i][0] - x) + abs(possible_extremes[i][1] - y)\n            if new_mmd > mmd:\n                mmd = new_mmd\n    return mmd\n\nclass Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        possible_extremes = find_pe(points)\n        mmd = 0 \n        suspects = None\n        for i in range(4):\n            for x, y in points:\n                new_mmd = abs(possible_extremes[i][0] - x) + abs(possible_extremes[i][1] - y)\n                if new_mmd > mmd:\n                    mmd = new_mmd\n                    suspects = [possible_extremes[i], (x, y)]\n        print(mmd, suspects)\n        \n        if suspects is None:\n            return 0\n        \n        new_list_1 = create_list_except(points, suspects[0])\n        new_list_2 = create_list_except(points, suspects[1])\n        return min(diam(new_list_1), diam(new_list_2))\n"
}