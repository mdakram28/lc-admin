{
    "username": "SR3mix",
    "submission": "// Z Mod Long Long\ntypedef long long ll;\nll M = 1e9 + 7;\nconst long long PrimeMod = M;\nstruct MLL\n{\n    long long x;\n    MLL(long long init_val = 0)\n    {\n        assert(init_val >= 0);\n        x = init_val % PrimeMod;\n    }\n    long long val() {\n        return x;\n    }\n    MLL power(long long exponent) {\n        MLL res = 1, a = x; \n        long long b = exponent;\n        for (; b; b /= 2, a *= a) {\n            if (b % 2) {\n                res *= a;\n            }\n        }\n        return res;\n    }\n    MLL inv() {\n        return power(PrimeMod - 2);\n    }\n    long long norm(long long v) {\n        if (v < 0) v += PrimeMod;\n        else if (v >= PrimeMod) v -= PrimeMod;\n        assert(v >= 0 && v < PrimeMod);\n        return v;\n    } \n    MLL &operator+=(MLL rhs) &{\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    MLL &operator-=(MLL rhs) &{\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    MLL &operator*=(MLL rhs) &{\n        x = (x * rhs.x)%PrimeMod;\n        return *this;\n    }\n    MLL &operator/=(MLL rhs) &{\n        x = (x * rhs.inv().x)%PrimeMod;\n        return *this;\n    }\n    friend MLL operator+(MLL lhs, MLL rhs)\n    {\n        MLL res = lhs; res += rhs;\n        return res;\n    }\n    friend MLL operator-(MLL lhs, MLL rhs)\n    {\n        MLL res = lhs; res -= rhs;\n        return res;\n    }\n    friend MLL operator*(MLL lhs, MLL rhs)\n    {\n        MLL res = lhs; res *= rhs;\n        return res;\n    }\n    friend MLL operator/(MLL lhs, MLL rhs) {\n        MLL res = lhs; res /= rhs;\n        return res;\n    }\n    friend bool operator==(MLL lhs, MLL rhs) {\n        return lhs.x == rhs.x;\n    }\n    friend bool operator!=(MLL lhs, MLL rhs) {\n        return lhs.x != rhs.x;\n    }\n    friend std::istream &operator>>(std::istream &is, MLL &a) {\n        long long v; is >> v;\n        a = MLL(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, MLL &a) {\n        return os << a.val();\n    }\n};\nusing Z = MLL;\nZ Zpowxy(long long a, long long b) {\n    Z x = a;\n    return x.power(b);\n}\nlong long int powxy(long long int x, long long int y, long long M) {\n    if (y == 0) return 1;\n    if (y%2 == 1) return (x*powxy(x, y-1, M))%M;\n    long long int t = powxy(x, y/2, M);\n    return (t*t)%M;\n}\n// CREDIT TO JIANGLY FOR THIS TEMPLATE -> https://codeforces.com/profile/jiangly\nclass Solution {\npublic:\n    int numberOfPermutations(int n, vector<vector<int>>& r) {\n        \n        //vector<vector<Z>>dp(n, vector<Z>(n));\n        sort(r.begin(), r.end());\n        int ma = 0;\n        for (auto &i : r) ma = max(ma,i[1]);\n        vector<vector<Z>>dp(n, vector<Z>(ma + 1));\n        for (int i = 0; i < r.size(); i++) {\n            ll ma = ((r[i][0] + 1) * (r[i][0]))/2;\n            if (r[i][1] > ma) return 0;\n        }\n        dp[0][0] = 1;\n        vector<int>reqs(n,-1);\n        for (auto &i : r) {\n            reqs[i[0]] = i[1];\n        }\n        for (int i = 1; i < n; i++) {\n            ll pre = i;\n            for (int j = 0; j <= ma; j++) {\n                for (int add = 0; add <= min(i,j); add++) {\n                    dp[i][j] += dp[i-1][j-add];\n                }   \n                if (reqs[i] != -1 && reqs[i] != j) dp[i][j] = 0;\n            }\n        }\n        Z ans = 0;\n        for (auto i : dp.back()) ans += i;\n        return ans.x;\n    }\n};",
    "submit_ts": "1719067903",
    "subm_id": "1296745283"
}