{
    "username": "kumarapoorv617",
    "submission": "template<class T>\nstruct RMQ{\n    int n, logn;\n    vector<vector<int>> b;\n    vector<T> A;\n    void build(const vector<T> &a) {\n        A = a, n = (int)a.size();\n        logn = 32 - __builtin_clz(n);\n        b.resize(logn, vector<int>(n));\n        iota(b[0].begin(), b[0].end(), 0);\n        for(int i = 1; i < logn ; i++){\n            for(int j = 0; j < n ; j++){\n                b[i][j] = b[i - 1][j];\n                if(j + (1 << (i - 1)) < n && A[b[i - 1][j + (1 << (i - 1))]] < A[b[i][j]])\n                    b[i][j] = b[i - 1][j + (1 << (i - 1))];\n            }\n        }\n    }\n    int rangeMin(int x, int y){\n        int k = 31 - __builtin_clz(y - x + 1);\n        return min(A[b[k][x]], A[b[k][y - (1 << k) + 1]]);\n    }\n    int minIndx(int x, int y){\n        int k = 31 - __builtin_clz(y - x + 1);\n        return A[b[k][x]] < A[b[k][y - (1 << k) + 1]] ? b[k][x] : b[k][y - (1 << k) + 1];\n    }\n};\n\nstruct LCA {\n    vector<int> tour, Findx, dpth;\n    RMQ<int> rmq;\n    void build(const vector<vector<int>> &adj, int src = 0) {\n        vector<bool> vis((int)adj.size());\n        vector<int> dpth1((int)adj.size());\n        function<void(int, int)> dfs = [&](int i, int d) {\n            tour.push_back(i);\n            vis[i] = 1;\n            dpth1[i] = d;\n            for(auto &u: adj[i]) if(!vis[u])    dfs(u, d + 1), tour.push_back(i);\n        };\n        dfs(src, 0);\n        Findx.resize((int)adj.size());\n        dpth.resize((int)tour.size());\n        for(int i = (int)tour.size() - 1 ; i >= 0 ; i--) {\n            dpth[i] = dpth1[tour[i]], Findx[tour[i]] = i;\n        }\n        rmq.build(dpth);\n    }\n    int lca(int x, int y) {\n        x = Findx[x], y = Findx[y];\n        if(x > y)     swap(x, y);\n        return tour[rmq.minIndx(x, y)];\n    }\n    int dist(int x, int y) {\n        x = Findx[x], y = Findx[y];\n        if(x > y)     swap(x, y);\n        return dpth[x] + dpth[y] - 2 * rmq.rangeMin(x, y);\n    }\n};\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int N = edges1.size() + 1, M = edges2.size() + 1;\n        vector<vector<int>> adj(N), bdj(M);\n        for(auto &v: edges1) {\n            int l = v[0], r = v[1];\n            adj[l].push_back(r);\n            adj[r].push_back(l);\n        }\n        for(auto &v: edges2) {\n            int l = v[0], r = v[1];\n            bdj[l].push_back(r);\n            bdj[r].push_back(l);\n        }\n\n        auto dia = [&](vector<vector<int>> &adj) {\n            int n = adj.size();\n            LCA lc; lc.build(adj);\n            int a = 0;\n            for(int i = 0 ; i < n ; ++i) {\n                if(lc.dist(0, i) > lc.dist(0, a)) {\n                    a = i;\n                }\n            }\n            int b = 0;\n            for(int i = 0 ; i < n ; ++i) {\n                if(lc.dist(a, i) > lc.dist(b, a)) {\n                    b = i;\n                }\n            }\n            return lc.dist(a, b);\n        };\n\n        int x = dia(adj);\n        int y = dia(bdj);\n\n        return max({x, y, (x + 1) / 2 + (y + 1) / 2 + 1});\n    }\n};",
    "submit_ts": 1719715661.0
}