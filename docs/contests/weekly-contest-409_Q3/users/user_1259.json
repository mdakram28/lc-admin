{
    "username": "competent-6ermainmsk",
    "submission": "class SegmentTree:\n    def __init__(self, nums: list[int]):\n        self.n = len(nums)\n        self.nums = nums\n        self.tree = [0] * (4 * self.n)\n        self.mark = [0] * (4 * self.n)\n        self.build(0, 0, self.n - 1)\n\n    def build(self, p: int, left: int, right: int):\n        if left == right:\n            self.tree[p] = self.nums[left]\n            return\n        mid = (left + right) // 2\n        self.build(2 * p + 1, left, mid)\n        self.build(2 * p + 2, mid + 1, right)\n        self.tree[p] = self.tree[2 * p + 1] + self.tree[2 * p + 2]\n\n    # \u5c06 [l, r] \u533a\u95f4\u7684\u5143\u7d20\u503c\u52a0\u4e0a val\n    def update(self, l: int, r: int, val: int):\n        self.update_helper(0, 0, self.n - 1, l, r, val)\n\n    def update_helper(self, p: int, left: int, right: int, l: int, r: int, val: int):\n        if left >= l and right <= r:\n            self.tree[p] += val * (right - left + 1)\n            self.mark[p] += val\n            return\n        mid = (left + right) // 2\n        self.push_down(p, left, right)\n        if l <= mid:\n            self.update_helper(2 * p + 1, left, mid, l, r, val)\n        if r > mid:\n            self.update_helper(2 * p + 2, mid + 1, right, l, r, val)\n        self.tree[p] = self.tree[2 * p + 1] + self.tree[2 * p + 2]\n\n    # \u67e5\u8be2 [l, r] \u533a\u95f4\u7684\u5143\u7d20\u548c\n    def query(self, l: int, r: int) -> int:\n        return self.query_helper(0, 0, self.n - 1, l, r)\n\n    def query_helper(self, p: int, left: int, right: int, l: int, r: int) -> int:\n        if l <= left and right <= r:\n            return self.tree[p]\n        mid = (left + right) // 2\n        self.push_down(p, left, right)\n        res = 0\n        if l <= mid:\n            res += self.query_helper(2 * p + 1, left, mid, l, r)\n        if r > mid:\n            res += self.query_helper(2 * p + 2, mid + 1, right, l, r)\n        return res\n\n    def push_down(self, p: int, left: int, right: int):\n        if self.mark[p]:\n            mid = (left + right) // 2\n            self.tree[2 * p + 1] += self.mark[p] * (mid - left + 1)\n            self.tree[2 * p + 2] += self.mark[p] * (right - mid)\n            self.mark[2 * p + 1] += self.mark[p]\n            self.mark[2 * p + 2] += self.mark[p]\n            self.mark[p] = 0\n\nfrom sortedcontainers import SortedList\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        f = list(range(n))\n        A = SegmentTree(f)\n\n        nodes = SortedList([])\n        dic = Counter()\n        ans = []\n        for u, v in queries:\n            fu = A.query(u, u)\n            fv = A.query(v, v)\n            if fu + 1 < fv:\n                index = bisect.bisect(nodes, v)\n                right = n - 1 if index == len(nodes) else nodes[index]\n                if right in dic and dic[right] <= u:\n                    ans.append(A.query(n - 1, n - 1))\n                    continue\n                diff = fu + 1 - fv\n                A.update(v, n - 1, diff)\n                nodes.add(v)\n                if v in dic:dic[v] = min(dic[v], u)\n                else: dic[v] = u\n            ans.append(A.query(n - 1, n - 1))\n        \n        return ans",
    "submit_ts": "1722743617",
    "subm_id": "552351840"
}