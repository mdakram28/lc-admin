{
    "username": "nithish_654",
    "submission": "#define ll long long\nclass SegmentTree{\n        vector<ll> segTree, lazy;\n        int n; vector<int> v;\n        // building segment tree\n        void build(int l, int h, int i){\n            if(l == h){\n                int x = 0;\n                if(l > 0 && l < n - 1 && v[l] > v[l - 1] && v[l] > v[l + 1]) x = 1;\n                segTree[i] = x;\n                return;\n            }\n            int mid = (l+h)/2;\n            build(l, mid, 2*i+1);\n            build(mid + 1, h, 2*i+2);\n            segTree[i] = segTree[2*i+1] + segTree[2*i+2];\n            // segTree[i] = max(segTree[2*i+1], segTree[2*i+2]);\n        }\n\n        // updating (or) increasing value at index idx in the array with val \n        void update(int i, int l, int h, int val, int idx){\n            if(l == h){\n                //segTree[i] += val; // increasing by val\n                int x = 0;\n                if(l > 0 && l < n - 1 && v[l] > v[l - 1] && v[l] > v[l + 1]) x = 1;\n                segTree[i] = x; // replacing  by val\n                return;\n            }\n            int mid = (l+h)/2;\n            if(idx <= mid) update(2*i + 1, l, mid, val, idx);\n            else update(2*i + 2, mid+1, h, val, idx);\n            segTree[i] = segTree[2*i + 1] + segTree[2*i + 2];\n            // segTree[i] = max(segTree[2*i+1], segTree[2*i+2]);\n        }\n\n\n        // sum in range l->r [l, r]\n        // max in range l->r [l, r]\n        int rangeQuery(int i, int low, int high, int l, int r){\n            if(low >= l && high <= r) return segTree[i];\n            // if(low > r || high < l) return 0; \n            if(low > r || high < l) return 0;\n            int mid = (low + high)/2;\n            int left = rangeQuery(2*i + 1, low, mid, l, r);\n            int right = rangeQuery(2*i + 2, mid + 1, high, l, r);\n            return (left + right);  \n            // return max(left, right);\n            //return max(rangeQuery(low, mid, l, r, 2*i+1), rangeQuery(mid + 1, high, l, r, 2*i+2));\n        }\n\n    public:\n        SegmentTree(int n){\n            this->n = n;\n            segTree.resize(4*n);\n            lazy.resize(4*n);\n            fill(segTree.begin(), segTree.end(), 0ll);\n            fill(lazy.begin(), lazy.end(), 0ll);\n        }\n\n        void build(vector<int>& v){\n            this->v = v;\n            build(0, n - 1, 0);\n        }\n\n        // idx -> 0 based indexing\n        void update(int idx, int val){\n            v[idx] = val;\n            update(0, 0, n - 1, val, idx);\n            if(idx > 0) update(0, 0, n - 1, v[idx - 1], idx - 1);\n            if(idx < n - 1) update(0, 0, n - 1, v[idx + 1], idx + 1);\n\n        }\n\n        // l->r [l, r] 0-based indexing\n        int rangeQuery(int l, int r){\n            return rangeQuery(0, 0, n - 1, l, r);\n        }\n    \n\n};\n\nclass Solution {\npublic:\n    \n    // 1 <= nums[i] <= 1e5\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        \n        SegmentTree seg(n);\n        seg.build(nums);\n        \n        vector<int> ans;\n        for(int i = 0; i < queries.size(); i++){\n            int t = queries[i][0], a = queries[i][1], b = queries[i][2];\n            if(t == 1){\n                int x = seg.rangeQuery(a, b);\n                if(a > 0 && a < n - 1 && nums[a] > nums[a - 1] && nums[a] > nums[a + 1]) x--;\n                if(a < b && b > 0 && b < n - 1 && nums[b] > nums[b - 1] && nums[b] > nums[b + 1]) x--;\n                ans.push_back(x);\n            }else{\n                seg.update(a, b);\n                nums[a] = b;\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1718508953",
    "subm_id": "1289695465"
}