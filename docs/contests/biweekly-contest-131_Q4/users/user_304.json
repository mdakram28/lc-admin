{
    "username": "Krypton99",
    "submission": "// segtree referenced from dreamoon\nconst int SEG_SIZE = 1 << 18;\ntypedef struct D{\n    int mx;\n    int l;\n    int r;\n    bool bar_l, bar_r, bar_in;\n    D(){\n        mx = 0, l = 0, r = 0, bar_l = bar_r = bar_in = 0;\n    }\n}D;\nusing Data = D;\nusing Qdata = int;\nstruct Seg{\n    Data node[SEG_SIZE];\n    Data merge(const Data &A, const Data &B) {\n        D tmp;\n        if(A.bar_r || B.bar_l){\n            tmp.l = A.l;\n            tmp.r = B.r;\n            tmp.mx = max(A.mx, B.mx);\n            tmp.bar_l = A.bar_l;\n            tmp.bar_r = B.bar_r;\n            tmp.bar_in = 1;\n            //cout << A.mx << ' ' << B.mx << '\\n';\n        }else{\n            if(!A.bar_in) tmp.l = A.l + B.l;\n            else tmp.l = A.l;\n            if(!B.bar_in) tmp.r = A.r + B.r;\n            else tmp.r = B.r;\n            tmp.mx = max({A.mx, B.mx, A.r + B.l});\n            tmp.bar_l = A.bar_l;\n            tmp.bar_r = B.bar_r;\n            tmp.bar_in = A.bar_in | B.bar_in;\n            \n        }\n        return tmp;\n    }\n    void pull(int id) {\n        node[id] = merge(node[id * 2], node[id * 2 + 1]);\n    }\n    void init(int L, int R, int id, vector<Data> &input) {\n        if(L == R){\n            node[id] = input[L];\n            return;\n        }\n        int mm = (L + R) / 2;\n        init(L, mm, id * 2, input);\n        init(mm + 1, R, id * 2 + 1, input);\n        pull(id);\n    }\n    Data qq(int L, int R, int id, int l, int r) {\n        if(L >= l && R <= r) return node[id];\n        int mm = (L + R) / 2;\n        if(r <= mm) return qq(L, mm, id * 2, l, r);\n        if(l > mm) return qq(mm + 1, R, id * 2 + 1, l, r);\n        return merge(qq(L, mm, id * 2, l, r), qq(mm + 1, R, id * 2 + 1, l, r));\n    }\n    void upd(int L, int R, int id, int p, Data v) {\n        if(L == R) {\n            node[id] = v;\n            return;\n        }\n        int mm = (L + R) / 2;\n        if(p <= mm) { upd(L, mm, id * 2, p, v); }\n        else { upd(mm + 1, R, id * 2 + 1, p, v); }\n        pull(id);\n    }\n    \n}seg;\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector<D> a(50006);\n        for(int i = 1; i <= 50005; ++i){\n            a[i].l = a[i].r = a[i].mx = 1;\n        }\n        seg.init(1,50005,1,a);\n        vector<bool> res;\n        for(auto x : queries){\n            if(x[0] == 1){\n                int pos = x[1];\n                D tmp;\n                tmp.r = tmp.l = tmp.mx = 1;\n                tmp.bar_r = 1;\n                seg.upd(1,50005,1,pos,tmp);\n                //cout << seg.qq(1,50005,1,1,2).mx << ' ';\n            }else{\n                int pos = x[1];\n                \n                int sz = x[2];\n                int mx = seg.qq(1,50005,1,1,pos).mx;\n                //cout << mx << ' ';\n                if(mx >= sz) res.push_back(1);\n                else res.push_back(0);\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1716652244.0
}