{
    "username": "Savior7",
    "submission": "import java.util.*;\n\nclass Solution {\n    static class Pair<K, V> {\n        public K first;\n        public V second;\n\n        public Pair(K first, V second) {\n            this.first = first;\n            this.second = second;\n        }\n    }\n// Java program to print DFS traversal\n// // from a given graph\n// import java.io.*;\n// import java.util.*;\n\n// // This class represents a\n// // directed graph using adjacency\n// // list representation\n// class Graph {\n//     private int V;\n\n//     // Array  of lists for\n//     // Adjacency List Representation\n//     private LinkedList<Integer> adj[];\n\n//     // Constructor\n//     @SuppressWarnings(\"unchecked\") Graph(int v)\n//     {\n//         V = v;\n//         adj = new LinkedList[v];\n//         for (int i = 0; i < v; ++i)\n//             adj[i] = new LinkedList();\n//     }\n\n//     // Function to add an edge into the graph\n//     void addEdge(int v, int w)\n//     {\n//         // Add w to v's list.\n//         adj[v].add(w);\n//     }\n\n//     // A function used by DFS\n//     void DFSUtil(int v, boolean visited[])\n//     {\n//         // Mark the current node as visited and print it\n//         visited[v] = true;\n//         System.out.print(v + \" \");\n\n//         // Recur for all the vertices adjacent to this\n//         // vertex\n//         Iterator<Integer> i = adj[v].listIterator();\n//         while (i.hasNext()) {\n//             int n = i.next();\n//             if (!visited[n])\n//                 DFSUtil(n, visited);\n//         }\n//     }\n\n//     // The function to do DFS traversal.\n//     // It uses recursive DFSUtil()\n//     void DFS(int v)\n//     {\n//         // Mark all the vertices as\n//         // not visited(set as\n//         // false by default in java)\n//         boolean visited[] = new boolean[V];\n\n//         // Call the recursive helper\n//         // function to print DFS\n//         // traversal\n//         DFSUtil(v, visited);\n//     }\n\n    \n// }\n    public int bfs(List<List<Integer>> graph, int start, int target1, int target2, int nodes) {\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] visited = new boolean[nodes + 4];\n        queue.add(start);\n        visited[start] = true;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (int v : graph.get(u)) {\n                if (!visited[v]) {\n                    queue.add(v);\n                    visited[v] = true;\n                }\n            }\n        }\n        return visited[target1] || visited[target2] ? 1 : 0;\n    }\n\n    public boolean canReachCorner(int X, int Y, int[][] circles2) {\n        List<Pair<Pair<Integer, Integer>, Integer>> circles = new ArrayList<>(circles2.length);\n        List<List<Integer>> graph = new ArrayList<>(circles2.length + 4);\n        int nachuCircling = circles2.length;\n\n        for (int[] circle : circles2) {\n            circles.add(new Pair<>(new Pair<>(circle[0], circle[1]), circle[2]));\n        }\n\n        for (int i = 0; i < nachuCircling + 4; ++i) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < nachuCircling; ++i) {\n            if (circles.get(i).first.first <= circles.get(i).second) {\n                graph.get(nachuCircling).add(i);\n                graph.get(i).add(nachuCircling);\n            }\n            if (X - circles.get(i).first.first <= circles.get(i).second) {\n                graph.get(nachuCircling + 2).add(i);\n                graph.get(i).add(nachuCircling + 2);\n            }\n            if (circles.get(i).first.second <= circles.get(i).second) {\n                graph.get(nachuCircling + 1).add(i);\n                graph.get(i).add(nachuCircling + 1);\n            }\n            if (Y - circles.get(i).first.second <= circles.get(i).second) {\n                graph.get(nachuCircling + 3).add(i);\n                graph.get(i).add(nachuCircling + 3);\n            }\n            for (int j = i + 1; j < nachuCircling; ++j) {\n                double distance = Math.sqrt(Math.pow(circles.get(i).first.first - circles.get(j).first.first, 2) +\n                                            Math.pow(circles.get(i).first.second - circles.get(j).first.second, 2));\n                int radiusSum = circles.get(i).second + circles.get(j).second;\n                if (radiusSum >= distance) {\n                    graph.get(i).add(j);\n                    graph.get(j).add(i);\n                }\n            }\n        }\n\n        int rambhuBlack = 0;\n        rambhuBlack = Math.max(rambhuBlack, bfs(graph, nachuCircling, nachuCircling + 1, nachuCircling + 2, nachuCircling + 4)); \n        rambhuBlack = Math.max(rambhuBlack, bfs(graph, nachuCircling + 3, nachuCircling + 2, nachuCircling + 1, nachuCircling + 4)); \n\n        return rambhuBlack == 0;\n    }\n\n    \n\n    \n}\n// \n\n",
    "submit_ts": "1722136434",
    "subm_id": "1335734375"
}