{
    "username": "agix",
    "submission": "class Solution {\npublic:\n    int findMinHeight(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        \n        if (n == 1)\n        {\n            return 1;\n        }\n        if (n == 2)\n        {\n            return 2;\n        }\n        \n        vector<vector<int>> graph(n);\n        \n        vector<int> deg(n);\n        \n        for (auto& edge : edges)\n        {\n            int u = edge[0];\n            int v = edge[1];\n            \n            graph[u].push_back(v);\n            graph[v].push_back(u);\n            \n            deg[u]++;\n            deg[v]++;\n        }\n        \n        vector<int> ans;\n        \n        queue<int> que;\n        vector<bool> visited(n);\n        \n        for (int i = 0; i < graph.size(); i++)\n        {\n            if (graph[i].size() == 1)\n            {\n                que.push(i);\n                visited[i] = true;\n                n--;\n                \n            }\n        }\n\n        int h = 1;\n        \n        while (n > 2)\n        {\n            int len = que.size();\n            \n            for (int i = 0; i < len; i++)\n            {\n                int cur = que.front();\n                que.pop();\n                \n                \n                for (auto& nei : graph[cur])\n                {\n                    if (!visited[nei])\n                    {\n                        deg[nei]--;\n                        \n                        if (deg[nei] == 1)\n                        {\n                            visited[nei] = true;\n                            que.push(nei);\n                            n--;\n                        }\n                    }\n                }\n            }\n            \n            h++;\n        }\n        \n        if (n == 1)\n        {\n            h += 1;\n        }\n        else\n        {\n            h += 2;\n        }\n        \n        return h;\n    }\n    \n    void dfs(vector<vector<int>>& graph, int parent, int cur, int dep, int& maxDepth, int& maxNode)\n    {\n        if (dep > maxDepth)\n        {\n            maxDepth = dep;\n            maxNode = cur;\n        }\n        \n        for (auto& nei : graph[cur])\n        {\n            if (nei == parent)\n            {\n                continue;\n            }\n            dfs(graph, cur, nei, dep + 1, maxDepth, maxNode);\n        }\n    }\n    \n    int findDiameter(vector<vector<int>>& edges)\n    {\n        int n = edges.size() + 1;\n        \n        vector<vector<int>> graph(n);\n        \n        for (auto& edge : edges)\n        {\n            int u = edge[0];\n            int v = edge[1];\n            \n            graph[u].push_back(v);\n            graph[v].push_back(u);\n        }\n        \n        int maxDepth = -1;\n        int maxNode = -1;\n        \n        dfs(graph, -1, 0, 0, maxDepth, maxNode);\n        \n        int cur = maxNode;\n        \n        maxDepth = -1;\n        maxNode = -1;\n        \n        dfs(graph, -1, cur, 0, maxDepth, maxNode);\n        \n        return maxDepth;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int h1 = findMinHeight(edges1);\n        int h2 = findMinHeight(edges2);\n        //cout << h1 << \" \" << h2 << endl;\n        int h = h1 + h2 - 1;\n        \n        int d1 = findDiameter(edges1);\n        int d2 = findDiameter(edges2);\n        //cout << d1 << \" \" << d2 << endl;\n        \n        int d = max(d1, d2);\n        \n        return max(h, d);\n    }\n};",
    "submit_ts": 1719719067.0
}