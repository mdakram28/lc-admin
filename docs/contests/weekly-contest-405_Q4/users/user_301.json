{
    "username": "Superultra",
    "submission": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std; using namespace __gnu_pbds;\n\n#define ll long long\n#define FOR(i, x, y) for (int i = x; i < y; i++)\n\nusing H = array<int, 1>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int md = 1e9 + 69; const H P{int(rng() % 100000) + 13};\nvector<H> pw{{1}}; //We dynamically extend pw\n\nH operator + (H a, H b){ //a + b\n    for (int i : {0}) if ((a[i] += b[i]) >= md) a[i] -= md;\n    return a;\n}\nH operator - (H a, H b){ //a - b\n    for (int i : {0}) if ((a[i] -= b[i]) < 0) a[i] += md;\n    return a;\n}\nH operator * (H a, H b){ //a * b\n    for (int i : {0}) a[i] = 1LL * a[i] * b[i] % md;\n    return a;\n}\nstruct hasher{\n    string curS = \" \"; vector<H> hsh{{0}};\n    void add(char c){ //curS is initialized with padding \" \"\n        curS += c;\n        hsh.push_back(hsh.back() * P + H{c - 'a' + 1});\n    }\n    H get(int l, int r){\n        while (pw.size() <= r - l + 1) pw.push_back(pw.back() * P); //Need to know pw[r-l+1]\n        return hsh[r] - (hsh[l - 1] * pw[r - l + 1]);\n    }\n};\nint enc(H h){\n    // return 1LL * h[0] * h[1];\n    return h[0];\n}\n\n\nstruct custom_hash {\n    static ll splitmix64(ll x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n    size_t operator()(ll x) const {\n        static const ll FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\nclass Solution {\npublic:\n    int minimumCost(string S, vector<string>& A, vector<int>& C) {\n        ios_base::sync_with_stdio(0); cin.tie(0); \n\n        int n = S.size();\n        S = \" \" + S;\n\n        hasher hs;\n\n        FOR(i, 1, n + 1){\n            hs.add(S[i]);\n        }\n\n        vector<int> lens;\n        gp_hash_table<int, int> mp;\n\n        FOR(i, 0, A.size()){\n            string s = A[i];\n            hasher tmp;\n            int m = s.size();\n\n            for (char c : s)\n                tmp.add(c);\n            \n            int val = enc(tmp.get(1, m));\n            lens.push_back(m);\n\n            if (mp.find(val) == mp.end())\n                mp[val] = C[i];\n            else  \n                mp[val] = min(mp[val], C[i]);\n        }\n\n        sort(lens.begin(), lens.end());\n        lens.resize(unique(lens.begin(), lens.end()) - lens.begin());\n\n        int dp[n + 1];\n        memset(dp, 0x3f, sizeof(dp));\n\n        dp[0] = 0;\n\n        for (int i = 1; i <= n; i++){\n            for (int l : lens){\n                // i - l + 1, i\n                if (i - l >= 0){\n                    int targ = enc(hs.get(i - l + 1, i));\n                    auto it = mp.find(targ);\n\n                    if (it != mp.end())\n                        dp[i] = min(dp[i], dp[i - l] + it->second);\n                }\n                else \n                    break;\n            }\n        }\n        return dp[n] >= (int)1e9 ? -1 : dp[n];\n    }\n};",
    "submit_ts": "1720320588",
    "subm_id": "1312298813"
}