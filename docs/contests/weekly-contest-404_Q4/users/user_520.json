{
    "username": "crisppy",
    "submission": "/*\n -> we find the diam for each tree:\n   -> tree1_len \n   -> tree2_len s\n   \n   -> need to max dfs\n*/\nclass Solution {\npublic:\n    void maxDFS(int node, int prev, const vector<vector<int>> &graph, int level, int &maxLeaf, int &maxLevel){\n        if(level > maxLevel) {\n            maxLeaf = node;\n            maxLevel = level;\n        }\n        \n        for(int neigh : graph[node]){\n            if(neigh == prev)\n                continue;\n            maxDFS(neigh,node, graph, level+1,maxLeaf,maxLevel);\n        }\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        vector<vector<int>> graph1(edges1.size()+1);\n        vector<vector<int>> graph2(edges2.size()+1);\n        \n        for(vector<int> e : edges1){\n            graph1[e[0]].push_back(e[1]);\n            graph1[e[1]].push_back(e[0]);\n        }\n        \n        for(vector<int> e : edges2){\n            graph2[e[0]].push_back(e[1]);\n            graph2[e[1]].push_back(e[0]);\n        }\n        \n        int maxLeaf1 = 0, maxLevel1 = 0;\n        maxDFS(0,-1,graph1,0,maxLeaf1,maxLevel1);\n        \n        int maxLeaf2 = 0, maxLevel2 = 0;\n        maxDFS(0,-1,graph2,0,maxLeaf2,maxLevel2);\n        \n        \n        int maxLeaf11 = 0, maxLevel11 = 0;\n        maxDFS(maxLeaf1,-1,graph1,0,maxLeaf11,maxLevel11);\n        \n        int maxLeaf22 = 0, maxLevel22 = 0;\n        maxDFS(maxLeaf2,-1,graph2,0,maxLeaf22,maxLevel22);\n        \n        int d1 = maxLevel11, d2 = maxLevel22;\n        int mix = (int)ceil((float)d1/2) + (int)ceil((float)d2/2) + 1;\n        \n       // cout << \"d1, d2: \" << d1 << \" \" << d2 << \"\\n\";\n      //  cout << \"mix: \" << mix << \"\\n\";\n        return max(mix,max(d1,d2));\n    }\n};",
    "submit_ts": 1719717938.0
}