{
    "username": "981377660LMT",
    "submission": "package main\n\nconst INF int = 1e18\n\n// \u7ed9\u4f60\u4e00\u4e2a\u4e0b\u6807\u4ece 0 \u5f00\u59cb\u7684\u6570\u7ec4 points \uff0c\u5b83\u8868\u793a\u4e8c\u7ef4\u5e73\u9762\u4e0a\u4e00\u4e9b\u70b9\u7684\u6574\u6570\u5750\u6807\uff0c\u5176\u4e2d points[i] = [xi, yi] \u3002\n// \u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u5b9a\u4e49\u4e3a\u5b83\u4eec\u7684\u66fc\u54c8\u987f\u8ddd\u79bb\u3002\n// \u8bf7\u4f60\u6070\u597d\u79fb\u9664\u4e00\u4e2a\u70b9\uff0c\u8fd4\u56de\u79fb\u9664\u540e\u4efb\u610f\u4e24\u70b9\u4e4b\u95f4\u7684 \u6700\u5927 \u8ddd\u79bb\u53ef\u80fd\u7684 \u6700\u5c0f \u503c\u3002\nfunc minimumDistance(points [][]int) int {\n\n\tk := 2\n\tfromPoint := func(point []int) E {\n\t\tvar res E\n\t\tres[0] = 0\n\t\tfor i := 0; i < 1<<k; i++ {\n\t\t\tfor j := 0; j < k; j++ {\n\t\t\t\tif i&(1<<j) > 0 {\n\t\t\t\t\tres[i] += point[j]\n\t\t\t\t} else {\n\t\t\t\t\tres[i] -= point[j]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tn := len(points)\n\tseg := NewSegmentTree(n, func(i int) E { return fromPoint(points[i]) })\n\tsetPoint := func(pos int, point []int) {\n\t\tseg.Set(pos, fromPoint(point))\n\t}\n\tquery := func() int {\n\t\ttmp := seg.QueryAll()\n\t\tres := 0\n\t\tfor i := 0; i < 1<<k; i++ {\n\t\t\tres = max(res, tmp[i]+tmp[(1<<k)-1-i])\n\t\t}\n\t\treturn res\n\t}\n\n\tres := INF\n\tx1, y1 := points[0][0], points[0][1]\n\txn, yn := points[n-1][0], points[n-1][1]\n\tfor i := 0; i < n; i++ {\n\t\tif i > 0 {\n\t\t\tsetPoint(i, []int{x1, y1})\n\t\t} else {\n\t\t\tsetPoint(i, []int{xn, yn})\n\t\t}\n\t\tres = min(res, query())\n\t\tsetPoint(i, points[i])\n\t}\n\treturn res\n}\n\ntype E = [4]int\n\nfunc (*SegmentTree) e() E { return [4]int{INF} }\nfunc (*SegmentTree) op(a, b E) E {\n\tif a[0] == INF {\n\t\treturn b\n\t}\n\tif b[0] == INF {\n\t\treturn a\n\t}\n\tfor i := 0; i < 4; i++ {\n\t\ta[i] = max(a[i], b[i])\n\t}\n\treturn a\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\ntype SegmentTree struct {\n\tn, size int\n\tseg     []E\n}\n\nfunc NewSegmentTree(n int, f func(int) E) *SegmentTree {\n\tres := &SegmentTree{}\n\tsize := 1\n\tfor size < n {\n\t\tsize <<= 1\n\t}\n\tseg := make([]E, size<<1)\n\tfor i := range seg {\n\t\tseg[i] = res.e()\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tseg[i+size] = f(i)\n\t}\n\tfor i := size - 1; i > 0; i-- {\n\t\tseg[i] = res.op(seg[i<<1], seg[i<<1|1])\n\t}\n\tres.n = n\n\tres.size = size\n\tres.seg = seg\n\treturn res\n}\nfunc NewSegmentTreeFrom(leaves []E) *SegmentTree {\n\tres := &SegmentTree{}\n\tn := len(leaves)\n\tsize := 1\n\tfor size < n {\n\t\tsize <<= 1\n\t}\n\tseg := make([]E, size<<1)\n\tfor i := range seg {\n\t\tseg[i] = res.e()\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tseg[i+size] = leaves[i]\n\t}\n\tfor i := size - 1; i > 0; i-- {\n\t\tseg[i] = res.op(seg[i<<1], seg[i<<1|1])\n\t}\n\tres.n = n\n\tres.size = size\n\tres.seg = seg\n\treturn res\n}\nfunc (st *SegmentTree) Get(index int) E {\n\tif index < 0 || index >= st.n {\n\t\treturn st.e()\n\t}\n\treturn st.seg[index+st.size]\n}\nfunc (st *SegmentTree) Set(index int, value E) {\n\tif index < 0 || index >= st.n {\n\t\treturn\n\t}\n\tindex += st.size\n\tst.seg[index] = value\n\tfor index >>= 1; index > 0; index >>= 1 {\n\t\tst.seg[index] = st.op(st.seg[index<<1], st.seg[index<<1|1])\n\t}\n}\nfunc (st *SegmentTree) Update(index int, value E) {\n\tif index < 0 || index >= st.n {\n\t\treturn\n\t}\n\tindex += st.size\n\tst.seg[index] = st.op(st.seg[index], value)\n\tfor index >>= 1; index > 0; index >>= 1 {\n\t\tst.seg[index] = st.op(st.seg[index<<1], st.seg[index<<1|1])\n\t}\n}\n\n// [start, end)\nfunc (st *SegmentTree) Query(start, end int) E {\n\tif start < 0 {\n\t\tstart = 0\n\t}\n\tif end > st.n {\n\t\tend = st.n\n\t}\n\tif start >= end {\n\t\treturn st.e()\n\t}\n\tleftRes, rightRes := st.e(), st.e()\n\tstart += st.size\n\tend += st.size\n\tfor start < end {\n\t\tif start&1 == 1 {\n\t\t\tleftRes = st.op(leftRes, st.seg[start])\n\t\t\tstart++\n\t\t}\n\t\tif end&1 == 1 {\n\t\t\tend--\n\t\t\trightRes = st.op(st.seg[end], rightRes)\n\t\t}\n\t\tstart >>= 1\n\t\tend >>= 1\n\t}\n\treturn st.op(leftRes, rightRes)\n}\nfunc (st *SegmentTree) QueryAll() E { return st.seg[1] }\nfunc (st *SegmentTree) GetAll() []E {\n\tres := make([]E, st.n)\n\tcopy(res, st.seg[st.size:st.size+st.n])\n\treturn res\n}\n\n// \u4e8c\u5206\u67e5\u8be2\u6700\u5927\u7684 right \u4f7f\u5f97\u5207\u7247 [left:right] \u5185\u7684\u503c\u6ee1\u8db3 predicate\nfunc (st *SegmentTree) MaxRight(left int, predicate func(E) bool) int {\n\tif left == st.n {\n\t\treturn st.n\n\t}\n\tleft += st.size\n\tres := st.e()\n\tfor {\n\t\tfor left&1 == 0 {\n\t\t\tleft >>= 1\n\t\t}\n\t\tif !predicate(st.op(res, st.seg[left])) {\n\t\t\tfor left < st.size {\n\t\t\t\tleft <<= 1\n\t\t\t\tif tmp := st.op(res, st.seg[left]); predicate(tmp) {\n\t\t\t\t\tres = tmp\n\t\t\t\t\tleft++\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn left - st.size\n\t\t}\n\t\tres = st.op(res, st.seg[left])\n\t\tleft++\n\t\tif (left & -left) == left {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn st.n\n}\n\n// \u4e8c\u5206\u67e5\u8be2\u6700\u5c0f\u7684 left \u4f7f\u5f97\u5207\u7247 [left:right] \u5185\u7684\u503c\u6ee1\u8db3 predicate\nfunc (st *SegmentTree) MinLeft(right int, predicate func(E) bool) int {\n\tif right == 0 {\n\t\treturn 0\n\t}\n\tright += st.size\n\tres := st.e()\n\tfor {\n\t\tright--\n\t\tfor right > 1 && right&1 == 1 {\n\t\t\tright >>= 1\n\t\t}\n\t\tif !predicate(st.op(st.seg[right], res)) {\n\t\t\tfor right < st.size {\n\t\t\t\tright = right<<1 | 1\n\t\t\t\tif tmp := st.op(st.seg[right], res); predicate(tmp) {\n\t\t\t\t\tres = tmp\n\t\t\t\t\tright--\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn right + 1 - st.size\n\t\t}\n\t\tres = st.op(st.seg[right], res)\n\t\tif right&-right == right {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn 0\n}\n"
}