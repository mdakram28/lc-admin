{
    "username": "goyalchirag2222",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define forloop(i, l, r) for(int i = int(l); i < int(r); i++)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((int)(x).size())\n#define pii pair<int,int>\n#define vpii vector<pair<int,int>>\n#define vvi vector<vector<int>>\n#define py cout<<\"YES\"<<endl\n#define pn cout<<\"NO\"<<endl\nconst int MOD=1e9+7;\nconst int mod=998244353;\n#define pb push_back\n#define input(a,n) for(int i = 0 ; i < n; i++)cin>>a[i];\n#define ff first\n#define ss second\n#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end()), x.shrink_to_fit()\n#define MIN(v) *min_element(all(v))\n#define MAX(v) *max_element(all(v))\n#define endl \"\\n\" \n#define for_(i, s, e) for (int i = s; i < (int) e; i++)\nint binaryToDecimal(string n){string num = n;int dec_value = 0;int base = 1;int len = num.length();for(int i = len - 1; i >= 0; i--){if (num[i] == '1')dec_value += base;base = base * 2;}return dec_value;}\nstring decToBinary(int n){string s=\"\";int i = 0;while (n > 0) {s =to_string(n % 2)+s;n = n / 2;i++;}return s;}\n#define min_heap priority_queue<int,vector<int>,greater<int>> \n#define max_heap priority_queue<int,vector<int>> \n#define max_heap_pair priority_queue<pair<int,int>,vector<pair<int,int>>> \n#define min_heap_pair priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> \nint dx[8]={-1,1,0,0,-1,1,-1,1};//UP DOWN LEFT RIGHT UP-RIGHT DOWN-RIGHT UP-LEFT DOWN-LEFT\nint dy[8]={0,0,-1,1,1,1,-1,-1};\nchar moves[4]={'U','D','L','R'};\n#include <ext/pb_ds/assoc_container.hpp> // Common file \n#include <ext/pb_ds/tree_policy.hpp>\n#include <functional> // for less \nusing namespace __gnu_pbds;\n\n// Declaring ordered_set\ntemplate <typename T>\n//using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nusing ordered_set = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;//allows duplicates also so no need to pair up with index\n// find_by_order(k) return kth largest element iterator(0 based indexing is there), order_of_key(x) count of element strictly less than x in a set(not equal to also)....to get x included also find order_of_key(x-1)\n//for defining now need to do ordered_set<int>s or ordered_set<pii>s\n//here if we change less<T> to greater<int> then it will going to store elements in descending order rather than ascending\n//and order_of_key(val) will return number of values strictly greater than val(not including val) and similarly find_by_order(k) will return iterator in the descending way\n\nusing namespace std;\n\n//here for defining create2DVector<int>(n,m) need to specifiy int,char in < > because compiler cannot deduce template parameter T\ntemplate <class T> vector<vector<T>> create2DVector(int n, int m) {vector<vector<T>> vec(n, vector<T>(m)); for (int i = 0; i < n; i++) {for (int j = 0; j < m; j++) {cin >> vec[i][j];}}return vec;}\ntemplate <class T> void _print(vector<vector<T>>& v) {for (auto& row : v) {for (auto& element : row) {cout << element << \" \";}cout << endl;}}\n\ntemplate <class T> void _print(set <T> &v) {for(auto temp:v){cout<<temp<<\" \";};cout<<endl;}\ntemplate <class T, class V> void _print(set <pair<T, V>> &s) {for (auto temp : s) {cout << temp.first << \" \" << temp.second << endl;}cout << endl;}\n\ntemplate <class T> void _print(ordered_set <T> &v) {for(auto temp:v){cout<<temp<<\" \";};cout<<endl;}\ntemplate <class T, class V> void _print(ordered_set <pair<T, V>> &s) {for (auto temp : s) {cout << temp.first << \" \" << temp.second << endl;}cout << endl;}\n\ntemplate <class T> void _print(vector <T> &v) {for(auto temp:v){cout<<temp<<\" \";};cout<<endl;}\ntemplate <class T, class V> void _print(vector <pair<T, V>> &v) {for (auto temp : v) {cout << temp.first << \" \" << temp.second << endl;}cout << endl;}\n\ntemplate <class T> void _print(multiset <T> &v) {for(auto temp:v){cout<<temp<<\" \";};cout<<endl;}\ntemplate <class T, class V> void _print(map <T, V> &v) {for(auto temp:v){cout<<temp.ff<<\" \"<<temp.ss<<endl;}}\n\n//customize hash function for unordered_map which maps pii with int\nstruct hash_pair {template <class T1, class T2>size_t operator()(const pair<T1, T2>& p) const {auto hash1 = hash<T1>{}(p.first);auto hash2 = hash<T2>{}(p.second);return hash1 ^ (hash2 << 1);}};\n//for defining this define like unordered_map<pair<int, int>, int, hash_pair> m;\n\n\nclass Solution {\nprivate:\n    static vector<long> segT;\n\n    static void build(int s, int e, int i, const vector<long>& a) {\n        if (s == e) {\n            segT[i] = a[s];\n            return;\n        }\n        int mid = s + (e - s) / 2;\n        build(s, mid, 2 * i + 1, a);\n        build(mid + 1, e, 2 * i + 2, a);\n        segT[i] = max(segT[2 * i + 1], segT[2 * i + 2]);\n    }\n\n    static void update(int s, int e, int i, int q, long v) {\n        if (s == e) {\n            segT[i] = v;\n            return;\n        }\n        int mid = s + (e - s) / 2;\n        if (q <= mid)\n            update(s, mid, 1+2 * i , q, v);\n        else\n            update(mid + 1, e, 2 * i + 2, q, v);\n        segT[i] = max(segT[1+2 * i ], segT[2+2 * i]);\n    }\n\n    static long range(int s, int e, int i, int qs, int qe) {\n        if (qs <= s && qe >= e)\n            return segT[i];\n        if (qs > e || qe < s)\n            return LONG_MIN;\n        int mid = s + (e - s) / 2;\n        long l = range(s, mid, 2 * i + 1, qs, qe);\n        long r = range(mid + 1, e, 2 * i + 2, qs, qe);\n        return max(l, r);\n    }\n\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector<bool> arr;\n        set<int> obstacleSet;\n        map<int, int> distanceMap;\n        obstacleSet.insert(0);\n        obstacleSet.insert(100000);\n        distanceMap[0] = 0;\n        distanceMap[100000] = 100000;\n\n        segT.assign(500000, LONG_MIN);\n\n        for (const auto& query : queries) {\n            if (query[0] == 1) {\n                int pos = query[1];\n                obstacleSet.insert(pos);\n\n                auto it = obstacleSet.find(pos);\n                int prev = *std::prev(it);\n                int next = *std::next(it);\n\n                distanceMap[next] = next - pos;\n                distanceMap[pos] = pos - prev;\n\n                update(0, 100000, 0, pos, distanceMap[pos]);\n                update(0, 100000, 0, next, distanceMap[next]);\n\n            } else {\n                int pos = query[1];\n                int size = query[2];\n\n                auto it = obstacleSet.lower_bound(pos);\n                if (it == obstacleSet.end() || *it > pos) {\n                    it--;\n                }\n\n                int prev = *it;\n                if (pos - prev >= size) {\n                    arr.pb(true);\n                } else if (range(0, 100000, 0, 0, pos) >= size) {\n                    arr.pb(true);\n                } else {\n                    arr.pb(false);\n                }\n            }\n        }\n        return arr;\n    }\n};\n\nvector<long> Solution::segT;\n",
    "submit_ts": 1716652598.0
}