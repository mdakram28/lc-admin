{
    "username": "sushantms",
    "submission": "from typing import List\nfrom collections import deque\nimport math\n\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        def bfs(graph, start, target1, target2, n):\n            queue = deque([start])\n            visited = [False] * (n + 4)\n            visited[start] = True\n            \n            while queue:\n                u = queue.popleft()\n                for v in graph[u]:\n                    if not visited[v]:\n                        queue.append(v)\n                        visited[v] = True\n                        \n            return visited[target1] or visited[target2]\n\n        nc = len(circles)\n        graph = [[] for _ in range(nc + 4)]\n        c = [[circle[0], circle[1], circle[2]] for circle in circles]\n\n        for i in range(nc):\n            if c[i][0] <= c[i][2]:\n                graph[nc].append(i)\n                graph[i].append(nc)\n            if X - c[i][0] <= c[i][2]:\n                graph[nc + 2].append(i)\n                graph[i].append(nc + 2)\n            if c[i][1] <= c[i][2]:\n                graph[nc + 1].append(i)\n                graph[i].append(nc + 1)\n            if Y - c[i][1] <= c[i][2]:\n                graph[nc + 3].append(i)\n                graph[i].append(nc + 3)\n            for j in range(i + 1, nc):\n                dx = c[i][0] - c[j][0]\n                dy = c[i][1] - c[j][1]\n                distance = math.sqrt(dx * dx + dy * dy)\n                if c[i][2] + c[j][2] >= distance:\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        return not (bfs(graph, nc, nc + 1, nc + 2, nc + 4) or \n                    bfs(graph, nc + 3, nc + 2, nc + 1, nc + 4))\n",
    "submit_ts": "1722138913",
    "subm_id": "1335802968"
}