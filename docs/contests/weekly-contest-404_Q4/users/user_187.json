{
    "username": "vrangr",
    "submission": "template<typename type> inline void print(const type &var) {\n    cout << var;\n}\ntemplate<typename type> inline void print(const vector<type> &vec) {\n    for (auto &it : vec) {\n        print(it); cout << \" \";\n    }\n}\n#define debug(x) if(false){cout<<#x<<\": \";print(x);cout<<endl;}\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size()+1, m = edges2.size()+1;\n        vector<vector<int>> e1(n), e2(m);\n        for (auto &edge : edges1) {\n            e1[edge[0]].push_back(edge[1]);\n            e1[edge[1]].push_back(edge[0]);\n        }\n        for (auto &edge : edges2) {\n            e2[edge[0]].push_back(edge[1]);\n            e2[edge[1]].push_back(edge[0]);\n        }\n        auto diam = [](auto &g) -> int {\n            int n = g.size();\n            if (n <= 2) return n;\n            int root = 0, mxl = -1, d = 0;\n            auto dfs = [&](auto &&self, int u, int p, int cd) {\n                assert(u >= 0);\n                assert(u < g.size());\n                if (g[u].size() == 1 && p != -1) {\n                    if (d < cd) {\n                        mxl = u;\n                        d = cd;\n                    }\n                    return;\n                }\n                for (int &v : g[u]) {\n                    if (v == p) continue;\n                    self(self,v,u,cd+1);\n                }\n            };\n            dfs(dfs,root,-1,0);\n            assert(mxl != -1);\n            root = mxl;\n            mxl = -1;\n            d = 0;\n            dfs(dfs,root,-1,0);\n            return d;\n        };\n        auto get = [](auto &g) -> vector<int> {\n            int n = g.size();\n            vector<int> sol(n,1);\n            auto dfs = [&](auto &&self, int u, int p) -> void {\n                for (int &v : g[u]) {\n                    if (v == p) continue;\n                    self(self,v,u);\n                    sol[u] = max(sol[u],sol[v]+1);\n                }\n            };\n            dfs(dfs,0,-1);\n            auto dfs2 = [&](auto &&self, int u, int p, int pd) -> void {\n                int m1 = -1, v1 = -1, m2 = -1, v2 = -1;\n                sol[u] = max(sol[u],pd+1);\n                for (int &v : g[u]) {\n                    if (v == p) continue;\n                    if (m1 == -1) {\n                        m1 = sol[v];\n                        v1 = v;\n                        continue;\n                    }\n                    if (m2 == -1) {\n                        m2 = sol[v];\n                        v2 = v;\n                        if (m2 > m1) {\n                            swap(m1,m2);\n                            swap(v1,v2);\n                        }\n                        continue;\n                    }\n                    if (sol[v] < m2) continue;\n                    if (sol[v] < m1) {\n                        m2 = sol[v];\n                        v2 = v;\n                        continue;\n                    }\n                    swap(m1,m2);\n                    swap(v1,v2);\n                    m1 = sol[v];\n                    v1 = v;\n                }\n                for (int &v : g[u]) {\n                    if (v == p) continue;\n                    if (v == v1) {\n                        int cd = max(m2+1,1);\n                        self(self,v,u,max(cd,pd+1));\n                        continue;\n                    }\n                    int cd = max(m1+1,1);\n                    self(self,v,u,max(cd,pd+1));\n                }\n            };\n            dfs2(dfs2,0,-1,0);\n            return sol;\n        };\n        vector<int> a1 = get(e1), a2 = get(e2);\n        return max({diam(e1), diam(e2), *min_element(a1.begin(),a1.end()) + *min_element(a2.begin(),a2.end()) - 1});\n    }\n};",
    "submit_ts": "1719718044",
    "subm_id": "1304407356"
}