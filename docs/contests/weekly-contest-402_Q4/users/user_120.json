{
    "username": "2499370956",
    "submission": "class Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        int n = nums.length;\n        SegmentTree<Integer> stSum = new SegmentTree<>(n, 0, Math::addExact);\n        for (int i = 0; i < n; i++) {\n            if (isPeak(nums, i)) {\n                stSum.set(i, 1);\n            }\n        }\n\n        List<Integer> out = new ArrayList<>();\n        for (int[] q : queries) {\n            int t = q[0];\n            if (t == 1) {\n                int l = q[1];\n                int r = q[2];\n                out.add(stSum.get(l + 1, r));\n            } else if (t == 2) {\n                int i = q[1];\n                int v = q[2];\n                nums[i] = v;\n                for (int j = i - 1; j <= i + 1; j++) {\n                    if (j < 0 || j >= n) {\n                        continue;\n                    }\n                    if (isPeak(nums, j)) {\n                        stSum.set(j, 1);\n                    } else {\n                        stSum.set(j, 0);\n                    }\n                }\n//                System.out.println(Arrays.toString(nums));\n//                for (int k = 0; k < n; k++) {\n//                    System.out.println(\"index \" + k);\n//                    System.out.println(isPeak(nums, k));\n//                    System.out.println(stSum.get(k, k + 1));\n//                }\n            }\n        }\n        return out;\n    }\n\n    private boolean isPeak(int[] a, int i) {\n        if (i <= 0 || i >= a.length - 1) {\n            return false;\n        }\n        return a[i] > a[i - 1] && a[i] > a[i + 1];\n    }\n\n    public class SegmentTree<T> {\n        private int size;\n        private T defaultValue;\n        private BiFunction<T, T, T> mergeFunction;\n        private Node<T> root;\n\n        public SegmentTree(int size, T defaultValue, BiFunction<T, T, T> mergeFunction) {\n            this.size = size;\n            this.defaultValue = defaultValue;\n            this.mergeFunction = mergeFunction;\n            this.root = create(0, size);\n        }\n\n        public void set(int index, T value) {\n            set(this.root, index, value);\n        }\n\n        public T get(int start, int end) {\n            return get(this.root, start, end);\n        }\n\n        private Node create(int start, int end) {\n            Node<T> node = new Node<>();\n            node.start = start;\n            node.end = end;\n            node.value = this.defaultValue;\n            if (end - start > 1) {\n                int mid = (end + start) / 2;\n                node.left = create(start, mid);\n                node.right = create(mid, end);\n            }\n            return node;\n        }\n\n        private T set(Node<T> node, int index, T value) {\n            if (index >= node.start && index < node.end) {\n                if (node.end - node.start > 1) {\n                    node.value = this.mergeFunction.apply(set(node.left, index, value), set(node.right, index, value));\n                } else {\n                    node.value = value;\n                }\n            }\n            return node.value;\n        }\n\n        private T get(Node<T> node, int start, int end) {\n            if (node.start >= start && node.end <= end) {\n                return node.value;\n            }\n            if (node.start >= end || node.end <= start) {\n                return this.defaultValue;\n            }\n            return this.mergeFunction.apply(get(node.left, start, end), get(node.right, start, end));\n        }\n\n        class Node<T> {\n            int start;\n            int end;\n            T value;\n            Node<T> left;\n            Node<T> right;\n        }\n    }\n}",
    "submit_ts": 1718506681.0
}