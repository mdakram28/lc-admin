{
    "username": "soupboy",
    "submission": "class Solution {\npublic:\n    int minFlips(vector<vector<int>>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        \n        int ret = 0;\n        \n        // lets find min leaving out the odd intermediate column and row;\n        for(int i1=0,i2=m-1;i1<i2;i1++,i2--) {\n            for(int j1=0,j2=n-1;j1<j2;j1++,j2--) {\n                // grid[i1][j1] grid[i1][j2] grid[i2][j1] grid[i2][j2] all needs to be equal;\n                int zc = 0;\n                int oc = 0;\n                if(grid[i1][j1] == 0) {\n                    zc++;\n                } else {\n                    oc++;\n                }\n                \n                if(grid[i1][j2] == 0) {\n                    zc++;\n                } else {\n                    oc++;\n                }\n                \n                if(grid[i2][j1] == 0) {\n                    zc++;\n                } else {\n                    oc++;\n                }\n                \n                if(grid[i2][j2] == 0) {\n                    zc++;\n                } else {\n                    oc++;\n                }\n                \n                if(zc == oc) {\n                    ret += 2;\n                } else if(zc == 1 || oc == 1) {\n                    ret += 1;\n                } // else either one is zero so need to do anything.                \n            }\n        }\n        \n        // cout<<ret<<\"\\n\";\n        // now lets make the oddth row and col palin.\n        if(m%2 == 1 && n%2 == 1) {\n            if(grid[m/2][n/2] == 1) {\n                ret++; // this must be made zero\n            }\n        }\n        // cout<<ret<<\"\\n\";\n        int countOnes = 0;\n        bool found = false;\n        // lets make the odd row palin;\n        if(m%2 == 1) {\n            int row = m/2;\n            for(int j1=0,j2=n-1;j1<j2;j1++,j2--) {\n                if(grid[row][j1] != grid[row][j2]) {\n                    ret++;\n                    found = true;\n                }     \n                if(grid[row][j1] == grid[row][j2] && grid[row][j1] == 1) {\n                    countOnes+=2;\n                }\n                \n            }\n        }\n        // cout<<ret<<\"\\n\";\n        if(n%2 == 1) {\n            int col = n/2;\n            for(int i1=0,i2=m-1;i1<i2;i1++,i2--) {\n                if(grid[i1][col] != grid[i2][col]) {\n                    ret++;\n                    found = true;\n                }\n                if(grid[i1][col] == grid[i2][col] && grid[i1][col] == 1) {\n                    countOnes+=2;\n                }\n            }\n        }\n        // cout<<ret<<\"\\n\";\n        \n        // if we took care of flipping something , that is found = true, we can adjust that with countOnes by either making this equal to 0 or 1. but if nothing is flipped, then we need to look at how many ones we got\n        \n        \n        if(!found && (countOnes % 4) != 0) {\n            // we need to trim some ones;\n            ret += 2;\n        }\n        // cout<<ret<<\"\\n\";\n        return ret;\n        \n    }\n};",
    "submit_ts": "1722697659",
    "subm_id": "1343154307"
}