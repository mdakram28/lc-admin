{
    "username": "Jayesh101",
    "submission": "class Solution {\n    public boolean canReachCorner(int X, int Y, int[][] edCircles){\n        List<int[]> circles = new ArrayList<>(edCircles.length);\n        List<List<Integer>> plane = new ArrayList<>(edCircles.length + 4);\n        int circle1 = edCircles.length;\n        for(int i = 0; i < circle1; ++i){\n            circles.add(new int[]{edCircles[i][0], edCircles[i][1], edCircles[i][2]});\n        }\n        for(int i = 0; i < circle1 + 4; i++){\n            plane.add(new ArrayList<>());\n        }\n        for(int i = 0; i < circle1; ++i){\n            if (circles.get(i)[0] <= circles.get(i)[2]){\n                plane.get(circle1).add(i);\n                plane.get(i).add(circle1);\n            }\n            if (X - circles.get(i)[0] <= circles.get(i)[2]){\n                plane.get(circle1 + 2).add(i);\n                plane.get(i).add(circle1 + 2);\n            }\n            if (circles.get(i)[1] <= circles.get(i)[2]) {\n                plane.get(circle1 + 1).add(i);\n                plane.get(i).add(circle1 + 1);\n            }\n            if (Y - circles.get(i)[1] <= circles.get(i)[2]) {\n                plane.get(circle1 + 3).add(i);\n                plane.get(i).add(circle1 + 3);\n            }\n            for (int j = i + 1; j < circle1; ++j) {\n                double distance = Math.sqrt(Math.pow(circles.get(i)[0] - circles.get(j)[0], 2) +\n                                            Math.pow(circles.get(i)[1] - circles.get(j)[1], 2));\n                int radius = circles.get(i)[2] + circles.get(j)[2];\n                if(radius >= distance){\n                    plane.get(i).add(j);\n                    plane.get(j).add(i);\n                }\n            }\n        }\n        int blocked = 0;\n        blocked = Math.max(blocked, bfs(plane, circle1, circle1 + 1, circle1 + 2, circle1 + 4));\n        blocked = Math.max(blocked, bfs(plane, circle1 + 3, circle1 + 2, circle1 + 1, circle1 + 4)); \n        return blocked == 0;\n    }\n    public int bfs(List<List<Integer>> plane, int start, int target1, int target2, int nodes) {\n        Queue<Integer> pq = new LinkedList<>();\n        boolean[] marked = new boolean[nodes + 4];\n        pq.add(start);\n        marked[start] = true;\n        while(!pq.isEmpty()){\n            int u = pq.poll();\n            for(int v : plane.get(u)){\n                if (!marked[v]) {\n                    pq.add(v);\n                    marked[v] = true;\n                }\n            }\n        }\n        return marked[target1] || marked[target2] ? 1 : 0;\n    }\n}",
    "submit_ts": "1722138454",
    "subm_id": "1335791168"
}