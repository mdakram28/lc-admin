{
    "username": "Reply1988",
    "submission": "class Solution {\nprivate:\n    int find(vector<int>&parent, int target) {\n        while(parent[target] != target) {\n            target = parent[target];\n        }\n        return target;\n    }\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        // union find\n        int n = circles.size();\n        vector<int> parent(n, -1);\n        unordered_map<int, array<int, 4>> ranges;\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n            auto & cur = circles[i];\n            ranges[i] = array<int, 4>{cur[0]-cur[2], cur[0]+cur[2], cur[1]-cur[2], cur[1]+cur[2]};\n        }\n        for (int i = 0; i < circles.size(); ++i) {\n            for (int j = 0; j < i; ++j) {\n                auto& p1 = circles[i];\n                auto& p2 = circles[j];\n                if (pow(p1[0]-p2[0], 2)+pow(p1[1]-p2[1], 2) <= pow(p1[2]+p2[2],2)) {\n                    // there is an overlap\n                    int parent1 = find(parent, i);\n                    int parent2 = find(parent, j);\n                    if (parent1 != parent2) {\n                        int small = min(parent1, parent2);\n                        int large = max(parent1, parent2);\n                        parent[large] = small;\n                        ranges[small][0] = min(ranges[small][0], ranges[large][0]);\n                        ranges[small][1] = max(ranges[small][1], ranges[large][1]);\n                        ranges[small][2] = min(ranges[small][2], ranges[large][2]);\n                        ranges[small][3] = max(ranges[small][3], ranges[large][3]);\n                        ranges.erase(large);\n                    }\n                }\n            }\n        }\n        for (auto itr = ranges.begin(); itr != ranges.end(); ++itr) {\n            //cout<<itr->second[0]<<\" \"<<itr->second[1]<<\" \"<<itr->second[2]<<\" \"<<itr->second[3]<<endl;\n            if ((itr->second[0] <= 0 && itr->second[1] >= X) || (itr->second[2] <= 0 && itr->second[3] >= Y))\n                return false;\n            if (itr->second[0] <= X && itr->second[1] >= X && itr->second[2]<= Y && itr->second[3]>=Y)\n                return false;\n            if (itr->second[0] <= 0 && itr->second[1] >= 0 && itr->second[2] <= 0 && itr->second[3] >= 0)\n                return false;\n        }\n        return true;\n    }\n};",
    "submit_ts": "1722139183",
    "subm_id": "1335810357"
}