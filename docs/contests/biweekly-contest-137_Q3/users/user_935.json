{
    "username": "baegopayo",
    "submission": "/////////////////////////////// Preface ///////////////////////////////\n// utility functions\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\n\n// typedef\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef tuple<int, int, int> ti3;\ntypedef tuple<int, int, int, int> ti4;\ntypedef tuple<int, int, int, int, int> ti5;\ntypedef tuple<ll, ll, ll> tll3;\ntypedef tuple<ll, ll, ll, ll> tll4;\ntypedef tuple<ll, ll, ll, ll, ll> tll5;\ntypedef vector<pll> vpll;\ntypedef array<int, 3> ai3;\ntypedef array<ll, 3> all3;\ntypedef array<ll, 4> all4;\ntypedef array<ll, 5> all5;\ntypedef vector<all3> vall3;\ntypedef vector<all4> vall4;\ntypedef vector<all5> vall5;\ntypedef pair<ld, ld> pld;\ntypedef vector<pld> vpld;\ntypedef vector<ld> vld;\ntypedef vector<ll> vll;\ntypedef vector<ull> vull;\ntypedef vector<vll> vvll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<bool> vb;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef deque<ll> dqll;\ntypedef deque<pll> dqpll;\ntypedef pair<string, string> pss;\ntypedef vector<pss> vpss;\ntypedef vector<string> vs;\ntypedef vector<vs> vvs;\ntypedef unordered_set<ll> usll;\n// typedef unordered_set<pll, PairHash> uspll;\ntypedef unordered_map<ll, ll> umll;\n// typedef unordered_map<pll, ll, PairHash> umpll;\n\n// macros\n#define X first\n#define Y second\n\nvoid _p(int x) { cout << x; }\nvoid _p(long x) { cout << x; }\nvoid _p(long long x) { cout << x; }\nvoid _p(unsigned x) { cout << x; }\nvoid _p(unsigned long x) { cout << x; }\nvoid _p(unsigned long long x) { cout << x; }\nvoid _p(float x) { cout << x; }\nvoid _p(double x) { cout << x; }\nvoid _p(long double x) { cout << x; }\nvoid _p(char x) { cout << '\\'' << x << '\\''; }\nvoid _p(const char *x) { cout << '\\\"' << x << '\\\"'; }\nvoid _p(const string &x) { cout << '\\\"' << x << '\\\"'; }\nvoid _p(bool x) { cout << (x ? \"true\" : \"false\"); }\ntemplate <typename A> void _p(const A &x) {\n    bool first = true;\n    cout << '{';\n    for (const auto &i : x) {\n        cout << (first ? \"\" : \",\"), _p(i);\n        first = false;\n    }\n    cout << '}';\n}\ntemplate <typename A, typename B> void _p(const pair<A, B> &p) {\n    cout << '(';\n    _p(p.first);\n    cout << ',';\n    _p(p.second);\n    cout << ')';\n}\ntemplate <typename... A> void _p(const tuple<A...> &t) {\n    bool first = true;\n    cout << '(';\n    apply(\n        [&first](const auto &...args) {\n            ((cout << (first ? \"\" : \",\"), _p(args), first = false), ...);\n        },\n        t);\n    cout << ')';\n}\nvoid _pt(const initializer_list<ll> &t) { _p(tuple(t)); }\ntemplate <typename T> void _p(stack<T> s) {\n    vector<T> debugVector;\n    while (!s.empty()) {\n        T t = s.top();\n        debugVector.push_back(t);\n        s.pop();\n    }\n    reverse(debugVector.begin(), debugVector.end());\n    _p(debugVector);\n}\ntemplate <typename T> void _p(queue<T> q) {\n    vector<T> debugVector;\n    while (!q.empty()) {\n        T t = q.front();\n        debugVector.push_back(t);\n        q.pop();\n    }\n    _p(debugVector);\n}\ntemplate <typename T, typename... U> void _p(priority_queue<T, U...> q) {\n    vector<T> debugVector;\n    while (!q.empty()) {\n        T t = q.top();\n        debugVector.push_back(t);\n        q.pop();\n    }\n    _p(debugVector);\n}\nvoid __p() { cout << \"]\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid __p(const Head &H, const Tail &...T) {\n    _p(H);\n    if (sizeof...(T))\n        cout << \", \";\n    __p(T...);\n}\n#ifndef ONLINE_JUDGE\n#define debug(...)                                                             \\\n    cout << \"Line:\" << __LINE__ << \" [\" << #__VA_ARGS__ << \"] = [\";            \\\n    __p(__VA_ARGS__);\n#else\n#define debug(...)\n#endif\n\n#define rep(i, m, n) for (ll i = m; i < n; i++)\n\ntemplate <typename T> void _pn(T &&t) { cout << t << \"\\n\"; }\ntemplate <typename T> void _pv(vector<T> v) {\n    ll n = v.size();\n    rep(i, 0, n) {\n        _p(v[i]);\n        if (i + 1 != n)\n            cout << ' ';\n    }\n    cout << endl;\n}\ntemplate <typename T> void _pvv(vector<vector<T>> v) {\n    ll n = v.size();\n    rep(i, 0, n) _pv(v[i]);\n}\ntemplate <typename T> void _pvln(vector<T> v) {\n    ll n = v.size();\n    rep(i, 0, n) cout << v[i] << endl;\n}\n\nint mod = 1e9 + 7;\n\nint mod_add(long long a, int b) { return (a + b) % mod; }\n\nint mod_sub(long long a, int b) { return (a + mod - b) % mod; }\n\nint mod_mul(long long a, int b) { return a * b % mod; }\n\nint mod_pow(int b, int p) {\n    if (!p)\n        return 1;\n    int half = mod_pow(b, p / 2);\n    return mod_mul(mod_mul(half, half), p % 2 ? b : 1);\n}\n\nint mod_inv(int b) { return mod_pow(b, mod - 2); }\n\nint mod_factorial(int x) {\n    if (x < 2)\n        return 1;\n    return mod_mul(x, mod_factorial(x - 1));\n}\n/////////////////////////////// Preface ///////////////////////////////\n\nclass Solution {\n  public:\n    long long maximumValueSum(vector<vector<int>> &g) {\n        int rows = g.size(), cols = g[0].size();\n\n        vector<vector<pair<ll, int>>> t(rows);\n        for (int r = 0; r < rows; ++r) {\n            for (int c = 0; c < cols; ++c) {\n                t[r].push_back({g[r][c], c});\n            }\n            sort(t[r].begin(), t[r].end(), greater{});\n        }\n\n        vector dp(rows, vector(cols + 1, vector<ll>(cols + 1, LLONG_MIN)));\n        auto dfs = [&](auto dfs, int r, int a, int b) {\n            if (r == rows)\n                return LLONG_MIN;\n            if (dp[r][a][b] == LLONG_MIN) {\n                // dp[r][a][b] = 0;\n                for (int i = 0; i < min(6, cols); ++i) {\n                    auto [topv, topc] = t[r][i];\n                    if (topc != a && topc != b) {\n                        if (a < cols && b < cols)\n                            dp[r][a][b] = max(dp[r][a][b], topv);\n                        else if (a < cols) {\n                            auto res = dfs(dfs, r + 1, a, topc);\n                            if (res != LLONG_MIN)\n                                dp[r][a][b] = max(dp[r][a][b], res + topv);\n                        } else {\n                            auto res = dfs(dfs, r + 1, topc, b);\n                            if (res != LLONG_MIN)\n                                dp[r][a][b] = max(dp[r][a][b], res + topv);\n                        }\n                    }\n                }\n                auto res = dfs(dfs, r + 1, a, b);\n                if (res != LLONG_MIN)\n                    dp[r][a][b] = max(dp[r][a][b], res);\n            }\n            return dp[r][a][b];\n        };\n        return dfs(dfs, 0, cols, cols);\n    }\n};",
    "submit_ts": "1723909114",
    "subm_id": "1359180149"
}