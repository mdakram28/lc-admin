{
    "username": "Vatsal_04V",
    "submission": "class Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        List<Integer> ans = new ArrayList<>();\n        SegTree segTree = new SegTree(nums);\n\n        for (int[] q : queries) {\n            if (q[0] == 1) {  \n                int l = q[1];\n                int r = q[2];\n                if (l == r || l + 1 == r) {\n                    ans.add(0);\n                } else {\n                    ans.add(segTree.query(l + 1, r - 1));\n                }\n            } else if (q[0] == 2) { \n                int idx = q[1];\n                int val = q[2];\n                segTree.update(nums, idx, val);\n                if (idx > 0) {\n                    segTree.update(nums, idx - 1, nums[idx - 1]);\n                }\n                if (idx < nums.length - 1) {\n                    segTree.update(nums, idx + 1, nums[idx + 1]);\n                }\n            }\n        }\n        \n        return ans;\n    }\n    \n    static ArrayList<Integer> Primes = new ArrayList<>();\n    \n    static void sieve(int n){\n        boolean prime[] = new boolean[n+1];\n        for(int i=0;i<=n;i++)\n            prime[i] = true;\n        \n        prime[0] = false;\n        prime[1] = false;\n        for(int p = 2; p*p<=n; p++) {\n            if(prime[p] == true) {\n                for(int i = p*p; i <= n; i += p)\n                    prime[i] = false;\n            }\n        }\n        for(int i = 2; i <= n; i++){\n            if(prime[i] == true)\n                Primes.add(i);\n        }\n    }\n    \n    static ArrayList<Integer> getPrimes(int num) {\n        ArrayList<Integer> ans = new ArrayList<>();\n        if( num < 2 ) { return ans ; }\n        int cnt = 0 ;\n        for ( int i=0;i<Primes.size();i++ ) {\n            while( num % Primes.get(i) == 0 ) {\n                ans.add(Primes.get(i));\n                num /= Primes.get(i) ;\n            }\n        }\n        if( num > 1 ) {\n            ans.add(num);\n            cnt++ ;\n        }\n        return ans ;\n    }\n    \n    static void merge(int arr[], int l, int m, int r) {\n        int n1 = m - l + 1;\n        int n2 = r - m;\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n        int i = 0, j = 0;\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n    \n    static void sort(int arr[], int l, int r) {\n        if (l < r) {\n            int m = l + (r - l) / 2;\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n            merge(arr, l, m, r);\n        }\n    }\n    \n    static class SegTree {\n        int[] tree;\n        int n;\n\n        public SegTree(int[] nums) {\n            n = nums.length;\n            tree = new int[4 * n];\n            build(nums, 0, 0, n - 1);\n        }\n\n        private void build(int[] nums, int node, int start, int end) {\n            if (start == end) {\n                tree[node] = (start > 0 && start < n - 1 && nums[start] > nums[start - 1] && nums[start] > nums[start + 1]) ? 1 : 0;\n            } else {\n                int mid = (start + end) / 2;\n                int left = 2 * node + 1;\n                int right = 2 * node + 2;\n                build(nums, left, start, mid);\n                build(nums, right, mid + 1, end);\n                tree[node] = tree[left] + tree[right];\n            }\n        }\n\n        public void update(int[] nums, int idx, int val) {\n            nums[idx] = val;\n            update(0, 0, n - 1, idx, nums);\n        }\n\n        private void update(int node, int start, int end, int idx, int[] nums) {\n            if (start == end) {\n                tree[node] = (start > 0 && start < n - 1 && nums[start] > nums[start - 1] && nums[start] > nums[start + 1]) ? 1 : 0;\n            } else {\n                int mid = (start + end) / 2;\n                int left = 2 * node + 1;\n                int right = 2 * node + 2;\n                if (idx <= mid) {\n                    update(left, start, mid, idx, nums);\n                } else {\n                    update(right, mid + 1, end, idx, nums);\n                }\n                tree[node] = tree[left] + tree[right];\n            }\n        }\n\n        public int query(int l, int r) {\n            return query(0, 0, n - 1, l, r);\n        }\n\n        private int query(int node, int start, int end, int l, int r) {\n            if (r < start || l > end) {\n                return 0;\n            }\n            if (l <= start && end <= r) {\n                return tree[node];\n            }\n            int mid = (start + end) / 2;\n            int left = 2 * node + 1;\n            int right = 2 * node + 2;\n            int leftQuery = query(left, start, mid, l, r);\n            int rightQuery = query(right, mid + 1, end, l, r);\n            return leftQuery + rightQuery;\n        }\n    }\n}",
    "submit_ts": 1718507960.0
}