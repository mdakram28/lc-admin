{
    "username": "hcpv5",
    "submission": "struct BIT {\n    vector<int> prefix;\n\n    BIT(int n) {\n        prefix.resize(n + 1);\n    }\n\n    void update(int i, int x) {\n        i++;\n        while (i < prefix.size()) {\n            prefix[i] += x;\n            i += lowbit(i);\n        }\n    }\n\n    int query(int i) {    // Get the prefix sum of [1 : i]\n        i++;\n        int sum = 0;\n        while (i > 0) {\n            sum += prefix[i];\n            i -= lowbit(i);\n        }\n        return sum;\n    }\n\nprivate:\n    int lowbit(int x) {\n        return x & (-x);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        BIT* bit = new BIT(n + 1);\n        \n        for (int i = 0; i < n; i++) {\n            if (i > 0 && i < n - 1 && nums[i - 1] < nums[i] && nums[i] > nums[i + 1]) {\n                bit->update(i, 1);\n            }\n        }\n        \n        vector<int> res;\n        for (auto& q : queries) {\n            int type = q[0];\n            if (type == 1) {\n                int l = q[1], r = q[2];\n                int cnt = l + 1 > r - 1 ? 0 : bit->query(r - 1) - bit->query(l);\n                res.push_back(cnt);\n            } else {\n                int i = q[1], val = q[2];\n                int left = bit->query(i - 1) - bit->query(i - 2);\n                int right = bit->query(i + 1) - bit->query(i);\n                int leftVal = i >= 1 ? nums[i - 1] : INT_MAX;\n                int rightVal = i < n - 1 ? nums[i + 1] : INT_MAX;\n                if (val > max(leftVal, rightVal) && nums[i] <= max(leftVal, rightVal)) {\n                    bit->update(i, 1);\n                }\n                if (val <= max(leftVal, rightVal) && nums[i] > max(leftVal, rightVal)) {\n                    bit->update(i, -1);\n                }\n                \n                // Left\n                int ii = i - 1;\n                if (ii >= 0) {\n                    leftVal = ii >= 1 ? nums[ii - 1] : INT_MAX;\n                    rightVal = ii < n - 1 ? nums[ii + 1] : INT_MAX;\n                    int rightValNew = ii < n - 1 ? val : INT_MAX;\n                    if (nums[ii] > max(leftVal, rightValNew) && nums[ii] <= max(leftVal, rightVal)) {\n                        bit->update(ii, 1);\n                    }\n                    if (nums[ii] <= max(leftVal, rightValNew) && nums[ii] > max(leftVal, rightVal)) {\n                        bit->update(ii, -1);\n                    }\n                }\n                    \n                // Right\n                ii = i + 1;\n                if (ii < n) {\n                    leftVal = ii >= 1 ? nums[ii - 1] : INT_MAX;\n                    int leftValNew = ii >= 1 ? val : INT_MAX;\n                    rightVal = ii < n - 1 ? nums[ii + 1] : INT_MAX;\n                    if (nums[ii] > max(leftValNew, rightVal) && nums[ii] <= max(leftVal, rightVal)) {\n                        bit->update(ii, 1);\n                    }\n                    if (nums[ii] <= max(leftValNew, rightVal) && nums[ii] > max(leftVal, rightVal)) {\n                        bit->update(ii, -1);\n                    }\n                }\n                \n                nums[i] = val;\n            }\n        }\n        \n        return res;\n    }\n};",
    "submit_ts": "1718508863",
    "subm_id": "1289693116"
}