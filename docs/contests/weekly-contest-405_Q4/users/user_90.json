{
    "username": "DedsecKnight",
    "submission": "typedef uint64_t ull;\nusing ll = long long;\nstruct H {\n    ull x; H(ull x=0) : x(x) {}\n    H operator+(H o) { return x + o.x + (x + o.x < x); }\n    H operator-(H o) { return *this + ~o.x; }\n    H operator*(H o) { auto m = (__uint128_t)x * o.x;\n        return H((ull)m) + (ull)(m >> 64); }\n    ull get() const { return x + !~x; }\n    bool operator==(H o) const { return get() == o.get(); }\n    bool operator<(H o) const { return get() < o.get(); }\n};\nstatic const H C = (ll)1e11+3; // (order ~ 3e9; random also ok)\n\nstruct HashInterval {\n    vector<H> ha, pw;\n    HashInterval(string& str) : ha(int(str.size())+1), pw(ha) {\n        pw[0] = 1;\n        for (int i = 0; i<int(str.size()); i++)\n            ha[i+1] = ha[i] * C + str[i],\n            pw[i+1] = pw[i] * C;\n    }\n    H hashInterval(int a, int b) { // hash [a, b)\n        return ha[b] - ha[a] * pw[b - a];\n    }};\n\nvector<H> getHashes(string& str, int length) {\n    if (int(str.size()) < length) return {};\n    H h = 0, pw = 1;\n    for (int i = 0; i<length; i++)\n        h = h * C + str[i], pw = pw * C;\n    vector<H> ret = {h};\n    for (int i = length; i < int(str.size()); i++) {\n        ret.push_back(h = h * C + str[i] - pw * str[i-length]);\n    }\n    return ret;\n}\n\nH hashString(const string& s){H h{}; for(char c:s) h=h*C+c;return h;}\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        vector<unordered_map<ull, int>> exists(target.size() + 1);\n        for (int i = 0; i<int(words.size()); i++) {\n            auto v = hashString(words[i]).get();\n            auto sz = words[i].size();\n            if (exists[sz].find(v) == exists[sz].end()) {\n                exists[sz][v] = costs[i];\n            } else {\n                exists[sz][v] = min(exists[sz][v], costs[i]);\n            }\n        }\n        vector<int> indices;\n        for (int i = 0; i<=int(target.size()); i++) {\n            if (!exists[i].empty()) indices.push_back(i);\n        }\n        HashInterval ha{target};\n        vector<int> dp(target.size() + 1, 1e9 + 10);\n        dp.back() = 0;\n        for (int i = int(target.size())-1; i>=0; i--) {\n            for (auto idx : indices) {\n                if (i + idx > target.size()) continue;\n                auto v = ha.hashInterval(i, i + idx).get();\n                if (exists[idx].find(v) != exists[idx].end()) {\n                    dp[i] = min(dp[i], dp[i + idx] + exists[idx][v]);\n                }\n           }\n        }\n        if (dp[0] == 1e9 + 10) {\n            return -1;\n        }\n        return dp[0];\n    }\n};",
    "submit_ts": "1720320683",
    "subm_id": "1312301630"
}