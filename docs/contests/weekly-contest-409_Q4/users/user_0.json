{
    "username": "tsreaper",
    "submission": "class Solution {\npublic:\n    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {\n        int n = colors.size();\n\n        int tree1[n + 1], tree2[n + 1];\n        memset(tree1, 0, sizeof(tree1)); memset(tree2, 0, sizeof(tree2));\n\n        auto lb = [&](int x) { return x & (-x); };\n\n        auto add = [&](int *tree, int pos, int val) {\n            for (; pos <= n; pos += lb(pos)) tree[pos] += val;\n        };\n\n        auto query = [&](int *tree, int pos) {\n            int ret = 0;\n            for (; pos; pos -= lb(pos)) ret += tree[pos];\n            return ret;\n        };\n\n        auto update = [&](int L, int R, int pos, int k) {\n            int old = (R - L + n) % n;\n            if (old == 0) old = n;\n            add(tree1, old, -k); add(tree2, old, -k * old);\n\n            int len = (pos - L + n) % n;\n            if (len == 0) len = n;\n            add(tree1, len, k); add(tree2, len, k * len);\n            len = (R - pos + n) % n;\n            if (len == 0) len = n;\n            add(tree1, len, k); add(tree2, len, k * len);\n        };\n\n        set<int> st;\n\n        auto ins = [&](int pos) {\n            if (st.empty()) {\n                st.insert(pos);\n                add(tree1, n, 1); add(tree2, n, n);\n            } else {\n                auto it = st.insert(pos).first;\n                int L = (it == st.begin() ? *prev(st.end()) : *prev(it));\n                int R = (next(it) == st.end() ? *(st.begin()) : *next(it));\n                update(L, R, pos, 1);\n            }\n        };\n\n        auto del = [&](int pos) {\n            if (st.size() == 1) {\n                st.erase(st.find(pos));\n                add(tree1, n, -1); add(tree2, n, -n);\n            } else {\n                auto it = st.erase(st.find(pos));\n                int L = (it == st.begin() ? *prev(st.end()) : *prev(it));\n                int R = (it == st.end() ? *(st.begin()) : *it);\n                update(L, R, pos, -1);\n            }\n        };\n\n        for (int i = 0; i < n; i++) if (colors[i] == colors[(i + 1) % n]) ins(i);\n        \n        vector<int> ans;\n        for (auto &qry : queries) {\n            if (qry[0] == 1) {\n                if (st.empty()) ans.push_back(n);\n                else {\n                    int sm = query(tree2, n) - query(tree2, qry[1] - 1);\n                    int cnt = query(tree1, n) - query(tree1, qry[1] - 1);\n                    ans.push_back(sm - cnt * qry[1] + cnt);\n                }\n            } else {\n                int idx = qry[1], col = qry[2];\n                int prv = (idx - 1 + n) % n, nxt = (idx + 1) % n;\n                if (colors[prv] == colors[idx]) del(prv);\n                if (colors[idx] == colors[nxt]) del(idx);\n                colors[idx] = col;\n                if (colors[prv] == colors[idx]) ins(prv);\n                if (colors[idx] == colors[nxt]) ins(idx);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722740941",
    "subm_id": "552334779"
}