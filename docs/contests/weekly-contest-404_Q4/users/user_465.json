{
    "username": "urimaj",
    "submission": "class Solution {\npublic:\n    int dfs1(int i, int p, vector<vector<int>>& g, vector<pair<int,int>>& a, vector<pair<int,int>>& b) {\n        int ret = 0;\n        for (int next : g[i]) {\n            if (next != p) {\n                int c = dfs1(next, i, g, a, b);\n                ret = max(ret, c + 1);\n                if (c + 1 > a[i].first) {\n                    b[i] = a[i];\n                    a[i] = {c + 1, next};\n                } else if (c + 1 > b[i].first) {\n                    b[i] = {c + 1, next};\n                }\n            }\n        }\n        return ret;\n    }\n\n    void dfs2(int i, int p, vector<vector<int>>& g, vector<pair<int,int>>& a, vector<pair<int,int>>& b) {\n        if (p != -1) {\n            if (a[p].second == i) {\n                if (b[p].first + 1 > a[i].first) {\n                    b[i] = a[i];\n                    a[i] = {b[p].first + 1, p};\n                } else if (b[p].first + 1 > b[i].first) {\n                    b[i] = {b[p].first + 1, p};\n                }\n            } else {\n                if (a[p].first + 1 > a[i].first) {\n                    b[i] = a[i];\n                    a[i] = {a[p].first + 1, p};\n                } else if (a[p].first + 1 > b[i].first) {\n                    b[i] = {a[p].first + 1, p};\n                }\n            }\n        }\n        for (int next : g[i]) {\n            if (next != p) {\n                dfs2(next, i, g, a, b);\n            }\n        }\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        vector<vector<int>> g1(n);\n        vector<vector<int>> g2(m);\n        for (auto& x : edges1) {\n            g1[x[0]].push_back(x[1]);\n            g1[x[1]].push_back(x[0]);\n        }\n        for (auto& x : edges2) {\n            g2[x[0]].push_back(x[1]);\n            g2[x[1]].push_back(x[0]);\n        }\n        \n        int ans = 0, anss = 0;\n        dfs3(g1, 0, 0, ans);\n        dfs3(g2, 0, 0, anss);\n        \n        vector<pair<int,int>> a1(n), b1(n), a2(m), b2(m);\n        \n        dfs1(0, -1, g1, a1, b1);\n\t\tdfs2(0, -1, g1, a1, b1);\n        dfs1(0, -1, g2, a2, b2);\n\t\tdfs2(0, -1, g2, a2, b2);\n        int ans1 = 1e9, ans2 = 2e9;\n        for (int i = 0; i < n; i++) {\n            ans1 = min(ans1, a1[i].first);\n            // cout << a1[i].first << endl;\n        }\n        cout << endl;\n        for (int i = 0; i < m; i++) {\n            ans2 = min(ans2, a2[i].first);\n            // cout << a2[i].first << endl;\n        }\n        \n        return max(ans, max(anss, ans2 + ans1 + 1));\n    }\n    \n    unordered_map<int, vector<int>> g;\n    \n    int dfs3(vector<vector<int>>& g, int c, int p, int& ans) {\n        // cout << c << \" \" << p << endl;\n        int best = 0;\n        int nbest = 0;\n        for (int next : g[c]) {\n            if (next != p) {\n                int x = dfs3(g, next, c, ans);\n                if (x > best) {\n                    nbest = best;\n                    best = x;\n                }\n                else if (x > nbest) {\n                    nbest = x;\n                }\n            }\n        }\n        ans = max(ans, nbest + best);\n        \n        return best + 1;\n    }\n    \n};",
    "submit_ts": 1719718727.0
}