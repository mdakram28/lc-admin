{
    "username": "faizanhussain2310",
    "submission": "class Solution {\npublic:\n    int findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        if (n == 1) return 0; // Special case with only one node\n        vector<int> degree(n, 0);\n        vector<vector<int>> graph(n);\n        for (auto& edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n            degree[edge[0]]++;\n            degree[edge[1]]++;\n        }\n\n        queue<int> leafQueue;\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 1) leafQueue.push(i);\n        }\n\n        int remainingNodes = n;\n        while (remainingNodes > 2) {\n            int leafCount = leafQueue.size();\n            remainingNodes -= leafCount;\n            for (int i = 0; i < leafCount; i++) {\n                int leaf = leafQueue.front();\n                leafQueue.pop();\n                for (int neighbor : graph[leaf]) {\n                    if (--degree[neighbor] == 1) {\n                        leafQueue.push(neighbor);\n                    }\n                }\n            }\n        }\n\n        vector<int> minHeightTrees;\n        while (!leafQueue.empty()) {\n            minHeightTrees.push_back(leafQueue.front());\n            leafQueue.pop();\n        }\n        return minHeightTrees.front();\n    }\n    \n    void dfs(int node,int par,int curr,vector<int> &level,vector<vector<int>> &adj) {\n        level[node]=curr;\n        \n        for(auto x : adj[node]) {\n            if(x==par) continue;\n            dfs(x,node,curr+1,level,adj);\n        }\n        \n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n=edges1.size()+1;\n        int m=edges2.size()+1;\n        \n        vector<vector<int>> adj1(n+5),adj2(m+5);\n        for(auto x : edges1) {\n            int u=x[0],v=x[1];\n            adj1[u].push_back(v);\n            adj1[v].push_back(u);\n        }\n        for(auto x : edges2) {\n            int u=x[0],v=x[1];\n            adj2[u].push_back(v);\n            adj2[v].push_back(u);\n        }\n        \n        int node1=findMinHeightTrees(n,edges1);\n        int node2=findMinHeightTrees(m,edges2);\n        vector<int> level1(n+5);\n        vector<int> level2(m+5);\n        \n        dfs(node1,-1,0,level1,adj1);\n        dfs(node2,-1,0,level2,adj2);\n        // cout<<\"node1 = \"<<node1<<\" node2 = \"<<node2<<\"\\n\";\n        // for(int i=0; i<n; i++) {\n        //     cout<<\"node = \"<<i<<\" level = \"<<level1[i]<<\"\\n\";\n        // }\n        \n        int large1=-1,large2=-1;\n        int req1=0,req2=0;\n        for(int i=0; i<n; i++) {\n            if(level1[i]>large1) {\n                large1=level1[i];\n                req1=i;\n            }\n        }\n        for(int i=0; i<m; i++) {\n            if(level2[i]>large2) {\n                large2=level2[i];\n                req2=i;\n            }\n        }\n        int diameter=(large1+large2+1);\n        \n        vector<int> level3(n+5);\n        vector<int> level4(m+5);\n        // cout<<\"req1 = \"<<req1<<\" req2 = \"<<req2<<\"\\n\";\n        // cout<<\"lar1 = \"<<large1<<\" lar2 = \"<<large2<<\"\\n\";\n        \n        dfs(req1,-1,0,level3,adj1);\n        dfs(req2,-1,0,level4,adj2);\n        \n        int diameter2=0,diameter3=0;\n        for(auto x : level3) diameter2=max(diameter2,x);\n        for(auto x : level4) diameter3=max(diameter3,x);\n        \n        // cout<<\"dia2 = \"<<diameter2<<\"\\n\";\n        // cout<<\"dia3 = \"<<diameter3<<\"\\n\";\n        \n        return max(diameter,max(diameter2,diameter3));\n    }\n};",
    "submit_ts": 1719719623.0
}