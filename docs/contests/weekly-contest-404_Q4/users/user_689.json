{
    "username": "teaNcode",
    "submission": "class Solution {\npublic:\n    \n    pair<int, int> findCenter(vector<vector<int>> &graph, vector<int> &deg) {\n        int n = graph.size();\n        queue<int> q;\n        for (int i=0;i<n;i++) {\n            if (deg[i] == 1) {\n                q.push(i);\n            }\n        }\n        vector<bool> vis(n, false);\n        int lastVisitedNode = -1;\n        int round = 0;\n        int lastRoundSize = 0;\n        while (!q.empty()) {\n            int size = q.size();\n            lastRoundSize = size;\n            round++;\n            while (size--) {\n                int node = q.front(); q.pop();\n                lastVisitedNode = node;\n                vis[node] = true;\n                for (auto ne : graph[node]) {\n                    if (!vis[ne]) {\n                        deg[ne]--;\n                        if (deg[ne] == 1) {\n                            q.push(ne);\n                        }\n                    }\n                }\n            }\n        }\n        return {lastVisitedNode, lastVisitedNode == -1 ? 0 : 2*(round-1)+(lastRoundSize%2 == 0)};\n    }\n    \n    int findMaxDist(vector<vector<int>> &graph, int source) {\n        int n = graph.size();\n        vector<int> dist(n, INT_MAX);\n        dist[source] = 0;\n        queue<pair<int, int>> q;\n        q.push({source, dist[source]});\n        while (!q.empty()) {\n            auto [node, d] = q.front(); q.pop();\n            if (d > dist[node]) continue;\n            for (int ne : graph[node]) {\n                if (dist[ne] > d + 1) {\n                    dist[ne] = d+1;\n                    q.push({ne, dist[ne]});\n                }\n            }\n        }\n        return *max_element(dist.begin(), dist.end());\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size()+1;\n        int m = edges2.size()+1;\n        vector<int> deg1(n,0);\n        vector<int> deg2(m,0);\n        vector<vector<int>> graph1(n);\n        vector<vector<int>> graph2(m);\n        \n        for (auto &e : edges1) {\n            graph1[e[0]].push_back(e[1]);\n            graph1[e[1]].push_back(e[0]);\n            deg1[e[0]]++;\n            deg1[e[1]]++;\n        }\n        for (auto &e : edges2) {\n            graph2[e[0]].push_back(e[1]);\n            graph2[e[1]].push_back(e[0]);\n            deg2[e[0]]++;\n            deg2[e[1]]++;\n        }\n        \n        pair<int, int> g1 = findCenter(graph1, deg1);\n        pair<int, int> g2 = findCenter(graph2, deg2);\n        int node1 = g1.first, dia1=g1.second, node2=g2.first, dia2=g2.second;\n        int maxDist1 = node1 == -1 ? 0 : findMaxDist(graph1, node1);\n        int maxDist2 = node2 == -1 ? 0 : findMaxDist(graph2, node2);\n        // cout<<node1<<\" \"<<dia1<<\" \"<<maxDist1<<\" | \"<<node2<<\" \"<<dia2<<\" \"<<maxDist2<<endl;\n        return max(maxDist1 + 1 + maxDist2, max(dia1, dia2));\n        \n    }\n};",
    "submit_ts": "1719719245",
    "subm_id": "1304437226"
}