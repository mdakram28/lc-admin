{
    "username": "soundboard",
    "submission": "\nusing ii = pair<int,int>;\n\n\nstruct state{\n\tint sum, lazy;\n\t//lazy contains the value to be propagated\n\n\tstate(int s=0, int l=-1)\n\t{\n    \tsum = s;\n    \tlazy = l;\n\t}\n};\n\n\nstruct ST{\n\tvector<state>T;\n\tvector<int>arr;\n\tST(int n, vector<int>v)\n\t{\n    \tT.clear();T.resize(4*n,state());arr=v;\n\t}\n\n\tstate merge(state a, state b)\n\t{\n    \tstate c = state(0,-1);\n    \tc.sum = a.sum+b.sum;\n    \treturn c;\n\t}\n\n\tvoid push(int node, int l, int r)\n\t{\n    \tif(T[node].lazy!=-1)\n    \t{\n        \t//we can directly calculate this value without updating the substreee\n        \tint val = T[node].lazy;\n        \tT[node].sum = (r-l+1)*val;\n\n        \tif(l!=r)\n        \t{\n            \tT[2*node].lazy = val;\n            \tT[2*node+1].lazy = val;\n        \t}\n\n        \tT[node].lazy = 0;\n    \t}\n\t}\n\n\tvoid build(int node,int l,int r)\n\t{\n    \tif(l==r)\n    \t{\n        \tT[node]={arr[l],-1};\n        \treturn;\n    \t}\n\n    \tint mid = (l+r)/2;\n    \tbuild(2*node,l,mid);\n    \tbuild(2*node+1,mid+1,r);\n\n    \tT[node] = merge(T[2*node],T[2*node+1]);\n\t}\n\n\n\tvoid update(int node,int l,int r,int lq, int rq, int val)\n\t{\n    \tpush(node,l,r);\n    \tif(lq>r || rq<l) return;\n    \tif(l>=lq && r<=rq)\n    \t{\n        \t//we will not go in the subtree further\n        \t//we are being lazy & we'll just tell it to update it later\n        \tT[node].lazy=val;\n        \tpush(node,l,r);\n        \treturn;\n    \t}\n\n    \tint mid = (l+r)/2;\n    \tupdate(2*node,l,mid,lq,rq,val);\n    \tupdate(2*node+1,mid+1,r,lq,rq,val);\n\n    \tT[node] = merge(T[2*node],T[2*node+1]);\n\t}\n\n\tstate query(int node,int l,int r,int lq,int rq)\n\t{\n    \tpush(node,l,r);\n    \tif(l>=lq && r<=rq) return T[node];\n    \telse if(l>rq || r<lq) return state(0,-1);\n\n    \tint mid = (l+r)/2;\n    \treturn (merge(query(2*node,l,mid,lq,rq),query(2*node+1,mid+1,r,lq,rq)));\n\t}\n};\n\n\n\n\n\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& qq) {\n        \n        set<pair<int,int>>t;\n        for(int i=0;i<n;i++) \n        {\n            if(i+1<n)\n            {\n                t.insert({i,i+1});\n            }\n        }\n\n        vector<int>arr(n,1);\n\n        ST a(n,arr);\n        a.build(1,0,n-1);\n\n        int ans = n-1;\n\n        vector<int>p;\n\n        for(auto q:qq)\n        {\n            int i=q[0],j=q[1];\n\n            if((a.query(1,0,n-1,i,i).sum==0) || (a.query(1,0,n-1,j,j).sum==0) || t.count({i,j}))\n            {\n                p.push_back(ans);\n                continue;\n            }\n\n            t.insert({i,j});\n            // cout<<i<<\" dd\"<<j<<endl;\n            cout<<a.query(1,0,n-1,i,i).sum<<\" \"<<a.query(1,0,n-1,j,j).sum<<endl;\n\n            int cnt = a.query(1,0,n-1,i+1,j-1).sum;\n\n            cout<<i+1<<\" \"<<j-1<<endl;\n            a.update(1,0,n-1,i+1,j-1,0);\n\n            cout<<cnt<<endl;\n\n            ans = ans-(cnt+1)+1;\n            p.push_back(ans);\n        }\n\n        return p;\n    }\n};",
    "submit_ts": "1722743734",
    "subm_id": "1343798426"
}