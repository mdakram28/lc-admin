{
    "username": "_mohit__",
    "submission": "class Solution {\npublic:\n        static bool isPeakElement(const vector<int>& arr, int index) {\n        if (index <= 0 || index >= arr.size() - 1) return false;\n        return arr[index] > arr[index - 1] && arr[index] > arr[index + 1];\n    }\n    class SegmentTree {\n    private:\n        vector<int> segment;\n        int length;\n        void buildTree(const vector<int>& arr, int node, int start, int end) {\n            if (start == end) {\n                segment[node] = isPeakElement(arr, start) ? 1 : 0;\n            } else {\n                int mid = (start + end) / 2;\n                buildTree(arr, 2 * node + 1, start, mid);\n                buildTree(arr, 2 * node + 2, mid + 1, end);\n                segment[node] = segment[2 * node + 1] + segment[2 * node + 2];\n            }\n        }\n        void updateTree(const vector<int>& arr, int node, int start, int end, int index) {\n            if (start == end) {\n                segment[node] = isPeakElement(arr, index) ? 1 : 0;\n            } else {\n                int mid = (start + end) / 2;\n                if (start <= index && index <= mid) {\n                    updateTree(arr, 2 * node + 1, start, mid, index);\n                } else {\n                    updateTree(arr, 2 * node + 2, mid + 1, end, index);\n                }\n                segment[node] = segment[2 * node + 1] + segment[2 * node + 2];\n            }\n        }\n        int queryTree(int node, int start, int end, int left, int right) {\n            if (right < start || end < left) {\n                return 0;\n            }\n            if (left <= start && end <= right) {\n                return segment[node];\n            }\n            int mid = (start + end) / 2;\n            int leftQuery = queryTree(2 * node + 1, start, mid, left, right);\n            int rightQuery = queryTree(2 * node + 2, mid + 1, end, left, right);\n            return leftQuery + rightQuery;\n        }\n    public:\n        SegmentTree(const vector<int>& arr) {\n            length = arr.size();\n            segment.resize(4 * length+5);\n            buildTree(arr, 0, 0, length - 1);\n        }\n\n        void update(const vector<int>& arr, int index) {\n            updateTree(arr, 0, 0, length - 1, index);\n        }\n\n        int query(int left, int right) {\n            return queryTree(0, 0, length - 1, left, right);\n        }\n    };\n    vector<int> countOfPeaks(vector<int>& arr, vector<vector<int>>& queries) {\n               int n = arr.size();\n        vector<int> results;\n        SegmentTree segTree(arr);\n        for ( auto query : queries) {\n            if (query[0] == 1) {\n                results.push_back(segTree.query(query[1] + 1, query[2] - 1));\n            } else if (query[0] == 2) {\n                arr[query[1]] = query[2];\n                if (query[1] > 0) segTree.update(arr, query[1] - 1);\n                segTree.update(arr, query[1]);\n                if (query[1] < n - 1) segTree.update(arr, query[1] + 1);\n            }\n        }\n\n        return results;\n    }\n};",
    "submit_ts": 1718509020.0
}