{
    "username": "Heltion",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef DEBUG\n#include \"debug.hpp\"\n#else\n#define debug(...) (void)0\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type, std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type, std::false_type>::type;\n\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value, __uint128_t,\n                              unsigned __int128>;\n\ntemplate <class T>\nusing is_integral =\n    typename std::conditional<std::is_integral<T>::value ||\n                                  is_signed_int128<T>::value ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type, std::false_type>::type;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_signed<T>::value) ||\n                                  is_signed_int128<T>::value,\n                              std::true_type, std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type, std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value, make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value, std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n\n#else\n\ntemplate <class T>\nusing is_integral = typename std::is_integral<T>;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type, std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type, std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned =\n    typename std::conditional<is_signed_int<T>::value, std::make_unsigned<T>,\n                              std::common_type<T>>::type;\n\n#endif\n\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\ntemplate <class T>\nusing to_unsigned_t = typename to_unsigned<T>::type;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\nnamespace atcoder {\n\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T>\nstruct fenwick_tree {\n  using U = internal::to_unsigned_t<T>;\n\n public:\n  fenwick_tree() : _n(0) {}\n  explicit fenwick_tree(int n) : _n(n), data(n) {}\n\n  void add(int p, T x) {\n    assert(0 <= p && p < _n);\n    p++;\n    while (p <= _n) {\n      data[p - 1] += U(x);\n      p += p & -p;\n    }\n  }\n\n  T sum(int l, int r) {\n    assert(0 <= l && l <= r && r <= _n);\n    return sum(r) - sum(l);\n  }\n\n private:\n  int _n;\n  std::vector<U> data;\n\n  U sum(int r) {\n    U s = 0;\n    while (r > 0) {\n      s += data[r - 1];\n      r -= r & -r;\n    }\n    return s;\n  }\n};\n\n}  // namespace atcoder\n\nclass Solution {\n public:\n  vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n    int n = nums.size();\n    auto check = [&](int i) {\n      return i > 0 and i + 1 < n and nums[i] > nums[i - 1] and\n             nums[i] > nums[i + 1];\n    };\n    atcoder::fenwick_tree<int> ft(n);\n    for (int i = 1; i + 1 < n; i += 1)\n      if (check(i)) ft.add(i, 1);\n    vector<int> ans;\n    for (auto& v : queries) {\n      if (v[0] == 1) {\n        int l = v[1], r = v[2];\n        if (l + 1 >= r) {\n          ans.push_back(0);\n        } else {\n          ans.push_back(ft.sum(l + 1, r));\n        }\n      } else {\n        int i = v[1], x = v[2];\n        for (int d : {-1, 0, 1})\n          if (check(i + d)) ft.add(i + d, -1);\n        nums[i] = x;\n        for (int d : {-1, 0, 1})\n          if (check(i + d)) ft.add(i + d, 1);\n      }\n    }\n    return ans;\n  }\n};\n#ifdef DEBUG\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n}\n#endif",
    "submit_ts": 1718505723.0
}