{
    "username": "shu-xi",
    "submission": "# \u6a21\u677f: \u7ebf\u6bb5\u6811\nclass SegTree:\n    def __init__(self, a):\n        self.a, self.n = [0] + a, len(a)\n        self.d = [0 for i in range(4*self.n)]\n        self.b = [0 for i in range(4*self.n)] # for lazy update\n        self.v = [0 for i in range(4*self.n)] # for update2\n        self.__build(1, self.n, 1)\n    def __build(self, s, t, p): # build [s, t]\n        if s == t:\n            self.d[p] = self.a[s]\n            return\n        m = s + ((t - s) >> 1)\n        self.__build(s, m, p * 2)\n        self.__build(m + 1, t, p * 2 + 1)\n        self.d[p] = self.d[p * 2] + self.d[(p * 2) + 1]\n    def __update(self, l, r, c, s, t, p):\n        if l <= s and t <= r:\n            self.d[p] = self.d[p] + (t - s + 1) * c\n            self.b[p] = self.b[p] + c\n            return\n        m = s + ((t - s) >> 1)\n        if self.b[p] and s != t:\n            self.d[p * 2] = self.d[p * 2] + self.b[p] * (m - s + 1)\n            self.d[p * 2 + 1] = self.d[p * 2 + 1] + self.b[p] * (t - m)\n            self.b[p * 2] = self.b[p * 2] + self.b[p]\n            self.b[p * 2 + 1] = self.b[p * 2 + 1] + self.b[p]\n            self.b[p] = 0\n        if l <= m:\n            self.__update(l, r, c, s, m, p * 2)\n        if r > m:\n            self.__update(l, r, c, m + 1, t, p * 2 + 1)\n        self.d[p] = self.d[p * 2] + self.d[p * 2 + 1]\n    def update(self, l, r, c): # update [l, r] to add c\n        self.__update(l+1, r+1, c, 1, self.n, 1)\n    def __update2(self, l, r, c, s, t, p):\n        if l <= s and t <= r:\n            self.d[p] = (t - s + 1) * c\n            self.b[p] = c\n            self.v[p] = 1\n            return\n        m = s + ((t - s) >> 1)\n        if self.v[p]:\n            self.d[p * 2] = self.b[p] * (m - s + 1)\n            self.d[p * 2 + 1] = self.b[p] * (t - m)\n            self.b[p * 2] = self.b[p * 2 + 1] = self.b[p]\n            self.v[p * 2] = self.v[p * 2 + 1] = 1\n            self.v[p] = 0\n        if l <= m:\n            self.__update2(l, r, c, s, m, p * 2)\n        if r > m:\n            self.__update2(l, r, c, m + 1, t, p * 2 + 1)\n        self.d[p] = self.d[p * 2] + self.d[p * 2 + 1]\n    def update2(self, l, r, c): # update [l, r] to update to c\n        self.__update2(l+1, r+1, c, 1, self.n, 1)\n    def __getsum(self, l, r, s, t, p):\n        if l <= s and t <= r:\n            return self.d[p]\n        m = s + ((t - s) >> 1)\n        if self.b[p]:\n            self.d[p * 2] = self.d[p * 2] + self.b[p] * (m - s + 1)\n            self.d[p * 2 + 1] = self.d[p * 2 + 1] + self.b[p] * (t - m)\n            self.b[p * 2] = self.b[p * 2] + self.b[p]\n            self.b[p * 2 + 1] = self.b[p * 2 + 1] + self.b[p]\n            self.b[p] = 0\n        res = 0\n        if l <= m:\n            res = self.__getsum(l, r, s, m, p * 2)\n        if r > m:\n            res = res + self.__getsum(l, r, m + 1, t, p * 2 + 1)\n        return res\n    def getsum(self, l, r): # getsum [l, r]\n        return self.__getsum(l+1, r+1, 1, self.n, 1)\nclass Solution:\n    def numberOfAlternatingGroups(self, colors: List[int], k: int) -> int:\n        res = 0\n        n = len(colors)\n        ok = [1 for i in range(n)] # [i, i+k-1]\n        seg = SegTree(ok)\n        for j in range(n):\n            if colors[j] == colors[(j+1)%n]:\n                # update i in [j-k+2, j]\n                l, r = (j-k+2)%n, j\n                if l < r:\n                    seg.update2(l, r, 0)\n                else:\n                    seg.update2(0, r, 0)\n                    seg.update2(l, n-1, 0)\n        return seg.getsum(0, n-1)",
    "submit_ts": "1720278773",
    "subm_id": "544564297"
}