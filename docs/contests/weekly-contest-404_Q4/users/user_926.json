{
    "username": "cswizardry",
    "submission": "class Solution {\n    void dfs(int node, int dist, int& maxDist, int& farNode, vector<bool>& visited, vector<vector<int>>& graph) {\n        // find diameter\n        visited[node] = true;\n        if (dist > maxDist) {\n            maxDist = dist;\n            farNode = node;\n        }\n        for (int adjNode : graph[node]) {\n            if (!visited[adjNode]) {\n                dfs(adjNode, dist + 1, maxDist, farNode, visited, graph);\n            }\n        }\n    }\n    void findDiameterAndRadius(vector<vector<int>>& graph, int& radius, int& diameter) {\n        int farNode = 0;\n        int maxDist = 0;\n        int n = graph.size();\n        vector<bool> visited(n, false);\n        dfs(0, 0, maxDist, farNode, visited, graph);\n        visited = vector<bool>(n, false);\n        dfs(farNode, 0, maxDist, farNode, visited, graph);\n        diameter = maxDist;\n        radius = (diameter + 1) / 2;\n    }\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        vector<vector<int>> graph1(n);\n        vector<vector<int>> graph2(m);\n        for (vector<int>& edge : edges1) {\n            graph1[edge[0]].push_back(edge[1]);\n            graph1[edge[1]].push_back(edge[0]);\n        }\n        for (vector<int>& edge : edges2) {\n            graph2[edge[0]].push_back(edge[1]);\n            graph2[edge[1]].push_back(edge[0]);\n        }\n        int diameter1 = 0;\n        int diameter2 = 0;\n        int radius1 = 0;\n        int radius2 = 0;\n        findDiameterAndRadius(graph1, radius1, diameter1);\n        findDiameterAndRadius(graph2, radius2, diameter2);\n        return max(radius1 + radius2 + 1, max(diameter1, diameter2));;\n    }\n};",
    "submit_ts": 1719718159.0
}