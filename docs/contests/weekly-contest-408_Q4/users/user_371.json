{
    "username": "tamuraup",
    "submission": "impl Solution {\n    pub fn can_reach_corner(x: i32, y: i32, circles: Vec<Vec<i32>>) -> bool {\n        can_reach_corner(x,y,circles)\n    }\n}\n\npub use __cargo_equip::prelude::*;\n\nuse acl_dsu::Dsu;\nuse myproconlib_utils::*;\npub fn can_reach_corner(X: i32, Y: i32, circles: Vec<Vec<i32>>) -> bool {\n    let N = circles.len();\n    let mut uf = Dsu::new(N + 2);\n    let LI = N;\n    let RI = N + 1;\n    for i in 0..circles.len() {\n        let x = circles[i][0];\n        let y = circles[i][1];\n        let r = circles[i][2];\n        if x - r <= 0 {\n            uf.merge(LI, i);\n            db!(\"li\", i);\n        }\n        if x + r >= X {\n            uf.merge(RI, i);\n            db!(\"ri\", i);\n        }\n        if y - r <= 0 {\n            uf.merge(RI, i);\n            db!(\"ri2\", i);\n        }\n        if y + r >= Y {\n            uf.merge(LI, i);\n            db!(\"li2\", i);\n        }\n        for j in 0..i {\n            let x2 = circles[j][0];\n            let y2 = circles[j][1];\n            let r2 = circles[j][2];\n            let dx = (x - x2) as i64;\n            let dy = (y - y2) as i64;\n\n            db!(dx * dx + dy * dy, (r as i64 + r2 as i64).pow(2));\n            if dx * dx + dy * dy <= (r as i64 + r2 as i64).pow(2) {\n                uf.merge(i, j);\n                db!(i, j);\n            }\n        }\n    }\n    !uf.same(LI, RI)\n}\nfn _main() {\n    let X = 3;\n    let Y = 3;\n    let circles = vec![vec![2, 1, 1], vec![1, 2, 1]];\n    can_reach_corner(X, Y, circles);\n}\n\n\n#[cfg_attr(any(), rustfmt::skip)]\n#[allow(unused)]\nmod __cargo_equip {\n    pub(crate) mod crates {\n        pub mod acl_dsu {pub use self::dsu::*;mod dsu{pub struct Dsu{n:usize,parent_or_size:Vec<i32>,}impl Dsu{pub fn new(size:usize)->Self{Self{n:size,parent_or_size:vec![-1;size],}}pub fn merge(&mut self,a:usize,b:usize)->usize{assert!(a<self.n);assert!(b<self.n);let(mut x,mut y)=(self.leader(a),self.leader(b));if x==y{return x;}if-self.parent_or_size[x]< -self.parent_or_size[y]{std::mem::swap(&mut x,&mut y);}self.parent_or_size[x]+=self.parent_or_size[y];self.parent_or_size[y]=x as i32;x}pub fn same(&mut self,a:usize,b:usize)->bool{assert!(a<self.n);assert!(b<self.n);self.leader(a)==self.leader(b)}pub fn leader(&mut self,a:usize)->usize{assert!(a<self.n);if self.parent_or_size[a]<0{return a;}self.parent_or_size[a]=self.leader(self.parent_or_size[a]as usize)as i32;self.parent_or_size[a]as usize}pub fn size(&mut self,a:usize)->usize{assert!(a<self.n);let x=self.leader(a);-self.parent_or_size[x]as usize}pub fn groups(&mut self)->Vec<Vec<usize>>{let mut leader_buf=vec![0;self.n];let mut group_size=vec![0;self.n];for i in 0..self.n{leader_buf[i]=self.leader(i);group_size[leader_buf[i]]+=1;}let mut result=vec![Vec::new();self.n];for i in 0..self.n{result[i].reserve(group_size[i]);}for i in 0..self.n{result[leader_buf[i]].push(i);}result.into_iter().filter(|x|!x.is_empty()).collect::<Vec<Vec<usize>>>()}}}}\n        pub mod myproconlib_utils {pub use crate::__cargo_equip::macros::myproconlib_utils::*;use std::ops::{Add,Rem};#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_mat{($($e:expr),*)=>{Vec::from(vec![$($e),*])};($($e:expr,)*)=>{Vec::from(vec![$($e),*])};($e:expr;$d:expr)=>{Vec::from(vec![$e;$d])};($e:expr;$d:expr$(;$ds:expr)+)=>{Vec::from(vec![mat![$e$(;$ds)*];$d])};}macro_rules!mat{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_mat!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_ec{($($num:expr),*)=>{let mut tmp=vec![];$(tmp.push(format!(\"{}\",$num));)*print!(\"{}\n\",tmp.join(\" \"));};}macro_rules!ec{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_ec!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_YesNo{($num:expr)=>{if($num)as i64==0{println!(\"No\");}else{println!(\"Yes\");}};}macro_rules!YesNo{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_YesNo!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_Yes{()=>{println!(\"Yes\");};}macro_rules!Yes{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_Yes!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_No{()=>{println!(\"No\");};}macro_rules!No{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_No!{$($tt)*})}pub trait SetMinMax{fn setmin(&mut self,v:Self)->bool;fn setmax(&mut self,v:Self)->bool;}impl<T>SetMinMax for T where T:PartialOrd,{fn setmin(&mut self,v:T)->bool{*self>v&&{*self=v;true}}fn setmax(&mut self,v:T)->bool{*self<v&&{*self=v;true}}}#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_chmax{($lhs:expr,$rhs:expr)=>{if$lhs<$rhs{let tmp=$rhs;$lhs=tmp;true}else{false}};}macro_rules!chmax{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_chmax!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_chmin{($lhs:expr,$rhs:expr)=>{if$lhs>$rhs{let tmp=$rhs;$lhs=tmp;true}else{false}};}macro_rules!chmin{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_chmin!{$($tt)*})}pub fn print_vec<T>(v:&[T])where T:std::fmt::Display,{for i in 0..v.len(){print!(\"{}{}\",v[i],if i+1==v.len(){\"\"}else{\" \"});}println!();}pub fn pmod<T:Copy+Add<Output=T>+Rem<Output=T>>(x:T,m:T)->T{((x%m)+m)%m}pub fn lower_bound<T>(a:&[T],x:&T)->usize where T:Ord,{if a.len()==0||a[0]>=*x{return 0;}let mut l=0;let mut r=a.len();while l+1<r{let m=(l+r)/2;if a[m]<*x{l=m;}else{r=m;}}r}pub fn upper_bound<T>(a:&[T],x:&T)->usize where T:Ord,{if a.len()==0||a[0]>*x{return 0;}let mut l=0;let mut r=a.len();while l+1<r{let m=(l+r)/2;if a[m]<=*x{l=m;}else{r=m;}}r}#[allow(unused_macros)]#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_db{($($a:expr),*$(,)*)=>{#[cfg(debug_assertions)]eprintln!(concat!($(\"| \",stringify!($a),\"={:?} \"),*),$(&$a),*);};}macro_rules!db{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_db!{$($tt)*})}#[allow(unused_macros)]#[macro_export]macro_rules!__cargo_equip_macro_def_myproconlib_utils_db2d{($vec:expr)=>{#[cfg(debug_assertions)]{eprintln!(\"> {}=\",stringify!($vec));for a in$vec.iter(){eprintln!(\"> {:?}\",a);}}};}macro_rules!db2d{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_myproconlib_utils_db2d!{$($tt)*})}#[derive(PartialEq,PartialOrd,Clone,Copy)]pub struct OrdF<T>(pub T);impl<T:PartialEq>Eq for OrdF<T>{}impl<T:PartialOrd>Ord for OrdF<T>{fn cmp(&self,other:&OrdF<T>)->std::cmp::Ordering{self.0.partial_cmp(&other.0).unwrap()}}}\n    }\n\n    pub(crate) mod macros {\n        pub mod acl_dsu {}\n        pub mod myproconlib_utils {pub use crate::{__cargo_equip_macro_def_myproconlib_utils_No as No,__cargo_equip_macro_def_myproconlib_utils_Yes as Yes,__cargo_equip_macro_def_myproconlib_utils_YesNo as YesNo,__cargo_equip_macro_def_myproconlib_utils_chmax as chmax,__cargo_equip_macro_def_myproconlib_utils_chmin as chmin,__cargo_equip_macro_def_myproconlib_utils_db as db,__cargo_equip_macro_def_myproconlib_utils_db2d as db2d,__cargo_equip_macro_def_myproconlib_utils_ec as ec,__cargo_equip_macro_def_myproconlib_utils_mat as mat};}\n    }\n\n    pub(crate) mod prelude {pub use crate::__cargo_equip::crates::*;}\n\n    mod preludes {\n        pub mod acl_dsu {}\n        pub mod myproconlib_utils {}\n    }\n}\n",
    "submit_ts": "1722137488",
    "subm_id": "1335765254"
}