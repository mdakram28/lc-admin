{
    "username": "indreshrsingh",
    "submission": "class Solution {\npublic:\n    \n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        if(n==0)\n            return {};\n        if(n==1)\n            return {0};\n        vector<int>res;\n        vector<int>degrees(n,0);\n        vector<vector<int>>adj(n);\n        for(int i=0;i<edges.size();i++)\n        {\n            adj[edges[i][0]].push_back(edges[i][1]);//creating adjacent list\n            adj[edges[i][1]].push_back(edges[i][0]);\n            degrees[edges[i][1]]++;//updating how many edges each node has\n            degrees[edges[i][0]]++;\n        }\n        queue<int>queue;\n        for(int i=0;i<n;i++)\n        {\n            if(degrees[i]==1)//adding all the leave nodes\n                queue.push(i);\n        }\n        while(!queue.empty())\n        {\n            res.clear();// clear vector before we start traversing level by level.\n            int size=queue.size();\n            for(int i=0;i<size;i++)\n            {\n                int cur=queue.front();\n                queue.pop();\n                res.push_back(cur);//adding nodes to vector.Goal is to get a vector of  just 1 or 2 nodes available.\n                for(auto &neighbor:adj[cur])\n                {\n                    degrees[neighbor]--;//removing current leave nodes\n                    if(degrees[neighbor]==1)//adding current leave nodes\n                        queue.push(neighbor);\n                }\n            }\n        }\n        return res;\n    }\n\n    pair<int,int> bfs(int v,int n,vector<vector<int>>& edges)\n    {\n        int dist[n+1];\n        int vis[n+1];\n        for(int i=0;i<=n;i++) dist[i]=0,vis[i]=0;\n        dist[v]=0;\n        queue<int> q;\n        q.push(v);\n        vis[v]=1;\n        int mx=0,ver=v;\n        vector<vector<int>>adj(n);\n        for(int i=0;i<edges.size();i++)\n        {\n            adj[edges[i][0]].push_back(edges[i][1]);//creating adjacent list\n            adj[edges[i][1]].push_back(edges[i][0]);\n            \n        }\n        while(!q.empty())\n        {\n            int v1=q.front();\n            q.pop();        \n            for(int u:adj[v1])\n        {   \n            if(!vis[u])\n            {\n                vis[u]=1;\n                dist[u]=dist[v1]+1;\n                q.push(u);\n                if(dist[u]>mx)\n                mx=max(mx,dist[u]),ver=u;\n            }\n        }\n        }\n        return {mx,ver};\n        \n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        vector<int> v1=findMinHeightTrees(edges1.size()+1,edges1);\n        vector<int> v2=findMinHeightTrees(edges2.size()+1,edges2);\n        auto  dist1=bfs(v1[0],edges1.size()+1,edges1);\n        auto dist2=bfs(v2[0],edges2.size()+1,edges2);\n        auto dist3=bfs(dist1.second,edges1.size()+1,edges1);\n        auto dist4=bfs(dist2.second,edges2.size()+1,edges2);\n        \n        return max({dist1.first+dist2.first+1,dist3.first,dist4.first});\n        \n        \n    }\n};",
    "submit_ts": 1719715893.0
}