{
    "username": "mikasaaaa",
    "submission": "class Solution {\npublic:\n    vector<int> bfs(int start, int n, const vector<vector<int>>& adj) {\n        vector<int> dis(n, -1);\n        queue<int> q;\n        q.push(start);\n        dis[start] = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            for (auto it : adj[node]) {\n                if (dis[it] == -1) {\n                    dis[it] = dis[node] + 1;\n                    q.push(it);\n                }\n            }\n        }\n        return dis;\n    }\n\n    int diameter(const vector<vector<int>>& adj, int n) {\n        vector<int> dis1 = bfs(0, n, adj);\n        int fn = max_element(dis1.begin(), dis1.end()) - dis1.begin();\n        vector<int> dis2 = bfs(fn, n, adj);\n        return *max_element(dis2.begin(), dis2.end());\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n\n        vector<vector<int>> adj1(n);\n        for (const auto& it : edges1) {\n            adj1[it[0]].push_back(it[1]);\n            adj1[it[1]].push_back(it[0]);\n        }\n\n        vector<vector<int>> adj2(m);\n        for (const auto& it : edges2) {\n            adj2[it[0]].push_back(it[1]);\n            adj2[it[1]].push_back(it[0]);\n        }\n\n        int d1 = diameter(adj1, n);\n        int d2 = diameter(adj2, m);\n\n        return max(d1, max(d2, (d1+1)/2 + (d2+1)/2 + 1));\n    }\n};",
    "submit_ts": "1719717001",
    "subm_id": "1304379814"
}