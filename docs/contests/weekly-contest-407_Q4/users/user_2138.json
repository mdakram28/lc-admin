{
    "username": "shashankag",
    "submission": "template <typename T, typename U>\nclass lazySegTree {\npublic:\n    int n;\n    vector<T> st;\n    vector<U> lazy;\n    \n    // Identity element for segment tree data\n    T SID = {INT_MAX, -1};\n    \n    // Identity element for lazy update\n    U LID = 0;\n    \n    T comb(T a, T b) {\n        if (a.first > b.first)\n            return b;\n        return a;\n    }\n    \n    lazySegTree(int _n) : n(_n) {\n        st.resize(4 * n, SID);\n        lazy.resize(4 * n, LID);\n    }\n    \n    void build(int node, int l, int r, vector<T> &v) {\n        if(l == r) {\n            st[node] = v[l];\n        } else {\n            int m = (l + r)/2;\n            build(2*node + 1, l, m, v);\n            build(2*node + 2, m+1, r, v);\n            pull(node);\n        }\n    }\n    \n    void pull(int node) {\n        st[node] = comb(st[2*node + 1], st[2*node + 2]);\n    }\n    \n    void push(int node, int l, int r) {\n        st[node].first += lazy[node]; // for sum multiply by (r - l + 1)\n        \n        if(l != r) {\n            lazy[2*node + 1] += lazy[node];\n            lazy[2*node + 2] += lazy[node];\n        }\n        lazy[node] = LID;\n    }\n    \n    void apply(int l, int r, int val) {\n        return apply(0, 0, n-1, val, l, r);\n    }\n    \n    void apply(int node, int tl, int tr, int val, int l, int r) {\n        // tl and tr are tree left and right\n        // apply val on range [l .. r] => increases value by val\n        push(node, tl, tr);\n        \n        // do not intersect\n        if (r < tl || tr < l) return;\n        \n        // completely overlaps(lies inside) with [l..r]\n        if (l <= tl && tr <= r) {\n            lazy[node] += val;\n            push(node, tl, tr);\n            return;\n        }\n        \n        // intersects\n        int tm = (tl + tr)/2;\n        apply(2*node + 1, tl, tm, val, l, r);\n        apply(2*node + 2, tm+1, tr, val, l, r);\n        pull(node);\n    }\n    \n    T query(int l, int r) {\n        return query(0, 0, n-1, l, r);\n    }\n    \n    T query(int node, int tl, int tr, int l, int r) {\n        push(node, tl, tr);\n        \n        // lies outside\n        if(r < tl || tr < l) return SID;\n        \n        // lies inside\n        if(l <= tl && tr <= r) return st[node];\n        \n        int tm = (tl + tr)/2;\n        return comb(query(2*node+1, tl, tm, l, r), query(2*node + 2, tm + 1, tr, l, r));\n    }\n};\n\nlong long findMin(int l, int r, vector<pair<int, int>> &v, lazySegTree<pair<int, int>, int> &st) {\n    if (l > r)\n        return 0;\n    pair<int, int> x = st.query(l, r);\n    int id = x.second;\n    long long val = x.first;\n    st.apply(l, r, -val);\n    return val + findMin(l, id - 1, v, st) + findMin(id + 1, r, v, st);\n}\n\nclass Solution {\npublic:\n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n        int n = nums.size();\n        vector<pair<int, int>> v(n), temp(n);\n        for (int i = 0; i < n; i++) {\n            temp[i] = {target[i] - nums[i], i};\n            v[i] = {abs(target[i] - nums[i]), i};\n        }\n        lazySegTree<pair<int, int>, int> st(n);\n        st.build(0, 0, n - 1, v);\n        long long ans = 0;\n        int i = 0;\n        while (i < n) {\n            if (temp[i].first == 0) {\n                i++;\n                continue;\n            }\n            int j = i;\n            while (j < n && temp[j].first > 0)\n                j++;\n            if (j > i) {\n                ans += findMin(i, j - 1, v, st);\n            }\n            i = j;\n            while (j < n && temp[j].first < 0)\n                j++;\n            if (j > i) {\n                ans += findMin(i, j - 1, v, st);\n            }\n            i = j;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1721533740",
    "subm_id": "1328015619"
}