{
    "username": "knikhil352000",
    "submission": "\nclass Solution {\npublic:\n    struct Node {\n      int sum;\n      int lazy;\n      Node() {\n        sum = 0;\n        lazy = 0; \n      }\n    };\n\n    Node seg[4 * 200001];\n\n    void push(int id, int l, int r) {\n      if(seg[id].lazy != 0) {\n        // if there is lazy apply and push it down \n        // apply logic\n        seg[id].sum += seg[id].lazy * (r - l + 1);\n        seg[id].sum = max(0, seg[id].sum);\n\n        // push it down\n        if(l != r) {\n          seg[2 * id].lazy += seg[id].lazy;\n          seg[2 * id + 1].lazy += seg[id].lazy;\n          seg[2 * id].lazy = max(-1, seg[2 * id].lazy);\n          seg[2 * id + 1].lazy = max(-1, seg[2 * id + 1].lazy);\n        }\n\n        // clear your lazy\n        seg[id].lazy = 0;\n      }\n    }\n\n    Node merge(Node a, Node b) {\n      Node temp;\n      temp.sum = a.sum + b.sum;\n      return temp;\n    }\n\n    void build(int id, int l, int r) {\n      if(l == r) {\n        seg[id].sum = 1;\n        seg[id].lazy = 0;\n        return;\n      }\n      int mid = (l + r) / 2;\n      build(2*id, l, mid);\n      build(2*id + 1, mid + 1, r);\n      // seg[id] = merge(seg[1 << id], seg[1 << id | 1])\n      seg[id] = merge(seg[2 * id], seg[2 * id + 1]);\n    }\n\n    void update(int id, int l, int r, int lq, int rq, int val) {\n      push(id, l, r);\n      if(rq < l || lq > r) return;\n      if(lq <= l && rq >= r) {\n        seg[id].lazy += val;\n        push(id, l, r);\n        return;\n      }\n      int mid = (l + r) / 2;\n      update(2*id, l, mid, lq, rq, val);\n      update(2*id + 1, mid + 1, r, lq, rq, val);\n      seg[id] = merge(seg[2 * id], seg[2 * id + 1]);\n    }\n\n    Node query(int id, int l, int r, int lq, int rq) {\n      push(id, l, r);\n      if(l > rq || r < lq) return Node();\n      if(l >= lq && r <= rq) {\n        return seg[id];\n      }\n      int mid = (l + r) / 2;\n      Node left = query(2 * id, l, mid, lq, rq);\n      Node right = query(2 * id + 1, mid + 1, r, lq, rq);\n      return merge(left, right);\n    }\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        build(1, 0, n - 1);\n        int q = queries.size();\n        vector<int> ans(q, 0);\n        update(1, 0, n - 1, n - 1, n - 1, -1);\n        for(int i = 0; i < q; i++) {\n            update(1, 0, n - 1, queries[i][0] + 1, queries[i][1] == n - 1 ? queries[i][1] : queries[i][1] - 1, -1);\n            ans[i] = query(1, 0, n - 1, 0, n - 1).sum;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722741001",
    "subm_id": "1343734102"
}