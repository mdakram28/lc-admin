{
    "username": "Ani_S",
    "submission": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int first = minimumOfMaxHeightAtNode(edges1, edges1.length + 1);\n        int second = minimumOfMaxHeightAtNode(edges2, edges2.length + 1);\n        \n        int f = (first + 1) / 2;\n        int s = (second + 1) / 2;\n        \n        return Math.max(f + s + 1, Math.max(first, second));\n    }\n    \n    int diameter;\n    \n    private int minimumOfMaxHeightAtNode(int[][] edges, int size) {\n        \n        List<List<Integer>> tree = new ArrayList<>();\n        \n        for(int i = 0; i < size; i++)\n            tree.add(new ArrayList<>());\n        \n        for(int edge[] : edges) {\n            tree.get(edge[0]).add(edge[1]);\n            tree.get(edge[1]).add(edge[0]);\n        }\n        \n        int height[] = new int[size];\n        diameter = 0;\n        \n        dfs(tree, 0, -1);\n        \n        return diameter;\n    }\n    \n    private int dfs(List<List<Integer>> tree, int node, int parent) {\n        int max = 0;\n        int smax = 0;\n        \n        for(int next : tree.get(node)) {\n            if(next == parent)\n                continue;\n            \n            int val = dfs(tree, next, node);\n            \n            if(val >= max) {\n                smax = max;\n                max = val;\n            } else if(val >= smax)\n                smax = val;\n        }\n        \n        diameter = Math.max(diameter, max + smax);\n        \n        return max + 1;\n    }\n}",
    "submit_ts": "1719717842",
    "subm_id": "1304402144"
}