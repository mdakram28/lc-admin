{
    "username": "JhaAdarsh002",
    "submission": "class Solution {\n    vector<int> nums;\n    vector<int> peaks;\n    vector<int> segTree;\n\n    void build(int pos, int left, int right) {\n        if (left == right) {\n            segTree[pos] = peaks[left];\n            return;\n        }\n        int mid = (left + right) / 2;\n        build(2 * pos + 1, left, mid);\n        build(2 * pos + 2, mid + 1, right);\n        segTree[pos] = segTree[2 * pos + 1] + segTree[2 * pos + 2];\n    }\n\n    void updateSegTree(int pos, int left, int right, int idx) {\n        if (left == right) {\n            segTree[pos] = peaks[left];\n            return;\n        }\n        int mid = (left + right) / 2;\n        if (idx <= mid) {\n            updateSegTree(2 * pos + 1, left, mid, idx);\n        } else {\n            updateSegTree(2 * pos + 2, mid + 1, right, idx);\n        }\n        segTree[pos] = segTree[2 * pos + 1] + segTree[2 * pos + 2];\n    }\n\n    int querySegTree(int pos, int left, int right, int l, int r) {\n        if (left > r || right < l) {\n            return 0;\n        }\n        if (left >= l && right <= r) {\n            return segTree[pos];\n        }\n        int mid = (left + right) / 2;\n        return querySegTree(2 * pos + 1, left, mid, l, r) + querySegTree(2 * pos + 2, mid + 1, right, l, r);\n    }\n\n    void updatePeaks(int idx) {\n        if (idx > 0 && idx < nums.size() - 1) {\n            peaks[idx] = (nums[idx] > nums[idx - 1] && nums[idx] > nums[idx + 1]) ? 1 : 0;\n        }\n    }\npublic:\n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& b) {\n          nums = a;\n        int n = nums.size();\n        peaks.resize(n, 0);\n        segTree.resize(4 * n, 0);\n\n        for (int i = 1; i < n - 1; ++i) {\n            updatePeaks(i);\n        }\n\n        build(0, 0, n - 1);\n\n        vector<int> result;\n\n        for (auto& q : b) {\n            if (q[0] == 1) {\n                int l = q[1];\n                int r = q[2];\n                result.push_back(querySegTree(0, 0, n - 1, l + 1, r - 1));\n            } else if (q[0] == 2) {\n                int idx = q[1];\n                int val = q[2];\n                nums[idx] = val;\n\n                for (int i = max(1, idx - 1); i <= min(n - 2, idx + 1); ++i) {\n                    updatePeaks(i);\n                    updateSegTree(0, 0, n - 1, i);\n                }\n            }\n        }\n\n        return result;\n    }\n};",
    "submit_ts": 1718509177.0
}