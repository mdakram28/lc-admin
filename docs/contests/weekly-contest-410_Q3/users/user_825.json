{
    "username": "21Cash",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma region\n\n// Library Source - https://github.com/21Cash/Competitive-Programming/tree/main/Library\n\ntemplate<class Fun> class y_combinator_result { Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n// --------------------------------------------------- Debug Template -------------------------------------------------------------\n\n#define DEBUG_OUT\n#define DEBUG_TC_NUM\n\nconst int new_line_count = 2; // How many new lines after each debug ? \n\nvoid __print(int x) { cout << x; }\nvoid __print(long x) { cout << x; }\nvoid __print(long long x) { cout << x; }\nvoid __print(unsigned x) { cout << x; }\nvoid __print(unsigned long x) { cout << x; }\nvoid __print(unsigned long long x) { cout << x; }\nvoid __print(float x) { cout << x; }\nvoid __print(double x) { cout << x; }\nvoid __print(long double x) { cout << x; }\nvoid __print(char x) { cout << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cout << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cout << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cout << (x ? \"true\" : \"false\"); }\nvoid _print() { cout << \"]\" << string(new_line_count, '\\n'); }\n\ntemplate <size_t N> void __print(const bitset<N>& x) { cout << x; };\ntemplate <typename T> void __print(const T &x);\ntemplate <typename T, typename V> void __print(const pair<T, V> &x);\ntemplate <typename T> void __print(const T &x);\ntemplate <typename T, typename... V> void _print(T t, V... v);\ntemplate <typename T, typename V> void __print(const pair<T, V> &x) \n{ cout << '{'; __print(x.first); cout << \", \"; __print(x.second); cout << '}'; }\ntemplate <typename T> void __print(const T &x) \n{ int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? \", \" : \"\"), __print(i); cout << \"}\"; }\ntemplate <typename T, typename... V> void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << \", \"; _print(v...); }\n\ntemplate<class T> bool ckmin(T&a, const T& b) { bool B = a > b; a = min(a,b); return B; }\ntemplate<class T> bool ckmax(T&a, const T& b) { bool B = a < b; a = max(a,b); return B; }\n\n#undef DEBUG_TC_NUM\n// #undef DEBUG_OUT\n\n#ifdef DEBUG_OUT\n#define dout std::cout\n#define db(x...) {cout << \"[\"; _print(x); }\n#define dbg(x...) { cout << \"[\" << #x << \"] = [\"; _print(x); } \n#define f_dbg(x...) { cout << \"[\" << __func__ << \":\" << (__LINE__) << \" [\" << #x << \"] = [\"; _print(x);  } \n#else\n#define dout if (false) std::cout\n#define db(x...) \n#define dbg(x...)\n#define f_dbg(x...)\n#endif\n\n// --------------------------------------------------------------------------------------------------------------------------------\n\nusing ll = long long;\n\n#define all(C) C.begin(), C.end()\n#define get_unique(v) {sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end());}\n#define to_long_long(vec) vector<long long>((vec).begin(), (vec).end())\n\nll GCD(ll x, ll y) { if (x == 0) return y; if (y == 0) return x; return GCD(y, x % y); }\nll lcm(ll a,ll b) { return a * b / GCD(a, b); }\nll ceil_div(ll x, ll y) { assert(y != 0); return (x + y - 1) / y; }\nll floor_div(ll x, ll y) { assert(y != 0); if (y < 0) { y = -y; x = -x; } if (x >= 0) return x / y; return (x + 1) / y - 1; }\n\n#pragma endregion\n\n\n\nll cache[2001][53][53];\n\nclass Solution {\npublic:\n    int countOfPairs(vector<int>& A) {\n        \n        const ll M = 1e9 + 7;\n        ll N = A.size();\n        \n        vector<ll> nums(all(A));\n        \n        auto solve = y_combinator([&] (auto solve, ll ind, ll prev1, ll prev2) -> ll {      \n            if(ind >= N) {\n                return 1;\n            }\n            if(cache[ind][prev1][prev2] != -1) return cache[ind][prev1][prev2];\n            \n            ll res = 0;\n            \n            for(ll take_val = 0; take_val <= 50; take_val++) {\n                ll new_val1 = take_val;\n                ll new_val2 = nums[ind] - take_val;\n                \n                if(take_val >= prev1 && prev2 >= new_val2 && take_val >= 0 && new_val2 >= 0) {\n                    ll cur_res = solve(ind + 1, new_val1, new_val2);\n                    res += cur_res;\n                    res %= M;\n                }\n            }\n            \n            return cache[ind][prev1][prev2] = res;\n        });\n        memset(cache, -1, sizeof(cache));\n        return solve(0, 0, 51);\n    }\n};",
    "submit_ts": "1723344963",
    "subm_id": "1351545763"
}