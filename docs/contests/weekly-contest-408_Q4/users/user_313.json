{
    "username": "browndwarf",
    "submission": "import numpy as np\n\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        N = len(circles)\n        adj = np.zeros((N+2, N+2), dtype=int)\n        Neighbors = [[] for i in range(N+2)]\n        # 0 is edge (0,0)->(X,0)->(X,Y)\n        # 1 is edge (0,0)->(0,Y)->(X,Y)\n        # Fill adjacency matrix\n        for i, circle in enumerate(circles):\n            x1, y1, r1 = circle\n            # check intersection with border\n            if (x1<=r1) or (y1>=Y-r1):\n                adj[1,i+2] = 1\n                adj[i+2,1] = 1\n            if (y1<=r1) or (x1>=X-r1):\n                adj[0,i+2] = 1\n                adj[i+2,0] = 1\n            for j, circle2 in enumerate(circles):\n                x2, y2, r2 = circle2\n                if j<=i:\n                    continue\n                if (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2:\n                    adj[i+2, j+2] = 1\n                    adj[j+2, i+2] = 1\n        #print(adj)\n        # BFS\n        visited = [0]*(N+2)\n        visited[0] = 1\n        queue = [0]\n        while len(queue)>0:\n            v = queue.pop()\n            if v == 1:\n                return False\n            # add all unvisited v's neighbors\n            for i in range(N+2):\n                if adj[v, i] and (visited[i]==0):\n                    visited[i] = 1\n                    queue.append(i)\n            \n        return True\n            \n            ",
    "submit_ts": "1722136598",
    "subm_id": "1335739410"
}