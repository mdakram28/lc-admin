{
    "username": "the_arc_knight_24",
    "submission": "class Solution {\n    #define ll long long \n    #define ppii pair<pair<int, int>, int> \n    #define veci vector<int>\nprivate: \n    int bfs(vector<vector<int>> &graph, int start, int target1, int target2, int nodes) {\n    queue<int> q;\n    vector<int> visited(nodes + 4, 0);\n    q.push(start);\n    visited[start] = 1;\n    \n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : graph[u]) {\n            if (!visited[v]) {\n                q.push(v);\n                visited[v] = 1;\n            }\n        }\n    }\n    return visited[target1] || visited[target2];\n}\n\n    bool isTrue(int l, int r){\n        return l<=r; \n        \n    }\n    void soluchan(vector<ppii>& temp, vector<veci>& circle, int n, vector<veci>& ds, int X, int Y){\n                 for (int i = 0; i < n; i++) {\n             int rec1= temp[i].first.first;\n                     int rec2= temp[i].second; \n                     int rec3= temp[i].first.second;\n            if (isTrue(rec1 ,rec2)) {\n                ds[n].push_back(i);\n                ds[i].push_back(n);\n            }\n            if (isTrue(X - rec1, rec2)) {\n                ds[n + 2].push_back(i);\n                ds[i].push_back(n + 2);\n            }\n            if (isTrue(rec3 , rec2) ){\n                ds[n + 1].push_back(i);\n                ds[i].push_back(n + 1);\n            }\n            if (isTrue(Y -  rec3 , rec2) ){\n                ds[n + 3].push_back(i);\n                ds[i].push_back(n + 3);\n            }\n    \n          solve(i,n,temp,ds);  \n        }\n\n    }\n    \n    void input( vector<ppii>& temp, vector<veci>& circle, int n){\n                for (int i = 0; i < n; ++i) {\n            temp[i].first.first=circle[i][0];\n            temp[i].first.second=circle[i][1];\n            temp[i].second=circle[i][2];\n        }\n        \n\n    }\n\n    void solve(int i, int n, vector<ppii>& temp, vector<veci>& ds){\n                    \n          for (int j = i + 1; j < n; j++) {\n                           int res1= temp[i].first.first;\n                                         int res2= temp[j].first.second;\n                            int res3= temp[j].first.first, res4= temp[i].first.second;\n                double distance = sqrt(pow(res1 - res3, 2) +\n                                       pow(res4 - res2, 2));\n                int ans = temp[i].second + temp[j].second;\n                if (ans >= distance) {\n                    ds[i].push_back(j);\n                    ds[j].push_back(i);\n                }\n            }\n\n    }\npublic:\n    bool canReachCorner(int X, int Y, vector<veci>& circle) {\n        int n=circle.size();\n        vector<ppii> temp(n);\n         vector<veci> ds(n + 4);\n        \n         input(temp,circle,n);        \n         soluchan(temp,circle,n,ds,X,Y);\n        \n        \n        int res = 0;\n\n        res = max(res, bfs(ds, n, n + 1, n + 2, n + 4)); \n        res = max(res, bfs(ds, n + 3, n + 2, n + 1, n + 4)); \n         if (res){return false;}\n        return true;\n\n    }\n};",
    "submit_ts": "1722138217",
    "subm_id": "1335785181"
}