{
    "username": "l_returns",
    "submission": "class SparseTable {\nprivate:\n    vector<vector<int>> table;\n    vector<int> logValues;\n\npublic:\n    SparseTable(const vector<int>& arr) {\n        int n = arr.size();\n        int maxLog = log2(n) + 1;\n\n        // Initialize the table with appropriate dimensions\n        table = vector<vector<int>>(n, vector<int>(maxLog));\n        logValues = vector<int>(n + 1);\n\n        // Fill the initial values for intervals of length 1\n        for (int i = 0; i < n; ++i) {\n            table[i][0] = arr[i];\n        }\n\n        // Compute the values for intervals of length 2^j\n        for (int j = 1; (1 << j) <= n; ++j) {\n            for (int i = 0; (i + (1 << j) - 1) < n; ++i) {\n                table[i][j] = min(table[i][j - 1], table[i + (1 << (j - 1))][j - 1]);\n            }\n        }\n\n        // Precompute log values\n        logValues[1] = 0;\n        for (int i = 2; i <= n; ++i) {\n            logValues[i] = logValues[i / 2] + 1;\n        }\n    }\n\n    int query(int L, int R) {\n        int length = R - L + 1;\n        int log = logValues[length];\n        return min(table[L][log], table[R - (1 << log) + 1][log]);\n    }\n};\n\nclass Solution {\n    \n    vector<int> extractSubarray(const vector<int>& arr, int start, int end) {\n        return vector<int>(arr.begin() + start, arr.begin() + end);\n    }\n    \n    long long recur(vector<int>& nums, map<int,vector<int>> &mp, SparseTable &s,int l, int r, int prval) {\n        if(l>r)\n            return 0;\n        int mini = s.query(l,r);\n        int prv = l;\n        long long ans = mini-prval;\n        auto it = lower_bound(mp[mini].begin(), mp[mini].end(), l);\n        while (it != mp[mini].end() && *it <= r) {\n            int x = *it;\n            ans+=recur(nums,mp,s,prv,x-1, mini);\n            prv=x+1;\n            it++;\n        }\n        ans+=recur(nums,mp,s,prv,r, mini);\n        return ans;\n    }\n    \n    long long solve_pos(vector<int>& nums) {\n        SparseTable s(nums);\n        map<int,vector<int>> mp;\n        for(int i=0;i<nums.size();i++)\n            mp[nums[i]].push_back(i);\n        return recur(nums, mp,s, 0, nums.size()-1, 0);\n    }\n    \n    long long solve(int l, int r, vector<int>& nums) {\n        if(l==r)\n            return 0;\n        vector<int> v = extractSubarray(nums,l,r);\n        for(int i=0;i<v.size();i++) {\n            v[i]=abs(v[i]);\n        }\n        return solve_pos(v);\n    }\n    \npublic:\n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n        int n = nums.size();\n        long long ans = 0;\n        for(int i=0;i<n;i++) {\n            nums[i]-=target[i];\n        }\n        int l=0, r=0;\n        for(int i=0;i<n;i++) {\n            if(nums[i]==0) {\n                ans+=solve(l,r,nums);\n                l=i+1; r=i+1;\n                continue;\n            }\n            if((nums[l]>0)==(nums[i]>0)) {\n                r=i+1;\n            } else {\n                ans+=solve(l,r,nums);\n                l=i; r=i+1;\n            }\n        }\n        ans+=solve(l,r,nums);\n        return ans;\n    }\n};\n",
    "submit_ts": "1721532630",
    "subm_id": "1327990378"
}