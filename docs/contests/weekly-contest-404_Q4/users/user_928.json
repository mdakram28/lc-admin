{
    "username": "kingstwo69",
    "submission": "from typing import List\nfrom collections import deque, defaultdict\n\nclass Solution:\n    def bfs_farthest_node(self, tree, start, n):\n        visited = [-1] * n\n        queue = deque([(start, 0)])\n        visited[start] = 0\n        farthest_node = start\n        max_distance = 0\n\n        while queue:\n            node, dist = queue.popleft()\n            for neighbor in tree[node]:\n                if visited[neighbor] == -1:\n                    visited[neighbor] = dist + 1\n                    queue.append((neighbor, dist + 1))\n                    if visited[neighbor] > max_distance:\n                        max_distance = visited[neighbor]\n                        farthest_node = neighbor\n        \n        return farthest_node, max_distance, visited\n\n    def tree_diameter(self, tree, n):\n        if n == 1:\n            return 0\n        farthest_node, _, _ = self.bfs_farthest_node(tree, 0, n)\n        other_node, diameter, _ = self.bfs_farthest_node(tree, farthest_node, n)\n        return diameter\n\n    def tree_center(self, tree, n):\n        if n == 1:\n            return 0\n        farthest_node, _, _ = self.bfs_farthest_node(tree, 0, n)\n        other_node, _, distances = self.bfs_farthest_node(tree, farthest_node, n)\n        \n        # Get the path from farthest_node to other_node\n        path = []\n        node = other_node\n        while node != farthest_node:\n            path.append(node)\n            for neighbor in tree[node]:\n                if distances[neighbor] == distances[node] - 1:\n                    node = neighbor\n                    break\n        path.append(farthest_node)\n        center = path[len(path) // 2]\n        return center\n\n    def tree_height(self, tree, n):\n        if n == 1:\n            return 0\n        center = self.tree_center(tree, n)\n        _, _, distances = self.bfs_farthest_node(tree, center, n)\n        return max(distances)\n\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def build_tree(edges):\n            tree = defaultdict(list)\n            max_node = -1\n            for u, v in edges:\n                tree[u].append(v)\n                tree[v].append(u)\n                max_node = max(max_node, u, v)\n            if max_node == -1:\n                return tree, 1  # Treat empty tree as a single-node tree\n            return tree, max_node + 1\n        \n        tree1, n1 = build_tree(edges1)\n        tree2, n2 = build_tree(edges2)\n\n        if n1 == 1 and n2 == 1:\n            return 1\n        if n1 == 1:\n            height2 = self.tree_height(tree2, n2)\n            return height2+1\n        if n2 == 1:\n            height1 = self.tree_height(tree1, n1)\n    \n            return height1+1\n\n        diameter1 = self.tree_diameter(tree1, n1)\n        diameter2 = self.tree_diameter(tree2, n2)\n        height1 = self.tree_height(tree1, n1)\n        height2 = self.tree_height(tree2, n2)\n\n        new_diameter = max(diameter1, diameter2, height1 + height2 + 1)\n        \n        return new_diameter",
    "submit_ts": "1719718936",
    "subm_id": "1304429747"
}