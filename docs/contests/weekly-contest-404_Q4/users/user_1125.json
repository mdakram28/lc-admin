{
    "username": "suhaanbhandary1",
    "submission": "class Solution {\npublic:\n    int getDistance(vector<vector<int>>& graph, int n){\n        // Find the furthest node with bfs\n        int farthest = 0;\n       { queue<int> q;\n        q.push(0);\n        vector<int> visited(n, 0);\n        visited[0] = 1;\n        \n        while(!q.empty()){\n            auto curr = q.front(); q.pop();\n            farthest = curr;\n            \n            // go to childrens\n            for(auto next: graph[curr]){\n                if(!visited[next]){\n                    q.push(next);\n                    visited[next] = 1;\n                }\n            }\n        }}\n        \n        // Find the distance from the largest distance from the node \n        queue<int> q;\n        q.push(farthest);\n        vector<int> visited(n, 0);\n        visited[farthest] = 1;\n        int distance = 0;\n        \n        while(!q.empty()){\n            int qSize = q.size();\n            distance++;\n            while(qSize--){\n                auto curr = q.front(); q.pop();\n            \n            // go to childrens\n            for(auto next: graph[curr]){\n                if(!visited[next]){\n                    q.push(next);\n                    visited[next] = 1;\n                }\n            }\n            }\n        }\n        return distance - 1;\n    }\n    \n    int getRadius(vector<vector<int>>& graph, int n){\n        vector<int> degree(n, 0);\n        for(int i = 0; i < n; i++){\n            degree[i]= graph[i].size();\n        }\n        \n        // Find the 1 degree\n        queue<int> q;\n        for(int i = 0; i < n; i++){\n            if(degree[i] == 1){\n                q.push(i);\n                // cout << \"push \" << i << endl;\n                degree[i] = -1;\n            }\n        }     \n        \n        int radius = -1;\n        bool isEvenLayer = false;\n        while(!q.empty()){\n            // cout << endl;\n            // cout << \"layer\" << endl;\n            radius++;\n            int qSize = q.size();\n            isEvenLayer = qSize % 2 == 0;\n            while(qSize--){\n                \n                int curr = q.front();\n                q.pop();\n                \n                // cout << curr << \" \";\n                \n                for(auto next: graph[curr]){\n                    degree[next]--;\n                    \n                    if(degree[next] == 1){\n                        // cout << \"nex \" << next << endl;\n                        q.push(next);\n                        degree[next] = -1;\n                    }\n                }\n            }\n        }\n        \n        // cout << endl;\n        // cout << radius << \" \" << isEvenLayer << endl;\n        return max(radius + isEvenLayer, 0);        \n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n1 = edges1.size() + 1;\n        int n2 = edges2.size() + 1;\n        \n        vector<vector<int>> graph1(n1), graph2(n2);\n        for(auto edge: edges1){\n            graph1[edge[0]].push_back(edge[1]);\n            graph1[edge[1]].push_back(edge[0]);\n        }\n        \n        for(auto edge: edges2){\n            graph2[edge[0]].push_back(edge[1]);\n            graph2[edge[1]].push_back(edge[0]);\n        }\n        \n        // Find radius\n        int r1 = getRadius(graph1, n1);\n        int r2 = getRadius(graph2, n2);\n\n        // cout << r1 << \" : \" << r2 << \" \" << getDistance(graph1, n1) << \"  \"<< getDistance(graph2, n2) << endl;\n\n        return max({r1 + r2 + 1, getDistance(graph1, n1), getDistance(graph2, n2)});\n    }\n};",
    "submit_ts": 1719719121.0
}