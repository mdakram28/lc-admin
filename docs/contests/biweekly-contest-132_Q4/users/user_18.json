{
    "username": "stupidRR",
    "submission": "class Solution {\nstruct segtree \n{\n    const int k=0;//constant will be 0 for operations like sum,max and gcd but for operations like min will iNF\n    int size;\n    vector< long long > seg;\n    \n    void init(int n)//initialize the segment tree\n    {\n        size=1;\n        while(size<n)\n            size=size*2;\n        seg.assign( 2*size , 0 );\n    }\n    \n    long long operation(long long x,long long y)\n    {\n        return std::max(x,y);\n    }    \n    void Real_build( vector<int> &a , int x , int lx , int rx)\n    {\n        if(rx-lx==1)\n        {\n            if( lx<(int)a.size() )\n                seg[x]=a[lx];\n            return;\n        }\n        int mid=(lx+rx)/2;\n        Real_build( a , x*2+1 , lx , mid );\n        Real_build( a , x*2+2 , mid , rx );\n        seg[x]= operation ( seg[2*x+1],seg[2*x+2] ) ;\n    }\n    \n    void build( vector<int> &a )\n    {\n        Real_build(a,0,0,size);\n    }\n    \n    \n    void Real_set( int i , int v ,int x , int lx , int rx)\n    {\n        if(rx-lx==1)//bottom label\n        {\n            seg[x]=v;\n            return;\n        }\n        int mid=(lx+rx)/2;\n        if(i<mid)\n            Real_set(i,v,2*x+1,lx,mid);\n        else\n            Real_set(i,v,2*x+2,mid,rx);\n        seg[x]= operation ( seg[2*x+1],seg[2*x+2] ) ;\n    }  \n    \n    void set (int i,int v)\n    {\n        Real_set(i,v,0,0,size);\n    }\n    \n    long long Real_query( int l , int r , int x , int lx , int rx)\n    {\n        if( lx>=r || l>=rx)//no intersection\n            return k;\n        if( lx>=l && rx<=r)\n            return seg[x];\n        int m=(lx+rx)/2;\n        long long s1=Real_query(l,r,2*x+1,lx,m);\n        long long s2=Real_query(l,r,2*x+2,m,rx);\n        return operation(s1,s2);\n    } \n    \n    long long query ( int l ,int r)\n    {\n        return Real_query(l,r,0,0,size);\n    }\n};\n \npublic:\n    int maximumLength(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> dp(n);\n        map<int,vector<int>> mp;\n        for(int i=0;i<nums.size();i++)\n        {\n            mp[nums[i]].push_back(i);\n            dp[i]=mp[nums[i]].size();\n        }        \n\n        for(int i=1;i<=k;i++)\n        {\n            vector<int> ndp(n);\n            segtree st;\n            st.init(n);\n            st.build(dp);\n\n            for(auto [val,vec] : mp)\n            {\n                int mx=-1e9;\n                for(int i=0;i<vec.size();i++)\n                {\n                    int ind=vec[i];\n                    st.set(ind,0);\n                    ndp[ind]=st.query(0,ind)+1;\n                    ndp[ind]=std::max(ndp[ind],mx+i);\n                    mx=std::max(mx,ndp[ind]-i);\n                }\n                for(auto ind : vec)\n                    st.set(ind,dp[ind]);\n            }\n            swap(ndp,dp);\n\n        }\n\n        int ans=0;\n        for(auto ele : dp)\n            ans=std::max(ans,ele);\n        return ans;\n    }\n};",
    "submit_ts": 1717858760.0
}