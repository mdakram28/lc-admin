{
    "username": "349775270",
    "submission": "#include <vector>\n#include <climits>  // For INT_MAX\n#include <algorithm> // For max and min functions\nusing namespace std;\n\nclass Solution {\nprivate:\n    struct Point {\n        int x, y;\n        Point() : x(0), y(0) {}  // Default constructor for safety\n        Point(int x, int y) : x(x), y(y) {}\n    };\n\n    struct Rectangle {\n        int a, b, c, d;\n        Rectangle() : a(0), b(0), c(0), d(0) {}  // Default constructor for safety\n        Rectangle(int a, int b, int c, int d) : a(a), b(b), c(c), d(d) {}\n    };\n\n    Rectangle rt[5];  // Static array as in Java\n    vector<Point> p;\n    int rectCnt = 0, ans = INT_MAX, ones = 0;\n\npublic:\n    int minimumSum(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size(), k = 0;\n        p.reserve(n * m);  // Assuming grid has at most n * m 1s.\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ones += grid[i][j];\n                if (grid[i][j] == 1) {\n                    p.emplace_back(i, j); // Constructs the object in place\n                }\n            }\n        }\n        dfs(0);\n        return ans;\n    }\n\n    void dfs(int index) {\n        int sum = 0;\n        for (int i = 0; i < rectCnt; i++) {\n            sum += area(rt[i]);\n        }\n        if (sum >= ans) return;\n\n        if (index == ones) {\n            ans = sum;\n            return;\n        }\n\n        for (int i = 0; i < rectCnt; i++) {\n            Rectangle temp = rt[i];  // Make a copy of the rectangle\n\n            // Expand the rectangle to include point p[index]\n            rt[i].a = max(p[index].x, rt[i].a);\n            rt[i].b = min(p[index].x, rt[i].b);\n            rt[i].c = min(p[index].y, rt[i].c);\n            rt[i].d = max(p[index].y, rt[i].d);\n\n            if (valid(i)) {\n                dfs(index + 1);\n            }\n\n            rt[i] = temp; // Restore the original rectangle\n        }\n\n        if (rectCnt < 3) {\n            rt[rectCnt] = Rectangle(p[index].x, p[index].x, p[index].y, p[index].y);\n            rectCnt++;\n            dfs(index + 1);\n            rectCnt--;\n        }\n    }\n\n    int area(const Rectangle& rect) {\n        return (rect.a - rect.b + 1) * (rect.d - rect.c + 1);\n    }\n\n    bool valid(int index) {\n        for (int i = 0; i < rectCnt; i++) {\n            if (index == i) continue;\n            if (overlap(rt[i], rt[index])) return false;\n        }\n        return true;\n    }\n\n    bool overlap(const Rectangle& r1, const Rectangle& r2) {\n        return !(r2.b > r1.a || r2.a < r1.b || r2.d < r1.c || r2.c > r1.d);\n    }\n};\n",
    "submit_ts": 1719114024.0
}