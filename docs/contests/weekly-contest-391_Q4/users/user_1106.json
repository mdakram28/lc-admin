{
    "username": "gdkkx",
    "submission": "class Solution {\npublic int minimumDistance(int[][] points) {\n        PriorityQueue<int[]> p1max = new PriorityQueue<>((o1, o2) -> o2[0] - o1[0]);\n        PriorityQueue<int[]> p1min = new PriorityQueue<>((o1, o2) -> o1[0] - o2[0]);\n        PriorityQueue<int[]> p2max = new PriorityQueue<>((o1, o2) -> o2[0] - o1[0]);\n        PriorityQueue<int[]> p2min = new PriorityQueue<>((o1, o2) -> o1[0] - o2[0]);\n\n        for (int i = 0; i < points.length; i++) {\n            p1max.offer(new int[]{points[i][0] + points[i][1], i});\n            p1min.offer(new int[]{points[i][0] + points[i][1], i});\n            p2max.offer(new int[]{points[i][0] - points[i][1], i});\n            p2min.offer(new int[]{points[i][0] - points[i][1], i});\n        }\n        int res = Integer.MAX_VALUE;\n        for (int i = 0; i < points.length; i++) {\n            int[] p1 = p1max.poll();\n            int[] p11 = p1min.poll();\n            int[] p2 = p2max.poll();\n            int[] p22 = p2min.poll();\n            int[] tempp1 = p1;\n            int[] tempp11 = p11;\n            int[] tempp2 = p2;\n            int[] tempp22 = p22;\n            if (p1[1] == i) {\n                p1 = p1max.peek();\n            }\n            if (p11[1] == i) {\n                p11 = p1min.peek();\n            }\n            if (p2[1] == i) {\n                p2 = p2max.peek();\n            }\n            if (p22[1] == i) {\n                p22 = p2min.peek();\n            }\n            res = Math.min(res, Math.max(Math.abs(p1[0] - p11[0]), Math.abs(p2[0] - p22[0])));\n            p1max.offer(tempp1);\n            p1min.offer(tempp11);\n            p2max.offer(tempp2);\n            p2min.offer(tempp22);\n        }\n        return res;\n    }\n}"
}