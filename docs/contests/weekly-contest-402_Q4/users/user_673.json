{
    "username": "lixiangfan97",
    "submission": "class Solution {\npublic:\n    #define MAXN 100010\n    int A[MAXN*4];\n    \n    int modify(int pos, int s, int e, int i, int diff) {\n        if (i < s || i > e) {\n            return A[pos];\n        }\n        if (s == e) {\n            A[pos] += diff;\n            return A[pos];\n        }\n        int mid = (s + e) >> 1;\n        A[pos] = modify(2*pos+1, s, mid, i, diff) + modify(2*pos+2, mid+1, e, i, diff);\n        return A[pos];\n    }\n    \n    int ask(int pos, int s, int e, int l, int r, const vector<int>& nums) {\n        int res = query(pos, s, e, l, r);\n        if (is_peak(nums, l)) {\n            res--;\n        }\n        if (l != r && is_peak(nums, r)) {\n            res--;\n        }\n        return res;\n    }\n    \n    int query(int pos, int s, int e, int l, int r) {\n        if (r < s || l > e) {\n            return 0;\n        }\n        if (s >= l && e <= r) {\n            return A[pos];\n        }\n        int mid = (s + e) >> 1;\n        return query(2*pos+1, s, mid, l, r) + query(2*pos+2, mid+1, e, l, r);\n    }\n    \n    int n;\n    \n    bool is_peak(const vector<int>& nums, int i) {\n        return i > 0 && i < (n-1) && (nums[i] > nums[i-1] && nums[i] > nums[i+1]);\n    }\n    \n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        memset(A, 0, sizeof(A));\n        n = (int)nums.size();\n        for (int i = 1; i < n - 1; ++i) {\n            if (is_peak(nums, i)) {\n                modify(0, 0, n-1, i, 1);\n            }\n        }\n        // cout << query(0, 0, n-1, 0, n-1) << endl;\n        \n        vector<int> ans;\n        ans.reserve(queries.size());\n        \n        for (const auto& q: queries) {\n            if (q[0] == 1) {\n                ans.push_back(ask(0, 0, n-1, q[1], q[2], nums));\n            } else if (q[0] == 2) {\n                bool now_peak = is_peak(nums, q[1]);\n                bool now_peak_1 = is_peak(nums, q[1]-1);\n                bool now_peak_2 = is_peak(nums, q[1]+1);\n                nums[q[1]] = q[2];\n                bool after_peak = is_peak(nums, q[1]);\n                bool after_peak_1 = is_peak(nums, q[1]-1);\n                bool after_peak_2 = is_peak(nums, q[1]+1);\n                if (now_peak != after_peak) {\n                    if (after_peak) {\n                        modify(0, 0, n-1, q[1], 1);\n                    } else {\n                        modify(0, 0, n-1, q[1], -1);\n                    }\n                }\n                \n                if (now_peak_1 != after_peak_1) {\n                    if (after_peak_1) {\n                        modify(0, 0, n-1, q[1]-1, 1);\n                    } else {\n                        modify(0, 0, n-1, q[1]-1, -1);\n                    }\n                }\n                \n                if (now_peak_2 != after_peak_2) {\n                    if (after_peak_2) {\n                        modify(0, 0, n-1, q[1]+1, 1);\n                    } else {\n                        modify(0, 0, n-1, q[1]+1, -1);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718506794.0
}