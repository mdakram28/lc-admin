{
    "username": "gaoyf1235",
    "submission": "namespace atcoder{\ntemplate <typename T, T (*operation)(T, T), T (*default_val)()> \nclass segtree {\nprivate:\n    int _n, size, log;\n    std::vector<T> d;\n    int ceil_pow2(int n) {\n        int x = 0;\n        while ((1U << x) < (unsigned int)(n)) x++;\n        return x;\n    }\n    void update(int k) { d[k] = operation(d[2 * k], d[2 * k + 1]); }\npublic:\n    // Constructor complexity: O(n)\n    segtree(int n) : segtree(std::vector<T>(n, default_val())) {}\n\n    segtree(const std::vector<T>& v) : _n(int(v.size())) {\n        log = ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<T>(2 * size, default_val());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, T x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    T get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n    // calculate operation(a[l], ..., a[r - 1]) in O(logn), where a is the original array data.\n    T prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        T sml = default_val(), smr = default_val();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = operation(sml, d[l++]);\n            if (r & 1) smr = operation(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return operation(sml, smr);\n    }\n\n    T all_prod() { return d[1]; }\n    // Apply binary search on the segment tree. The function bool f(T x) should be defined.\n    // https://atcoder.github.io/ac-library/master/document_en/segtree.html\n    template <bool (*f)(T)> int max_right(int l) {\n        return max_right(l, [](T x) { return f(x); });\n    }\n\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(default_val()));\n        if (l == _n) return _n;\n        l += size;\n        T sm = default_val();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(operation(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(operation(sm, d[l]))) {\n                        sm = operation(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = operation(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(T)> int min_left(int r) {\n        return min_left(r, [](T x) { return f(x); });\n    }\n\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(default_val()));\n        if (r == 0) return 0;\n        r += size;\n        T sm = default_val();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(operation(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(operation(d[r], sm))) {\n                        sm = operation(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = operation(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n};\n\n}  // namespace atcoder\n\nclass Solution {\n    using ll = long long;\n    using pii = pair<int, int>;\n    using pll = pair<ll, ll>;\n    const ll mod = 1'000'000'007;\n    struct Info{\n        ll first_last{0};\n        ll first_nolast{0};\n        ll nofirst_last{0};\n        ll nofirst_nolast{0};\n        Info(ll a, ll b, ll c, ll d) : first_last(a), first_nolast(b), nofirst_last(c), nofirst_nolast(d){}\n    };\n    static Info default_max() {return Info(0,0,0,0); }\n    static Info max_operation(Info a, Info b) {\n        ll fl = max(a.first_last + b.nofirst_last, a.first_nolast + b.first_last);\n        fl = max(fl, a.first_nolast + b.nofirst_last);\n        ll fnl = max(a.first_last + b.nofirst_nolast, a.first_nolast + b.first_nolast);\n        fnl = max(fnl, a.first_nolast + b.nofirst_nolast);\n        ll nfl = max(a.nofirst_last + b.nofirst_last, a.nofirst_nolast + b.first_last);\n        nfl = max(nfl, a.nofirst_nolast + b.nofirst_last);\n        ll nfnl =  max(a.nofirst_nolast + b.first_nolast, a.nofirst_last + b.nofirst_nolast);\n        nfnl =  max(nfnl, a.nofirst_nolast + b.nofirst_nolast);\n        return Info(fl,  fnl, nfl, nfnl); \n    }\n    \n    \n    \n    template<typename T>\n    void printAll(T& vec, const string& delimiter =  \" \"){\n        for(const auto& x : vec){\n            cout << x << delimiter;\n        }\n        cout << endl;\n    }\n    void show(Info& info){\n        vector<ll> v{info.first_last, info.first_nolast, info.nofirst_last, info.nofirst_nolast};\n        printAll(v);\n    }\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<Info> data(n, default_max());\n        for(int i = 0; i < n; i++){\n            data[i] = Info(nums[i], 0, 0, 0);\n        }\n        atcoder::segtree<Info, max_operation, default_max> tree(data);\n        // auto ar = tree.all_prod(); \n        // show(ar);\n        ll res = 0;\n        for(auto& q : queries){\n            int p = q[0];\n            ll val = q[1];\n            tree.set(p, Info(val, 0, 0, 0));\n            auto rinfo = tree.all_prod(); \n            // show(rinfo);\n            ll r = 0;\n            r = max(r, rinfo.first_last);\n            r = max(r, rinfo.first_nolast);\n            r = max(r, rinfo.nofirst_last);\n            r = max(r, rinfo.nofirst_nolast);\n            res += r;\n            res %= mod;\n        }\n        return res;\n    }\n};",
    "submit_ts": 1716694992.0
}