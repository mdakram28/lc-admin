{
    "username": "abhishek21ee10003kgp",
    "submission": "#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution { \n    vector<multiset<int>> diaA; // Stores the two largest distances from each node\n    vector<int> myVal; // Stores the maximum distance from each node to its farthest descendant\n\n    // First DFS to calculate the maximum distances from each node to its farthest descendants\n    int dfs1(vector<vector<int>>& adj, int node, int par) {\n        int ans = 0;\n        diaA[node].insert(0); // Start by inserting 0 distance for the current node\n        for (auto t : adj[node]) {\n            if (t == par) continue; // Skip the parent node to avoid cycles\n            int v = dfs1(adj, t, node); // Recursively calculate the maximum distance for the child node\n            ans = max(ans, 1 + v); // Update the maximum distance for the current node\n            diaA[node].insert(1 + v); // Insert the distance for the current node\n            if (diaA[node].size() > 2) diaA[node].erase(diaA[node].begin()); // Keep only the two largest distances\n        } \n        myVal[node] = ans; // Store the maximum distance for the current node\n        return ans;\n    }\n\n    // Second DFS to update the distances considering the parent nodes\n    void dfs2(vector<vector<int>>& adj, int node, int par) { \n        bool f = true;\n        if (par != -1) {\n            for (auto t : diaA[par]) { // For each distance in the parent's set\n                if (t == myVal[node] + 1 && f) f = false; // Skip the child's distance\n                else diaA[node].insert(t + 1); // Insert the distance plus one for the current node\n            }\n        }\n        while (diaA[node].size() > 2) diaA[node].erase(diaA[node].begin()); // Keep only the two largest distances\n        for (auto t : adj[node]) {\n            if (t == par) continue; // Skip the parent node to avoid cycles\n            dfs2(adj, t, node); // Recursively update the distances for the child nodes\n        } \n    }\n\n    // Function to get the diameter of the tree using the first approach\n    int getDia(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        diaA.clear();\n        myVal.clear();\n        diaA.resize(n);\n        myVal.resize(n, 0);\n        vector<vector<int>> adj(n); // Adjacency list representation of the tree\n        for (auto& edge : edges) {\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n        dfs1(adj, 0, -1); // Perform the first DFS\n        dfs2(adj, 0, -1); // Perform the second DFS\n        int ans = 1e9;\n        for(int i = 0; i < n; i++) ans = min(ans, *diaA[i].rbegin()); // Find the minimum diameter possible\n        return ans;\n    }\n\n    // Helper function to perform a DFS and return the farthest node and its distance\n    pair<int, int> dfs3(vector<vector<int>>& adj, int node, int par) {\n        pair<int, int> ans = {node, 0}; // {farthest node, distance}\n        for (auto t : adj[node]) {\n            if (t == par) continue;\n            auto res = dfs3(adj, t, node);\n            if (res.second + 1 > ans.second) {\n                ans = {res.first, res.second + 1};\n            }\n        }\n        return ans;\n    }\n\n    // Function to get the diameter of the tree using the second approach\n    int getDia2(vector<vector<int>>& edges) {\n        if(edges.empty()) return 0;\n        int n = edges.size() + 1;\n        vector<vector<int>> adj(n); // Adjacency list representation of the tree\n        for (auto& edge : edges) {\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n\n        // Find a leaf node (a node with only one connection)\n        int leaf = -1;\n        for (int i = 0; i < n; ++i) {\n            if (adj[i].size() == 1) {\n                leaf = i;\n                break;\n            }\n        }\n\n        // Perform a DFS from the leaf node to find the farthest node\n        auto farthest = dfs3(adj, leaf, -1);\n\n        // Perform a DFS from the farthest node to find the diameter\n        auto diameter = dfs3(adj, farthest.first, -1);\n\n        return diameter.second; // Return the diameter\n    }\n\npublic:\n    // Function to calculate the minimum diameter after merging two trees\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int a = getDia(edges1); // Calculate the diameter of the first tree\n        int b = getDia(edges2); // Calculate the diameter of the second tree\n        return max({a + b + 1,getDia2(edges1),getDia2(edges2)}); // Return the sum of the two diameters plus one\n    }\n};\n",
    "submit_ts": "1719717586",
    "subm_id": "1304395503"
}