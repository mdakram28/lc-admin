{
    "username": "ultraaryan10",
    "submission": "struct Tree {\n    int n, d;\n    vector<vector<int>> adj;\n    vector<int> dist;\n\n    pair<int, int> dfs_farthest_node(int start) {\n        vector<int> distance(n, -1);\n        stack<pair<int, int>> s;\n        s.push({start, 0});\n        int farthest_node = start, max_distance = 0;\n\n        while (!s.empty()) {\n            auto [node, dist] = s.top(); s.pop();\n            if (distance[node] == -1) {\n                distance[node] = dist;\n                if (dist > max_distance) {\n                    max_distance = dist;\n                    farthest_node = node;\n                }\n                for (int neighbor : adj[node]) {\n                    if (distance[neighbor] == -1) {\n                        s.push({neighbor, dist + 1});\n                    }\n                }\n            }\n        }\n\n        return {farthest_node, max_distance};\n    }\n\n    vector<int> dfs_distances(int start) {\n        vector<int> distance(n, -1);\n        stack<pair<int, int>> s;\n        s.push({start, 0});\n\n        while (!s.empty()) {\n            auto [node, dist] = s.top(); s.pop();\n            if (distance[node] == -1) {\n                distance[node] = dist;\n                for (int neighbor : adj[node]) {\n                    if (distance[neighbor] == -1) {\n                        s.push({neighbor, dist + 1});\n                    }\n                }\n            }\n        }\n\n        return distance;\n    }\n\n    void find_max_path_lengths() {\n        int node_a = 0;\n        auto [node_b, _] = dfs_farthest_node(node_a);\n        vector<int> distances_from_b = dfs_distances(node_b);\n        auto [node_c, __] = dfs_farthest_node(node_b);\n        vector<int> distances_from_c = dfs_distances(node_c);\n        vector<int> max_path_lengths(n);\n        for (int i = 0; i < n; ++i) {\n            max_path_lengths[i] = max(distances_from_b[i], distances_from_c[i]);\n        }\n\n        dist = max_path_lengths;\n    }\n\n    Tree(vector<vector<int>>& edges) {\n        n = 0;\n        for (auto& e : edges)\n            n = max(n, max(e[0], e[1]));\n        ++n;\n        adj.resize(n);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            adj[e[1]].push_back(e[0]);\n        }\n        find_max_path_lengths();\n        d = *max_element(dist.begin(), dist.end());\n    }\n};\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        Tree A(edges1), B(edges2);\n        return max(\n            max(A.d, B.d), \n            1 + *min_element(A.dist.begin(), A.dist.end()) + *min_element(B.dist.begin(), B.dist.end())\n        );\n    }\n};",
    "submit_ts": "1719718129",
    "subm_id": "1304409487"
}