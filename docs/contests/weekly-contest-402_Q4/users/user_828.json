{
    "username": "yumkam",
    "submission": "#ifndef FENWICK_TREE_HPP\n#define FENWICK_TREE_HPP\n#include <vector>\ntemplate <typename T, typename V = std::vector<T>>\nclass FenwickTree {\n    // One-based Fenwick tree with a twist (A[0] saves nums[0])\n    V A;\n    // for all operations T must support 'a += b'\n    // for get(), set(), range_sum(), cast to V, T must support 'a -= b'\n    // for range_query(), lower_bound(), T must support 'a -= b' and 'a < b'\n    public:\n    typedef typename V::size_type size_type;\n    typedef typename V::value_type value_type;\n    private:\n    static const size_type LSB(const size_type i) {\n        return i & -i;\n    }\n\n    // Convert A[] in place to Fenwick tree form\n    static void init(V &A) {\n        for (size_type i = 1; i < A.size(); ++i) {\n            auto j = i + LSB(i);\n            if (j < A.size())\n                A[j] += A[i];\n        }\n    }\n\n    // Convert back to array of per-element counts\n    static void fini(V &A) {\n        for (size_type i = A.size(); i-- > 1;) {\n            auto j = i + LSB(i);\n            if (j < A.size())\n                A[j] -= A[i];\n        }\n    }\n    public:\n    FenwickTree(size_type size = 0):A(size) {\n    }\n\n    FenwickTree(const V &nums):A(nums) {\n        init(A);\n    }\n\n    FenwickTree(V &&nums):A(std::move(nums)) {\n        init(A);\n    }\n\n    FenwickTree(const FenwickTree &) = default;\n    FenwickTree(FenwickTree &&) = default;\n\n    FenwickTree &operator = (const V & A) {\n        this->A = A;\n        init(this->A);\n        return *this;\n    }\n\n    FenwickTree &operator = (V && A) {\n        this->A = std::move(A);\n        init(this->A);\n        return *this;\n    }\n\n    FenwickTree &operator = (const FenwickTree &) = default;   \n    FenwickTree &operator = (FenwickTree &&) = default;\n\n    operator V () const & {\n        V ret = A;\n        fini(ret);\n        return ret;\n    }\n    operator V () && {\n        fini(A);\n        return std::move(A);\n    }\n\n    // Returns the sum of the first i elements (indices 0 to i)\n    // Equivalent to range_sum(0, i)\n    T prefix_sum(size_type i) const {\n        // assert(i < A.size());\n        T sum = A[0];\n        for (; i != 0; i -= LSB(i))\n            sum += A[i];\n        return sum;\n    }\n\n    // Add delta to element with index i (zero-based)\n    void add(size_type i, T delta) {\n        // assert(i < A.size());\n        if (i == 0) {\n            A[0] += delta;\n            return;\n        }\n        for (; i < A.size(); i+= LSB(i))\n            A[i] += delta;\n    }\n\n    // Returns sum of nums[i + 1] to nums[j].\n    // Same as prefix_sum(j) - prefix_sum(i), but a bit faster\n    T range_sum(size_type i, size_type j) const {\n        T sum = 0;\n        // assert(0 < i);\n        // assert(i < j);\n        // assert(j < A.size());\n        for (; j > i; j -= LSB(j))\n            sum += A[j];\n        for (; i > j; i -= LSB(i))\n            sum -= A[i];\n        return sum;\n    }\n\n    //\n    T get(size_type i) const {\n        return i == 0 ? A[0] : range_sum(i - 1, i);\n    }\n\n    constexpr size_type size() const { return A.size(); }\n\n    constexpr bool empty() const { return A.empty(); }\n};\n#endif\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        const unsigned n = nums.size();\n        vector<int> ispeak(n);\n        for (unsigned i = 2; i < n; ++i) {\n            if (nums[i - 2] < nums[i - 1] && nums[i] < nums[i - 1])\n                ispeak[i - 1] = 1;\n        }\n        FenwickTree<int> ft(ispeak);\n        vector<int> ret;\n        for (const auto &q: queries) {\n            auto type = q[0];\n            if (type == 1) {\n                auto l = q[1];\n                auto r = q[2];\n                ret.push_back(l + 1 < r ? (l == 0 ? ft.prefix_sum(r - 1) : ft.range_sum(l, r - 1)) : 0);\n            } else {\n                unsigned idx = q[1];\n                auto nval = q[2];\n                nums[idx] = nval;\n                //cout << 'c' << idx << endl;\n                for (unsigned i = max(2u, idx); i < min(idx + 3, n); ++i) {\n                    int newpeak = nums[i - 2] < nums[i - 1] && nums[i] < nums[i - 1];\n                    ft.add(i - 1, newpeak - ispeak[i - 1]);\n                    //cout << i - 1 << ':' << ispeak[i - 1] << '>' << newpeak << endl;\n                    ispeak[i - 1] = newpeak;\n                }\n            }\n        }\n        return ret;\n    }\n};",
    "submit_ts": 1718508551.0
}