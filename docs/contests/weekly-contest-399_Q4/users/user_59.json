{
    "username": "lydxlx",
    "submission": "\nimport java.io.*;\nimport java.util.*;\nimport java.util.stream.IntStream;\n\npublic class Solution {\n\n    static class KMP {\n        int next[];\n        String pattern;\n\n        KMP(String p) {\n            pattern = p;\n            next = new int[p.length()];\n            next[0] = -1;\n            int j = -1;\n            for (int i = 1; i < next.length; i++) {\n\n                while (j > -1 && p.charAt(j + 1) != p.charAt(i)) j = next[j];\n                if (p.charAt(j + 1) == p.charAt(i)) j++;\n                next[i] = j;\n            }\n        }\n\n        ArrayList<Integer> kmp(String s) {\n            ArrayList<Integer> ans = new ArrayList<Integer>();\n            int j = -1;\n            for (int i = 0; i < s.length(); i++) {\n\n\n                while (j > -1 && pattern.charAt(j + 1) != s.charAt(i)) j = next[j];\n                if (pattern.charAt(j + 1) == s.charAt(i)) j++;\n                if (j == pattern.length() - 1) { // Find a matching!\n                    ans.add(i + 1 - pattern.length());\n                    j = next[j];\n                }\n            }\n            return ans;\n        }\n    }\n\n    static class Tree {\n        int begin;\n        int end;\n        Tree left, right;\n\n        private long[][] data = new long[2][2];\n\n        private void combine() {\n            for (int i = 0; i < 2; i++)\n                for (int j = 0; j < 2; j++) {\n                    data[i][j] = 0;\n                    for (int jj = 0; jj < 2; jj++)\n                        for (int ii = 0; ii < 2; ii++)\n                            if (jj + ii < 2) {\n                                data[i][j] = Math.max(data[i][j], left.data[i][jj] + right.data[ii][j]);\n                            }\n                }\n        }\n    }\n\n    static long INF = Long.MAX_VALUE / 100;\n\n    static Tree build(int[] A, int l, int r) {\n        Tree node = new Tree();\n        node.begin = l;\n        node.end = r;\n        if (l == r) {\n            node.data[1][1] = A[l];\n        } else {\n            int mid = (l + r) / 2;\n            node.left = build(A, l, mid);\n            node.right = build(A, mid + 1, r);\n            node.combine();\n        }\n        return node;\n    }\n\n    static void set(Tree root, int index, int val) {\n        if (root.begin > index || root.end < index) return;\n        if (root.begin == root.end) {\n            root.data[1][1] = Math.max(0, val);\n        } else {\n            set(root.left, index, val);\n            set(root.right, index, val);\n            root.combine();\n        }\n    }\n\n    void dfs(Tree root) {\n        if (root == null) return;\n        System.out.println(root.begin + \" \" + root.end + \" \" + root.data[0][0] + \" \" + root.data[0][1] + \" \" + root.data[1][0] + \" \" + root.data[1][1]);\n        dfs(root.left);\n        dfs(root.right);\n    }\n\n\n    public int maximumSumSubsequence(int[] nums, int[][] queries) {\n        Tree root = build(nums, 0, nums.length - 1);\n\n        long ans = 0;\n        for (int[] query : queries) {\n            set(root, query[0], Math.max(query[1], 0));\n//            dfs(root);\n            long res = 0;\n            for (int i = 0; i < 2; i++)\n                for (int j = 0; j < 2; j++)\n                    res = Math.max(res, root.data[i][j]);\n            ans += res;\n//            System.out.println(query[0] + \" \" + query[1] + \" \" + res);\n        }\n        return (int) (ans % 1000000007);\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        Reader.init(System.in);\n        BufferedWriter cout = new BufferedWriter(new OutputStreamWriter(System.out));\n        System.out.println(\"Start\");\n        {\n            Solution sol = new Solution();\n            // nums = [3,5,9], queries = [[1,-2],[0,-3]]\n            int[] nums = {3, 5, 9};\n            int[][] queries = {{1, -2}, {0, -3}};\n            System.out.println(sol.maximumSumSubsequence(nums, queries));\n\n            // nums = [0,-1], queries = [[0,-5]]\n            nums = new int[]{0, -1};\n            queries = new int[][]{{0, -5}};\n            System.out.println(sol.maximumSumSubsequence(nums, queries));\n\n\n        }\n        {\n            Solution sol = new Solution();\n        }\n        {\n            Solution sol = new Solution();\n        }\n        {\n            Solution sol = new Solution();\n        }\n\n\n        cout.close();\n    }\n\n\n    /**\n     * Class for buffered reading int and double values\n     */\n    static class Reader {\n        static BufferedReader reader;\n        static StringTokenizer tokenizer;\n\n        /**\n         * call this method to initialize reader for InputStream\n         */\n        static void init(InputStream input) {\n            reader = new BufferedReader(new InputStreamReader(input));\n            tokenizer = new StringTokenizer(\"\");\n        }\n\n        /**\n         * get next word\n         */\n        static String next() throws IOException {\n            while (!tokenizer.hasMoreTokens()) {\n                // TODO add check for eof if necessary\n                tokenizer = new StringTokenizer(reader.readLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        static int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        static double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n}",
    "submit_ts": 1716693672.0
}