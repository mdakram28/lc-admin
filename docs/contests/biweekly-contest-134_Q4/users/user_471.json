{
    "username": "madflash",
    "submission": "#include <bits/stdc++.h>\n\n#define FOR(i, l, r) for (int i = l; i < r; ++i)\n#define FORR(i, r, l) for (int i = r; i >= l; --i)\n#define FORI(n) FOR(i, 0, n)\n#define FORJ(n) FOR(j, 0, n)\n#define FORK(n) FOR(k, 0, n)\n#define loop(n) FOR(_, 0, n)\n#define all(x) x.begin(), x.end()\n#define sz(x) x.size()\n#define pb push_back\n#define yesno(x) ((x) ? \"YES\" : \"NO\")\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T1, typename T2> using hashmap = unordered_map<T1, T2>;\ntemplate <typename T> using hashset = unordered_set<T>;\nconst int MOD = 1e9 + 7;\nconst int INF = numeric_limits<int>::max();\nconst ll INFLL = numeric_limits<ll>::max();\n\nvoid __print(int x) { cout << x; }\nvoid __print(long x) { cout << x; }\nvoid __print(long long x) { cout << x; }\nvoid __print(unsigned x) { cout << x; }\nvoid __print(unsigned long x) { cout << x; }\nvoid __print(unsigned long long x) { cout << x; }\nvoid __print(float x) { cout << x; }\nvoid __print(double x) { cout << x; }\nvoid __print(long double x) { cout << x; }\nvoid __print(char x) { cout << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cout << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cout << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cout << (x ? \"true\" : \"false\"); }\ntemplate <size_t N>\nvoid __print(const bitset<N> &x) {\n    cout << x;\n};\n \ntemplate <typename T>\nvoid __print(const T &x);\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x);\ntemplate <typename T>\nvoid __print(const T &x);\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v);\n \ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n    cout << '{';\n    __print(x.first);\n    cout << \", \";\n    __print(x.second);\n    cout << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n    int f = 0;\n    cout << '{';\n    for (auto &i : x) cout << (f++ ? \", \" : \"\"), __print(i);\n    cout << \"}\";\n}\nvoid _print() { cout << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n    __print(t);\n    if (sizeof...(v))\n        cout << \", \";\n    _print(v...);\n}\n \n#define dbg(x...)                                                              \\\n    cout << __func__ << \":\" << __LINE__ - 9 << \" [\" << #x << \"] = [\";          \\\n    _print(x);                                                                 \\\n    cout << endl;\n\n\n#if __cplusplus >= 201703L\ntemplate <class S, auto op, auto e> struct segtree {\n    static_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>,\n                  \"op must work as S(S, S)\");\n    static_assert(std::is_convertible_v<decltype(e), std::function<S()>>,\n                  \"e must work as S()\");\n\n#else\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n#endif\n\n    // @return same with std::bit::bit_ceil\n    unsigned int bit_ceil(unsigned int n) {\n        unsigned int x = 1;\n        while (x < (unsigned int)(n)) x *= 2;\n        return x;\n    }\n\n    // @param n `1 <= n`\n    // @return same with std::bit::countr_zero\n    int countr_zero(unsigned int n) {\n#ifdef _MSC_VER\n        unsigned long index;\n        _BitScanForward(&index, n);\n        return index;\n#else\n        return __builtin_ctz(n);\n#endif\n    }\n\n  public:\n    segtree() : segtree(0) {}\n    explicit segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    explicit segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        size = (int)bit_ceil((unsigned int)(_n));\n        log = countr_zero((unsigned int)size);\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) const {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) const {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() const { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) const {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) const {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) const {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) const {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\ntemplate <typename S, S (*op)(S, S), bool overlap_friendly>\nstruct sparse_table {\n    static const int LOG = 20;\n    int n;\n    V<V<S>> table;\n\n    sparse_table() = default;\n\n    sparse_table(const V<S> &a) : n(a.size()), table(LOG, V<S>(a.size())) {\n        for (int i = a.size() - 1; i >= 0; --i) {\n            table[0][i] = a[i];\n            FOR(k, 1, LOG) {\n                if (i + (1 << k) - 1 >= a.size())\n                    break;\n                table[k][i] =\n                    op(table[k - 1][i], table[k - 1][i + (1 << (k - 1))]);\n            }\n        }\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r < n);\n        int len = r - l + 1;\n        int k = 31 - __builtin_clz(len);\n\n        if (overlap_friendly) {\n            return op(table[k][l], table[k][r - (1 << k) + 1]);\n        } else {\n            S res = table[k][l];\n            for (int i = l + (1 << k--); k >= 0; --k) {\n                if (len & (1 << k)) {\n                    res = op(res, table[k][i]);\n                    i += (1 << k);\n                }\n            }\n            return res;\n        }\n    }\n};\n\n    \nusing S =int;\nS op(S a,S b) {\n    return a & b;\n}\n    \nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        int n = sz(nums);\n        sparse_table<S,op,false> st(nums);\n        ll ans = 0;\n        \n        FORR(i, n - 1, 0) {\n            int lo = i;\n            int hi = n - 1;\n            int LB = -1;\n            int UB = -1;\n            \n            \n            while (lo <= hi) {\n                int mid = lo + (hi - lo) / 2;\n                int v = st.prod(i, mid);\n                if (v > k) {\n                    lo = mid + 1;\n                } else if (v < k) {\n                    hi = mid - 1;\n                } else if (v == k) {\n                    UB = mid;\n                    lo = mid + 1;\n                }\n            }\n            \n            lo = i;\n            hi = n - 1;\n            \n            while (lo <= hi) {\n                int mid = lo + (hi - lo) / 2;\n                int v = st.prod(i, mid);\n                if (v > k) {\n                    lo = mid + 1;\n                } else if (v < k) {\n                    hi = mid - 1;\n                } else {\n                    LB = mid;\n                    hi = mid - 1;\n                }\n            }\n            \n            if (UB != -1)\n                ans +=  UB - LB + 1;\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": "1720276831",
    "subm_id": "1311634742"
}