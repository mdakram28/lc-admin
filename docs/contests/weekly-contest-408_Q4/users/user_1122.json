{
    "username": "doanquocthinh2004",
    "submission": "#pragma once\n\ntemplate <class T> int sgn(T x) { return (x > 0) - (x < 0); }\ntemplate<class T>\nstruct Point {\n\ttypedef Point P;\n\tT x, y;\n\texplicit Point(T x=0, T y=0) : x(x), y(y) {}\n\tbool operator<(P p) const { return tie(x,y) < tie(p.x,p.y); }\n\tbool operator==(P p) const { return tie(x,y)==tie(p.x,p.y); }\n\tP operator+(P p) const { return P(x+p.x, y+p.y); }\n\tP operator-(P p) const { return P(x-p.x, y-p.y); }\n\tP operator*(T d) const { return P(x*d, y*d); }\n\tP operator/(T d) const { return P(x/d, y/d); }\n\tT dot(P p) const { return x*p.x + y*p.y; }\n\tT cross(P p) const { return x*p.y - y*p.x; }\n\tT cross(P a, P b) const { return (a-*this).cross(b-*this); }\n\tT dist2() const { return x*x + y*y; }\n\tdouble dist() const { return sqrt((double)dist2()); }\n\t// angle to x-axis in interval [-pi, pi]\n\tdouble angle() const { return atan2(y, x); }\n\tP unit() const { return *this/dist(); } // makes dist()=1\n\tP perp() const { return P(-y, x); } // rotates +90 degrees\n\tP normal() const { return perp().unit(); }\n\t// returns point rotated 'a' radians ccw around the origin\n\tP rotate(double a) const {\n\t\treturn P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }\n\tfriend ostream& operator<<(ostream& os, P p) {\n\t\treturn os << \"(\" << p.x << \",\" << p.y << \")\"; }\n};\n\ntypedef Point<double> P;\n\nbool circleInter(P a,P b,double r1,double r2,pair<P, P>* out) {\n\tif (a == b) { return false; }\n\tP vec = b - a;\n\tdouble d2 = vec.dist2(), sum = r1+r2, dif = r1-r2,\n\t       p = (d2 + r1*r1 - r2*r2)/(d2*2), h2 = r1*r1 - p*p*d2;\n\tif (sum*sum < d2 || dif*dif > d2) return false;\n\tP mid = a + vec*p, per = vec.perp() * sqrt(fmax(0, h2) / d2);\n\t*out = {mid + per, mid - per};\n\treturn true;\n}\n\ntemplate<class P>\nvector<P> circleLine(P c, double r, P a, P b) {\n\tP ab = b - a, p = a + ab * (c-a).dot(ab) / ab.dist2();\n\tdouble s = a.cross(b, c), h2 = r*r - s*s / ab.dist2();\n\tif (h2 < 0) return {};\n\tif (h2 == 0) return {p};\n\tP h = ab.unit() * sqrt(h2);\n\treturn {p - h, p + h};\n}\n\ntemplate<class P> bool onSegment(P s, P e, P p) {\n\treturn p.cross(s, e) == 0 && (s - p).dot(e - p) <= 0;\n}\n\nbool findv(int x, vector<int>& v) {\n    auto it = find(v.begin(), v.end(), x);\n    return it != v.end();\n}\n\nint onSegmentVector(P s, P e, vector<P>& vp) {\n    for (auto &p: vp) if (onSegment(s, e, p)) return 1;\n    return 0;\n}\n\ntemplate<class T>\nbool isPointInCircle(const Point<T>& point, const Point<T>& center, T radius) {\n    // Calculate the squared distance between the point and the center\n    T dist2 = (point - center).dist2();\n    \n    // Compare the squared distance to the squared radius\n    return dist2 <= radius * radius;\n}\n\n#define pb push_back\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n        vector<vector<int>> v(n, vector<int>(4, 0));\n        for (int i = 0; i < n; ++i) {\n            P p(circles[i][0], circles[i][1]);\n            double r = circles[i][2];\n            P p1(0, 0), p2(X, 0), p3(X, Y), p4(0, Y);\n            if (isPointInCircle(p1, p, r) || isPointInCircle(p3, p, r)) {return false;}\n            vector<P> line1 = circleLine(p, r, p1, p2);\n            vector<P> line2 = circleLine(p, r, p2, p3);\n            vector<P> line3 = circleLine(p, r, p3, p4);\n            vector<P> line4 = circleLine(p, r, p4, p1);\n            v[i][0] = onSegmentVector(p1, p2, line1);\n            v[i][1] = onSegmentVector(p2, p3, line2);\n            v[i][2] = onSegmentVector(p3, p4, line3);\n            v[i][3] = onSegmentVector(p4, p1, line4);\n            // for (auto x: v[i]) cout << x << ' '; cout << endl;\n            for (int j = 0; j < i; ++j) {\n                vector<int> vv(4);\n                pair<P, P> out;\n                if (circleInter(p, P(circles[j][0], circles[j][1]), r, circles[j][2], &out)) {\n                    for (int k = 0; k < 4; ++k) vv[k] = v[i][k] | v[j][k];\n                    for (int k = 0; k < 4; ++k) v[i][k] = v[j][k] = vv[k];\n                }\n                \n            }\n            for (int j = 0; j <= i; ++j) {\n                int check1 = v[i][0] & v[i][3], check2 = v[i][1] & v[i][2], check3 = v[i][0] & v[i][2], check4 = v[i][1] & v[i][3];\n                // cout << check1 << ' ' << check2 << ' ' << check3 << ' ' << check4;\n                int check = check1 | check2 | check3 | check4;\n                if (check) return false;\n            }\n        }\n        return true;\n    }\n};",
    "submit_ts": "1722139199",
    "subm_id": "1335810936"
}