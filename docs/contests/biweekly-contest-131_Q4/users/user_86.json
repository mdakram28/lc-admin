{
    "username": "loxa_",
    "submission": "class Solution {\npublic:\n    //MAX SEGMENT TREE\n    template<typename T>\n    class ST{\n    public:\n        int n, n_;\n        T INF;\n        vector<T> st, lazy;\n        ST(int n, T null_element):n_(n), INF(-null_element){\n            while((n&(n-1))!=0) n++;\n            this->n = n;\n            // INITIALIZE NULL ELEMENTS PROPERLY(initialize -INF for max, INF for min, 0 for sum)\n            st = vector<T>(2*n-1, -INF);\n            lazy = vector<T>(2*n-1, -INF);\n        }\n        T operation(T a, T b){\n            // CHANGE OPERATION ACCORDING TO REQUIREMENT\n            return max(a, b); // creating segment tree which maintains max over ranges\n        }\n        void build(vector<T>& a){\n            _build(0, 0, n-1, a);\n        }\n        // x is the node index in segment tree array which will have 2*n-1 nodes\n        // lx, rx is the range node x corresponds to in the original array \n        void _build(int x, int lx, int rx, vector<T>& a){\n            if(lx==rx){\n                if(lx<n_) st[x] = a[lx];\n                return;\n            }\n            int mid = (lx+rx)/2;\n            _build(2*x+1, lx, mid, a);\n            _build(2*x+2, mid+1, rx, a);\n            st[x] = operation(st[2*x+1], st[2*x+2]);\n        }\n        void _propagate(int x, int lx, int rx){\n            // CHANGE PROPAGATION LOGIC ACCORDING TO REQUIREMENT\n            if(lazy[x]!=-INF){ // if lazy array is set at this node only then propagate\n                // updates max segment tree range by setting all elements in the range to \"f\"\n                st[2*x+1] = lazy[x];\n                st[2*x+2] = lazy[x];\n                // stores update value in the lazy array at this node for future propagation\n                lazy[2*x+1] = lazy[x];\n                lazy[2*x+2] = lazy[x];\n            }\n            lazy[x] = -INF; // reset lazy array at this node\n        }\n        T query(int l, int r){\n            return _query(0, l, r, 0, n-1);\n        }\n        // l, r is the range in the original array on which the query is made\n        // query is in range [l:r+1], indices from l to r(including r)\n        T _query(int x, int l, int r, int lx, int rx){\n            if(lx>r || rx<l) return -INF; // SET NULL ELEMENTS PROPERLY(set -INF for max, INF for min, 0 for sum)\n            else if(lx>=l && rx<=r) return st[x];\n            _propagate(x, lx, rx);\n            int mid = (lx+rx)/2;\n            T ql = _query(2*x+1, l, r, lx, mid);\n            T qr = _query(2*x+2, l, r, mid+1, rx);\n            T res = operation(qr, ql);\n            return res;\n        }\n        void update(int l, int r, T f){\n            _update(0, l, r, f, 0, n-1);\n        }\n        void _update(int x, int l, int r, T f, int lx, int rx){\n            if(lx>r || rx<l) return;\n            else if(lx>=l && rx<=r){\n                // CHANGE UPDATE LOGIC ACCORDING TO REQUIREMENT\n                lazy[x] = f; // stores update value in the lazy array at this node for future propagation\n                st[x] = f; // updates max segment range by setting all elements in the range by \"f\"\n                return;\n            }\n            _propagate(x, lx, rx);\n            int mid = (lx+rx)/2;\n            _update(2*x+1, l, r, f, lx, mid);\n            _update(2*x+2, l, r, f, mid+1, rx);\n            st[x] = operation(st[2*x+1], st[2*x+2]);\n        }\n    };\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        set<int> s;\n        s.insert(0);\n        int N = 5*1e4+10, INF = 1e9+7;\n        ST<int> st = ST(N, -INF);\n        st.update(0, 0, 0);\n        vector<bool> res;\n        for(vector<int>& query: queries){\n            int t = query[0], x = query[1];\n            if(t==1){\n                auto it = s.upper_bound(x);\n                if(it!=s.end()) st.update((*it), (*it), (*it)-x);\n                it--;\n                st.update(x, x, x-(*it));\n                s.insert(x);\n            }\n            else{\n                int sz = query[2];\n                auto it = s.upper_bound(x);\n                it--;\n                int possible = max(st.query(0, (*it)), x-(*it));\n                // cout << x << ' ' << sz << ' ' << *it << '\\n';\n                // cout << possible << '\\n';\n                if(possible>=sz) res.push_back(true);\n                else res.push_back(false);\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1716650151.0
}