{
    "username": "SyamantakPaul",
    "submission": "import java.util.Arrays;\n\nclass Solution {\n    public int numberOfPermutations(int n, int[][] requirements) {\n        final int MOD = 1000000007;\n        int[][] dp = new int[n + 1][401];\n        \n        dp[0][0] = 1;  // There's one way to arrange 0 elements with 0 inversions.\n        \n        for (int i = 1; i <= n; i++) {\n            for (int k = 0; k <= 400; k++) {\n                dp[i][k] = 0;\n                for (int j = 0; j < i; j++) {\n                    if (k >= j) {\n                        dp[i][k] = (dp[i][k] + dp[i - 1][k - j]) % MOD;\n                    }\n                }\n            }\n        }\n        \n        // Create a mask of required inversion counts.\n        int[] reqCount = new int[n];\n        Arrays.fill(reqCount, -1);\n        for (int[] req : requirements) {\n            reqCount[req[0]] = req[1];\n        }\n        \n        // Now we need to count all valid permutations satisfying the requirements.\n        int[][] validDp = new int[n + 1][401];\n        validDp[0][0] = 1;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int k = 0; k <= 400; k++) {\n                validDp[i][k] = 0;\n                if (reqCount[i - 1] != -1 && reqCount[i - 1] != k) {\n                    continue;  // Skip this state if it doesn't meet the requirement.\n                }\n                for (int j = 0; j < i; j++) {\n                    if (k >= j) {\n                        validDp[i][k] = (validDp[i][k] + validDp[i - 1][k - j]) % MOD;\n                    }\n                }\n            }\n        }\n        \n        // We need to sum up all valid permutations for n elements satisfying all requirements.\n        int result = 0;\n        for (int k = 0; k <= 400; k++) {\n            if (reqCount[n - 1] == -1 || reqCount[n - 1] == k) {\n                result = (result + validDp[n][k]) % MOD;\n            }\n        }\n        \n        return result;\n    }\n}\n",
    "submit_ts": 1719068196.0
}