{
    "username": "user8557",
    "submission": "\nstruct MyTreeNode {\n    MyTreeNode(int i) : index(i) {}\n    int index;\n    vector<pair<int, MyTreeNode *>> children;\n    MyTreeNode *parent = nullptr;\n    int totalTime = 0;\n    int goParentTime = 0;\n};\n\nvector<vector<int>> getGraph(const vector<vector<int>>& edges) {\n    const int n = edges.size() + 1;\n    vector<vector<int>> graph(n);\n    for (const auto &edge : edges) {\n        int a = edge[0];\n        int b = edge[1];\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    return graph;\n}\n\nMyTreeNode *buildTree(const vector<vector<int>>& graph, int parent, int index) {\n    MyTreeNode *root = new MyTreeNode(index);\n    for (auto child : graph[index]) {\n        if (child == parent) {\n            continue;\n        }\n        root->children.push_back(make_pair(0, buildTree(graph, index, child)));\n        root->children.back().second->parent = root;\n    }\n    return root;\n}\n\nvoid fillTime(MyTreeNode *root) {\n    for (auto &[t, child] : root->children) {\n        fillTime(child);\n        int toChildTime = child->index % 2;\n        if (toChildTime == 0) {\n            toChildTime = 2;\n        }\n        t = child->totalTime + toChildTime;\n    }\n    sort(root->children.begin(), root->children.end());\n    if (!root->children.empty()) {\n        root->totalTime = root->children.back().first;\n    }\n}\n\nvoid fillRes(MyTreeNode *root, vector<int> &res) {\n    if (!root->parent) {\n        res[root->index] = root->totalTime;\n    } else {\n        int childTime = root->totalTime;\n\n        auto parent = root->parent;\n        auto oneStepParentTime = (parent->index % 2) == 1 ? 1 : 2;\n        int parentTime = 0;\n        if (parent->children.size() > 1) {\n            auto targetIter = parent->children.end() - 1;\n            if (parent->children.back().second == root) {\n                targetIter--;\n            }\n            parentTime = targetIter->first;\n        }\n        parentTime = max(parentTime, parent->goParentTime);\n        parentTime += oneStepParentTime;\n        root->goParentTime = parentTime;\n\n        int ans = max(childTime, parentTime);\n        res[root->index] = ans;\n    }\n    for (auto child : root->children) {\n        fillRes(child.second, res);\n    }\n}\n\nclass Solution {\npublic:\n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        const int n = edges.size() + 1;\n        auto graph = getGraph(edges);\n        auto root = buildTree(graph, -1, 0);\n        fillTime(root);\n        vector<int> res(n);\n        fillRes(root, res);\n        return res;\n    }\n};\n",
    "submit_ts": "1722699319",
    "subm_id": "552275107"
}