{
    "username": "ha-ha-62e",
    "submission": "class Solution {\npublic:\n    struct ${\n        int l, r, x, mx, lz, mid;\n    }tree[100005 << 2];\n    \n    void pushup(int rt) {\n        tree[rt].mx = max(tree[rt << 1].mx, tree[rt << 1 | 1].mx);\n    }\n    \n    void pushdown(int rt) {\n        if (tree[rt].lz != 0) {\n            tree[rt << 1].mx += tree[rt].lz;\n            tree[rt << 1].lz += tree[rt].lz;\n            tree[rt << 1 | 1].mx += tree[rt].lz;\n            tree[rt << 1 | 1].lz += tree[rt].lz;\n            tree[rt].lz = 0;\n        }\n    }\n    \n    void build(int l, int r, int rt) {\n        tree[rt].l = l, tree[rt].r = r;\n        tree[rt].mid = (l + r) >> 1;\n        tree[rt].lz = 0;\n        if (l == r) {\n            tree[rt].mx = l;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(l, mid, rt << 1);\n        build(mid + 1, r, rt << 1 | 1);\n        pushup(rt);\n    }\n    \n    void update(int l, int r, int d, int rt) {\n        if (l <= tree[rt].l && tree[rt].r <= r) {\n            tree[rt].lz += d;\n            tree[rt].mx += d;\n            return;\n        }\n        pushdown(rt);\n        if (l <= tree[rt].mid) {\n            update(l, r, d, rt << 1);\n        }\n        if (tree[rt].mid < r) {\n            update(l, r, d, rt << 1 | 1);\n        }\n        pushup(rt);\n    }\n    \n    int query(int l, int r, int rt) {\n        if (l <= tree[rt].l && tree[rt].r <= r) return tree[rt].mx;\n        pushdown(rt);\n        int mx = 0;\n        if (l <= tree[rt].mid) mx = max(mx, query(l, r, rt << 1));\n        if (tree[rt].mid < r) mx = max(mx, query(l, r, rt << 1 | 1));\n        return mx;\n    }\n    \n    \n    vector<bool> getResults(vector<vector<int>>& q) {\n        int pre = 0;\n        vector<bool>ans;\n        int n = 1e5 + 7;\n        build(1, n, 1);\n        set<int> s;\n        s.insert(0);\n        s.insert(n);\n        for (auto p : q) {\n            if (p.size() == 2) {\n                int cnt = 0;\n                auto ps = s.lower_bound(p[1]);\n                ps--;\n                auto pe = s.upper_bound(p[1]);\n                int begin = *ps, end = *pe, x = p[1];\n                // [x + 1, end] +begin -x\n                update(x + 1, end, begin - x, 1);\n                s.insert(x);\n            } else {\n                int x = p[1], sz = p[2];\n                ans.push_back(query(1, x, 1) >= sz);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716652267.0
}