{
    "username": "balakrishnan_v",
    "submission": "#define MAXN 1000\n#define ll long long\nclass Solution {\npublic:\n    \n    ll SquaredDist(ll x1, ll y1, ll x2, ll y2) {\n        return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n    }\n    \n    bool Inside(ll x,ll y,const vector<int>& circle) {\n        ll cx = circle[0];\n        ll cy = circle[1];\n        ll r = circle[2];\n        return SquaredDist(x,y,cx,cy)<=r*r;\n    }\n    \n    bool Intersect(const vector<int>& c1, const vector<int>& c2) {\n        ll cx1 = c1[0];\n        ll cy1 = c1[1];\n        ll cx2 = c2[0];\n        ll cy2 = c2[1];\n        ll r1 = c1[2];\n        ll r2 = c2[2];\n        return SquaredDist(cx1,cy1,cx2,cy2) <= (r1+r2)*(r1+r2);\n    }\n    \n    vector<int> E[MAXN+2];\n    int comp_ids[MAXN+2];\n    \n    void dfs(int u, int comp_id) {\n        if (comp_ids[u]!=-1) return;\n        comp_ids[u]=comp_id;\n        for(int v : E[u]) {\n            dfs(v,comp_id);\n        }\n    }\n    \n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n=circles.size();\n        for(auto tmp : circles) {\n            if (Inside(X,Y,tmp)) return false;\n            if (Inside(0,0,tmp)) return false;\n        }        \n        bool left_blocked=false;\n        bool right_blocked=false;\n        vector<int> left_circles,right_circles;\n        for(int i=0;i<circles.size();i++) {\n            auto tmp = circles[i];\n            int x=tmp[0];\n            int y=tmp[1];\n            int r=tmp[2];\n            bool curr_left_blocked = false;\n            if (x-r <= 0 && y <= Y) curr_left_blocked=true;\n            if (Inside(0,Y,tmp)) curr_left_blocked=true;\n            if (y+r >= Y && x <= X) curr_left_blocked=true;\n            if (curr_left_blocked) {\n                left_circles.push_back(i);\n                left_blocked = true;\n            }\n            \n            bool curr_right_blocked = false;\n            \n            if (Inside(X,0,tmp)) curr_right_blocked=true;\n            if (y-r<=0 && x<=X) curr_right_blocked=true;\n            if (x+r >= X && y <= Y) curr_right_blocked=true;\n            if (curr_right_blocked) {\n                right_circles.push_back(i);\n                right_blocked = true;\n            }\n        }\n        if (!left_blocked || !right_blocked) return true;\n        \n        \n        for(int i=0;i<n;i++) {\n            for(int j=0;j<n;j++) {\n                if (i==j) continue;\n                if (Intersect(circles[i],circles[j])) {\n                    E[i].push_back(j);\n                }\n            }\n        }\n        \n        for(int i=0;i<n;i++) {\n            comp_ids[i]=-1;\n        }\n        \n        int c=0;\n        for(int i=0;i<n;i++) {\n            if (comp_ids[i]!=-1) continue;\n            dfs(i,c);\n            c++;\n        }\n        \n        for(int l : left_circles) \n            for(int r : right_circles) {\n                if (comp_ids[l]==comp_ids[r]) return false;\n            }\n        \n        return true;\n        \n    }\n};",
    "submit_ts": "1722137216",
    "subm_id": "1335757490"
}