{
    "username": "RoadToIndiaNumber1",
    "submission": "struct segmenttree\n{\n    int n;\n    vector<int> st, lazy;\n\n    void init(int _n)\n    {\n        this->n = _n;\n        st.resize(4 * n, 0);\n        lazy.resize(4 * n, 0);\n    }\n\n    void push(int start, int ending, int node)\n    {\n        if (lazy[node])\n        {\n            st[node] = ending - lazy[node];\n\n            if (start != ending)\n            {\n                lazy[2 * node + 1] = lazy[node];\n                lazy[2 * node + 2] = lazy[node];\n            }\n\n            lazy[node]  = 0;\n        }\n    }\n\n    void build(int start, int ending, int node)\n    {\n        \n        if (start == ending)\n        {\n            st[node] = start;\n            return;\n        }\n\n        int mid = (start + ending) / 2;\n\n        build(start, mid, 2 * node + 1);\n\n        build(mid + 1, ending, 2 * node + 2);\n\n        st[node] = max(st[node * 2 + 1], st[node * 2 + 2]);\n    }\n\n    int query(int start, int ending, int l, int r, int node)\n    {\n        push(start, ending, node);\n\n        if (start > r || ending < l)\n        {\n            return 0;\n        }\n\n        if (start >= l && ending <= r)\n        {\n            return st[node];\n        }\n\n        int mid = (start + ending) / 2;\n\n        int q1 = query(start, mid, l, r, 2 * node + 1);\n        int q2 = query(mid + 1, ending, l, r, 2 * node + 2);\n\n        return max(q1 , q2);\n    }\n\n    void update(int start, int ending, int node, int l, int r, int value)\n    {\n        push(start, ending, node);\n\n        if (start > r || ending < l)\n        {\n            return;\n        }\n\n        if (start >= l && ending <= r)\n        {\n            lazy[node] = value;\n            push(start, ending, node);\n            return;\n        }\n\n        // partial case\n        int mid = (start + ending) / 2;\n\n        update(start, mid, 2 * node + 1, l, r, value);\n\n        update(mid + 1, ending, 2 * node + 2, l, r, value);\n\n        st[node] = max(st[node * 2 + 1] , st[node * 2 + 2]);\n\n        return;\n    }\n\n    void build()\n    {\n        build(0, n - 1, 0);\n    }\n\n    int query(int l, int r)\n    {\n        return query(0, n - 1, l, r, 0);\n    }\n\n    void update(int l, int r, int x)\n    {\n        update(0, n - 1, 0, l, r, x);\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        \n        vector<bool>results;\n                \n        set<int>blockers; \n        \n        int N = min((int)(5e4 + 1), (int)(3 * queries.size() + 1));\n        \n        blockers.insert(0); blockers.insert(N);\n        \n        segmenttree prefix;\n        prefix.init(N), \n        prefix.build(); \n        \n        for(auto &i : queries) {\n            \n            if(i[0] == 1) {\n                int block = i[1];\n                auto itr = blockers.lower_bound(block);\n                int right = *itr; \n                prefix.update(block + 1, right, block);\n                blockers.insert(block);\n            }\n            else {\n                // cout << prefix.query(0, i[1]) << \" \" << i[1] << \"\\n\";x\n                results.push_back(prefix.query(0, i[1]) >= i[2]);\n            }\n            \n        }       \n            \n        \n        return results;\n    }\n};",
    "submit_ts": 1716649936.0
}