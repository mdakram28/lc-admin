{
    "username": "papaya",
    "submission": "#include<bits/stdc++.h>\nusing namespace std ; \ntypedef long long int64 ; \n \nclass DFS  { \n \n public: \n\n    vector<int> a ;\n    int n ; \n \n    vector<vector<int> > edge ; \n \npublic:\n    void init( int tn ) {\n        n = tn ;\n        edge.assign( n , {} ) ; \n    }\n    inline void add_edge( int u , int v ) {\n        edge[ u ].emplace_back( v ) ; \n        edge[ v ].emplace_back ( u ) ; \n    }\n \n    void dfs( int u , int parent , int h , vector<int> & d   ) { \n \n        d[ u ] = h ; \n        for( auto v : edge[ u ] ) {\n \n            if( v == parent ) {\n                continue ;\n            }\n\n            dfs( v , u , h + 1 , d ) ; \n        }\n    }\n\n    bool find( int target_end ,  int u ,int parent , vector<int> &path   ) { \n        \n        if( u == target_end ) { \n            return true ; \n        }\n        for( auto v : edge[ u ] ) {\n \n            if( v == parent ) {\n                continue ;\n            }\n\n            path.emplace_back( v ) ; \n\n            if( find( target_end ,  v ,  u , path ) ) {\n                return true ; \n            }\n            path.pop_back( ) ; \n        }\n        return false ; \n    }\n\n\n    int get_max( vector<int> &d ) { \n \n        int max_d = -1 , ans = -1 ; \n        for( int i = 0 ; i < n ; i++ ) {\n            if( max_d < d[i] ) { \n \n                max_d = d[i] ; \n                ans = i ; \n            }\n        }\n        return ans ; \n    }\n    \n    int  calc ( ) {\n \n        vector<int> d ( n , -1 ) ; \n        dfs( 0 ,  -1 ,  0 ,   d ) ; \n \n        int root_0 = get_max( d ) ; \n        vector<int> d0( n , -1 )  , d1( n , -1 ) ; \n \n        dfs( root_0 , -1 , 0 , d0 ) ; \n \n        int root_1 = get_max( d0 ) ; \n        dfs( root_1 , -1 , 0 , d1 ) ; \n        return *max_element( d1.begin() , d1.end() ) ; //[ root_1 ] ; \n    }\n\n    vector<int>   solve( ) {\n \n        vector<int> d ( n , -1 ) ; \n        dfs( 0 ,  -1 ,  0 ,   d ) ; \n \n        int root_0 = get_max( d ) ; \n        vector<int> d0( n , -1 )  , d1( n , -1 ) ; \n \n        dfs( root_0 , -1 , 0 , d0 ) ; \n \n        int root_1 = get_max( d0 ) ; \n        dfs( root_1 , -1 , 0 , d1 ) ; \n\n        // cout << \" root0: \" << root_0 << \" \" << root_1 << \"\\n\" ; \n\n        /*\n        root_0 \u548c root_1 \u5fc5\u4e3a \u6811\u7684\u76f4\u5f84\u4e0a\u7684 \u4e24\u4e2a\u7aef\u70b9\n        */\n        vector<int> path ; \n        path.emplace_back( root_0 ) ;\n        if( root_1 != root_0 ) { \n            find( root_1 , root_0 , -1 , path ) ; \n        }\n        \n        // for( auto x : path ) {\n        //     cout <<x << \" \" ; \n        // }\n        // cout << \"\\n\" ; \n\n        return path ; \n    }\n} ; \n\n\nclass Solution {\npublic:\n    int n , m ; \n    DFS t1 , t2 ; \n    DFS base_t ; \n    vector<int> path_1 , path_2 ; \n\n    int xunion( int xu , int xv ) { \n\n        DFS t = base_t ; \n        t.add_edge( xu , xv ) ; \n\n        // auto path = t.solve() ; \n        // return path.size() - 1 ; \n\n        auto ret = t.calc() ; \n        return ret ; \n    }\n    int solve_1( auto &path_1 , auto &path_2 ) { \n\n        int tn = path_1.size() ; \n        int tm = path_2.size() ; \n\n\n        int i = tn / 2 , j = tm / 2 ; \n\n        int ret = 1e8  ; \n        for( auto di : { i , i + 1 } ) {\n            for( auto dj : { j , j + 1} ) { \n\n                if( di >= tn || dj >= tm ) {\n                    continue ; \n                }\n\n                int xu = path_1[ di ] ; \n                int xv = path_2[ dj ] + n ; \n                auto t_ans  = xunion( xu , xv ) ; \n\n\n                ret = min( ret , t_ans ) ; \n            }\n        }\n        return ret ; \n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        \n\n        n = edges1.size() + 1 ;\n        m = edges2.size() + 1 ; \n\n        t1.init( n ) ; \n        t2.init( m ) ; \n        base_t.init( n + m ) ; \n        for( auto &p : edges1 ) { \n            int u = p[0] , v = p[1] ; \n            t1.add_edge( u , v ) ; \n            base_t.add_edge( u , v ) ; \n        }\n\n        for( auto &p : edges2 ) { \n            int u = p[0] , v = p[1] ; \n            t2.add_edge( u , v ) ; \n            base_t.add_edge( u + n , v + n ) ; \n        }\n\n        path_1 = t1.solve() ; \n        path_2 = t2.solve() ; \n\n        auto ans = solve_1  ( path_1 , path_2 ) ; \n\n        return ans ; \n    }\n};\n\n\nint ma2in( )  { \n    Solution  t; \n\n    vector< vector<int> > a , b ;\n  \n    a = { { 0 , 1 } , { 0 , 2 } , { 0 , 3 }} ; \n    b = { { 0 , 1 }} ; \n    \n\n    // edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]\n\n\n    // a = { { 0 , 1 } , { 0 , 2 } , { 0 , 3 } , { 2 , 4 } , {2,5} , { 3 , 6 } , {2,7}  } ; \n    \n    // b = { {0,1} , {0,2 } , {0,3 } , \n    //     { 2 , 4 } , { 2, 5} , { 3,6}, \n    //     { 2, 7 } } ; \n\n\n\n    // a = {{0,1},{2,0},{3,2},{3,6},{8,7},{4,8},{5,4},{3,5},{3,9}} ; \n    // b = {{0,1},{0,2},{0,3}} ; \n\n    auto ans = t.minimumDiameterAfterMerge ( a , b ) ; \n    cout << ans << \"\\n\" ;\n\n\n    return 0 ; \n}\n",
    "submit_ts": 1719719043.0
}