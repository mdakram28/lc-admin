{
    "username": "Namakian",
    "submission": "class Solution {\npublic:\n    \n    const static int N = 5*1e4 + 10;\n    \n    // const static int N = 10;\n    \n    struct node {\n        int max_length;\n        int max_pref;\n        int max_suff;\n        int total_length;\n        \n        node(int max_l, int max_p, int max_s, int total_length) : max_length(max_l), max_pref(max_p), max_suff(max_s), total_length(total_length){}\n        \n        node() {}\n    };\n    \n    \n    node seg_tree[4*N];\n    \n    \n    node merge(node& n1, node& n2) {\n        node p;\n        p.max_length = max({n1.max_length, n2.max_length, n1.max_suff + n2.max_pref});\n        p.max_pref = n1.max_pref;\n        if(n1.max_pref == n1.total_length) p.max_pref+= n2.max_pref;\n        p.max_suff = n2.max_suff;\n        if(n2.max_suff == n2.total_length)  p.max_suff += n1.max_suff;\n        p.total_length = n1.total_length + n2.total_length;\n        \n        return p;\n    }\n    \n    \n    \n    void build(int ind, int L, int R) {\n        if(L==R) {\n            seg_tree[ind] = node(1,1,1, 1);\n            return;\n        }\n        \n        int M = (L+R)/2;\n        \n        build(2*ind, L, M);\n        build(2*ind+1, M+1, R);\n        seg_tree[ind] = merge(seg_tree[2*ind], seg_tree[2*ind+1]);\n        \n        // cout << L << \" \" << R << \" \" << seg_tree[ind].max_length << \" \" << seg_tree[ind].max_pref << \" \" << seg_tree[ind].max_suff << endl;\n    }\n    \n    \n    void update(int ind, int L, int R, int x) {\n        if(L==R) {\n            seg_tree[ind] = node(0,0,0,1);\n            return;\n        }\n        \n        int M = (L+R)/2;\n        \n        if(x <= M) {\n            update(2*ind, L, M, x);\n        } else {\n            update(2*ind+1, M+1,R, x);\n        }\n        \n        seg_tree[ind] = merge(seg_tree[2*ind], seg_tree[2*ind+1]);\n    }\n    \n    node query(int ind, int L, int R, int qx, int qy) {\n        if(qx<=L && R<=qy) {\n            return seg_tree[ind];\n        }\n        \n        if(L>qy || R<qx) {\n            return node(0,0,0,1);\n        }\n        \n        int M = (L+R)/2;\n        \n        node l = query(2*ind, L, M, qx, qy);\n        node r = query(2*ind+1, M+1, R, qx,qy);\n        \n        return merge(l,r);\n    }\n    \n    \n    vector<bool> getResults(vector<vector<int>>& queries) {\n        \n        build(1, 0, N);\n        \n        // cout << seg_tree[1].max_length << endl;\n        \n        vector<bool> ans;\n        \n        for(auto& q : queries) {\n            if(q[0] ==1) {\n                update(1, 0, N, q[1]);\n            } else {\n                node t = query(1,0,N,1, q[1]-1);\n                \n                int length = t.max_length + 1;\n                \n                // if(q[1] != 1) {\n                //     length++;\n                // }\n                \n                // cout << q[1] << \" \" << q[2] << \" \" << t.max_length<< endl;\n                \n                if(length >= q[2]) {\n                    \n                    ans.push_back(true);\n                } else {\n                    ans.push_back(false);\n                }\n            }\n        }\n            \n        return ans;\n        \n    }\n};",
    "submit_ts": 1716651726.0
}