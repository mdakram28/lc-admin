{
    "username": "loxa_",
    "submission": "class Solution {\npublic:\n    #define ll long long\n        //SUM SEGMENT TREE\n    template<typename T>\n    class ST{\n    public:\n        int n, n_;\n        T identity_element;\n        vector<T> st, lazy;\n        ST(int n, T identity_element):n_(n), identity_element(identity_element){\n            while((n&(n-1))!=0) n++;\n            this->n = n;\n            // INITIALIZE IDENTITY ELEMENTS PROPERLY(initialize -INF for max, INF for min, 0 for sum)\n            st = vector<T>(2*n-1, identity_element);\n            lazy = vector<T>(2*n-1, identity_element);\n        }\n        T operation(T a, T b){\n            // CHANGE OPERATION ACCORDING TO REQUIREMENT\n            return a&b; // creating segment tree which maintains sum over ranges\n        }\n        void build(vector<T>& a){\n            _build(0, 0, n-1, a);\n        }\n        // x is the node index in segment tree array which will have 2*n-1 nodes\n        // lx, rx is the range node x corresponds to in the original array \n        void _build(int x, int lx, int rx, vector<T>& a){\n            if(lx==rx){\n                if(lx<n_) st[x] = a[lx];\n                return;\n            }\n            int mid = (lx+rx)/2;\n            _build(2*x+1, lx, mid, a);\n            _build(2*x+2, mid+1, rx, a);\n            st[x] = operation(st[2*x+1], st[2*x+2]);\n        }\n        void _propagate(int x, int lx, int rx){\n            // CHANGE PROPAGATION LOGIC ACCORDING TO REQUIREMENT\n            if(lazy[x]!=identity_element){ // if lazy array is set at this node only then propagate\n                int mid = (lx+rx)/2;\n                // updates sum segment tree range by incrementing all elements in the range by \"f\"\n                st[2*x+1]+=lazy[x]*(mid-lx+1);\n                st[2*x+2]+=lazy[x]*(rx-mid);\n                // stores update value in the lazy array at this node for future propagation\n                lazy[2*x+1]+=lazy[x];\n                lazy[2*x+2]+=lazy[x];\n            }\n            lazy[x] = identity_element; // reset lazy array at this node\n        }\n        T query(int l, int r){\n            return _query(0, l, r, 0, n-1);\n        }\n        // l, r is the range in the original array on which the query is made\n        // query is in range [l:r+1], indices from l to r(including r)\n        T _query(int x, int l, int r, int lx, int rx){\n            if(lx>r || rx<l) return identity_element; // SET IDENTITY ELEMENTS PROPERLY(set -INF for max, INF for min, 0 for sum)\n            else if(lx>=l && rx<=r) return st[x];\n            _propagate(x, lx, rx);\n            int mid = (lx+rx)/2;\n            T ql = _query(2*x+1, l, r, lx, mid);\n            T qr = _query(2*x+2, l, r, mid+1, rx);\n            T res = operation(ql, qr);\n            return res;\n        }\n        void update(int l, int r, T f){\n            _update(0, l, r, f, 0, n-1);\n        }\n        void _update(int x, int l, int r, T f, int lx, int rx){\n            if(lx>r || rx<l) return;\n            else if(lx>=l && rx<=r){\n                // CHANGE UPDATE LOGIC ACCORDING TO REQUIREMENT\n                lazy[x]+=f; // stores update value in the lazy array at this node for future propagation\n                st[x]+=f*(rx-lx+1); // updates sum segment range by incrementing all elements in the range by \"f\"\n                return;\n            }\n            _propagate(x, lx, rx);\n            int mid = (lx+rx)/2;\n            _update(2*x+1, l, r, f, lx, mid);\n            _update(2*x+2, l, r, f, mid+1, rx);\n            st[x] = operation(st[2*x+1], st[2*x+2]);\n        }\n    };\n    ll atmost(vector<int>& nums, int k, ST<int>& st){\n        int l = 0, r = 0, n = nums.size();\n        ll res = 0;\n        while(r<n){\n            int q = st.query(l, r);\n            while(q<k){\n                l++;\n                if(l>r) break;\n                q = st.query(l, r);\n            }\n            // cout << l << ' ' << r << '\\n';\n            if(l<=r && q>=k) res+=(r-l+1); \n\n            r++;\n        }\n        // cout << res << '\\n';\n        return res;\n    }\n    long long countSubarrays(vector<int>& nums, int k) {\n        int n = nums.size();\n        ST<int> st(n, INT_MAX);\n        st.build(nums);\n        ll x = atmost(nums, k, st), y = atmost(nums, k+1, st);\n        // cout << x << ' ' << y << '\\n';\n        return x-y;\n    }\n};",
    "submit_ts": "1720278035",
    "subm_id": "1311691427"
}