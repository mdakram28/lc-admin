{
    "username": "Zachary Chao",
    "submission": "#define sz(x) int(x.size())\n#define all(x) x.begin(), x.end()\n#define db double\n#define ll long long\n#define ar array\ntemplate<typename T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate<class T> struct segtree {\n    const int N; vector<T> tree, lazy, size;\n    segtree(int n) : N(1<<(__lg(n)+1)), tree(2*N), lazy(2*N), size(2*N) {\n        for (int i = 0; i < n; i++) size[i+N] = 1;\n        for (int i = N-1; i >= 1; i--) size[i] = size[i*2] + size[i*2+1];\n    }\n    void push(int node) {\n        if (lazy[node]) {\n            tree[node] += lazy[node] * size[node];\n            if (node < N) lazy[node*2] += lazy[node], lazy[node*2+1] += lazy[node];\n            lazy[node] = 0;\n        }\n    }\n    void update(int node, int nl, int nr, int ql, int qr, T v) {\n        push(node);\n        if (ql > nr || qr < nl) return;\n        if (ql <= nl && nr <= qr) {\n            lazy[node] += v, push(node);\n            return;\n        }\n        int mid = (nl+nr)/2;\n        update(node*2, nl, mid, ql, qr, v);\n        update(node*2+1, mid+1, nr, ql, qr, v);\n        tree[node] = tree[node*2] + tree[node*2+1];\n    }\n    T query(int node, int nl, int nr, int ql, int qr) {\n        push(node);\n        if (ql > nr || qr < nl) return 0;\n        if (ql <= nl && nr <= qr) return tree[node];\n        int mid = (nl+nr)/2;\n        return query(node*2, nl, mid, ql, qr) + query(node*2+1, mid+1, nr, ql, qr);\n    }\n    void update(int l, int r, T v) { update(1, 0, N-1, l, r, v); }\n    T query(int l, int r) { return query(1, 0, N-1, l, r); }\n};\n\nclass Solution {\npublic:\n    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n        int n = sz(s);\n        vector<vector<ar<int, 2>>> add(n);\n        for (int i = 0; i < sz(queries); i++) {\n            add[queries[i][1]].push_back({queries[i][0], i});\n        }\n        vector<ll> ans(sz(queries));\n        vector<int> p1(n), p2(n);\n        for (int i = 0; i < n; i++) {\n            p1[i] = (s[i] == '0') + (i ? p1[i-1] : 0);\n            p2[i] = (s[i] == '1') + (i ? p2[i-1] : 0);\n        }\n        segtree<ll> st(n);\n        for (int i = 0; i < n; i++) {\n            int l = 0, r = i, ans2 = i;\n            while (l <= r) {\n                int mid = (l+r)/2;\n                if (p1[i] - (mid ? p1[mid-1] : 0) <= k || p2[i] - (mid ? p2[mid-1] : 0) <= k) ans2 = mid, r = mid-1;\n                else l = mid+1;\n            }\n            st.update(ans2, i, 1);\n            for (auto [l, idx] : add[i]) ans[idx] = st.query(l, i);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1723949983",
    "subm_id": "1359734068"
}