{
    "username": "wangchaohui",
    "submission": "class SimpleSegmentTree<T>(\n    private val n: Int,\n    private val identity: T,\n    private val combine: (T, T) -> T,\n) {\n    private val tree = MutableList(2 * n) { identity }\n\n    constructor(values: List<T>, identity: T, combine: (T, T) -> T) :\n            this(values.size, identity, combine) {\n        values.forEachIndexed { i, v -> tree[i + n] = v }\n        for (i in n - 1 downTo 1) tree[i] = combine(tree[i * 2], tree[i * 2 + 1])\n    }\n\n    /** Queries for the range `[l, r)`. */\n    fun query(l: Int, r: Int): T {\n        var resL = identity\n        var resR = identity\n        var i = l + n\n        var j = r + n\n        while (i < j) {\n            if (i and 1 > 0) resL = combine(resL, tree[i++])\n            if (j and 1 > 0) resR = combine(tree[--j], resR)\n            i /= 2\n            j /= 2\n        }\n        return combine(resL, resR)\n    }\n\n    operator fun get(i: Int) = query(i, i + 1)\n\n    fun update(p: Int, transform: (T) -> T) {\n        var i = p + n\n        tree[i] = transform(tree[i])\n        while (i > 1) {\n            i /= 2\n            tree[i] = combine(tree[i * 2], tree[i * 2 + 1])\n        }\n    }\n}\n\ndata class Segment(\n    val left: Int? = null,\n    val right: Int? = left,\n    val leftCandidate: Int? = null,\n    val rightCandidate: Int? = null,\n    val ans: Int = 0,\n)\n\nclass Solution {\n    fun countOfPeaks(nums: IntArray, queries: Array<IntArray>): List<Int> {\n        val tree = SimpleSegmentTree(nums.map { Segment(it) }, identity = Segment()) { l, r ->\n            if (l.left == null || l.right == null) return@SimpleSegmentTree r\n            if (r.left == null || r.right == null) return@SimpleSegmentTree l\n            var ans = l.ans + r.ans\n            if (l.rightCandidate != null && l.rightCandidate > r.left) ans++\n            if (r.leftCandidate != null && r.leftCandidate > l.right) ans++\n            Segment(\n                left = l.left,\n                right = r.right,\n                leftCandidate = l.leftCandidate ?: if (l.left > r.left) l.left else -1,\n                rightCandidate = r.rightCandidate ?: if (r.right > l.right) r.right else -1,\n                ans = ans,\n            )\n        }\n        val ans = mutableListOf<Int>()\n        for (query in queries) {\n            when (query[0]) {\n                1 -> {\n                    val l = query[1]\n                    val r = query[2]\n                    ans += tree.query(l, r + 1).ans\n                }\n\n                2 -> {\n                    val i = query[1]\n                    val v = query[2]\n                    tree.update(i) { Segment(v) }\n                }\n            }\n        }\n        return ans\n    }\n}",
    "submit_ts": "1718507419",
    "subm_id": "539781242"
}