{
    "username": "wddd",
    "submission": "class Solution {\n    public int minimumSum(int[][] grid) {\n        int[] rows = new int[grid.length];\n        int[] cols = new int[grid[0].length];\n\n        int[] rr = new int[rows.length];\n        int[] rc = new int[cols.length];\n\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == 1) {\n                    rows[i] += 1 << j;\n                    cols[j] += 1 << i;\n\n                    rr[grid.length - 1 - i] += 1 << (grid[0].length - 1 - j);\n                    rc[grid[0].length - 1 - j] += 1 << (grid.length - 1 - i);\n                }\n            }\n        }\n\n//        int[] rr = new int[rows.length];\n//        int[] rc = new int[cols.length];\n//        for (int i = 0; i < rows.length; i++) {\n//            rr[i] = rows[rows.length - 1 - i];\n//        }\n//        for (int i = 0; i < cols.length; i++) {\n//            rc[i] = cols[cols.length - 1 - i];\n//        }\n\n        return Math.min(minimumSum(rows, cols), minimumSum(rr, rc));\n    }\n\n    private int minimumSum(int[] rows, int[] cols) {\n        int min = Integer.MAX_VALUE;\n        int rStart = 0;\n        while (rows[rStart] == 0) {\n            rStart++;\n        }\n        for (int i = rStart; i < rows.length; i++) {\n            int temp = above(rows, rStart, i);\n            int remaining = divideTwo(rows, cols, i + 1, -1);\n            if (temp + remaining < min) {\n                min = temp + remaining;\n            }\n        }\n\n        int cStart = 0;\n        while (cols[cStart] == 0) {\n            cStart++;\n        }\n        for (int j = cStart; j < cols.length; j++) {\n            int temp = above(cols, cStart, j);\n            int remaining = divideTwo(rows, cols, -1, j + 1);\n            if (temp + remaining < min) {\n                min = temp + remaining;\n            }\n        }\n\n        return min;\n    }\n\n    private int divideTwo(int[] rows, int[] cols, int rd, int cd) {\n        if (rd == -1) {\n            return divideTwo(cols, rows, cd, rd);\n        }\n\n        int mask = -1;\n        for (int i = 0; i < rd; i++) {\n            mask &= ~(1 << i);\n        }\n\n        int[] nc = cols.clone();\n        for (int i = 0; i < nc.length; i++) {\n            nc[i] &= mask;\n        }\n\n        return Math.min(divide(rows, rd), divide(nc, 0));\n    }\n\n    private int divide(int[] rows, int start) {\n        while (start < rows.length && rows[start] == 0) {\n            start++;\n        }\n\n        int end = rows.length - 1;\n        while (end >= start && rows[end] == 0) {\n            end--;\n        }\n\n        if (end <= start) {\n            return Integer.MAX_VALUE / 3;\n        }\n\n        int min = Integer.MAX_VALUE;\n\n        for (int i = start; i <= end; i++) {\n            if (rows[i] != 0) {\n                int temp = area(rows, start, i);\n\n                int next = i + 1;\n                while (next <= end && rows[next] == 0) {\n                    next++;\n                }\n                temp += area(rows, next, end);\n                min = Math.min(min, temp);\n            }\n        }\n\n        return min;\n    }\n\n    private int area(int[] rows, int start, int end) {\n        if (end < start) {\n            return Integer.MAX_VALUE / 3;\n        }\n\n        int cStart = 100;\n        int cEnd = 0;\n\n        for (int i = start; i <= end; i++) {\n            if (rows[i] != 0) {\n                cStart = Math.min(cStart, Integer.numberOfTrailingZeros(rows[i]));\n                cEnd = Math.max(cEnd, 31 - Integer.numberOfLeadingZeros(rows[i]));\n            }\n        }\n\n        return (end - start + 1) * (cEnd - cStart + 1);\n    }\n\n    private int above(int[] rows, int start, int end) {\n        int cStart = 100;\n        int cEnd = 0;\n\n        for (int i = start; i <= end; i++) {\n            if (rows[i] != 0) {\n                cStart = Math.min(cStart, Integer.numberOfTrailingZeros(rows[i]));\n                cEnd = Math.max(cEnd, 31 - Integer.numberOfLeadingZeros(rows[i]));\n\n//                cStart = Math.min(cStart, Integer.lowestOneBit(rows[i]));\n//                cEnd = Math.max(cEnd, Integer.highestOneBit(rows[i]));\n            }\n        }\n\n        return (end - start + 1) * (cEnd - cStart + 1);\n    }\n}",
    "submit_ts": 1719115034.0
}