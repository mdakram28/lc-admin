{
    "username": "Tanguilol",
    "submission": "class Solution {\n    public int numberOfSubstrings(String s) {\n        int[] zeroCounts = new int[s.length()];\n        TreeSet<Integer> indexs = new TreeSet<>();\n        int count = 0;\n        \n        int result = 0;\n        \n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '0') {\n                count++;\n                indexs.add(i);\n            }\n            \n            zeroCounts[i] = count;\n        }\n        \n        int initialZeros = 0;\n        \n        for (int i = 0; i < zeroCounts.length; i++) {\n            int ones = 0;\n            int zeros = 0;\n            int currentIndex = i - 1;\n\n            while (true) {\n                if (ones >= zeros * zeros) {\n                    // currently valid, find next zero\n                    Integer nextIndex = indexs.higher(currentIndex);\n                    \n                    //System.out.println(\"valid from \" + currentIndex + \" to \" + nextIndex);\n                    \n                    // everything up until this point is definitely valid\n                    if (nextIndex == null) {\n                        result += zeroCounts.length - currentIndex - 1;\n                        break;\n                        \n                    } else {\n                        int onesPassed = nextIndex - currentIndex - 1;\n                            \n                        result += onesPassed;\n                        \n                        ones += onesPassed;\n                        zeros++;\n                        currentIndex = nextIndex;\n                        \n                        if (ones >= zeros * zeros) {\n                            result++;\n                        }\n                    }\n                } else {\n                    // not currently valid, proceed to next possible valid spot\n                    int need = zeros * zeros - ones;\n                    \n                    //System.out.println(\"invalid from \" + currentIndex + \" to \" + (currentIndex + need));\n                    \n                    currentIndex += need;\n\n                    if (currentIndex >= zeroCounts.length) {\n                        break;\n                    }\n                    \n                    int length = currentIndex - i + 1;\n                    zeros = zeroCounts[currentIndex] - initialZeros;\n                    ones = length - zeros;\n                    \n                    if (ones >= zeros * zeros) {\n                        result++;\n                    }\n                }\n            }\n            \n            initialZeros = zeroCounts[i];\n        }\n        \n        return result;\n    }\n    \n    \n    /*\n        int result = 0;\n        \n        for (int i = 0; i < s.length(); i++) {\n            int ones = 0;\n            int add = 1;\n            int req = 0;\n            \n            for (int j = i; j < s.length(); j++) {\n                if (s.charAt(j) == '1') {\n                    ones++;\n                } else {\n                    req += add;\n                    add += 2;\n                }\n                \n                if (ones >= req) {\n                    result++;\n                }\n            }\n        }\n        \n        return result;\n    }\n    */\n}",
    "submit_ts": "1722136503",
    "subm_id": "1335736510"
}