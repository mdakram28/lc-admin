{
    "username": "Nishith G. Behera",
    "submission": "#define ll long long\n\nconst int maxN = 2e5 + 5;\nint N, Q;\nint a[maxN];\n\nstruct node {\n\tll val;\n\tll lzAdd;\n\tll lzSet;\n\tnode(){};\n} tree[maxN << 2];\n\n#define lc p << 1\n#define rc (p << 1) + 1\n\ninline void pushup(int p) {\n\ttree[p].val = tree[lc].val + tree[rc].val;\n\treturn;\n}\n\nvoid pushdown(int p, int l, int mid, int r) {\n\t// lazy: range set\n\tif (tree[p].lzSet != 0) {\n\t\ttree[lc].lzSet = tree[rc].lzSet = tree[p].lzSet;\n\t\ttree[lc].val = (mid - l + 1) * tree[p].lzSet;\n\t\ttree[rc].val = (r - mid) * tree[p].lzSet;\n\t\ttree[lc].lzAdd = tree[rc].lzAdd = 0;\n\t\ttree[p].lzSet = 0;\n\t} else if (tree[p].lzAdd != 0) {  // lazy: range add\n\t\tif (tree[lc].lzSet == 0) tree[lc].lzAdd += tree[p].lzAdd;\n\t\telse {\n\t\t\ttree[lc].lzSet += tree[p].lzAdd;\n\t\t\ttree[lc].lzAdd = 0;\n\t\t}\n\t\tif (tree[rc].lzSet == 0) tree[rc].lzAdd += tree[p].lzAdd;\n\t\telse {\n\t\t\ttree[rc].lzSet += tree[p].lzAdd;\n\t\t\ttree[rc].lzAdd = 0;\n\t\t}\n\t\ttree[lc].val += (mid - l + 1) * tree[p].lzAdd;\n\t\ttree[rc].val += (r - mid) * tree[p].lzAdd;\n\t\ttree[p].lzAdd = 0;\n\t}\n\treturn;\n}\n\nvoid build(int p, int l, int r) {\n\ttree[p].lzAdd = tree[p].lzSet = 0;\n\tif (l == r) {\n\t\ttree[p].val = a[l];\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(lc, l, mid);\n\tbuild(rc, mid + 1, r);\n\tpushup(p);\n\treturn;\n}\n\nvoid add(int p, int l, int r, int a, int b, ll val) {\n\tif (a > r || b < l) return;\n\tif (a <= l && r <= b) {\n\t\ttree[p].val += (r - l + 1) * val;\n\t\tif (tree[p].lzSet == 0) tree[p].lzAdd += val;\n\t\telse tree[p].lzSet += val;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tpushdown(p, l, mid, r);\n\tadd(lc, l, mid, a, b, val);\n\tadd(rc, mid + 1, r, a, b, val);\n\tpushup(p);\n\treturn;\n}\n\nll query(int p, int l, int r, int a, int b) {\n\tif (a > r || b < l) return 0;\n\tif (a <= l && r <= b) return tree[p].val;\n\tint mid = (l + r) >> 1;\n\tpushdown(p, l, mid, r);\n\treturn query(lc, l, mid, a, b) + query(rc, mid + 1, r, a, b);\n}\n\nbool validate(vector<ll>& ps0, vector<ll>& ps1, int l, int r, int k) {\n    bool zc = ps0[r+1] - ps0[l] <= k;\n    bool oc = ps1[r+1] - ps1[l] <= k;\n    return zc || oc;\n}\n\nclass Solution {\npublic:\n    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n        int n = s.size(), q = queries.size();\n        for(int i = 0; i < 2*n+5; i++) a[i] = 0;\n        vector<ll> ps0(1), ps1(1);\n        for(auto x : s) {\n            ps0.push_back(ps0.back() + (x == '0'));\n            ps1.push_back(ps1.back() + (x == '1'));\n        }\n        vector<ll> ans(q);\n        for(int i = 0; i < q; i++) {\n            queries[i].push_back(i);\n            swap(queries[i][0], queries[i][1]);\n        }\n        sort(queries.begin(), queries.end());\n        build(1, 1, n);\n        int l = 0, r = 0, qi = 0;\n        while(r < n) {\n            // if not valid move forward\n            while(!validate(ps0, ps1, l, r, k)) l++;\n            // add 1 to this range of l, r\n            add(1, 1, n, l+1, r+1, 1);\n            // get query result\n            while(qi < q && queries[qi][0] == r) {\n                ans[queries[qi][2]] = query(1, 1, n, queries[qi][1]+1, queries[qi][0]+1);\n                qi++;\n            }\n            r++;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1723953548",
    "subm_id": "1359824261"
}