{
    "username": "maxcruickshanks",
    "submission": "const int MM = 1e5 + 5;\nstruct node {\n    int l, r, mx;\n} seg[4 * MM];\nvoid pushup(int rt) {\n    if (seg[rt].l == seg[rt].r) return;\n    int lc = 2 * rt, rc = 2 * rt + 1;\n    seg[rt].mx = max(seg[lc].mx, seg[rc].mx);\n}\nvoid build(int rt, int l, int r) {\n    seg[rt].l = l, seg[rt].r = r;\n    if (l == r) {\n        seg[rt].mx = 0; return;\n    }\n    int mid = (l + r) / 2;\n    build(2 * rt, l, mid), build(2 * rt + 1, mid + 1, r);\n    pushup(rt);\n}\nint query_seg(int rt, int l, int r) {\n    if (seg[rt].r < l || seg[rt].l > r || l > r) return INT_MIN;\n    if (l <= seg[rt].l && seg[rt].r <= r) return seg[rt].mx;\n    return max(query_seg(2 * rt, l, r), query_seg(2 * rt + 1, l, r));\n}\nvoid update(int rt, int idx, int v) {\n    if (seg[rt].l > idx || seg[rt].r < idx) return;\n    if (seg[rt].l == idx && seg[rt].r == idx) {\n        seg[rt].mx = v; return;\n    }\n    update(2 * rt, idx, v), update(2 * rt + 1, idx, v);\n    pushup(rt);\n}\nvoid add(int loc, int sz, set<pair<int, int>>& st) {\n    //cout << \"ADD \" << loc << \" \" << sz << \"\\n\";\n    update(1, loc, sz);\n    st.insert({loc, sz});\n}\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        set<pair<int, int>> st;\n        vector<bool> ret;\n        int hi = 5e4 + 5;\n        build(1, 0, hi);\n        st.insert({0, hi});\n        update(1, 0, hi);\n        //cout << st.begin()->first << \"\\n\";\n        for (vector<int> &query : queries) {\n            //cout << \"process\\n\";\n            //cout << st.begin()->first << \"\\n\";\n            if (query[0] == 1) {\n                auto cur = st.lower_bound({query[1], hi + 1});\n                if (cur == st.end() || cur->first > query[1]) {\n                    // Move to the previous element which should cover the range\n                    if (cur != st.begin()) {\n                        --cur;\n                    }\n                }\n                if (cur == st.end() || cur->first > query[1]) {\n                    //cout << \"Error: No valid interval found\\n\";\n                    continue;  // Handle appropriately if necessary\n                }\n                //cout << cur->first << \" \" << cur->second << \"\\n\";\n                \n                pair<int, int> val = *cur, nxt = {0, 0};\n                bool good = false;\n                cur++;\n                if (cur != st.end()) good = true, nxt = *cur;\n                cur--;\n                st.erase(cur);\n                update(1, val.first, 0);\n                //cout << \"set \" << val.first << \" TO 0\\n\";\n                int sz = query[1] - val.first;\n                if (sz != 0) {\n                    add(val.first, sz, st);\n                }\n                if (good) {\n                    sz = nxt.first - query[1];\n                    //cout << \"NXT \" << sz << \"\\n\";\n                    if (sz != 0) {\n                        add(query[1], sz, st);\n                    }\n                } else {\n                    add(query[1], hi, st);\n                }\n            }\n            else if (query[0] == 2) {\n                int rit = query[1] - query[2],\n                    res = query_seg(1, 0, rit);\n                //cout << \"query \" << rit << \" \" << res << \" \" << query[2] << \"\\n\";\n                ret.push_back(res >= query[2]);\n            }\n        }\n        return ret;\n    }\n};",
    "submit_ts": "1716650052",
    "subm_id": "1267604998"
}