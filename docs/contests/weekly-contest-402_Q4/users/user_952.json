{
    "username": "ankit1442002",
    "submission": "class SegmentTree {\npublic:\n    SegmentTree(const vector<int>& nums_, int a, int b) : start(a), end(b), val(0), left(nullptr), right(nullptr), nums(nums_) {\n        \n        if (start == end) {\n            val = nums[start];\n            return;\n        }\n        \n        int mid = (a + b) / 2;\n        \n        left = new SegmentTree(nums, a, mid);\n        right = new SegmentTree(nums, mid + 1, b);\n        \n        val = left->val + right->val;\n    }\n    \n    void updateNode(int index, int n) {\n        if (index < start || index > end) {\n            return;\n        }\n        \n        if (start == end) {\n            val = n;\n            return;\n        }\n        \n        left->updateNode(index, n);\n        right->updateNode(index, n);\n        \n        val = left->val + right->val;\n    }\n    \n    int queryRange(int a, int b) {\n        if (a > end || b < start) {\n            return 0;\n        }\n        \n        if (start >= a && end <= b) {\n            return val;\n        }\n        \n        return left->queryRange(a, b) + right->queryRange(a, b);\n    }\n    \nprivate:\n    SegmentTree* left;\n    SegmentTree* right;\n    int start;\n    int end;\n    int val;\n    \n    const vector<int>& nums;\n};\n\n\nclass Solution {\n    SegmentTree* tree;\npublic:\n    \n//     vector<int> v(100100), Tree(4*100100), Lazy(4*100100, 0);\n\n// void buildTree(int tidx, int lo, int hi){\n\n// \tif(lo==hi){\n// \t\tTree[tidx] = v[hi];\n// \t\treturn;\n// \t}\n\n// \tint mid = (lo+hi)/2;\n\n// \tbuildTree(2*tidx+1, lo, mid);\n// \tbuildTree(2*tidx+2, mid+1, hi);\n\n// \tTree[tidx] = Tree[2*tidx+1] + Tree[2*tidx+2];\n\n// }\n\n// void updateTree(int tidx, int lo, int hi, int idx, int val){\n\n// \tif(lo==hi){\n// \t\tTree[tidx] = val;\n// \t\treturn;\n// \t}\n\n// \tint mid = (lo+hi)/2;\n\n// \tif(idx<=mid)\n// \t\tupdateTree(2*tidx+1, lo, mid, idx, val);\n// \telse\n// \t\tupdateTree(2*tidx+2, mid+1, hi, idx, val);\n\n// \tTree[tidx] = Tree[2*tidx+1] + Tree[2*tidx+2];\n\n// }\n\n// int query(int tidx, int lo, int hi, int L, int R){\n\n// \t// The Range which we are currently in : [lo, hi]\n// \t// The Range of which we have to compute the answer : [L, R]\n\n// \t// Outside Range\n// \tif( R<lo || L>hi )\n// \t\treturn 0;\n\n// \t// In Range\n// \tif( lo>=L && hi<=R )\n// \t\treturn Tree[tidx];\n\n// \t// Partial Overlap\n// \tint mid = (lo+hi)/2;\n// \tint leftans = query(2*tidx+1, lo, mid, L, R);\n// \tint rightans = query(2*tidx+2, mid+1, hi, L, R);\n\n// \treturn leftans + rightans;\n\n// }\n    \nvector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        vector<int > v(n);\n        tree = new SegmentTree(v, 0, v.size() - 1);\n\n        for(int i = 1;i<n - 1;i++){\n            if(a[i] > a[i-1] && a[i] > a[i + 1]){\n                // cout << i << endl;\n                tree->updateNode(i, 1);\n            }\n        }\n        vector<int > res;\n        for(int i =0 ;i< q.size();i++){\n            if(q[i][0] == 1){\n                res.push_back(tree->queryRange(q[i][1] + 1,  q[i][2] - 1));\n            } else{\n                a[q[i][1]] = q[i][2];\n                for(int j =q[i][1] - 1 ;j<q[i][1] + 2;j++){\n                    // cout << j <<\" this \" << endl;\n                    if(j >0 && j< n - 1){\n                        // check j and update \n                        if(a[j] > a[j-1] && a[j] > a[j + 1]){\n                            \n                            tree->updateNode(j, 1);\n                        } else{\n                            // cout << j << endl;\n                            tree->updateNode(j, 0);\n                        }\n                    }\n                }\n                // for(int i =0 ;i<n;i++){\n                //     cout << \"this \" << tree->queryRange(i ,i) << \" \" << a[i] << endl;\n                // }\n            }\n            \n        }\n        return  res;\n        \n    }\n};",
    "submit_ts": 1718508870.0
}