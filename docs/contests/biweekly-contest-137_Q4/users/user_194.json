{
    "username": "Basim256",
    "submission": "class Solution {\npublic:\n    struct Edge {\n        long long int from, to, capacity, cost;\n    };\n\n    vector<vector<long long int>> adj, cost, capacity;\n\n    const long long int INF = 1e18;  // Updated INF to a larger value\n\n    void shortest_paths(long long int n, long long int v0, vector<long long int>& d, vector<long long int>& p) {\n        d.assign(n, INF);\n        d[v0] = 0;\n        vector<bool> inq(n, false);\n        queue<long long int> q;\n        q.push(v0);\n        p.assign(n, -1);\n\n        while (!q.empty()) {\n            long long int u = q.front();\n            q.pop();\n            inq[u] = false;\n            for (long long int v : adj[u]) {\n                if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\n                    d[v] = d[u] + cost[u][v];\n                    p[v] = u;\n                    if (!inq[v]) {\n                        inq[v] = true;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n\n    long long int min_cost_flow(long long int N, vector<Edge> edges, long long int K, long long int s, long long int t) {\n        adj.assign(N, vector<long long int>());\n        cost.assign(N, vector<long long int>(N, 0));\n        capacity.assign(N, vector<long long int>(N, 0));\n        for (Edge e : edges) {\n            adj[e.from].push_back(e.to);\n            adj[e.to].push_back(e.from);\n            cost[e.from][e.to] = e.cost;\n            cost[e.to][e.from] = -e.cost;\n            capacity[e.from][e.to] = e.capacity;\n        }\n\n        long long int flow = 0;\n        long long int cost = 0;\n        vector<long long int> d, p;\n        while (flow < K) {\n            shortest_paths(N, s, d, p);\n            if (d[t] == INF)\n                break;\n\n            // find max flow on that path\n            long long int f = K - flow;\n            long long int cur = t;\n            while (cur != s) {\n                f = min(f, capacity[p[cur]][cur]);\n                cur = p[cur];\n            }\n\n            // apply flow\n            flow += f;\n            cost += f * d[t];\n            cur = t;\n            while (cur != s) {\n                capacity[p[cur]][cur] -= f;\n                capacity[cur][p[cur]] += f;\n                cur = p[cur];\n            }\n        }\n\n        if (flow < K)\n            return -1;\n        else\n            return cost;\n    }\n\n    long long int maximumValueSum(vector<vector<int>>& board) {\n        // source --> n nodes --> m nodes --> 1 node --3 cap--> sink\n        long long int n = board.size();\n        long long int m = board[0].size();\n        long long int maxx = board[0][0];\n\n        vector<vector<long long int>> costs(n, vector<long long int>(m));\n\n        for (long long int i = 0; i < n; i++) {\n            for (long long int j = 0; j < m; j++) {\n                maxx = std::max(maxx, static_cast<long long int>(board[i][j]));\n            }\n        }\n\n        for (long long int i = 0; i < n; i++) {\n            for (long long int j = 0; j < m; j++) {\n                costs[i][j] = maxx - board[i][j];\n            }\n        }\n\n        vector<Edge> edges;\n        // source = 0, 1-n rows, n+1-->n+m columns n+m+1 sink\n        for (long long int i = 1; i <= n; i++) {\n            edges.push_back(Edge{0, i, 1, 0});\n        }\n        for (long long int i = 1; i <= n; i++) {\n            for (long long int j = 1; j <= m; j++) {\n                edges.push_back(Edge{i, n + j, 1, costs[i - 1][j - 1]});\n            }\n        }\n        for (long long int j = 1; j <= m; j++) {\n            edges.push_back(Edge{n + j, n + m + 1, 1, 0});\n        }\n\n        long long int mincost = min_cost_flow(n + m + 2, edges, 3, 0, n + m + 1);\n\n        return 3 * maxx - mincost;\n    }\n};\n",
    "submit_ts": "1723908579",
    "subm_id": "1359158526"
}