{
    "username": "ypsirK",
    "submission": "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define ll long long\n//#define int ll\n#define pb push_back\n#define MOD 1000000007\n#define umap unordered_map\n//#define MOD 998244353\n#define mp make_pair\n#define FOR(i,a,b) for (int i = a; i < b; i++)\n#define FORD(i,a,b) for (int i = a; i >= b; i--)\n#define remax(a,b) a = max(a,b)\n#define remin(a,b) a = min(a,b)\n#define pii pair<int,int>\n#define F first\n#define S second\n#define vi vector<int>\n#define all(v) v.begin(),v.end()\n#define WL(t) while(t--)\n#define gcd(a,b) __gcd((a),(b))\n#define lcm(a,b) ((a)*(b))/gcd((a),(b))\n#define out(x) cout << #x << \" is \" << x << endl\n#define FastIO ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate<typename T> using pset = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>; // set\ntemplate<typename T> using pmultiset = tree<T,null_type,less_equal<T>,rb_tree_tag,tree_order_statistics_node_update>; // multiset\n\nvi adj[100005][2];\n\npii dfs(int cv,int p,int dep,int typ){\n    pii a = {cv,dep};\n    for(auto x:adj[cv][typ]){\n        if(x != p){\n            pii t = dfs(x,cv,dep+1,typ);\n            if(t.S > a.S){\n                a.F = t.F;\n                a.S = t.S;\n            }\n        }\n    }\n    return a;\n}\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size()+1;\n        int m = edges2.size()+1;\n        FOR(i,0,n){\n            adj[i][0].clear();\n        }\n        FOR(i,0,m){\n            adj[i][1].clear();\n        }\n        FOR(i,0,edges1.size()){\n            int u = edges1[i][0],v = edges1[i][1];\n            adj[u][0].pb(v);\n            adj[v][0].pb(u);\n        }\n        FOR(i,0,edges2.size()){\n            int u = edges2[i][0],v = edges2[i][1];\n            adj[u][1].pb(v);\n            adj[v][1].pb(u);\n        }\n        pii r1 = dfs(0,-1,0,0);\n        r1 = dfs(r1.F,-1,0,0);\n        pii r2 = dfs(0,-1,0,1);\n        r2 = dfs(r2.F,-1,0,1);\n        return max(((r1.S+1)/2)+((r2.S+1)/2)+1,max(r1.S,r2.S));\n    }\n};",
    "submit_ts": "1719717340",
    "subm_id": "1304389006"
}