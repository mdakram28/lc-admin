{
    "username": "Ajayreddy",
    "submission": "#ifndef LOCAL\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\n\nnamespace mitsuha{\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &A) {\n    os << A.first << \" \" << A.second;\n    return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &A) {\n    for (size_t i = 0; i < A.size(); i++) {\n        if (i) os << \" \";\n        os << A[i];\n    }\n    return os;\n}\n\nvoid print() {\n    std::cout << \"\\n\";\n    std::cout.flush();\n}\n\ntemplate <class Head, class... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n    std::cout << head;\n    if (sizeof...(Tail)) std::cout << \" \";\n    print(std::forward<Tail>(tail)...);\n}\n}\n\nnamespace mitsuha {\ntemplate <class T> bool chmin(T& x, const T& y) { \n    return y >= x ? false : (x = y, true); \n}\ntemplate <class T> bool chmax(T& x, const T& y) { \n    return y <= x ? false : (x = y, true); \n}\ntemplate <class T> constexpr T fld(const T x, const T y) { \n    T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); \n}\ntemplate <class T> constexpr T cld(const T x, const T y) { \n    T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); \n}\ntemplate <class T> constexpr T rem(const T x, const T y) { \n    return x - y * fld(x, y); \n}\ntemplate <class Iterable> void settify(Iterable& a) { \n    std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); \n}\ntemplate <typename T, typename... Vectors>\nvoid concat(std::vector<T> &first, const Vectors &... others) {\n    std::vector<T> &res = first;\n    (res.insert(res.end(), others.begin(), others.end()), ...);\n};\ntemplate <size_t D> struct Dim : std::array<int, D> {\n    template <typename ...Ints> Dim(const Ints& ...ns) : \n        std::array<int, D>::array{ static_cast<int>(ns)... } {}\n};\ntemplate <typename ...Ints> Dim(const Ints& ...) -> Dim<sizeof...(Ints)>;\ntemplate <class T, size_t D, size_t I = 0>\nauto ndvec(const Dim<D> &ns, const T& value = {}) {\n    if constexpr (I + 1 < D) {\n        return std::vector(ns[I], ndvec<T, D, I + 1>(ns, value));\n    } else {\n        return std::vector<T>(ns[I], value);\n    }\n}\n}\n\nnamespace mitsuha {\nusing str = std::string;\nusing int128 = __int128;\nusing uint128 = unsigned __int128;\ntemplate <class T> using min_priority_queue \n                            = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T> using max_priority_queue \n                            = std::priority_queue<T, std::vector<T>, std::less<T>>;\n}\n \n#ifndef __COUNTER__\n#define __COUNTER__ __LINE__\n#endif\n\n#define TL (long long)\n \n#define OVERLOAD5(a, b, c, d, e, ...) e\n#define REP1_0(b, c) REP1_1(b, c)\n#define REP1_1(b, c) for (long long REP_COUNTER_##c = 0; REP_COUNTER_##c < TL(b); ++REP_COUNTER_##c)\n#define REP1(b) REP1_0(b, __COUNTER__)\n#define REP2(i, b) for (long long i = 0; i < TL(b); ++i)\n#define REP3(i, a, b) for (long long i = TL(a); i < TL(b); ++i)\n#define REP4(i, a, b, c) for (long long i = TL(a); i < TL(b); i += TL(c))\n#define For(...) OVERLOAD5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)\n#define RREP2(i, a) for (long long i = TL(a)-1; i >= 0; --i)\n#define RREP3(i, a, b) for (long long i = TL(b)-1; i >= TL(a); --i)\n#define RREP4(i, a, b, c) for (long long i = TL(b)-1; i >= TL(a); i -= TL(c))\n#define Frr(...) OVERLOAD5(__VA_ARGS__, RREP4, RREP3, RREP2)(__VA_ARGS__)\n\n#define All(iterable) std::begin(iterable), std::end(iterable)\n#define len(iterable) TL iterable.size()\n#define elif else if\n\n#define KBIT(a, k) (a & (1ULL << (k)))\n\n#define Assert(x) void(0);\n\nusing namespace mitsuha;\nusing namespace std;\n \nconstexpr int iinf = std::numeric_limits<int>::max() / 2;\nconstexpr long long linf = std::numeric_limits<long long>::max() / 2;\n\nnamespace mitsuha{\nnamespace internal {\n    template <class E>\n    struct csr {\n        vector<int> start;\n        vector<E> elist;\n        explicit csr(int n, const vector<pair<int, E>>& edges): start(n + 1), elist(edges.size()) {\n            for (auto e: edges) { start[e.first + 1]++; }\n            for (int i = 1; i <= n; i++) { start[i] += start[i - 1]; }\n            auto counter = start;\n            for (auto e: edges) { elist[counter[e.first]++] = e.second; }\n        }\n    };\n\n    template <class T>\n    struct simple_queue {\n        vector<T> payload;\n        int pos = 0;\n        void reserve(int n) { payload.reserve(n); }\n        int size() const { return int(payload.size()) - pos; }\n        bool empty() const { return pos == int(payload.size()); }\n        void push(const T& t) { payload.push_back(t); }\n        T& front() { return payload[pos]; }\n        void clear() {\n            payload.clear();\n            pos = 0;\n        }\n        void pop() { pos++; }\n    };\n\n}\n\n/*\n\u30fbSlightly modified version of atcoder library\n\u30fbIf DAG = true, negative side OK (1st shortest path is done with dp)\nHowever, it is assumed that the vertex numbers have been toposorted.\n*/\ntemplate <class Cap = int, class Cost = long long, bool DAG = false>\nstruct Min_Cost_Flow {\npublic:\n    Min_Cost_Flow() {}\n    explicit Min_Cost_Flow(int n, int source, int sink) : n(n), source(source), sink(sink) {\n        assert(0 <= source && source < n);\n        assert(0 <= sink && sink < n);\n        assert(source != sink);\n    }\n\n    // frm, to, cap, cost\n    int add(int frm, int to, Cap cap, Cost cost) {\n        assert(0 <= frm && frm < n);\n        assert(0 <= to && to < n);\n        assert(0 <= cap);\n        assert(DAG || 0 <= cost);\n        if (DAG) assert(frm < to);\n        int m = int(_edges.size());\n        _edges.push_back({frm, to, cap, 0, cost});\n        return m;\n    }\n\n    struct edge {\n        int frm, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n\n    edge get_edge(int i) {\n        int m = int(_edges.size());\n        assert(0 <= i && i < m);\n        return _edges[i];\n    }\n    vector<edge> edges() { return _edges; }\n\n    pair<Cap, Cost> flow() { return flow(numeric_limits<Cap>::max() / 2); }\n    pair<Cap, Cost> flow(Cap flow_limit) { return slope(flow_limit).back(); }\n    vector<pair<Cap, Cost>> slope() { return slope(numeric_limits<Cap>::max() / 2); }\n    vector<pair<Cap, Cost>> slope(Cap flow_limit) {\n        int m = int(_edges.size());\n        vector<int> edge_idx(m);\n\n        auto g = [&]() {\n            vector<int> degree(n), redge_idx(m);\n            vector<pair<int, _edge>> elist;\n            elist.reserve(2 * m);\n            for (int i = 0; i < m; i++) {\n                auto e = _edges[i];\n                edge_idx[i] = degree[e.frm]++;\n                redge_idx[i] = degree[e.to]++;\n                elist.push_back({e.frm, {e.to, -1, e.cap - e.flow, e.cost}});\n                elist.push_back({e.to, {e.frm, -1, e.flow, -e.cost}});\n            }\n            auto _g = internal::csr<_edge>(n, elist);\n            for (int i = 0; i < m; i++) {\n                auto e = _edges[i];\n                edge_idx[i] += _g.start[e.frm];\n                redge_idx[i] += _g.start[e.to];\n                _g.elist[edge_idx[i]].rev = redge_idx[i];\n                _g.elist[redge_idx[i]].rev = edge_idx[i];\n            }\n            return _g;\n        }();\n\n        auto result = slope(g, flow_limit);\n\n        for (int i = 0; i < m; i++) {\n            auto e = g.elist[edge_idx[i]];\n            _edges[i].flow = _edges[i].cap - e.cap;\n        }\n\n        return result;\n    }\n\n    // O(F(N+M)) Route restoration using about\n    vector<vector<int>> path_decomposition() {\n        vector<vector<int>> TO(n);\n        for (auto&& e: edges()) { for(int _ = 0; _ < e.flow; ++_) TO[e.frm].eb(e.to); }\n        vector<vector<int>> res;\n        vector<int> vis(n);\n\n        while (!TO[source].empty()) {\n            vector<int> path = {source};\n            vis[source] = 1;\n            while (path.back() != sink) {\n                int to = TO[path.back()].back();\n                TO[path.back()].pop_back();\n                while (vis[to]) {\n                    vis[path.back()] = 0;\n                    path.pop_back();\n                }\n                path.emplace_back(to), vis[to] = 1;\n            }\n            for (auto&& v: path) vis[v] = 0;\n            res.emplace_back(path);\n        }\n        return res;\n    }\n\nprivate:\n    int n, source, sink;\n    vector<edge> _edges;\n\n    // inside edge\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n\n    vector<pair<Cap, Cost>> slope(internal::csr<_edge>& g, Cap flow_limit) {\n        if (DAG) assert(source == 0 && sink == n - 1);\n        vector<pair<Cost, Cost>> dual_dist(n);\n        vector<int> prev_e(n);\n        vector<bool> vis(n);\n        struct Q {\n            Cost key;\n            int to;\n            bool operator<(Q r) const { return key > r.key; }\n        };\n        vector<int> que_min;\n        vector<Q> que;\n        auto dual_ref = [&]() {\n            for (int i = 0; i < n; i++) { dual_dist[i].second = numeric_limits<Cost>::max() / 2; }\n            fill(vis.begin(), vis.end(), false);\n            que_min.clear();\n            que.clear();\n\n            // que[0..heap_r) was heapified\n            size_t heap_r = 0;\n\n            dual_dist[source].second = 0;\n            que_min.push_back(source);\n            while (!que_min.empty() || !que.empty()) {\n                int v;\n                if (!que_min.empty()) {\n                    v = que_min.back();\n                    que_min.pop_back();\n                } else {\n                    while (heap_r < que.size()) {\n                        heap_r++;\n                        push_heap(que.begin(), que.begin() + heap_r);\n                    }\n                    v = que.front().to;\n                    pop_heap(que.begin(), que.end());\n                    que.pop_back();\n                    heap_r--;\n                }\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == sink) break;\n                Cost dual_v = dual_dist[v].first, dist_v = dual_dist[v].second;\n                for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                    auto e = g.elist[i];\n                    if (!e.cap) continue;\n                    Cost cost = e.cost - dual_dist[e.to].first + dual_v;\n                    if (dual_dist[e.to].second > dist_v + cost) {\n                        Cost dist_to = dist_v + cost;\n                        dual_dist[e.to].second = dist_to;\n                        prev_e[e.to] = e.rev;\n                        if (dist_to == dist_v) {\n                            que_min.push_back(e.to);\n                        } else {\n                            que.push_back(Q{dist_to, e.to});\n                        }\n                    }\n                }\n            }\n            if (!vis[sink]) { return false; }\n\n            for (int v = 0; v < n; v++) {\n                if (!vis[v]) continue;\n                dual_dist[v].first -= dual_dist[sink].second - dual_dist[v].second;\n            }\n            return true;\n        };\n\n        auto dual_ref_dag = [&]() {\n            for(int i = 0; i < n; ++i) dual_dist[i].second = numeric_limits<Cost>::max() / 2;\n            dual_dist[source].second = 0;\n            fill(vis.begin(), vis.end(), false);\n            vis[0] = true;\n\n            for(int v = 0; v < n; ++v) {\n                if (!vis[v]) continue;\n                Cost dual_v = dual_dist[v].first, dist_v = dual_dist[v].second;\n                for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                    auto e = g.elist[i];\n                    if (!e.cap) continue;\n                    Cost cost = e.cost - dual_dist[e.to].first + dual_v;\n                    if (dual_dist[e.to].second > dist_v + cost) {\n                        vis[e.to] = true;\n                        Cost dist_to = dist_v + cost;\n                        dual_dist[e.to].second = dist_to;\n                        prev_e[e.to] = e.rev;\n                    }\n                }\n            }\n            if (!vis[sink]) { return false; }\n\n            for (int v = 0; v < n; v++) {\n                if (!vis[v]) continue;\n                dual_dist[v].first -= dual_dist[sink].second - dual_dist[v].second;\n            }\n            return true;\n        };\n\n        Cap flow = 0;\n        Cost cost = 0, prev_cost_per_flow = -1;\n        vector<pair<Cap, Cost>> result = {{Cap(0), Cost(0)}};\n        while (flow < flow_limit) {\n            if (DAG && flow == 0) {\n                if (!dual_ref_dag()) break;\n            } else {\n                if (!dual_ref()) break;\n            }\n            Cap c = flow_limit - flow;\n            for (int v = sink; v != source; v = g.elist[prev_e[v]].to) {\n                c = min(c, g.elist[g.elist[prev_e[v]].rev].cap);\n            }\n            for (int v = sink; v != source; v = g.elist[prev_e[v]].to) {\n                auto& e = g.elist[prev_e[v]];\n                e.cap += c;\n                g.elist[e.rev].cap -= c;\n            }\n            Cost d = -dual_dist[source].first;\n            flow += c;\n            cost += c * d;\n            if (prev_cost_per_flow == d) { result.pop_back(); }\n            result.push_back({flow, cost});\n            prev_cost_per_flow = d;\n        }\n        return result;\n    }\n};\n\ntemplate <class Cap = int, class Cost = long long, bool DAG = false>\nostream &operator<<(ostream &out, const Min_Cost_Flow<Cap, Cost, DAG> &Mcf){\n    auto mcf = Mcf;\n    out << \"flow graph\\n\";\n    out << \"frm, to, cap, cost\";\n    for (auto&& [frm, to, cap, flow, cost]: mcf._edges) {\n        out << \"\\n\" << frm << \" \" << to << \" \" << cap << \" \" << cost;\n    }\n    return out;\n}\n} // namespace mitsuha\n\nclass Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& a) {\n        \n        int n = len(a);\n        int m = len(a[0]);\n\n        Min_Cost_Flow<int, long long, true> Mf(n + m + 2, 0, n + m + 1);\n\n        For(x, n){\n            Mf.add(0, x + 1, 1, 0);\n            For(y, m){\n                Mf.add(x + 1, n + y + 1, 1, -a[x][y]);\n            }\n        }\n        For(y, m){\n            Mf.add(n + y + 1, n + m + 1, 1, 0);\n        }\n\n        return -Mf.flow(3).second;\n    }\n};\n\n",
    "submit_ts": "1723905377",
    "subm_id": "1358999278"
}