{
    "username": "ferferge",
    "submission": "\nclass PeakIntervalSegmentTree:\n \n    def __init__(self, n, merge=max, update_type='reset'):\n        self.init_val = {max: -float('inf'), min: float('inf')}\n        self.tree = defaultdict(lambda: self.init_val[merge])\n        self.lazy = defaultdict(lambda: self.init_val[merge])\n        self.n = n\n        self._merge = merge\n        self.update_type = update_type\n \n    def query(self, l, r):\n        return self._query(l, r, 0, self.n - 1, 1)\n \n    def update(self, l, r, val):\n        return self._update(l, r, 0, self.n - 1, val, 1)\n \n    def push_down(self, i):\n        if self.lazy[i] != self.init_val[self._merge]:\n            self.lazy[2 * i] = self._merge(self.lazy[2 * i], self.lazy[i])\n            self.lazy[2 * i + 1] = self._merge(self.lazy[2 * i + 1], self.lazy[i])\n            self.tree[2 * i] = self._merge(self.tree[2 * i], self.lazy[i])\n            self.tree[2 * i + 1] = self._merge(self.tree[2 * i + 1], self.lazy[i])\n            self.lazy[i] = self.init_val[self._merge]\n \n    def _update(self, l, r, s, t, val, i):\n        if l <= s and t <= r:\n            if self.update_type == 'reset':\n                self.tree[i] = self.lazy[i] = val\n            else:\n                self.tree[i] = self._merge(self.tree[i], val)\n                self.lazy[i] = self._merge(self.lazy[i], val)\n        else:\n            self.push_down(i)\n            m = s + (t - s) // 2\n            if l <= m:\n                self._update(l, r, s, m, val, 2 * i)\n            if r > m:\n                self._update(l, r, m + 1, t, val, 2 * i + 1)\n            self.tree[i] = self._merge(self.tree[2 * i], self.tree[2 * i + 1])\n \n    def _query(self, l, r, s, t, i):\n        if l <= s and t <= r:\n            return self.tree[i]\n        self.push_down(i)\n        m = s + (t - s) // 2\n        res = self.init_val[self._merge]\n        if l <= m:\n            cur = self._query(l, r, s, m, 2 * i)\n            res = self._merge(res, cur)\n        if r > m:\n            cur = self._query(l, r, m + 1, t, 2 * i + 1)\n            res = self._merge(res, cur)\n        return res\n\n\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        from sortedcontainers import SortedList\n        res = []\n        btree = PeakIntervalSegmentTree(5 * 10 ** 4 + 1)\n        sd = SortedList([0])\n        m = defaultdict(SortedList)\n        for q in queries:\n            if q[0] == 1:\n                idx = sd.bisect_right(q[1])\n                if idx >= len(sd):\n                    m[q[1]].add(q[1] - sd[-1])\n                    btree.update(q[-1], q[-1], m[q[1]][-1])\n                else:\n                    left, right = sd[idx - 1], sd[idx]\n                    m[right].remove(right - left)\n                    m[q[1]].add(q[1] - left)\n                    m[right].add(right - q[1])\n                    btree.update(q[-1], q[-1], m[q[1]][-1])\n                    btree.update(right, right, m[right][-1])\n                sd.add(q[1])\n            else:\n                fa = btree.query(0, q[1]) >= q[2] \n                fb = q[1] - sd[sd.bisect_right(q[1]) - 1]  >= q[2]\n                res.append(fa or fb)\n        return res\n        \n        ",
    "submit_ts": 1716651157.0
}