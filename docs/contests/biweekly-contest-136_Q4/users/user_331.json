{
    "username": "azesx",
    "submission": "using ll = long long;\n#define _rep_sel(a1,a2,a3,a4,exp,...) exp\n#define rep_n(n) for(ll i=0;i<(ll)(n);++i)\n#define rep_in(i,n) for(ll i=0;i<(ll)(n);++i)\n#define rep_isn(i,s,n) for(ll i=(ll)(s);i<(ll)(n);++i)\n#define rep_isninc(i,s,n,inc) for(ll i=(ll)(s);i<(ll)(n);i+=(ll)(inc))\n#define rep(...) _rep_sel(__VA_ARGS__,rep_isninc,rep_isn,rep_in,rep_n)(__VA_ARGS__)\n#define rrep(i,j,n,m) for(ll i=0;i<(ll)(n);++i) for(ll j=0;j<(ll)(m);++j)\n#define per(i,n) for(ll i=(ll)(n);i>=(ll)0;--i)\n#define each(it, a) for (const auto& it: a)\nconstexpr ll inf64 = 1e18+1;\nconstexpr int inf32 = 1e9+1;\ntemplate<class T, class TVal> inline bool chmax(T &a, const TVal &b) { return (a < b ? a = b, 1 : 0); }\ntemplate<class T, class TVal> inline bool chmin(T &a, const TVal &b) { return (a > b ? a = b, 1 : 0); }\ntemplate<typename T1, typename T2 = T1> struct v2 { T1 x; T2 y; friend strong_ordering operator<=>(const v2&, const v2&) = default; };\ntemplate<typename T1, typename T2 = T1, typename T3 = T1> struct v3 { T1 x; T2 y; T3 z; friend strong_ordering operator<=>(const v3&, const v3&) = default; };\ntemplate<typename T> using vec = vector<T>;\ntemplate<typename T> using vvec = vector<vector<T>>;\nusing veci = vec<ll>; using vveci = vvec<ll>;\nusing vecb = vec<bool>; using vvecb = vvec<bool>;\nusing v2i = v2<ll>; using v3i = v3<ll>;\ntemplate<typename T> using pq_dec = priority_queue<T>;\ntemplate<typename T> using pq_inc = priority_queue<T, vector<T>, greater<T>>;\n\n\nclass Solution {\npublic:\n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        vveci G(edges.size() + 1);\n        rep(i, edges.size())\n        {\n            G[edges[i][0]].push_back(edges[i][1]);\n            G[edges[i][1]].push_back(edges[i][0]);\n        }\n\n        vveci D(edges.size() + 1);\n        calc(0, -1, G, D);\n        correct(0, -1, G, D, 0);\n        vec<int> res = helper(D);\n        return res;\n    }\n\n    int calc(int index, int from, vveci& G, vveci& D)\n    {\n        int last = 0;\n        rep(i, G[index].size())\n        {\n            if(G[index][i] == from)\n            {\n                D[index].push_back(-inf32);\n                continue;\n            }\n\n            int price = calc(G[index][i], index, G, D);\n            D[index].push_back(price);\n            chmax(last, price);\n        }\n\n        return last + over(index);\n    }\n\n    void correct(int index, int from, vveci& G, vveci& D, int fromPrice)\n    {\n        veci mx2(2, 0);\n        rep(i, G[index].size())\n        {\n            if(G[index][i] == from)\n            {\n                D[index][i] = fromPrice;\n                break;\n            }\n        }\n\n        rep(i, G[index].size())\n        {\n            ch(mx2, D[index][i]);\n        }\n\n        rep(i, G[index].size())\n        {\n            if(G[index][i] == from) continue;\n            int t = mx2[0];\n            if(D[index][i] == mx2[0])\n            {\n                t = mx2[1];\n            }\n\n            correct(G[index][i], index, G, D, t + over(index));\n        }\n    }\n\n    vec<int> helper(vveci& D)\n    {\n        vec<int> cc(D.size(), 0);\n        rep(i, D.size())\n        {\n            rep(j, D[i].size())\n            {\n                chmax(cc[i], D[i][j]);\n            }\n        }\n\n        return cc;\n    }\n\n    void ch(veci& orig, int val)\n    {\n        if(val >= orig[0])\n        {\n            orig[1] = orig[0];\n            orig[0] = val;\n            return;\n        }\n\n        if(val > orig[1]) orig[1] = val;\n    }\n\n    int over(int index)\n    {\n        return (index % 2 ? 1 : 2);\n    }\n};",
    "submit_ts": "1722700563",
    "subm_id": "1343245778"
}