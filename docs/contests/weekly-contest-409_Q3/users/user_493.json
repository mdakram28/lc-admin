{
    "username": "Fasdr",
    "submission": "class Solution {\n    public int[] shortestDistanceAfterQueries(int n, int[][] queries) {\n        int m = queries.length;\n        LazySegmentTree lst = new LazySegmentTree(n);\n        int[] res = new int[m];\n        for (int i = 0; i < m; i++) {\n            lst.setZeroRange(queries[i][0] + 1, queries[i][1] - 1);\n            res[i] = lst.sumRange(0, n - 1);\n        }\n        \n        // System.out.println(Arrays.toString(lst.val));\n        return res;\n    }\n}\n\nclass LazySegmentTree {\n    \n    public int[] val;\n    public boolean[] lazy;\n    public int n;\n    \n    public LazySegmentTree(int n) {\n        val = new int[4 * n];\n        lazy = new boolean[4 * n];\n        this.n = n;\n        initialize(1, 0, n - 1);\n    }\n    \n    public int initialize(int node, int tl, int tr) {\n        if (tl == tr) {\n            if (tl == n - 1) {\n                return val[node] = 0;\n            }\n            return val[node] = 1;\n        }\n        int pivot = tl + (tr - tl) / 2;\n        return val[node] = (initialize(2 * node, tl, pivot) + initialize(2 * node + 1, pivot + 1, tr));\n    }\n    \n    public void setZeroRange(int ql, int qr) {\n        setZeroRangeHelp(1, ql, qr, 0, n - 1);\n    }\n    \n    public int setZeroRangeHelp(int node, int ql, int qr, int tl, int tr) {\n        if (lazy[node]) {\n            val[node] = 0;\n            lazy[node] = false;\n            if (tl != tr) {\n                lazy[2 * node] = true;\n                lazy[2 * node + 1] = true;\n            }\n        }\n        \n        if (ql <= tl && tr <= qr) {\n            val[node] = 0;\n            if (tl != tr) {\n                lazy[2 * node] = true;\n                lazy[2 * node + 1] = true;\n            }\n            return val[node];\n        }\n        if (tr < ql || qr < tl)\n            return val[node];\n        int pivot = tl + (tr - tl) / 2;\n        return val[node] = (setZeroRangeHelp(2 * node, ql, qr, tl , pivot) + setZeroRangeHelp(2 * node + 1, ql, qr, pivot + 1, tr));\n    }\n    \n    public int sumRange(int ql, int qr) {\n        return sumRangeHelp(1, ql, qr, 0, n - 1);\n    }\n    \n    public int sumRangeHelp(int node, int ql, int qr, int tl, int tr) {\n        if (lazy[node]) {\n            val[node] = 0;\n            lazy[node] = false;\n            if (tl != tr) {\n                lazy[2 * node] = true;\n                lazy[2 * node + 1] = true;\n            }\n        }\n        \n        if (ql <= tl && tr <= qr)\n            return val[node];\n        if (tr < ql || qr < tl)\n            return 0;\n        int pivot = (tr - tl) / 2 + tl;\n        return sumRangeHelp(2 * node, ql, qr, tl, pivot) + sumRangeHelp(2 * node + 1, ql, qr, pivot + 1, tr);\n    }\n    \n}\n\n\n",
    "submit_ts": "1722742008",
    "subm_id": "1343758744"
}