{
    "username": "avijain14",
    "submission": "#define ll long long\n\ntemplate<typename Node, typename Update>\nstruct SegTree {\nprivate:\n\tvector<Node> tree;\n\tvector<ll> arr;\n\tint n;\n\tint s;\n\tvoid build(int start, int end, int index)\n\t{\n\t\tif (start == end)\t{\n\t\t\ttree[index] = Node(arr[start]);\n\t\t\treturn;\n\t\t}\n\t\tint mid = (start + end) / 2;\n\t\tbuild(start, mid, 2 * index);\n\t\tbuild(mid + 1, end, 2 * index + 1);\n\t\ttree[index].merge(tree[2 * index], tree[2 * index + 1]);\n\t}\n\tvoid update(int start, int end, int index, int query_index, Update &u)\n\t{\n\t\tif (start == end) {\n\t\t\tu.apply(tree[index]);\n\t\t\treturn;\n\t\t}\n\t\tint mid = (start + end) / 2;\n\t\tif (mid >= query_index)\n\t\t\tupdate(start, mid, 2 * index, query_index, u);\n\t\telse\n\t\t\tupdate(mid + 1, end, 2 * index + 1, query_index, u);\n\t\ttree[index].merge(tree[2 * index], tree[2 * index + 1]);\n\t}\n\tNode query(int start, int end, int index, int left, int right) {\n\t\tif (start > right || end < left)\n\t\t\treturn Node();\n\t\tif (start >= left && end <= right)\n\t\t\treturn tree[index];\n\t\tint mid = (start + end) / 2;\n\t\tNode l, r, ans;\n\t\tl = query(start, mid, 2 * index, left, right);\n\t\tr = query(mid + 1, end, 2 * index + 1, left, right);\n\t\tans.merge(l, r);\n\t\treturn ans;\n\t}\n\t\npublic:\n\tSegTree(int a_len, vector<ll> &a) {\n\t\tarr = a;\n\t\tn = a_len;\n\t\ts = 1;\n\t\twhile(s < 2 * n){\n\t\t\ts = s << 1;\n\t\t}\n\t\ttree.resize(s); fill(tree.begin(), tree.end(), Node());\n\t\tbuild(0, n - 1, 1);\n\t}\n\tvoid make_update(int index, ll val) {\n\t\tUpdate new_update = Update(val);\n\t\tupdate(0, n - 1, 1, index, new_update);\n\t}\n\tll make_query(int left, int right) {\n\t\treturn query(0, n - 1, 1, left, right).val;\n\t}\n};\n\nstruct Node1 {\n\tll val; \n\tNode1() { \n\t\tval = 0;\t\n\t}\n\tNode1(ll p1) {\n\t\tval = p1;\n\t}\n\tvoid merge(Node1 &l, Node1 &r) { \n\t\tval = l.val + r.val;  \n\t}\n};\n\nstruct Update1 {\n\tll val;\n\tUpdate1(ll p1) {\n\t\tval = p1;\n\t}\n\tvoid apply(Node1 &a) {\n\t\ta.val = val; \n\t}\n};\n\nclass Solution \n{\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) \n    {\n        vector<ll> arr(nums.size(), 0);\n        for (int i = 1; i < nums.size() - 1; i++)\n        {\n            if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) arr[i] = 1;\n        }\n        SegTree<Node1, Update1> st(nums.size(), arr);\n        vector<int> ans;\n        for (auto q : queries)\n        {\n            if (q[0] == 1)\n            {\n                if (q[2] - q[1] > 1)\n                    ans.push_back(st.make_query(q[1] + 1, q[2] - 1));\n                else ans.push_back(0);\n            }\n            else\n            {\n                int idx = q[1], val = q[2];\n\n                if (idx > 1 && arr[idx - 1] == 1 && val >= nums[idx - 1]) \n                {\n                    st.make_update(idx - 1, 0);\n                    arr[idx - 1] = 0;\n                }\n\n                if (idx < nums.size() - 1 && arr[idx + 1] == 1 && val >= nums[idx + 1]) \n                {\n                    st.make_update(idx + 1, 0);\n                    arr[idx + 1] = 0;\n                }\n\n                if (idx > 0 && idx < nums.size() - 1 && val > nums[idx - 1] && val > nums[idx + 1]) \n                {\n                    st.make_update(idx, 1);\n                    arr[idx] = 1;\n                }\n\n                if (idx > 0 && idx < nums.size() - 1 && (val <= nums[idx - 1] || val <= nums[idx + 1])) \n                {\n                    st.make_update(idx, 0);\n                    arr[idx] = 0;\n                }\n                \n                if (idx > 1 && nums[idx - 1] > nums[idx - 2] && nums[idx - 1] > val)\n                {\n                    st.make_update(idx - 1, 1);\n                    arr[idx - 1] = 1;\n                }\n\n                if (idx < nums.size() - 2 && nums[idx + 1] > nums[idx + 2] && nums[idx + 1] > val)\n                {\n                    st.make_update(idx + 1, 1);\n                    arr[idx + 1] = 1;\n                }\n\n                nums[idx] = val;\n            }\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": 1718508026.0
}