{
    "username": "Satyam1782",
    "submission": "// struct node{\n//     int left,right,peek;\n    \n//     node(int a,int b,int c)\n//     {\n//         left=a;\n//         right=b;\n//         peek=c;\n//     }\n// };\n\nclass SGTree {\npublic: vector<int> seg;\n    int size;\npublic:\n\tSGTree(int n) {\n\t\tseg.resize(4 * n + 1);\n        size=n;\n\t}\n \n\tvoid build(int ind, int low, int high,vector<int> &arr) {\n        \n\t\tif (low == high) {\n            int ans=0;\n            \n            if(low>0 && low<size-1 && arr[low-1]<arr[low] && arr[low+1]<arr[low])\n                ans++;\n            \n\t\t\tseg[ind] = ans;\n\t\t\treturn;\n\t\t}\n \n\t\tint mid = (low + high) / 2;\n\t\tbuild(2 * ind + 1, low, mid,arr);\n\t\tbuild(2 * ind + 2, mid + 1, high,arr);\n//         node l=seg[2*ind+1];\n//         node r=seg[2*ind+2];\n        \n//         int total=l.peek+r.peek;\n        \n//         if(l.right!=r.left)\n//             total++;\n        \n    \n\t\tseg[ind] = seg[2*ind+1]+seg[2*ind+2];\n\t}\n \n\tint query(int ind, int low, int high, int l, int r) {\n\t\t// no overlap\n\t\t// l r low high or low high l r\n\t\tif (r < low || high < l) return 0;\n \n\t\t// complete overlap\n\t\t// [l low high r]\n\t\tif (low >= l && high <= r) return seg[ind];\n \n\t\tint mid = (low + high) >> 1;\n\t\tint left = query(2 * ind + 1, low, mid, l, r);\n\t\tint right = query(2 * ind + 2, mid + 1, high, l, r);\n\t\treturn left + right;\n\t}\n\tvoid update(int ind, int low, int high, int i, int val,vector<int> &arr) {\n\t\tif (low == high) {\n            int ans=0; \n            \n            if(low>0 && low<size-1 && arr[low-1]<val && arr[low+1]<val)\n                ans++;\n            \n\t\t\tseg[ind]=ans;\n            arr[low]=val;\n            \n\t\t\treturn;\n\t\t}\n \n\t\tint mid = (low + high) >> 1;\n\t\tif (i <= mid) update(2 * ind + 1, low, mid, i, val,arr);\n\t\telse update(2 * ind + 2, mid + 1, high, i, val,arr);\n\t\tseg[ind] = seg[2 * ind + 1] + seg[2 * ind + 2];\n\t}\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        SGTree st(n);\n        st.build(0,0,n-1,nums);\n        vector<int> ans;\n        \n        for(auto it:queries)\n        {\n            int type=it[0];\n            \n            if(type==1)\n            {\n                int l=it[1];\n                int r=it[2];\n                \n                int c=0;\n                \n                if(l>0 && l+1<n && nums[l]>nums[l+1] && nums[l]>nums[l-1])\n                    c++;\n                \n                if(l!=r && r>0 && r+1<n && nums[r]>nums[r+1] && nums[r]>nums[r-1])\n                    c++;\n                \n                int res=st.query(0,0,n-1,l,r)-c;\n\n                ans.push_back(res);\n            }\n            else\n            {\n                int ind=it[1];\n                int val=it[2];\n                \n                st.update(0,0,n-1,ind,val,nums);\n                if(ind>0)\n                    st.update(0,0,n-1,ind-1,nums[ind-1],nums);\n                \n                if(ind<n-1)\n                    st.update(0,0,n-1,ind+1,nums[ind+1],nums);\n            }\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": 1718509518.0
}