{
    "username": "tllwtg",
    "submission": "template <typename T>\nclass SegmentTree\n{\nprivate:\n    int n;\n    vector<T> tree, mark;\n    void push_down(int p, int len)\n    {\n        mark[p * 2] += mark[p];\n        mark[p * 2 + 1] += mark[p];\n        tree[p * 2] += mark[p] * (len - len / 2);\n        tree[p * 2 + 1] += mark[p] * (len / 2);\n        mark[p] = 0;\n    }\n\npublic:\n    vector<T> arr;\n    SegmentTree(int _n) : n(_n)\n    {\n        tree.resize(4 * n + 10, 0);\n        mark.resize(4 * n + 10, 0);\n        arr.resize(n + 10);\n    }\n    void build(int l, int r, int p = 1)\n    {\n        if (l == r)\n            tree[p] = arr[l];\n        else\n        {\n            int middle = (l + r) / 2;\n            build(l, middle, 2 * p);\n            build(middle + 1, r, 2 * p + 1);\n            tree[p] = tree[2 * p] + tree[2 * p + 1];\n        }\n    }\n    void update(int l, int r, int cl, int cr, T d, int p = 1)\n    {\n        if (cr < l || cl > r)\n            return;\n        else if (l <= cl && cr <= r)\n        {\n            tree[p] += d * (cr - cl + 1);\n            if (cr > cl)\n                mark[p] += d;\n        }\n        else\n        {\n            int middle = (cl + cr) / 2;\n            push_down(p, cr - cl + 1);\n            update(l, r, cl, middle, d, p * 2);\n            update(l, r, middle + 1, cr, d, p * 2 + 1);\n            tree[p] = tree[p * 2] + tree[p * 2 + 1];\n        }\n    }\n    T query(int l, int r, int cl, int cr, int p = 1)\n    {\n        if (cl > r || cr < l)\n            return 0;\n        else if (cl >= l && cr <= r)\n            return tree[p];\n        else\n        {\n            int mid = (cl + cr) / 2;\n            push_down(p, cr - cl + 1);\n            return query(l, r, cl, mid, p * 2) + query(l, r, mid + 1, cr, p * 2 + 1);\n        }\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        SegmentTree<int> tree(n);\n        nums.insert(nums.begin(), 0);\n        vector<int> is(n + 1, 0);\n        for (int i = 2; i <= n - 1; ++i)\n            if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1])\n            {\n                is[i] = 1;\n                tree.update(i, i, 1, n, 1);\n            }\n        vector<int> ans;\n        for (int i = 0; i < m; ++i)\n        {\n            if (queries[i][0] == 1)\n            {\n                if (queries[i][2] - queries[i][1] <= 1)\n                    ans.push_back(0);\n                else\n                    ans.push_back(tree.query(queries[i][1] + 2, queries[i][2], 1, n));\n            }\n            else\n            {\n                int p = queries[i][1] + 1;\n                int d = queries[i][2];\n                if (p == 1)\n                {\n                    if (nums[p + 1] > nums[p + 2] && nums[p + 1] > d)\n                    {\n                        if (is[p + 1] == 0)\n                            tree.update(p + 1, p + 1, 1, n, 1);\n                        is[p + 1] = 1;\n                    }\n                    else\n                    {\n                        if (is[p + 1] == 1)\n                            tree.update(p + 1, p + 1, 1, n, -1);\n                        is[p + 1] = 0;\n                    }\n                    nums[p] = d;\n                }\n                else if (p == n)\n                {\n                    if (nums[p - 1] > nums[p - 2] && nums[p - 1] > d)\n                    {\n                        if (is[p - 1] == 0)\n                            tree.update(p - 1, p - 1, 1, n, 1);\n                        is[p - 1] = 1;\n                    }\n                    else\n                    {\n                        if (is[p - 1] == 1)\n                            tree.update(p - 1, p - 1, 1, n, -1);\n                        is[p - 1] = 0;\n                    }\n                    nums[p] = d;\n                }\n                else\n                {\n                    if (d > nums[p - 1] && d > nums[p + 1])\n                    {\n                        if (is[p] == 0)\n                            tree.update(p, p, 1, n, 1);\n                        is[p] = 1;\n                    }\n                    else\n                    {\n                        if (is[p] == 1)\n                            tree.update(p, p, 1, n, -1);\n                        is[p] = 0;\n                    }\n                    if (p != 2)\n                    {\n                        if (nums[p - 1] > nums[p - 2] && nums[p - 1] > d)\n                        {\n                            if (is[p - 1] == 0)\n                                tree.update(p - 1, p - 1, 1, n, 1);\n                            is[p - 1] = 1;\n                        }\n                        else\n                        {\n                            if (is[p - 1] == 1)\n                                tree.update(p - 1, p - 1, 1, n, -1);\n                            is[p - 1] = 0;\n                        }\n                    }\n                    if (p != n - 1)\n                    {\n                        if (nums[p + 1] > nums[p + 2] && nums[p + 1] > d)\n                        {\n                            if (is[p + 1] == 0)\n                                tree.update(p + 1, p + 1, 1, n, 1);\n                            is[p + 1] = 1;\n                        }\n                        else\n                        {\n                            if (is[p + 1] == 1)\n                                tree.update(p + 1, p + 1, 1, n, -1);\n                            is[p + 1] = 0;\n                        }\n                    }\n                    nums[p] = d;\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718507950.0
}