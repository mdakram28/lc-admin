{
    "username": "LessThanExpert",
    "submission": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define ll long long\n#define ull unsigned ll\n#define float double\n#define ff first\n#define ss second\n#define all(up) up.begin(), up.end()\n#define sz(x) ((ll)x.size())\n#define debug(x) cerr << #x << \" \" << x << \"\\n\";\n#define printans(okk) cout << (okk ? \"Yes\\n\" : \"No\\n\");\n#define uniq(up) up.erase(unique(all(up)), up.end());\n#define iofast ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\ntemplate <class T>\nusing oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nll getRandomNumber(ll l, ll r) { return uniform_int_distribution<ll>(l, r)(rng); }\nconst ll N = 1e5 + 7, mod = 1E9 + 7, nodes = 2e5 + 7, LOG = 18, INF = 1e18, inf = 1e9;\nclass Tree_Dia\n{\npublic:\n    vector<int> level;\n    vector<vector<int>> adj;\n    void dfs(int root, int par, int depth)\n    {\n        level[root] = depth;\n        for (auto child : adj[root])\n        {\n            if (child != par)\n            {\n                dfs(child, root, depth + 1);\n            }\n        }\n    }\n    int Dia(vector<vector<int>> &edges)\n    {\n        int n = edges.size() + 1;\n        adj = vector<vector<int>>(n + 10);\n        level = vector<int>(n + 10);\n        for (auto &e : edges)\n        {\n            int u = e[0] + 1, v = e[1] + 1;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        dfs(1, 0, 0);\n        int pos = 0;\n        for (int i = 0; i < n+10; i++)\n            if (level[pos] < level[i])\n                pos = i;\n        dfs(pos, 0, 0);\n        for (int i = 0; i < n+10; i++)\n            if (level[pos] < level[i])\n                pos = i;\n        return level[pos];\n    }\n};\nclass Solution\n{\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>> &edges1, vector<vector<int>> &edges2)\n    {\n        Tree_Dia t1, t2;\n        int Dia1 = t1.Dia(edges1);\n        int Dia2 = t2.Dia(edges2);\n        // cout<<Dia1<<' '<<Dia2<<'\\n';\n        return max({Dia1, Dia2, ((Dia1+ 1)/ 2) + ((Dia2+ 1)/ 2) + 1});\n    }\n};\nauto init = []()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    return 0;\n}();\n",
    "submit_ts": 1719718705.0
}