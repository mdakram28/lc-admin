{
    "username": "TheoGermal",
    "submission": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T>\nusing pbds =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n// #define cerr if(false)cerr\n\n#define pb push_back\n#define F first\n#define S second\n#define yes cout << \"Yes\\n\"\n#define no cout << \"No\\n\"\n#define yn(x) x ? yes : no\n#define f(i, s, e) for (int i = s; i < e; i++)\n#define vi vector<int>\n#define vb vector<bool>\n#define pii pair<int, int>\n#define vpi vector<pii>\n#define all(x) x.begin(), x.end()\n#define minele(x) *min_element(all(x))\n#define maxele(x) *max_element(all(x))\n#define endl '\\n'\n\nconst int N = 2e5;\nconst int MOD = 998244353;\n\n#ifndef ONLINE_JUDGE\n#define debug(x)            \\\n    cerr << (#x) << \" is \"; \\\n    _print(x)\n#define dbg(x...)           \\\n    cerr << (#x) << \" is \"; \\\n    _print(x)\n#else\n#define debug(x)\n#define dbg(x)\n#define dbg(x...)\n#endif\n\ntemplate <typename T>\nvoid _print(T a)\n{\n    cerr << a;\n}\ntemplate <typename T1, typename... T2>\nvoid _print(T1 t1, T2... t2)\n{\n    cerr << t1 << \", \";\n    _print(t2...);\n    cerr << endl;\n}\ntemplate <typename T>\nvoid print(T a)\n{\n    cout << a << ' ';\n}\ntemplate <typename T>\nvoid println(T a)\n{\n    cout << a << endl;\n}\ntemplate <class T>\nistream &operator>>(istream &is, vector<T> &a)\n{\n    for (auto &x : a)\n        is >> x;\n    return is;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &a)\n{\n    for (const auto &x : a)\n        os << x << ' ';\n    return os;\n}\n\ntemplate <class T, class V>\nvoid _print(pair<T, V> p);\ntemplate <class T>\nvoid _print(vector<T> v);\ntemplate <class T>\nvoid _print(set<T> v);\ntemplate <class T, class V>\nvoid _print(map<T, V> v);\ntemplate <class T>\nvoid _print(multiset<T> v);\ntemplate <class T, class V>\nvoid _print(pair<T, V> p)\n{\n    cerr << \"{\";\n    _print(p.F);\n    cerr << \",\";\n    _print(p.S);\n    cerr << \"} \";\n}\ntemplate <class T>\nvoid _print(vector<T> v)\n{\n    cerr << \"[ \";\n    for (T i : v)\n    {\n        _print(i);\n        cerr << \" \";\n    }\n    cerr << \"]\";\n    cerr << endl;\n}\ntemplate <class T>\nvoid _print(set<T> v)\n{\n    cerr << \"[ \";\n    for (T i : v)\n    {\n        _print(i);\n        cerr << \" \";\n    }\n    cerr << \"]\";\n    cerr << endl;\n}\ntemplate <class T>\nvoid _print(multiset<T> v)\n{\n    cerr << \"[ \";\n    for (T i : v)\n    {\n        _print(i);\n        cerr << \" \";\n    }\n    cerr << \"]\";\n    cerr << endl;\n}\ntemplate <class T, class V>\nvoid _print(map<T, V> v)\n{\n    cerr << \"[ \";\n    for (auto i : v)\n    {\n        _print(i);\n        cerr << \" \";\n    }\n    cerr << \"]\";\n    cerr << endl;\n}\ntemplate <class T, class V>\nvoid _print(unordered_map<T, V> v)\n{\n    cerr << \"[ \";\n    for (auto i : v)\n    {\n        _print(i);\n        cerr << \" \";\n    }\n    cerr << \"]\";\n    cerr << endl;\n}\n\nstruct info {\n    int a;\n    int b;\n    int c;\n    int d;\n    info()\n    {\n        a = b = c = d = 0;\n    }\n    info(int A, int B, int C, int D)\n    {\n        a = A;\n        b = B;\n        c = C;\n        d = D;\n    }\n};\n\nclass SegmentTree\n{\npublic:\n    int n;\n    vector<info> tree;\n    vi v;\n    void build(int low, int high, int ind)\n    {\n        if (low == high)\n        {\n            tree[ind].a = v[low];\n            return;\n        }\n        int mid = (low + high) >> 1;\n\n        build(low, mid, 2 * ind + 1);\n        build(mid + 1, high, 2 * ind + 2);\n\n        tree[ind] = merge(tree[2 * ind + 1] , tree[2 * ind + 2]);\n    }\n    SegmentTree(vi &v)\n    {\n        this->v = v;\n        this->n = v.size();\n        tree.resize(4 * n);\n        this->build(0, n - 1, 0);\n    }\n    void update(int low, int high, int u, int value, int ind)\n    {\n        if (low == high)\n        {\n            tree[ind].a = value;\n            return;\n        }\n        int mid = (low + high) >> 1;\n        if (u <= mid)\n        {\n            update(low, mid, u, value, 2 * ind + 1);\n        }\n        else\n        {\n            update(mid + 1, high, u, value, 2 * ind + 2);\n        }\n\n        tree[ind] = merge(tree[2 * ind + 1] , tree[2 * ind + 2]);\n    }\n    info query(int low, int high, int l, int r, int ind)\n    {\n        int mid = (low + high) >> 1;\n        if (low > r || high < l)\n        {\n            return info(0, 0, 0, 0);\n        }\n        if (low >= l && high <= r)\n        {\n            return tree[ind];\n        }\n        info left = query(low, mid, l, r, 2 * ind + 1);\n        info right = query(mid + 1, high, l, r, 2 * ind + 2);\n\n        return merge(left , right);\n    }\n    info merge(info AA, info BB)\n    {\n        info CC;\n// a -> l, r : b -> l + 1, r : c -> l, r - 1 : d -> l + 1, r - 1\n        CC.a = max({AA.c + BB.b, AA.a + BB.b, AA.c + BB.a});\n        CC.b = max({AA.d + BB.b, AA.b + BB.b, AA.d + BB.a});\n        CC.c = max({AA.c + BB.d, AA.a + BB.d, AA.c + BB.c});\n        CC.d = max({AA.d + BB.d, AA.b + BB.d, AA.d + BB.c});\n\n        return CC;\n    }\n    void update(int u, int x)\n    {\n        update(0, n - 1, u, x, 0);\n    }\n    int query(int l, int r)\n    {\n        info Q = query(0, n - 1, l, r, 0);\n        return max({Q.a, Q.b, Q.c, Q.d});\n    }\n};\n\nclass Solution\n{\npublic:\n    const int m = 1e9 + 7;\n    int add(int a, int b)\n    {\n        a %= m;\n        b %= m;\n        return (a + b) % m;\n    }\n    int maximumSumSubsequence(vector<int> &v, vector<vector<int>> &queries)\n    {\n        // dp[i] = max(dp[i], dp[i - 1])\n        // dp[i] = max(dp[i], v[i] + dp[i - 2]);\n\n        SegmentTree st(v);\n        int n = v.size();\n        long long ans = 0;\n        for(auto q : queries)\n        {\n            st.update(q[0], q[1]);\n            ans = add(ans, st.query(0, n - 1));\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716694668.0
}