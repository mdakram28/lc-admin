{
    "username": "bhavik_11",
    "submission": "#define ll long long\n\n// My Segment Tree Template (inspired from Pashka)\nclass item {\n    public:\n    ll val;\n    \n    item() {\n        val = (1ll<<31)-1;\n    }\n    \n    item(ll v) {\n        val = v;\n    }\n};\n \nclass SegTree {\n    public:\n    ll size;\n    vector<item> values;\n \n    item NEUTRAL_ELEMENT = item();\n \n    item merge(item l,item r) {\n        return item(l.val & r.val);\n    }\n \n    item single(ll v) {\n        return item(v);\n    }\n \n    void init(ll n) {\n        size = 1;\n        while(size < n) size *= 2; //for last level array with some extra nodes for complete binary tree\n        values.resize(2*size -1);  //for complete binary tree\n    }\n    \n    void build(vector<int> &a,ll x,ll lx,ll rx) {\n        //base case\n        if(rx-lx == 1) {\n            if(lx < int(a.size())) {\n                values[x] = single(a[lx]);\n            }\n            return; \n        }\n \n        ll m = (lx+rx)/2;\n        build(a,2*x +1,lx,m);\n        build(a,2*x +2,m,rx);\n        values[x] = merge(values[2*x +1],values[2*x +2]);\n    }\n \n    void build(vector<int> &a) {\n        build(a,0,0,size);\n    }\n \n    void set(ll i,ll v,ll x,ll lx,ll rx) {\n        //base case\n        if(rx-lx == 1) {\n            values[x] = single(v);\n            return;\n        }\n \n        ll m = (lx+rx)/2;\n        if(i < m) {\n            set(i,v,2*x +1,lx,m);\n        }\n        else {\n            set(i,v,2*x +2,m,rx);\n        }\n        values[x] = merge(values[2*x+1],values[2*x+2]);\n    }\n \n    void set(ll i,ll v) {\n        set(i,v,0,0,size);\n    }\n\n    item calc(ll l,ll r,ll x,ll lx,ll rx) {\n        //base cases\n        if(lx >= r || l >= rx) return NEUTRAL_ELEMENT;\n        if(lx >= l && rx <= r) return values[x];\n \n        ll m = (lx+rx)/2;\n        item s1 = calc(l,r,2*x+1,lx,m);\n        item s2 = calc(l,r,2*x+2,m,rx);\n        return merge(s1,s2);\n    }   \n \n    item sum(ll l,ll r) {\n        return calc(l,r+1,0,0,size);\n    }\n};\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& arr, int k) {\n        int n = arr.size();\n        \n        SegTree st;\n        st.init(n);\n        st.build(arr);\n        \n        ll ans = 0;\n        for(int i=0; i<n; ++i) {\n            auto findMinIndex = [&]() -> ll {\n                ll minIndex = n;\n                ll l = i;\n                ll r = n-1;\n                while(l <= r){\n                    ll mid = l + (r-l)/2;\n                    ll res = st.sum(i, mid).val;\n                    if(res == k) {\n                        minIndex = mid;\n                        r = mid-1;\n                    }\n                    else if(res < k) r = mid-1;\n                    else l = mid+1;\n                }\n                return minIndex;\n            };\n            auto findMaxIndex = [&]() -> ll {\n                ll maxIndex = -1;\n                ll l = i;\n                ll r = n-1;\n                while(l <= r){\n                    ll mid = l + (r-l)/2;\n                    ll res = st.sum(i, mid).val;\n                    if(res == k) {\n                        maxIndex = mid;\n                        l = mid+1;\n                    }\n                    else if(res < k) r = mid-1;\n                    else l = mid+1;\n                }\n                return maxIndex;\n            };\n            ll minIndex = findMinIndex();\n            ll maxIndex = findMaxIndex();\n            if(minIndex != n && maxIndex != -1) ans += (maxIndex - minIndex + 1);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720279537",
    "subm_id": "1311755157"
}