{
    "username": "Time-limit-exceed",
    "submission": "\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int> ans;\n        // for each query, first find if the current query is in the range of the previous queries, if so then current query does not contribute to the result\n        // if not then find the previous queries that is in the range of the current query\n        // remove them and add the current query\n        // the current value would equal to the previous value - range of the current query + previous overlapped queries range\n        \n        map<int, int> buf0;\n        vector<int> res(1, n-1);\n        for(auto q: queries){\n            // check if is in the previous query\n            {\n                auto iter = buf0.upper_bound(q[0]);\n                if(iter != buf0.begin()){\n                    auto niter = --iter;\n                    if(niter->second >= q[1]){\n                        res.push_back(res.back());\n                        continue;\n                    }\n                }\n            }\n            int cres = res.back();\n            // check and remove all the previous queries that is in the range of the current query\n            {\n                auto iter = buf0.lower_bound(q[0]);\n                while(iter != buf0.end() && iter->first < q[1]){\n                    // cout<<iter->first<<\" \";\n                    cres += (iter->second-iter->first-1);\n                    iter = buf0.erase(iter);\n                }\n                // cout<<endl;\n            }\n            // cout<<q[0]<<\" \"<<q[1]<<endl;\n            cres -= (q[1]-q[0]-1);\n            buf0[q[0]] = q[1];\n            res.push_back(cres);\n        }\n        res.erase(res.begin());\n        return res;\n    }\n\n};",
    "submit_ts": "1722743177",
    "subm_id": "1343786146"
}