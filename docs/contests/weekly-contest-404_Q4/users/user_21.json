{
    "username": "LarryNY",
    "submission": "from collections import defaultdict, deque\n\ndef bfs_farthest_node(start, graph):\n    n = len(graph)\n    visited = [False] * n\n    dist = [0] * n\n    queue = deque([start])\n    visited[start] = True\n    farthest_node = start\n\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                dist[neighbor] = dist[node] + 1\n                queue.append(neighbor)\n                if dist[neighbor] > dist[farthest_node]:\n                    farthest_node = neighbor\n    \n    return farthest_node, dist[farthest_node]\n\ndef find_tree_diameter(edges):\n    n = len(edges) + 1\n    # Build the adjacency list\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Start from any node (node 0 in this case)\n    farthest_node, _ = bfs_farthest_node(0, graph)\n    # Find the farthest node from the previously found farthest node\n    farthest_node, diameter = bfs_farthest_node(farthest_node, graph)\n    \n    return diameter\n\ndef find_tree_center(edges):\n    n = len(edges) + 1\n    if n == 1:\n        return [0]\n    \n    # Build the adjacency list\n    graph = defaultdict(list)\n    degree = [0] * n\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degree[u] += 1\n        degree[v] += 1\n\n    # Initialize leaves\n    leaves = deque()\n    for i in range(n):\n        if degree[i] == 1:\n            leaves.append(i)\n\n    # Trim leaves until reaching the center\n    remaining_nodes = n\n    while remaining_nodes > 2:\n        leaves_count = len(leaves)\n        remaining_nodes -= leaves_count\n        for _ in range(leaves_count):\n            leaf = leaves.popleft()\n            for neighbor in graph[leaf]:\n                degree[neighbor] -= 1\n                if degree[neighbor] == 1:\n                    leaves.append(neighbor)\n\n    return list(leaves)\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        c1 = find_tree_center(edges1)\n        c2 = find_tree_center(edges2)\n        \n        edges = edges1[:]\n        offset = len(edges) + 1\n        for u, v in edges2:\n            edges.append([u + offset, v + offset])\n\n        INF = 10 ** 20\n        best = INF\n        for l in c1:\n            for r in c2:\n                edges.append([l, r + offset])\n                best = min(best, find_tree_diameter(edges))\n                edges.pop()\n        \n        return best",
    "submit_ts": 1719715605.0
}