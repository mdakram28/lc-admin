{
    "username": "Deepanshu_Jindal",
    "submission": "class Solution {\nprivate:\n    struct Graph {\n        vector<vector<int>> connections;\n        int nodeCount;\n\n        Graph(const vector<vector<int>>& edges) {\n            nodeCount = edges.size() + 1;\n            connections.resize(nodeCount);\n            for (const auto& edge : edges) {\n                connections[edge[0]].push_back(edge[1]);\n                connections[edge[1]].push_back(edge[0]);\n            }\n        }\n    };\n\n    int findLongestPath(const Graph& g, int start, int& endNode) {\n        vector<int> distances(g.nodeCount, -1);\n        function<void(int, int)> explore = [&](int current, int distance) {\n            distances[current] = distance;\n            if (distance > distances[endNode]) {\n                endNode = current;\n            }\n            for (int next : g.connections[current]) {\n                if (distances[next] == -1) {\n                    explore(next, distance + 1);\n                }\n            }\n        };\n        endNode = start;\n        explore(start, 0);\n        return distances[endNode];\n    }\n\n    int calculateDiameter(const Graph& g) {\n        int farNode = 0;\n        findLongestPath(g, 0, farNode);\n        return findLongestPath(g, farNode, farNode);\n    }\n\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        Graph graph1(edges1);\n        Graph graph2(edges2);\n\n        int diam1 = calculateDiameter(graph1);\n        int diam2 = calculateDiameter(graph2);\n\n        int result = max(diam1, diam2);\n        int radius1 = (diam1 + 1) / 2;\n        int radius2 = (diam2 + 1) / 2;\n        result = max(result, radius1 + radius2 + 1);\n\n        return result;\n    }\n};",
    "submit_ts": 1719717401.0
}