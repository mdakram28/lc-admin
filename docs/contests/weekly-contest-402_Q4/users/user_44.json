{
    "username": "peicd7699",
    "submission": "class NumArray:\n    def build(self, array, v, l, r):\n        # the vertex tree[v] will be responsible for the range array[l...r]\n        if l == r:\n            self.segment_tree[v] = array[l]\n        else:\n            m = l + (r-l)//2\n            left = v*2\n            right = left + 1\n            self.build(array, left, l, m)\n            self.build(array, right, m+1,r)\n\n            self.segment_tree[v] = self.segment_tree[left] + self.segment_tree[right]\n\n    def update_tree(self, v, l, r, index, val):\n        # we are at tree[v], which is reponsible for the segment nums[l...r]\n        if l == r:\n            self.segment_tree[v] = val\n        else:\n            m = l + (r-l)//2\n            if index <= m:\n                self.update_tree(v*2, l, m, index, val)\n            else:\n                self.update_tree(v*2+1, m+1, r, index, val)\n            self.segment_tree[v] = self.segment_tree[v*2]+self.segment_tree[v*2+1]\n\n    def rangesum_tree(self, v, l, r, ql, qr):\n        # tree[v] is responsible for nums[l...r]\n        # ql, qr are the query ranges\n        if ql > qr:\n            return 0\n        if l == ql and r == qr:\n            return self.segment_tree[v]\n        m = (r+l)//2\n        return self.rangesum_tree(v*2, l, m, ql, min(qr, m)) + self.rangesum_tree(v*2+1, m+1, r, max(m+1, ql), qr)\n    def __init__(self, nums: List[int]):\n        # initialise a segment tree\n        l = len(nums)\n        self.length = l\n        self.segment_tree = [0]*l*4\n        # the root will be 1\n        self.build(nums, 1, 0, l-1)\n\n    def update(self, index: int, val: int) -> None:\n        self.update_tree(1, 0, self.length-1, index, val)\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.rangesum_tree(1 , 0, self.length-1, left, right)\n    \n    \nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        is_peak = []\n        n = len(nums)\n        \n        \n        for i,v in enumerate(nums):\n            if 0<i<n-1 and v>nums[i-1] and v>nums[i+1]:\n                is_peak += [1]\n            else:\n                is_peak += [0]\n                \n        \n        tree = NumArray(is_peak)\n        ret = []\n        \n        for a,b,c in queries:\n            if a == 1:\n                ret += [tree.sumRange(b+1,c-1)]\n            else:\n                ind, val = b,c\n                if ind > 0:\n                    if is_peak[ind-1] and val >= nums[ind-1]:\n                        is_peak[ind-1] = 0\n                        tree.update(ind-1, 0)\n                    if is_peak[ind-1] == 0 and val < nums[ind-1] and ind >= 2 and nums[ind-1] > nums[ind-2]:\n                        is_peak[ind-1] = 1\n                        tree.update(ind-1, 1)\n                if ind < n-1:\n                    if is_peak[ind+1] and val >= nums[ind+1]:\n                        is_peak[ind+1] = 0\n                        tree.update(ind+1, 0)\n                        \n                    if is_peak[ind+1] == 0 and val < nums[ind+1] and ind < n-2 and nums[ind+1] > nums[ind+2]:\n                        is_peak[ind+1] = 1\n                        tree.update(ind+1, 1)\n                        \n                if is_peak[ind] and (val <= nums[ind-1] or val <= nums[ind+1]):\n                    is_peak[ind] = 0\n                    tree.update(ind, 0)\n                if is_peak[ind] == 0 and 0<ind<n-1 and val > nums[ind-1] and val > nums[ind+1]:\n                    is_peak[ind] = 1\n                    tree.update(ind, 1)\n                nums[ind] = val\n            # print(a, b, c, is_peak, nums)\n        return ret",
    "submit_ts": "1718506261",
    "subm_id": "1289612700"
}