{
    "username": "ernestlu",
    "submission": "class Solution {\npublic:\n    using pii = pair<int, int>;\nint minimumSum(vector<vector<int>> &grid) {\n  int min_x = 1e9, max_x = -1, min_y = 1e9, max_y = -1;\n  int n = (int)grid.size(), m = (int)grid[0].size();\n  const auto& a = grid;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (grid[i][j] == 1) {\n        min_x = min(min_x, i);\n        max_x = max(max_x, i);\n        min_y = min(min_y, j);\n        max_y = max(max_y, j);\n      }\n    }\n  }\n\n  using rect = array<int, 4>;\n\n  auto range_insct = [](int l, int r, int l2, int r2) -> bool {\n    if (l > l2) {\n      swap(l, l2);\n      swap(r, r2);\n    }\n    return l2 <= r;\n  };\n\n  auto rect_insct = [&range_insct](const rect &r, const rect &x) -> bool {\n    return range_insct(r[0], r[1], x[0], x[1]) and\n           range_insct(r[2], r[3], x[2], x[3]);\n  };\n\n  auto rect_area = [](const rect &r) -> int {\n    return (r[1] - r[0] + 1) * (r[3] - r[2] + 1);\n  };\n\n  auto transpose = [](const auto &a) -> vector<vector<int>> {\n    int n = (int)a.size(), m = (int)a[0].size();\n    vector<vector<int>> res(m, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        res[j][i] = a[i][j];\n      }\n    }\n    return res;\n  };\n\n  auto transpose_rect = [](const rect &r) -> rect {\n    return {r[2], r[3], r[0], r[1]};\n  };\n    \n  auto ta = transpose(a);\n    \n\n\n  constexpr int INF = 1e9;\n  auto f2 = [&](const auto &a, const rect &r) -> int {\n    int n = (int)a.size(), m = (int)a[0].size();\n    auto in_rect = [&](int i, int j) -> bool {\n        return i >= r[0] and i <= r[1] and j >= r[2] and j <= r[3];  \n    };\n    int min_x = 1e9, max_x = -1, min_y = 1e9, max_y = -1;\n    vector<int> pf_min_y(n, INF), pf_max_y(n, -1), suf_min_y(n, INF),\n        suf_max_y(n, -1);\n\n    vector<int> pf_max_x(n, -1), suf_min_x(n, INF);\n    for (int i = 0; i < n; i++) {\n        if (i > 0)\n            pf_min_y[i] = pf_min_y[i - 1], pf_max_y[i] = pf_max_y[i - 1],\n            pf_max_x[i] = pf_max_x[i - 1];\n      for (int j = 0; j < m; j++) {\n        if (in_rect(i, j))\n            continue;\n        if (a[i][j] == 1) {\n          min_x = min(min_x, i);\n          max_x = max(max_x, i);\n          min_y = min(min_y, j);\n          max_y = max(max_y, j);\n          pf_min_y[i] = min(pf_min_y[i], j);\n          pf_max_y[i] = max(pf_max_y[i], j);\n          pf_max_x[i] = max(pf_max_x[i], i);\n        }\n      }\n    }\n\n\n    for (int i = n - 1; i >= 0; i--) {\n      if (i + 1 < n)\n        suf_min_y[i] = suf_min_y[i + 1], suf_max_y[i] = suf_max_y[i + 1],\n        suf_min_x[i] = suf_min_x[i + 1];\n\n      for (int j = 0; j < m; j++) {\n          if (in_rect(i, j))\n            continue;\n        if (a[i][j] == 1) {\n          suf_min_y[i] = min(suf_min_y[i], j);\n          suf_max_y[i] = max(suf_max_y[i], j);\n          suf_min_x[i] = min(suf_min_x[i], i);\n        }\n      }\n    }\n\n    int ans = INF;\n    for (int split_x = min_x; split_x + 1 <= max_x; split_x++) {\n      if (suf_min_y[split_x + 1] == INF or pf_min_y[split_x] == INF) {\n        continue;\n      }\n\n      rect left = {min_x, pf_max_x[split_x], pf_min_y[split_x],\n                   pf_max_y[split_x]};\n      rect right = {suf_min_x[split_x + 1], max_x, suf_min_y[split_x + 1],\n                    suf_max_y[split_x + 1]};\n      if (rect_insct(r, left) or rect_insct(r, right)) {\n        continue;\n      }\n      ans = min(ans, rect_area(left) + rect_area(right));\n    }\n    return ans;\n  };\n\n  int ans = INF;\n  for (int rx = min_x; rx <= max_x; rx++) {\n    for (int ly = 0; ly <= max_y; ly++) {\n      for (int ry = ly; ry <= max_y; ry++) {\n        int lx = min_x;\n        rect rc = {lx, rx, ly, ry};\n        int h = rect_area(rc);\n        int h2 = f2(a, rc);\n        int h3 = f2(ta, transpose_rect(rc));\n        ans = min(ans, h + min(h2, h3));\n      }\n    }\n  }\n  return ans;\n}\n\n};",
    "submit_ts": 1719114733.0
}