{
    "username": "therealchainman",
    "submission": "class SegmentTree:\n    def __init__(self, n: int, neutral: int, func):\n        self.func = func\n        self.neutral = neutral\n        self.size = 1\n        self.n = n\n        while self.size<n:\n            self.size*=2\n        self.nodes = [neutral for _ in range(self.size*2)]\n\n    def ascend(self, segment_idx: int) -> None:\n        while segment_idx > 0:\n            segment_idx -= 1\n            segment_idx >>= 1\n            left_segment_idx, right_segment_idx = 2*segment_idx + 1, 2*segment_idx + 2\n            self.nodes[segment_idx] = self.func(self.nodes[left_segment_idx], self.nodes[right_segment_idx])\n        \n    def update(self, segment_idx: int, val: int) -> None:\n        segment_idx += self.size - 1\n        self.nodes[segment_idx] = val\n        self.ascend(segment_idx)\n            \n    def query(self, left: int, right: int) -> int:\n        stack = [(0, self.size, 0)]\n        result = self.neutral\n        while stack:\n            # BOUNDS FOR CURRENT INTERVAL and idx for tree\n            segment_left_bound, segment_right_bound, segment_idx = stack.pop()\n            # NO OVERLAP\n            if segment_left_bound >= right or segment_right_bound <= left: continue\n            # COMPLETE OVERLAP\n            if segment_left_bound >= left and segment_right_bound <= right:\n                result = self.func(result, self.nodes[segment_idx])\n                continue\n            # PARTIAL OVERLAP\n            mid_point = (segment_left_bound + segment_right_bound) >> 1\n            left_segment_idx, right_segment_idx = 2*segment_idx + 1, 2*segment_idx + 2\n            stack.extend([(mid_point, segment_right_bound, right_segment_idx), (segment_left_bound, mid_point, left_segment_idx)])\n        return result\n    \n    def __repr__(self) -> str:\n        return f\"nodes array: {self.nodes}\"\nfrom sortedcontainers import SortedList\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        m = len(queries)\n        res = []\n        compressed = {}\n        pos = [0]\n        for i, query in enumerate(queries):\n            if len(query) == 2:\n                i, x = query\n                pos.append(x)\n        pos.append(1_000_000)\n        pos.sort()\n        for x in pos:\n            compressed[x] = len(compressed)\n        n = len(compressed)\n        seg = SegmentTree(n, 0, max)\n        obstacles = SortedList()\n        obstacles.add(1_000_000)\n        obstacles.add(0)\n        seg.update(compressed[1_000_000], 1_000_000)\n        for query in queries:\n            if len(query) == 2:\n                _, x = query\n                r = obstacles.bisect_right(x)\n                l = r - 1\n                ldist = x - obstacles[l]\n                rdist = obstacles[r] - x\n                seg.update(compressed[obstacles[r]], rdist)\n                obstacles.add(x)\n                seg.update(compressed[x], ldist)\n                # print(x, seg)\n            else:\n                _, x, sz = query\n                i = obstacles.bisect_right(x) - 1\n                rdist = x - obstacles[i]\n                ldist = seg.query(0, compressed[obstacles[i]] + 1)\n                # print(\"rdist\", rdist, \"ldist\", ldist)\n                res.append(rdist >= sz or ldist >= sz)\n        return res",
    "submit_ts": 1716649629.0
}