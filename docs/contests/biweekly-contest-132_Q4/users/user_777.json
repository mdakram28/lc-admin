{
    "username": "darshit901",
    "submission": "class Solution {\n    public int maximumLength(int[] nums, int k) {\n        HashMap<Integer, HashMap<Integer, Integer>> startMaxLength = new HashMap<Integer, HashMap<Integer, Integer>>();\n        \n        int maxLen = 1;\n        HashMap<Integer, TreeMap<Integer, HashSet<Integer>>> kLengthStarts = new HashMap<Integer, TreeMap<Integer, HashSet<Integer>>>();\n        \n        final int n = nums.length;\n        startMaxLength.computeIfAbsent(nums[n-1], j -> new HashMap<Integer, Integer>()).put(0, 1);\n        kLengthStarts.computeIfAbsent(0, j -> new TreeMap<Integer, HashSet<Integer>>(Collections.reverseOrder())).computeIfAbsent(1, i -> new HashSet<Integer>()).add(nums[n-1]);\n        \n        for(int i=n-2; i>=0; i--) {\n            HashMap<Integer, Integer> currentVals = startMaxLength.getOrDefault(nums[i], new HashMap<Integer, Integer>());\n            currentVals.putIfAbsent(0, 0);\n            HashMap<Integer, Integer> newVals = new HashMap<Integer, Integer>();\n            int next = 0;\n            // System.out.println(startMaxLength);\n            while(next <= k) {\n                if(!currentVals.containsKey(next) && !kLengthStarts.containsKey(next-1)) {\n                    next++;\n                    continue;\n                } else if(!currentVals.containsKey(next)) {\n                    HashSet<Integer> candidates = kLengthStarts.get(next-1).firstEntry().getValue();\n                    // System.out.println(candidates);\n                    if(candidates.size() > 1 || !candidates.contains(nums[i])) {\n                        newVals.put(next, 1+kLengthStarts.get(next-1).firstKey());\n                    }\n                } else if(!kLengthStarts.containsKey(next-1)) {\n                    newVals.put(next, 1+currentVals.get(next));\n                } else {\n                    int length = 1+currentVals.get(next);\n                    Map.Entry<Integer, HashSet<Integer>> bestOption = kLengthStarts.get(next-1).pollFirstEntry();\n                    if(bestOption.getValue().size() == 1 && bestOption.getValue().contains(nums[i])) {\n                        if(!kLengthStarts.get(next-1).isEmpty()) {\n                            length = Math.max(length, kLengthStarts.get(next-1).firstEntry().getKey()+1);\n                        }\n                    } else {\n                        length = Math.max(length, bestOption.getKey()+1);\n                    }\n                    kLengthStarts.get(next-1).put(bestOption.getKey(), bestOption.getValue());\n                    newVals.put(next, length);\n                }\n                next++;\n            }\n            // System.out.println(newVals);\n            // Remove old keys from global map\n            if(currentVals.get(0) == 0) {\n                currentVals.remove(0);\n            }\n            for(Map.Entry<Integer, Integer> e: currentVals.entrySet()) {\n                HashSet<Integer> set = kLengthStarts.get(e.getKey()).get(e.getValue());\n                if(set.size() == 1) {\n                    kLengthStarts.get(e.getKey()).remove(e.getValue());\n                } else {\n                    set.remove(nums[i]);\n                }\n            }\n            \n            // Add new keys to global map\n            for(Map.Entry<Integer, Integer> e: newVals.entrySet()) {\n                maxLen = Math.max(maxLen, e.getValue());\n                kLengthStarts.computeIfAbsent(e.getKey(), j -> new TreeMap<Integer, HashSet<Integer>>(Collections.reverseOrder())).computeIfAbsent(e.getValue(), l -> new HashSet<Integer>()).add(nums[i]);\n            }\n            // System.out.println(kLengthStarts);\n            startMaxLength.put(nums[i], newVals);\n            // System.out.println();\n        }\n        \n        return maxLen;\n    }\n}",
    "submit_ts": "1717862040",
    "subm_id": "1281810093"
}