{
    "username": "LoHhhha",
    "submission": "class Segment {\n    int q(int x, int y, int l, int r, int ptr) {\n        if (x <= l && r <= y) {\n            return Tree[ptr];\n        }\n        else if (x > r || y < l) {\n            return INT_MIN;\n        }\n        int mid = (l + r) / 2;\n        return max(q(x, y, l, mid, ptr << 1 | 1), q(x, y, mid + 1, r, (ptr << 1) + 2));\n    }\n\n    void build(int l, int r, int ptr) {\n        if (l == r) {\n            Tree[ptr] = -1;\n            return;\n        }\n        int mid = (l + r) / 2;\n        build(l, mid, ptr << 1 | 1);\n        build(mid + 1, r, (ptr << 1) + 2);\n        Tree[ptr] = max(Tree[ptr << 1 | 1], Tree[(ptr << 1) + 2]);\n    }\n\n    void _update(int place, int val, int l, int r, int ptr) {\n        int mid = (l + r) / 2;\n        if (l == r) {\n            Tree[ptr] = val;\n            return;\n        }\n        if (place <= mid) {\n            _update(place, val, l, mid, ptr << 1 | 1);\n        }\n        else {\n            _update(place, val, mid + 1, r, (ptr << 1) + 2);\n        }\n        Tree[ptr] = max(Tree[ptr << 1 | 1], Tree[(ptr << 1) + 2]);\n    }\n\npublic:\n    int n;\n    vector<int>Tree;\n\n    Segment(int n) {\n        this->n=n;\n        Tree.resize(4 * n);\n        build(0, n - 1, 0);\n    }\n\n    void update(int place, int val) {\n        _update(place, val, 0, n - 1, 0);\n    }\n\n    int query(int l, int r) {\n        return q(l, r, 0, n - 1, 0);\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int n=queries.size();\n        vector<bool>res;\n        set<int>idxs;\n        Segment seg(min(50001, 3*n+1));\n        for(auto &q:queries){\n            if(q[0]==1){\n                auto it=idxs.lower_bound(q[1]);\n                if(it!=idxs.begin()){\n                    it--;\n                    seg.update(q[1],q[1]-(*it));\n                }\n                else{\n                    seg.update(q[1],q[1]);\n                }\n                it=idxs.upper_bound(q[1]);\n                if(it!=idxs.end()){\n                    seg.update(*it,(*it)-q[1]);\n                }\n                idxs.insert(q[1]);\n            }\n            else{\n                auto it=idxs.lower_bound(q[1]);\n                if(it==idxs.begin()){\n                    res.push_back(q[1]>=q[2]);\n                    continue;\n                }\n                it--;\n                int mx=seg.query(0,*it);\n                res.push_back(max(q[1]-(*it),mx)>=q[2]);\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1716652018.0
}