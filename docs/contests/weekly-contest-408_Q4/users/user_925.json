{
    "username": "YanlinGong",
    "submission": "class UnionFind():\n    def __init__ (self,n):\n        self.parent = {}\n        self.count = 0\n        self.rank = [0 for _ in range(n)]\n    def find(self,x):\n        if self.parent[x] == x:\n            return x\n        self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self,x,y): \n        rootx = self.find(x)\n        rooty = self.find(y)\n        if rootx != rooty:\n            if self.rank[rootx] > self.rank[rooty]:\n                self.parent[rooty] = rootx\n            elif self.rank[rootx] < self.rank[rooty]:\n                self.parent[rootx] = rooty\n            else:\n                self.parent[rooty] = rootx ##can chooce either, but need to add 1 level to the height for the root selected.\n                self.rank[rootx] += 1\n            self.count -= 1\n\n\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        \n        n = len(circles)\n        uf = UnionFind(n)\n        for i in range(n):\n            uf.parent[i] = i\n            uf.count += 1\n        dis = [[0 for _ in range(n)] for _ in range(n)]\n        import math\n        for i in range(n):\n            for j in range(i+1,n):\n                dis[i][j] = math.pow((circles[i][0] - circles[j][0]), 2) + math.pow((circles[i][1] - circles[j][1]),2)\n                if dis[i][j] <= math.pow((circles[i][2] + circles[j][2]), 2):\n                    uf.union(i,j)\n        tmp = collections.defaultdict(list);\n        for i in range(n):\n            tmp[uf.find(i)].append(i)\n        \n        for i in tmp:\n            curxmin, curymin = float('inf'), float('inf')\n            curxmax, curymax = float('-inf'), float('-inf')\n            for j in tmp[i]:\n                r = circles[j][2] \n                curxmin = min(curxmin, circles[j][0] - r)\n                curymin = min(curymin, circles[j][1] - r)\n                curxmax = max(curxmax, circles[j][0] + r)\n                curymax = max(curymax, circles[j][1] + r)\n            if curxmin >= X or curymin >= Y:\n                continue\n            if curxmax <= 0 or curymax <= 0:\n                continue\n            if curxmax >= X and curymax >= Y:\n                return False\n            if curxmin <= 0 and curymin <= 0:\n                return False\n            if (curxmin <= 0 and curxmax >= X) or (curymin <= 0 and curymax >= Y):\n                return False\n        return True\n\n        ",
    "submit_ts": "1722138389",
    "subm_id": "1335789504"
}