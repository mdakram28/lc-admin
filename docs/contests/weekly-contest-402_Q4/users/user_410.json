{
    "username": "ItzWho",
    "submission": "class Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<bool> isPeakArray(n, false);\n        vector<int> result;\n        auto isPeak = [&](int i) {\n            if (i <= 0 || i >= n - 1) return false;\n            return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n        };\n        \n        // Initial peak calculation\n        for (int i = 1; i < n - 1; ++i) {\n            if (isPeak(i)) {\n                isPeakArray[i] = true;\n            }\n        }\n\n        SegmentTree segTree(n);\n        for (int i = 1; i < n - 1; ++i) {\n            if (isPeakArray[i]) {\n                segTree.update(i, 1);\n            }\n        }\n\n        for (const auto& query : queries) {\n            if (query[0] == 1) { \n                int li = query[1];\n                int ri = query[2];\n                if (li >= ri - 1) {\n                    result.push_back(0);\n                } else {\n                    result.push_back(segTree.query(li + 1, ri - 1));\n                }\n            } else if (query[0] == 2) {\n                int index = query[1];\n                int newVal = query[2];\n\n                // Update the element\n                nums[index] = newVal;\n\n                for (int i = max(1, index - 1); i <= min(n - 2, index + 1); ++i) {\n                    bool wasPeak = isPeakArray[i];\n                    isPeakArray[i] = isPeak(i);\n\n                    if (wasPeak && !isPeakArray[i]) {\n                        segTree.update(i, -1);\n                    } else if (!wasPeak && isPeakArray[i]) {\n                        segTree.update(i, 1);\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\nprivate:\n    class SegmentTree {\n    public:\n        SegmentTree(int size) : n(size) {\n            tree.resize(4 * n, 0);\n        }\n\n        void update(int idx, int value) {\n            updateUtil(0, 0, n - 1, idx, value);\n        }\n\n        int query(int l, int r) {\n            return queryUtil(0, 0, n - 1, l, r);\n        }\n\n    private:\n        vector<int> tree;\n        int n;\n\n        void updateUtil(int node, int start, int end, int idx, int value) {\n            if (start == end) {\n                tree[node] += value;\n            } else {\n                int mid = (start + end) / 2;\n                if (idx <= mid) {\n                    updateUtil(2 * node + 1, start, mid, idx, value);\n                } else {\n                    updateUtil(2 * node + 2, mid + 1, end, idx, value);\n                }\n                tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n            }\n        }\n\n        int queryUtil(int node, int start, int end, int l, int r) {\n            if (r < start || l > end) {\n                return 0;\n            }\n            if (l <= start && r >= end) {\n                return tree[node];\n            }\n            int mid = (start + end) / 2;\n            int leftQuery = queryUtil(2 * node + 1, start, mid, l, r);\n            int rightQuery = queryUtil(2 * node + 2, mid + 1, end, l, r);\n            return leftQuery + rightQuery;\n        }\n    };\n};\n",
    "submit_ts": "1718506876",
    "subm_id": "1289633832"
}