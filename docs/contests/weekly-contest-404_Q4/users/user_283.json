{
    "username": "theabbie",
    "submission": "from collections import *\n\nclass Solution:\n    def BFS(self, graph, i):\n        q = deque([(i, 0)])\n        dist = {}\n        dist[i] = 0\n        while len(q) > 0:\n            curr, d = q.pop()\n            for j in graph[curr]:\n                if dist.get(j, float('inf')) > d + 1:\n                    dist[j] = d + 1\n                    q.appendleft((j, d + 1))\n        res = max(dist.keys(), key = lambda i: dist[i])\n        return (res, dist)\n    \n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        m = len(edges1) + 1\n        n = len(edges2) + 1\n        g1 = [[] for _ in range(m)]\n        g2 = [[] for _ in range(n)]\n        for u, v in edges1:\n            g1[u].append(v)\n            g1[v].append(u)\n        for u, v in edges2:\n            g2[u].append(v)\n            g2[v].append(u)\n        fx, fdx = self.BFS(g1, 0)\n        fy, fdy = self.BFS(g1, fx)\n        fz, fdz = self.BFS(g1, fy)\n        sx, sdx = self.BFS(g2, 0)\n        sy, sdy = self.BFS(g2, sx)\n        sz, sdz = self.BFS(g2, sy)\n        fdiameter = sdiameter = 0\n        for i in range(m):\n            fdiameter = max(fdiameter, fdy[i], fdz[i])\n        for i in range(n):\n            sdiameter = max(sdiameter, sdy[i], sdz[i])\n        res = float('inf')\n        sdist = float('inf')\n        for j in range(n):\n            sdist = min(sdist, max(sdy[j], sdz[j]))\n        for i in range(m):\n            res = min(res, max(fdy[i], fdz[i]) + 1 + sdist)\n        res = max(res, fdiameter, sdiameter)\n        return res",
    "submit_ts": "1719716478",
    "subm_id": "1304365583"
}