{
    "username": "ernestlu",
    "submission": "using ll = long long;\nconst ll MOD = 1e9 + 7;\nstruct mint {\n  int x;\n  mint() : x(0) {}\n  template <class T> mint(T value) : x(value % MOD) {\n    if (x < 0)\n      x += MOD;\n  }\n  mint &operator+=(const mint &oth) {\n    x += oth.x;\n    if (x >= MOD)\n      x -= MOD;\n    return *this;\n  }\n  mint &operator-=(const mint &oth) {\n    x -= oth.x;\n    if (x < 0)\n      x += MOD;\n    return *this;\n  }\n  mint &operator*=(const mint &oth) {\n    x = (long long)x * oth.x % MOD;\n    return *this;\n  }\n  friend mint operator+(mint l, const mint &r) { return l += r; }\n  friend mint operator-(mint l, const mint &r) { return l -= r; }\n  friend mint operator*(mint l, const mint &r) { return l *= r; }\n  mint &operator--() {\n    if (--x == -1)\n      x = MOD - 1;\n    return *this;\n  }\n  mint &operator++() {\n    if (++x == MOD)\n      x = 0;\n    return *this;\n  }\n  mint operator--(int) {\n    mint temp = *this;\n    --*this;\n    return temp;\n  }\n  mint operator++(int) {\n    mint temp = *this;\n    ++*this;\n    return temp;\n  }\n  mint operator-() const { return 0 - *this; }\n  mint operator+() const { return *this; }\n  friend bool operator==(const mint &l, const mint &r) { return l.x == r.x; }\n  friend bool operator!=(const mint &l, const mint &r) { return l.x != r.x; }\n  friend ostream &operator<<(ostream &out, const mint &a) { return out << a.x; }\n  mint pow(long long e = MOD - 2) const {\n    mint ans = 1, b = *this;\n    while (e > 0) {\n      if (e % 2 == 1) {\n        ans *= b;\n      }\n      b *= b;\n      e /= 2;\n    }\n    return ans;\n  }\n};\n\nclass Solution {\npublic:\n    const int B = 1001;\nint countOfPairs(vector<int> &nums) {\n  vector<mint> dp(B + 1);\n  dp[0] = 1;\n  int pnum = B + 1;\n  for (auto u : nums) {\n    vector<mint> new_dp(B + 1, 0);\n\n    vector<mint> pdp = dp;\n    for (int i = 1; i <= B; i++)\n      pdp[i] += pdp[i - 1];\n\n    auto range_q = [&](int l, int r) {\n      if (l > r)\n        return mint(0);\n      return pdp[min(r, (int)pdp.size() - 1)] - (l <= 0 ? 0 : pdp[l - 1]);\n    };\n\n    for (int nval = 0; nval <= u; nval++) {\n      int noval = u - nval;\n\n      // pnum - pval >= num - nval\n      // pnum + nval >= num + pval\n      // pval <= pnum + nval - num\n\n      int pval_up = nval;\n      int pval_hi = pnum + nval - u;\n      new_dp[nval] = range_q(0, min(pval_up, pval_hi));\n    }\n\n    // for (int pval = 0; pval <= B; pval++) {\n    //   if (dp[pval] == 0)\n    //     continue;\n    //   int poval = pnum - pval;\n    //   for (int nval = pval; nval <= u; nval++) {\n    //     int noval = u - nval;\n    //     if (noval > poval)\n    //       continue;\n    //     new_dp[nval] += dp[pval];\n    //   }\n    // }\n    pnum = u;\n    swap(dp, new_dp);\n  }\n\n  return accumulate(dp.begin(), dp.end(), mint(0)).x;\n}\n\n};",
    "submit_ts": "1723344340",
    "subm_id": "1351532191"
}