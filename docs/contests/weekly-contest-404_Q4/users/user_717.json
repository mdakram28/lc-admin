{
    "username": "imaheshno1",
    "submission": "#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        \n        auto diameter = [](const vector<vector<int>>& edges, int nodes) -> int {\n            vector<vector<int>> adj(nodes);\n            for (const auto& edge : edges) {\n                adj[edge[0]].push_back(edge[1]);\n                adj[edge[1]].push_back(edge[0]);\n            }\n            \n            auto bfs = [&](int start) -> pair<int, int> {\n                vector<int> dist(nodes, -1);\n                queue<int> q;\n                q.push(start);\n                dist[start] = 0;\n                int farthest_node = start, max_dist = 0;\n                \n                while (!q.empty()) {\n                    int node = q.front();\n                    q.pop();\n                    \n                    for (int neighbor : adj[node]) {\n                        if (dist[neighbor] == -1) {\n                            dist[neighbor] = dist[node] + 1;\n                            q.push(neighbor);\n                            if (dist[neighbor] > max_dist) {\n                                max_dist = dist[neighbor];\n                                farthest_node = neighbor;\n                            }\n                        }\n                    }\n                }\n                \n                return {farthest_node, max_dist};\n            };\n            \n            pair<int, int> p1 = bfs(0);\n            pair<int, int> p2 = bfs(p1.first);\n            return p2.second;\n        };\n        \n        int d1 = diameter(edges1, n);\n        int d2 = diameter(edges2, m);\n        \n        return max({d1, d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1});\n    }\n};\n",
    "submit_ts": 1719717152.0
}