{
    "username": "STARs_56789",
    "submission": "#ifndef LOCAL\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\n\nnamespace mitsuha{\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &A) {\n    os << A.first << \" \" << A.second;\n    return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &A) {\n    for (size_t i = 0; i < A.size(); i++) {\n        if (i) os << \" \";\n        os << A[i];\n    }\n    return os;\n}\n\nvoid print() {\n    std::cout << \"\\n\";\n    std::cout.flush();\n}\n\ntemplate <class Head, class... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n    std::cout << head;\n    if (sizeof...(Tail)) std::cout << \" \";\n    print(std::forward<Tail>(tail)...);\n}\n}\n\nnamespace mitsuha {\ntemplate <class T> bool chmin(T& x, const T& y) { \n    return y >= x ? false : (x = y, true); \n}\ntemplate <class T> bool chmax(T& x, const T& y) { \n    return y <= x ? false : (x = y, true); \n}\ntemplate <class T> constexpr T fld(const T x, const T y) { \n    T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); \n}\ntemplate <class T> constexpr T cld(const T x, const T y) { \n    T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); \n}\ntemplate <class T> constexpr T rem(const T x, const T y) { \n    return x - y * fld(x, y); \n}\ntemplate <class Iterable> void settify(Iterable& a) { \n    std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); \n}\ntemplate <size_t D> struct Dim : std::array<int, D> {\n    template <typename ...Ints> Dim(const Ints& ...ns) : \n        std::array<int, D>::array{ static_cast<int>(ns)... } {}\n};\ntemplate <typename ...Ints> Dim(const Ints& ...) -> Dim<sizeof...(Ints)>;\ntemplate <class T, size_t D, size_t I = 0>\nauto ndvec(const Dim<D> &ns, const T& value = {}) {\n    if constexpr (I + 1 < D) {\n        return std::vector(ns[I], ndvec<T, D, I + 1>(ns, value));\n    } else {\n        return std::vector<T>(ns[I], value);\n    }\n}\n}\n\nnamespace mitsuha {\nusing str = std::string;\nusing int128 = __int128;\nusing uint128 = unsigned __int128;\ntemplate <class T> using min_priority_queue \n                            = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T> using max_priority_queue \n                            = std::priority_queue<T, std::vector<T>, std::less<T>>;\n}\nnamespace mitsuha { \n    const std::vector<std::string> Yes = {\"No\", \"Yes\"};\n    const std::vector<std::string> YES = {\"NO\", \"YES\"};\n}\n \n#ifndef __COUNTER__\n#define __COUNTER__ __LINE__\n#endif\n\n#define TL (long long)\n \n#define OVERLOAD5(a, b, c, d, e, ...) e\n#define REP1_0(b, c) REP1_1(b, c)\n#define REP1_1(b, c) for (long long REP_COUNTER_##c = 0; REP_COUNTER_##c < TL(b); ++REP_COUNTER_##c)\n#define REP1(b) REP1_0(b, __COUNTER__)\n#define REP2(i, b) for (long long i = 0; i < TL(b); ++i)\n#define REP3(i, a, b) for (long long i = TL(a); i < TL(b); ++i)\n#define REP4(i, a, b, c) for (long long i = TL(a); i < TL(b); i += TL(c))\n#define For(...) OVERLOAD5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)\n#define RREP2(i, a) for (long long i = TL(a)-1; i >= 0; --i)\n#define RREP3(i, a, b) for (long long i = TL(b)-1; i >= TL(a); --i)\n#define RREP4(i, a, b, c) for (long long i = TL(b)-1; i >= TL(a); i -= TL(c))\n#define Frr(...) OVERLOAD5(__VA_ARGS__, RREP4, RREP3, RREP2)(__VA_ARGS__)\n\n#define All(iterable) std::begin(iterable), std::end(iterable)\n#define len(iterable) TL iterable.size()\n#define elif else if\n\n#define KBIT(a, k) (a & (1ULL << k))\n\n#define Assert(x) void(0);\n\nusing namespace mitsuha;\nusing namespace std;\n \nconstexpr int iinf = std::numeric_limits<int>::max() / 2;\nconstexpr long long linf = std::numeric_limits<long long>::max() / 2;\n\nnamespace mitsuha{\nstruct has_mod_impl {\n    template <class T>\n    static auto check(T &&x) -> decltype(x.get_mod(), std::true_type{});\n    template <class T>\n    static auto check(...) -> std::false_type;\n};\n\ntemplate <class T>\nclass has_mod : public decltype(has_mod_impl::check<T>(std::declval<T>())) {};\n\ntemplate <typename mint>\nmint inv(int n) {\n    static const int mod = mint::get_mod();\n    static vector<mint> dat = {0, 1};\n    assert(0 <= n);\n    if (n >= mod) n %= mod;\n    while (len(dat) <= n) {\n        int k = len(dat);\n        int q = (mod + k - 1) / k;\n        dat.emplace_back(dat[k * q - mod] * mint::raw(q));\n    }\n    return dat[n];\n}\n\ntemplate <typename mint>\nmint fact(int n) {\n    static const int mod = mint::get_mod();\n    assert(0 <= n && n < mod);\n    static vector<mint> dat = {1, 1};\n    while (len(dat) <= n) dat.emplace_back(dat[len(dat) - 1] * mint::raw(len(dat)));\n    return dat[n];\n}\n\ntemplate <typename mint>\nmint fact_inv(int n) {\n    static vector<mint> dat = {1, 1};\n    if (n < 0) return mint(0);\n    while (len(dat) <= n) dat.emplace_back(dat[len(dat) - 1] * inv<mint>(len(dat)));\n    return dat[n];\n}\n\ntemplate <class mint, class... Ts>\nmint fact_invs(Ts... xs) {\n    return (mint(1) * ... * fact_inv<mint>(xs));\n}\n\ntemplate <typename mint, class Head, class... Tail>\nmint multinomial(Head &&head, Tail &&... tail) {\n    return fact<mint>(head) * fact_invs<mint>(std::forward<Tail>(tail)...);\n}\n\ntemplate <typename mint>\nmint C_dense(int n, int k) {\n    static vector<vector<mint>> C;\n    static int H = 0, W = 0;\n    auto calc = [&](int i, int j) -> mint {\n        if (i == 0) return (j == 0 ? mint(1) : mint(0));\n        return C[i - 1][j] + (j ? C[i - 1][j - 1] : 0);\n    };\n    if (W <= k) {\n        for(int i = 0; i < H; ++i) {\n            C[i].resize(k + 1);\n            for(int j = W; j < k + 1; ++j) { C[i][j] = calc(i, j); }\n        }\n        W = k + 1;\n    }\n    if (H <= n) {\n        C.resize(n + 1);\n        for(int i = H; i < n + 1; ++i) {\n            C[i].resize(W);\n            for(int j = 0; j < W; ++j) { C[i][j] = calc(i, j); }\n        }\n        H = n + 1;\n    }\n    return C[n][k];\n}\n\ntemplate <typename mint, bool large = false, bool dense = false>\nmint C(long long n, long long k) {\n    assert(n >= 0);\n    if (k < 0 || n < k) return 0;\n    if constexpr (dense) return C_dense<mint>(n, k);\n    if constexpr (!large) return multinomial<mint>(n, k, n - k);\n    k = min(k, n - k);\n    mint x(1);\n    for(int i = 0; i < k; ++i) x *= mint(n - i);\n    return x * fact_inv<mint>(k);\n}\n\ntemplate <typename mint, bool large = false>\nmint C_inv(long long n, long long k) {\n    assert(n >= 0);\n    assert(0 <= k && k <= n);\n    if (not large) return fact_inv<mint>(n) * fact<mint>(k) * fact<mint>(n - k);\n    return mint(1) / C<mint, true>(n, k);\n}\n\n// [x^d](1-x)^{-n}\ntemplate <typename mint, bool large = false, bool dense = false>\nmint C_negative(long long n, long long d) {\n    assert(n >= 0);\n    if (d < 0) return mint(0);\n    if (n == 0) { return (d == 0 ? mint(1) : mint(0)); }\n    return C<mint, large, dense>(n + d - 1, d);\n}\n} // namespace mitsuha\n\nnamespace mitsuha{\ntemplate <int mod>\nstruct modint {\n    static constexpr unsigned int umod = (unsigned int)(mod);\n    static_assert(umod < 1U << 31);\n    unsigned int val;\n\n    static modint raw(unsigned int v) {\n        modint x;\n        x.val = v;\n        return x;\n    }\n    constexpr modint() : val(0) {}\n    constexpr modint(unsigned int x) : val(x % umod) {}\n    constexpr modint(unsigned long long x) : val(x % umod) {}\n    constexpr modint(unsigned __int128 x) : val(x % umod) {}\n    constexpr modint(int x) : val((x %= mod) < 0 ? x + mod : x){};\n    constexpr modint(long long x) : val((x %= mod) < 0 ? x + mod : x){};\n    constexpr modint(__int128 x) : val((x %= mod) < 0 ? x + mod : x){};\n    bool operator<(const modint &other) const { return val < other.val; }\n    modint &operator+=(const modint &p) {\n        if ((val += p.val) >= umod) val -= umod;\n        return *this;\n    }\n    modint &operator-=(const modint &p) {\n        if ((val += umod - p.val) >= umod) val -= umod;\n        return *this;\n    }\n    modint &operator*=(const modint &p) {\n        val = (unsigned long long)(val) * p.val % umod;\n        return *this;\n    }\n    modint &operator/=(const modint &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n    modint operator-() const { return modint::raw(val ? mod - val : 0U); }\n    modint operator+(const modint &p) const { return modint(*this) += p; }\n    modint operator-(const modint &p) const { return modint(*this) -= p; }\n    modint operator*(const modint &p) const { return modint(*this) *= p; }\n    modint operator/(const modint &p) const { return modint(*this) /= p; }\n    bool operator==(const modint &p) const { return val == p.val; }\n    bool operator!=(const modint &p) const { return val != p.val; }\n    modint inverse() const {\n        int a = val, b = mod, u = 1, v = 0, t;\n        while (b > 0) {\n            t = a / b;\n            swap(a -= t * b, b), swap(u -= t * v, v);\n        }\n        return modint(u);\n    }\n    modint pow(long long n) const {\n        assert(n >= 0);\n        modint ret(1), mul(val);\n        while (n > 0) {\n            if (n & 1) ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    static constexpr int get_mod() { return mod; }\n   // (n, r), r is the 2^nth root of 1\n    static constexpr pair<int, int> ntt_info() {\n        if (mod == 120586241) return {20, 74066978};\n        if (mod == 167772161) return {25, 17};\n        if (mod == 469762049) return {26, 30};\n        if (mod == 754974721) return {24, 362};\n        if (mod == 880803841) return {23, 211};\n        if (mod == 943718401) return {22, 663003469};\n        if (mod == 998244353) return {23, 31};\n        if (mod == 1045430273) return {20, 363};\n        if (mod == 1051721729) return {20, 330};\n        if (mod == 1053818881) return {20, 2789};\n        return {-1, -1};\n    }\n    static constexpr bool can_ntt() { return ntt_info().first != -1; }\n};\n\n#ifdef FASTIO\ntemplate<int _mod>  \nvoid rd(modint<_mod> &number){\n    long long v; io::rd(v);\n    v %= _mod;\n    if (v < 0) {\n        v += _mod;\n    }\n    number.val = v;\n}\ntemplate<int _mod>\nvoid wt(const modint<_mod> &number){\n    io::wt(number.val);\n}\n#endif\n\ntemplate<int _mod>\nostream &operator<<(ostream &out, const modint<_mod> &number){ return out << number.val; }\n\nusing modint107 = modint<1000000007>;\nusing modint998 = modint<998244353>;\n} // namespace mitsuha\n\nusing mint = modint107;\n\ntemplate<class T>\nstruct range_add_range_sum_query_solver{\n\tint n;\n\tvector<T> data0, data1;\n\trange_add_range_sum_query_solver(){ }\n\t// O(n)\n\trange_add_range_sum_query_solver(int n): n(n), data0(n), data1(n){ }\n\t// O(n)\n\trange_add_range_sum_query_solver(int n, T init): range_add_range_sum_query_solver(vector<T>(n, init)){ }\n\t// O(n)\n\trange_add_range_sum_query_solver(const vector<T> &v): n((int)v.size()), data0(n), data1(v){\n\t\tfor(auto i = 1; i <= n; ++ i) if(i + (i & -i) <= n) data1[i + (i & -i) - 1] += data1[i - 1];\n\t}\n\tvoid update(int ql, int qr, T x){\n\t\tassert(0 <= ql && ql <= qr && qr <= n);\n\t\tif(ql == qr) return;\n\t\tfor(auto l = ql + 1; l <= n; l += l & -l) data0[l - 1] += x, data1[l - 1] -= ql * x;\n\t\tfor(auto r = qr + 1; r <= n; r += r & -r) data0[r - 1] -= x, data1[r - 1] += qr * x;\n\t}\n\tT pref(int qr) const{\n\t\tassert(0 <= qr && qr <= n);\n\t\tT sum0 = {}, sum1 = {};\n\t\tfor(auto r = qr; r > 0; r -= r & -r) sum0 += data0[r - 1], sum1 += data1[r - 1];\n\t\treturn qr * sum0 + sum1;\n\t}\n\tT query(int l, int r) const{\n\t\tassert(0 <= l && l <= r && r <= n);\n\t\treturn pref(r) - pref(l);\n\t}\n\ttemplate<class output_stream>\n\tfriend output_stream &operator<<(output_stream &out, const range_add_range_sum_query_solver<T> &solver){\n\t\tout << \"[\";\n\t\tfor(auto i = 0; i < solver.n; ++ i){\n\t\t\tout << solver.query(i, i + 1);\n\t\t\tif(i != solver.n - 1) out << \", \";\n\t\t}\n\t\treturn out << ']';\n\t}\n};\n\nusing uint = unsigned int;\ntemplate<uint _mod>\nstruct modular_fixed_base{\n    static constexpr uint mod(){\n        return _mod;\n    }\n    template<class T>\n    static vector<modular_fixed_base> precalc_power(T base, int SZ){\n        vector<modular_fixed_base> res(SZ + 1, 1);\n        for(auto i = 1; i <= SZ; ++ i) res[i] = res[i - 1] * base;\n        return res;\n    }\n    static vector<modular_fixed_base> _INV;\n    static void precalc_inverse(int SZ){\n        if(_INV.empty()) _INV.assign(2, 1);\n        for(auto x = _INV.size(); x <= SZ; ++ x) _INV.push_back(_mod / x * -_INV[_mod % x]);\n    }\n    // _mod must be a prime\n    static modular_fixed_base _primitive_root;\n    static modular_fixed_base primitive_root(){\n        if(_primitive_root) return _primitive_root;\n        if(_mod == 2) return _primitive_root = 1;\n        if(_mod == 998244353) return _primitive_root = 3;\n        uint divs[20] = {};\n        divs[0] = 2;\n        int cnt = 1;\n        uint x = (_mod - 1) / 2;\n        while(x % 2 == 0) x /= 2;\n        for(auto i = 3; 1LL * i * i <= x; i += 2){\n            if(x % i == 0){\n                divs[cnt ++] = i;\n                while(x % i == 0) x /= i;\n            }\n        }\n        if(x > 1) divs[cnt ++] = x;\n        for(auto g = 2; ; ++ g){\n            bool ok = true;\n            for(auto i = 0; i < cnt; ++ i){\n                if((modular_fixed_base(g).power((_mod - 1) / divs[i])) == 1){\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) return _primitive_root = g;\n        }\n    }\n    constexpr modular_fixed_base(): data(){ }\n    modular_fixed_base(const double &x){ data = normalize(llround(x)); }\n    modular_fixed_base(const long double &x){ data = normalize(llround(x)); }\n    template<class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base(const T &x){ data = normalize(x); }\n    template<class T, typename enable_if<is_integral<T>::value>::type* = nullptr> static uint normalize(const T &x){\n        int sign = x >= 0 ? 1 : -1;\n        uint v =  _mod <= sign * x ? sign * x % _mod : sign * x;\n        if(sign == -1 && v) v = _mod - v;\n        return v;\n    }\n    const uint &operator()() const{ return data; }\n    template<class T> operator T() const{ return data; }\n    modular_fixed_base &operator+=(const modular_fixed_base &otr){ if((data += otr.data) >= _mod) data -= _mod; return *this; }\n    modular_fixed_base &operator-=(const modular_fixed_base &otr){ if((data += _mod - otr.data) >= _mod) data -= _mod; return *this; }\n    template<class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base &operator+=(const T &otr){ return *this += modular_fixed_base(otr); }\n    template<class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base &operator-=(const T &otr){ return *this -= modular_fixed_base(otr); }\n    modular_fixed_base &operator++(){ return *this += 1; }\n    modular_fixed_base &operator--(){ return *this += _mod - 1; }\n    modular_fixed_base operator++(int){ modular_fixed_base result(*this); *this += 1; return result; }\n    modular_fixed_base operator--(int){ modular_fixed_base result(*this); *this += _mod - 1; return result; }\n    modular_fixed_base operator-() const{ return modular_fixed_base(_mod - data); }\n    modular_fixed_base &operator*=(const modular_fixed_base &rhs){\n        data = (unsigned long long)data * rhs.data % _mod;\n        return *this;\n    }\n    template<class T, typename enable_if<is_integral<T>::value>::type* = nullptr>\n    modular_fixed_base &inplace_power(T e){\n        if(!data) return *this = {};\n        if(data == 1) return *this;\n        if(data == mod() - 1) return e % 2 ? *this : *this = -*this;\n        if(e < 0) *this = 1 / *this, e = -e;\n        modular_fixed_base res = 1;\n        for(; e; *this *= *this, e >>= 1) if(e & 1) res *= *this;\n        return *this = res;\n    }\n    template<class T, typename enable_if<is_integral<T>::value>::type* = nullptr>\n    modular_fixed_base power(T e) const{\n        return modular_fixed_base(*this).inplace_power(e);\n    }\n    modular_fixed_base &operator/=(const modular_fixed_base &otr){\n        int a = otr.data, m = _mod, u = 0, v = 1;\n        if(a < _INV.size()) return *this *= _INV[a];\n        while(a){\n            int t = m / a;\n            m -= t * a; swap(a, m);\n            u -= t * v; swap(u, v);\n        }\n        assert(m == 1);\n        return *this *= u;\n    }\n    uint data;\n};\ntemplate<uint _mod> vector<modular_fixed_base<_mod>> modular_fixed_base<_mod>::_INV;\ntemplate<uint _mod> modular_fixed_base<_mod> modular_fixed_base<_mod>::_primitive_root;\ntemplate<uint _mod> bool operator==(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return lhs.data == rhs.data; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> bool operator==(const modular_fixed_base<_mod> &lhs, T rhs){ return lhs == modular_fixed_base<_mod>(rhs); }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> bool operator==(T lhs, const modular_fixed_base<_mod> &rhs){ return modular_fixed_base<_mod>(lhs) == rhs; }\ntemplate<uint _mod> bool operator!=(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return !(lhs == rhs); }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> bool operator!=(const modular_fixed_base<_mod> &lhs, T rhs){ return !(lhs == rhs); }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> bool operator!=(T lhs, const modular_fixed_base<_mod> &rhs){ return !(lhs == rhs); }\ntemplate<uint _mod> bool operator<(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return lhs.data < rhs.data; }\ntemplate<uint _mod> bool operator>(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return lhs.data > rhs.data; }\ntemplate<uint _mod> bool operator<=(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return lhs.data <= rhs.data; }\ntemplate<uint _mod> bool operator>=(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return lhs.data >= rhs.data; }\ntemplate<uint _mod> modular_fixed_base<_mod> operator+(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return modular_fixed_base<_mod>(lhs) += rhs; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base<_mod> operator+(const modular_fixed_base<_mod> &lhs, T rhs){ return modular_fixed_base<_mod>(lhs) += rhs; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base<_mod> operator+(T lhs, const modular_fixed_base<_mod> &rhs){ return modular_fixed_base<_mod>(lhs) += rhs; }\ntemplate<uint _mod> modular_fixed_base<_mod> operator-(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return modular_fixed_base<_mod>(lhs) -= rhs; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base<_mod> operator-(const modular_fixed_base<_mod> &lhs, T rhs){ return modular_fixed_base<_mod>(lhs) -= rhs; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base<_mod> operator-(T lhs, const modular_fixed_base<_mod> &rhs){ return modular_fixed_base<_mod>(lhs) -= rhs; }\ntemplate<uint _mod> modular_fixed_base<_mod> operator*(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return modular_fixed_base<_mod>(lhs) *= rhs; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base<_mod> operator*(const modular_fixed_base<_mod> &lhs, T rhs){ return modular_fixed_base<_mod>(lhs) *= rhs; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base<_mod> operator*(T lhs, const modular_fixed_base<_mod> &rhs){ return modular_fixed_base<_mod>(lhs) *= rhs; }\ntemplate<uint _mod> modular_fixed_base<_mod> operator/(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs) { return modular_fixed_base<_mod>(lhs) /= rhs; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base<_mod> operator/(const modular_fixed_base<_mod> &lhs, T rhs) { return modular_fixed_base<_mod>(lhs) /= rhs; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base<_mod> operator/(T lhs, const modular_fixed_base<_mod> &rhs) { return modular_fixed_base<_mod>(lhs) /= rhs; }\ntemplate<uint _mod> istream &operator>>(istream &in, modular_fixed_base<_mod> &number){\n    long long x;\n    in >> x;\n    number.data = modular_fixed_base<_mod>::normalize(x);\n    return in;\n}\n// #define _SHOW_FRACTION\ntemplate<uint _mod> ostream &operator<<(ostream &out, const modular_fixed_base<_mod> &number){\n#if defined(LOCAL) && defined(_SHOW_FRACTION)\n    out << number();\n\tcerr << \"(\";\n\tfor(auto d = 1; ; ++ d){\n\t\tif((number * d).data <= 1000000){\n\t\t\tcerr << (number * d).data << \"/\" << d;\n\t\t\tbreak;\n\t\t}\n\t\telse if((-number * d).data <= 1000000){\n\t\t\tcerr << \"-\" << (-number * d).data << \"/\" << d;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcerr << \")\";\n\treturn out;\n#else\n    return out << number();\n#endif\n}\n#undef _SHOW_FRACTION\n\nconst uint mod = 1e9 + 7; // 1000000007\n// const uint mod = (119 << 23) + 1; // 998244353\n// const uint mod = 1e9 + 9; // 1000000009\n\nusing modular = modular_fixed_base<mod>;\n\nclass Solution {\npublic:\n    int countOfPairs(vector<int>& nums) {\n        range_add_range_sum_query_solver<modular> dp(1001, modular(0));\n        for(int i = 0; i < nums.size(); i++){\n            range_add_range_sum_query_solver<modular> ndp(1001, modular(0));\n            for(int j = 0; j <= nums[i]; j++){\n                if(i == 0){\n                    ndp.update(j, j + 1, 1);\n                    continue;\n                }\n                int prev = max(0, nums[i - 1] - nums[i] + j + 1);\n                prev = min(prev, j + 1);\n                ndp.update(j, j + 1, dp.query(0, prev));\n            }            \n            swap(dp, ndp);\n        }\n        return dp.query(0, 1001);\n    }\n};\n\n",
    "submit_ts": "1723345659",
    "subm_id": "1351560551"
}