{
    "username": "yash_116",
    "submission": "class Solution {\npublic:\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        vector<int> indegree(n,0);\n        vector<int>v,v2;\n        if(n<2){\n            for(int i=0;i<n;i++)v.push_back(i);\n            return v;\n        }\n        vector<vector<int>>v1;\n        v1.resize(n);\n        for(auto& i:edges){\n            v1[i[0]].push_back(i[1]);\n            v1[i[1]].push_back(i[0]);\n        }\n        for(int i = 0;i<n;i++) {\n\t        for(auto it: v1[i]) {\n\t            indegree[it]++; \n\t        }\n\t    }\n        for(int i=0;i<n;i++){\n            if(indegree[i]==1)\n                v.push_back(i);\n        }\n        while(n>2){\n            n-=v.size();\n            for(auto& i:v){\n                for(int j=0;j<v1[i].size();j++)\n                    if(--indegree[v1[i][j]]==1)v2.push_back(v1[i][j]);\n            }\n            v=v2;\n            v2.clear();\n        }\n        return v;\n\n    }\n    int dfs1(int n, vector<vector<int>>&adj1,vector<int>&vis1){\n        vis1[n]=1;\n        int p=0;\n        for(auto&j:adj1[n]){\n            if(!vis1[j]){\n                p=max(p,dfs1(j,adj1,vis1));  \n            }\n        }\n        return p+1;\n    }\n    int x;\n \nvoid dfsUtil(int node, int count, vector<int>&visited,\n                   int& maxCount, vector<vector<int>>&adj)\n{\n    visited[node] = true;\n    count++;\n    for (auto&i:adj[node]) {\n        if (!visited[i]) {\n            if (count >= maxCount) {\n                maxCount = count;\n                x = i;\n            }\n            dfsUtil(i, count, visited, maxCount, adj);\n        }\n    }\n}\n \n\nvoid dfs(int node, int n, vector<vector<int>>&adj, int& maxCount)\n{\n    vector<int>visited(n+1);\n    int count = 0;\n \n    for (int i = 1; i <= n; ++i)\n        visited[i] = false;\n \n    dfsUtil(node, count + 1, visited, maxCount, adj);\n}\n \n\nint diameter(vector<vector<int>>&adj, int n)\n{\n    int maxCount = INT_MIN;\n \n   \n    dfs(1, n, adj, maxCount);\n \n   \n    dfs(x, n, adj, maxCount);\n \n    return maxCount;\n}\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        // if(edges1.empty() && edges2.empty())return 0;\n        int n=edges1.size()+1;\n        vector<int>v1=findMinHeightTrees(n,edges1);\n        int m=edges2.size()+1;\n        vector<int>v2=findMinHeightTrees(m,edges2);\n        int i1=v1[0],i2=v2[0];\n        vector<vector<int>>adj1(n+1),adj2(m+1);\n        for(auto&i:edges1){\n            adj1[i[0]].push_back(i[1]);\n            adj1[i[1]].push_back(i[0]);\n        }\n        for(auto&i:edges2){\n            adj2[i[0]].push_back(i[1]);\n            adj2[i[1]].push_back(i[0]);\n        }\n        vector<int>vis1(n+1,0),vis2(m+1,0);\n        int d1=diameter(adj1,n);\n        int d2=diameter(adj2,m);\n       \n        if(d1<0 && d2<0)d1=0,d2=0;\n        else if(d1<0)d1=0;\n        else if(d2<0)d2=0;\n         d1--;d2--;\n        cout<<d1<<' '<<d2<<'\\n';\n        int res=0;\n        res=max(res,d1);\n        res=max(res,d2);\n        if(d1&1 && d2&1){\n            res=max(res,(d2+1)/2+(d1+1)/2+1);\n        }\n        else if(d1%2==0 && d2&1){\n            res=max(res,(d2+1)/2+(d1+1)/2+1);\n        }\n        else res=max(res,(d2+1)/2+(d1+1)/2+1);\n        return res;\n    }\n};",
    "submit_ts": "1719719057",
    "subm_id": "1304432717"
}