{
    "username": "FNUAmanraj",
    "submission": "from collections import deque\n\ndef breadthfirstsearch(tree, start):\n    queue = deque([start])\n    visited = {start}\n    dis = {start: 0}\n    most_distance = start\n    \n    while queue:\n        node = queue.popleft()\n        for adjacent_node in tree[node]:\n            if adjacent_node not in visited:\n                visited.add(adjacent_node)\n                dis[adjacent_node] = dis[node] + 1\n                queue.append(adjacent_node)\n                if dis[adjacent_node] > dis[most_distance]:\n                    most_distance = adjacent_node\n    \n    return most_distance, dis[most_distance]\n\ndef diameterOfTree(e, n):\n    if n == 1:\n        return 0\n    t = [[] for _ in range(n)]\n    for i, j in e:\n        t[i].append(j)\n        t[j].append(i)\n    \n    most_distance, _ = breadthfirstsearch(t, 0)\n    _, diameter = breadthfirstsearch(t, most_distance)\n    return diameter\n\nclass Solution(object):\n    def minimumDiameterAfterMerge(self, edges1, edges2):\n        len1 = len(edges1) + 1\n        len2 = len(edges2) + 1\n        \n        dia1= diameterOfTree(edges1, len1)\n        dia2= diameterOfTree(edges2, len2)\n        \n        return max((dia1 + 1)//2+(dia2 + 1)//2+1,dia1,dia2)\n\n\n",
    "submit_ts": "1719718158",
    "subm_id": "1304410193"
}