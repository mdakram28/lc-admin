{
    "username": "yangxm",
    "submission": "#define X first\n#define Y second\n\nusing Psi = pair<string, int>;\n\nconstexpr int MAXN = 50010;\nconstexpr int MAXC = 26;\nconstexpr int INF = 0x3F3F3F3F;\n\ntemplate <typename T, typename HashFunc>\nstruct ACAutomaton {\n  struct Node {\n    int nxt[MAXC], fail, acc;\n    Node() : fail(-1), acc(-1) { memset(nxt, -1, sizeof(nxt)); }\n  } q[MAXN];\n\n  int que[MAXN], front, rear, sz = 1;\n  HashFunc chidx;\n\n  Node& operator[](int k) { return q[k]; }\n\n  int size() const { return sz; }\n\n  void clear() {\n    fill(q, q + sz, Node());\n    sz = 1;\n  }\n\n  void insert(const T* str, int n, int k) {\n    int x = 0, i;\n    for (i = 0; i < n; ++i) {\n      if (q[x].nxt[chidx(str[i])] == -1) q[x].nxt[chidx(str[i])] = sz++;\n      x = q[x].nxt[chidx(str[i])];\n    }\n    q[x].acc = k;\n  }\n\n  void build() {\n    int x, y, i;\n    front = rear = 0;\n    for (que[rear++] = 0; front < rear;) {\n      for (x = que[front++], i = 0; i < MAXC; ++i) {\n        if ((y = q[x].nxt[i]) == -1)\n          q[x].nxt[i] = x ? q[q[x].fail].nxt[i] : 0;\n        else {\n          q[y].fail = x ? q[q[x].fail].nxt[i] : 0;\n          // q[y].acc |= q[q[y].fail].acc;\n          que[rear++] = y;\n        }\n      }\n    }\n  }\n};\n\nstruct HashFunc {\n  int operator()(char ch) const { return ch - 'a'; }\n};\n\nACAutomaton<char, HashFunc> ac;\n\nint dp[MAXN];\nPsi s[MAXN];\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n      ac.clear();\n      int m = words.size();\n      for (int i = 0; i < m; ++i) {\n        s[i] = make_pair(words[i], costs[i]);\n      }\n      sort(s, s + m);\n      ac.insert(s[0].X.c_str(), s[0].X.length(), 0);\n      for (int i = 1; i < m; ++i) {\n        if (s[i].X != s[i - 1].X) {\n          ac.insert(s[i].X.c_str(), s[i].X.length(), i);\n        }\n      }\n      ac.build();\n      int n = target.length();\n      fill(dp, dp + n + 1, INF);\n      dp[0] = 0;\n      int x = 0;\n      for (int i = 1; i <= n; ++i) {\n        int d = target[i - 1] - 'a';\n        x = ac[x].nxt[d];\n        for (int y = x; y > 0; y = ac[y].fail) {\n          if (ac[y].acc != -1) {\n            int j = ac[y].acc;\n            dp[i] = min(dp[i], dp[i - s[j].X.length()] + s[j].Y);\n          }\n        }\n      }\n      return dp[n] < INF ? dp[n] : -1;\n    }\n};",
    "submit_ts": "1720321150",
    "subm_id": "1312314892"
}