{
    "username": "Kitetsu",
    "submission": "import java.util.*;\n\nclass Solution {\n    public List<Boolean> getResults(int[][] queries) {\n        SegmentTree segmentTree = new SegmentTree();\n        return segmentTree.processQueries(queries);\n    }\n}\n\nclass SegmentTree {\n    private long[] segT;\n\n    public List<Boolean> processQueries(int[][] queries) {\n        segT = new long[5 * 100000]; // Assuming the maximum value as 100000\n        List<Boolean> results = new ArrayList<>();\n        TreeSet<Integer> set = new TreeSet<>();\n        set.add(0);\n        set.add(100000);\n        HashMap<Integer, Integer> map = new HashMap<>();\n        map.put(0, 0);\n        map.put(100000, 100000);\n\n        for (int[] query : queries) {\n            if (query[0] == 1) {\n                int position = query[1];\n                set.add(position);\n                int prev = set.lower(position);\n                int next = set.higher(position);\n                map.put(next, next - position);\n                map.put(position, position - prev);\n                update(0, 100000, 0, position, map.get(position));\n                update(0, 100000, 0, next, map.get(next));\n            } else {\n                int position = query[1];\n                int prev = set.lower(position);\n                if (position - prev >= query[2]) {\n                    results.add(true);\n                    continue;\n                } else if (range(0, 100000, 0, 0, position) >= query[2]) {\n                    results.add(true);\n                    continue;\n                }\n                results.add(false);\n            }\n        }\n        return results;\n    }\n\n    private void build(int s, int e, int i, long[] a) {\n        if (s == e) {\n            segT[i] = a[s];\n            return;\n        }\n        int mid = s + (e - s) / 2;\n        build(s, mid, 2 * i + 1, a);\n        build(mid + 1, e, 2 * i + 2, a);\n        segT[i] = Math.max(segT[2 * i + 1], segT[2 * i + 2]);\n    }\n\n    private void update(int s, int e, int i, int q, long v) {\n        if (s == e) {\n            segT[i] = v;\n            return;\n        }\n        int mid = s + (e - s) / 2;\n        if (q <= mid)\n            update(s, mid, 2 * i + 1, q, v);\n        else\n            update(mid + 1, e, 2 * i + 2, q, v);\n        segT[i] = Math.max(segT[2 * i + 1], segT[2 * i + 2]);\n    }\n\n    private long range(int s, int e, int i, int qs, int qe) {\n        if (qs <= s && qe >= e)\n            return segT[i];\n        if (qs > e || qe < s)\n            return Long.MIN_VALUE;\n        int mid = s + (e - s) / 2;\n        long l = range(s, mid, 2 * i + 1, qs, qe);\n        long r = range(mid + 1, e, 2 * i + 2, qs, qe);\n        return Math.max(l, r);\n    }\n}\n",
    "submit_ts": 1716652719.0
}