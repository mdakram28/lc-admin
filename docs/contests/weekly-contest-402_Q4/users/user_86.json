{
    "username": "ASAPIN",
    "submission": "#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<bitset>\n#include<functional>\n#include<chrono>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cassert>\n#include<cmath>\n#include<iomanip>\n#include<random>\n#include<ctime>\n#include<complex>\n#include<type_traits>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef long long LL;\ntypedef double D;\n#define all(v) (v).begin(), (v).end()\nmt19937 gene(chrono::system_clock::now().time_since_epoch().count());\ntypedef complex<double> Complex;\ntypedef pair<int, int> pii;\n#define fi first\n#define se second\n#define ins insert\n#define pb push_back\ninline char GET_CHAR(){\n    const int maxn = 131072;\n    static char buf[maxn],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;\n}\ninline int getInt() {\n    int res(0);\n    char c = getchar();\n    while(c < '0') c = getchar();\n    while(c >= '0') {\n        res = res * 10 + (c - '0');\n        c = getchar();\n    }\n    return res;\n}\ninline LL fastpo(LL x, LL n, LL mod) {\n    LL res(1);\n    while(n) {\n        if(n & 1) {\n            res = res * (LL)x % mod;\n        }\n        x = x * (LL) x % mod;\n        n /= 2;\n    }\n    return res;\n}\ntemplate<LL mod> struct Num {\n\tLL a;\n\tNum operator + (const Num & b) { return Num{(a + b.a) % mod}; }\n\tNum operator - (const Num & b) { return Num{(a - b.a + mod) % mod}; }\n\tNum operator * (const Num & b) { return Num{a * b.a % mod}; }\n\tNum operator / (const Num & b) { return Num{a * fastpo(b.a, mod - 2, mod) % mod}; }\n\tvoid operator += (const Num & b) {if((a += b.a) >= mod) a -= mod;}\n\tvoid operator -= (const Num & b) {if((a -= b.a) < 0) a += mod;}\n\tvoid operator *= (const Num & b) { a = a * b.a % mod; }\n\tvoid operator /= (const Num & b) { a = a * fastpo(b.a, mod - 2, mod) % mod; }\n\tvoid operator = (const Num & b) { a = b.a; }\n\tvoid operator = (const LL & b) { a = b; }\n};\ntemplate<LL mod> ostream & operator << (ostream & os, const Num<mod> & a) {\n\tos << a.a;\n\treturn os;\n}\nLL gcd(LL a, LL b) { return b ? gcd(b, a % b) : a; }\n\ninline string itoa(LL x, int width = 0) {\n\tstring res;\n\tif(x == 0) res.push_back('0');\n\twhile(x) {\n\t\tres.push_back('0' + x % 10);\n\t\tx /= 10;\n\t}\n\twhile((int)res.size() < width) res.push_back('0');\n\treverse(res.begin(), res.end());\n\treturn res;\n}\nconst int _B = 131072;\nchar buf[_B];\nint _bl = 0;\ninline void flush() {\n\tfwrite(buf, 1, _bl, stdout);\n\t_bl = 0;\n}\n__inline void _putchar(char c) {\n\tif(_bl == _B) flush();\n\tbuf[_bl++] = c;\n}\ninline void print(LL x, char c) {\n\tstatic char tmp[20];\n\tint l = 0;\n\tif(!x) tmp[l++] = '0';\n\telse {\n\t\twhile(x) {\n\t\t\ttmp[l++] = x % 10 + '0';\n\t\t\tx /= 10;\n\t\t}\n\t}\n\tfor(int i = l - 1; i >= 0; i--) _putchar(tmp[i]);\n\t_putchar(c);\n}\ntypedef double C;\nstruct P {\n\tC x, y;\n\tvoid scan() {\n\t\tdouble _x, _y;\n\t\tscanf(\"%lf%lf\", &_x, &_y);\n\t\tx = _x; y = _y;\n\t}\n\tvoid print() {\n\t\tcout << '(' << x << ' ' << y << ')' << endl;\n\t}\n\tP operator + (const P & b) const { return P{x + b.x, y + b.y}; }\n\tP operator - (const P & b) const { return P{x - b.x, y - b.y}; }\n\tC operator * (const P & b) const { return x * b.y - y * b.x; }\n\tC operator % (const P & b) const { return x * b.x + y * b.y; }\n};\nP operator * (const C & x, const P & b) { return P{x * b.x, x * b.y}; }\nconst int N = 100033;\nconst int LOG = 20;\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 7;\nint n, m;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint rela[N];\nint getr(int x) {\n    int p = x;\n    while(rela[p] != p) p = rela[p];\n    int p1 = p; p = x;\n    while(rela[p] != p) {\n        int p2 = rela[p];\n        rela[p] = p1;\n        p = p2;\n    }\n    return p1;\n}\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        ordered_set st;\n        auto update = [&](int pos) {\n            int x = pos >= 1 && pos + 1 < n && a[pos] > a[pos - 1] && a[pos] > a[pos + 1];\n            if((st.find(pos) != st.end()) != x) {\n                if(x == 1) {\n                    st.insert(pos);\n                } else {\n                    st.erase(pos);\n                }\n            }\n        };\n        for(int i = 0; i < n; i++) {\n            update(i);\n        }\n        vector<int> res;\n        for(auto &t : q) {\n            if(t[0] == 1) {\n                int ans = st.order_of_key(t[2] + 1) - st.order_of_key(t[1]);\n                if(st.find(t[2]) != st.end()) {\n                    ans--;\n                }\n                if(t[2] != t[1] && st.find(t[1]) != st.end()) {\n                    ans--;\n                }\n                res.pb(ans);\n            } else {\n                a[t[1]] = t[2];\n                for(int d = -1; d <= 1; d++){\n                    if(t[1] + d >= 0 && t[1] + d < n) {\n                        update(t[1] + d);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": "1718506223",
    "subm_id": "539773604"
}