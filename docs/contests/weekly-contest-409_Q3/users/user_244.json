{
    "username": "virinci",
    "submission": "// clang-format off\ntemplate <typename T, typename U>\nclass LazySegTree {\n\tint n;\n\tT IT;\n\tU IU;\n\tvector<T> tree;\n\tvector<U> lazy;\n\npublic:\n\tLazySegTree(const T *a, int n_, T it, U iu)\n\t\t: n{n_}, IT{it}, IU{iu}, tree(4 * n, IT), lazy(4 * n, IU) {\n\t\tbuild(a, 1, 0, n - 1);\n\t}\n\n\tT query(int l, int r) { return query(l, r, 1, 0, n - 1); }\n\tvoid update(int l, int r, const U& u) { update(l, r, u, 1, 0, n - 1); }\n\nprivate:\n\tT combine(const T& l, const T& r) {\n\t\treturn l + r;\n\t}\n\n\t// Apply an update u to value t.\n\tvoid apply(T& t, const U& u, int tl, int tr) {\n\t\tassert(u != IU);\n\t\tt = 0;\n\t}\n\n\t// Combine a new update u intended for [l, r] to an update w intended for [tl, tr].\n\tvoid combine_updates(U& w, int tl, int tr, int l, int r, const U& u) {\n\t\tassert(tl >= l && tr <= r);\n\t\tassert(u != IU);\n\t\tw = 0;\n\t}\n\n\t// Apply v's lazy update and push down the update to children.\n\tvoid propagate(int v, int tl, int tr) {\n\t\tif (lazy[v] == IU) return;\n\t\tapply(tree[v], lazy[v], tl, tr);\n\t\tif (tl != tr) {\n\t\t\tint tm = (tl + tr) >> 1;\n\t\t\tcombine_updates(lazy[2 * v], tl, tm, tl, tr, lazy[v]);\n\t\t\tcombine_updates(lazy[2 * v + 1], tm + 1, tr, tl, tr, lazy[v]);\n\t\t}\n\t\tlazy[v] = IU;\n\t}\n\n\t// Apply an update u that was meant for [l, r] on [tl, tr].\n\tvoid update(int l, int r, const U& u, int v, int tl, int tr) {\n\t\tif (l <= tl && r >= tr) combine_updates(lazy[v], tl, tr, l, r, u);\n\t\tpropagate(v, tl, tr);\n\t\tif (r < tl || l > tr || (l <= tl && r >= tr)) { return; }\n\t\tauto tm = (tl + tr) >> 1;\n\t\tupdate(l, r, u, 2 * v, tl, tm);\n\t\tupdate(l, r, u, 2 * v + 1, tm + 1, tr);\n\t\ttree[v] = combine(tree[2 * v], tree[2 * v + 1]);\n\t}\n\n\tT query(int l, int r, int v, int tl, int tr) {\n\t\tif (r < tl || l > tr) return IT;\n\t\tpropagate(v, tl, tr);\n\t\tif (l <= tl && r >= tr) return tree[v];\n\t\tauto tm = (tl + tr) >> 1;\n\t\treturn combine(query(l, r, 2 * v, tl, tm), query(l, r, 2 * v + 1, tm + 1, tr));\n\t}\n\n\tvoid build(const T* a, int v, int tl, int tr) {\n\t\tif (tl == tr) { tree[v] = a[tl]; return; }\n\t\tauto tm = (tl + tr) >> 1;\n\t\tbuild(a, 2 * v, tl, tm);\n\t\tbuild(a, 2 * v + 1, tm + 1, tr);\n\t\ttree[v] = combine(tree[2 * v], tree[2 * v + 1]);\n\t}\n};\n// clang-format on\n\nstatic const int _ = []() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(nullptr);\n\treturn 0;\n}();\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n\t\tvector<int> a(n, 1);\n\t\ta[0] = 0;\n\t\tLazySegTree<int, int> lst(a.data(), n, 0, 1);\n\n\t\tvector<int> ans;\n\n\t\tfor (auto& q : queries) {\n\t\t\tint u = q[0], v = q[1];\n\t\t\tlst.update(u + 1, v - 1, 0);\n\t\t\tans.emplace_back(lst.query(0, n - 1));\n\t\t}\n\n\t\treturn ans;\n    }\n};",
    "submit_ts": "1722740909",
    "subm_id": "1343731790"
}