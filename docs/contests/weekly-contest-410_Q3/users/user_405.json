{
    "username": "The_2nd_Derivative",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)\n// trace std::pair\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){\n    return os<<\"{\"<<P.first<<\":\"<<P.second<<\"}\";\n}\n// trace std::vector\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){\n    os<<\"[ \";for(auto v:V)os<<v<<\" \";return os<<\"]\";\n}\n// trace std::map;\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {\n    os<<\"[ \";for(auto& P : MP) os<<P<<\" \";return os<<\"]\";\n}\n// trace unordred_std::map\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {\n    os<<\"[ \";for(auto& P : MP) os<<P<<\" \";return os<<\"]\";\n}\n// trace std::set\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){\n    os<<\"[ \";for(auto s:S)os<<s<<\" \";return os<<\"]\";\n}\n// trace std::unordered_set\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){\n    os<<\"[ \";for(auto s:S)os<<s<<\" \";return os<<\"]\";\n}\n// std::stack FUN\ntemplate<class T> void F_Stack(std::stack<T> st, std::string& cont) { \n    if(st.empty()) return;\n    T mem=st.top();st.pop();F_Stack(st,cont);cont+=\" \"+to_string(mem);  \n}\n// trace std::stack                                                  \ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {\n    os<<\"[\";std::string cont=\"\";F_Stack(st,cont);return os<<cont<<\" ]\";\n}\n// track std::queue\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {\n    os<<\"[ \";while(!q.empty()) os<<q.front()<<\" \",q.pop();return os<<\"]\";\n}\n\n// for last arg.\ntemplate<typename Arg1>\nvoid __f(const char* name,Arg1&& arg1){\n    std::cout<<name<<\" : \"<<arg1<<std::endl;\n}\n// for variable arg\ntemplate <typename Arg1,typename... Args>\nvoid __f(const char* names,Arg1&& arg1,Args&&... args){\n    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<\" : \"<<arg1<<\" | \";__f(comma+1,args...);\n}\n\n// dbg std::array\ntemplate<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){\n    os<<\"[ \";for(auto v:V)os<<v<<\" \";return os<<\"]\";\n}\n\n// X.find_by_order(k) return iterator to kth element. 0 indexed.\n// X.order_of_key(k) returns count of elements strictly less than k.\n\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// template <class T>\n// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\n\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define sz(x) ((ll)(x).size())\n#define nl '\\n'\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n \nusing ll = long long int;\nusing pii = pair<ll,ll>;\nusing mii = map<ll,ll>;\nusing umii = unordered_map<ll,ll>;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvii = vector<vpii>;\n\ntemplate<class T> bool chmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool chmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nconst ll INF = 1e18;\nconst ll N = 1e5+5;\n\n\n// -MODULAR-\ntemplate<int P>\nstruct Modular {\n    Modular() : x{} {}\n    Modular(long long x) : x{norm(x % P)} {}\n    \n    int norm(int x) { if (x < 0) { x += P;} if (x >= P) { x -= P;} return x; }\n    int val() const { return x; }\n    Modular inv() const { assert(x != 0); return pwr(*this, P - 2); }\n    explicit operator long long () { return x; }  //** Warning : Explicit **\n    \n    // unary\n    Modular operator - () const { return Modular(-x); }\n    Modular operator ++ ()  { x = norm(++x); return *this; }\n    Modular operator -- () { x = norm(--x); return *this; }\n    Modular operator ++ (int) { Modular result = *this; ++*this; return result; }\n    Modular operator -- (int) { Modular result = *this; --*this; return result; }\n    Modular &operator*=(const Modular &rhs) { x = 1LL * x * rhs.val() % P; return *this; }\n    Modular &operator+=(const Modular &rhs) { x = norm(x + rhs.val()); return *this;}\n    Modular &operator-=(const Modular &rhs) { x = norm(x - rhs.val()); return *this; }  \n    Modular &operator/=(const Modular &rhs) { return *this *= rhs.inv(); }\n \n    // equality\n    friend bool operator == (const Modular &lhs, const Modular &rhs) { return lhs.val() == rhs.val(); }\n    friend bool operator <  (const Modular &lhs, const Modular &rhs) { return lhs.val() < rhs.val(); }\n    friend bool operator >  (const Modular &lhs, const Modular &rhs) { return lhs.val() > rhs.val(); }\n    friend bool operator >= (const Modular &lhs, const Modular &rhs) { return lhs.val() >= rhs.val(); }\n    friend bool operator <= (const Modular &lhs, const Modular &rhs) { return lhs.val() <= rhs.val(); }\n \n    // binary\n    friend Modular operator*(const Modular &lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }\n    friend Modular operator+(const Modular &lhs, const Modular &rhs) { return Modular(lhs) += rhs; }\n    friend Modular operator-(const Modular &lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }\n    friend Modular operator/(const Modular &lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }\n    \n    // stream\n    friend std::istream &operator>>(std::istream &is, Modular &a) { long long v; is >> v; a = Modular(v); return is; }\n    friend std::ostream &operator<<(std::ostream &os, const Modular &a) { return os << a.val(); }\n \nprivate:\n    int x;\n};\n \nconst int M = 1000000007; \nusing mi = Modular<M>;\n\nmi pwr(mi a, ll b) { mi res = 1; while (b>0) { if (b&1) res *= a; a *= a; b >>= 1; } return res; } \n \n/*vector<mi> fact(1, 1);\nvector<mi> inv_fact(1, 1);\n\nmi F(int n) {\n    while ((int) fact.size() < n + 1) {\n        fact.push_back(fact.back() * (int) fact.size());\n        inv_fact.push_back(1 / fact.back());\n    }\n    return fact[n];\n}\n\nmi I(int n) {\n    while ((int) fact.size() < n + 1) {\n        fact.push_back(fact.back() * (int) fact.size());\n        inv_fact.push_back(1 / fact.back());\n    }\n    return inv_fact[n];\n}\n\nmi C(int n, int k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    while ((int) fact.size() < n + 1) {\n        fact.push_back(fact.back() * (int) fact.size());\n        inv_fact.push_back(1 / fact.back());\n    }\n    return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint dp[2001][51][51];\n\nclass Solution {\npublic:\n    \n    \n    mi rec(int idx,int l1,int l2,vi& nums){\n        if(idx==sz(nums))\n            return 1;\n        if(dp[idx][l1][l2]!=-1)\n            return dp[idx][l1][l2];\n        mi ans = 0;\n        for(int i=0;i<=nums[idx];i++){\n            int j=nums[idx]-i;\n            if(i>=l1&&l2>=j)\n                ans+=mi(rec(idx+1,i,j,nums));\n        }\n        return dp[idx][l1][l2]=ans.val();\n    }\n    \n    int countOfPairs(vector<int>& nums) {\n        memset(dp,-1,sizeof(dp));\n        return rec(0,0,50,nums).val();\n    }\n};",
    "submit_ts": "1723344408",
    "subm_id": "1351533751"
}