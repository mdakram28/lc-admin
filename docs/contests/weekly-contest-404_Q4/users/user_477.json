{
    "username": "liaoyunyang0815",
    "submission": "class Solution {\npublic:\n#define pb push_back\n    vector<int> e[2][100005];\n    int dep[2][100005];\n    int ans[2], d[2];\n    void dfs(int now, int f, int t) {\n        dep[t][now] = 1;\n    \n        for (int i:e[t][now]) if (i != f) {\n            dfs(i, now, t);\n            dep[t][now] = max(dep[t][now], dep[t][i] + 1);\n        }\n      \n    }\n\n    void dfs2(int now, int f, int t, int up) {\n        int maxn = max(dep[t][now], up);\n        d[t] = max(d[t], dep[t][now] + up - 1);\n       \n        ans[t] = min(ans[t], maxn);\n        multiset<int, greater<int>> mtst;\n        mtst.insert(1);\n        for (int i:e[t][now]) if (i != f) {\n           mtst.insert(dep[t][i] + 1);\n        }\n        for (int i:e[t][now]) if (i != f) {\n           mtst.erase(mtst.find(dep[t][i]+1));\n           int newup = max(up + 1, *mtst.begin() + 1);\n           dfs2(i, now, t, newup);\n           mtst.insert(dep[t][i]+1);\n        }\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int s1, s2;\n        d[0] = d[1] = 1;\n        ans[0] = 1; ans[1] = 1;\n        for (auto i : edges1) {\n            e[0][i[0]].pb(i[1]);\n            e[0][i[1]].pb(i[0]);\n        }\n        for (auto i : edges2) {\n            e[1][i[0]].pb(i[1]);\n            e[1][i[1]].pb(i[0]);\n        }\n        if (edges1.size()) {\n            s1 = edges1[0][0],\n            dfs(s1, -1, 0);\n             ans[0] = 100000000;\n            dfs2(s1, -1, 0, 1);\n        }\n        if (edges2.size()) {\n            s2 = edges2[0][0];\n            ans[1] = 100000000;\n            dfs(s2, -1, 1);\n            dfs2(s2, -1, 1, 1);\n        }\n\n        //cout << d[0] << \" \" << d[1] << \" \" << ans[0] << \" \" << ans[1] << endl;\n\n        return max(d[0] - 1, max(d[1] - 1, ans[0] + ans[1] - 1));\n\n    }\n};",
    "submit_ts": "1719718161",
    "subm_id": "1304410276"
}