{
    "username": "shiyuanjia0",
    "submission": "class Solution {\npublic:\n    struct TrieNode {\n        unordered_map<char, TrieNode*> children;\n        int cost = -1; \n    };\n\n    void insert(TrieNode* root, const string& word, int cost) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (!node->children.count(c)) {\n                node->children[c] = new TrieNode();\n            }\n            node = node->children[c];\n        }\n        if (node->cost == -1 || node->cost > cost) {\n            node->cost = cost; \n        }\n    }\n\n    int minimumCost(const string& target, const vector<string>& words,\n                    const vector<int>& costs) {\n        TrieNode* root = new TrieNode();\n        // Build the Trie\n        for (int i = 0; i < words.size(); i++) {\n            insert(root, words[i], costs[i]);\n        }\n\n        // dp array to store the minimum cost to form the first i characters of\n        // target\n        vector<int> dp(target.length() + 1, numeric_limits<int>::max());\n        dp[0] = 0; // Cost to form the empty prefix is 0\n\n        for (int i = 0; i < target.length(); ++i) {\n            if (dp[i] == numeric_limits<int>::max())\n                continue; \n\n            TrieNode* node = root;\n            for (int j = i; j < target.length() && node != nullptr; ++j) {\n                node = node->children[target[j]];\n                if (node == nullptr)\n                    break;\n\n                if (node->cost != -1) { \n                    int newCost = dp[i] + node->cost;\n                    if (newCost < dp[j + 1]) {\n                        dp[j + 1] = newCost;\n                    }\n                }\n            }\n        }\n\n        int result = dp[target.length()];\n        return result == numeric_limits<int>::max() ? -1 : result;\n    }\n};",
    "submit_ts": "1720322410",
    "subm_id": "1312349163"
}