{
    "username": "STARs_56789",
    "submission": "#ifndef LOCAL\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nnamespace mitsuha {\ntemplate <class T> bool chmin(T& x, const T& y) { return y >= x ? false : (x = y, true); }\ntemplate <class T> bool chmax(T& x, const T& y) { return y <= x ? false : (x = y, true); }\ntemplate <class T> constexpr T floor(const T x, const T y) { T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); }\ntemplate <class T> constexpr T ceil(const T x, const T y) { T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); }\ntemplate <class T> constexpr T bmod(const T x, const T y) { return x - y * floor(x, y); }\n}\n\nnamespace mitsuha::macro {\n#define IMPL_REPITER(cond) auto& begin() { return *this; } auto end() { return nullptr; } auto& operator*() { return _val; } auto& operator++() { return _val += _step, *this; } bool operator!=(std::nullptr_t) { return cond; }\ntemplate <class Int, class IntL = Int, class IntStep = Int, std::enable_if_t<(std::is_signed_v<Int> == std::is_signed_v<IntL>), std::nullptr_t> = nullptr> struct rep_impl {\n    Int _val; const Int _end, _step;\n    rep_impl(Int n) : rep_impl(0, n) {}\n    rep_impl(IntL l, Int r, IntStep step = 1) : _val(l), _end(r), _step(step) {}\n    IMPL_REPITER((_val < _end))\n};\ntemplate <class Int, class IntL = Int, class IntStep = Int, std::enable_if_t<(std::is_signed_v<Int> == std::is_signed_v<IntL>), std::nullptr_t> = nullptr> struct rrep_impl {\n    Int _val; const Int _end, _step;\n    rrep_impl(Int n) : rrep_impl(0, n) {}\n    rrep_impl(IntL l, Int r) : _val(r - 1), _end(l), _step(-1) {}\n    rrep_impl(IntL l, Int r, IntStep step) : _val(l + floor<Int>(r - l - 1, step) * step), _end(l), _step(-step) {}\n    IMPL_REPITER((_val >= _end))\n};\n#undef IMPL_REPITER\n}\n\n#include <unistd.h>\nnamespace mitsuha::io {\nstatic constexpr uint32_t SZ = 1 << 17;\nchar ibuf[SZ], obuf[SZ], out[100];\nuint32_t pil = 0, pir = 0, por = 0;\nstruct Pre {\n    char num[10000][4];\n    constexpr Pre() : num() {\n        for (int i = 0; i < 10000; i++) {\n            int n = i;\n            for (int j = 3; j >= 0; j--) { num[i][j] = n % 10 | '0'; n /= 10; }\n        }\n    }\n} constexpr pre;\n\ninline void load() {\n    memcpy(ibuf, ibuf + pil, pir - pil);\n    pir = pir - pil + fread(ibuf + pir - pil, 1, SZ - pir + pil, stdin);\n    pil = 0;\n}\ninline void flush() { fwrite(obuf, 1, por, stdout); por = 0; }\n\nvoid rd(char &c) { do { if (pil + 1 > pir) load(); c = ibuf[pil++]; } while (isspace(c)); }\nvoid rd(std::string &x) {\n    x.clear(); char c;\n    do { if (pil + 1 > pir) load(); c = ibuf[pil++]; } while (isspace(c));\n    do { x += c; if (pil == pir) load(); if (pil == pir) break; c = ibuf[pil++]; } while (!isspace(c));\n}\ntemplate <typename T> void rd_real(T &x) { std::string s; rd(s); x = stod(s); }\ntemplate <typename T>\nvoid rd_integer(T &x) {\n    if (pil + 100 > pir) load();\n    char c;\n    do { c = ibuf[pil++]; }while (c < '-');\n    bool minus = 0;\n    if constexpr (std::is_signed<T>::value || std::is_same_v<T, __int128>) { if (c == '-') { minus = 1, c = ibuf[pil++]; } }\n    x = 0;\n    while (c >= '0') { x = x * 10 + (c & 15), c = ibuf[pil++]; }\n    if constexpr (std::is_signed<T>::value || std::is_same_v<T, __int128>) { if (minus) x = -x; }\n}\n\nvoid rd(int &x) { rd_integer(x); }\nvoid rd(long int x) { rd_integer(x); }\nvoid rd(long long &x) { rd_integer(x); }\nvoid rd(__int128 &x) { rd_integer(x); }\nvoid rd(unsigned int &x) { rd_integer(x); }\nvoid rd(unsigned long long &x) { rd_integer(x); }\nvoid rd(unsigned __int128 &x) { rd_integer(x); }\nvoid rd(double &x) { rd_real(x); }\nvoid rd(long double &x) { rd_real(x); }\nvoid rd(__float128 &x) { rd_real(x); }\n    \ntemplate <class T, class U> void rd(std::pair<T, U> &p) { return rd(p.first), rd(p.second); }\ntemplate <size_t N = 0, typename T>\nvoid rd(T &t) { if constexpr (N < std::tuple_size<T>::value) { auto &x = std::get<N>(t); rd(x); rd<N + 1>(t); } }\ntemplate <class... T> void rd(std::tuple<T...> &tpl) { rd(tpl); }\ntemplate <size_t N = 0, typename T> void rd(std::array<T, N> &x) { for (auto &d: x) rd(d); }\ntemplate <class T> void rd(std::vector<T> &x) { for (auto &d: x) rd(d); }\n\nvoid read() {}\ntemplate <class H, class... T> void read(H &h, T &... t) { rd(h), read(t...); }\n\nvoid wt(const char c) { if (por == SZ) flush(); obuf[por++] = c; }\nvoid wt(const std::string &s) { for (char c: s) wt(c); }\nvoid wt(const char *s) { size_t len = strlen(s); for (size_t i = 0; i < len; i++) wt(s[i]); }\ntemplate <typename T> void wt_integer(T x) {\n    if (por > SZ - 100) flush();\n    if (x < 0) { obuf[por++] = '-', x = -x; }\n    int outi;\n    for (outi = 96; x >= 10000; outi -= 4) { memcpy(out + outi, pre.num[x % 10000], 4); x /= 10000; }\n    if (x >= 1000) { memcpy(obuf + por, pre.num[x], 4); por += 4; } \n    else if (x >= 100) { memcpy(obuf + por, pre.num[x] + 1, 3); por += 3; } \n    else if (x >= 10) { int q = (x * 103) >> 10; obuf[por] = q | '0'; obuf[por + 1] = (x - q * 10) | '0'; por += 2; } \n    else obuf[por++] = x | '0';\n    memcpy(obuf + por, out + outi + 4, 96 - outi); por += 96 - outi;\n}\ntemplate <typename T>\nvoid wt_real(T x) {\n    std::ostringstream oss; oss << std::fixed << std::setprecision(15) << double(x);\n    std::string s = oss.str(); wt(s);\n}\nvoid wt(int x) { wt_integer(x); }\nvoid wt(long int x) { wt_integer(x); }\nvoid wt(long long x) { wt_integer(x); }\nvoid wt(__int128 x) { wt_integer(x); }\nvoid wt(unsigned int x) { wt_integer(x); }\nvoid wt(unsigned long long x) { wt_integer(x); }\nvoid wt(unsigned __int128 x) { wt_integer(x); }\nvoid wt(double x) { wt_real(x); }\nvoid wt(long double x) { wt_real(x); }\nvoid wt(__float128 x) { wt_real(x); }\n    \ntemplate <class T, class U> void wt(const std::pair<T, U> val) { wt(val.first); wt(' '); wt(val.second); }\ntemplate <size_t N = 0, typename T> void wt_tuple(const T t) {\n    if constexpr (N < std::tuple_size<T>::value) {\n        if constexpr (N > 0) { wt(' '); }\n        const auto x = std::get<N>(t);\n        wt(x); wt_tuple<N + 1>(t);\n    }\n}\ntemplate <class... T> void wt(std::tuple<T...> tpl) { wt_tuple(tpl); }\ntemplate <class T, size_t S> void wt(const std::array<T, S> val) {\n    auto n = val.size(); for (size_t i = 0; i < n; i++) { if (i) wt(' '); wt(val[i]); }\n}\ntemplate <class T> void wt(const std::vector<T> val) {\n    auto n = val.size(); for (size_t i = 0; i < n; i++) { if (i) wt(' '); wt(val[i]); }\n}\n\nvoid print() { wt('\\n'); }\ntemplate <class Head, class... Tail>\nvoid print(Head &&head, Tail &&... tail) { wt(head); if (sizeof...(Tail)) wt(' '); print(std::forward<Tail>(tail)...); }\nvoid __attribute__((destructor)) _d() { flush(); }\n} // namespace mitsuha::io\nnamespace mitsuha{ using io::read; using io::print; using io::flush; }\n\nnamespace mitsuha {\ntemplate <class T, class ToKey, class CompKey = std::less<>, std::enable_if_t<std::conjunction_v<std::is_invocable<ToKey, T>, std::is_invocable_r<bool, CompKey, std::invoke_result_t<ToKey, T>, std::invoke_result_t<ToKey, T>>>, std::nullptr_t> = nullptr>\nauto lambda(const ToKey& to_key, const CompKey& comp_key = std::less<>()) {\n    return [=](const T& x, const T& y) { return comp_key(to_key(x), to_key(y)); };\n}\ntemplate <class Compare, std::enable_if_t<std::is_invocable_r_v<bool, Compare, int, int>, std::nullptr_t> = nullptr>\nstd::vector<int> sorted_indices(int n, const Compare& compare) {\n    std::vector<int> p(n);\n    return std::iota(p.begin(), p.end(), 0), std::sort(p.begin(), p.end(), compare), p;\n}\ntemplate <class ToKey, std::enable_if_t<std::is_invocable_v<ToKey, int>, std::nullptr_t> = nullptr>\nstd::vector<int> sorted_indices(int n, const ToKey& to_key) { return sorted_indices(n, lambda<int>(to_key)); }\n\ntemplate <typename T, typename Gen>\nauto generate_vector(int n, Gen generator) { std::vector<T> v(n); for (int i = 0; i < n; ++i) v[i] = generator(i); return v; }\ntemplate <typename T> auto generate_range(T l, T r) { return generate_vector<T>(r - l, [l](int i) { return l + i; }); }\ntemplate <typename T> auto generate_range(T n) { return generate_range<T>(0, n); }\n\ntemplate <class Iterable>\nvoid settify(Iterable& a) { std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); }\n\ntemplate <size_t D> struct Dim : std::array<int, D> {\n    template <typename ...Ints> Dim(const Ints& ...ns) : std::array<int, D>::array{ static_cast<int>(ns)... } {}\n};\ntemplate <typename ...Ints> Dim(const Ints& ...) -> Dim<sizeof...(Ints)>;\ntemplate <class T, size_t D, size_t I = 0>\nauto ndvec(const Dim<D> &ns, const T& value = {}) {\n    if constexpr (I + 1 < D) {\n        return std::vector(ns[I], ndvec<T, D, I + 1>(ns, value));\n    } else {\n        return std::vector<T>(ns[I], value);\n    }\n} \n} // namescape mitsuha\n\nnamespace mitsuha {\nusing str = std::string;\nusing int128 = __int128;\nusing uint128 = unsigned __int128;\ntemplate <class T> using min_priority_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T> using max_priority_queue = std::priority_queue<T, std::vector<T>, std::less<T>>;\n}\nnamespace mitsuha { const std::string Yes = \"Yes\", No = \"No\", YES = \"YES\", NO = \"NO\"; }\n\n#define Int(...) int __VA_ARGS__; read(__VA_ARGS__)\n#define Ll(...) long long __VA_ARGS__; read(__VA_ARGS__)\n#define Dbl(...) double __VA_ARGS__; read(__VA_ARGS__)\n#define Chr(...) char __VA_ARGS__; read(__VA_ARGS__)\n#define Str(...) string __VA_ARGS__; read(__VA_ARGS__)\n#define Vt(type, name, size) vector<type> name(size); read(name)\n#define Vvt(type, name, h, w) vector<vector<type>> name(h, vector<type>(w)); read(name)\n#define die(...)  do { print(__VA_ARGS__); return; } while (false)\n#define kill(...) do { print(__VA_ARGS__); return 0; } while (false)\n\n#define Each(e, v) for (auto &&e : v)\n#define CFor(e, v) for (const auto &e : v)\n#define For(i, ...) CFor(i, mitsuha::macro::rep_impl(__VA_ARGS__))\n#define Frr(i, ...) CFor(i, mitsuha::macro::rrep_impl(__VA_ARGS__))\n#define Loop(n) for ([[maybe_unused]] const auto& _ : mitsuha::macro::rep_impl(n))\n\n#define All(iterable) std::begin(iterable), std::end(iterable)\n#define len(iterable) (long long) iterable.size()\n#define elif else if\n \nusing namespace mitsuha;\nusing namespace std;\n\n#ifdef LOCAL\n/*-*/#include \"library/debug/pprint.hpp\"\n#else\n#define debug(...) void(0)\n#endif\n \nconstexpr int iinf = std::numeric_limits<int>::max() / 2;\nconstexpr long long linf = std::numeric_limits<long long>::max() / 2;\n\nnamespace mitsuha{\nnamespace hashing {\n    static const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();\n \n#if USE_AES\n    std::mt19937 rd(FIXED_RANDOM);\n    const __m128i KEY1{(int64_t)rd(), (int64_t)rd()};\n    const __m128i KEY2{(int64_t)rd(), (int64_t)rd()};\n#endif\n \n    template <class T, class D = void>\n    struct custom_hash {};\n \n    // https://www.boost.org/doc/libs/1_55_0/doc/html/hash/combine.html\n    template <class T>\n    inline void hash_combine(uint64_t& seed, const T& v) {\n        custom_hash<T> hasher;\n        seed ^= hasher(v) + 0x9e3779b97f4a7c15 + (seed << 12) + (seed >> 4);\n    };\n \n    // http://xorshift.di.unimi.it/splitmix64.c\n    template <class T>\n    struct custom_hash<T, typename std::enable_if<std::is_integral<T>::value>::type> {\n        uint64_t operator()(T _x) const {\n            uint64_t x = _x;\n#if USE_AES\n            // implementation defined till C++17, defined from C++20\n            __m128i m{int64_t(uint64_t(x) * 0xbf58476d1ce4e5b9uint64_t), (int64_t)FIXED_RANDOM};\n            __m128i y = _mm_aesenc_si128(m, KEY1);\n            __m128i z = _mm_aesenc_si128(y, KEY2);\n            return z[0];\n#else\n            x += 0x9e3779b97f4a7c15 + FIXED_RANDOM;\n            x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n            x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n            return x ^ (x >> 31);\n#endif\n        }\n    };\n \n    template <class T>\n    struct custom_hash<T, std::void_t<decltype(std::begin(std::declval<T>()))>> {\n        uint64_t operator()(const T& a) const {\n            uint64_t value = FIXED_RANDOM;\n            for (auto& x : a) hash_combine(value, x);\n            return value;\n        }\n    };\n \n    template <class... T>\n    struct custom_hash<std::tuple<T...>> {\n        uint64_t operator()(const std::tuple<T...>& a) const {\n            uint64_t value = FIXED_RANDOM;\n            std::apply([&value](T const&... args) { (hash_combine(value, args), ...); }, a);\n            return value;\n        }\n    };\n \n    template <class T, class U>\n    struct custom_hash<std::pair<T, U>> {\n        uint64_t operator()(const std::pair<T, U>& a) const {\n            uint64_t value = FIXED_RANDOM;\n            hash_combine(value, a.first);\n            hash_combine(value, a.second);\n            return value;\n        }\n    };\n \n}; // namespace hashing\n}; // namespace mitsuha\n\n#include \"ext/pb_ds/assoc_container.hpp\"\n#include \"ext/pb_ds/tree_policy.hpp\"\n\nnamespace mitsuha{\nnamespace pbds {\n    using namespace __gnu_pbds;\n#ifdef PB_DS_ASSOC_CNTNR_HPP\n    template <class Key, class Value, class Hash>\n    using unordered_map = gp_hash_table<Key, Value, Hash, std::equal_to<Key>, direct_mask_range_hashing<>, linear_probe_fn<>,\n                                        hash_standard_resize_policy<hash_exponential_size_policy<>, hash_load_check_resize_trigger<>, true>>;\n    template <class Key, class Hash>\n    using unordered_set = pbds::unordered_map<Key, null_type, Hash>;\n#endif\n#ifdef PB_DS_TREE_POLICY_HPP\n    template <typename T>\n    using ordered_set = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n    template <typename T>\n    using ordered_multiset = tree<T, null_type, std::less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n    template <class Key, class Value, class Compare = std::less<Key>>\n    using ordered_map = tree<Key, Value, Compare, rb_tree_tag, tree_order_statistics_node_update>;\n#endif\n} // namespace pbds\n} // namespace mitsuha\n\nnamespace mitsuha{\ntemplate <typename Signature, typename Lambda>\nstruct Cache;\n \ntemplate <typename ReturnType, typename... Args, typename Lambda>\nstruct Cache<ReturnType(Args...), Lambda> {\n    template <typename... DummyArgs>\n    ReturnType operator()(DummyArgs&&... args) {\n        auto tied_args = std::tie(args...);\n        auto it = memo.find(tied_args);\n        if (it == memo.end()) {\n            auto&& ans = f(*this, std::forward<DummyArgs>(args)...);\n            memo[tied_args] = ans;\n            return ans;\n        } else {\n            return it->second;\n        }\n    }\n \n    template <class _Lambda>\n    Cache(std::tuple<>, _Lambda&& _f) : f(std::forward<_Lambda>(_f)) {}\n \n    Lambda f;\n    using TiedArgs = std::tuple<std::decay_t<Args>...>;\n    pbds::unordered_map<TiedArgs, ReturnType, hashing::custom_hash<TiedArgs>> memo;\n};\n \ntemplate <class Signature, class Lambda>\nauto use_cache(Lambda&& f) {\n    return Cache<Signature, Lambda>(std::tuple{}, std::forward<Lambda>(f));\n}\n} // namespace mitsuha\n\nclass Solution {\npublic:\n    int waysToReachStair(int k) {\n        \n        auto f = use_cache<int(int, int, int)>([&](auto &&self, int at, int j, int used)->int{\n\n            if (at > k + 1 or j > 30) return 0;\n            if (at < 0) return 0;\n            \n            if (used) return (at == 1) + self(at - (1 << j), j + 1, false);\n            return (at == 1) + self(at - (1 << j), j + 1, false) + self(at + 1, j, true);\n        });\n\n        return f(k, 0, false);\n    }\n};\n\n",
    "submit_ts": "1716087342",
    "subm_id": "1261780682"
}