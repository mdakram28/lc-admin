{
    "username": "07dishwasherbob8",
    "submission": "template<typename T>\nstruct Tree {\n    static constexpr T base = 0;\n    vector<T> v;\n    int n, size;\n    T comb(T a, T b) { //change this when doing maximum vs minimum etc.\n        return a + b;\n    }\n    Tree(int n = 0, T def = base) {\n        this->n = n; //max number of elements\n        size = 1;\n        while(size < n) size *= 2;\n        v.assign(size * 2, def);\n    }\n    void update(int pos, T val) { //update 0 indexed, assignment\n        assert(pos < n && pos >= 0);\n        int curr = pos + size;\n        v[curr] = val;\n        while(curr != 1) {\n            if(curr & 1) { //handles non-communative operations\n                v[curr / 2] = comb(v[curr ^ 1], v[curr]);\n            } else {\n                v[curr / 2] = comb(v[curr], v[curr ^ 1]);\n            }\n            curr /= 2;\n        }\n    }\n    bool isLeaf(int idx) {\n        return idx >= size;\n    }\n    T at(int idx) {\n        assert(idx >= 0 && idx < n);\n        return v[idx + size];\n    }\n    T query(int l, int r) {//queries in range [l,r)\n        return _query(1,0,size,l,r);\n    }\n    T _query(int idx, int currl, int currr, int &targetl, int &targetr) {\n        if(currr <= targetl || currl >= targetr) return base;\n        if(currl >= targetl && currr <= targetr) return v[idx];\n        int mid = (currl + currr) / 2;\n        return comb(\n            _query(idx * 2, currl, mid, targetl, targetr),\n            _query(idx * 2 + 1, mid, currr, targetl, targetr)\n        );\n    }\n};\n\nclass Solution {\n    \nvoid updatePeak(int i, vector<int> &nums, Tree<int> &tree) {\n    if(i > 0 && i < nums.size() - 1) {\n        tree.update(i,nums[i] > nums[i-1] && nums[i] > nums[i+1]); \n    }\n    \n}\n    \npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        Tree<int> tree(n);\n        for(int i = 0; i < n; i++) updatePeak(i,nums,tree);\n        vector<int> res;\n        for(auto q : queries) {\n            if(q[0] == 1) {\n                res.push_back(tree.query(q[1]+1,q[2]));\n            } else {\n                nums[q[1]] = q[2];\n                updatePeak(q[1],nums,tree);\n                updatePeak(q[1]-1,nums,tree);\n                updatePeak(q[1]+1,nums,tree);\n\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": "1718506129",
    "subm_id": "1289607927"
}