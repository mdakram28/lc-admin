{
    "username": "Dinh Trung Tran",
    "submission": "function maximumValueSum(board: number[][]): number {\n    const ROWS = board.length;\n    const COLS = board[0].length;\n\n    // Step 1: Extract all cell values with their positions and sort them\n    const cells: { value: number, row: number, col: number }[] = [];\n    for (let r = 0; r < ROWS; r++) {\n        for (let c = 0; c < COLS; c++) {\n            cells.push({ value: board[r][c], row: r, col: c });\n        }\n    }\n    cells.sort((a, b) => b.value - a.value); // Sort by value in descending order\n\n    let maxSum = -Infinity;\n\n    // Step 2: Use DFS with Branch and Bound\n    const dfs = (index: number, count: number, currentSum: number, usedRows: Set<number>, usedCols: Set<number>) => {\n        if (count === 3) {\n            maxSum = Math.max(maxSum, currentSum);\n            return;\n        }\n\n        if (index >= cells.length) return;\n\n        // Calculate the optimistic bound\n        let bound = currentSum;\n        for (let i = index; i < index + (3 - count) && i < cells.length; i++) {\n            bound += cells[i].value;\n        }\n\n        // If the optimistic bound is less than the current max sum, prune the branch\n        if (bound <= maxSum) return;\n\n        // Option 1: Skip the current cell\n        dfs(index + 1, count, currentSum, usedRows, usedCols);\n\n        // Option 2: Place a rook at the current cell if it's not in a used row/column\n        const { row, col, value } = cells[index];\n        if (!usedRows.has(row) && !usedCols.has(col)) {\n            usedRows.add(row);\n            usedCols.add(col);\n            dfs(index + 1, count + 1, currentSum + value, usedRows, usedCols);\n            usedRows.delete(row);\n            usedCols.delete(col);\n        }\n    };\n\n    dfs(0, 0, 0, new Set(), new Set());\n\n    return maxSum;\n}\n\nfunction maximumValueSum2(board: number[][]): number {\n    const ROWS = board.length;\n    const COLS = board[0].length;\n    \n    const cells: { value: number, row: number, col: number }[] = [];\n    for (let r = 0; r < ROWS; r++) {\n        for (let c = 0; c < COLS; c++) {\n            cells.push({ value: board[r][c], row: r, col: c });\n        }\n    }\n    cells.sort((a, b) => b.value - a.value); \n\n    let maxSum = -Infinity;\n    \n    for (let i = 0; i < cells.length; i++) {\n        const { row: row1, col: col1, value: val1 } = cells[i];\n        for (let j = i + 1; j < cells.length; j++) {\n            const { row: row2, col: col2, value: val2 } = cells[j];\n            if (row1 === row2 || col1 === col2) continue; \n            for (let k = j + 1; k < cells.length; k++) {\n                const { row: row3, col: col3, value: val3 } = cells[k];\n                if (row1 === row3 || col1 === col3 || row2 === row3 || col2 === col3) continue; \n                const currentSum = val1 + val2 + val3;\n                maxSum = Math.max(maxSum, currentSum);\n                break;\n            }\n        }\n    }\n    \n    return maxSum;\n};",
    "submit_ts": "1723909676",
    "subm_id": "1359201576"
}