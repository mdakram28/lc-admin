{
    "username": "yeetcode_dot_io_LC_tutorials",
    "submission": "#include <vector>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n\nusing namespace std;\n\nclass SegmentTree {\npublic:\n    SegmentTree(const vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        lazy.resize(4 * n, 0);\n        build(arr, 0, 0, n - 1);\n    }\n\n    void updateRange(int l, int r, int diff) {\n        updateRangeUtil(0, 0, n - 1, l, r, diff);\n    }\n\n    int queryRangeMin(int l, int r) {\n        return queryRangeUtilMin(0, 0, n - 1, l, r);\n    }\n\n    int queryRangeMax(int l, int r) {\n        return queryRangeUtilMax(0, 0, n - 1, l, r);\n    }\n\n    int findFurthestLeftGreaterEqualZero(int l, int r) {\n        return findFurthestLeftUtil(0, 0, n - 1, l, r, [](int x) { return x >= 0; });\n    }\n\n    int findFurthestLeftLessEqualZero(int l, int r) {\n        return findFurthestLeftUtil(0, 0, n - 1, l, r, [](int x) { return x <= 0; });\n    }\n\n    int val(int index) {\n        return valUtil(0, 0, n - 1, index);\n    }\n\nprivate:\n    vector<pair<int, int>> tree;\n    vector<int> lazy;\n    int n;\n\n    void build(const vector<int>& arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = { arr[start], arr[start] };\n        } else {\n            int mid = (start + end) / 2;\n            int left_child = 2 * node + 1;\n            int right_child = 2 * node + 2;\n            build(arr, left_child, start, mid);\n            build(arr, right_child, mid + 1, end);\n            tree[node] = { max(tree[left_child].first, tree[right_child].first), min(tree[left_child].second, tree[right_child].second) };\n        }\n    }\n\n    void propagate(int node, int start, int end) {\n        if (lazy[node] != 0) {\n            tree[node].first += lazy[node];\n            tree[node].second += lazy[node];\n            if (start != end) {\n                lazy[2 * node + 1] += lazy[node];\n                lazy[2 * node + 2] += lazy[node];\n            }\n            lazy[node] = 0;\n        }\n    }\n\n    void updateRangeUtil(int node, int start, int end, int l, int r, int diff) {\n        propagate(node, start, end);\n\n        if (start > end || start > r || end < l) {\n            return;\n        }\n\n        if (start >= l && end <= r) {\n            tree[node].first += diff;\n            tree[node].second += diff;\n            if (start != end) {\n                lazy[2 * node + 1] += diff;\n                lazy[2 * node + 2] += diff;\n            }\n            return;\n        }\n\n        int mid = (start + end) / 2;\n        updateRangeUtil(2 * node + 1, start, mid, l, r, diff);\n        updateRangeUtil(2 * node + 2, mid + 1, end, l, r, diff);\n        tree[node] = { max(tree[2 * node + 1].first, tree[2 * node + 2].first), min(tree[2 * node + 1].second, tree[2 * node + 2].second) };\n    }\n\n    int queryRangeUtilMin(int node, int start, int end, int l, int r) {\n        propagate(node, start, end);\n\n        if (start > end || start > r || end < l) {\n            return INT_MAX;\n        }\n\n        if (start >= l && end <= r) {\n            return tree[node].second;\n        }\n\n        int mid = (start + end) / 2;\n        int left_query = queryRangeUtilMin(2 * node + 1, start, mid, l, r);\n        int right_query = queryRangeUtilMin(2 * node + 2, mid + 1, end, l, r);\n        return min(left_query, right_query);\n    }\n\n    int queryRangeUtilMax(int node, int start, int end, int l, int r) {\n        propagate(node, start, end);\n\n        if (start > end || start > r || end < l) {\n            return INT_MIN;\n        }\n\n        if (start >= l && end <= r) {\n            return tree[node].first;\n        }\n\n        int mid = (start + end) / 2;\n        int left_query = queryRangeUtilMax(2 * node + 1, start, mid, l, r);\n        int right_query = queryRangeUtilMax(2 * node + 2, mid + 1, end, l, r);\n        return max(left_query, right_query);\n    }\n\n    int findFurthestLeftUtil(int node, int start, int end, int l, int r, function<bool(int)> condition) {\n        propagate(node, start, end);\n\n        if (start > end || start > r || end < l) {\n            return -1;\n        }\n\n        if (start == end) {\n            if (condition(tree[node].first)) {\n                return start;\n            } else {\n                return -1;\n            }\n        }\n\n        int mid = (start + end) / 2;\n        int left_result = findFurthestLeftUtil(2 * node + 1, start, mid, l, r, condition);\n        if (left_result != -1) {\n            return left_result;\n        }\n        int right_result = findFurthestLeftUtil(2 * node + 2, mid + 1, end, l, r, condition);\n        return right_result;\n    }\n\n    int valUtil(int node, int start, int end, int index) {\n        propagate(node, start, end);\n\n        if (start > end || start > index || end < index) {\n            return INT_MAX;\n        }\n\n        if (start == end) {\n            return tree[node].first;\n        }\n\n        int mid = (start + end) / 2;\n        if (index <= mid) {\n            return valUtil(2 * node + 1, start, mid, index);\n        } else {\n            return valUtil(2 * node + 2, mid + 1, end, index);\n        }\n    }\n};\n\nclass Solution {\npublic:\n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n        vector<int> diffs(nums.size());\n        for (int i = 0; i < nums.size(); ++i) {\n            diffs[i] = target[i] - nums[i];\n        }\n        SegmentTree st(diffs);\n        int i = 0;\n        long long res = 0;\n        while (i < nums.size()) {\n            int val = st.val(i);\n            if (val == 0) {\n                ++i;\n                continue;\n            } else if (val < 0) {\n                int leftmostGTEZero = st.findFurthestLeftGreaterEqualZero(i, nums.size() - 1);\n                if (leftmostGTEZero == -1) {\n                    leftmostGTEZero = nums.size();\n                }\n                int incrementUpToAndIncluding = leftmostGTEZero - 1;\n                int biggestInRange = st.queryRangeMax(i, incrementUpToAndIncluding);\n                st.updateRange(i, incrementUpToAndIncluding, -biggestInRange);\n                res += abs(biggestInRange);\n            } else if (val > 0) {\n                int leftmostLTEZero = st.findFurthestLeftLessEqualZero(i, nums.size() - 1);\n                if (leftmostLTEZero == -1) {\n                    leftmostLTEZero = nums.size();\n                }\n                int decrementUpToAndIncluding = leftmostLTEZero - 1;\n                int smallestInRange = st.queryRangeMin(i, decrementUpToAndIncluding);\n                st.updateRange(i, decrementUpToAndIncluding, -smallestInRange);\n                res += smallestInRange;\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": "1721532865",
    "subm_id": "1327995870"
}