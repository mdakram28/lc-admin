{
    "username": "naturel-r",
    "submission": "class TreeNode:\n    def __init__(self, val=0):\n        self.left = -1  # \u533a\u95f4\u5de6\u8fb9\u754c\n        self.right = -1  # \u533a\u95f4\u53f3\u8fb9\u754c\n        self.val = val  # \u8282\u70b9\u503c\uff08\u533a\u95f4\u503c\uff09\n        self.lazy_tag = None  # \u533a\u95f4\u548c\u95ee\u9898\u7684\u5ef6\u8fdf\u66f4\u65b0\u6807\u8bb0\n# \u7ebf\u6bb5\u6811\u7c7b\nclass SegmentTree:\n    def __init__(self, nums):\n        self.size = len(nums)\n        self.tree = [TreeNode() for _ in range(4 * self.size)]  # \u7ef4\u62a4 TreeNode \u6570\u7ec4\n        self.nums = nums  # \u539f\u59cb\u6570\u636e\n        if self.size > 0:\n            self.__build(0, 0, self.size - 1)\n\n    # \u6784\u5efa\u7ebf\u6bb5\u6811\uff0c\u8282\u70b9\u7684\u5b58\u50a8\u4e0b\u6807\u4e3a index\uff0c\u8282\u70b9\u7684\u533a\u95f4\u4e3a [left, right]\n    def __build(self, index, left, right):\n        self.tree[index].left = left\n        self.tree[index].right = right\n        if left == right:  # \u53f6\u5b50\u8282\u70b9\uff0c\u8282\u70b9\u503c\u4e3a\u5bf9\u5e94\u4f4d\u7f6e\u7684\u5143\u7d20\u503c\n            self.tree[index].val = self.nums[left]\n            return\n\n        mid = left + (right - left) // 2  # \u5de6\u53f3\u8282\u70b9\u5212\u5206\u70b9\n        left_index = index * 2 + 1  # \u5de6\u5b50\u8282\u70b9\u7684\u5b58\u50a8\u4e0b\u6807\n        right_index = index * 2 + 2  # \u53f3\u5b50\u8282\u70b9\u7684\u5b58\u50a8\u4e0b\u6807\n        self.__build(left_index, left, mid)  # \u9012\u5f52\u521b\u5efa\u5de6\u5b50\u6811\n        self.__build(right_index, mid + 1, right)  # \u9012\u5f52\u521b\u5efa\u53f3\u5b50\u6811\n        self.__pushup(index)  # \u5411\u4e0a\u66f4\u65b0\u8282\u70b9\u7684\u533a\u95f4\u503c\n\n    # \u5411\u4e0a\u66f4\u65b0\u4e0b\u6807\u4e3a index \u7684\u8282\u70b9\u533a\u95f4\u503c\uff0c\u8282\u70b9\u7684\u533a\u95f4\u503c\u7b49\u4e8e\u8be5\u8282\u70b9\u5de6\u53f3\u5b50\u8282\u70b9\u5143\u7d20\u503c\u7684\u805a\u5408\u8ba1\u7b97\u7ed3\u679c\n    def __pushup(self, index):\n        left_index = index * 2 + 1  # \u5de6\u5b50\u8282\u70b9\u7684\u5b58\u50a8\u4e0b\u6807\n        right_index = index * 2 + 2  # \u53f3\u5b50\u8282\u70b9\u7684\u5b58\u50a8\u4e0b\u6807\n        self.tree[index].val = self.tree[left_index].val + self.tree[right_index].val\n    def update_point(self, i, val):\n        self.nums[i] = val\n        self.__update_point(i, val, 0, 0, self.size - 1)\n    def __update_point(self, i, val, index, left, right):\n        if self.tree[index].left == self.tree[index].right:\n            self.tree[index].val = val  # \u53f6\u5b50\u8282\u70b9\uff0c\u8282\u70b9\u503c\u4fee\u6539\u4e3a val\n            return\n\n        mid = left + (right - left) // 2  # \u5de6\u53f3\u8282\u70b9\u5212\u5206\u70b9\n        left_index = index * 2 + 1  # \u5de6\u5b50\u8282\u70b9\u7684\u5b58\u50a8\u4e0b\u6807\n        right_index = index * 2 + 2  # \u53f3\u5b50\u8282\u70b9\u7684\u5b58\u50a8\u4e0b\u6807\n        if i <= mid:  # \u5728\u5de6\u5b50\u6811\u4e2d\u66f4\u65b0\u8282\u70b9\u503c\n            self.__update_point(i, val, left_index, left, mid)\n        else:  # \u5728\u53f3\u5b50\u6811\u4e2d\u66f4\u65b0\u8282\u70b9\u503c\n            self.__update_point(i, val, right_index, mid + 1, right)\n        self.__pushup(index)  # \u5411\u4e0a\u66f4\u65b0\u8282\u70b9\u7684\u533a\u95f4\u503c\n    def query_interval(self, q_left, q_right):\n        return self.__query_interval(q_left, q_right, 0, 0, self.size - 1)\n    def __query_interval(self, q_left, q_right, index, left, right):\n        if left >= q_left and right <= q_right:  # \u8282\u70b9\u6240\u5728\u533a\u95f4\u88ab [q_left, q_right] \u6240\u8986\u76d6\n            return self.tree[index].val  # \u76f4\u63a5\u8fd4\u56de\u8282\u70b9\u503c\n        if right < q_left or left > q_right:  # \u8282\u70b9\u6240\u5728\u533a\u95f4\u4e0e [q_left, q_right] \u65e0\u5173\n            return 0\n\n        self.__pushdown(index)\n\n        mid = left + (right - left) // 2  # \u5de6\u53f3\u8282\u70b9\u5212\u5206\u70b9\n        left_index = index * 2 + 1  # \u5de6\u5b50\u8282\u70b9\u7684\u5b58\u50a8\u4e0b\u6807\n        right_index = index * 2 + 2  # \u53f3\u5b50\u8282\u70b9\u7684\u5b58\u50a8\u4e0b\u6807\n        res_left = 0  # \u5de6\u5b50\u6811\u67e5\u8be2\u7ed3\u679c\n        res_right = 0  # \u53f3\u5b50\u6811\u67e5\u8be2\u7ed3\u679c\n        if q_left <= mid:  # \u5728\u5de6\u5b50\u6811\u4e2d\u67e5\u8be2\n            res_left = self.__query_interval(q_left, q_right, left_index, left, mid)\n        if q_right > mid:  # \u5728\u53f3\u5b50\u6811\u4e2d\u67e5\u8be2\n            res_right = self.__query_interval(q_left, q_right, right_index, mid + 1, right)\n        return res_left + res_right  # \u8fd4\u56de\u5de6\u53f3\u5b50\u6811\u5143\u7d20\u503c\u7684\u805a\u5408\u8ba1\u7b97\u7ed3\u679c\n    def __pushdown(self, index):\n        lazy_tag = self.tree[index].lazy_tag\n        if not lazy_tag:\n            return\n\n        left_index = index * 2 + 1  # \u5de6\u5b50\u8282\u70b9\u7684\u5b58\u50a8\u4e0b\u6807\n        right_index = index * 2 + 2  # \u53f3\u5b50\u8282\u70b9\u7684\u5b58\u50a8\u4e0b\u6807\n\n        self.tree[left_index].lazy_tag = lazy_tag  # \u66f4\u65b0\u5de6\u5b50\u8282\u70b9\u61d2\u60f0\u6807\u8bb0\n        left_size = (self.tree[left_index].right - self.tree[left_index].left + 1)\n        self.tree[left_index].val = lazy_tag * left_size  # \u66f4\u65b0\u5de6\u5b50\u8282\u70b9\u503c\n\n        self.tree[right_index].lazy_tag = lazy_tag  # \u66f4\u65b0\u53f3\u5b50\u8282\u70b9\u61d2\u60f0\u6807\u8bb0\n        right_size = (self.tree[right_index].right - self.tree[right_index].left + 1)\n        self.tree[right_index].val = lazy_tag * right_size  # \u66f4\u65b0\u53f3\u5b50\u8282\u70b9\u503c\n\n        self.tree[index].lazy_tag = None  # \u66f4\u65b0\u5f53\u524d\u8282\u70b9\u7684\u61d2\u60f0\u6807\u8bb0\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        treels = [0]*n\n        for i in range(1, n-1):\n            if nums[i]>nums[i-1] and nums[i]>nums[i+1]:\n                treels[i] = 1\n        def ispeak(pos):\n            nonlocal n, nums\n            if pos == 0 or pos == n-1:\n                return 0\n            return int(nums[pos]>nums[pos+1] and nums[pos]>nums[pos-1])\n        st = SegmentTree(treels)\n        res = []\n        for id, l, r in queries:\n            if id == 1:\n                res.append(st.query_interval(l+1, r-1))\n            else:\n                nums[l] = r\n                s, e = max(0, l-1), min(l+1, n-1)\n                for i in range(s, e+1):\n                    if ispeak(i) != st.nums[i]:\n                        st.update_point(i, ispeak(i))\n        return res",
    "submit_ts": 1718508411.0
}