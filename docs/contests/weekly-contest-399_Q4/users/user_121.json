{
    "username": "dk_sensei",
    "submission": "    #define ll long long\n\nstruct Tree {\n     typedef struct node{\n         ll lr,l1r,lr1,l1r1;\n     } T;\n     static constexpr T unit = {0, 0, 0, 0};\n     T f(T a, T b){\n          T res;\n          res.lr = max({a.lr1+b.l1r, a.lr+b.l1r,a.lr1+b.lr});\n          res.l1r = max({a.l1r1+b.l1r, a.l1r+b.l1r,a.l1r1+b.lr});\n          res.lr1 = max({a.lr1+b.l1r1, a.lr+b.l1r1,a.lr1+b.lr1});\n          res.l1r1 = max({a.l1r1+b.l1r1, a.l1r+b.l1r1,a.l1r1+b.lr1});\n          return res;\n     } // (any associative fn)\n     vector<T> s;\n     int n;\n     Tree(int n = 0, T def = unit): s(2 * n, def), n(n) {}\n     void update(int pos, T val) {\n          for (s[pos += n] = val; pos /= 2;)\n               s[pos] = f(s[pos * 2], s[pos * 2 + 1]);\n     }\n     T query(int b, int e) { // query [b, e)\n          T ra = unit, rb = unit;\n          for (b += n, e += n; b < e; b /= 2, e /= 2) {\n               if (b % 2) ra = f(ra, s[b++]);\n               if (e % 2) rb = f(s[--e], rb);\n          }\n          return f(ra, rb);\n     }\n};\n\n\nclass Solution {\npublic:\n    const int md=1e9+7;\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        Tree T(n+1);\n        for(int i=0;i<n;i++){\n            if(nums[i]<0) nums[i]=0;\n            T.update(i,{nums[i],0,0,0});\n        }\n        ll ans=0;\n        for(auto q:queries){\n          ll ind=q[0],val=q[1];\n          if(val<0) val=0;\n          T.update(ind,{val,0,0,0});\n          auto res=T.query(0,n+1);\n          ll x=max({res.lr,res.l1r,res.lr1,res.l1r1});\n          ans=(ans+x)%md;\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716694460.0
}