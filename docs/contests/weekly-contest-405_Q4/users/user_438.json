{
    "username": "mikeqiyh",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"O3,unroll-loops\")\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<pi> vpi;\ntypedef vector<pll> vpll;\ntypedef vector<ld> vld;\n#define ms(x, a) memset(x, a, sizeof(x))\n#define siz(x) (int)x.size()\n#define len(x) (int)x.length()\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define F first\n#define S second\n#define FOR(i, x) for (int i = 0; i < x; i++)\nconst int NO_DEB = 1;\n#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename... Args>\nvoid logger(string vals, Args &&...values){\n    if (NO_DEB) return;\n    cout << vals << \" = \";\n    string delim = \"\";\n    (..., (cout << delim << values, delim = \", \"));\n    cout << endl;\n}\nconst int INF = 0x3f3f3f3f;\nconst ll LLINF = 0x3f3f3f3f3f3f3f3f;\nconst ll MOD = 1e9+7; //998244353;\n//===========================================\ntemplate<int MOD> struct mint {\n    static const int mod = MOD;\n     int v;\n     explicit operator int() const { return v; }\n    mint():v(0) {}\n    mint(ll _v):v(int(_v%MOD)) { v += (v<0)*MOD; }\n    mint& operator+=(mint o) {\n        if ((v += o.v) >= MOD) v -= MOD;\n        return *this; }\n    mint& operator-=(mint o) {\n        if ((v -= o.v) < 0) v += MOD;\n        return *this; }\n    mint& operator*=(mint o) {\n        v = int((ll)v*o.v%MOD); return *this; }\n    mint& operator/=(const mint& o) { return (*this) *= inv(o); }\n    friend mint pow(mint a, ll p) { assert(p >= 0);\n        return p==0?1:pow(a*a,p/2)*(p&1?a:1); }\n    friend mint inv(mint a) { assert(a.v != 0); return pow(a,MOD-2); }\n    friend mint operator+(mint a, mint b) { return a += b; }\n    friend mint operator-(mint a, mint b) { return a -= b; }\n    friend mint operator*(mint a, mint b) { return a *= b; }\n    friend mint operator/(mint a, const mint& b) { return a /= b; }\n};\nusing mi = mint<MOD>;\n//===========================================\nconst int MAX = 5e4+5;\nunordered_map<int, int> pp[MAX];\nll hh[MAX], pw[MAX] = {1};\n\nll f(string s){\n    ll ret = 0;\n    for (char c: s){\n        ret = (ret*31+(c-'a'+1))%MOD;\n    }\n    return ret;\n}\n\nll getHsh(int l, int r){\n    ll ret = hh[r];\n    if (l) ret = (ret-(hh[l-1]*pw[r-l+1])%MOD+MOD)%MOD;\n    return ret;\n}\n\nclass Solution {\npublic:\n    int minimumCost(string tar, vector<string>& words, vector<int>& val) {\n        if (pw[1] == 0){\n            for (int i = 1; i < MAX; i++) pw[i] = pw[i-1]*31%MOD;\n        }\n        vi tt;\n        for (int i = 0; i < siz(words); i++){\n            string s = words[i];\n            if (!pp[len(s)].count(f(s)) || pp[len(s)][f(s)] > val[i]){\n                pp[len(s)][f(s)] = val[i];\n            }\n            deb(s, f(s));\n            tt.pb(len(s));\n        }\n        sort(all(tt)); tt.resize(unique(all(tt))-tt.begin());\n        int n = len(tar);\n        vi dp(n, INF);\n        for (int i = 0; i < n; i++){\n            hh[i] = ((i? hh[i-1] : 0)*31+(tar[i]-'a'+1))%MOD;\n            for (int x: tt){\n                if (x > i+1) break;\n                ll hsh = getHsh(i-x+1, i);\n                deb(x, hsh);\n                if (pp[x].count(hsh)){\n                    //deb(i, x);\n                    dp[i] = min(dp[i], (i-x < 0? 0 : dp[i-x])+pp[x][hsh]);\n                }\n            }\n            deb(i, dp[i]);\n        }\n        for (int i = 0; i < siz(words); i++){\n            string s = words[i];\n            pp[len(s)].clear();\n        }\n        return (dp[n-1] == INF? -1 : dp[n-1]);\n    }\n};",
    "submit_ts": "1720321552",
    "subm_id": "1312325919"
}