{
    "username": "camillacui",
    "submission": "#define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const multiset<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntemplate <class T> auto vect(const T& v, int n) { return vector<T>(n, v); }\ntemplate <class T, class... D> auto vect(const T& v, int n, D... m) {\n  return vector<decltype(vect(v, m...))>(n, vect(v, m...));\n}\n\nusing int64 = long long;\nusing int128 = __int128_t;\nusing ii = pair<int, int>;\n#define SZ(x) (int)((x).size())\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nmt19937_64 mrand(random_device{}());\nint64 rnd(int64 x) { return mrand() % x; }\nconstexpr inline int lg2(int64 x) { return x == 0 ? -1 : sizeof(int64) * 8 - 1 - __builtin_clzll(x); }\nconstexpr inline int64 p2ceil(int64 x) { return 1LL << (lg2(x - 1) + 1); }\ntemplate <class T> void out(const vector<T>& a) { for (int i = 0; i < SZ(a); ++i) cout << a[i] << \" \\n\"[i + 1 == SZ(a)]; }\ntemplate <class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate <class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate <class T> void dedup(vector<T>& v) { sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); }\ninline void add_mod(int& x, int y) { x += y; if (x >= MOD) x -= MOD; }\ninline void sub_mod(int& x, int y) { x += MOD - y; if (x >= MOD) x -= MOD; }\ninline int mod(int x) { return x >= MOD ? x - MOD : x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\ntemplate<size_t N,\n         class T,\n         T (*op)(const T&, const T&),\n         T (*e)()>\nstruct SegmentTree {\n  struct Node {\n    Node *left, *right;\n    T val;\n    void pushup() { val = op(left->val, right->val); }\n  };\n  Node pool[N << 1], *last, *rt;\n  int n;\n  SegmentTree(const vector<T>& v): n(SZ(v)) {\n    last = pool;\n    rt = build(0, n, v);\n  }\n  SegmentTree(int n): SegmentTree(vector<T>(n, e())) {}\n  Node* build(int a, int b, const vector<T>& v) {\n    Node* ret = last++;\n    if (a + 1 == b) { ret->val = v[a]; return ret; }\n    int mid = (a + b) / 2;\n    ret->left = build(a, mid, v);\n    ret->right = build(mid, b, v);\n    ret->pushup();\n    return ret;\n  }\n  void set(int pos, T val) { return set(rt, 0, n, pos, val); }\n  void set(Node* cur, int a, int b, int pos, T val) {\n    if (pos < a || pos >= b) return;\n    if (a + 1 == b) { cur->val = val; return; }\n    int mid = (a + b) / 2;\n    set(cur->left, a, mid, pos, val);\n    set(cur->right, mid, b, pos, val);\n    cur->pushup();\n  }\n  T query(int ll, int rr) { return query(rt, 0, n, ll, rr); }\n  T query(Node* cur, int a, int b, int ll, int rr) {\n    if (ll >= rr || a >= rr || b <= ll) return e();\n    if (a >= ll && b <= rr) return cur->val;\n    int mid = (a + b) / 2;\n    return op(query(cur->left, a, mid, ll, rr), query(cur->right, mid, b, ll, rr));\n  }\n};\n\nconst int N = 1e5 + 10;\n\n// sum\ntemplate<typename T> T add(const T& a, const T& b) { return a + b; }\ntemplate<typename T> T id() { return T(); }\nusing segtree = SegmentTree<N, int, add, id>;\n\nclass Solution {\npublic:\n  vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& queries) {\n    int n = a.size();\n    vector<int> v(n);\n    for (int i = 1; i < n - 1; ++i) v[i] = a[i] > a[i - 1] && a[i] > a[i + 1];\n    segtree tr(v);\n    vector<int> ret;\n    for (auto& v : queries) {\n      int op = v[0];\n      if (op == 1) {\n        int L = v[1], R = v[2] + 1;\n        ret.push_back(tr.query(L + 1, R - 1));\n      } else {\n        int x = v[1], val = v[2];\n        a[x] = val;\n        auto check =\n          [&](int x) {\n            return (x - 1 >= 0 && x + 1 < n && a[x] > a[x - 1] && a[x] > a[x + 1]);\n          };\n        tr.set(x, check(x));\n        if (x - 1 >= 0) tr.set(x - 1, check(x - 1));\n        if (x + 1 < n) tr.set(x + 1, check(x + 1));\n      }\n    }\n    return ret;\n  }\n};\n",
    "submit_ts": "1718505815",
    "subm_id": "539770789"
}