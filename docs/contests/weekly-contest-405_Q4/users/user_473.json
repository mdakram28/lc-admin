{
    "username": "Consistent_Contest",
    "submission": "class Solution {\npublic:\n    struct TrieNode {\n        unordered_map<char, TrieNode*> children; // Map of character to TrieNode pointer\n        vector<pair<int, int>> wordEnds; // Vector of pairs (index, cost)\n    };\n\n    class Trie {\n    public:\n        TrieNode* root; // Root of the Trie\n        Trie() { root = new TrieNode(); } // Initialize root\n\n        // Function to insert a word with its index and cost into the Trie\n        void insert(string& word, int index, int cost) {\n            TrieNode* node = root;\n            for (char c : word) {\n                if (!node->children.count(c))\n                    node->children[c] = new TrieNode();\n                node = node->children[c];\n            }\n            node->wordEnds.push_back({index, cost});\n        }\n    };\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        string target_string = target; \n        vector<string> words_vector = words;\n        vector<int> costs_vector = costs;\n        int target_size = target_string.size(); // Size of the target string\n        vector<int> dp(target_size + 1, INT_MAX); // DP array to store minimum cost to form each prefix of target string\n        dp[0] = 0; // Base case: cost to form an empty string is 0\n\n        Trie trie; // Trie object to store words and their costs\n        for (int i = 0; i < words_vector.size(); ++i) {\n            trie.insert(words_vector[i], i, costs_vector[i]); // Insert each word with its index and cost into the Trie\n        }\n\n        // Iterate over each position in the target string\n        for (int i = 0; i < target_size; ++i) {\n            if (dp[i] == INT_MAX) continue; // Skip if current prefix cannot be formed\n\n            TrieNode* node = trie.root; // Start from the root of the Trie\n            // Try to match characters from current position to end of target string\n            for (int j = i; j < target_size; ++j) {\n                if (!node->children.count(target_string[j])) break; // If character not found in Trie, break\n                node = node->children[target_string[j]]; // Move to the child node for the current character\n                // Update dp array for each valid word ending at current position j\n                for (auto& p : node->wordEnds) {\n                    int word_index = p.first; // Index of the word in words_vector\n                    int word_cost = p.second; // Cost associated with forming this word\n                    int word_length = words_vector[word_index].size(); // Length of the word\n                    // Update dp array if forming this word is cheaper\n                    if (i + word_length <= target_size) {\n                        dp[i + word_length] = min(dp[i + word_length], dp[i] + word_cost);\n                    }\n                }\n            }\n        }\n\n        // Return minimum cost to form the entire target string, or -1 if not possible\n        return dp[target_size] == INT_MAX ? -1 : dp[target_size];\n    }\n};\n      ",
    "submit_ts": "1720322540",
    "subm_id": "1312352637"
}