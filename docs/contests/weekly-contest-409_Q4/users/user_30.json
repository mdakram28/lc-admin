{
    "username": "2499370956",
    "submission": "class Solution {\n    public List<Integer> numberOfAlternatingGroups(int[] colors, int[][] queries) {\n        int n = colors.length;\n\n        TreeSet<Integer> same = new TreeSet<>();\n        same.add(0);\n        same.add(n);\n        for (int i = 1; i < n; i++) {\n            if (colors[i] == colors[i - 1]) {\n                same.add(i);\n            }\n        }\n\n        CountingMap<Integer> intervalSizes = new CountingMap<>();\n        int start = 0;\n        while (start < n) {\n            int next = same.higher(start);\n            intervalSizes.addOneCount(next - start);\n            start = next;\n        }\n\n//        System.out.println(intervalSizes);\n\n        List<Integer> out = new ArrayList<>();\n        for (int[] q : queries) {\n            if (q[0] == 1) {\n                // count\n                int size = q[1];\n                int count = 0;\n                Integer s = intervalSizes.ceilingKey(size);\n                while (s != null) {\n                    count += intervalSizes.get(s) * (s - size + 1);\n                    s = intervalSizes.higherKey(s);\n                }\n                if (colors[0] != colors[n - 1]) {\n                    int prefix = Math.min(size - 1, same.higher(0));\n                    int suffix = Math.min(size - 1, n - same.lower(n));\n                    count += Math.max(0, prefix + suffix - size + 1);\n                }\n                out.add(count);\n            } else if (q[0] == 2) {\n                // change color\n                int index = q[1];\n                int color = q[2];\n                if (colors[index] == color) {\n                    continue;\n                }\n\n                if (index > 0) {\n                    if (colors[index] == colors[index - 1]) {\n                        same.remove(index);\n                        int prevSize = index - same.lower(index);\n                        int nextSize = same.higher(index) - index;\n                        intervalSizes.removeOneCount(prevSize);\n                        intervalSizes.removeOneCount(nextSize);\n                        intervalSizes.addOneCount(prevSize + nextSize);\n                    } else {\n                        same.add(index);\n                        int prevSize = index - same.lower(index);\n                        int nextSize = same.higher(index) - index;\n                        intervalSizes.addOneCount(prevSize);\n                        intervalSizes.addOneCount(nextSize);\n                        intervalSizes.removeOneCount(prevSize + nextSize);\n                    }\n                }\n\n                if (index < n - 1) {\n                    int i = index + 1;\n                    if (colors[index] == colors[index + 1]) {\n                        same.remove(i);\n                        int prevSize = i - same.lower(i);\n                        int nextSize = same.higher(i) - i;\n                        intervalSizes.removeOneCount(prevSize);\n                        intervalSizes.removeOneCount(nextSize);\n                        intervalSizes.addOneCount(prevSize + nextSize);\n                    } else {\n                        same.add(i);\n                        int prevSize = i - same.lower(i);\n                        int nextSize = same.higher(i) - i;\n                        intervalSizes.addOneCount(prevSize);\n                        intervalSizes.addOneCount(nextSize);\n                        intervalSizes.removeOneCount(prevSize + nextSize);\n                    }\n                }\n\n                colors[index] = color;\n            }\n        }\n\n        return out;\n    }\n\n    class CountingMap<T> extends TreeMap<T, Integer> {\n        long count = 0;\n\n        public void addOneCount(T k) {\n            count++;\n            put(k, 1 + getOrDefault(k, 0));\n        }\n\n        public void removeOneCount(T k) {\n            count--;\n            int v = getOrDefault(k, 0) - 1;\n            if (v <= 0) {\n                remove(k);\n            } else {\n                put(k, v);\n            }\n        }\n\n        public long getCount() {\n            return count;\n        }\n\n        @Override\n        public CountingMap<T> clone() {\n            CountingMap<T> clone = new CountingMap<>();\n            clone.count = this.count;\n            for (Map.Entry<T, Integer> e : this.entrySet()) {\n                clone.put(e.getKey(), e.getValue());\n            }\n            return clone;\n        }\n    }\n}",
    "submit_ts": "1722743587",
    "subm_id": "1343795316"
}