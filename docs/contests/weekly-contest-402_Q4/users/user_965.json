{
    "username": "gautam_311",
    "submission": "class SegmentTree {\nprivate:\n    std::vector<int> tree;\n    int n;\n\n    void build(const std::vector<bool>& peaks, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = peaks[start] ? 1 : 0;\n        } else {\n            int mid = (start + end) / 2;\n            build(peaks, 2 * node, start, mid);\n            build(peaks, 2 * node + 1, mid + 1, end);\n            tree[node] = tree[2 * node] + tree[2 * node + 1];\n        }\n    }\n\n    void update(int node, int start, int end, int idx, bool isPeak) {\n        if (start == end) {\n            tree[node] = isPeak ? 1 : 0;\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid) {\n                update(2 * node, start, mid, idx, isPeak);\n            } else {\n                update(2 * node + 1, mid + 1, end, idx, isPeak);\n            }\n            tree[node] = tree[2 * node] + tree[2 * node + 1];\n        }\n    }\n\n    int query(int node, int start, int end, int l, int r) {\n        if (r < start || end < l) {\n            return 0;\n        }\n        if (l <= start && end <= r) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int left_query = query(2 * node, start, mid, l, r);\n        int right_query = query(2 * node + 1, mid + 1, end, l, r);\n        return left_query + right_query;\n    }\n\npublic:\n    SegmentTree(const std::vector<bool>& peaks) {\n        n = peaks.size();\n        tree.resize(4 * n, 0);\n        build(peaks, 1, 0, n - 1);\n    }\n\n    void update(int idx, bool isPeak) {\n        update(1, 0, n - 1, idx, isPeak);\n    }\n\n    int query(int l, int r) {\n        if (l > r) return 0;\n        return query(1, 0, n - 1, l, r);\n    }\n};\n\nclass Solution {\n    \n\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n       int n = nums.size();\n        std::vector<int> answer;\n\n        // Helper function to determine if an element at index i is a peak\n        auto is_peak = [&](int i) -> bool {\n            if (i <= 0 || i >= n - 1) return false;\n            return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n        };\n\n        // Initial peak calculation\n        std::vector<bool> peaks(n, false);\n        for (int i = 1; i < n - 1; ++i) {\n            peaks[i] = is_peak(i);\n        }\n\n        // Build the segment tree for initial peaks\n        SegmentTree segTree(peaks);\n\n        for (const auto& query : queries) {\n            int type = query[0];\n            if (type == 1) {\n                // Count peaks in range [li, ri]\n                int li = query[1];\n                int ri = query[2];\n                if (ri - li <= 1) {\n                    answer.push_back(0);\n                } else {\n                    answer.push_back(segTree.query(li + 1, ri - 1));\n                }\n            } else if (type == 2) {\n                // Update nums[indexi] to vali\n                int index = query[1];\n                int val = query[2];\n                nums[index] = val;\n\n                // Update peak status for index and its neighbors in the segment tree\n                for (int i = std::max(1, index - 1); i <= std::min(n - 2, index + 1); ++i) {\n                    segTree.update(i, is_peak(i));\n                }\n            }\n        }\n\n        return answer;\n    }\n};",
    "submit_ts": 1718508304.0
}