{
    "username": "vandorlot",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        distance = {}\n        def half_diameter(edge_list):\n            adjacency_list = defaultdict(list)\n            \n            for n1, n2 in edge_list:\n                adjacency_list[n1].append(n2)\n                adjacency_list[n2].append(n1)\n            \n            def bfs_last_node(node):\n                nonlocal distance\n                distance = {node: 0}\n                queue = deque([node])\n                visited = set()\n                exploring = node\n                while queue:\n                    exploring = queue.popleft()\n                    visited.add(exploring)\n                    \n                    for neighbor in adjacency_list[exploring]:\n                        if neighbor not in visited:\n                            distance[neighbor] = distance[exploring] + 1\n                            queue.append(neighbor)\n                return exploring\n            \n            first = bfs_last_node(0)\n            second = bfs_last_node(first)\n            return distance[second]\n                \n                        \n                    \n        return max(half_diameter(edges1), half_diameter(edges2), 1 + math.ceil(half_diameter(edges2) / 2) + math.ceil(half_diameter(edges1) / 2))\n        \n",
    "submit_ts": "1719718126",
    "subm_id": "1304409401"
}