{
    "username": "FSPINDLE",
    "submission": "\n\n\nusing ll = long long;\n   struct node{\n         \n          ll ans,lazy;\n          node(){\n              this->ans=0;  \n              this->lazy=0;      \n          }\n      };\n      \n      class segTree{\n         \n            public:\n             \n            vector<node>Tree;\n\n            segTree(ll n){\n                 Tree.resize(4*n);\n            }\n\n            node merge(node node1,node node2){\n\n                 node nd;\n                 nd.ans=node1.ans+node2.ans;\n                 return nd;\n\n            }\n\n            void push(ll idx,ll l,ll r){\n                 \n                 // Apply lazy\n                  if(Tree[idx].lazy){\n                       Tree[idx].ans+=(r-l+1)*Tree[idx].lazy;             \n                // pushdown lazy;\n                  if(l!=r){\n                     Tree[2*idx].lazy+=Tree[idx].lazy;\n                     Tree[2*idx+1].lazy+=Tree[idx].lazy;\n                  }\n                   Tree[idx].lazy=0;\n                  }\n            }\n\n            node build(ll idx,ll l,ll r,vector<ll>&arr){\n                  \n                  if(l==r) {\n                     Tree[idx].ans=arr[l];\n                     return Tree[idx];\n                  }\n                  \n                   ll mid=(l+r)/2;\n\n                 return  Tree[idx]=merge(build(2*idx,l,mid,arr),build(2*idx+1,mid+1,r,arr));\n            }\n\n            ll query(ll idx,ll l,ll r,ll L,ll R){\n                     \n                     push(idx,l,r);\n\n                   if(l>=L&&r<=R) {\n                        push(idx,l,r);\n                        return Tree[idx].ans;\n                   }\n                   if(l>R||r<L) return 0;\n\n                   ll mid=(l+r)/2;\n\n                   return query(2*idx,l,mid,L,R)+query(2*idx+1,mid+1,r,L,R);\n            }\n            \n            void update(ll idx,ll l,ll r,ll L,ll R,ll val){\n                       \n                    push(idx,l,r);\n                    if(l>=L&&r<=R){\n                         Tree[idx].lazy+=val;\n                         push(idx,l,r);\n                         return; \n                    }\n                    if(l>R||r<L) return ;\n\n                    ll mid=(l+r)/2;\n\n                    update(2*idx,l,mid,L,R,val);\n                    update(2*idx+1,mid+1,r,L,R,val);\n                    Tree[idx]=merge(Tree[2*idx],Tree[2*idx+1]);\n            }\n\n      };\n       \n\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n           \n            \n                     ll n = nums.size() ;\n                     vector<ll>arr(n) ;\n                      vector<int>ans;\n            \n                   for(ll i = 1 ; i < n - 1 ; i ++){\n                              arr[i] = (nums[i] > max(nums[i - 1] , nums[i + 1])) ;\n                   }\n                    \n                    segTree ST(n) ;\n                    ST.build(1 , 0 , n - 1 , arr);\n             \n             auto do_  = [&](ll idx ) -> void {\n                     \n                     if(idx == 0 || idx == n - 1) return ;\n                     \n                     ll prev =  ST.query(1 , 0 , n - 1 , idx , idx ) ; \n                     ll curr = (nums[idx] > max(nums[idx - 1] ,nums[idx + 1])) ;\n                     \n                     if(prev){\n                               if(!curr) ST.update(1 , 0 , n - 1 , idx , idx , -1) ; \n                     }\n                     else {\n                              if(curr)  ST.update(1 , 0 , n - 1 , idx , idx , 1) ; \n                      }\n                     \n             } ;\n                   \n             for(auto it : queries){\n                        ll type = it[0] ; \n                     \n                       if(type == 1){\n                                 ll l = it[1] , r = it[2] ;\n                                 ll ret = 0 ;\n                                 if(r - l + 1 > 2 )ret =  ST.query(1 , 0 , n - 1 , l + 1 , r - 1) ;\n                                ans.push_back(ret) ;\n                       }\n                     else{\n                              ll idx = it[1] , val  = it[2] ;\n                              nums[idx] = val ;\n                               do_(idx) ;\n                               if(idx) do_(idx - 1) ;\n                              if(idx < n - 1) do_(idx + 1) ;\n                     }\n             }\n                return ans;     \n    }\n};\n\n\n\n",
    "submit_ts": 1718507204.0
}