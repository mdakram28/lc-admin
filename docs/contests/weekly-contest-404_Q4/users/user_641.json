{
    "username": "leetcodeyu1990",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def bfs_farthest_node(start, graph):\n            q = deque([start])\n            visited = {start}\n            farthest_node = start\n            dist = 0\n\n            while q:\n                size = len(q)\n                for _ in range(size):\n                    node = q.popleft()\n                    farthest_node = node\n                    for neighbor in graph[node]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            q.append(neighbor)\n                dist += 1\n\n            return farthest_node, dist - 1\n\n        def tree_diameter(n, edges):\n            if n == 1:\n                return 0\n            graph = defaultdict(list)\n            for u, v in edges:\n                graph[u].append(v)\n                graph[v].append(u)\n\n            # Find one endpoint of the longest path in the tree\n            farthest_node, _ = bfs_farthest_node(0, graph)\n            # Find the actual longest path in the tree\n            farthest_node, diameter = bfs_farthest_node(farthest_node, graph)\n\n            return diameter\n\n        def tree_radius(diameter):\n            return (diameter + 1) // 2\n\n        n = len(edges1) + 1\n        m = len(edges2) + 1\n        diameter1 = tree_diameter(n, edges1)\n        diameter2 = tree_diameter(m, edges2)\n\n        radius1 = tree_radius(diameter1)\n        radius2 = tree_radius(diameter2)\n\n        return max(diameter1, diameter2, radius1 + radius2 + 1)\n        ",
    "submit_ts": "1719719403",
    "subm_id": "1304441141"
}