{
    "username": "LostFromKanto",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define LINF (ll)1e18\n#define f first\n#define s second\n#define rep(i,a,b) for (int i=a; i<b; ++i)\n#define setpr(x) cout<<setprecision(x)<<fixed\n#define sz(v) int(v.size())\n#define all(v) v.begin(),v.end()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\n\ntemplate <typename T> T mod(T a, T mod = MOD){ a %= mod; if (a<0) a += mod; return a; }\ntemplate <typename T> T add(T a, T b, T mod = MOD){ return (a+b)%mod; }\ntemplate <typename T> T sub(T a, T b, T mod = MOD){ return (a-b+mod)%mod; };\ntemplate <typename T> T mul(T a, T b, T mod = MOD){ return (a * 1ll * b) % mod; }\ntemplate <typename T> T binPow(T a, T b, T mod = MOD){ T res = 1; while (b>0){ if (b&1) res = mul<T>(res, a, mod); a = mul<T>(a,a, mod); b >>= 1; } return res; }\ntemplate <typename T> T binPowNoMod(T a, T b){ T res = 1; while (b>0){ if (b&1) res *= a; a *= a; b >>= 1; } return res; }\ntemplate <typename T> T divMod(T a, T b, T mod = MOD){ return mul(a, binPow(b, mod-2, mod), mod); }\n\ntemplate <typename Node, typename T>\nstruct SegmentTree{\n  vector<Node> t;\npublic:\n  int n;\n  SegmentTree(vector<T> &a): n(sz(a)){\n    t.resize(4*n);\n    build(a);\n  }\n  \n  SegmentTree(int n): n(n){\n    t.resize(4*n);\n    fill(all(t),Node());\n  }\n  \n  void build(vector<T> &a){\n    build(a, 0, n-1, 1);\n  }\n  \n  void update(int pos, T diff){\n    update(0, n-1, 1, pos, diff);\n  }\n  \n  Node query(int l, int r){\n    return query(0, n-1, 1, l, r);\n  }\n  \nprivate:\n  void build(vector<T> &a, int l, int r, int curInd){\n    if (l==r){\n      t[curInd] = Node(a[l]);\n      return;\n    }\n    \n    int mid = l+(r-l)/2;\n    build(a,l,mid,2*curInd);\n    build(a,mid+1,r,2*curInd+1);\n    t[curInd].merge(t[2*curInd],t[2*curInd+1]);\n  }\n  \n  void update(int l, int r, int i, int pos, T diff){\n    if (l==r){\n      t[i] = Node(diff);\n      return;\n    }\n    int mid = l+(r-l)/2;\n    if (pos<= mid) update(l, mid, 2*i, pos, diff);\n    else update(mid+1, r, 2*i+1, pos, diff);\n    t[i] = Node();\n    t[i].merge(t[2*i], t[2*i+1]);\n  }\n  \n  Node query(int l, int r, int curInd, int targetL, int targetR){\n    if (targetL>targetR) return Node();\n    if (l==targetL && r==targetR) {\n      return t[curInd];\n    }\n    \n    int mid = l+(r-l)/2;\n    Node ret, node_l = query(l, mid, 2*curInd, targetL, min(mid,targetR)), node_r = query(mid+1, r, 2*curInd+1, max(mid+1,targetL), targetR);\n    ret.merge(node_l,node_r);\n    return ret;\n  }\n};\n\nstruct Node1{\n  ll val = 0;\n  \n  Node1(){\n    val = 0;\n  }\n  \n  Node1(ll v){\n    val = v;\n  }\n  \n  void merge(Node1& l, Node1& r){\n    val = l.val + r.val;\n  }\n};\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = int(nums.size());\n        vector<int> a(n);\n        rep(i,1,n-1) a[i] = (nums[i]>nums[i-1] && nums[i]>nums[i+1]) ? 1 : 0;\n        \n        for (int i: a) cout<<i<<\" \";\n        cout<<endl;\n        \n        SegmentTree<Node1,int> st(a);\n        vector<int> res;\n        for (auto v: queries){\n            int op = v[0];\n            if (op==1){\n                int l = v[1];\n                int r = v[2];\n                res.push_back(st.query(l+1,r-1).val);\n            }else{\n                int ind = v[1];\n                int val = v[2];\n                \n                nums[ind] = val;\n                \n                for (int i=max(ind-1,1); i<=min(ind+1,n-2); i++){\n                    if (i>0 && i<n-1) {\n                        // cout<<\"Updating \"<<i<<\" \"<<(nums[i]>nums[i-1] && nums[i]>nums[i+1])<<endl;\n                        st.update(i, nums[i]>nums[i-1] && nums[i]>nums[i+1]);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1718506894.0
}