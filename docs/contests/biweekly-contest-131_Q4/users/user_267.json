{
    "username": "nyp00n",
    "submission": "#include <vector>\n#include <set>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nclass SegmentTree {\npublic:\n    SegmentTree(int n) : n(n), tree(4 * n, 0) {}\n\n    void update(int pos, int value) {\n        update(1, 0, n - 1, pos, value);\n    }\n\n    int query(int left, int right) {\n        return query(1, 0, n - 1, left, right);\n    }\n\n    int firstNonZero(int x) {\n        int left = 0, right = x;\n        int ans = 0;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (query(x - mid, x) == 0) {\n                left = mid + 1;\n                ans = mid;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return x - ans;\n    }\n\nprivate:\n    int n;\n    vector<int> tree;\n\n    void update(int node, int start, int end, int pos, int value) {\n        if (start == end) {\n            tree[node] = value;\n        } else {\n            int mid = (start + end) / 2;\n            if (pos <= mid) {\n                update(2 * node, start, mid, pos, value);\n            } else {\n                update(2 * node + 1, mid + 1, end, pos, value);\n            }\n            tree[node] = max(tree[2 * node], tree[2 * node + 1]);\n        }\n    }\n\n    int query(int node, int start, int end, int left, int right) {\n        if (right < start || end < left) {\n            return 0;  // Return the minimum value (as we are looking for maximum gaps)\n        }\n        if (left <= start && end <= right) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int q1 = query(2 * node, start, mid, left, right);\n        int q2 = query(2 * node + 1, mid + 1, end, left, right);\n        return max(q1, q2);\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        set<int> obstacles = {0, 200000};\n        SegmentTree segTree(200001);\n\n        // Initialize the segment tree with the initial gap\n        segTree.update(0, 1);\n\n        vector<bool> results;\n\n        for (const auto& query : queries) {\n            if (query[0] == 1) {\n                int x = query[1];\n\n                auto it = obstacles.insert(x).first;\n\n                auto prevIt = prev(it);\n                auto nextIt = next(it);\n\n                int left = *prevIt;\n                int right = *nextIt;\n\n                segTree.update(x, x - left);\n                segTree.update(right, right - x);\n\n            } else if (query[0] == 2) {\n                int x = query[1];\n                int sz = query[2];\n\n                int maxGap = segTree.query(0, x);\n                int distanceToNonZero = x - segTree.firstNonZero(x) + 1;\n               // cout << maxGap << '\\n';\n            //    cout << distanceToNonZero << '\\n';\n\n                bool canPlace = (x >= sz) && (maxGap >= sz || (distanceToNonZero >= sz));\n                results.push_back(canPlace);\n                \n            }\n        }\n\n        return results;\n    }\n};\n\n",
    "submit_ts": 1716651389.0
}