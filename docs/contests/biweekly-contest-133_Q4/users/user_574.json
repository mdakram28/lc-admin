{
    "username": "rohitsadhu",
    "submission": "package main\n\nimport (\n    \"fmt\"\n)\n\n// Main function to determine the number of permutations meeting the requirements\nfunc numberOfPermutations(n int, requirements [][]int) int {\n    // Create a map to hold inversion count requirements\n    inversion_Count_Reqs := make(map[int]int) // Map to store inversion requirements\n    for _, req := range requirements {\n        // Adjust 1-based index and store in map\n        inversion_Count_Reqs[req[0]+1] = req[1] // Store requirements in map\n    }\n\n    // Initialize DP table\n    permutation_Counts := initialize_DP_Table(n) // Initialize DP table\n\n    // Update DP table and enforce requirements for each length\n    for current_Length := 1; current_Length <= n; current_Length++ {\n        update_DP_Table(permutation_Counts, current_Length) // Update DP table\n        enforce_Requirements(permutation_Counts, inversion_Count_Reqs, current_Length) // Enforce requirements\n    }\n\n    return calculate_Result(permutation_Counts, n) // Calculate and return the final result\n}\n\n// Function to initialize the DP table\nfunc initialize_DP_Table(n int) [][]int {\n    // Create a 2D slice for DP table\n    d_p := make([][]int, n+1) // d_p holds the DP table with n+1 rows\n    for i := range d_p {\n        // Initialize each row with _chu_de+1 columns\n        d_p[i] = make([]int, _chu_de+1) // Each row has _chu_de+1 columns\n    }\n    // Base case: one way to have 0 inversions with 0 length\n    d_p[0][0] = 1 // Set base case value\n    return d_p // Return the initialized DP table\n}\n\n// Function to calculate the final result from the DP table\nfunc calculate_Result(permutation_Counts [][]int, n int) int {\n    // Initialize result count\n    result_Count := 0 // Result accumulator\n    for _, count := range permutation_Counts[n] {\n        // Sum up all valid permutation counts\n        result_Count = (result_Count + count) % mod_archod // Add count to result with modulo\n    }\n    return result_Count // Return the final result\n}\n\n// Function to update the DP table with permutation counts for the current length\nfunc update_DP_Table(permutation_Counts [][]int, current_Length int) {\n    for inv_Count := 0; inv_Count <= _chu_de; inv_Count++ {\n        for position := 0; position < current_Length; position++ {\n            // Calculate the previous inversion count\n            prev_Inversion_Count := inv_Count - position // Previous inversion count\n            if prev_Inversion_Count >= 0 {\n                // Update the permutation count using previous length's values\n                permutation_Counts[current_Length][inv_Count] = \n                    (permutation_Counts[current_Length][inv_Count] + \n                    permutation_Counts[current_Length-1][prev_Inversion_Count]) % mod_archod // Update DP table\n            }\n        }\n    }\n}\n\n// Function to enforce specific inversion requirements on the DP table\nfunc enforce_Requirements(permutation_Counts [][]int, inversion_Count_Reqs map[int]int, current_Length int) {\n    // Check if there are specific inversion requirements for the current length\n    if target_Inversions, exists := inversion_Count_Reqs[current_Length]; exists { // Check for specific requirements\n        for inv_Count := 0; inv_Count <= _chu_de; inv_Count++ {\n            // Invalidate permutations not meeting the requirement\n            if inv_Count != target_Inversions { // If current inv count doesn't match target\n                permutation_Counts[current_Length][inv_Count] = 0 // Set to 0 if it doesn't meet the requirement\n            }\n        }\n    }\n}\n\n\nconst mod_archod = 1000000007 // Large prime number for modulo operations\nconst _chu_de = 400           // Maximum number of inversions considered",
    "submit_ts": "1719070691",
    "subm_id": "1296829366"
}