{
    "username": "Gavieeen",
    "submission": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n    \n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\nclass Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        n = len(target)\n        pq = [(0, 0)]  # (current cost, index in target)\n        min_cost = [float('inf')] * (n + 1)\n        min_cost[0] = 0\n        \n        trie = Trie()\n        word_to_cost, max_word, trie = {}, 0, Trie()\n        for word, cost in zip(words, costs):\n            trie.insert(word)\n            max_word = max(max_word, len(word))\n            word_to_cost[word] = min(word_to_cost.get(word, float(\"inf\")), cost)\n        \n        while pq:\n            current_cost, i = heapq.heappop(pq)\n            if i == n: return current_cost\n            if current_cost > min_cost[i]: continue\n            \n            node = trie.root\n            j = i\n            s = \"\"\n            while j < n and j < i + max_word and target[j] in node.children:\n                s += target[j]\n                node = node.children[target[j]]\n                j += 1\n                if node.is_end_of_word:\n                    new_cost = current_cost + word_to_cost[s]\n                    if new_cost < min_cost[j]:\n                        min_cost[j] = new_cost\n                        heapq.heappush(pq, (new_cost, j))\n        \n        return -1 if min_cost[n] == float('inf') else min_cost[n]\n        \n        \n        \n        \n        \n        \n        # n, words_len = len(target), len(words)\n        # pq = [(0, 0)]  # (cost, index in target)\n        # min_cost = [float('inf')] * (n + 1)\n        # min_cost[0] = 0\n\n        # def can_match(start: int, word: str) -> bool:\n        #     word_len = len(word)\n        #     if start + word_len > n: return False\n        #     for j in range(word_len):\n        #         if target[start + j] != word[j]: return False\n        #     return True\n        \n        # while pq:\n        #     current_cost, i = heapq.heappop(pq)\n        #     if i == n: return current_cost\n        #     if current_cost > min_cost[i]: continue\n            \n        #     for k in range(words_len):\n        #         word, cost = words[k], costs[k]\n        #         word_len = len(word)\n                \n        #         if can_match(i, word):\n        #             new_cost = current_cost + cost\n        #             new_index = i + word_len\n        #             if new_cost < min_cost[new_index]:\n        #                 min_cost[new_index] = new_cost\n        #                 heapq.heappush(pq, (new_cost, new_index))\n        \n        # return -1 if min_cost[n] == float('inf') else min_cost[n]",
    "submit_ts": "1720324279",
    "subm_id": "1312395752"
}