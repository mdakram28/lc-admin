{
    "username": "virinci",
    "submission": "static const int _ = []() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(nullptr);\n\treturn 0;\n}();\n\ntemplate <typename T, typename U>\nclass LazySegTree {\n\tint n;\n\tT IT;\n\tU IU;\n\tvector<T> tree;\n\tvector<U> lazy;\n\npublic:\n\tLazySegTree(const T *a, int n, T it, U iu)\n\t\t: n{n}, IT{it}, IU{iu}, tree(4 * n, IT), lazy(4 * n, IU) {\n\t\tbuild(a, 1, 0, n - 1);\n\t}\n\n\tT query(int l, int r) { return query(l, r, 1, 0, n - 1); }\n\tvoid update(int l, int r, U u) { update(l, r, u, 1, 0, n - 1); }\n\nprivate:\n\t/// Combine the values of two adjacent ranges.\n\tT combine(T l, T r) {\n\t\treturn l & r;\n\t}\n\n\t/// Apply `v`'s updates to `v`'s value.\n\tvoid apply(int v, int tl, int tr) {\n\t\tassert(lazy[v] != IU);\n\t\tif (lazy[v] < 0) {\n\t\t\ttree[v] = -lazy[v] * (tr - tl + 1);\n\t\t} else {\n\t\t\ttree[v] += lazy[v] * (tr - tl + 1);\n\t\t}\n\t}\n\n\t/// Combine an update `u` with `v`'s previous updates.\n\tvoid combine_updates(int l, int r, U u, int v, int tl, int tr) {\n\t\tassert(tl >= l && tr <= r);\n\t\tassert(u != IU);\n\n\t\tif (u < 0) {\n\t\t\tlazy[v] = u;\n\t\t} else if (lazy[v] < 0) {\n\t\t\tlazy[v] -= u;\n\t\t} else {\n\t\t\tlazy[v] += u;\n\t\t}\n\t}\n\n\tvoid build(const T *a, int v, int tl, int tr) {\n\t\tif (tl == tr) {\n\t\t\ttree[v] = a[tl];\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr) / 2;\n\t\tbuild(a, 2 * v, tl, tm);\n\t\tbuild(a, 2 * v + 1, tm + 1, tr);\n\t\ttree[v] = combine(tree[2 * v], tree[2 * v + 1]);\n\t}\n\n\t/// Apply `v`'s update on `v` and push down the update to children.\n\tvoid propagate(int v, int tl, int tr) {\n\t\tif (lazy[v] == IU) return;\n\t\tapply(v, tl, tr);\n\t\tif (tl != tr) {\n\t\t\tint tm = (tl + tr) / 2;\n\t\t\tcombine_updates(tl, tr, lazy[v], 2 * v, tl, tm);\n\t\t\tcombine_updates(tl, tr, lazy[v], 2 * v + 1, tm + 1, tr);\n\t\t}\n\t\tlazy[v] = IU;\n\t}\n\n\tT query(int l, int r, int v, int tl, int tr) {\n\t\tif (r < tl || l > tr) return IT;\n\t\tpropagate(v, tl, tr);\n\t\tif (l <= tl && r >= tr) return tree[v];\n\t\tint tm = (tl + tr) / 2;\n\t\treturn combine(query(l, r, 2 * v, tl, tm), query(l, r, 2 * v + 1, tm + 1, tr));\n\t}\n\n\t/// Apply an update `u` that was meant for `[l, r]` on `[tl, tr]`.\n\tvoid update(int l, int r, U u, int v, int tl, int tr) {\n\t\t// NOTE: Putting this propagate call after the 1st or 2nd if block doesn't work. Why???\n\t\t// This caused CSES Polynomial Queries to fail.\n\t\t// Should this be done in query too? Who knows.\n\t\tpropagate(v, tl, tr);\n\n\t\tif (r < tl || l > tr) return;\n\t\tif (l <= tl && r >= tr) {\n\t\t\tcombine_updates(l, r, u, v, tl, tr);\n\t\t\tpropagate(v, tl, tr);\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr) / 2;\n\t\tupdate(l, r, u, 2 * v, tl, tm);\n\t\tupdate(l, r, u, 2 * v + 1, tm + 1, tr);\n\t\ttree[v] = combine(tree[2 * v], tree[2 * v + 1]);\n\t}\n};\n\nclass Solution {\npublic:\n\tint minimumDifference(vector<int>& nums, int k) {\n\t\tint n = ssize(nums);\n\t\tLazySegTree<int, int> tree(nums.data(), n, (1 << 30) - 1, 0);\n\t\tlong long ans = numeric_limits<long long>::max();\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint lo = i - 1, hi = n;\n\t\t\twhile (lo + 1 < hi) {\n\t\t\t\tint mi = (lo + hi) >> 1;\n\t\t\t\tif (tree.query(i, mi) >= k) lo = mi;\n\t\t\t\telse hi = mi;\n\t\t\t}\n\n\t\t\tif (lo >= i) ans = min(ans, abs(1LL * tree.query(i, lo) - k));\n\t\t\tif (hi  < n) ans = min(ans, abs(1LL * tree.query(i, hi) - k));\n\t\t}\n\n\t\treturn ans;\n\t}\n};",
    "submit_ts": "1717299028",
    "subm_id": "1274799435"
}