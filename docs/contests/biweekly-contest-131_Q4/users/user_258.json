{
    "username": "yumkam",
    "submission": "#ifndef SEGMENT_TREE_NREC_HPP\n#define SEGMENT_TREE_NREC_HPP\n// requires: -std=c++17 (or greater) [std::gcd, std::as_const]\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <algorithm>\n#if __cplusplus > 201703L\n#include <bit>\n#endif\n// See https://codeforces.com/blog/entry/18051\n// Title: \"Efficient and easy segment trees\"\n// Author: Al.Cash <https://codeforces.com/profile/Al.Cash>\n// Date: 2015-05-23 13:51\nnamespace SegmentTree {\n    template <typename T>\n        struct FunctionalMin {\n            static constexpr T neutral = std::numeric_limits<T>::max();\n            const T &operator() (const T&a, const T&b) const { return std::min(a, b); }\n        };\n    template <typename T>\n        struct FunctionalMax {\n            static constexpr T neutral = std::numeric_limits<T>::min();\n            const T &operator() (const T&a, const T&b) const { return std::max(a, b); }\n        };\n    template <typename T>\n        struct FunctionalGCD {\n            static constexpr T neutral = 0;\n            T operator() (const T a, const T b) { return std::gcd(a, b); }\n        };\n}\nnamespace SegmentTree {\n    namespace PointUpdateRangeQuery {\n        // combine(value_type a, value_type b) -> value_type\n        template<typename Container, typename Combine, typename ValueType = typename Container::value_type, typename SizeType = typename Container::size_type>\n            requires requires (Combine combine, ValueType &&a, ValueType &&b) {\n                { combine(a, b) } -> std::same_as<ValueType>;\n            }\n            class SegTree {\n                // combine should be callable as `combine(const value_type &, const value_type &) -> value_type`\n                // container should support `value_type &operator[](size_type)` and `size_type size() const`\n                public:\n                typedef SizeType size_type;\n                typedef SizeType index_type;\n                typedef ValueType value_type;\n                private:\n                Container t;\n                [[no_unique_address]]\n                    Combine combine;\n                public:\n                SegTree(index_type size, Combine combine = Combine()) : t(size*2), combine{combine} {\n                    if (combine(t[0], t[0]) != t[0])\n                        init();\n                }\n                template <typename Source>\n                    SegTree(index_type size, Source src, Combine combine = Combine()) : t(size*2), combine(combine) {\n                        init(src);\n                    }\n                SegTree(index_type size, const value_type &initv, Combine combine = Combine()) : t(size*2, initv), combine{combine} {\n                    if (combine(initv, initv) != initv)\n                        init();\n                }\n                template <typename Iterator>\n                    SegTree(Iterator begin, Iterator end, Combine combine = Combine()) : SegTree(std::distance(begin, end), [begin]() mutable { return *begin++; }, combine) {\n                    }\n                SegTree(const Container &c, Combine combine = Combine()) : SegTree(c.cbegin(), c.cend(), combine) {\n                }\n                SegTree(Container &&c, Combine combine = Combine()) : SegTree(c.size(), [begin = c.begin()]() mutable { return std::move(*begin++); }, combine) {\n                }\n                SegTree(const SegTree &) = default;\n                SegTree(SegTree &&) = default;\n                SegTree& operator=(const SegTree &) = default;\n                SegTree& operator=(SegTree &&) = default;\n                constexpr auto size () const noexcept { return t.size() >> 1; }\n                template<typename Source>\n                    void init(Source src) {\n                        std::generate_n(t.begin() + size(), size(), src);\n                        init();\n                    }\n                private:\n                void init() {\n                    index_type n = size();\n                    for (index_type i = n; i--; )\n                        t[i] = combine(std::as_const(t)[i<<1], std::as_const(t)[(i<<1)^1]);\n                }\n                public:\n                // for non-commutative combine\n                void update(index_type pos, const value_type &val, bool) {\n                    index_type n = size();\n                    pos += n;\n                    t[pos] = val;\n                    while(pos > 1) {\n                        auto next = pos >> 1;\n                        t[next] = combine(std::as_const(t)[pos & ~1], std::as_const(t)[pos | 1]);\n                        pos = next;\n                    }\n                }\n                ///////////////////////////////////////////////////////////////////////////////////////\n                // for non-commutative combine\n                auto query_halfopen(index_type l, index_type r, value_type resl, value_type resr) const { // [ l; r )\n                    index_type n = size();\n                    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n                        if ((l & 1))\n                            resl = combine(resl, t[l++]);\n                        if ((r & 1))\n                            resr = combine(t[--r], resr);\n                    }\n                    return combine(resl, resr);\n                }\n                auto query(index_type l, index_type r, value_type res) const { // [ l; r]\n                    const index_type n = size();\n                    for (l += n, r += n; l <= r; l >>= 1, r >>= 1) {\n                        if (l & 1) {\n                            res = combine(res, t[l]); ++l;\n                        }\n                        if (!(r & 1)) {\n                            res = combine(t[r], res); --r;\n                        }\n                    }\n                    return res;\n                }\n                // for non-commutative combine\n                auto query(index_type l, index_type r, value_type resl, value_type resr) const { // [ l; r]\n                    index_type n = size();\n                    for (l += n, r += n; l <= r; l >>= 1, r >>= 1) {\n                        if ((l & 1)) {\n                            resl = combine(resl, t[l]); ++l;\n                        }\n                        if (!(r & 1)) {\n                            resr = combine(t[r], resr); --r;\n                        }\n                    }\n                    return combine(resl, resr);\n                }\n            }; // class SegTree\n        template<typename Container>\n            using SegTreeSum = SegTree<Container, std::plus<typename Container::value_type>>;\n        template<typename Container>\n            using SegTreeMin = SegTree<Container, FunctionalMin<typename Container::value_type>>;\n        template<typename Container>\n            using SegTreeMax = SegTree<Container, FunctionalMax<typename Container::value_type>>;\n    } // namespace PointUpdateRangeQuery\n}\n#endif\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        using namespace SegmentTree::PointUpdateRangeQuery;\n        struct node {\n            unsigned size = 2;\n            unsigned maxblock = 2; // max size of free block within node\n            unsigned head = 2; // distance from begin of node to first obstacle\n            unsigned tail = 2; // distance from end of node to last obstacle;\n        };\n        auto combine = [](const auto a, const auto b) {\n            decay_t<decltype(a)> c;\n            if (a.size == 0)\n                return b;\n            if (b.size == 0)\n                return a;\n            c.size = a.size + b.size;\n            c.head = a.head == a.size ? a.head + b.head : a.head;\n            c.tail = b.tail == b.size ? a.tail + b.tail : b.tail;\n            c.maxblock = max(max(a.maxblock, b.maxblock), a.tail + b.head);\n            return c;\n        };\n        unsigned maxv = 0;\n        unsigned rsize = 0;\n        for (const auto &q: queries) {\n            maxv = max<unsigned>(maxv, q[1]);\n            rsize += q[0] == 2;\n        }\n        ++maxv;\n        SegTree st(vector<node>(maxv), combine);\n        const unsigned m = queries.size();\n        st.update(0, node { 2, 1, 1, 1}, true);\n        vector<bool> ret(rsize);\n        for (unsigned i = 0, j = 0; i < m; ++i) {\n            const auto &q = queries[i];\n            if (q[0] == 1) {\n                auto x = q[1];\n                st.update(x, node { 2, 0, 1, 1}, true);\n            } else {\n                assert(q[0] == 2);\n                auto x = q[1];\n                auto sz = q[2];\n                auto res = st.query_halfopen(0, x + 1, node { 0, 0, 0, 0}, node {2, 0, 0, 0});\n                //cout << res.size << ' ' << res.head << ' ' << res.tail << ' ' << res.maxblock << endl;\n                ret[j++] = res.maxblock >= sz*2;\n            }\n        }\n        cout << endl;\n        return ret;\n    }\n};",
    "submit_ts": "1716651579",
    "subm_id": "1267643657"
}