{
    "username": "fmota",
    "submission": "using ll = long long;\nusing pii = pair<int,int>;\n \ntypedef double ld;\nconst ld DINF = 1e18;\nconst ld pi = acos(-1.0);\nconst ld eps = 1e-9;\n \n#define sq(x) ((x)*(x))\n \nbool eq(ld a, ld b) {\n\treturn abs(a - b) <= eps;\n}\n \nstruct pt { // ponto\n\tld x, y;\n\tpt(ld x_ = 0, ld y_ = 0) : x(x_), y(y_) {}\n\tbool operator < (const pt p) const {\n\t\tif (!eq(x, p.x)) return x < p.x;\n\t\tif (!eq(y, p.y)) return y < p.y;\n\t\treturn 0;\n\t}\n\tbool operator == (const pt p) const {\n\t\treturn eq(x, p.x) and eq(y, p.y);\n\t}\n\tpt operator + (const pt p) const { return pt(x+p.x, y+p.y); }\n\tpt operator - (const pt p) const { return pt(x-p.x, y-p.y); }\n\tpt operator * (const ld c) const { return pt(x*c  , y*c  ); }\n\tpt operator / (const ld c) const { return pt(x/c  , y/c  ); }\n\tld operator * (const pt p) const { return x*p.x + y*p.y; }\n\tld operator ^ (const pt p) const { return x*p.y - y*p.x; }\n\tfriend istream& operator >> (istream& in, pt& p) {\n\t\treturn in >> p.x >> p.y;\n\t}\n};\n \nstruct line { // reta\n\tpt p, q;\n\tline() {}\n\tline(pt p_, pt q_) : p(p_), q(q_) {}\n\tfriend istream& operator >> (istream& in, line& r) {\n\t\treturn in >> r.p >> r.q;\n\t}\n};\n \n// PONTO & VETOR\n \nld dist(pt p, pt q) { // distancia\n\treturn hypot(p.y - q.y, p.x - q.x);\n}\n \nld dist2(pt p, pt q) { // quadrado da distancia\n\treturn sq(p.x - q.x) + sq(p.y - q.y);\n}\n \nld norm(pt v) { // norma do vetor\n\treturn dist(pt(0, 0), v);\n}\n \nld angle(pt v) { // angulo do vetor com o eixo x\n\tld ang = atan2(v.y, v.x);\n\tif (ang < 0) ang += 2*pi;\n\treturn ang;\n}\n \nld sarea(pt p, pt q, pt r) { // area com sinal\n\treturn ((q-p)^(r-q))/2;\n}\n \nbool col(pt p, pt q, pt r) { // se p, q e r sao colin.\n\treturn eq(sarea(p, q, r), 0);\n}\n \nbool ccw(pt p, pt q, pt r) { // se p, q, r sao ccw\n\treturn sarea(p, q, r) > eps;\n}\n \npt rotate(pt p, ld th) { // rotaciona o ponto th radianos\n\treturn pt(p.x * cos(th) - p.y * sin(th),\n\t\t\tp.x * sin(th) + p.y * cos(th));\n}\n \npt rotate90(pt p) { // rotaciona 90 graus\n\treturn pt(-p.y, p.x);\n}\n \n// RETA\n \nbool isvert(line r) { // se r eh vertical\n\treturn eq(r.p.x, r.q.x);\n}\n \nbool isinseg(pt p, line r) { // se p pertence ao seg de r\n\tpt a = r.p - p, b = r.q - p;\n\treturn eq((a ^ b), 0) and (a * b) < eps;\n}\n \nld get_t(pt v, line r) { // retorna t tal que t*v pertence a reta r\n\treturn (r.p^r.q) / ((r.p-r.q)^v);\n}\n \npt proj(pt p, line r) { // projecao do ponto p na reta r\n\tif (r.p == r.q) return r.p;\n\tr.q = r.q - r.p; p = p - r.p;\n\tpt proj = r.q * ((p*r.q) / (r.q*r.q));\n\treturn proj + r.p;\n}\n \npt inter(line r, line s) { // r inter s\n\tif (eq((r.p - r.q) ^ (s.p - s.q), 0)) return pt(DINF, DINF);\n\tr.q = r.q - r.p, s.p = s.p - r.p, s.q = s.q - r.p;\n\treturn r.q * get_t(r.q, s) + r.p;\n}\n \nbool interseg(line r, line s) { // se o seg de r intersecta o seg de s\n\tif (isinseg(r.p, s) or isinseg(r.q, s)\n\t\tor isinseg(s.p, r) or isinseg(s.q, r)) return 1;\n \n\treturn ccw(r.p, r.q, s.p) != ccw(r.p, r.q, s.q) and\n\t\t\tccw(s.p, s.q, r.p) != ccw(s.p, s.q, r.q);\n}\n \nld disttoline(pt p, line r) { // distancia do ponto a reta\n\treturn 2 * abs(sarea(p, r.p, r.q)) / dist(r.p, r.q);\n}\n \nld disttoseg(pt p, line r) { // distancia do ponto ao seg\n\tif ((r.q - r.p)*(p - r.p) < 0) return dist(r.p, p);\n\tif ((r.p - r.q)*(p - r.q) < 0) return dist(r.q, p);\n\treturn disttoline(p, r);\n}\n \nld distseg(line a, line b) { // distancia entre seg\n\tif (interseg(a, b)) return 0;\n \n\tld ret = DINF;\n\tret = min(ret, disttoseg(a.p, b));\n\tret = min(ret, disttoseg(a.q, b));\n\tret = min(ret, disttoseg(b.p, a));\n\tret = min(ret, disttoseg(b.q, a));\n \n\treturn ret;\n}\n \n// POLIGONO\n \n// corta poligono com a reta r deixando os pontos p tal que \n// ccw(r.p, r.q, p)\nvector<pt> cut_polygon(vector<pt> v, line r) { // O(n)\n\tvector<pt> ret;\n\tfor (int j = 0; j < v.size(); j++) {\n\t\tif (ccw(r.p, r.q, v[j])) ret.push_back(v[j]);\n\t\tif (v.size() == 1) continue;\n\t\tline s(v[j], v[(j+1)%v.size()]);\n\t\tpt p = inter(r, s);\n\t\tif (isinseg(p, s)) ret.push_back(p);\n\t}\n\tret.erase(unique(ret.begin(), ret.end()), ret.end());\n\tif (ret.size() > 1 and ret.back() == ret[0]) ret.pop_back();\n\treturn ret;\n}\n \n// distancia entre os retangulos a e b (lados paralelos aos eixos)\n// assume que ta representado (inferior esquerdo, superior direito)\nld dist_rect(pair<pt, pt> a, pair<pt, pt> b) {\n\tld hor = 0, vert = 0;\n\tif (a.second.x < b.first.x) hor = b.first.x - a.second.x;\n\telse if (b.second.x < a.first.x) hor = a.first.x - b.second.x;\n\tif (a.second.y < b.first.y) vert = b.first.y - a.second.y;\n\telse if (b.second.y < a.first.y) vert = a.first.y - b.second.y;\n\treturn dist(pt(0, 0), pt(hor, vert));\n}\n \nld polarea(vector<pt> v) { // area do poligono\n\tld ret = 0;\n\tfor (int i = 0; i < v.size(); i++)\n\t\tret += sarea(pt(0, 0), v[i], v[(i + 1) % v.size()]);\n\treturn abs(ret);\n}\n \n// se o ponto ta dentro do poligono: retorna 0 se ta fora,\n// 1 se ta no interior e 2 se ta na borda\nint inpol(vector<pt>& v, pt p) { // O(n)\n\tint qt = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (p == v[i]) return 2;\n\t\tint j = (i+1)%v.size();\n\t\tif (eq(p.y, v[i].y) and eq(p.y, v[j].y)) {\n\t\t\tif ((v[i]-p)*(v[j]-p) < eps) return 2;\n\t\t\tcontinue;\n\t\t}\n\t\tbool baixo = v[i].y+eps < p.y;\n\t\tif (baixo == (v[j].y+eps < p.y)) continue;\n\t\tauto t = (p-v[i])^(v[j]-v[i]);\n\t\tif (eq(t, 0)) return 2;\n\t\tif (baixo == (t > eps)) qt += baixo ? 1 : -1;\n\t}\n\treturn qt != 0;\n}\n \nbool interpol(vector<pt> v1, vector<pt> v2) { // se dois poligonos se intersectam - O(n*m)\n\tint n = v1.size(), m = v2.size();\n\tfor (int i = 0; i < n; i++) if (inpol(v2, v1[i])) return 1;\n\tfor (int i = 0; i < n; i++) if (inpol(v1, v2[i])) return 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++)\n\t\tif (interseg(line(v1[i], v1[(i+1)%n]), line(v2[j], v2[(j+1)%m]))) return 1;\n\treturn 0;\n}\n \nld distpol(vector<pt> v1, vector<pt> v2) { // distancia entre poligonos\n\tif (interpol(v1, v2)) return 0;\n \n\tld ret = DINF;\n \n\tfor (int i = 0; i < v1.size(); i++) for (int j = 0; j < v2.size(); j++)\n\t\tret = min(ret, distseg(line(v1[i], v1[(i + 1) % v1.size()]),\n\t\t\t\t\tline(v2[j], v2[(j + 1) % v2.size()])));\n\treturn ret;\n}\n \nvector<pt> convex_hull(vector<pt> v) { // convex hull - O(n log(n))\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tif (v.size() <= 1) return v;\n\tvector<pt> l, u;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\twhile (l.size() > 1 and !ccw(l.end()[-2], l.end()[-1], v[i]))\n\t\t\tl.pop_back();\n\t\tl.push_back(v[i]);\n\t}\n\tfor (int i = v.size() - 1; i >= 0; i--) {\n\t\twhile (u.size() > 1 and !ccw(u.end()[-2], u.end()[-1], v[i]))\n\t\t\tu.pop_back();\n\t\tu.push_back(v[i]);\n\t}\n\tl.pop_back(); u.pop_back();\n\tfor (pt i : u) l.push_back(i);\n\treturn l;\n}\n \nstruct convex_pol {\n\tvector<pt> pol;\n \n\t// nao pode ter ponto colinear no convex hull\n\tconvex_pol() {}\n\tconvex_pol(vector<pt> v) : pol(convex_hull(v)) {}\n \n\t// se o ponto ta dentro do hull - O(log(n))\n\tbool is_inside(pt p) {\n\t\tif (pol.size() == 0) return false;\n\t\tif (pol.size() == 1) return p == pol[0];\n\t\tint l = 1, r = pol.size();\n\t\twhile (l < r) {\n\t\t\tint m = (l+r)/2;\n\t\t\tif (ccw(p, pol[0], pol[m])) l = m+1;\n\t\t\telse r = m;\n\t\t}\n\t\tif (l == 1) return isinseg(p, line(pol[0], pol[1]));\n\t\tif (l == pol.size()) return false;\n\t\treturn !ccw(p, pol[l], pol[l-1]);\n\t}\n\t// ponto extremo em relacao a cmp(p, q) = p mais extremo q\n\t// (copiado de https://github.com/gustavoM32/caderno-zika)\n\tint extreme(const function<bool(pt, pt)>& cmp) {\n\t\tint n = pol.size();\n\t\tauto extr = [&](int i, bool& cur_dir) {\n\t\t\tcur_dir = cmp(pol[(i+1)%n], pol[i]);\n\t\t\treturn !cur_dir and !cmp(pol[(i+n-1)%n], pol[i]);\n\t\t};\n\t\tbool last_dir, cur_dir;\n\t\tif (extr(0, last_dir)) return 0;\n\t\tint l = 0, r = n;\n\t\twhile (l+1 < r) {\n\t\t\tint m = (l+r)/2;\n\t\t\tif (extr(m, cur_dir)) return m;\n\t\t\tbool rel_dir = cmp(pol[m], pol[l]);\n\t\t\tif ((!last_dir and cur_dir) or\n\t\t\t\t\t(last_dir == cur_dir and rel_dir == cur_dir)) {\n\t\t\t\tl = m;\n\t\t\t\tlast_dir = cur_dir;\n\t\t\t} else r = m;\n\t\t}\n\t\treturn l;\n\t}\n\tint max_dot(pt v) {\n\t\treturn extreme([&](pt p, pt q) { return p*v > q*v; });\n\t}\n\tpair<int, int> tangents(pt p) {\n\t\tauto L = [&](pt q, pt r) { return ccw(p, r, q); };\n\t\tauto R = [&](pt q, pt r) { return ccw(p, q, r); };\n\t\treturn {extreme(L), extreme(R)};\n\t}\n};\n \n// CIRCUNFERENCIA\n \npt getcenter(pt a, pt b, pt c) { // centro da circunf dado 3 pontos\n\tb = (a + b) / 2;\n\tc = (a + c) / 2;\n\treturn inter(line(b, b + rotate90(a - b)),\n\t\t\tline(c, c + rotate90(a - c)));\n}\n \nvector<pt> circ_line_inter(pt a, pt b, pt c, ld r) { // intersecao da circunf (c, r) e reta ab\n\tvector<pt> ret;\n\tb = b-a, a = a-c;\n\tld A = b*b;\n\tld B = a*b;\n\tld C = a*a - r*r;\n\tld D = B*B - A*C;\n\tif (D < -eps) return ret;\n\tret.push_back(c+a+b*(-B+sqrt(D+eps))/A);\n\tif (D > eps) ret.push_back(c+a+b*(-B-sqrt(D))/A);\n\treturn ret;\n}\n \nvector<pt> circ_inter(pt a, pt b, ld r, ld R) { // intersecao da circunf (a, r) e (b, R)\n\tvector<pt> ret;\n\tld d = dist(a, b);\n\tif (d > r+R or d+min(r, R) < max(r, R)) return ret;\n\tld x = (d*d-R*R+r*r)/(2*d);\n\tld y = sqrt(r*r-x*x);\n\tpt v = (b-a)/d;\n\tret.push_back(a+v*x + rotate90(v)*y);\n\tif (y > 0) ret.push_back(a+v*x - rotate90(v)*y);\n\treturn ret;\n}\n \nbool operator <(const line& a, const line& b) { // comparador pra reta\n\t// assume que as retas tem p < q\n\tpt v1 = a.q - a.p, v2 = b.q - b.p;\n\tif (!eq(angle(v1), angle(v2))) return angle(v1) < angle(v2);\n\treturn ccw(a.p, a.q, b.p); // mesmo angulo\n}\nbool operator ==(const line& a, const line& b) {\n\treturn !(a < b) and !(b < a);\n}\n \n// comparador pro set pra fazer sweep line com segmentos\nstruct cmp_sweepline {\n\tbool operator () (const line& a, const line& b) const {\n\t\t// assume que os segmentos tem p < q\n\t\tif (a.p == b.p) return ccw(a.p, a.q, b.q);\n\t\tif (!eq(a.p.x, a.q.x) and (eq(b.p.x, b.q.x) or a.p.x+eps < b.p.x))\n\t\t\treturn ccw(a.p, a.q, b.p);\n\t\treturn ccw(a.p, b.q, b.p);\n\t}\n};\n \n// comparador pro set pra fazer sweep angle com segmentos\npt dir;\nstruct cmp_sweepangle {\n\tbool operator () (const line& a, const line& b) const {\n\t\treturn get_t(dir, a) + eps < get_t(dir, b);\n\t}\n};\n \nstruct union_find {\n    vector<int> parent;\n    int n;\n    union_find(int n) : n(n) { clear(); }\n    inline void clear(){ parent.assign(n, -1); }\n    inline int find(int u){ return (parent[u] < 0) ? u : parent[u] = find(parent[u]); }\n    inline bool same(int u, int v){ return find(u) == find(v); }\n    inline bool join(int u, int v){\n        u = find(u);\n        v = find(v);\n        if (u != v){\n            if (parent[u] > parent[v])\n                swap(u, v);\n            parent[u] += parent[v];\n            parent[v] = u;\n        }\n        return u != v;\n    }\n    inline int size(int u){ return -parent[find(u)]; }\n};\n \nbool is_in_range(pt a, pt b, pt c, ld r) { // intersecao da circunf (c, r) e reta ab\n\tld d1 = (a - c) * (a - c);\n  ld d2 = (b - c) * (b - c);\n  ld r2 = r * r;\n  if(d1 <= r2 && d2 <= r2) return true;\n  if(d1 < r2 || d2 < r2) return true;\n\treturn false;\n}\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& _c) {\n        auto read_pt = [&](){\n    int x, y; cin >> x >> y;\n    return pt(x, y);\n  };\n  pt u = pt(0, 0);\n  pt v = pt(X, Y);\n  auto is_inside = [&](pt p){\n    if(p.x - u.x > eps && v.x - p.x > eps && p.y - u.y > eps && v.y - p.y > eps) return true;\n    if(abs(p.x - u.x) < eps && p.y - u.y > eps && v.y - p.y > eps) return true;\n    if(abs(p.x - v.x) < eps && p.y - u.y > eps && v.y - p.y > eps) return true;\n    if(abs(p.y - u.y) < eps && p.x - u.x > eps && v.x - p.x > eps) return true;\n    if(abs(p.y - v.y) < eps && p.x - u.x > eps && v.x - p.x > eps) return true;\n    return false;\n  };\n  auto is_edge = [&](pt p){\n    return (eq(p.x, u.x) || eq(p.x, v.x)) && (eq(p.y, u.y) || eq(p.y, v.y));\n  };\n  vector<pair<pt, ll>> circles;\n  int n = _c.size();\n  for(int i = 0; i < n; i++){\n    pt p = pt(_c[i][0], _c[i][1]);\n    ll r = _c[i][2];\n    circles.emplace_back(p, r);\n  }\n  union_find uf(n + 4);\n  for(int i = 0; i < n; i++){\n    auto [p, r] = circles[i];\n    auto in_range = is_in_range(pt(u.x, u.y), pt(u.x, v.y), p, r);\n    if(in_range){\n      uf.join(n, i);\n      continue;\n    }\n    auto m = circ_line_inter(pt(u.x, u.y), pt(u.x, v.y), p, r);\n    if(m.size() < 1) continue;\n      uf.join(n, i);\n  }\n  for(int i = 0; i < n; i++){\n    auto [p, r] = circles[i];\n    auto in_range = is_in_range(pt(u.x, v.y), pt(v.x, v.y), p, r);\n    if(in_range){\n      uf.join(n + 1, i);\n      continue;\n    }\n    auto m = circ_line_inter(pt(u.x, v.y), pt(v.x, v.y), p, r);\n    if(m.size() < 1) continue;\n      uf.join(n + 1, i);\n  }\n  for(int i = 0; i < n; i++){\n    auto [p, r] = circles[i];\n    auto in_range = is_in_range(pt(v.x, u.y), pt(v.x, v.y), p, r);\n    if(in_range){\n      uf.join(n + 2, i);\n      continue;\n    }\n    auto m = circ_line_inter(pt(v.x, u.y), pt(v.x, v.y), p, r);\n    if(m.size() < 1) continue;\n    uf.join(n + 2, i);\n  }\n  for(int i = 0; i < n; i++){\n    auto [p, r] = circles[i];\n    auto in_range = is_in_range(pt(u.x, u.y), pt(v.x, u.y), p, r);\n    if(in_range){\n      uf.join(n + 3, i);\n      continue;\n    }\n    auto m = circ_line_inter(pt(u.x, u.y), pt(v.x, u.y), p, r);\n    if(m.size() < 1) continue;\n     uf.join(n + 3, i);\n  }\n  for(int i = 0; i < n; i++){\n    for(int j = i + 1; j < n; j++){\n      if(ll(_c[i][0] - _c[j][0]) * ll(_c[i][0] - _c[j][0]) + ll(_c[i][1] - _c[j][1]) * ll(_c[i][1] - _c[j][1]) <= ll(_c[i][2] + _c[j][2]) * ll(_c[i][2] + _c[j][2]))\n    uf.join(i, j);\n    }\n  }\n  bool bad = uf.same(n, n+2) || uf.same(n+1, n+2) || uf.same(n+1, n+3) || uf.same(n, n+3);\n  return !bad;\n    }\n};",
    "submit_ts": "1722135487",
    "subm_id": "1335703410"
}