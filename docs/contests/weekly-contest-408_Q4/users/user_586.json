{
    "username": "_Nikhil_Sharma",
    "submission": "import java.util.*;\n\nclass Circle {\n    int x, y, radius;\n\n    Circle(int x, int y, int radius) {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n}\n\nclass Solution {\n    // Helper method to perform BFS and check connectivity\n    private boolean isConnected(List<List<Integer>> graph, int start, int end1, int end2, int totalNodes) {\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] visited = new boolean[totalNodes + 4];\n        queue.offer(start);\n        visited[start] = true;\n\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            for (int neighbor : graph.get(current)) {\n                if (!visited[neighbor]) {\n                    queue.offer(neighbor);\n                    visited[neighbor] = true;\n                }\n            }\n        }\n        return visited[end1] || visited[end2];\n    }\n\n    // Method to check if the path to any corner is accessible\n    public boolean canReachCorner(int width, int height, int[][] circleData) {\n        int circleCount = circleData.length;\n        List<Circle> circles = new ArrayList<>();\n        List<List<Integer>> graph = new ArrayList<>();\n\n        // Initialize the adjacency list for graph\n        for (int i = 0; i < circleCount + 4; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        // Convert input data into Circle objects\n        for (int[] data : circleData) {\n            circles.add(new Circle(data[0], data[1], data[2]));\n        }\n\n        // Build the graph by checking circle overlaps and boundary conditions\n        for (int i = 0; i < circleCount; i++) {\n            Circle c = circles.get(i);\n            if (c.x <= c.radius) {\n                graph.get(circleCount).add(i);\n                graph.get(i).add(circleCount);\n            }\n            if (width - c.x <= c.radius) {\n                graph.get(circleCount + 2).add(i);\n                graph.get(i).add(circleCount + 2);\n            }\n            if (c.y <= c.radius) {\n                graph.get(circleCount + 1).add(i);\n                graph.get(i).add(circleCount + 1);\n            }\n            if (height - c.y <= c.radius) {\n                graph.get(circleCount + 3).add(i);\n                graph.get(i).add(circleCount + 3);\n            }\n            for (int j = i + 1; j < circleCount; j++) {\n                Circle c2 = circles.get(j);\n                double distance = Math.sqrt(Math.pow(c.x - c2.x, 2) + Math.pow(c.y - c2.y, 2));\n                int radiusSum = c.radius + c2.radius;\n                if (radiusSum >= distance) {\n                    graph.get(i).add(j);\n                    graph.get(j).add(i);\n                }\n            }\n        }\n\n        // Check if any of the corners are reachable\n        boolean isBlocked = false;\n        isBlocked |= isConnected(graph, circleCount, circleCount + 1, circleCount + 2, circleCount + 4); // Bottom-left corner\n        isBlocked |= isConnected(graph, circleCount + 3, circleCount + 2, circleCount + 1, circleCount + 4); // Top-right corner\n\n        return !isBlocked;\n    }\n}\n",
    "submit_ts": "1722137687",
    "subm_id": "1335770852"
}