{
    "username": "harshS301",
    "submission": "struct TrieNode {\n    TrieNode* children[26];\n    int cost;\n    \n    TrieNode() : cost(INT_MAX) {\n        fill(begin(children), end(children), nullptr);\n    }\n};\n\nclass Trie {\npublic:\n    \n    Trie() {\n        root = new TrieNode();\n    }\n    \n    void insert(const string& word, int cost) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (!node->children[c - 'a']) {\n                node->children[c - 'a'] = new TrieNode();\n            }\n            node = node->children[c - 'a'];\n        }\n        node->cost = min(node->cost, cost);\n    }\n    \n    int getCost(const string& word) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (!node->children[c - 'a']) {\n                return INT_MAX;\n            }\n            node = node->children[c - 'a'];\n        }\n        return node->cost;\n    }\n    \n\n    TrieNode* root;\n};\n\nclass Solution {\npublic:\n    \n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n//         int n = target.size();\n//         unordered_map<string, int> map;\n//         int m = words.size();\n\n//         // Fill the map with the minimum cost for each word\n//         for (int i = 0; i < m; i++) {\n//             if (map.find(words[i]) != map.end()) {\n//                 map[words[i]] = min(costs[i], map[words[i]]);\n//             } else {\n//                 map[words[i]] = costs[i];\n//             }\n//         }\n\n//         // Initialize dp array with INT_MAX, except for dp[n] which is 0\n//         vector<int> dp(n + 1, INT_MAX);\n//         dp[n] = 0;\n\n//         // Fill the dp array from the end of the target string to the start\n//         for (int ind = n - 1; ind >= 0; ind--) {\n//             string curr = \"\";\n//             for (int i = ind; i < n; i++) {\n//                 curr += target[i];  // Build the substring from index ind to i\n//                 if (map.find(curr) != map.end() && dp[i + 1] != INT_MAX) {\n//                     dp[ind] = min(dp[ind], dp[i + 1] + map[curr]);\n//                 }\n//             }\n//         }\n\n//         return dp[0] == INT_MAX ? -1 : dp[0];\n        \n        int n = target.size();\n        Trie trie;\n        int m = words.size();\n\n        // Insert words and their costs into the Trie\n        for (int i = 0; i < m; i++) {\n            trie.insert(words[i], costs[i]);\n        }\n\n        // Initialize dp array\n        vector<int> dp(n + 1, INT_MAX);\n        dp[n] = 0; // Cost to transform an empty suffix is 0\n\n        // Fill the dp array from the end of the target string to the start\n        for (int ind = n - 1; ind >= 0; ind--) {\n            TrieNode* node = trie.root;\n            for (int i = ind; i < n && node; i++) {\n                node = node->children[target[i] - 'a'];\n                if (node && node->cost != INT_MAX && dp[i + 1] != INT_MAX) {\n                    dp[ind] = min(dp[ind], dp[i + 1] + node->cost);\n                }\n            }\n        }\n\n        return dp[0] == INT_MAX ? -1 : dp[0];\n    }\n};",
    "submit_ts": "1720324511",
    "subm_id": "1312401327"
}