{
    "username": "tepamid",
    "submission": "\n#define fo(i, n) for (int i = 0; i < n; ++i)\n#define foback(i, n) for (int i = n - 1; i >= 0; --i)\n#define fo1(i, n) for (ll i = 1; i <= n; ++i)\n\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define makeunique(x) sort(all(x)), (x).resize(unique(all(x)) - (x).begin())\n\ntypedef long long ll;\n\n\nstruct segtree\n{\n    typedef int Node;\n\n    Node op(Node lv, Node rv)\n    {\n        return (lv & rv);\n    }\n\n    void setLeaf(int x, int v)\n    {\n        tree[x] = v;\n    }\n\n    const Node ZERO = 0x7FFFFFFF;\n\n    vector<Node> tree;\n    int size;\n\n    void init(int n)\n    {\n        size = 1;\n        while (size < n)\n            size *= 2;\n        tree.assign(2 * size - 1, ZERO);\n    }\n\n    void build(const vector<Node> &a, int x, int lx, int rx)\n    {\n        if (rx - lx == 1)\n        {\n            if (lx < a.size())\n                setLeaf(x, a[lx]);\n            return;\n        }\n\n        int m = (lx + rx) / 2;\n        build(a, getLeftChild(x), lx, m);\n        build(a, getRightChild(x), m, rx);\n\n        tree[x] = op(tree[getLeftChild(x)], tree[getRightChild(x)]);\n    }\n\n    void build(const vector<int> &a)\n    {\n        init(a.size());\n        build(a, 0, 0, size);\n    }\n\n    void set(int i, int v)\n    {\n        set(i, v, 0, 0, size);\n    }\n\n    void set(int i, int v, int x, int lx, int rx)\n    {\n        if (rx - lx == 1)\n        {\n            setLeaf(x, v);\n            return;\n        }\n\n        int m = (lx + rx) / 2;\n        if (i < m)\n        {\n            set(i, v, getLeftChild(x), lx, m);\n        }\n        else\n        {\n            set(i, v, getRightChild(x), m, rx);\n        }\n\n        tree[x] = op(tree[getLeftChild(x)], tree[getRightChild(x)]);\n    }\n\n    Node get(int l, int r, int x, int lx, int rx)\n    {\n        if (lx >= r || l >= rx)\n        {\n            return ZERO;\n        }\n\n        if (lx >= l && rx <= r)\n        {\n            return tree[x];\n        }\n\n        int m = (lx + rx) / 2;\n        auto s1 = get(l, r, getLeftChild(x), lx, m);\n        auto s2 = get(l, r, getRightChild(x), m, rx);\n        return op(s1, s2);\n    }\n\n    Node get(int l, int r)\n    {\n        return get(l, r, 0, 0, size);\n    }\n\n    int getLeftChild(int x)\n    {\n        return 2 * x + 1;\n    }\n\n    int getRightChild(int x)\n    {\n        return 2 * x + 2;\n    }\n};\n\n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& a, int k) {\n        int ans = abs(a[0]-k);\n        \n        segtree st;\n        st.build(a);\n        \n        int n = a.size();\n        for(int i=0; i<n; i++) {\n            \n             if (a[i] <= k) {\n                 int cur = abs(a[i]-k);\n                 ans = min(ans, cur);\n                 continue;\n             } \n            \n            int r=i;\n            int l=-1;\n            \n            while(l+1<r) {\n                int m = (l+r)/2;\n                auto x = st.get(m, i+1);\n                \n                if (x>=k) r=m;\n                else l=m;\n            }\n            \n            // ... k ...\n            {\n                auto x = st.get(r, i+1);\n                auto cur = abs(x-k);\n                ans = min(ans,cur);\n            }\n            if (l>=0) {\n                auto x = st.get(l, i+1);\n                auto cur = abs(x-k);\n                ans = min(ans,cur);\n            }\n            \n            \n        }\n        \n        return ans;\n    }\n};\n",
    "submit_ts": 1717297835.0
}