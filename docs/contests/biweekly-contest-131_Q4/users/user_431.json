{
    "username": "liujg3",
    "submission": "class SegmentTree:#\u52a8\u6001\u5f00\u70b9\uff0c\u9700\u8981\u5e73\u8861\uff1f\n    def __init__(self,l,r):#\u6bcf\u4e2a\u533a\u95f4\u7684\u6700\u5927\u7a7a\u4f4d\uff0c\u6709\u5de6\u5fc5\u6709\u53f3\uff1f\n        self.l=l\n        self.r=r\n        self.left=None\n        self.right=None\n        self.maxSpace=r-l\n        self.depth=0\n        \n    def add(self,pos):#pos\u80af\u5b9a\u5728\u8303\u56f4\u5185\n        if self.left:\n            if pos<self.right.l:\n                self.left.add(pos)\n            elif pos>self.right.l:\n                self.right.add(pos)\n        else:\n            self.left=SegmentTree(self.l,pos)\n            self.right=SegmentTree(pos,self.r)\n        m1,m2=sorted([self.left.depth,self.right.depth])\n        if m1*2<=m2:\n            self.rebalance()\n        self.maxSpace=max(self.left.maxSpace,self.right.maxSpace)\n        self.depth=1+max(self.left.depth,self.right.depth)\n    \n    def dfsGetL(self):\n        res=[]\n        if self.left:\n            res=self.left.dfsGetL()\n        if self.right:\n            res+=self.right.dfsGetL()\n        if not len(res):\n            res=[self.l]\n        return res\n    \n    def rebalance(self):#\u8bb0\u5f55\u533a\u95f4\u5185\u6240\u6709\u969c\u788d\uff0c\u91cd\u65b0\u5206\u914d\n        pos=[]\n        # def dfsGetL(node):\n        #     if node.left:\n        #         dfsGetL(node.left)\n        #     # pos.append(node.l)\n        #     # if node.left:\n        #         dfsGetL(node.right)\n        #     else:\n        #         pos.append(node.l)\n        # # dfsGetL(self)\n        pos=self.dfsGetL()\n        pos.append(self.r)\n        # print(\"rebalance,pos=\",pos)\n        def buildFromArr(l,r):#\u91cd\u8bbe\n            node=SegmentTree(pos[l],pos[r])\n            if r-l>1:\n                m=(l+r+1)//2\n                node.left=buildFromArr(l,m)#SegmentTree(pos[l],pos[m])#\u6709\u53ef\u80fd\u88ab\u9500\u6bc1\u4e86\n                node.right=buildFromArr(m,r)#SegmentTree(pos[m],pos[r])\n                node.maxSpace=max(node.left.maxSpace,node.right.maxSpace)\n                node.depth=1+max(node.left.depth,node.right.depth)\n            return node\n        n=len(pos)\n        m=(n)//2\n        self.left=buildFromArr(0,m)\n        self.right=buildFromArr(m,n-1)\n        \n    def check(self,l,r):#\u53ea\u9700\u5224\u65ad0-x\u5185\n        if l<=self.l and r>=self.r:\n            return self.maxSpace\n        if (not self.left) and (not self.right):\n            return min(r,self.r)-max(l,self.l)\n        res=0\n        if self.left and self.left.r>l:\n            res=max(res,self.left.check(l,r))\n        if self.right and self.right.l<r:\n            res=max(res,self.right.check(l,r))\n        return res\n        \nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:#\u7ebf\u6bb5\u6811\uff0c\u6216\u63d2\u5165\u6392\u5e8f\uff0c\u4e8c\u5206\u641c\u7d22\u3002\u5982\u679c\u67e5\u7684\u8303\u56f4\u5f88\u5927\uff0c\u7269\u4f53\u8f83\u5c0f\u65f6\u4e8c\u5206\u641c\u7d22\u6548\u7387\u4f4e\n        res=[]\n        sgt=SegmentTree(0,10**9)\n        # print(sgt.check(0,2))\n        for q in queries:\n            if q[0]==1:\n                sgt.add(q[1])\n            # elif not sgt.left:\n            #     res.append(q[1]>=q[2])\n            else:\n                maxSpace=sgt.check(0,q[1])\n                res.append(maxSpace>=q[2])\n        #         print(q,maxSpace)\n        #     print(q,sgt.dfsGetL())\n        # print()\n        return res\n        ",
    "submit_ts": "1716652035",
    "subm_id": "534777349"
}