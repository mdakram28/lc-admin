{
    "username": "MonoLithh",
    "submission": "class Solution {\npublic:\n    int  result(int a, int b)\n    {\n      return (a&b); // desired changes are needed here \n    } \n    void build_tree(int node, int a, int b,vector<int>&arr, vector<int>&t) {\n        if(a > b) return; // Out of range\n\n        if(a == b) { // Leaf node\n            t[node] = arr[a]; // Init value\n        return;\n      }\n\n      build_tree(node*2, a, (a+b)/2,arr,t); // Init left child\n      build_tree(node*2+1, 1+(a+b)/2, b,arr,t); // Init right child\n\n      t[node] = result(t[node*2], t[node*2+1]); // Init root value\n    }\n    int query_tree(int node, int a, int b, int i, int j,vector<int>&t) {\n\n      if(a > b || a > j || b < i) return INT_MAX; // Out of range\n\n      if(a >= i && b <= j) // Current segment is totally within range [i, j]\n        return t[node];\n\n      int q1 = query_tree(node*2, a, (a+b)/2, i, j,t); // Query left child\n      int q2 = query_tree(1+node*2, 1+(a+b)/2, b, i, j,t); // Query right child\n\n      int res = result(q1, q2); // Return final result\n\n      return res;\n    }\n    int calc1(int i,int n,int k, vector<int>&t)\n    {\n        int l=i;\n        int r=n-1;\n        int ans=n+1;\n        while(l<=r)\n        {\n            int mid=l+(r-l)/2;\n            int res=query_tree(1,0,n-1,i,mid,t);\n            if(res==k)\n            {\n                ans=mid;\n                r=mid-1;\n            }\n            else if(res>k)\n            {\n                l=mid+1;\n            }\n            else\n            {\n                r=mid-1;\n            }\n        }\n        return ans;\n    }\n    int calc2(int i,int n,int k, vector<int>&t)\n    {\n        int l=i;\n        int r=n-1;\n        int ans=-n;\n        while(l<=r)\n        {\n            int mid=l+(r-l)/2;\n            int res=query_tree(1,0,n-1,i,mid,t);\n            if(res==k)\n            {\n                ans=mid;\n                l=mid+1;\n            }\n            else if(res>k)\n            {\n                l=mid+1;\n            }\n            else\n            {\n                r=mid-1;\n            }\n        }\n        return ans;\n    }\n    int nextPowerOf2(int n) \n    { \n        int  count = 0; \n\n        // First n in the below condition \n        // is for the case where n is 0 \n        if (n && !(n & (n - 1))) \n            return n; \n\n        while( n != 0) \n        { \n            n >>= 1; \n            count += 1; \n        } \n\n        return 1 << count; \n    } \n    long long countSubarrays(vector<int>& arr, int k) {\n      int n=arr.size();\n      int nn=nextPowerOf2(2*n);\n      vector<int>t(nn);\n      build_tree(1,0,n-1,arr,t);\n      long long ans=0;\n      for(int i=0;i<n;i++)\n      {\n          int ind1=calc1(i,n,k,t);\n          int ind2=calc2(i,n,k,t);\n          ans+=1ll*max(0,ind2-ind1+1);\n      }\n        return ans;\n    }\n};",
    "submit_ts": "1720279827",
    "subm_id": "1311766706"
}