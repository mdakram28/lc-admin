{
    "username": "STARs_56789",
    "submission": "#ifndef LOCAL\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\n\nnamespace mitsuha{\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &A) {\n    os << A.first << \" \" << A.second;\n    return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &A) {\n    for (size_t i = 0; i < A.size(); i++) {\n        if (i) os << \" \";\n        os << A[i];\n    }\n    return os;\n}\n\nvoid print() {\n    std::cout << \"\\n\";\n    std::cout.flush();\n}\n\ntemplate <class Head, class... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n    std::cout << head;\n    if (sizeof...(Tail)) std::cout << \" \";\n    print(std::forward<Tail>(tail)...);\n}\n}\n\nnamespace mitsuha {\ntemplate <class T> bool chmin(T& x, const T& y) { \n    return y >= x ? false : (x = y, true); \n}\ntemplate <class T> bool chmax(T& x, const T& y) { \n    return y <= x ? false : (x = y, true); \n}\ntemplate <class T> constexpr T fld(const T x, const T y) { \n    T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); \n}\ntemplate <class T> constexpr T cld(const T x, const T y) { \n    T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); \n}\ntemplate <class T> constexpr T rem(const T x, const T y) { \n    return x - y * fld(x, y); \n}\ntemplate <class Iterable> void settify(Iterable& a) { \n    std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); \n}\ntemplate <size_t D> struct Dim : std::array<int, D> {\n    template <typename ...Ints> Dim(const Ints& ...ns) : \n        std::array<int, D>::array{ static_cast<int>(ns)... } {}\n};\ntemplate <typename ...Ints> Dim(const Ints& ...) -> Dim<sizeof...(Ints)>;\ntemplate <class T, size_t D, size_t I = 0>\nauto ndvec(const Dim<D> &ns, const T& value = {}) {\n    if constexpr (I + 1 < D) {\n        return std::vector(ns[I], ndvec<T, D, I + 1>(ns, value));\n    } else {\n        return std::vector<T>(ns[I], value);\n    }\n}\n}\n\nnamespace mitsuha {\nusing str = std::string;\nusing int128 = __int128;\nusing uint128 = unsigned __int128;\ntemplate <class T> using min_priority_queue \n                            = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T> using max_priority_queue \n                            = std::priority_queue<T, std::vector<T>, std::less<T>>;\n}\nnamespace mitsuha { \n    const std::vector<std::string> Yes = {\"No\", \"Yes\"};\n    const std::vector<std::string> YES = {\"NO\", \"YES\"};\n}\n \n#ifndef __COUNTER__\n#define __COUNTER__ __LINE__\n#endif\n\n#define TL (long long)\n \n#define OVERLOAD5(a, b, c, d, e, ...) e\n#define REP1_0(b, c) REP1_1(b, c)\n#define REP1_1(b, c) for (long long REP_COUNTER_##c = 0; REP_COUNTER_##c < TL(b); ++REP_COUNTER_##c)\n#define REP1(b) REP1_0(b, __COUNTER__)\n#define REP2(i, b) for (long long i = 0; i < TL(b); ++i)\n#define REP3(i, a, b) for (long long i = TL(a); i < TL(b); ++i)\n#define REP4(i, a, b, c) for (long long i = TL(a); i < TL(b); i += TL(c))\n#define For(...) OVERLOAD5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)\n#define RREP2(i, a) for (long long i = TL(a)-1; i >= 0; --i)\n#define RREP3(i, a, b) for (long long i = TL(b)-1; i >= TL(a); --i)\n#define RREP4(i, a, b, c) for (long long i = TL(b)-1; i >= TL(a); i -= TL(c))\n#define Frr(...) OVERLOAD5(__VA_ARGS__, RREP4, RREP3, RREP2)(__VA_ARGS__)\n\n#define All(iterable) std::begin(iterable), std::end(iterable)\n#define len(iterable) TL iterable.size()\n#define elif else if\n\n#define KBIT(a, k) (a & (1ULL << k))\n\n#define Assert(x) void(0);\n\nusing namespace mitsuha;\nusing namespace std;\n \nconstexpr int iinf = std::numeric_limits<int>::max() / 2;\nconstexpr long long linf = std::numeric_limits<long long>::max() / 2;\n\nnamespace mitsuha{\nstruct UnionFind{\n    int n, _group_count;\n    vector<int> p;\n    vector<list<int>> group;\n    UnionFind(){ }\n    UnionFind(int n): n(n), _group_count(n), p(n, -1), group(n){\n        Assert(n >= 0);\n        for(auto i = 0; i < n; ++ i) group[i] = {i};\n    }\n    int root(int u){\n        Assert(0 <= u && u < n);\n        return p[u] < 0 ? u : p[u] = root(p[u]);\n    }\n    int operator[](int u) { return root(u); }\n    bool same(int u, int v){\n        Assert(0 <= min(u, v) && max(u, v) < n);\n        return root(u) == root(v);\n    }\n    int size(int u){\n        Assert(0 <= u && u < n);\n        return -p[root(u)];\n    }\n    bool merge(int u, int v){\n        Assert(0 <= min(u, v) && max(u, v) < n);\n        u = root(u), v = root(v);\n        if(u == v) return false;\n        -- _group_count;\n        if(p[u] > p[v]) swap(u, v);\n        p[u] += p[v], p[v] = u;\n        group[u].splice(group[u].end(), group[v]);\n        return true;\n    }\n    int group_count() const{\n        return _group_count;\n    }\n    const list<int> &group_of(int u){\n        Assert(0 <= u && u < n);\n        return group[root(u)];\n    }\n    vector<vector<int>> group_up(){\n        vector<vector<int>> g(n);\n        for(auto i = 0; i < n; ++ i) g[root(i)].push_back(i);\n        g.erase(remove_if(g.begin(), g.end(), [&](auto &s){ return s.empty(); }), g.end());\n        return g;\n    }\n    void clear(){\n        _group_count = n;\n        fill(p.begin(), p.end(), -1);\n        for(auto i = 0; i < n; ++ i) group[i] = {i};\n    }\n};\n\nostream &operator<<(ostream &out, const UnionFind &ds){\n    auto dsu = ds;\n    auto gs = dsu.group_up();\n    out << \"{\";\n    if(!gs.empty()) for(auto i = 0; i < (int)gs.size(); ++ i){\n            out << \"{\";\n            for(auto j = 0; j < (int)gs[i].size(); ++ j){\n                out << gs[i][j];\n                if(j + 1 < (int)gs[i].size()) out << \", \";\n            }\n            out << \"}\";\n            if(i + 1 < (int)gs.size()) out << \", \";\n        }\n    return out << \"}\";\n}\n} // namespace mitsuha\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = len(circles);\n    \n        UnionFind uf(n + 4);\n\n        For(x, n) For(y, x + 1, n){\n            // x, y, r\n            long long dist = abs(circles[x][0] - circles[y][0]) * TL abs(circles[x][0] - circles[y][0]) + \n                                abs(circles[x][1] - circles[y][1]) * TL abs(circles[x][1] - circles[y][1]);\n            long long r = (circles[x][2] + circles[y][2]) * TL (circles[x][2] + circles[y][2]);\n\n            if (dist <= r){\n                uf.merge(x, y);\n            }\n        }\n\n        For(x, n){\n            if (circles[x][0] + circles[x][2] >= X) uf.merge(x, n);\n            if (circles[x][0] - circles[x][2] <= 0) uf.merge(x, n + 1);\n            if (circles[x][1] + circles[x][2] >= Y) uf.merge(x, n + 2);\n            if (circles[x][1] - circles[x][2] <= 0) uf.merge(x, n + 3);\n        }\n\n        bool ans = true;\n        if (uf.same(n + 2, n + 3)) ans = false;\n        if (uf.same(n + 0, n + 1)) ans = false;\n        if (uf.same(n + 0, n + 2)) ans = false;\n        if (uf.same(n + 1, n + 3)) ans = false;\n        return ans;\n    }\n};\n\n",
    "submit_ts": "1722134703",
    "subm_id": "1335675409"
}