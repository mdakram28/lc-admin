{
    "username": "9iSL5Z7hA7",
    "submission": "#include <vector>\n#include <unordered_map>\n#include <iostream>\n\nclass Solution {\npublic:\n    long long countSubarrays(std::vector<int>& nums, int k) {\n        long long count = 0;\n        int n = nums.size();\n        std::unordered_map<int, int> andMap; // map to store the last occurrence of each AND value\n        std::unordered_map<int, int> freqMap; // map to store the frequency of each AND value\n        \n        for (int i = 0; i < n; ++i) {\n            std::unordered_map<int, int> newMap; // temporary map to store new AND values\n            \n            // Update the map with AND of current number with all previous AND values\n            for (const auto& [val, freq] : freqMap) {\n                int newVal = val & nums[i];\n                newMap[newVal] += freq;\n            }\n            \n            // Also consider the subarray starting with the current element itself\n            newMap[nums[i]]++;\n            \n            // Update the frequency map\n            freqMap = newMap;\n            \n            // If k is in the frequency map, add its frequency to the count\n            if (freqMap.find(k) != freqMap.end()) {\n                count += freqMap[k];\n            }\n        }\n        \n        return count;\n    }\n};\n\n\n",
    "submit_ts": "1720277316",
    "subm_id": "1311657992"
}