{
    "username": "evancui",
    "submission": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing STR=string; using LL=long long;\ntemplate<class T> using V=vector<T>;template<class T> using VV=V<V<T>>; template<class T1, class T2> using P=pair<T1, T2>;\ntemplate<class T1, class T2> using M=map<T1, T2>; template<class T1, class T2> using UM=unordered_map<T1, T2>;\ntemplate<class T> using S=set<T>; template<class T> using US=unordered_set<T>;\nusing VI=V<int>; using VVI=V<VI>; using VLL=V<LL>; using VVLL=V<VLL>; using VS=V<STR>; using VB=V<bool>; using VVB=VV<bool>;\nusing PII=P<int, int>; using MII=M<int, int>; using SI=S<int>; using UII=UM<int, int>; using UI=US<int>;\ntemplate<class T> using PQG=priority_queue<T, V<T>, greater<T>>;template<class T> using PQL=priority_queue<T, V<T>, less<T>>;\ntemplate<class...P> using TP=tuple<P...>;\nV<PII> dir4{{-1,0},{1,0},{0,-1},{0,1}};\nV<PII> dir8{{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\nPII operator+(PII a, PII b){return{a.first+b.first,a.second+b.second};}VI operator+(VI& a,VI& b){return{a[0]+b[0],a[1]+b[1]};}\nPII operator+(PII a, VI b){return{a.first+b[0],a.second+b[1]};}VI operator+(VI a,PII b){return{a[0]+b.first,a[1]+b.second};}\nPII to_pii(VI a){return{a[0],a[1]};}VI to_vi(PII a){return{a.first,a.second};}\n#define FOR(i, n) for (int i = 0; i < int(n); i++)\nauto dummy = [](){ cin.tie(nullptr); return ios::sync_with_stdio(false); }();\nstruct ufs {\n    VI u;\n    ufs(int n) : u(n) { FOR (i, n) u[i] = i; }\n    int find(int i) { return i == u[i] ? i : (u[i] = find(u[i])); }\n    void uni(int i, int j) { u[find(i)] = find(j); }\n};\nstruct fenwick {\n    vector<int> f;\n    fenwick(int n) : f(n + 1) { }\n    int lowbit(int i) { return i & -i; }\n    void add(int i, int d) { while (i < (int)f.size()) { f[i] += d; i += lowbit(i); } }\n    int ask(int i) { int ans = 0; while (i > 0) { ans += f[i]; i -= lowbit(i); } return ans;}\n};\nconst int mod1e9 = 1e9+7, mod9 = 998244353, mod = mod1e9;\nconst int INF = 1e9;\nconst LL LINF = 1e18;\nLL bitpow(LL b, LL p, int md = mod) {\n    LL ans = 1;\n    while (p) {\n        if (p & 1) { ans *= b; ans %= md; }\n        p >>= 1; b *= b; b %= md;\n    }\n    return ans;\n}\nUM<int, LL> _permutations;\nLL perm(int i, int md = mod) {\n    if (i == 0) return 1;\n    if (!_permutations.count(i)) {\n        LL ans = perm(i-1) * i; ans %= md; _permutations[i] = ans;\n    }\n    return _permutations[i];\n}\nclass logger {\n    template<class T> inline static void _info(const T &v) { cout << v; }\n    inline static void _info(const string &v) { cout << v; }\n    template<class K, class V> inline static void _info(const pair<K, V> &v) { info<'\\0', false>('(', v.first, ',', v.second, ')'); }\n    template<template<class...>class M,class...T>\n    inline static void _info(const M<T...> &v){_info(\"[\");int o=0;for(const auto &p:v){o++>0&&cout<<\",\";_info(p);}_info(\"]\");}\n    template <size_t i=0, class... T> inline static void _info(const tuple<T...> &a) {\n        const auto n=sizeof...(T);if(!i)_info(\"<\");if constexpr(i<n){_info(get<i>(a));if(i<n-1)_info(\",\");_info<i+1>(a);}if (i==n)_info(\">\");\n    }\npublic:\n    template <char sep = ',', bool el = true, class... T> inline static void info(const T &...a) {\n        size_t o=0; [_={(_info(a),++o<sizeof...(a)?(sep&&cout<<sep):(el&&cout<<endl))...}]{};\n    }\n};\n\n#define LO\ntemplate <class... T> inline static void info(const T &...args) {\n#ifdef LOG\n    logger::info(args...);\n#endif\n}\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        fenwick f(n);\n        \n        for (int i = 1; i < n-1; i++) {\n            if (nums[i] > nums[i-1] && nums[i] > nums[i+1]) {\n                f.add(i, 1);\n            }\n        }\n        \n        vector<int> ans;\n        \n        for (auto &q : queries) {\n            int t = q[0];\n            if (t == 1) {\n                int i = q[1], j = q[2];\n                if (j - 1 < i + 1 || j - 1 < 0) ans.push_back(0);\n                else {\n                    ans.push_back(f.ask(j-1) - f.ask(i));\n                }\n            } else {\n                int i = q[1], v = q[2];\n                auto proc = [&](int x, int d) {\n                    if (x <= 0 || x >= n-1) return;\n                    if (nums[x] > nums[x-1] && nums[x] > nums[x+1]) {\n                        f.add(x, d);\n                    }\n                };\n                \n                proc(i, -1);\n                proc(i-1, -1);\n                proc(i+1, -1);\n                \n                nums[i] = v;\n                \n                proc(i, 1);\n                proc(i-1, 1);\n                proc(i+1, 1);\n            }\n            \n            info(f.f);\n            info(nums);\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": "1718508339",
    "subm_id": "539786771"
}