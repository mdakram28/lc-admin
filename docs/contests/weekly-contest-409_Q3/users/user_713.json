{
    "username": "theeeeeeekhai",
    "submission": "typedef long long ll;\n\nclass SegmentTree{\npublic:\n    vector<ll> tree, lazy, mx;\n    SegmentTree(int n){\n        mx.resize(4 * n);\n        tree.resize(4 * n);\n        lazy.resize(4 * n);\n    }\n\n    void buildTree(int idx, int low, int high, vector<int>& arr){\n        lazy[idx] = 0;\n        if(low == high){\n            tree[idx] = arr[low];\n            mx[idx] = arr[low];\n            return;\n        }\n        int mid = (low + high) >> 1;\n        buildTree(2 * idx + 1, low, mid, arr);\n        buildTree(2 * idx + 2, mid + 1, high, arr);\n        tree[idx] = tree[2 * idx + 1] + tree[2 * idx + 2];\n        mx[idx] = max(tree[2 * idx + 1], tree[2 * idx + 2]);\n    }\n\n    long long query1(int idx, int low, int high, int l, int r){\n        if(lazy[idx] != 0){\n            tree[idx] += 1ll * (high - low + 1) * lazy[idx];\n            if(low != high){\n                lazy[2 * idx + 1] += lazy[idx];\n                lazy[2 * idx + 2] += lazy[idx];\n            }\n            lazy[idx] = 0;\n        }\n        if(r < low || high < l) return 0;\n        if(low >= l && high <= r) return tree[idx];\n        int mid = (low + high) >> 1;\n        ll left = query1(2 * idx + 1, low, mid, l, r);\n        ll right = query1(2 * idx + 2, mid + 1, high, l, r);\n        return left + right;\n    }\n\n    int query2(int idx, int low, int high, int r, int i){\n        if(mx[idx] < i || low >= r) {\n            // cout << low << \" \" << high << \" \" << r << \" \" << i << endl;\n            return -1;\n        }\n        if(low == high) return mx[idx];\n        int mid = (low + high) >> 1;\n        int right = query2(2 * idx + 2, mid + 1, high, r, i);\n        if(right == -1) return query2(2 * idx + 1, low, mid, r, i);\n        return right;\n    }\n\n    long long query3(int idx, int low, int high, int l, int r){\n        if(r < low || high < l) return 0;\n        if(low >= l && high <= r) return mx[idx];\n        int mid = (low + high) >> 1;\n        ll left = query3(2 * idx + 1, low, mid, l, r);\n        ll right = query3(2 * idx + 2, mid + 1, high, l, r);\n        return max(left, right);\n    }\n\n    void update1(int idx, int low, int high, int l, int r, int val){\n        if(lazy[idx] != 0){\n            tree[idx] += 1ll * (high - low + 1) * lazy[idx];\n            if(low != high){\n                lazy[2 * idx + 1] += lazy[idx];\n                lazy[2 * idx + 2] += lazy[idx];\n            }\n            lazy[idx] = 0;\n        }\n        if(r < low || high < l) return;\n        if(low >= l && high <= r){\n            tree[idx] += 1ll * (high - low + 1) * val;\n            if(low != high){\n                lazy[2 * idx + 1] += val;\n                lazy[2 * idx + 2] += val;\n            }\n            return;\n        }\n        int mid = (low + high) >> 1;\n        update1(2 * idx + 1, low, mid, l, r, val);\n        update1(2 * idx + 2, mid + 1, high, l, r, val);\n        tree[idx] = tree[2 * idx + 1] + tree[2 * idx + 2];\n    }\n\n    void update2(int idx, int low, int high, int i, int val){\n        if(high == low){\n            mx[idx] = val;\n            return;\n        }\n        int mid = (low + high) >> 1;\n        if(i <= mid) update2(2 * idx + 1, low, mid, i, val);\n        else update2(2 * idx + 2, mid + 1, high, i, val);\n        mx[idx] = max(mx[2 * idx + 1], mx[2 * idx + 2]);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int> ans;\n        vector<int> dist(n);\n        vector<int> r(n);\n        for(int i = 0; i < n; i++) {\n            dist[i] = n - i - 1;\n            if(i != 0) {\n                r[i - 1] = i;\n            }\n        }\n        SegmentTree sg1(n), sg2(n);\n        sg1.buildTree(0, 0, n - 1, dist);\n        sg2.buildTree(0, 0, n - 1, r);\n        for(auto& q: queries) {\n            int a = q[0], b = q[1];\n            int idx = sg2.query2(0, 0, n - 1, a, b) + 1;\n            int nd = sg1.query1(0, 0, n - 1, b, b) + 1;\n            int od = sg1.query1(0, 0, n - 1, a, a);\n\n\n            // for(int i = 0; i < n; i++) {\n            //     cout << sg2.query3(0, 0, n - 1, i, i) << \" \";\n            // }\n            // cout << endl;\n\n            // cout << idx << endl;\n\n            if(a >= idx) sg1.update1(0, 0, n - 1, idx, a, -max(0, od - nd));\n            sg2.update2(0, 0, n - 1, a, max(r[a], b));\n            ans.push_back(sg1.query1(0, 0, n - 1, 0, 0));\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722742493",
    "subm_id": "1343770255"
}