{
    "username": "fmota",
    "submission": "template <typename T>\nstruct fenwick {\n    int n, lgn;\n    vector<T> fenw;\n    fenwick(int n): n(n) {\n        for(lgn = 0; (1<<lgn) <= n; lgn++);\n        fenw.resize(n);\n    }\n    T get(int p){\n        T r = T();\n        for(; p; p -= p & -p)\n            r = r + fenw[p];\n        return r;\n    }\n    T get(int l, int r){\n        return get(r) - get(l - 1);\n    }\n    void add(int p, T v){\n        for(; p < n; p += p & -p)\n            fenw[p] = fenw[p] + v;\n    }\n    int lower_bound(T v){\n        int p = 0;\n        T sum = 0;\n        for(int i = lgn - 1; i >= 0; i--){\n            int np = p + (1<<i);\n            if(np < n && sum + fenw[np] < v){\n                p = np;\n                sum = sum + fenw[p];\n            }\n        }\n        return p + 1;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> numberOfAlternatingGroups(vector<int>& A, vector<vector<int>>& qu) {\n        int n = A.size();\n        set<int> on;\n        for(int i = 0; i < n; i++){\n            int j = (i + 1) % n;\n            if(A[i] == A[j]){\n                on.insert(i);\n            }\n        }\n        auto get_dist = [&](int l, int r){\n            int d = (r - l + n); \n            d %= n;\n            if(d == 0){\n                return n;\n            }\n            return d;\n        };\n        int M = n + 1;\n        fenwick<int> cnt(M), sum(M);\n        if(on.empty()){\n            \n        } else {\n            for(int v : on){\n                auto it = on.lower_bound(v);\n                it++;\n                if(it == on.end()){\n                    it = on.begin();\n                }\n                int dist = get_dist(v, *it);\n                cnt.add(dist, 1);\n                sum.add(dist, dist);\n            }\n        }\n        auto rem = [&](int pos){\n            assert(!on.empty());\n            if(on.size() == 1){\n                cnt.add(n, -1);\n                sum.add(n, -n);\n                on.clear();\n                return;\n            }\n            auto it = on.lower_bound(pos);\n            auto pv = it;\n            if(pv == on.begin()){\n                pv = prev(on.end());\n            } else {\n                pv--;\n            }\n            auto nx = it; nx++;\n            if(nx == on.end()){\n                nx = on.begin();\n            }\n            int d_pv_pos = get_dist(*pv, pos), d_pos_nx = get_dist(pos, *nx);\n            cnt.add(d_pv_pos, -1);\n            sum.add(d_pv_pos, -d_pv_pos);\n            cnt.add(d_pos_nx, -1);\n            sum.add(d_pos_nx, -d_pos_nx);\n            int d_pv_nx = get_dist(*pv, *nx);\n            cnt.add(d_pv_nx, 1);\n            sum.add(d_pv_nx, d_pv_nx);\n            on.erase(pos);\n        };\n        auto ins = [&](int pos){\n            if(on.empty()){\n                on.insert(pos);\n                cnt.add(n, 1);\n                sum.add(n, n);\n                return;\n            }\n            auto it = on.lower_bound(pos);\n            auto nx = it;\n            if(nx == on.end()){\n                nx = on.begin();\n            }\n            auto pv = it;\n            if(pv == on.begin()){\n                pv = prev(on.end());\n            } else {\n                pv--;\n            }\n            int d_pv_nx = get_dist(*pv, *nx);\n            cnt.add(d_pv_nx, -1);\n            sum.add(d_pv_nx, -d_pv_nx);\n            int d_pv_pos = get_dist(*pv, pos), d_pos_nx = get_dist(pos, *nx);\n            cnt.add(d_pv_pos, 1);\n            sum.add(d_pv_pos, d_pv_pos);\n            cnt.add(d_pos_nx, 1);\n            sum.add(d_pos_nx, d_pos_nx);\n            on.insert(pos);\n        };\n        int q = qu.size();\n        vector<int> qans;\n        for(int i = 0; i < q; i++){\n            if(qu[i][0] == 1){\n                int s = qu[i][1];\n                int t = cnt.get(s, n);\n                int su = sum.get(s, n);\n                int res = su - t * (s - 1);\n                if(on.empty()){\n                    qans.push_back(n);\n                } else {\n                    qans.push_back(res);\n                }\n            } else {\n                int idx = qu[i][1], cor = qu[i][2];\n                int prv = (idx - 1 + n) % n, nxt = (idx + 1 + n) % n;\n                if(on.count(idx)){\n                    rem(idx);\n                }\n                if(on.count(prv)){\n                    rem(prv);\n                }\n                A[idx] = cor;\n                if(A[prv] == A[idx]){\n                    ins(prv);\n                }\n                if(A[idx] == A[nxt]){\n                    ins(idx);\n                }\n            }\n        }\n        return qans;\n    }\n};",
    "submit_ts": "1722741478",
    "subm_id": "1343745992"
}