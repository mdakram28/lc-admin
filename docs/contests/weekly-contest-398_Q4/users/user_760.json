{
    "username": "hemantpatil10125",
    "submission": "class Solution {\npublic:\n    //int ans = 0;\n    //map<pair<int,pair<int,pair<int,int>>>> mp;\n    \n    struct TupleHash {\n    template <class T1, class T2, class T3, class T4>\n    size_t operator()(const tuple<T1, T2, T3, T4>& t) const {\n        auto h1 = hash<T1>()(get<0>(t));\n        auto h2 = hash<T2>()(get<1>(t));\n        auto h3 = hash<T3>()(get<2>(t));\n        auto h4 = hash<T4>()(get<3>(t));\n        return h1 ^ h2 ^ h3 ^ h4;\n        }\n    };\n    \n    unordered_map<tuple<int, int, int, int>, int, TupleHash> dp;\n    \n    int solve(int cur , int jump , int ch , int req)\n    {\n        if(cur > req + 1 || cur < 0)\n        return 0;\n        \n        //if(mp.find({cur,{jump,{ch,req}}})!=mp.end())\n        //return mp[{cur,{jump,{ch,req}}}];\n        \n        auto key = make_tuple(cur, jump, ch, req);\n        if(dp.find(key)!=dp.end())\n        return dp[key];\n        \n        int ans = 0;\n        if(cur==req)\n        ans++;\n        \n        if(ch)\n        ans += solve(cur - 1,jump,0,req);\n        \n        ans += solve(cur + (1<<jump) , jump + 1,  1 , req);\n        \n        return dp[key] = ans;\n    }\n    int waysToReachStair(int k) \n    {\n        return solve(1,0,1,k);\n        \n    }\n};",
    "submit_ts": 1716088885.0
}