{
    "username": "Yuvraj Singh",
    "submission": "import java.util.Arrays;\nimport java.util.Comparator;\n\nclass Solution {\n    private long maxSum;\n    private boolean[] rowsUsed;\n    private boolean[] colsUsed;\n\n    public long maximumValueSum(int[][] board) {\n        int m = board.length;\n        int n = board[0].length;\n\n        // Initialize\n        maxSum = Long.MIN_VALUE;\n        rowsUsed = new boolean[m];\n        colsUsed = new boolean[n];\n\n        // Sort the cells based on their values in descending order\n        int[][] cells = new int[m * n][3]; // Store [value, row, col]\n        int index = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                cells[index++] = new int[] {board[i][j], i, j};\n            }\n        }\n\n        // Sort cells by value in descending order\n        Arrays.sort(cells, (a, b) -> Integer.compare(b[0], a[0]));\n\n        // Start backtracking\n        placeRooks(board, cells, m, n, 0, 0, 0);\n\n        return maxSum;\n    }\n\n    private void placeRooks(int[][] board, int[][] cells, int m, int n, int rookCount, long currentSum, int startIndex) {\n        // Base case: If three rooks are placed, update maxSum\n        if (rookCount == 3) {\n            maxSum = Math.max(maxSum, currentSum);\n            return;\n        }\n\n        // Estimate the potential maximum sum\n        long potentialMaxSum = currentSum;\n        int addedRooks = 0;\n        for (int i = startIndex; i < cells.length && addedRooks < 3 - rookCount; i++) {\n            int row = cells[i][1];\n            int col = cells[i][2];\n            if (!rowsUsed[row] && !colsUsed[col]) {\n                potentialMaxSum += cells[i][0];\n                addedRooks++;\n            }\n        }\n        if (potentialMaxSum <= maxSum) {\n            return; // Prune the branch if it cannot exceed maxSum\n        }\n\n        // Recursive case: Try placing a rook in every valid position\n        for (int i = startIndex; i < cells.length; i++) {\n            int row = cells[i][1];\n            int col = cells[i][2];\n            if (!rowsUsed[row] && !colsUsed[col]) {\n                // Place the rook at (row, col)\n                rowsUsed[row] = true;\n                colsUsed[col] = true;\n                // Recursively place the next rook\n                placeRooks(board, cells, m, n, rookCount + 1, currentSum + cells[i][0], i + 1);\n                // Backtrack\n                rowsUsed[row] = false;\n                colsUsed[col] = false;\n            }\n        }\n    }\n}\n",
    "submit_ts": "1723907858",
    "subm_id": "1359127465"
}