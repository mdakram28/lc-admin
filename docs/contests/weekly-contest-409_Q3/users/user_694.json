{
    "username": "destiny-god",
    "submission": "typedef pair<int, int> pi;\ntypedef pair<pi, pi> pii;\ntypedef vector<vector<vector<int>>> viii;\ntypedef vector<vector<int>> vii;\ntypedef vector<int> vi;\n#define x first\n#define y second\n\nclass Solution {\npublic:\n    class SegmentTree {\n    public:\n        vector<int>tree;\n        vector<int>mark;\n        int n=0;\n        void build(int n){\n            tree.resize((n<<2)+5);\n            mark.resize((n<<2)+5);\n            this->n = n;\n        }\n        void build(vector<int>&v){\n            build(v.size()-1);\n            build(v,1,n,1);\n        }\n        void update(int l,int r,int d){\n            update(l,r,d,1,n,1);\n        }\n        int query(int l,int r){\n            return query(l,r,1,n,1);\n        }\n    private:\n        void build(vector<int>&v,int l,int r,int p){\n            if(l==r){\n                tree[p]=v[l];\n                return;\n            }\n            int mid=(l+r)/2;\n            build(v,l,mid,p*2);\n            build(v,mid+1,r,p*2+1);\n            tree[p]=tree[p*2]+tree[p*2+1];\n        }\n        void update(int l,int r,int d,int cl,int cr,int p) {\n            if(cl>r||cr<l) return;\n            if(l<=cl&&r>=cr){\n                tree[p]=(cr-cl+1)*d;\n                mark[p]=d;\n                return;\n            }\n            int mid=(cl+cr)/2;\n            push_down(cr-cl+1,p);\n            update(l,r,d,cl,mid,p*2);\n            update(l,r,d,mid+1,cr,p*2+1);\n            tree[p]=tree[p*2]+tree[p*2+1];\n        }\n        int query(int l,int r,int cl,int cr,int p){\n            if(cl>r||cr<l) return 0;\n            if(cl>=l&&cr<=r) return tree[p];\n            int mid=(cl+cr)/2;\n            push_down(cr-cl+1,p);\n            return query(l,r,cl,mid,p*2)+query(l,r,mid+1,cr,p*2+1);\n        }\n        void push_down(int len,int p){\n            if(mark[p]==0) return;\n            mark[p*2]=mark[p];\n            mark[p*2+1]=mark[p];\n            tree[p*2]=(len-len/2)*mark[p];\n            tree[p*2+1]=(len/2)*mark[p];\n        }\n    };\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        int ans=n-1;\n        vector<int> res;\n        SegmentTree seg;\n        seg.build(n+1);\n        set<pi>p;\n        for(auto i:queries) {\n            int a=seg.query(i[0]+1,i[0]+1);\n            int s=seg.query(i[0]+1,i[1]);\n            vector<pi>del;\n            auto it=p.lower_bound(pi(i[0]+1,0));\n            int c=0;\n            while(it!=p.end()&&it->second<=i[1]) {\n                del.push_back(*it);\n                c++;\n                it++;\n            }\n            for(auto t:del) {\n                p.erase(t);\n            }\n            if(a==0||c>0){\n                ans-=(i[1]-i[0]-s)+(c-1);\n                seg.update(i[0]+1,i[1],1);\n                p.insert(pi(i[0]+1,i[1]));\n            }\n                \n            res.push_back(ans);\n        }\n        return res;\n    }\n};\n",
    "submit_ts": "1722742730",
    "subm_id": "552346524"
}