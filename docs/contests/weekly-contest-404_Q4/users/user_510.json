{
    "username": "mustafiz05",
    "submission": "typedef int ll;\nvector<ll>grone[100009], grtwo[100009];\nll maxiOne[100009], maxiTwo[100009];\nll maxi, newnode;\n\nvoid dfs1(ll node, ll parr, ll dep){\n    \n    maxiOne[node] = max(maxiOne[node], dep);\n    \n    if(dep > maxi) maxi = dep, newnode = node;\n    \n    for(ll i = 0; i < grone[node].size(); i++){\n        ll child = grone[node][i];\n        if(child == parr) continue;\n        dfs1(child,node, dep + 1);\n    }\n}\n\n\n\n\nvoid dfs2(ll node, ll parr, ll dep){\n    maxiTwo[node] = max(maxiTwo[node], dep);\n    \n    if(dep > maxi) maxi = dep, newnode = node;\n    \n    for(ll i = 0; i < grtwo[node].size(); i++){\n        ll child = grtwo[node][i];\n        if(child == parr) continue;\n        dfs2(child,node, dep + 1);\n    }\n}\n\n\n\n\n\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        \n         for(ll i = 0; i < edges1.size() + 8; i++) {\n            grone[i].clear();\n             maxiOne[i] =0;\n         }\n    \n        \n         for(ll i = 0; i < edges2.size() + 8; i++) {\n            grtwo[i].clear();\n             maxiTwo[i] =0;\n         }\n    \n        \n        \n        ll ans = 0;\n        \n        for(ll i = 0; i < edges1.size(); i++) {\n            ll u = edges1[i][0];\n            ll v = edges1[i][1];\n            \n            grone[u].push_back(v);\n            grone[v].push_back(u);\n            \n        }\n        \n        \n         for(ll i = 0; i < edges2.size(); i++) {\n            ll u = edges2[i][0];\n            ll v = edges2[i][1];\n            \n            grtwo[u].push_back(v);\n            grtwo[v].push_back(u);\n            \n        }\n        \n        \n        /** for first tree **/\n        \n        maxi = newnode = 0;\n        \n        dfs1(0, -1,0);\n        \n        \n        ll firstD1 = newnode;\n        \n        \n        \n        maxi = newnode = 0;\n        \n        dfs1(firstD1, - 1, 0);\n        \n        \n        ll firstD2 = newnode;\n        \n        maxi = newnode = 0;\n        \n        dfs1(firstD2, - 1, 0);\n        \n        \n        \n        \n        \n        ans = maxi;\n        \n        \n        \n        \n        \n        \n        \n         /** for second tree **/\n        \n        maxi = newnode = 0;\n        \n        dfs2(0, -1,0);\n        \n        \n        ll secondD1 = newnode;\n        \n        \n        \n         maxi = newnode = 0;\n        \n        dfs2(secondD1, - 1, 0);\n        \n        \n     \n        \n        ll secondD2 = newnode;\n        \n        \n        maxi = newnode = 0;\n        dfs2(secondD2, - 1, 0);\n        \n        \n        ans = max(ans, maxi );\n        \n        \n        \n        ll one = 1e8;\n        ll two = 1e8;\n        \n        \n        \n        for(ll i = 0; i < edges1.size() + 1; i++) one = min(one, maxiOne[i] );\n        for(ll i = 0; i < edges2.size() + 1; i++) two = min(two, maxiTwo[i] );\n        \n        if(one == 1e8) one = 0;\n        if(two == 1e8) two = 0;\n        \n        \n        ans = max(ans, one + two + 1 );\n        \n        \n        return ans;\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n};",
    "submit_ts": "1719717116",
    "subm_id": "1304382892"
}