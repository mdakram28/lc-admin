{
    "username": "anna-hcj",
    "submission": "/**\n * @param {number[][]} edges1\n * @param {number[][]} edges2\n * @return {number}\n */\nvar minimumDiameterAfterMerge = function(edges1, edges2) {\n  let [maxInTreeOne, onePathTreeOne] = getMinHeight(edges1);\n  let [maxInTreeTwo, onePathTreeTwo] = getMinHeight(edges2);\n  return Math.max(onePathTreeOne + onePathTreeTwo + 1, maxInTreeOne, maxInTreeTwo);\n};\n\nfunction getMinHeight(edges) {\n  let n = edges.length + 1;\n  let graph = Array(n).fill(0).map(() => []);\n  for (let [a, b] of edges) {\n    graph[a].push(b);\n    graph[b].push(a);\n  }\n  let minHeightRoots = findMinHeightTrees(n, edges);\n  let maxLenWithinTree = 0;\n  let maxLen = dfs(minHeightRoots[0]);\n  return [maxLenWithinTree - 1, maxLen - 1];\n\n  function dfs(node, parent) {\n    let maxLen = 0, secondMaxLen = 0;\n    for (let nei of graph[node]) {\n      if (nei === parent) continue;\n      let len = dfs(nei, node);\n      if (len >= maxLen) {\n        secondMaxLen = maxLen;\n        maxLen = len;\n      } else if (len > secondMaxLen) {\n        secondMaxLen = len;\n      }\n    }\n    maxLenWithinTree = Math.max(maxLenWithinTree, maxLen + secondMaxLen + 1);\n    return maxLen + 1;\n  }  \n}\n\nfunction findMinHeightTrees(n, edges) {\n  let graph = Array(n).fill(0).map(() => []);\n  let indegrees = Array(n).fill(0);\n  for (let [a, b] of edges) {\n    graph[a].push(b);\n    graph[b].push(a);\n    indegrees[a]++;\n    indegrees[b]++;\n  }\n  let queue = [];\n  for (let node = 0; node < n; node++) {\n    if (indegrees[node] <= 1) {\n      queue.push(node);\n    }\n  }\n  let remaining = n;\n  while (remaining > 2) {\n    let next = [];\n    while (queue.length) {\n      let node = queue.pop();\n      remaining--;\n      while (graph[node].length > 0) {\n        let nei = graph[node].pop();\n        indegrees[nei]--;\n        if (indegrees[nei] === 1) {\n          next.push(nei);\n        }\n      }\n    }\n    queue = next;\n  }\n  return queue;\n};",
    "submit_ts": 1719719417.0
}