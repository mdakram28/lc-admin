{
    "username": "sampleaccountpage",
    "submission": "from collections import defaultdict, deque\nfrom collections import defaultdict\nfrom queue import Queue\n\ndef rootForMinimumHeight(edges):\n    # Create the graph\n    graph = defaultdict(list)\n    degree = defaultdict(int)\n    vertices = set()\n\n    # Build the graph and compute degrees\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degree[u] += 1\n        degree[v] += 1\n        vertices.add(u)\n        vertices.add(v)\n\n    V = len(vertices)\n    q = Queue()\n\n    # Enqueue all leaf nodes\n    for v in vertices:\n        if degree[v] == 1:\n            q.put(v)\n\n    # Perform BFS\n    while V > 2:\n        level_size = q.qsize()\n        V -= level_size\n\n        for _ in range(level_size):\n            v = q.get()\n            for neighbor in graph[v]:\n                degree[neighbor] -= 1\n                if degree[neighbor] == 1:\n                    q.put(neighbor)\n\n    # Return the remaining vertices (roots)\n    return list(q.queue)\n\ndef get_diameter(graph):\n    diameter = 0\n\n    def dfs(curr, parent):\n        \"\"\"\n            return the max distance\n                starting from the 'curr' node to its leaf nodes\n        \"\"\"\n        nonlocal diameter\n\n        # the top 2 distance starting from this node\n        top_1_distance, top_2_distance = 0, 0\n\n        for neighbor in graph[curr]:\n            if neighbor == parent:\n                continue\n\n            distance = 1 + dfs(neighbor, curr)\n\n            if distance > top_1_distance:\n                top_1_distance, top_2_distance = distance, top_1_distance\n            elif distance > top_2_distance:\n                top_2_distance = distance\n\n        # with the top 2 distance, we can update the current diameter\n        diameter = max(diameter, top_1_distance + top_2_distance)\n\n        return top_1_distance\n\n    dfs(0, -1)\n    return diameter\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:    \n        if not edges1 and not edges2:\n            return 1\n\n        if not edges1:\n            graph = defaultdict(set)\n        \n            for a, b in edges2:\n                graph[a].add(b)\n                graph[b].add(a)\n            \n            d = get_diameter(graph)\n            return d if d > 1 else d + 1\n        if not edges2:\n            graph = defaultdict(set)\n        \n            for a, b in edges1:\n                graph[a].add(b)\n                graph[b].add(a)\n            d = get_diameter(graph)\n            return d if d > 1 else d + 1\n\n        left = rootForMinimumHeight(edges1)[0]\n        right = rootForMinimumHeight(edges2)[0]\n        offset = 10 ** 5 + 1\n        graph = defaultdict(set)\n        \n        for a, b in edges1:\n            graph[a].add(b)\n            graph[b].add(a)\n        \n        for a, b in edges2:\n            a += offset\n            b += offset\n            graph[a].add(b)\n            graph[b].add(a)\n        graph[left].add(right + offset)\n        graph[right + offset].add(left)\n\n        return get_diameter(graph)",
    "submit_ts": 1719719973.0
}