{
    "username": "pB3X9bravM",
    "submission": "class Solution {\npublic:\n    long long minimumCostOfBreaking(vector<int> X, vector<int> Y, int M, int N){\n       priority_queue<int>pq1(X.begin(),X.end()),pq2(Y.begin(),Y.end());\n       long long v=1,h=1;\n       long long ans=0;\n       while(pq1.size() and pq2.size()){\n           if(pq1.top()>pq2.top()){\n               ans+=pq1.top()*h;\n               v++;pq1.pop();\n           }\n           else{\n                 ans+=pq2.top()*v;\n               h++; pq2.pop(); \n           }\n       }\n       \n       \n          while(pq1.size() ){\n        //   if(pq1.top()>pq2.top()){\n               ans+=pq1.top()*h;\n               v++;pq1.pop();\n       }\n          while(pq2.size()){\n       \n                 ans+=pq2.top()*v;\n              pq2.pop(); \n        //   }\n       }\n       \n       return ans;\n    }\n    long long minimumCost(int m, int n, vector<int>& horizontalCut, vector<int>& verticalCut) {\n         return minimumCostOfBreaking(horizontalCut,verticalCut,n,m);\n    }\n};",
    "submit_ts": "1720925887",
    "subm_id": "1320269410"
}