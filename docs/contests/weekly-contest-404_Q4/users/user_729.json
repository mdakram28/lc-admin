{
    "username": "hoanghonghieu",
    "submission": "class Solution {\npublic:\n    pair<int, int> minHeight(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vector<int> incoming(n);\n        vector<vector<int>> adjacents(n);\n        vector<bool> visited(n);\n        for (auto& edge : edges) {\n            for (int i = 0; i < 2; i++) {\n                incoming[edge[i]]++;\n                adjacents[edge[i]].push_back(edge[(i + 1) % 2]);\n            }\n        }\n\n        queue<int> ready;\n        for (int i = 0; i < n; i++) {\n            if (incoming[i] == 1) {\n                ready.push(i);\n                visited[i] = true;\n            }\n        }\n        int height = 0;\n        int lastSize = 0;\n        while (!ready.empty()) {\n            // bfs\n            lastSize = ready.size();\n            for (int i = ready.size(); i > 0; i--) {\n                int node = ready.front();\n                ready.pop();\n                for (auto neighbor : adjacents[node]) {\n                    if (visited[neighbor] == false) {\n                        incoming[neighbor]--;\n                        if (incoming[neighbor] == 1) {\n                            ready.push(neighbor);\n                            visited[neighbor]  = true;\n                        }\n                    }\n                }\n            }\n            height++;\n        }\n        if (lastSize == 2) height++;\n\n        height--;\n        // cout << height << \" \" << (lastSize == 2 ? height * 2 - 1 : height * 2 )<< endl;\n        return {max(0, height), lastSize == 2 ? height * 2 - 1 : height * 2};\n    };\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        auto [h1, d1] = minHeight(edges1);\n        auto [h2, d2] = minHeight(edges2);\n        int ans = max(d1, d2);\n        return max(ans, h1 + h2 + 1);\n    }\n};",
    "submit_ts": "1719719680",
    "subm_id": "1304447921"
}