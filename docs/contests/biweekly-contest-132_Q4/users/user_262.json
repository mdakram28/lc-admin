{
    "username": "varangrai",
    "submission": "class SegmentTree {\nprivate:\n    vector<int> tree;\n    vector<int> data;\n    int n;\n\n    void build(int node, int start, int end) {\n        if (start == end) {\n            tree[node] = data[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(2 * node + 1, start, mid);\n            build(2 * node + 2, mid + 1, end);\n            tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    void update(int node, int start, int end, int idx, int value) {\n        if (start == end) {\n            data[start] = value;\n            tree[node] = value;\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid)\n                update(2 * node + 1, start, mid, idx, value);\n            else\n                update(2 * node + 2, mid + 1, end, idx, value);\n            tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    int query(int node, int start, int end, int l, int r) {\n        if (r < start || end < l)\n            return INT_MIN; // return minimum value for max query\n        if (l <= start && end <= r)\n            return tree[node];\n        int mid = (start + end) / 2;\n        int left_query = query(2 * node + 1, start, mid, l, r);\n        int right_query = query(2 * node + 2, mid + 1, end, l, r);\n        return max(left_query, right_query);\n    }\n\npublic:\n    SegmentTree(vector<int> values) {\n        data = values;\n        n = values.size();\n        tree.assign(4 * n, 0);\n        build(0, 0, n - 1);\n    }\n\n    void update(int idx, int value) { update(0, 0, n - 1, idx, value); }\n\n    int query(int l, int r) { return query(0, 0, n - 1, l, r); }\n};\n\nvoid compress(vector<int> &nums){\n    int n = nums.size();\n    map<int,int> mp;\n    int idx = 1;\n    for(int i=0;i<n;i++){\n        if(mp.find(nums[i])==mp.end()){\n            mp[nums[i]] = idx;\n            idx++;\n        }\n        nums[i] = mp[nums[i]];\n    }\n}\nclass Solution {\npublic:\n    int maximumLength(vector<int>& nums, int maxDiff) {\n        // dp[i][j][k] -> 0...i in consideration and last element is j\n        int n = nums.size();\n        int dp[n][maxDiff + 1];\n        memset(dp, 0, sizeof(dp));\n        vector<SegmentTree> vec;\n        compress(nums);\n        for(int i=0;i<=maxDiff;i++){\n            SegmentTree st = SegmentTree(vector<int>(n+3, 0));\n            vec.push_back(st);\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int k = 0; k <= maxDiff; k++) {\n                if (i == 0) {\n                    dp[i][k] = 1;\n                } else {\n                    dp[i][k] = 1;\n                    if (k > 0)\n                        dp[i][k] = dp[i][k - 1];\n                    dp[i][k] = max(dp[i][k], 1 + vec[k].query(nums[i], nums[i]));\n                    if(k>0)\n                        dp[i][k] = max(dp[i][k], 1 + max(vec[k-1].query(nums[i] +1, n+1), \n                                                         vec[k-1].query(0, nums[i] - 1)));\n                }\n                vec[k].update(nums[i], max(vec[k].query(nums[i], nums[i]), dp[i][k]));\n            }\n        }\n        int ans = 1;\n        for (int i = 0; i < n; i++)\n            ans = max(ans, dp[i][maxDiff]);\n        return ans;\n    }\n};",
    "submit_ts": 1717861626.0
}