{
    "username": "eliteCoder26",
    "submission": "using ll = long long;\nclass SegmentTree{\nprivate:\n\n\tvector<ll> tree;\n\tll N;\n\n\tvoid buildTree(ll l,ll r,int i,vector<ll>& arr){\n\t\tif (l==r){\n\t\t\ttree[i]=arr[l];\n\t\t\treturn;\n\t\t}\n\t\tll mid = (l+r)/2;\n\t\tbuildTree(l,mid,2*i+1,arr);\n\t\tbuildTree(mid+1,r,2*i+2,arr);\n\t\ttree[i] = (tree[2*i+1]&tree[2*i+2]);\n\t}\n\n    ll query(ll x,ll y,ll l,ll r,ll i){\n\t\tif(r<x || l>y)return ((1LL<<34)-1);//no overlap (all ones) \n\t\tif(l>=x && r<=y)return tree[i];//complete overlap\n\n\t\tll mid = (l+r)/2;\n\t\treturn (query(x,y,l,mid,2*i+1)&query(x,y,mid+1,r,2*i+2));\n\t}\n\n// \tvoid update(int idx,int new_val,int l,int r,int i){\n// \t\tif(l==r){\n// \t\t\ttree[i]=new_val;\n// \t\t\treturn;\n// \t\t}\n\n// \t\tint mid = (l+r)/2;\n// \t\tif(idx<=mid)update(idx,new_val,l,mid,2*i+1);\n// \t\telse update(idx,new_val,mid+1,r,2*i+2);\n// \t\ttree[i] = (tree[2*i+1]&tree[2*i+2]);\n// \t}\n\n\npublic:\n\n\tvoid buildTree(vector<ll>& arr){\n\t\tN = arr.size();\n\t\ttree.resize(4*N);\n\t\tbuildTree(0,N-1,0,arr);\n\t}\n\n\tll query(ll i,ll j){\n\t\treturn query(i,j,0,N-1,0);\n\t}\n\n// \tvoid update(int i,int val){\n// \t\tupdate(i,val,0,N-1,0);\n// \t}\n\n\t\n};\nclass Solution {\npublic:\n    \n    SegmentTree s;\n    int k;\n    vector<ll> a;\n    \n    \n    int find_first(int start,int n){ //first index in [start:n-1] where AND of subarray = k \n        //[1,\"2\",3]\n        //predicate is AND<=k\n        // FFFFFFFF\"T\"TTTTTTTT\n        \n//         for(int i=start;i<a.size();i++)cout<<a[i]<<\" \";\n//         cout<<endl;\n        \n//         for(int i=start;i<a.size();i++){\n//             cout<<s.query(start,i)<<\" \";\n//         }\n//         cout<<endl;\n        \n        \n        int l = start, h = n-1,mid;\n        while(h-l>1){\n            mid = (l+h)/2;\n            int and_val = s.query(start,mid);\n            if(and_val<=k){\n                h = mid;\n            }\n            else{\n                l =mid+1;\n            }\n        }\n        int ans=-1;\n        if(s.query(start,h)<=k)ans=h;\n        if(s.query(start,l)<=k)ans=l;\n        \n        if(ans==-1)return -1;\n        \n        if(s.query(start,ans)==k)return ans;\n        return -1;\n        \n    }\n    \n    int find_last(int start,int n){ //last index in [start:n-1] where AND of subarray = k \n        \n        //predicate is AND<k\n        // FFFFFFFF\"T\"TTTTTTT\n        \n        int l = start, h = n-1,mid;\n        while(h-l>1){\n            mid = (l+h)/2;\n            int and_val = s.query(start,mid);\n            if(and_val<k){\n                h = mid;\n            }\n            else{\n                l = mid+1;\n            }\n        }\n        int ans = -1;\n        if(s.query(start,h)<k)ans = h;\n        if(s.query(start,l)<k)ans = l;\n        if(ans==-1){\n            if(s.query(start,n-1)==k)return n-1;\n            return -1;\n        }\n        \n        if(s.query(start,ans)==k)return ans;\n        if(ans-1>=start && s.query(start,ans-1)==k)return ans-1;\n        return -1;\n        \n    }\n    \n    \n    long long countSubarrays(vector<int>& _nums, int _k) {\n        k = _k;\n        int n = _nums.size();\n        vector<ll> nums(n);\n        for(int i=0;i<n;i++)nums[i]=_nums[i];\n        a=nums;\n        s.buildTree(nums);\n        \n        ll cnt=0;\n        for(int i=0;i<n;i++){\n            // if(i!=1)continue;\n            //subarrays starting from nums[i];\n            // AND is decresing function\n            int start = find_first(i,n);\n            int end = find_last(i,n);\n            // cout<<i <<\" \"<< start<<\" \"<<end<<endl;\n            if(start==-1 || end==-1)continue;\n            cnt+=end-start+1;\n        }\n        \n        // for(int i=0;i<n;i++){\n        //     for(int j=i;j<n;j++){\n        //         cout<<i<<\" \"<<j<<\" \"<<s.query(i,j)<<endl;\n        //     }\n        // }\n        \n        return cnt;\n    }\n};",
    "submit_ts": "1720280345",
    "subm_id": "1311785892"
}