{
    "username": "LayCurse",
    "submission": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"inline\")\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<class T> struct cLtraits_identity{\n  using type = T;\n}\n;\ntemplate<class T> using cLtraits_try_make_signed =\n  typename conditional<\n    is_integral<T>::value,\n    make_signed<T>,\n    cLtraits_identity<T>\n    >::type;\ntemplate <class S, class T> struct cLtraits_common_type{\n  using tS = typename cLtraits_try_make_signed<S>::type;\n  using tT = typename cLtraits_try_make_signed<T>::type;\n  using type = typename common_type<tS,tT>::type;\n}\n;\ntemplate<class S, class T> inline auto min_L(S a, T b)\n-> typename cLtraits_common_type<S,T>::type{\n  return (typename cLtraits_common_type<S,T>::type) a <= (typename cLtraits_common_type<S,T>::type) b ? a : b;\n}\ntemplate<class S, class T> inline S divup_L(S a, T b){\n  return (a+b-1)/b;\n}\ntemplate<class S> inline void arrInsert(const int k, int &sz, S a[], const S aval){\n  int i;\n  sz++;\n  for(i=sz-1;i>k;i--){\n    a[i] = a[i-1];\n  }\n  a[k] = aval;\n}\ntemplate<class S, class T> inline void arrInsert(const int k, int &sz, S a[], const S aval, T b[], const T bval){\n  int i;\n  sz++;\n  for(i=sz-1;i>k;i--){\n    a[i] = a[i-1];\n  }\n  for(i=sz-1;i>k;i--){\n    b[i] = b[i-1];\n  }\n  a[k] = aval;\n  b[k] = bval;\n}\ntemplate<class S, class T, class U> inline void arrInsert(const int k, int &sz, S a[], const S aval, T b[], const T bval, U c[], const U cval){\n  int i;\n  sz++;\n  for(i=sz-1;i>k;i--){\n    a[i] = a[i-1];\n  }\n  for(i=sz-1;i>k;i--){\n    b[i] = b[i-1];\n  }\n  for(i=sz-1;i>k;i--){\n    c[i] = c[i-1];\n  }\n  a[k] = aval;\n  b[k] = bval;\n  c[k] = cval;\n}\ntemplate<class S, class T, class U, class V> inline void arrInsert(const int k, int &sz, S a[], const S aval, T b[], const T bval, U c[], const U cval, V d[], const V dval){\n  int i;\n  sz++;\n  for(i=sz-1;i>k;i--){\n    a[i] = a[i-1];\n  }\n  for(i=sz-1;i>k;i--){\n    b[i] = b[i-1];\n  }\n  for(i=sz-1;i>k;i--){\n    c[i] = c[i-1];\n  }\n  for(i=sz-1;i>k;i--){\n    d[i] = d[i-1];\n  }\n  a[k] = aval;\n  b[k] = bval;\n  c[k] = cval;\n  d[k] = dval;\n}\n#define main dummy_main\nint main(){\n  return 0;\n}\n#undef main\nint arr[1000000];\nint val[1000000];\nint dig[1000000];\nint sz;\nint res[1000000];\nint doit(int dep, int now, int k){\n  int i;\n  int j;\n  if(dep==sz){\n    if(now==0){\n      return 1;\n    }\n    return 0;\n  }\n  for(i=(10)-1;i>=(1);i--){\n    res[dig[dep]] = i;\n    if(doit(dep+1, (now+i*val[dep])%k, k)){\n      return 1;\n    }\n  }\n  return 0;\n}\nclass Solution{\n  public:\n  string largestPalindrome(int n, int k){\n    int i;\n    int j;\n    int t;\n    int nn;\n    string ans;\n    nn =(divup_L(n,2));\n    for(i=(0);i<(nn);i++){\n      arr[i] = 0;\n    }\n    t = 1;\n    for(i=(0);i<(n);i++){\n      j =min_L(i, n-1-i);\n      arr[j] = (arr[j] + t) % k;\n      t = (t * 10) % k;\n    }\n    sz = 0;\n    for(i=(0);i<(nn);i++){\n      if(arr[i] && (i < 3 || i > nn-4)){\n        arrInsert(sz, sz, val, arr[i], dig, i);\n      }\n    }\n    for(i=(0);i<(nn);i++){\n      res[i] = 9;\n    }\n    t = 0;\n    for(i=(0);i<(nn);i++){\n      if(arr[i] && !(i < 3 || i > nn-4)){\n        t = (t + res[i] * arr[i]) % k;\n      }\n    }\n    doit(0, t, k);\n    for(i=(0);i<(n);i++){\n      j =min_L(i, n-1-i);\n      ans += (char)('0' + res[j]);\n    }\n    return ans;\n  }\n}\n;\n// cLay version 20240810-1 [beta]\n\n// --- original code ---\n// #define main dummy_main\n// {}\n// #undef main\n// \n// int arr[1d6], val[1d6], dig[1d6], sz;\n// int res[1d6];\n// \n// int doit(int dep, int now, int k){\n//   int i, j;\n// \n//   if(dep==sz){\n//     if(now==0) return 1;\n//     return 0;\n//   }\n// \n//   rrep(i,1,10){\n//     res[dig[dep]] = i;\n//     if(doit(dep+1, (now+i*val[dep])%k, k)) return 1;\n//   }\n// \n//   return 0;\n// \n// }\n// \n// class Solution {\n// public:\n//   string largestPalindrome(int n, int k) {\n//     int i, j, t, nn;\n//     string ans;\n// \n//     nn = n /+ 2;\n//     rep(i,nn) arr[i] = 0;\n// \n//     t = 1;\n//     rep(i,n){\n//       j = min(i, n-1-i);\n//       arr[j] = (arr[j] + t) % k;\n//       t = (t * 10) % k;\n//     }\n// \n//     sz = 0;\n//     rep(i,nn) if(arr[i] && (i < 3 || i > nn-4)) arrInsert(sz, sz, val, arr[i], dig, i);\n// \n//     rep(i,nn) res[i] = 9;\n// \n//     t = 0;\n//     rep(i,nn) if(arr[i] && !(i < 3 || i > nn-4)) t = (t + res[i] * arr[i]) % k;\n// \n//     doit(0, t, k);\n// \n//     rep(i,n){\n//       j = min(i, n-1-i);\n//       ans += (char)('0' + res[j]);\n//     }\n// \n//     return ans;\n//   }\n// };\n",
    "submit_ts": "1723949626",
    "subm_id": "1359724594"
}