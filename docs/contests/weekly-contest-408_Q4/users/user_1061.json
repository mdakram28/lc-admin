{
    "username": "Ansh007Bhutada",
    "submission": "class Solution\n{\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>> &circles)\n    {\n        int sz = circles.size();\n        vector<pair<pair<int, int>, int>> temp(sz);\n        vector<vector<int>> graph(sz + 4);\n        for (int i = 0; i < sz; i++)\n        {\n            temp[i] = make_pair(make_pair(circles[i][0], circles[i][1]), circles[i][2]);\n        }\n        for (int i = 0; i < sz; i++)\n        {\n            if (temp[i].first.first - temp[i].second <= 0)\n            {\n                graph[i].push_back(sz);\n                graph[sz].push_back(i);\n            }\n            if (X - temp[i].first.first <= temp[i].second)\n            {\n                graph[i].push_back(sz + 2);\n                graph[sz + 2].push_back(i);\n            }\n            if (temp[i].first.second - temp[i].second <= 0)\n            {\n                graph[i].push_back(sz + 1);\n                graph[sz + 1].push_back(i);\n            }\n            if (Y - temp[i].first.second <= temp[i].second)\n            {\n                graph[i].push_back(sz + 3);\n                graph[sz + 3].push_back(i);\n            }\n            for (int j = i + 1; j < sz; j++)\n            {\n                long long dx = temp[i].first.first - temp[j].first.first;\n                long long dy = temp[i].first.second - temp[j].first.second;\n                long long distanceSquared = dx * dx + dy * dy;\n                long long radiusSum = temp[i].second + temp[j].second;\n                if (distanceSquared <= (long long)radiusSum * radiusSum)\n                {\n                    graph[i].push_back(j);\n                    graph[j].push_back(i);\n                }\n            }\n        }\n        auto bfs = [&](int start, int a, int b)\n        {\n            queue<int> q;\n            vector<int> visited(sz + 4, 0);\n            q.push(start);\n            visited[start] = 1;\n            while (!q.empty())\n            {\n                int f = q.front();\n                q.pop();\n                for (int neighbour : graph[f])\n                {\n                    if (!visited[neighbour])\n                    {\n                        visited[neighbour] = 1;\n                        q.push(neighbour);\n                    }\n                }\n            }\n            return visited[a] || visited[b];\n        };\n        return !(bfs(sz, sz + 1, sz + 2) || bfs(sz + 3, sz + 2, sz + 1));\n    }\n};\n",
    "submit_ts": "1722138400",
    "subm_id": "1335789803"
}