{
    "username": "mafailure",
    "submission": "const int inf = 1e8;\nclass SegTree {\n    #define left (p<<1)\n    #define right (left|1)\n    #define mid ((l+r)>>1)\n    #define toleft left,l,mid\n    #define toright right,mid+1,r \n    public: \n    int n; \n    vector<int> t; \n    vector<int> lazy; \n    SegTree(int n):n(n),t(4*n),lazy(4*n,0){;}\n    void build(int p,int l,int r){\n        if(l==r){\n            t[p] = l; \n            return; \n        }\n        build(toleft); build(toright);\n        t[p] = mer(t[left], t[right]); \n    }\n    \n    void update(int p,int l,int r,int i,int j,int val){\n        push(p,l,r); \n        if(l>j||r<i)return; \n        if(i<=l&&r<=j)return lazy[p]=val,push(p,l,r); \n        update(toleft,i,j,val); update(toright,i,j,val); \n        t[p]=mer(t[left], t[right]); \n    }\n    void push(int p,int l,int r){\n        if(lazy[p]==0)return; \n        t[p]+=lazy[p]; \n        if(l!=r)lazy[left]+=lazy[p], lazy[right]+=lazy[p]; \n        lazy[p] = 0; \n    }\n    int query(int p,int l,int r,int ind){\n        push(p,l,r);\n        if(ind>r||ind<l)return inf;\n        if(l==r)return t[p]; \n        return mer(query(toleft,ind), query(toright,ind)); \n    }\n    int mer(int a,int b){\n        return min(a,b); \n    }\n    \n};\nclass Solution {\npublic:\n    void update(vector<int> & ft,int ind, int val){\n        for(int i=ind;i<ft.size();i+=(i&(-i)))ft[i]+=val; \n    }\n    int query(vector<int> & ft,int ind, int ans = 0){\n        for(int i=ind;i;i-=(i&(-i)))ans+=ft[i]; \n        return ans; \n    }\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        SegTree seg(n); \n        seg.build(1,0,n-1);\n        vector<int> ans; \n        vector<int> l(n+1); \n        vector<int> r(n+1); \n        vector<set<int>>sett(n); \n        for(auto it:queries){\n            int u = it[0]; \n            int v= it[1]; \n            \n            int startBefore = query(l,u);  \n            int endBefore = query(r,u+1); \n            int exact = (sett[u].size()?((*sett[u].rbegin())>=v):0); \n            int cover = startBefore-endBefore+exact;  \n            if(cover){\n                ans.push_back((ans.size()?ans.back():n-1)); \n                sett[u].insert(v); \n                update(l,u+1,1); \n                update(r,v+1,1); \n                continue; \n            } \n            sett[u].insert(v); \n            update(l,u+1,1); \n            update(r,v+1,1); \n            //cout<<u<<\" \"<<v<<\" \"<<cover<<\" \"<<startBefore<<\" \"<<endBefore<<\" \"<<exact<<endl; \n            int f = seg.query(1,0,n-1,u); \n            int s = seg.query(1,0,n-1,v);\n            int should = v-u; \n            int actual = s-f; \n            int reduced = should-actual; \n            int diff = v-u-1-reduced; \n            seg.update(1,0,n-1,v,n-1,-diff);\n            ans.push_back(seg.query(1,0,n-1,n-1)); \n        }\n        return ans; \n    }\n};",
    "submit_ts": "1722741498",
    "subm_id": "1343746491"
}