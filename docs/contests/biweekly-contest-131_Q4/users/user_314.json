{
    "username": "nicholasfoocl",
    "submission": "\ntypedef long long ll;\n\nstruct SegmentTree {\n    vector<ll> treeSum, treeMax, lazy;\n    ll n, root, size;\n    SegmentTree(int currSize) : n(currSize), root(1) {\n        ll x = (ll)(ceil(log2(currSize)));\n        size = 2*(ll)pow(2, x);\n        treeSum.resize(size, 0);\n        treeMax.resize(size, 0);\n        lazy.resize(size, 0);\n    }\n    SegmentTree(const vector<ll> &arr) : n(arr.size()), root(1) {\n        ll x = (ll)(ceil(log2(n)));\n        size = 2*(ll)pow(2, x);\n        treeSum.resize(size);\n        treeMax.resize(size);\n        lazy.resize(size, 0);\n        build(arr, root, 0, n-1);\n    }\n    void build(const vector<ll> &arr, int node, int start, int end) {\n        if(start == end) treeMax[node] = treeSum[node] = arr[start];\n        else {\n            ll mid = (start+end)/2;\n            build(arr, 2*node, start, mid);\n            build(arr, 2*node+1, mid+1, end);\n            treeSum[node] = treeSum[2*node] + treeSum[2*node+1];\n            treeMax[node] = max(treeMax[2*node], treeMax[2*node+1]);\n        }\n    }\n    void pendingUpdate(int node, int start, int end) {\n        if(lazy[node]) {\n            treeSum[node] += (end-start+1) * lazy[node];\n            treeMax[node] += lazy[node];\n            if(start != end) {\n                lazy[2*node] += lazy[node];\n                lazy[2*node+1] += lazy[node];\n            }\n            lazy[node] = 0;\n        }\n    }\n    void updateRange(int l, int r, ll diff) {updateRange(root, 0, n-1, l, r, diff);}\n    void updateRange(int node, int start, int end, int l, int r, ll diff) {\n        pendingUpdate(node, start, end);\n        if(start > end || start > r || end < l) return;\n        if(start >= l && end <= r) {\n            treeSum[node] += (end-start+1) * diff;\n            treeMax[node] += diff;\n            if(start != end) {\n                lazy[2*node] += diff;\n                lazy[2*node+1] += diff;\n            }\n            return;\n        }\n        ll mid = (start + end) / 2;\n        updateRange(2*node, start, mid, l, r, diff);\n        updateRange(2*node+1, mid+1, end, l, r, diff);\n        treeSum[node] = treeSum[2*node] + treeSum[2*node+1];\n        treeMax[node] = max(treeMax[2*node], treeMax[2*node+1]);\n    }\n    ll querySum(int l, int r) {return querySum(root, 0, n-1, l, r);}\n    ll querySum(int node, int start, int end, int l, int r) {\n        if(r < start || end < l) return 0;\n        pendingUpdate(node, start, end);\n        if(l <= start && end <= r) return treeSum[node];\n        ll mid = (start+end)/2;\n        return querySum(2*node, start, mid, l, r) + querySum(2*node+1, mid+1, end, l, r);\n    }\n    ll queryMax(int l, int r) {return queryMax(root, 0, n-1, l, r);}\n    ll queryMax(int node, int start, int end, int l, int r) {\n        if(r < start || end < l) return -1e18;\n        pendingUpdate(node, start, end);\n        if(l <= start && end <= r) return treeMax[node];\n        ll mid = (start+end)/2;\n        return max(queryMax(2*node, start, mid, l, r), queryMax(2*node+1, mid+1, end, l, r));\n    }\n};\n\nclass Solution {\npublic:\n\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector<int> blocks{0};\n        map<int,int> m;\n        for(auto&q:queries){\n            if(q[0]==1){\n                blocks.push_back(q[1]);\n            }\n        }\n        ranges::sort(blocks);\n        // cout << \"BLOCKS: \";\n        // for(auto&x:blocks) cout << x << ' '; cout << endl;\n        for(int i=0; i<blocks.size(); i++){\n            m[blocks[i]] = i;\n        }\n        m[INT_MAX] = blocks.size();\n        // cout << \"M: \";\n        // for(auto&[k,v]:m) cout << k<<',' << v << ' '; cout << endl;\n        vector<int> gaps{0};\n        for(int i=1; i<blocks.size(); i++){\n            gaps.push_back(blocks[i]-blocks[i-1]);\n        }\n        gaps.push_back(1e9);\n        // cout << \"GAPS: \";\n        // for(auto&x:gaps) cout << x << ' '; cout << endl;\n        SegmentTree st(gaps.size());\n        for(int i=0; i<gaps.size(); i++){\n            st.updateRange(i,i,gaps[i]);\n        }\n        reverse(queries.begin(), queries.end());\n        vector<bool> ans;\n        for(auto&q:queries){\n            if(q[0]==2){\n                // cout << \"Q2: \" << q[1] << endl;\n                auto it = m.upper_bound(q[1]);\n                \n                auto it2 = prev(it);\n                // cout << \"RANGEMAX: \" << it->second-1 << ' ' << st.queryMax(0,it->second-1) << endl;\n                // cout << \"AfterPREV: \" << q[1] << ' ' << it2->first << endl;\n                ans.push_back(st.queryMax(0,it->second-1) >= q[2] || q[1]-it2->first >= q[2]);\n            } else {\n                int pos = m[q[1]];\n                m.erase(q[1]);\n                int val = gaps[pos];\n                auto it = m.upper_bound(q[1]);\n                int nextPos = it->second;\n                gaps[nextPos] += val;\n                gaps[pos] = 0;\n                // cout << pos << \" drop by \" << val << '\\n';\n                // cout << nextPos << \" inc by \" << val << endl;\n                // cout << q[1] << ' ' << pos << ' ' << val << endl;\n                st.updateRange(pos,pos,-val);\n                st.updateRange(nextPos,nextPos,+val);\n            }\n        }\n        // cout << st.queryMax(0,4) << endl;\n        reverse(ans.begin(), ans.end());\n        return ans;\n        \n    }\n};",
    "submit_ts": 1716652020.0
}