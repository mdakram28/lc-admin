{
    "username": "cwallisch",
    "submission": "class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        \n        #print(\"New\")\n        \n        toVec = lambda num : [*map(int, bin(num)[2:].zfill(32))]\n        \n        def update(curIdx, oldMem):\n            vec = toVec(nums[curIdx])\n            result = []\n            for startIdx, isOne in zip(oldMem, vec):\n                if not isOne:\n                    result.append(-1)\n                else:\n                    if startIdx == -1:\n                        result.append(curIdx)\n                    else:\n                        result.append(startIdx)\n            return result\n        \n        INDICES = [idx for idx, val in enumerate(toVec(k)) if val == 1]\n        count = 0\n        \n        mem = 32 * [-1]\n        for curIdx in range(len(nums)):\n            mem = update(curIdx, mem)\n            #print(mem)\n            \n            if all(mem[idx] != -1 for idx in INDICES):\n                lowestIdxInside = max((mem[idx] for idx in INDICES), default=0)\n                lowestIdxOutside = min((mem[idx] for idx in range(32) if idx not in INDICES and mem[idx] != -1), default=curIdx+1)\n                #print(lowestIdxInside, lowestIdxOutside)\n                #print(lowestIdxInside, lowestIdxOutside)\n                #print(curIdx)\n                #print(mem)\n                if lowestIdxInside < lowestIdxOutside:\n                    count += lowestIdxOutside - lowestIdxInside\n  \n        return count\n            ",
    "submit_ts": "1720281563",
    "subm_id": "1311829939"
}