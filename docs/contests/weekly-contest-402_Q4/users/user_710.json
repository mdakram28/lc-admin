{
    "username": "billy_tngo",
    "submission": "class Solution {\nprivate:\n    int P[100000];\n    int T[100000];\n    \n    void updateTree(int start,int end,int index,int v){\n        if(start == end){\n            P[start] += v;\n            return;\n        }\n        \n        int mid = (start+end)/2;\n        T[mid] += v;\n        \n        if(index <= mid){\n            updateTree(start,mid,index,v);\n            return; \n        }\n        \n        updateTree(mid+1,end,index,v);\n    }\n    \n    int query(int start,int end,int _start,int _end){\n        if(start == _start && end == _end){\n            return (start == end) ? P[start] : T[(start+end)/2];\n        }\n        \n        int mid = (start+end)/2;\n        \n        if(_end <= mid){\n            return query(start,mid,_start,_end);\n        }\n        \n        if(_start > mid){\n            return query(mid+1,end,_start,_end);\n        }\n        \n        return query(start,mid,_start,mid) + query(mid+1,end,mid+1,_end);\n    }\n    \npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = (int)nums.size();\n        fill(P,P+n,0);\n        fill(T,T+n,0);\n        for(int i=1;i<n-1;i++){\n            if(nums[i] > nums[i-1] && nums[i] > nums[i+1]){\n                updateTree(0,n-1,i,1);\n            }\n        }\n        \n        vector<int> ret;\n        \n        for(int i=0;i<(int)queries.size();i++){\n            if(queries[i][0] == 1){\n                int l = queries[i][1]+1;\n                int r = queries[i][2]-1;\n                if(l <= r){\n                    ret.push_back(query(0,n-1,l,r));\n                } else {\n                    ret.push_back(0);\n                }\n            } else {\n                int index = queries[i][1];\n                int v = queries[i][2];\n                nums[index] = v;\n                \n                if(index-2 >= 0){\n                    if(nums[index-1] > nums[index-2] && nums[index-1] > nums[index]){\n                        if(P[index-1] == 0){\n                            updateTree(0,n-1,index-1,1);\n                        }\n                    } else {\n                        if(P[index-1] == 1){\n                            updateTree(0,n-1,index-1,-1);\n                        }\n                    }\n                }\n                \n                if(index+2 < n){\n                    if(nums[index+1] > nums[index] && nums[index+1] > nums[index+2]){\n                        if(P[index+1] == 0){\n                            updateTree(0,n-1,index+1,1);\n                        }\n                    } else {\n                        if(P[index+1] == 1){\n                            updateTree(0,n-1,index+1,-1);\n                        }\n                    }\n                }\n                \n                if(index-1 >= 0 && index+1 < n){\n                    if(nums[index] > nums[index-1] && nums[index] > nums[index+1]){\n                        if(P[index] == 0){\n                            updateTree(0,n-1,index,1);\n                        }\n                    } else {\n                        if(P[index] == 1){\n                            updateTree(0,n-1,index,-1);\n                        }\n                    }\n                }\n            }\n        }\n        \n        return ret;\n    }\n};",
    "submit_ts": 1718508299.0
}