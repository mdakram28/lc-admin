{
    "username": "jwpassion1",
    "submission": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<string>\n#include<deque>\n#include<set>\n#include<map>\n#include<ctime>\n#include<cmath>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> graph1, graph2;\n    int d1 = 1000000, d2 = 1000000, dia = 0;\n    \n    vector<int> dep1, dep2, ret1, ret2;\n    vector<pair<int, int>> dow1, dow2;\n    \n    \n    int dfs1(int node, int last){\n        ret1[node] = 0;\n        for (int i : graph1[node]){\n            if (i == last) continue;\n            dep1[i] = dep1[node] + 1;\n            int tmp = dfs1(i, node);\n            if (dow1[node].second < tmp){\n                dow1[node].second = tmp;\n                if (dow1[node].first < tmp) swap(dow1[node].first, dow1[node].second);\n            }\n            ret1[node] = max(ret1[node], tmp);\n        }\n        return ret1[node] + 1;\n    }\n    int dfs2(int node, int last){\n        ret2[node] = 0;\n        for (int i : graph2[node]){\n            if (i == last) continue;\n            dep2[i] = dep2[node] + 1;\n            int tmp = dfs2(i, node);\n            if (dow2[node].second < tmp){\n                dow2[node].second = tmp;\n                if (dow2[node].first < tmp) swap(dow2[node].first, dow2[node].second);\n            }\n            ret2[node] = max(ret2[node], tmp);\n        }\n        return ret2[node] + 1;\n    }\n    \n    void find1(int node, int last, int f){\n        d1 = min(d1, max(f, dow1[node].first));\n        vector<int> tt;\n        tt.push_back(f);\n        tt.push_back(dow1[node].first);\n        tt.push_back(dow1[node].second);\n        sort(tt.begin(), tt.end());\n        dia = max(dia, tt[1] + tt[2]);\n        for (int i : graph1[node]){\n            if (i == last) continue;\n            int tmp = dow1[node].first;\n            if (tmp == dow1[i].first + 1) tmp = dow1[node].second;\n            find1(i, node, max(f + 1, tmp + 1));\n        }\n    }\n    void find2(int node, int last, int f){\n        d2 = min(d2, max(f, dow2[node].first));\n        vector<int> tt;\n        tt.push_back(f);\n        tt.push_back(dow2[node].first);\n        tt.push_back(dow2[node].second);\n        sort(tt.begin(), tt.end());\n        dia = max(dia, tt[1] + tt[2]);\n        for (int i : graph2[node]){\n            if (i == last) continue;\n            int tmp = dow2[node].first;\n            if (tmp == dow2[i].first + 1) tmp = dow2[node].second;\n            find2(i, node, max(f + 1, tmp + 1));\n        }\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = (int)edges1.size() + 1, m = (int)edges2.size() + 1;\n        graph1.resize(n);\n        graph2.resize(m);\n        dep1.resize(n);\n        dep2.resize(m);\n        dow1.resize(n);\n        dow2.resize(m);\n        ret1.resize(n);\n        ret2.resize(m);\n        \n        for (vector<int> i : edges1){\n            graph1[i[0]].push_back(i[1]);\n            graph1[i[1]].push_back(i[0]);\n        }\n        for (vector<int> i : edges2){\n            graph2[i[0]].push_back(i[1]);\n            graph2[i[1]].push_back(i[0]);\n        }\n        \n        dfs1(0, -1);\n        dfs2(0, -1);\n        find1(0, -1, 0);\n        find2(0, -1, 0);\n        \n\n        cout << d1 << ' ' << d2 << '\\n';\n        \n        return max(d1 + d2 + 1, dia);\n    }\n};",
    "submit_ts": "1719717933",
    "subm_id": "1304404467"
}