{
    "username": "aminjonshermatov",
    "submission": "template <typename Node>\nstruct BottomUpSegmentTree {\n  std::size_t n{};\n  std::vector<Node> nodes;\n\n  BottomUpSegmentTree() = default;\n\n  explicit BottomUpSegmentTree(std::size_t n_) { init(std::vector(n_, Node())); }\n\n  BottomUpSegmentTree(std::size_t n_, Node&& node) {\n    init(std::vector(n_, std::forward<Node>(node)));\n  }\n\n  template <typename T>\n  explicit BottomUpSegmentTree(const std::vector<T>& init_) { init(init_); }\n\n  template <typename T>\n  void init(const std::vector<T>& init_) {\n    n = 1u << std::__lg(2 * init_.size() - 1);\n    nodes.assign(2 * n, Node());\n    for (std::size_t i{}; i < init_.size(); ++i) {\n      nodes[i + n] = Node{init_[i]};\n    }\n    for (std::size_t i = n - 1; i >= 1u; --i) {\n      nodes[i] = Node::unite(std::forward<Node>(nodes[i << 1]),\n                             std::forward<Node>(nodes[i << 1 | 1]));\n    }\n  }\n  void reset() {\n    std::ranges::fill(nodes, Node());\n  }\n\n  void modify(std::size_t pos, Node&& val) {\n    nodes[pos += n] = val;\n    for (pos >>= 1; pos >= 1; pos >>= 1) {\n      nodes[pos] = Node::unite(std::forward<Node>(nodes[pos << 1]),\n                               std::forward<Node>(nodes[pos << 1 | 1]));\n    }\n  }\n\n  Node query(std::size_t l, std::size_t r) {\n    auto retL = Node(), retR = Node();\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if (l % 2 == 1u) {\n        retL = Node::unite(retL, nodes[l++]);\n      }\n      if (r % 2 == 1u) {\n        retR = Node::unite(nodes[--r], retR);\n      }\n    }\n    return Node::unite(std::forward<Node>(retL), std::forward<Node>(retR));\n  }\n\n  Node query(std::size_t pos) {\n    return query(pos, pos + 1);\n  }\n};\n\nstruct Node {\n  int val = 0;\n  static Node unite(const Node& a, const Node& b) {\n    return {std::max(a.val, b.val)};\n  }\n};\nBottomUpSegmentTree<Node> st(1e6);\nclass Solution {\npublic:\n  vector<bool> getResults(vector<vector<int>>& qs) {\n    st.reset();\n    map<int, int> xs;\n    xs[0] = 1e6;\n    st.modify(0, {int(1e6)});\n    int q = int(qs.size());\n    vector<bool> ret;\n    for (int i = 0; i < q; ++i) {\n      if (qs[i][0] == 1) {\n        auto it = xs.upper_bound(qs[i][1]);\n        assert(it != xs.begin());\n        it = prev(it);\n        auto dist = qs[i][1] - it->first;\n        if (it->second > dist) {\n          st.modify(it->first, {dist});\n          auto old = exchange(it->second, dist);\n          it->second = dist;\n          if (!xs.contains(qs[i][1])) {\n            st.modify(qs[i][1], {old - dist});\n            xs[qs[i][1]] = old - dist;\n          }\n        }\n      } else {\n        ret.emplace_back(st.query(0, std::max(0, qs[i][1] - qs[i][2] + 1)).val >= qs[i][2]);\n      }\n    }\n    return ret;\n  }\n};",
    "submit_ts": 1716648790.0
}