{
    "username": "Yao_Yin",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int d1 = findDiameter(edges1);\n        int d2 = findDiameter(edges2);\n        return max(max(d1, d2), (d1 + 1)/2 + (d2 + 1) / 2 + 1);\n    }\n    \n    int findDiameter(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vector<vector<int>> g(n);\n        for (auto & e: edges) {\n            // cout << e[0] << \" \" << e[1] << \" \" << n << endl;\n            g[e[0]].push_back(e[1]);\n            g[e[1]].push_back(e[0]);\n        }\n        \n        \n        // return 1;\n        auto [dist, x] = bfs(g, 0);\n        cout << dist << \" \" << x << endl;\n        return bfs(g, x).first;\n    }\n    \n    pair<int, int> bfs(vector<vector<int>> & g, int x) {\n        int n = g.size();\n        vector<bool> vis(n, 0);\n        vector<int> dist(n, n);\n        dist[x] = 0;\n        queue<int> q;\n        q.push(x);\n        vis[x] = true;\n        while (!q.empty()) {\n            auto y = q.front();\n            q.pop();\n            for (auto nxt: g[y]) {\n                if (!vis[nxt]) {\n                    dist[nxt] = min(dist[nxt], dist[y] + 1);\n                    vis[nxt] = true;\n                    q.push(nxt);\n                }\n            }\n        }\n        \n        int k = max_element(dist.begin(), dist.end()) - dist.begin();\n        return {dist[k], k};\n    }\n};",
    "submit_ts": 1719718172.0
}