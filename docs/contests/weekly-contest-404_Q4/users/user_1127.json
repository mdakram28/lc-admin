{
    "username": "Phoenix-101",
    "submission": "class Solution {\npublic:\n \n// Sets maxCount as maximum distance from node.\nvoid dfsUtil(int node, vector<int> &dist,vector<int> adj[])\n{\n    for (auto i:adj[node]) {\n        if (dist[i]==-1) {\n            dist[i]=dist[node]+1;\n            dfsUtil(i,dist,adj);\n        }\n    }\n}\n \n// The function to do DFS traversal. It uses recursive\n// dfsUtil()\npair<int,int> dfs(int node, int n, vector<int> adj[], int& maxCount)\n{\n    vector<int>dist(n,-1);\n    dist[node]=0;\n    // Mark all the vertices as not visite\n \n    // Increment count by 1 for visited node\n    dfsUtil(node,dist,adj);\n    int idx=0;\n    for(int i=0;i<n;i++){\n        if(dist[idx]<dist[i]) idx=i;\n    }\n    return {idx,dist[idx]};\n}\n \n// Returns diameter of binary tree represented\n// as adjacency list.\nint diameter(vector<int> adj[], int n)\n{\n    int maxCount = INT_MIN;\n \n    /* DFS from a random node and then see\n    farthest node X from it*/\n    int x=dfs(0, n, adj, maxCount).first;\n \n    /* DFS from X and check the farthest node\n    from it */\n    return dfs(x, n, adj, maxCount).second;\n \n}\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n=edges1.size()+1,m=edges2.size()+1,ans=0;\n        vector<int> adj1[n+1],adj2[m+1];\n        for(auto edge:edges1){\n            adj1[edge[0]].push_back(edge[1]);\n            adj1[edge[1]].push_back(edge[0]);\n        }\n        for(auto edge:edges2){\n            adj2[edge[0]].push_back(edge[1]);\n            adj2[edge[1]].push_back(edge[0]);\n        }\n        int dia1=diameter(adj1,n);\n        int dia2=diameter(adj2,m);\n        \n\n        return max((dia1+1)/2+(dia2+1)/2+1,max(dia1,dia2));\n    }\n};",
    "submit_ts": "1719719197",
    "subm_id": "1304436072"
}