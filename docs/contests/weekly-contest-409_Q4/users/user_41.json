{
    "username": "wjli",
    "submission": "\n\n// COPY ALL MACROS BELOW\n\ntypedef long long LL;\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define LB lower_bound\n#define UB upper_bound\n#define SZ(x) ((int)x.size())\n#define LEN(x) ((int)x.length())\n#define ALL(x) begin(x), end(x)\n#define RSZ resize\n#define ASS assign\n#define REV(x) reverse(x.begin(), x.end());\n#define trav(a, x) for (auto& a : x)\ntypedef pair<LL, LL> PL;\ntypedef vector<LL> VL;\ntypedef vector<PL> VPL;\ntypedef vector<VL> VVL;\ntypedef vector<VVL> VVVL;\ntypedef vector<VVVL> VVVVL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PI;\ntypedef vector<int> VI;\ntypedef vector<PI> VPI;\ntypedef vector<vector<int>> VVI;\ntypedef vector<vector<PI>> VVPI;\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\n#define FOR(i, n) for (int i = 0; i < n; i++) \n#define FOR1(i, n) for (int i = 1; i <= n; i++) \n#define SORT(x) sort(x.begin(), x.end())\n#define RSORT(x) sort(x.rbegin(), x.rend())\n#define SUM(x) accumulate(x.begin(), x.end(), 0LL)\n\ntemplate <typename T>\nclass fenwick_tree {\npublic:\n\tvector<T> fenw;\n\tint n;\n\n\tfenwick_tree(int _n) : n(_n) {\n\t\tfenw.resize(n);\n\t}\n\n\tfenwick_tree() {\n\n\t}\n\n\tvoid initialize(int _n) {\n\t\tfenw.assign(_n, 0);\n\t\tn = _n;\n\t}\n\n\tvoid update(int x, T v) {\n\t\twhile (x < n) {\n\t\t\tfenw[x] += v;\n\t\t\tx |= (x + 1);\n\t\t\t//x += (x & (-x));\n\t\t}\n\t}\n\n\tT query(int x) {\n\t\tT v{};\n\t\twhile (x >= 0) {\n\t\t\tv += fenw[x];\n\t\t\tx = (x & (x + 1)) - 1;\n\t\t}\n\t\treturn v;\n\t}\n\n\tT query_full(int a, int b) {\t\t// range query\n\t\tif ((a == 0) || (b == 0) || (a > b)) return 0;\n\t\treturn query(b) - ((a <= 1) ? 0 : query(a - 1));\n\t}\n};\n\nclass Solution {\npublic:\n\tvector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {\n\t\tint n = colors.size(), i, j, k, m = queries.size(), ct = 0, len;\n\t\tVI next(n), prev(n);\n\t\tFOR(i, n) {\n\t\t\tnext[i] = (i + 1) % n;\n\t\t\tprev[i] = (i + n - 1) % n;\n\t\t}\n\t\tset<PI> s;\n\n\t\tfenwick_tree<int> ft(n + 10), ftct(n + 10);\n\t\tFOR(i, n) {\n\t\t\tif (colors[i] == colors[next[i]]) {\n\t\t\t\ts.insert({ i, i });\n\t\t\t\tft.update(1, 1); \n\t\t\t\tftct.update(1, 1); \n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (j = i; (j < n) && (colors[j] != colors[next[j]]); j++);\n\t\t\t\tif (j == n) j = n - 1;\n\t\t\t\ts.insert({ i, j });\n\t\t\t\tlen = j - i + 1;\n\n\t\t\t\tft.update(len, len);\n\t\t\t\tftct.update(len, 1);\n\t\t\t\ti = j;\n\t\t\t}\n\t\t}\n\n\t\tVI ans;\n\t\tFOR(mm, m) {\n\t\t\tint id = queries[mm][0];\n\t\t\tif (id == 1) {\n\t\t\t\tint sz = queries[mm][1], a = -1, b = -1, ab = -1;\n\n\t\t\t\tif ((s.size() > 1) && (s.begin()->first == 0) && (s.rbegin()->second == n - 1) && (colors[0] != colors[n - 1])) {\n\t\t\t\t\ta = s.begin()->second - s.begin()->first + 1;\n\t\t\t\t\tb = s.rbegin()->second - s.rbegin()->first + 1;\n\t\t\t\t\tab = a + b;\n\n\t\t\t\t\tft.update(a, -a);\n\t\t\t\t\tft.update(b, -b);\n\t\t\t\t\tft.update(ab, ab);\n\n\t\t\t\t\tftct.update(a, -1);\n\t\t\t\t\tftct.update(b, -1);\n\t\t\t\t\tftct.update(ab, 1);\n\t\t\t\t}\n\n\t\t\t\tint ss = ft.query_full(sz, n), ct = ftct.query_full(sz, n);\n\t\t\t\tint anss = ss - (sz - 1) * ct;\n\n\t\t\t\tif ((s.size() == 1) && (s.begin()->first == 0) && (s.begin()->second == n - 1) && (colors[0] != colors[n - 1])) anss = n;\n\n\t\t\t\tans.push_back(anss);\n\n\t\t\t\tif (ab != -1) {\n\t\t\t\t\tft.update(a, a);\n\t\t\t\t\tft.update(b, b);\n\t\t\t\t\tft.update(ab, -ab);\n\n\t\t\t\t\tftct.update(a, 1);\n\t\t\t\t\tftct.update(b, 1);\n\t\t\t\t\tftct.update(ab, -1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// change color\n\t\t\t\tint pos = queries[mm][1], cc = queries[mm][2];\n\t\t\t\tif (cc == colors[pos]) continue;\n\t\t\t\tcolors[pos] = cc;\n\n\t\t\t\tset<PI>::iterator it = s.upper_bound({ pos + 1, -1 });\n\t\t\t\tit--;\n\n\t\t\t\tint l, r, len;\n\t\t\t\ttie(l, r) = *it;\n\t\t\t\ts.erase(*it);\n\n\t\t\t\tlen = r - l + 1;\n\t\t\t\tft.update(len, -len);\n\t\t\t\tftct.update(len, -1);\n\n\t\t\t\tif (l != pos) {\n\t\t\t\t\ts.insert({ l, pos - 1 });\n\t\t\t\t\tlen = (pos - 1) - l + 1;\n\t\t\t\t\tft.update(len, len);\n\t\t\t\t\tftct.update(len, 1);\n\t\t\t\t}\n\n\t\t\t\ts.insert({ pos, pos });\n\t\t\t\tlen = 1;\n\t\t\t\tft.update(len, len);\n\t\t\t\tftct.update(len, 1);\n\n\t\t\t\tif (r != pos) {\n\t\t\t\t\ts.insert({ pos + 1, r });\n\t\t\t\t\tlen = r - (pos + 1) + 1;\n\t\t\t\t\tft.update(len, len);\n\t\t\t\t\tftct.update(len, 1);\n\t\t\t\t}\n\n\t\t\t\tint ll = pos, rr = pos;\n\t\t\t\tif ((pos > 0) && (colors[pos] != colors[pos - 1])) {\n\t\t\t\t\tit = s.find({ pos, pos });\n\t\t\t\t\tit--;\n\n\t\t\t\t\ttie(l, r) = *it;\n\t\t\t\t\ts.erase(*it);\n\t\t\t\t\tlen = r - l + 1;\n\t\t\t\t\tft.update(len, -len);\n\t\t\t\t\tftct.update(len, -1);\n\n\t\t\t\t\tll = l;\n\t\t\t\t}\n\n\t\t\t\tif ((pos < n - 1) && (colors[pos] != colors[pos + 1])) {\n\t\t\t\t\tit = s.find({ pos, pos });\n\t\t\t\t\tit++;\n\n\t\t\t\t\ttie(l, r) = *it;\n\t\t\t\t\ts.erase(*it);\n\t\t\t\t\tlen = r - l + 1;\n\t\t\t\t\tft.update(len, -len);\n\t\t\t\t\tftct.update(len, -1);\n\n\t\t\t\t\trr = r; \n\t\t\t\t}\n\n\t\t\t\tif ((ll != pos) || (rr != pos)) {\n\t\t\t\t\ts.erase({ pos, pos });\n\t\t\t\t\tlen = 1;\n\t\t\t\t\tft.update(len, -len);\n\t\t\t\t\tftct.update(len, -1);\n\n\t\t\t\t\ts.insert({ ll, rr });\n\t\t\t\t\tlen = rr - ll + 1;\n\t\t\t\t\tft.update(len, len);\n\t\t\t\t\tftct.update(len, 1);\n\t\t\t\t}\n\n\t\t\t\tk = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n};\n",
    "submit_ts": "1722741800",
    "subm_id": "1343753807"
}