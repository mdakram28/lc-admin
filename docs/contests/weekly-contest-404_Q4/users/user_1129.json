{
    "username": "pratik_rockstar",
    "submission": "#define maxN 100001\n \n// Adjacency List to store the graph\nvector<int> adj[maxN];\n \n// Stores the height of each node\nint height[maxN];\n \n// Stores the maximum distance of a\n// node from its ancestors\nint dist[maxN];\n \n// Function to add edge between\n// two vertices\nvoid addEdge(int u, int v)\n{\n    // Insert edge from u to v\n    adj[u].push_back(v);\n \n    // Insert edge from v to u\n    adj[v].push_back(u);\n}\n \n// Function to calculate height of\n// each Node\nvoid dfs1(int cur, int par)\n{\n    // Iterate in the adjacency\n    // list of the current node\n    for (auto u : adj[cur]) {\n \n        if (u != par) {\n \n            // Dfs for child node\n            dfs1(u, cur);\n \n            // Calculate height of nodes\n            height[cur]\n                = max(height[cur], height[u]);\n        }\n    }\n \n    // Increase height\n    height[cur] += 1;\n}\n \n// Function to calculate the maximum\n// distance of a node from its ancestor\nvoid dfs2(int cur, int par)\n{\n    int max1 = 0;\n    int max2 = 0;\n \n    // Iterate in the adjacency\n    // list of the current node\n    for (auto u : adj[cur]) {\n \n        if (u != par) {\n \n            // Find two children\n            // with maximum heights\n            if (height[u] >= max1) {\n                max2 = max1;\n                max1 = height[u];\n            }\n            else if (height[u] > max2) {\n                max2 = height[u];\n            }\n        }\n    }\n \n    int sum = 0;\n \n    for (auto u : adj[cur]) {\n        if (u != par) {\n \n            // Calculate the maximum distance\n            // with ancestor for every node\n            sum = ((max1 == height[u]) ? max2 : max1);\n \n            if (max1 == height[u])\n                dist[u]\n                    = 1 + max(1 + max2, dist[cur]);\n            else\n                dist[u]\n                    = 1 + max(1 + max1, dist[cur]);\n \n            // Calculating for children\n            dfs2(u, cur);\n        }\n    }\n}\n\nclass Solution {\npublic:\n    \n    \n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        \n\n\n        int n=size(edges1)+1;\n        int m=size(edges2)+1;\n        int maxh=-1;\n        \n        for (int i=0; i<=n; i++){\n            adj[i].clear();\n            height[i]=0;\n            dist[i]=0;\n        }\n        \n        for (auto i:edges1){\n            addEdge(i[0], i[1]);\n        }\n        // Calculate height of\n        // nodes of the tree\n        dfs1(0, 0);\n\n        // Calculate the maximum\n        // distance with ancestors\n        dfs2(0, 0);\n        int h1=INT_MAX, h2=INT_MAX;\n        // Print the maximum of the two\n        // distances from each node\n        for (int i = 0; i <n; i++){\n            h1=min(h1, (max(dist[i], height[i]) - 1));\n            maxh=max(maxh,(max(dist[i], height[i]) - 1) );\n        }\n    \n        for (int i=0; i<=m; i++){\n            adj[i].clear();\n            height[i]=0;\n            dist[i]=0;\n        }\n    \n       \n        for (auto i:edges2){\n            addEdge(i[0], i[1]);\n        }\n        // Calculate height of\n        // nodes of the tree\n        dfs1(0, 0);\n\n        // Calculate the maximum\n        // distance with ancestors\n        dfs2(0, 0);\n        for (int i = 0; i <m; i++){\n            h2=min(h2, (max(dist[i], height[i]) - 1));\n             maxh=max(maxh,(max(dist[i], height[i]) - 1) );\n\n        }\n        int ans=max({maxh, h1+h2+1});\n        return ans;}\n};",
    "submit_ts": 1719719886.0
}