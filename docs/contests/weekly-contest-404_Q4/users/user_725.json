{
    "username": "LQnVRuiNVr",
    "submission": "from collections import deque\nfrom typing import List, Tuple\n\nclass Solution:\n    def treeDiameter(self, edges: List[List[int]]) -> int:\n        num_nodes = len(edges) + 1\n        adj_list = [[] for _ in range(num_nodes)]\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n        \n        def bfs(start_node: int) -> Tuple[int, int]:\n            distances = [-1] * num_nodes\n            queue = deque([start_node])\n            distances[start_node] = 0\n            farthest_node = start_node\n            while queue:\n                current_node = queue.popleft()\n                for neighbor in adj_list[current_node]:\n                    if distances[neighbor] == -1:\n                        distances[neighbor] = distances[current_node] + 1\n                        queue.append(neighbor)\n                        if distances[neighbor] > distances[farthest_node]:\n                            farthest_node = neighbor\n            return farthest_node, distances[farthest_node]\n        \n        first_bfs_result = bfs(0)\n        second_bfs_result = bfs(first_bfs_result[0])\n        return second_bfs_result[1]\n\n    def findTreeCenters(self, edges: List[List[int]]) -> List[int]:\n        num_nodes = len(edges) + 1\n        adj_list = [[] for _ in range(num_nodes)]\n        degrees = [0] * num_nodes\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n            degrees[u] += 1\n            degrees[v] += 1\n        \n        leaves = deque()\n        for node in range(num_nodes):\n            if degrees[node] == 1:\n                leaves.append(node)\n        \n        remaining_nodes = num_nodes\n        while remaining_nodes > 2:\n            leaves_count = len(leaves)\n            remaining_nodes -= leaves_count\n            for _ in range(leaves_count):\n                leaf = leaves.popleft()\n                for neighbor in adj_list[leaf]:\n                    degrees[neighbor] -= 1\n                    if degrees[neighbor] == 1:\n                        leaves.append(neighbor)\n        \n        centers = list(leaves)\n        return centers\n\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        if not edges1 and not edges2:\n            return 1\n        if not edges1 or not edges2:\n            return 2\n        \n        diameter1 = self.treeDiameter(edges1)\n        diameter2 = self.treeDiameter(edges2)\n        \n        centers1 = self.findTreeCenters(edges1)\n        centers2 = self.findTreeCenters(edges2)\n        \"\"\"\n        \n            def findTreeCenters(self, edges: List[List[int]]) -> List[int]:\n        num_nodes = len(edges) + 1\n        adj_list = [[] for _ in range(num_nodes)]\n        degrees = [0] * num_nodes\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n            degrees[u] += 1\n            degrees[v] += 1\n        \n        leaves = deque()\n        for node in range(num_nodes):\n            if degrees[node] == 1:\n                leaves.append(node)\n        \n        remaining_nodes = num_nodes\n        while remaining_nodes > 2:\n            leaves_count = len(leaves)\n            remaining_nodes -= leaves_count\n            for _ in range(leaves_count):\n                leaf = leaves.popleft()\n                for neighbor in adj_list[leaf]:\n                    degrees[neighbor] -= 1\n                    if degrees[neighbor] == 1:\n                        leaves.append(neighbor)\n        \n        centers = list(leaves)\n        return centers\n        \n        \n        \n            def findTreeCenters(self, edges: List[List[int]]) -> List[int]:\n        num_nodes = len(edges) + 1\n        adj_list = [[] for _ in range(num_nodes)]\n        degrees = [0] * num_nodes\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n            degrees[u] += 1\n            degrees[v] += 1\n        \n        leaves = deque()\n        for node in range(num_nodes):\n            if degrees[node] == 1:\n                leaves.append(node)\n        \n        remaining_nodes = num_nodes\n        while remaining_nodes > 2:\n            leaves_count = len(leaves)\n            remaining_nodes -= leaves_count\n            for _ in range(leaves_count):\n                leaf = leaves.popleft()\n                for neighbor in adj_list[leaf]:\n                    degrees[neighbor] -= 1\n                    if degrees[neighbor] == 1:\n                        leaves.append(neighbor)\n        \n        centers = list(leaves)\n        return centers\n        \n        \n        \n            def findTreeCenters(self, edges: List[List[int]]) -> List[int]:\n        num_nodes = len(edges) + 1\n        adj_list = [[] for _ in range(num_nodes)]\n        degrees = [0] * num_nodes\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n            degrees[u] += 1\n            degrees[v] += 1\n        \n        leaves = deque()\n        for node in range(num_nodes):\n            if degrees[node] == 1:\n                leaves.append(node)\n        \n        remaining_nodes = num_nodes\n        while remaining_nodes > 2:\n            leaves_count = len(leaves)\n            remaining_nodes -= leaves_count\n            for _ in range(leaves_count):\n                leaf = leaves.popleft()\n                for neighbor in adj_list[leaf]:\n                    degrees[neighbor] -= 1\n                    if degrees[neighbor] == 1:\n                        leaves.append(neighbor)\n        \n        centers = list(leaves)\n        return centers\n        \n        \n        \n            def findTreeCenters(self, edges: List[List[int]]) -> List[int]:\n        num_nodes = len(edges) + 1\n        adj_list = [[] for _ in range(num_nodes)]\n        degrees = [0] * num_nodes\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n            degrees[u] += 1\n            degrees[v] += 1\n        \n        leaves = deque()\n        for node in range(num_nodes):\n            if degrees[node] == 1:\n                leaves.append(node)\n        \n        remaining_nodes = num_nodes\n        while remaining_nodes > 2:\n            leaves_count = len(leaves)\n            remaining_nodes -= leaves_count\n            for _ in range(leaves_count):\n                leaf = leaves.popleft()\n                for neighbor in adj_list[leaf]:\n                    degrees[neighbor] -= 1\n                    if degrees[neighbor] == 1:\n                        leaves.append(neighbor)\n        \n        centers = list(leaves)\n        return centers\n        \n        \n        \n        \n            def findTreeCenters(self, edges: List[List[int]]) -> List[int]:\n        num_nodes = len(edges) + 1\n        adj_list = [[] for _ in range(num_nodes)]\n        degrees = [0] * num_nodes\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n            degrees[u] += 1\n            degrees[v] += 1\n        \n        leaves = deque()\n        for node in range(num_nodes):\n            if degrees[node] == 1:\n                leaves.append(node)\n        \n        remaining_nodes = num_nodes\n        while remaining_nodes > 2:\n            leaves_count = len(leaves)\n            remaining_nodes -= leaves_count\n            for _ in range(leaves_count):\n                leaf = leaves.popleft()\n                for neighbor in adj_list[leaf]:\n                    degrees[neighbor] -= 1\n                    if degrees[neighbor] == 1:\n                        leaves.append(neighbor)\n        \n        centers = list(leaves)\n        return centers\n        \n        \n        \n            def findTreeCenters(self, edges: List[List[int]]) -> List[int]:\n        num_nodes = len(edges) + 1\n        adj_list = [[] for _ in range(num_nodes)]\n        degrees = [0] * num_nodes\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n            degrees[u] += 1\n            degrees[v] += 1\n        \n        leaves = deque()\n        for node in range(num_nodes):\n            if degrees[node] == 1:\n                leaves.append(node)\n        \n        remaining_nodes = num_nodes\n        while remaining_nodes > 2:\n            leaves_count = len(leaves)\n            remaining_nodes -= leaves_count\n            for _ in range(leaves_count):\n                leaf = leaves.popleft()\n                for neighbor in adj_list[leaf]:\n                    degrees[neighbor] -= 1\n                    if degrees[neighbor] == 1:\n                        leaves.append(neighbor)\n        \n        centers = list(leaves)\n        return centers\n        \n        \n        \n            def findTreeCenters(self, edges: List[List[int]]) -> List[int]:\n        num_nodes = len(edges) + 1\n        adj_list = [[] for _ in range(num_nodes)]\n        degrees = [0] * num_nodes\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n            degrees[u] += 1\n            degrees[v] += 1\n        \n        leaves = deque()\n        for node in range(num_nodes):\n            if degrees[node] == 1:\n                leaves.append(node)\n        \n        remaining_nodes = num_nodes\n        while remaining_nodes > 2:\n            leaves_count = len(leaves)\n            remaining_nodes -= leaves_count\n            for _ in range(leaves_count):\n                leaf = leaves.popleft()\n                for neighbor in adj_list[leaf]:\n                    degrees[neighbor] -= 1\n                    if degrees[neighbor] == 1:\n                        leaves.append(neighbor)\n        \n        centers = list(leaves)\n        return centers\n        \n        \"\"\"\n        min_diameter = float('inf')\n        for center1 in centers1:\n            for center2 in centers2:\n                new_diameter = max(diameter1, diameter2, (diameter1 + 1) // 2 + (diameter2 + 1) // 2 + 1)\n                min_diameter = min(min_diameter, new_diameter)\n        \n        return min_diameter\n",
    "submit_ts": 1719719971.0
}