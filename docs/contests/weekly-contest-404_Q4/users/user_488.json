{
    "username": "SSD9797",
    "submission": "class Solution:\n    def build_adjacency_list(self, edges):\n        adj_list = defaultdict(list)\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n        return adj_list\n\n    def bfs_farthest_node(self, adj_list, start):\n        visited = {}\n        queue = deque([(start, 0)]) \n        farthest_node = start\n        max_distance = 0\n\n        while queue:\n            node, dist = queue.popleft()\n            visited[node] = dist\n\n            if dist > max_distance:\n                max_distance = dist\n                farthest_node = node\n\n            for neighbor in adj_list[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, dist + 1))\n\n        return farthest_node, max_distance\n\n    def tree_diameter(self, edges):\n        if len(edges)==0:\n            return 0\n        adj_list = self.build_adjacency_list(edges)\n\n        start_node = next(iter(adj_list.keys()))\n        farthest_node_from_start, _ = self.bfs_farthest_node(adj_list, start_node)\n\n        _, diameter = self.bfs_farthest_node(adj_list, farthest_node_from_start)\n\n        return diameter\n    \n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        d1, d2 = self.tree_diameter(edges1),  self.tree_diameter(edges2)\n       \n        return max(d1, d2, 1 + (d1+1)//2 + (d2+1)//2)\n        \n        \n        ",
    "submit_ts": "1719718521",
    "subm_id": "1304419306"
}