{
    "username": "samanwaysadhu5",
    "submission": "class LazySegmentTree\n{\n    vector<int> tree;\n    vector<int> lazy;\n    int size;\n    \n    void constructSTUtil(vector<int> &arr, int ss, int se, int si)\n    {\n        if (ss > se)\n            return ;\n     \n        if (ss == se)\n        {\n            tree[si] = arr[ss];\n            return;\n        }\n        \n        int mid = (ss + se) / 2;\n        constructSTUtil(arr, ss, mid, si * 2 + 1);\n        constructSTUtil(arr, mid + 1, se, si * 2 + 2);\n     \n        tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];\n    }\n    \n    int getSumUtil(int ss, int se, int qs, int qe, int si)\n    {\n        if (lazy[si] != 0)\n        {\n            tree[si] += (se - ss + 1) * lazy[si];\n            if (ss != se)\n            {\n                lazy[si * 2 + 1] += lazy[si];\n                lazy[si * 2 + 2] += lazy[si];\n            }\n            lazy[si] = 0;\n        }\n     \n        if (ss > se || ss > qe || se < qs) return 0;\n     \n        if (ss >= qs && se <= qe)\n            return tree[si];\n     \n        int mid = (ss + se) / 2;\n        return getSumUtil(ss, mid, qs, qe, 2 * si + 1) +\n               getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);\n    }\n    \n    void updateRangeUtil(int si, int ss, int se, int us,\n                     int ue, int diff)\n    {\n        if (lazy[si] != 0)\n        {\n            tree[si] += (se - ss + 1) * lazy[si];\n            if (ss != se)\n            {\n                lazy[si * 2 + 1] += lazy[si];\n                lazy[si * 2 + 2] += lazy[si];\n            }\n            lazy[si] = 0;\n        }\n        \n        if (ss > se || ss > ue || se < us)\n            return;\n        \n        if (ss >= us && se <= ue)\n        {\n            tree[si] += (se - ss + 1) * diff;\n            if (ss != se)\n            {\n                lazy[si*2 + 1] += diff;\n                lazy[si*2 + 2] += diff;\n            }\n            return;\n        }\n\n        int mid = (ss + se) / 2;\n        updateRangeUtil(si * 2 + 1, ss, mid, us, ue, diff);\n        updateRangeUtil(si * 2 + 2, mid + 1, se, us, ue, diff);\n\n        tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];\n    }\n    \n    public:\n    LazySegmentTree()\n    {\n        size = 0;\n    }\n    \n    LazySegmentTree(int n)\n    {\n        size = n;\n        tree.assign(4 * n, 0);\n        lazy.assign(4 * n, 0);\n    }\n    \n    LazySegmentTree(vector<int> &a)\n    {\n        size = a.size();\n        tree.assign(4 * size, 0);\n        lazy.assign(4 * size, 0);\n        constructST(a);\n    }\n    \n    void constructST(vector<int> &a)\n    {\n        if (size != a.size())\n        {\n            size = a.size();\n            tree.resize(4 * size, 0);\n            lazy.resize(4 * size, 0);\n        }\n        constructSTUtil(a, 0, size - 1, 0);\n    }\n    \n    int getSum(int qs, int qe)\n    {\n        if (qs < 0 || qe >= size || qs > qe)\n        {\n            cout <<\"Invalid Input\";\n            return -1;\n        }\n     \n        return getSumUtil(0, size - 1, qs, qe, 0);\n    }\n    \n    void updateRange(int us, int ue, int diff)\n    {\n        updateRangeUtil(0, 0, size - 1, us, ue, diff);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries)\n    {\n        int n = nums.size();\n        vector<int> a(n, 0);\n        for (int i = 1; i + 1 < n; i++)\n            if (nums[i] > max(nums[i - 1], nums[i + 1]))\n                a[i] = 1;\n        \n        LazySegmentTree t(a);\n        vector<int> ans;\n        for (const vector<int> &q: queries)\n        {\n            if (q[0] == 1)\n            {\n                if (q[2] > q[1] + 1) ans.push_back(t.getSum(q[1] + 1, q[2] - 1));\n                else ans.push_back(0);\n                continue;\n            }\n            nums[q[1]] = q[2];\n            for (int i = max(1, q[1] - 1); i <= min(n - 2, q[1] + 1); i++)\n            {\n                if (nums[i] > max(nums[i - 1], nums[i + 1]) && a[i] == 0)\n                {\n                    a[i] = 1;\n                    t.updateRange(i, i, 1);\n                }\n                else if (nums[i] <= max(nums[i - 1], nums[i + 1]) && a[i] == 1)\n                {\n                    a[i] = 0;\n                    t.updateRange(i, i, -1);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718508046.0
}