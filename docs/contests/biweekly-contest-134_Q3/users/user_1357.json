{
    "username": "parasraina_",
    "submission": "import java.lang.reflect.Array;\nimport java.util.*;\n\nimport javax.swing.text.Segment;\n\nclass Solution {\n\n    static final Random random = new Random();\n\n    static final int mod = 998244353;\n\n    static long add(long a, long b) {\n\n        return (a + b) % mod;\n\n    }\n\n    static long sub(long a, long b) {\n\n        return ((a - b) % mod + mod) % mod;\n\n    }\n\n    static long mul(long a, long b) {\n\n        return (a * b) % mod;\n\n    }\n\n    static long exp(long base, long exp) {\n\n        if (exp == 0)\n            return 1;\n\n        long half = exp(base, exp / 2);\n\n        if (exp % 2 == 0)\n            return mul(half, half);\n\n        return mul(half, mul(half, base));\n\n    }\n\n    static long[] factorials = new long[2_000_001];\n\n    static long[] invFactorials = new long[2_000_001];\n\n    static void precompFacts() {\n\n        factorials[0] = invFactorials[0] = 1;\n\n        for (int i = 1; i < factorials.length; i++)\n            factorials[i] = mul(factorials[i - 1], i);\n\n        invFactorials[factorials.length - 1] = exp(factorials[factorials.length - 1], mod - 2);\n\n        for (int i = invFactorials.length - 2; i >= 0; i--)\n\n            invFactorials[i] = mul(invFactorials[i + 1], i + 1);\n\n    }\n\n    static long nCk(int n, int k) {\n\n        return mul(factorials[n], mul(invFactorials[k], invFactorials[n - k]));\n\n    }\n\n    static void sort(int[] a) {\n\n        ArrayList<Integer> l = new ArrayList<>();\n\n        for (int i : a)\n            l.add(i);\n\n        Collections.sort(l);\n\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n\n    }\n    int[] isComposite;\n    ArrayList<Integer> primes;\n    void sieve(int N) {\n\n        isComposite = new int[N + 1];\n\n        isComposite[0] = isComposite[1] = 1; // 0 indicates a prime number\n\n        primes = new ArrayList<Integer>();\n\n        for (int i = 2; i <= N; ++i) // can loop till i*i <= N if primes array is not needed O(N log log sqrt(N))\n\n            if (isComposite[i] == 0) // can loop in 2 and odd integers for slightly better performance\n\n            {\n\n                primes.add(i);\n\n                if (1l * i * i <= N)\n\n                    for (int j = i * i; j <= N; j += i) // j = i * 2 will not affect performance too much, may alter in\n                                                        // modified sieve\n\n                        isComposite[j] = 1;\n\n            }\n\n    }\n\n    ArrayList<Integer> primeFactors(int N) {\n\n        ArrayList<Integer> factors = new ArrayList<Integer>(); // take abs(N) in case of -ve integers\n\n        int idx = 0, p = primes.get(idx);\n\n        while (p * p <= N) {\n\n            while (N % p == 0) {\n\n                factors.add(p);\n\n                N /= p;\n\n            }\n\n            p = primes.get(++idx);\n\n        }\n\n        if (N != 1) // last prime factor may be > sqrt(N)\n\n            factors.add(N); // for integers whose largest prime factor has a power of 1\n\n        return factors;\n\n    }\n\n    int gcd(int a, int b) {\n\n        return b == 0 ? (a < 0 ? -a : a) : gcd(b, a % b);\n\n    }\n\n    long gcd(long a, long b) {\n\n        return b == 0 ? (a < 0 ? -a : a) : gcd(b, a % b);\n\n    }\n\n    long lcm(long a, long b) {\n\n        long lcm = (a / gcd(a, b)) * b;\n\n        return lcm > 0 ? lcm : -lcm;\n\n    }\n\n    int lcm(int a, int b) {\n\n        int lcm = (a / gcd(a, b)) * b;\n\n        return lcm > 0 ? lcm : -lcm;\n\n    }\n\n    class Multiset<T> extends TreeMap<T, Long> {\n\n        public Multiset() {\n\n            super();\n\n        }\n\n        public Multiset(List<T> list) {\n\n            super();\n\n            for (T e : list)\n                this.addOne(e);\n\n        }\n\n        public long count(Object elm) {\n\n            return getOrDefault(elm, 0L);\n\n        }\n        public void insert(T elm, long amount){\n            put(elm, amount);\n        }\n        public void add(T elm, long amount) {\n\n            if (!this.containsKey(elm))\n                put(elm, amount);\n\n            else\n                replace(elm, get(elm) + amount);\n\n            if (this.count(elm) == 0)\n                this.remove(elm);\n\n        }\n\n        public void addOne(T elm) {\n\n            this.add(elm, 1);\n\n        }\n\n        public void removeOne(T elm) {\n\n            this.add(elm, -1);\n\n        }\n\n    }\n\n    int[] prefixFunction(char[] s) {\n\n        int n = s.length, pi[] = new int[n];\n\n        for (int i = 1, j = 0; i < n; ++i) // j = pi[i-1] at the beginning of every iteration\n\n        {\n\n            while (j > 0 && s[i] != s[j])\n\n                j = pi[j - 1];\n\n            if (s[i] == s[j])\n\n                ++j;\n\n            pi[i] = j;\n\n        }\n\n        return pi;\n\n    }\n\n    class SparseTable {\n\n        int[][] rmq;\n\n        public SparseTable(int[] a) {\n\n            int n = a.length;\n\n            rmq = new int[32 - Integer.numberOfLeadingZeros(n)][];\n\n            rmq[0] = a.clone();\n\n            for (int i = 1; i < rmq.length; i++) {\n\n                rmq[i] = new int[n - (1 << i) + 1];\n\n                for (int j = 0; j < rmq[i].length; j++)\n\n                    rmq[i][j] = op(rmq[i - 1][j], rmq[i - 1][j + (1 << (i - 1))]);\n\n            }\n\n        }\n\n        public int query(int i, int j) {\n\n            int k = 31 - Integer.numberOfLeadingZeros(j - i + 1);\n\n            return op(rmq[k][i], rmq[k][j - (1 << k) + 1]);\n\n        }\n\n        int op(int a, int b) {\n\n            return Math.max(a, b);\n\n        }\n\n    }\n\n    class Pair implements Comparable<Pair> {\n\n        int a;\n\n        int b;\n\n        Pair(int a, int b) {\n\n            this.a = a;\n\n            this.b = b;\n\n        }\n\n        public int hashCode() {\n\n            return Objects.hash(a, b);\n\n        }\n\n        public boolean equals(Object obj) {\n\n            Pair that = (Pair) obj;\n\n            return a == that.a && b == that.b;\n\n        }\n\n        public String toString() {\n\n            return \"[\" + a + \", \" + b + \"]\";\n\n        }\n\n        public int compareTo(Pair v) {\n\n            return a - v.a;\n\n        }\n\n    }\n\n    int[][] g;\n\n    int n;\n\n    int m;\n\n    int s;\n\n    int t;\n\n    int[] from;\n\n    int[] to;\n\n    int[][] arr;\n\n    \n\n\n    int[][] makeGraph(int N, int M) {\n\n        int[][] G = new int[N][];\n\n        int[] p = new int[N];\n\n        for (int i = 0; i < M; i++) {\n\n            p[from[i]]++;\n\n            p[to[i]]++;\n\n        }\n\n        for (int i = 0; i < N; i++)\n            G[i] = new int[p[i]];\n\n        for (int i = 0; i < M; i++) {\n\n            G[from[i]][--p[from[i]]] = to[i];\n\n            G[to[i]][--p[to[i]]] = from[i];\n\n        }\n\n        return G;\n\n    }\n\n    class FenwickTree {\n\n        public int[] tree;\n\n        public int size;\n\n        public FenwickTree(int size) {\n\n            this.size = size;\n\n            tree = new int[size + 5];\n\n        }\n\n        public void add(int i, int v) {\n\n            while (i <= size) {\n\n                tree[i] += v;\n\n                i += i & -i;\n\n            }\n\n        }\n\n        public int find(int i) {\n\n            int res = 0;\n\n            while (i >= 1) {\n\n                res += tree[i];\n\n                i -= i & -i;\n\n            }\n\n            return res;\n\n        }\n\n        public int find(int l, int r) {\n\n            return find(r) - find(l - 1);\n\n        }\n\n    }\n\n    class STLazy {\n\n        int leftmost;\n\n        int rightmost;\n\n        STLazy lchild;\n\n        STLazy rchild;\n\n        int sum;\n\n        public STLazy(int leftmost, int rightmost, int[] a) {\n\n            this.leftmost = leftmost;\n\n            this.rightmost = rightmost;\n\n            if (leftmost == rightmost) {\n\n                // leaf\n\n                sum = a[leftmost];\n\n            } else {\n\n                // 2 children\n\n                int mid = (leftmost + rightmost) / 2;\n\n                // (l,mid) (mid+1,r)\n\n                lchild = new STLazy(leftmost, mid, a);\n\n                rchild = new STLazy(mid + 1, rightmost, a);\n\n                recalc();\n\n            }\n\n        }\n\n        public void recalc() {\n\n            if (leftmost == rightmost)\n                return;\n\n            sum = Math.max(lchild.sum, rchild.sum);\n\n        }\n\n        public void update(int index, int newVal) {\n\n            if (leftmost == rightmost) {\n\n                // leaf;\n\n                sum += newVal;\n\n            } else {\n\n                // 2 children\n\n                if (index <= lchild.rightmost)\n                    lchild.update(index, newVal);\n\n                else\n                    rchild.update(index, newVal);\n\n                recalc();\n\n            }\n\n        }\n\n        public int query(int l, int r) {\n\n            // entirely disjoint\n\n            if (l > rightmost || r < leftmost)\n                return 0;\n\n            // covers us\n\n            if (l <= leftmost && r >= rightmost)\n                return sum;\n\n            // we don't know\n\n            return Math.max(lchild.query(l, r), rchild.query(l, r));\n\n        }\n\n    }\n\n    int[] smallerToRight(int[] a) {\n\n        int n = a.length;\n\n        int[] p = new int[n];\n\n        for (int i = n - 1; i >= 0; i--) {\n\n            int j = i + 1;\n\n            while (j != n && a[j] >= a[i]) {\n\n                j = p[j];\n\n            }\n\n            p[i] = j;\n\n        }\n\n        return p;\n\n    }\n\n    int[] greaterToRight(int[] a) {\n\n        int n = a.length;\n\n        int[] p = new int[n];\n\n        for (int i = n - 1; i >= 0; i--) {\n\n            int j = i + 1;\n\n            while (j != n && a[j] <= a[i]) {\n\n                j = p[j];\n\n            }\n\n            p[i] = j;\n\n        }\n\n        return p;\n\n    }\n\n    class ST {\n\n        int leftmost;\n\n        int rightmost;\n\n        ST lchild;\n\n        ST rchild;\n\n        int max,lmax,rmax;\n\n\n        public ST(int leftmost, int rightmost, int[] a) {\n\n            this.leftmost = leftmost;\n\n            this.rightmost = rightmost;\n\n            if (leftmost == rightmost) {\n\n                // leaf\n\n                max = lmax = rmax = a[leftmost];\n\n            } else {\n\n                // 2 children\n\n                int mid = (leftmost + rightmost) / 2;\n\n                // (l,mid) (mid+1,r)\n\n                lchild = new ST(leftmost, mid, a);\n\n                rchild = new ST(mid + 1, rightmost, a);\n\n                recalc();\n\n            }\n\n        }\n\n        public void recalc() {\n\n            max= Math.max(lchild.rmax+rchild.lmax,Math.max(lchild.max, rchild.max));\n            if(lchild.lmax==lchild.rightmost-lchild.leftmost+1)\n                lmax= lchild.lmax+rchild.lmax;\n            else\n                lmax= lchild.lmax;\n\n            if(rchild.rmax==rchild.rightmost-rchild.leftmost+1)\n                rmax= rchild.rmax+lchild.rmax;\n            else    \n                rmax= rchild.rmax;\n            \n        }\n        public void update(int index, int newVal) {\n\n            if (leftmost == rightmost) {\n\n                // leaf;\n\n                max = lmax = rmax = newVal;\n\n            } else {\n\n                // 2 children\n\n                if (index <= lchild.rightmost)\n                    lchild.update(index, newVal);\n\n                else\n                    rchild.update(index, newVal);\n\n                recalc();\n\n            }\n\n        }\n\n        public int[] query(int l, int r) {\n\n            // entirely disjoint\n\n            if (l > rightmost || r < leftmost)\n\n                return new int[]{0,0,0};\n\n            // covers us\n\n            if (l <= leftmost && r >= rightmost)\n                return new int[]{max,lmax,rmax};\n\n            // we don't know\n            int[] lans= lchild.query(l, r);\n            int[] rans= rchild.query(l, r);\n            int max1= Math.max(lans[2]+rans[1],Math.max(lans[0], rans[0]));\n            int lnow,rnow=0;\n            if(lans[1]==lchild.rightmost-lchild.leftmost+1)\n                lnow= lans[1]+rans[1];\n            else\n                lnow= lans[1];\n\n            if(rans[2]==rchild.rightmost-rchild.leftmost+1)\n                rnow= rans[2]+lans[2];\n            else    \n                rnow= rans[2];\n\n            return new int[]{max1, lnow,rnow};\n\n        }\n\n    }\n    boolean[] vis;\n    \n\n    class dsu {\n\n        private int size;\n\n        private int[] sz;\n\n        private int[] par;\n\n        private int numComponents;\n\n        public dsu(int size) {\n\n            this.size = numComponents = size;\n\n            sz = new int[size];\n\n            par = new int[size];\n\n            clear();\n\n        }\n\n        public int find(int p) {\n\n            if (p == par[p])\n                return p;\n\n            return par[p] = find(par[p]);\n\n        }\n\n        public void merge(int p, int q) {\n\n            int root1 = find(p);\n\n            int root2 = find(q);\n\n            if (root1 == root2)\n                return;\n\n            if (sz[root2] > sz[root1]) {\n\n                root1 ^= root2;\n\n                root2 ^= root1;\n\n                root1 ^= root2;\n\n            }\n\n            sz[root1] += sz[root2];\n\n            par[root2] = root1;\n\n            numComponents--;\n\n        }\n\n        public void clear() {\n\n            for (int i = 0; i < size; i++) {\n\n                par[i] = i;\n\n                sz[i] = 1;\n\n            }\n\n        }\n\n    }\n\n    class Tuple implements Comparable<Tuple> {\n\n        int a;\n\n        int b;\n\n        int c;\n\n        Tuple(int a, int b, int c) {\n\n            this.a = a;\n\n            this.b = b;\n\n            this.c = c;\n\n        }\n\n        public int compareTo(Tuple v) {\n\n            return a - v.a;\n\n        }\n\n    }\n\n    void reverse(int[] arr, int i, int j) {\n\n        while (i < j) {\n\n            swap(arr, i++, j--);\n\n        }\n\n    }\n\n    void swap(int[] arr, int i, int j) {\n\n        if (i != j) {\n\n            arr[i] ^= arr[j];\n\n            arr[j] ^= arr[i];\n\n            arr[i] ^= arr[j];\n\n        }\n\n    }\n\n    ArrayList<Long> findDiv(long N) {\n\n        // gens all divisors of N\n\n        ArrayList<Long> ls1 = new ArrayList<>();\n\n        ArrayList<Long> ls2 = new ArrayList<>();\n\n        for (int i = 1; i <= (int) (Math.sqrt(N) + 0.00000001); i++)\n\n            if (N % i == 0) {\n\n                ls1.add(1l * i);\n\n                ls2.add(N / i);\n\n            }\n\n        Collections.reverse(ls2);\n\n        for (long b : ls2)\n\n            if (b != ls1.get(ls1.size() - 1))\n\n                ls1.add(b);\n\n        return ls1;\n\n    }\n\n    long power(long x, long y) {\n\n        // 0^0 = 1\n\n        long res = 1L;\n\n        x = x % mod;\n\n        while (y > 0) {\n\n            if ((y & 1) == 1)\n\n                res = (res * x) % mod;\n\n            y >>= 1;\n\n            x = (x * x) % mod;\n\n        }\n\n        return res;\n\n    }\n\n    int[] nsvLeft(int[] a) {\n        int n = a.length;\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            int j = i - 1;\n            while (j != -1 && a[j] <= a[i]) {\n                j = p[j];\n            }\n            p[i] = j;\n        }\n        return p;\n    }\n\n    int[] nsvRight(int[] a) {\n        int n = a.length;\n        int[] p = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            int j = i + 1;\n            while (j != n && a[j] <= a[i]) {\n                j = p[j];\n            }\n            p[i] = j;\n        }\n        return p;\n    }\n    /* int floor(int[] arr, int x,int i){\n        int l=0;\n        int r= i;\n        int ans=0;\n        while(l<=r){\n            int mid= l+(r-l)/2;\n            if(seg.query(mid, i)>=x){\n                ans=mid;\n                l= mid+1;\n            }else{\n                r=mid-1;\n            }\n        }\n        return ans;\n    }\n    int ceil(int[] arr, int x,int i){\n        int l=0;\n        int r= i;\n        int ans=r;\n        while(l<=r){\n            int mid = l+ (r-l)/2;\n            if(seg.query(mid, i)<=x){\n                ans=mid;\n                r=mid-1;\n            }else{\n                l= mid+1;\n            }\n        }\n        return ans;\n    } */\n\n    int[] bfs(int st,ArrayList<Integer>[] g1) {\n\n        int[] D = new int[n];\n\n        Arrays.fill(D, Integer.MAX_VALUE);\n\n        Queue<Integer> q = new LinkedList<>();\n\n        q.add(st);\n\n        D[st] = 0;\n\n        while (!q.isEmpty()) {\n\n            int p = q.poll();\n\n            for (int a : g1[p]) {\n\n                if (D[a] > D[p] + 1) {\n\n                    D[a] = D[p] + 1;\n\n                    q.add(a);\n\n                }\n\n            }\n\n        }\n\n        return D;\n\n    }\n    public int numberOfAlternatingGroups(int[] color, int k) {\n        int n= color.length;\n        int[] arr= new int[n+k-1];\n        for(int i=0;i<n;i++){\n            arr[i]= color[i];\n        }\n        for(int i=n;i<arr.length;i++){\n            arr[i]= arr[i-n];\n        }\n        int ans=0;\n        int last=0;\n        for(int i=0;i<n;i++){\n            if(last==1){\n                if(arr[i+k-1]==arr[i+k-2]){\n                    last=0;\n                    i= i+k-2;\n                    \n                }else{\n                    ans++;\n                }\n                continue;\n            }\n            int j=1;\n            for(;j<k;j++){\n                if(arr[i+j]==arr[i+j-1]){\n                    break;\n                }\n            }\n            if(j==k){\n                last=1;\n                ans++;\n            }else{\n                last=0;\n                i= i+j-1;\n            }\n        }\n        return ans;\n    }\n    \n}\n",
    "submit_ts": "1720278475",
    "subm_id": "1311710798"
}