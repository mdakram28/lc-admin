{
    "username": "ritikjainrj18",
    "submission": "\nclass DSU {\n    long long n;\n    vector<long long> par, siz;\n\npublic:\n    vector<vector<long long>> p;\n    DSU(long long n) {\n        this->n = n;\n        for(int i=0;i<n;i++){\n              par.push_back(i);\n              siz.push_back(1);\n              p.push_back({(long long)1e9+1,0,(long long)1e9+1,0});\n        }\n\n        // for (long long i = 0; i < n; i++) {\n        //     par[i] = i;\n        // }\n    }\n\n    long long getPar(long long x) {\n        if (par[x] == x) return x;\n        return par[x] = getPar(par[x]);\n    }\n\n    void merge(long long a, long long b) {\n        a = getPar(a);\n        b = getPar(b);\n        if (a == b) return;\n\n        if (siz[a] < siz[b]) {\n            swap(a, b);\n        }\n        par[b] = a;\n        siz[a] += siz[b];\n\n        p[a][0] = min(p[a][0], p[b][0]);\n        p[a][1] = max(p[a][1], p[b][1]);\n        p[a][2] = min(p[a][2], p[b][2]);\n        p[a][3] = max(p[a][3], p[b][3]);\n    }\n};\n\nclass Solution {\npublic:\n    bool canReachCorner(long long X, long long Y, vector<vector<int>>& circles) {\n        long long n = circles.size();\n        DSU d(n);\n\n        for (long long i = 0; i < n; i++) {\n            for (long long j = 0; j <= i; j++) {\n                long long para = d.getPar(i);\n                long long parb = d.getPar(j);\n\n                d.p[para][0] = min(d.p[para][0], max(0LL,(long long)circles[i][0] - circles[i][2]));\n                d.p[para][1] = max(d.p[para][1], min(X, (long long)circles[i][0] + circles[i][2]));\n                d.p[para][2] = min(d.p[para][2], max(0LL,(long long) circles[i][1] - circles[i][2]));\n                d.p[para][3] = max(d.p[para][3], min(Y, (long long)circles[i][1] + circles[i][2]));\n\n                if (para == parb) continue;\n                \n                d.p[parb][0] = min(d.p[parb][0], max(0LL, (long long)circles[j][0] - circles[j][2]));\n                d.p[parb][1] = max(d.p[parb][1], min(X, (long long)circles[j][0] + circles[j][2]));\n                d.p[parb][2] = min(d.p[parb][2], max(0LL, (long long)circles[j][1] - circles[j][2]));\n                d.p[parb][3] = max(d.p[parb][3], min(Y, (long long)circles[j][1] + circles[j][2]));\n                long long x1=circles[i][0];\n                long long x2=circles[j][0];\n                long long y1=circles[i][1];\n                long long y2=circles[j][1];\n                long long r1=circles[i][2];\n                long long r2=circles[j][2];\n                if((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)<=(r1+r2)*(r1+r2))\n                d.merge(para, parb);\n            }\n        }\n\n        for (long long i = 0; i < n; i++) {\n            long long para = d.getPar(i);\n            // cout<<d.p[para][0]<< \" \"<<d.p[para][1]<< \" \"<<d.p[para][2]<< \" \"<<d.p[para][3]<<endl;\n            if((d.p[para][0]==0)&&(d.p[para][1]==X)) return 0;\n            if((d.p[para][2]==0)&&(d.p[para][3]==Y)) return 0;\n            if((d.p[para][0]==0)&&(d.p[para][2]==0)) return 0;\n            if((d.p[para][1]==X)&&(d.p[para][3]==Y)) return 0;\n\n         \n        }\n        return true;\n    }\n};\n\n\n// 8\n// 9\n// [[3,1,1],[1,5,1],[4,8,2]]",
    "submit_ts": "1722137692",
    "subm_id": "1335770987"
}