{
    "username": "aryangarg0729",
    "submission": "class Solution {\npublic:\n    class SegmentTree{\n        public:\n    vector<long long>seg,lazy;\n    int n;\n    void build(vector<int>&nums,int ind,int low, int high){\n        if(low==high){\n            seg[ind] = nums[low];\n            return;\n        }\n        int mid = (low+high)/2;\n        build(nums,2*ind+1,low,mid);\n        build(nums,2*ind+2,mid+1,high);\n        seg[ind] = seg[2*ind+1]+seg[2*ind+2];\n    }\n    long long query(int ind,int low,int high,int l,int r){\n        // update the node if some updates are left in lazy\n        if(lazy[ind]!=0){\n            seg[ind] += (high-low+1)*lazy[ind];\n            // propogate lazy update downwards if the node is not leaf\n            if(low!=high){\n                lazy[2*ind+1] += lazy[ind];\n                lazy[2*ind+2] += lazy[ind];\n            }\n            // clear lazy\n            lazy[ind]=0;\n        }\n        // no overlap\n        if(l>high || r<low)return 0;\n\n        // complete overlap\n        if(low>=l && high<=r) return seg[ind];\n\n        // partial overlap\n        int mid = (low+high)/2;\n        long long left = query(2*ind+1,low,mid,l,r);\n        long long right = query(2*ind+2,mid+1,high,l,r);\n        return left+right;\n    }\n\n    void update(int ind,int low,int high,int i,int val){\n        if(low==high){\n            seg[ind] = val;\n            return;\n        }\n\n        int mid = (low+high)/2;\n        \n        if(mid>=i)update(2*ind+1,low,mid,i,val);\n        else update(2*ind+2,mid+1,high,i,val);\n\n        seg[ind] = seg[2*ind+1]+seg[2*ind+2];\n    }\n\n    void rangeUpdate(int ind,int low,int high,int l,int r,int val){\n        // update previous remaining updates\n        // and propagate downwards\n        if(lazy[ind]!=0){\n            seg[ind] += (high-low+1)*lazy[ind];\n            // propogate lazy update downwards\n            if(low!=high){\n                lazy[2*ind+1] += lazy[ind];\n                lazy[2*ind+2] += lazy[ind];\n            }\n\n            lazy[ind]=0;\n        }\n        // no overlap\n        // we don't do anything and return\n        if(high<l || r<low)return;\n\n        // complete overlap\n        if(low>=l && high<=r){\n            // update value in seg tree\n            seg[ind]+=(high-low+1)*val;\n            //prop down if not leaf\n            if(low!=high){\n                lazy[2*ind+1] += val;\n                lazy[2*ind+2] += val;\n            }\n            return;\n        } \n\n        // partial overlap\n        int mid = (low+high)/2;\n        rangeUpdate(2*ind+1,low,mid,l,r,val);\n        rangeUpdate(2*ind+2,mid+1,high,l,r,val);\n        seg[ind] = seg[2*ind+1]+seg[2*ind+2];\n    }\n    public:\n    SegmentTree(vector<int>&nums,int val){\n        n = nums.size();\n        seg.resize(4*n,val);\n        lazy.resize(4*n,val);\n        build(nums,0,0,n-1);\n    }\n    \n    // query range l to r\n    long long query(int l,int r){\n        return query(0,0,n-1,l,r);\n    }\n\n    // point update(replace value at index i with val)\n    void update(int ind,int val){\n        update(0,0,n-1,ind,val);\n    }\n\n    // increase a range by val\n    void rangeUpdate(int l,int r,int val){\n        rangeUpdate(0,0,n-1,l,r,val);\n    }\n    \n};\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int>adj(n),dist(n);\n        for(int i = 0;i<n-1;i++){\n            adj[i] = i+1;\n            dist[i] = n-1-i;\n        }\n        vector<int>vs(n,1);\n        SegmentTree seg(dist,0);\n        SegmentTree vis(vs,0);\n        vector<int>ans;\n        for(auto q:queries){\n            int u = q[0],v = q[1];\n            if(vs[u]==0 || vs[v]==0){\n                ans.push_back(ans.back());\n                continue;\n            }\n            adj[u] = max(adj[u],v);\n            for(int i = u+1;i<v;i++){\n                if(vs[i]==0)break;\n                adj[i]=-1;\n                vs[i] = 0;\n            }\n            for(int i = v-1;i>u;i--){\n                if(vs[i]==0)break;\n                adj[i]=-1;\n                vs[i] = 0;\n            }\n            int count = vis.query(u+1,v-1);\n            // cout<<count<<endl;\n            vis.rangeUpdate(u+1,u+1,-count);\n            // for(int i = u+1;i<v;i++){\n            //     vis.update(i,0);\n            // }\n            seg.rangeUpdate(0,u,-count);\n            ans.push_back(seg.query(0,0));\n        }\n        return ans;\n        \n    }\n};\n// 23\n// [[19,21],[17,21],[14,22]]\n// [21,19,15]",
    "submit_ts": "1722743192",
    "subm_id": "1343786489"
}