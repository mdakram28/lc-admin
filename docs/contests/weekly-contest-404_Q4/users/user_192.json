{
    "username": "ocavue",
    "submission": "from typing import List\nfrom collections import defaultdict\n\n\ndef find_center(edges: List[List[int]]):\n    n = len(edges) + 1\n    if n == 1:\n        return [0, 0]\n\n    degrees = [0] * n\n    graph = defaultdict(set)\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n        degrees[a] += 1\n        degrees[b] += 1\n\n    stack: List[int] = [i for i in range(n) if degrees[i] == 1]\n    heights = [0] * n\n    seen = set(stack)\n\n    while stack:\n        next_stack: List[int] = []\n\n        for a in stack:\n            for b in graph[a]:\n                degrees[b] -= 1\n                if b not in seen and degrees[b] == 1:\n                    seen.add(b)\n                    next_stack.append(b)\n                    heights[b] = max(heights[a] + 1, heights[b])\n\n        stack = next_stack\n\n    # print(\"heights\", heights)\n\n    max_height = max(heights)\n\n    if heights.count(max_height) == 1:\n        return [max_height, max_height * 2]\n    else:\n        return [max_height + 1, max_height * 2 + 1]\n\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        d1, l1 = find_center(edges1)\n        d2, l2 = find_center(edges2)\n        # print(d1, d2)\n        return max(d1 + d2 + 1, l1, l2)\n ",
    "submit_ts": "1719717759",
    "subm_id": "1304399995"
}