{
    "username": "shubhamvarshney2000",
    "submission": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ar array\n#define ll long long\n#define ld long double\n#define sza(x) ((int)x.size())\n#define all(a) (a).begin(), (a).end()\n\nconst int MAX_N = 1e5 + 5;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e9;\nconst ld EPS = 1e-9;\n\nlong long pow_m(long long base, long long exp, long long mod) {\n    long long result = 1LL;\n    base = (base % mod);\n        \n    while (exp > 0) {\n        if ((exp & 1LL) == 1LL) result = (result * base) % mod;\n        exp >>= 1LL;\n        base = (base * base) % mod;\n    }\n    return result;\n\n}\nclass DSU {\nprivate:\n    int sz;\n    vector<int> root, rank;\npublic:\n    DSU(int sz){\n        this->sz = sz;\n        root.resize(sz);\n        rank.resize(sz);\n        for(int i = 0; i < sz; i++){\n            root[i] = i;\n            rank[i] = 1;\n        }\n    }\n    \n    int find(int x){\n        if(root[x] == x) return x;\n        return root[x] = find(root[x]);\n    }\n    \n    bool unionSet(int x, int y){\n        int rootX = find(x);\n        int rootY = find(y);\n        if(rootX == rootY)\n            return false;\n        if(rank[rootX] > rank[rootY])\n            root[rootY] = rootX;\n        else if(rank[rootX] < rank[rootY])\n            root[rootX] = rootY;\n        else{\n            root[rootY] = rootX;\n            rank[rootX]++;\n        }\n        return true;\n    }\n\n    void reset() {\n        for(int i = 0; i < sz; i++){\n            root[i] = i;\n            rank[i] = 1;\n        }\n    }\n};\n\n\nclass TreeAncestor {\n    public:\n    vector<vector<int>> vec;\n    vector<int> depth;\n    int h = 18;\n    int n;\n    TreeAncestor(int _n, vector<int>& parent) {\n        n = _n;\n        depth.resize(n,0);\n        vec.resize(h,vector<int>(n+1,-1));\n        for(int i=0;i<n;i++){\n            vec[0][i] = parent[i];\n        }\n        for(int i=1;i<h;i++){\n            for(int j=0;j<n;j++){\n                if(vec[i-1][j] != -1)\n                    vec[i][j] = vec[i-1][vec[i-1][j]];\n            }\n        }\n    }\n    \n    int getKthAncestor(int node, int k) {\n        for(int i=0;i<h;i++){\n            if(k&(1<<i)){\n                node = vec[i][node];\n                if(node == -1){\n                    return -1;\n                }\n            }\n        }\n        return node;\n    }\n    int lca(int a, int b)\n    {\n        if(depth[a] < depth[b])\n            swap(a, b);\n        \n        int diff = depth[a] - depth[b];\n        for(int i = 0; i < 16; i++)\n            if(diff & (1 << i))\n                a = vec[a][i];\n\n        if(a == b)\n            return a;\n        \n        for(int i = 15; i >= 0; i--)\n        {\n            if(vec[a][i] != vec[b][i])\n            {\n                a = vec[a][i];\n                b = vec[b][i];\n            }\n        }\n\n        return vec[a][0];\n    }\n    void dfs(int src, int paren,vector<vector<int>> &g)\n    {\n        for(auto x : g[src])\n        {\n            if(x == paren)\n                continue;\n            depth[x] = depth[src] + 1;\n            dfs(x, src,g);\n        }\n    }\n};\n\nbool help(ll x,ll y,ll sum){\n    ll s = 0;\n    while(x>0 && y>0){\n        if(s>=sum){\n            s= s-2;\n            y--;\n        }\n        else{\n            s += 1;\n            x--;\n        }\n    }\n    if(x<=sum){\n        return 1;\n    }\n    else{\n        return 0;\n    }\n}\n bool subArrayExists(ll arr[], int N)\n{\n    unordered_set<int> sumSet;\n \n    // Traverse through array\n    // and store prefix sums\n    ll sum = 0;\n    for (int i = 0; i < N; i++) {\n        sum += arr[i];\n \n        // If prefix sum is 0 or\n        // it is already present\n        if (sum == 0 || sumSet.find(sum) != sumSet.end())\n            return true;\n \n        sumSet.insert(sum);\n    }\n    return false;\n}\nbool isSubsetSum(ll set[], ll n, ll sum)\n{\n    // The value of subset[i][j] will be true if\n    // there is a subset of set[0..j-1] with sum\n    // equal to i\n    bool subset[n + 1][sum + 1];\n \n    // If sum is 0, then answer is true\n    for (int i = 0; i <= n; i++)\n        subset[i][0] = true;\n \n    // If sum is not 0 and set is empty,\n    // then answer is false\n    for (int i = 1; i <= sum; i++)\n        subset[0][i] = false;\n \n    // Fill the subset table in bottom up manner\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= sum; j++) {\n            if (j < set[i - 1])\n                subset[i][j] = subset[i - 1][j];\n            if (j >= set[i - 1])\n                subset[i][j]\n                    = subset[i - 1][j]\n                      || subset[i - 1][j - set[i - 1]];\n        }\n    }\n \n    return subset[n][sum];\n}\nlong long solve(vector<int> nums,int k){\n    int n = nums.size();\n        long long ans = 0;\n        unordered_map<long long, long long> prev;\n        for (int i = 0; i < n; ++i) {\n            unordered_map<long long, long long> c;\n\n            if (nums[i] == k) {\n                ++ans;\n            }\n            c[nums[i]] += 1;\n\n            for (auto& [val, freq] : prev) {  \n                long long x = val & nums[i];\n                if (x == k) {\n                    ans += freq;\n                }\n                c[x] += freq;\n            }\n            prev = move(c);\n        }\n\n        return ans;\n}\nclass SegmentTree {\nprivate:\n    int n;\n    vector<int> tree;\n    \npublic:\n    SegmentTree(vector<int>& nums) {\n        n = nums.size();\n        tree.resize(2 * n);\n        build(nums);\n    }\n    \n    void build(vector<int>& nums) {\n        for (int i = 0; i < n; ++i) {\n            tree[n + i] = nums[i];\n        }\n        for (int i = n - 1; i > 0; --i) {\n            tree[i] = tree[2 * i] & tree[2 * i + 1];\n        }\n    }\n    \n    int query(int l, int r) {\n        l += n;\n        r += n;\n        int res = INT_MAX;\n        while (l < r) {\n            if (l % 2 == 1) {\n                res &= tree[l++];\n            }\n            if (r % 2 == 1) {\n                res &= tree[--r];\n            }\n            l /= 2;\n            r /= 2;\n        }\n        return res;\n    }\n};\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        return solve(nums,k);\n    }\n};",
    "submit_ts": "1720279793",
    "subm_id": "1311765344"
}