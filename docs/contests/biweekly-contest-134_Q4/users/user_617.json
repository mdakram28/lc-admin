{
    "username": "wisdompeak",
    "submission": "using LL = long long;\nclass SegmentTree {\nprivate:\n    vector<int> tree;\n    int n;\n    \n    void build(vector<int>& nums, int node, int start, int end) \n    {\n        if (start == end) {\n            tree[node] = nums[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(nums, 2 * node, start, mid);\n            build(nums, 2 * node + 1, mid + 1, end);\n            tree[node] = tree[2 * node] & tree[2 * node + 1];\n        }\n    }\n    \n    void update(int node, int start, int end, int L, int R, int val) \n    {\n        if (R < start || end < L) {\n            return;\n        }\n        if (L <= start && end <= R) {\n            tree[node] = val;\n            return;\n        }\n        int mid = (start + end) / 2;\n        update(2 * node, start, mid, L, R, val);\n        update(2 * node + 1, mid + 1, end, L, R, val);\n        tree[node] = tree[2 * node] & tree[2 * node + 1];\n    }\n\n    int query(int node, int start, int end, int L, int R) \n    {\n        if (R < start || end < L) {\n            return INT_MAX; // Identity for AND operation (all bits set)\n        }\n        if (L <= start && end <= R) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int leftAnd = query(2 * node, start, mid, L, R);\n        int rightAnd = query(2 * node + 1, mid + 1, end, L, R);\n        return leftAnd & rightAnd;\n    }\n\npublic:\n    SegmentTree(vector<int>& nums) {\n        n = nums.size();\n        tree.resize(4 * n, 0);\n        build(nums, 1, 0, n - 1);\n    }\n\n    void rangeUpdate(int L, int R, int val) {\n        update(1, 0, n - 1, L, R, val);\n    }\n\n    int rangeAnd(int L, int R) {\n        return query(1, 0, n - 1, L, R);\n    }\n};\n\nclass Solution {    \npublic:\n    long long countSubarrays(vector<int>& nums, int k) \n    {\n        int n = nums.size();\n        SegmentTree segTree(nums);\n        LL ret = 0;\n        \n        for (int i=0; i<n; i++)\n        {\n            int a = -1, b = -1;\n            \n            int left = i, right = n-1;\n            while (left < right)\n            {\n                int mid = left+(right-left)/2;\n                if (segTree.rangeAnd(i,mid)>k)\n                    left = mid+1;\n                else\n                    right = mid;\n            }\n            if (segTree.rangeAnd(i,left)==k)\n                a = left;\n            \n            left = i, right = n-1;\n            while (left < right)\n            {\n                int mid = right-(right-left)/2;\n                if (segTree.rangeAnd(i,mid)<k)\n                    right = mid-1;\n                else\n                    left = mid;\n            }\n            if (segTree.rangeAnd(i,left)==k)\n                b = left;\n            \n            // cout<<i<<\":\"<<a<<\" \"<<b<<endl;\n            \n            if (a!=-1 && b!=-1 && a<=b)\n                ret += b-a+1;\n        }\n        \n        return ret;\n    }\n};",
    "submit_ts": "1720279145",
    "subm_id": "544566161"
}