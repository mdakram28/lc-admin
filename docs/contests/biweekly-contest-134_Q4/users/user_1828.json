{
    "username": "bibimoni",
    "submission": "// segtree with one-based indexing\n//\n// build:\n//    SegTree<int> seg;\n//    seg.build(a); // vector `a` must be one-indexed\n// \n// update:\n//    seg.update(pos, inc); //increase a[pos] to a[pos] + inc\n//    //you may want to set this\n// query:\n//    seg.query(l, r)\n\ntemplate<class T>\nstruct SegTree {\n  vector<T> st;\n  int n;\n  SegTree(int _n) : n(_n) {\n    T default_value = 0;\n    st.assign(4 * n, default_value);\n  }\n  void build(const vector<T> &a) {\n    build(a, 1, 1, n);\n  }\n  void build(const vector<T>& a, int id, int l, int r) {\n    if(l == r) {\n      st[id] = a[l];\n      return;\n    }\n    int mid = (l + r) >> 1;\n    build(a, id * 2, l, mid);\n    build(a, id * 2 | 1, mid + 1, r);\n    st[id] = st[id * 2] & st[id * 2 | 1];\n  }\n  void update(int pos, T inc) {\n    update(pos, inc, 1, 1, n);\n  }\n  void update(int pos, T inc, int id, int l, int r) {\n    if(pos < l || r < pos) {\n      return;\n    }\n    if(l == r) {\n      st[id] += inc;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    update(pos, inc, id * 2, l, mid);\n    update(pos, inc, id * 2 | 1, mid + 1, r);\n    st[id] = st[id * 2] & st[id * 2 | 1];\n  }\n  T query(int u, int v) {\n    return query(u, v, 1, 1, n);\n  }\n  T query(int u, int v, int id, int l, int r) {\n    if(v < l || r < u) {\n      return (1ll << 30) - 1;\n    }\n    if(u <= l && r <= v) {\n      return st[id];\n    }\n    int mid = (l + r) >> 1;\n    return query(u, v, id * 2, l, mid) & query(u, v, id * 2 | 1, mid + 1, r);\n  }\n};\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& a, int k) {\n        long long ans = 0, n = a.size();\n        a.insert(a.begin(), 0);\n        SegTree<int> st(n);\n        st.build(a);\n        for (int i = 1; i <= n; i++) {\n            int l = 1, r = i;\n            int br = -1;\n            while (l <= r) {\n                int m = (l + r) >> 1;\n                int val = st.query(m, i);\n                // cout << \"val : \" << val << \" m i: \" << m << ' ' << i << '\\n';\n                if (val > k) {\n                    r = m - 1;\n                } else {\n                    l = m + 1;\n                    if (val == k) {\n                        if (br == -1) {\n                            br = m;\n                        } else {\n                            br = max(br, m);\n                        }\n                    }\n                }\n            }\n            l = 1;\n            r = i;\n            int bl = -1;\n            while (l <= r) {\n                int m = (l + r) >> 1;\n                int val = st.query(m, i);\n                if (val >= k) {\n                    r = m - 1;\n                    if (val == k) {\n                        if (bl == -1) {\n                            bl = m;\n                        } else {\n                            bl = min(bl, m);\n                        }\n                    }\n                } else {\n                    l = m + 1;\n                }\n            }\n            if (bl == -1 || br == -1) {\n                continue;\n            }\n            int curr = br - bl + 1;\n            // cout << \"curr: \" << curr << '\\n';\n        \n            ans += curr;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720280145",
    "subm_id": "1311778556"
}