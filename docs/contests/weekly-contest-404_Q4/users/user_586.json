{
    "username": "karthik447",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        n, m = len(edges1), len(edges2)\n        \n        def findDiameter(n, edges):\n            if n == 1: return 0\n            dic = [set() for i in range(n)]\n            for e in edges:\n                dic[e[0]].add(e[1])\n                dic[e[1]].add(e[0])\n\n            queue = deque([0])\n            visited = set([0])\n\n            u = None\n            while queue:\n                u = queue.popleft()\n                for v in dic[u]:\n                    if v not in visited:\n                        visited.add(v)\n                        queue.append(v)\n            # bfs from u\n            visited = set([u])\n            queue = deque([u])\n            d = -1\n            while queue:\n                Q = len(queue)\n                for _ in range(Q):\n                    u = queue.popleft()\n                    for v in dic[u]:\n                        if v not in visited:\n                            visited.add(v)\n                            queue.append(v)\n                d += 1\n            \n            return d\n\n\n        def findMinHeightTree(n: int, edges: List[List[int]]) -> List[int]:\n            if n == 1: return 0\n            dic = [set() for i in range(n)]\n            for e in edges:\n                dic[e[0]].add(e[1])\n                dic[e[1]].add(e[0])\n            dict = deepcopy(dic)\n\n            queue = deque()\n            for i in range(n):\n                if len(dic[i]) == 1:\n                    queue.append((i, 0))\n            \n            rem = n\n            while rem > 2:\n                idx, degree = queue.popleft()\n                rem -= 1\n                for e in dic[idx]:\n                    dic[e].remove(idx)\n                    if len(dic[e]) == 1: queue.append((e, 1+degree))\n            \n            roots = [queue[0][0], queue[1][0]] if queue[0][1] == queue[1][1] else [queue[1][0]]\n            \n            visited = set()\n            queue = deque([roots[0]])\n            visited.add(roots[0])\n            h = -1\n            while queue:\n                Q = len(queue)\n                for _ in range(Q):\n                    u = queue.popleft()\n                    for v in dict[u]:\n                        if v not in visited:\n                            visited.add(v)\n                            queue.append(v)\n                h += 1\n            return h\n\n        return max(findDiameter(n+1, edges1), findDiameter(m+1, edges2), findMinHeightTree(n+1, edges1) + findMinHeightTree(m+1, edges2) + 1)\n\n",
    "submit_ts": "1719718511",
    "subm_id": "1304419038"
}