{
    "username": "realstar",
    "submission": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int dia1 = treeDiameter(edges1);\n        int dia2 = treeDiameter(edges2);\n        //System.out.println(dia1 + \", \" + dia2);\n        return Math.max(Math.max(dia1 / 2 + dia2 / 2 + 1, dia1 - 1), dia2 - 1);\n    }\n\t\n\tprivate static int treeDiameter(int[][] edges) {\n\t\tint n = edges.length + 1;\n        if (n == 1)\n            return 0;\n\t\tList<Integer> adj[] = new List[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tadj[i] = new ArrayList();\n\t\tfor (int[] edge : edges) {\n\t\t\tadj[edge[0]].add(edge[1]);\n\t\t\tadj[edge[1]].add(edge[0]);\n\t\t}\n\t\treturn diameter(adj, n);\n\t}\n\t\n\tprivate static int x;\n\tprivate static int maxCount;\n\tprivate static void dfsUtil(int node, int count, boolean visited[], List<Integer> adj[]) {\n\t\tvisited[node] = true;\n\t\tcount++;\n\t\tList<Integer> l = adj[node];\n\t\tfor (int i: l) {\n\t\t\tif(!visited[i]) {\n\t\t\t\tif (count >= maxCount) {\n\t\t\t\t\tmaxCount = count;\n\t\t\t\t\tx = i;\n\t\t\t\t}\n\t\t\t\tdfsUtil(i, count, visited, adj);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static void dfs(int node, int n, List<Integer> adj[]) {\n\t\tboolean[] visited = new boolean[n];\n\t\tint count = 0;\n\t\t\n\t\tdfsUtil(node, count + 1, visited, adj);\n\t}\n\n\tprivate static int diameter(List<Integer> adj[], int n) {\n\t\tmaxCount = Integer.MIN_VALUE;\n\t\tdfs(0, n, adj);\n\t\tdfs(x, n, adj);\n\t\treturn maxCount;\n    }\n}",
    "submit_ts": "1719718830",
    "subm_id": "1304427136"
}