{
    "username": "MountAim",
    "submission": "struct SegmentTree\n{\n\tint n;\n\tvector<int> v,lazy,ar;\n\n\tvoid init(vector<int> a,int sz)\n\t{\n\t\tn=sz;\n\t\tar=a;\n\t\tsz=4*n+1;\n\t\tv.clear();\n\t\tlazy.clear();\n\t\tv.resize(sz,0);\n\t\tlazy.resize(sz,0);\n\t}\n\n\tvoid build(int ipos,int fpos,int pos=1)\n\t{\n\t\tif(ipos>fpos)\n\t\t\treturn ;\n\t\tif(ipos==fpos)\n\t\t\tv[pos]=ar[ipos];\n\t\telse\n\t\t{\n\t\t\tint mid=(ipos+fpos)/2;\n\t\t\tbuild(ipos,mid,pos*2);\n\t\t\tbuild(mid+1,fpos,pos*2+1);\n\t\t\tv[pos] = max(v[pos*2], v[pos*2+1]);\n\t\t}\n\t}\n\n\n\tint query(int l,int r,int ipos,int fpos,int pos=1) //<--This segtree is for sum of range\n\t{\n\t\tif(ipos>fpos)\n\t\t\treturn 0;\n\t\tif(l>r)\n\t\t\treturn 0;\n\t\tif (lazy[pos] != 0) \n\t    { \n\t        v[pos] +=(fpos-ipos+1) * lazy[pos]; \n\t        if (ipos != fpos) \n\t        {\n\t            lazy[pos*2]  += lazy[pos]; \n\t            lazy[pos*2 + 1]   += lazy[pos]; \n\t        } \n\t        lazy[pos] = 0; \n\t    } \n\t\tint mid=(ipos+fpos)/2;\n\t\tif((l==ipos)&&(r==fpos))\n\t\t\treturn v[pos];\n\t\telse\n\t\t \treturn max(query(l,min(mid,r),ipos,mid,pos*2), query(max(mid+1,l),r,mid+1,fpos,pos*2+1));\n\t}\n\n\tvoid update(int index,int val,int ipos,int fpos,int pos=1)\n\t{\n\t\tif(ipos>fpos)\n\t\t\treturn ;\n\t\tif(ipos==fpos)\n\t\t{\n\t\t\tif(ipos==index)\n\t\t\t{\n\t\t\t\tv[pos]=val;\n\t\t\t}\n\t\t}\t\n\t\telse\n\t\t{\n\t\t\tint mid=(ipos+fpos)/2;\n\t\t\tif(mid>=index)\n\t\t\t\tupdate(index,val,ipos,mid,pos*2);\n\t\t\telse\n\t\t\t\tupdate(index,val,mid+1,fpos,pos*2+1);\n\t\t\tv[pos]=max(v[pos*2], v[pos*2+1]);\n\t\t}\n\n\t}\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) \n    {\n        set < int > st;\n        set < int, greater < int >> ulta_st; \n        \n        SegmentTree stree; \n\n        int N = 1e5;\n        \n        vector < int > a(N); \n\n        stree.init(a, N); \n        stree.build(0, N - 1); \n\n        st.insert(0);\n        ulta_st.insert(0); \n        st.insert(N - 1); \n        ulta_st.insert(N - 1); \n        a[N - 1] = N - 1; \n        \n        vector<bool> ans;\n        for(auto i : queries)\n        {\n            if(i[0] == 1)\n            {\n                auto itr = ulta_st.lower_bound(i[1]);\n                a[i[1]] = i[1] - ( * itr); \n                stree.update(i[1], a[i[1]], 0, N - 1); \n               \n                auto itr2 = st.lower_bound(i[1]); \n\n                a[ * itr2] = ( * itr2) - i[1]; \n                stree.update( * itr2, a[ * itr2], 0, N - 1); \n        \n                st.insert(i[1]);\n                ulta_st.insert(i[1]);\n            }\n            else\n            {\n            \tauto itr = ulta_st.lower_bound(i[1]); \n                int mx = i[1] - ( * itr); \n           //     cout<<mx<<' ';\n                mx = max(mx, stree.query(0,  * itr, 0, N - 1)); \n                \n           //     cout<<mx<<'\\n';\n                if(mx >= i[2])\n                {\n                \tans.push_back(true); \n                }\n                else ans.push_back(false); \n            }\n        }\n        \n        return ans;\n        \n    }\n};",
    "submit_ts": 1716649912.0
}