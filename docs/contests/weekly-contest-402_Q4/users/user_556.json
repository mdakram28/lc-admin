{
    "username": "rajipthakur2002",
    "submission": "using ll=long long;\nstruct segmenttree\n{\n    ll n;\n    vector<ll> st;\n    ll identity;\n\n    ll merge(ll a, ll b)\n    {\n        return a + b;\n    }\n\n    void init(ll _n, ll identity)\n    {\n        this->n = _n;\n        st.resize(4 * n, identity);\n        this->identity = identity;\n    }\n\n    void build(ll start, ll ending, ll node, vector<ll> &v)\n    {\n        // leaf node base case\n        if (start == ending)\n        {\n            st[node] = v[start];\n            return;\n        }\n\n        ll mid = (start + ending) / 2;\n\n        // left subtree is (start,mid)\n        build(start, mid, 2 * node + 1, v);\n\n        // right subtree is (mid+1,ending)\n        build(mid + 1, ending, 2 * node + 2, v);\n\n        st[node] = merge(st[node * 2 + 1], st[node * 2 + 2]);\n    }\n\n    ll query(ll start, ll ending, ll l, ll r, ll node)\n    {\n        // non overlapping case\n        if (start > r || ending < l)\n        {\n            return identity;\n        }\n\n        // complete overlap\n        if (start >= l && ending <= r)\n        {\n            return st[node];\n        }\n\n        // partial case\n        ll mid = (start + ending) / 2;\n\n        ll q1 = query(start, mid, l, r, 2 * node + 1);\n        ll q2 = query(mid + 1, ending, l, r, 2 * node + 2);\n\n        return merge(q1, q2);\n    }\n\n    void update(ll start, ll ending, ll node, ll index, ll value)\n    {\n        // base case\n        if (start == ending)\n        {\n            st[node] = value;\n            return;\n        }\n\n        ll mid = (start + ending) / 2;\n        if (index <= mid)\n        {\n            // left subtree\n            update(start, mid, 2 * node + 1, index, value);\n        }\n        else\n        {\n            // right\n            update(mid + 1, ending, 2 * node + 2, index, value);\n        }\n\n        st[node] = merge(st[node * 2 + 1], st[node * 2 + 2]);\n    }\n\n    void build(vector<ll> &v)\n    {\n        build(0, n - 1, 0, v);\n    }\n\n    ll query(ll l, ll r)\n    {\n        return query(0, n - 1, l, r, 0);\n    }\n\n    void update(ll x, ll y)\n    {\n        update(0, n - 1, 0, x, y);\n    }\n};\n\nclass Solution\n{\npublic:\n    vector<int> countOfPeaks(vector<int> &a, vector<vector<int>> &q)\n    {\n        int tot = 0;\n        int n = a.size();\n        vector<int> b;\n        int inf = 1e9;\n        b.push_back(inf);\n        for (auto &e : a)\n            b.push_back(e);\n\n        b.push_back(inf);\n\n        a=b;\n\n        segmenttree sg;\n        sg.init(n + 1, 0);\n\n        for (int i = 1; i <= n; i++)\n        {\n            if (b[i] > b[i - 1] && b[i] > b[i + 1])\n            {\n                sg.update(i, 1);\n            }\n        }\n\n        vector<int> ans;\n\n        for (auto &e : q)\n        {\n            int t = e[0];\n            if (t == 1)\n            {\n                int l = e[1] + 2, r = e[2] + 1-1;\n                if(r>=l){\n                    ans.push_back(sg.query(l, r));\n                }else{\n                    ans.push_back(0);\n                }\n            }\n            else\n            {\n\n                int i = e[1] + 1;\n                a[i]=e[2];\n\n                if (i == 1)\n                {\n\n                    a[i] = e[2];\n\n                    if (a[i + 1] > a[i + 2] && a[i + 1] > a[i])\n                    {\n\n                        sg.update(i + 1, 1);\n                    }\n                    else\n                    {\n                        sg.update(i + 1, 0);\n                    }\n                }\n                else if (i == n)\n                {\n                   \n                    a[i] = e[2];\n\n                    if (a[i - 1] > a[i] && a[i - 1] > a[i - 2])\n                    {\n                       sg.update(i-1,1);\n                    }\n                    else\n                    {\n                        sg.update(i-1,0);\n                    }\n                }\n                else\n                {\n\n                 \n                    a[i] = e[2];\n\n                    if (a[i] > a[i + 1] && a[i] > a[i - 1])\n                    {\n                        sg.update(i,1);\n                    }\n                    else\n                    {\n                        sg.update(i,0);\n                    }\n\n                    if (a[i - 1] > a[i] && a[i - 1] > a[i - 2])\n                    {\n                        sg.update(i-1,1);\n                    }\n                    else\n                    {\n                       sg.update(i-1,0);\n                    }\n\n                    if (a[i + 1] > a[i] && a[i + 1] > a[i + 2])\n                    {\n                        sg.update(i+1,1);\n                    }\n                    else\n                    {\n                       sg.update(i+1,0);\n                    }\n                }\n            }\n        }\n\n        return ans;\n    }\n};\n",
    "submit_ts": "1718507895",
    "subm_id": "1289665665"
}