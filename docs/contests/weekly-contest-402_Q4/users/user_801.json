{
    "username": "e7x0pbWqIm",
    "submission": "typedef long long ll;\nstruct seg_tree\n{\n    vector<ll> seg;\n \npublic:\n    seg_tree(int n)\n    {\n        seg.resize(4 * n + 1, 0);\n    }\n \n    void build(int ind, int low, int high, vector<ll> &arr)\n    {\n        if (low == high)\n        {\n            seg[ind] = arr[low];\n            return;\n        }\n \n        int mid = (low + high) / 2;\n        build(2 * ind + 1, low, mid, arr);\n        build(2 * ind + 2, mid + 1, high, arr);\n \n        seg[ind] = (seg[2 * ind + 1] + seg[2 * ind + 2]);\n    }\n \n    void update(int ind, int low, int high, int i, ll val)\n    {\n        if (low == high)\n        {\n            seg[ind] = val;\n            return;\n        }\n \n        int mid = (low + high) / 2;\n \n        if (i <= mid)\n            update(2 * ind + 1, low, mid, i, val);\n        else\n            update(2 * ind + 2, mid + 1, high, i, val);\n \n        seg[ind] = seg[2 * ind + 1] +  seg[2 * ind + 2];\n    }\n \n    ll query(int ind, int low, int high, int l, int r)\n    {\n        if (r < low || high < l)\n            return 0;\n \n        if (low >= l && high <= r)\n            return seg[ind];\n \n        int mid = (low + high) / 2;\n \n        ll left = query(2 * ind + 1, low, mid, l, r);\n        ll right = query(2 * ind + 2, mid + 1, high, l, r);\n \n        return (left + right);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        \n        vector<ll>peak(n,0);\n        for(int i = 1;i<n - 1;i++)peak[i] = (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]);\n        \n        seg_tree st(n);\n        st.build(0,0,n-1,peak);\n        \n        vector<int>ans;\n        \n        for(auto &vec : queries){\n            if(vec[0] == 1){\n                int l = vec[1],r = vec[2];\n                if(r - l + 1 < 3){\n                    ans.push_back(0); continue;\n                }\n                int res = st.query(0,0,n-1,vec[1],vec[2]);\n                res -= st.query(0,0,n-1,l,l);\n                res -= st.query(0,0,n-1,r,r);\n                ans.push_back(res);\n            }else{\n                int ind = vec[1],val = vec[2];\n                nums[ind] = val;\n                if(ind > 0 &&  ind < n - 1)st.update(0,0,n-1,ind,(nums[ind] > nums[ind - 1] && nums[ind] > nums[ind + 1]));\n                if(ind - 2 >= 0)st.update(0,0,n-1,ind - 1,(nums[ind - 1] > nums[ind - 2] && nums[ind - 1] > nums[ind]));\n                if(ind + 2 < n)st.update(0,0,n-1,ind + 1,(nums[ind + 1] > nums[ind + 2] && nums[ind + 1] > nums[ind]));\n            }\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": 1718506441.0
}