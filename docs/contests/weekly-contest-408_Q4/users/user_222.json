{
    "username": "mohdquamartyagi",
    "submission": "\nclass Solution {\npublic:\n    int bfs(vector<vector<int>> &graph_dsa, int alpha, int beta, int gamma, int delta) {\n        queue<int> phi;\n        vector<int> omega(delta + 4, 0);\n        phi.push(alpha);\n        omega[alpha] = 1;\n        \n        while (!phi.empty()) {\n            int sigma = phi.front();\n            phi.pop();\n            for (int tau : graph_dsa[sigma]) {\n                if (!omega[tau]) {\n                    phi.push(tau);\n                    omega[tau] = 1;\n                }\n            }\n        }\n        return omega[beta] || omega[gamma];\n    }\n    \n    bool canReachCorner(int epsilon, int zeta, vector<vector<int>>& theta) {\n        vector<pair<pair<int, int>, int>> iota(theta.size());\n        vector<vector<int>> kappa(theta.size() + 4);\n        int lambda = theta.size();\n        \n        for (int mu = 0; mu < lambda; ++mu) {\n            iota[mu].first.first = theta[mu][0];\n            iota[mu].first.second = theta[mu][1];\n            iota[mu].second = theta[mu][2];\n        }\n        \n        for (int nu = 0; nu < lambda; ++nu) {\n            if (iota[nu].first.first <= iota[nu].second) {\n                kappa[lambda].push_back(nu);\n                kappa[nu].push_back(lambda);\n            }\n            if (epsilon - iota[nu].first.first <= iota[nu].second) {\n                kappa[lambda + 2].push_back(nu);\n                kappa[nu].push_back(lambda + 2);\n            }\n            if (iota[nu].first.second <= iota[nu].second) {\n                kappa[lambda + 1].push_back(nu);\n                kappa[nu].push_back(lambda + 1);\n            }\n            if (zeta - iota[nu].first.second <= iota[nu].second) {\n                kappa[lambda + 3].push_back(nu);\n                kappa[nu].push_back(lambda + 3);\n            }\n            for (int xi = nu + 1; xi < lambda; ++xi) {\n                double pi = sqrt(pow(iota[nu].first.first - iota[xi].first.first, 2) +\n                                 pow(iota[nu].first.second - iota[xi].first.second, 2));\n                int rho = iota[nu].second + iota[xi].second;\n                if (rho >= pi) {\n                    kappa[nu].push_back(xi);\n                    kappa[xi].push_back(nu);\n                }\n            }\n        }\n        \n        int sigma_max = 0;\n        sigma_max = max(sigma_max, bfs(kappa, lambda, lambda + 1, lambda + 2, lambda + 4)); // Check for bottom-left corner\n        sigma_max = max(sigma_max, bfs(kappa, lambda + 3, lambda + 2, lambda + 1, lambda + 4)); // Check for top-right corner\n\n        if (sigma_max) {\n            return false;\n        }\n        return true;\n    }\n};",
    "submit_ts": "1722136595",
    "subm_id": "1335739327"
}