{
    "username": "some_idiot",
    "submission": "/*\nlib:        https://github.com/old-yan/CP-template\nauthor:     oldyan\n*/\n#include <algorithm>\n#include <bit>\n#include <cassert>\n#include <cstdint>\n#include <cstring>\n#include <numeric>\n#include <vector>\n#ifndef __OY_INFOQUEUE__\n#define __OY_INFOQUEUE__\nnamespace OY {\n    namespace INFOQUEUE {\n        using size_type = uint32_t;\n        struct Ignore {};\n        template <typename Tp, typename Operation>\n        struct InfoPair {\n            using sum_type = Tp;\n            Tp m_val, m_sum;\n        };\n        template <typename Tp>\n        struct InfoPair<Tp, Ignore> {\n            using sum_type = void;\n            Tp m_val;\n        };\n        template <typename Tp>\n        struct VectorAdapter : std::vector<Tp> {\n            static constexpr bool is_special = false;\n            const Tp &top() const { return std::vector<Tp>::back(); }\n        };\n        template <typename Tp, size_t N>\n        struct StaticAdapter {\n            static Tp s_buf[N];\n            struct type1 {\n                static constexpr bool is_special = true;\n                Tp *m_l = s_buf, *m_r = s_buf;\n                bool empty() const { return m_l == m_r; }\n                size_type size() const { return m_r - m_l; }\n                void pop_back() { m_l++; }\n                const Tp &top() const { return *m_l; }\n                Tp &operator[](size_type i) const { return *(m_r - i - 1); }\n            };\n            struct type2 {\n                static constexpr bool is_special = true;\n                Tp *m_l = s_buf, *m_r = s_buf;\n                bool empty() const { return m_l == m_r; }\n                size_type size() const { return m_r - m_l; }\n                void push_back(const Tp &x) { *m_r++ = x; }\n                const Tp &top() const { return *(m_r - 1); }\n                const Tp &operator[](size_type i) const { return m_l[i]; }\n            };\n        };\n        template <typename Tp, size_t N>\n        Tp StaticAdapter<Tp, N>::s_buf[N];\n        template <typename Tp, typename Operation = Ignore, typename Adapter1 = VectorAdapter<InfoPair<Tp, Operation>>, typename Adapter2 = VectorAdapter<InfoPair<Tp, Operation>>>\n        struct Queue {\n            static constexpr bool is_ignore = std::is_same<Operation, Ignore>::value;\n            mutable Adapter1 m_left;\n            mutable Adapter2 m_right;\n            Operation m_op;\n            void _trans() const {\n                if constexpr (Adapter1::is_special) {\n                    m_left.m_l = m_right.m_l, m_left.m_r = m_right.m_l = m_right.m_r;\n                    if constexpr (!is_ignore) {\n                        m_left[0].m_sum = m_left[0].m_val;\n                        for (size_type i = 1, sz = m_left.size(); i != sz; i++) m_left[i].m_sum = m_op(m_left[i].m_val, m_left[i - 1].m_sum);\n                    }\n                } else {\n                    if constexpr (is_ignore)\n                        m_left.push_back({m_right.top().m_val});\n                    else\n                        m_left.push_back({m_right.top().m_val, m_right.top().m_val});\n                    m_right.pop_back();\n                    size_type sz = m_right.size();\n                    while (sz--) {\n                        if constexpr (is_ignore)\n                            m_left.push_back({m_right.top().m_val});\n                        else\n                            m_left.push_back({m_right.top().m_val, m_op(m_right.top().m_val, m_left.top().m_sum)});\n                        m_right.pop_back();\n                    }\n                }\n            }\n            Queue(Operation op = Operation()) : m_op(op) {}\n            void push(const Tp &x) {\n                if constexpr (is_ignore)\n                    m_right.push_back({x});\n                else if (m_right.empty())\n                    m_right.push_back({x, x});\n                else\n                    m_right.push_back({x, m_op(m_right.top().m_sum, x)});\n            }\n            void pop() {\n                if (m_left.empty()) _trans();\n                m_left.pop_back();\n            }\n            const Tp &front() const {\n                if (m_left.empty()) _trans();\n                return m_left.top().m_val;\n            }\n            bool empty() const { return m_left.empty() && m_right.empty(); }\n            size_type size() const { return m_left.size() + m_right.size(); }\n            typename InfoPair<Tp, Operation>::sum_type query_all() const {\n                static_assert(!is_ignore, \"Operation Mustn't Be Ignore\");\n                if (m_left.empty())\n                    return m_right.top().m_sum;\n                else if (m_right.empty())\n                    return m_left.top().m_sum;\n                else\n                    return m_op(m_left.top().m_sum, m_right.top().m_sum);\n            }\n            const Tp &operator[](size_type i) const { return i < m_left.size() ? m_left[m_left.size() - 1 - i].m_val : m_right[i - m_left.size()].m_val; }\n        };\n    }\n    template <typename Tp, typename Operation, size_t N>\n    using GlobalInfoQueue = INFOQUEUE::Queue<Tp, Operation, typename INFOQUEUE::StaticAdapter<INFOQUEUE::InfoPair<Tp, Operation>, N>::type1, typename INFOQUEUE::StaticAdapter<INFOQUEUE::InfoPair<Tp, Operation>, N>::type2>;\n    template <typename Tp, typename Operation = INFOQUEUE::Ignore>\n    using VectorInfoQueue = INFOQUEUE::Queue<Tp, Operation, INFOQUEUE::VectorAdapter<INFOQUEUE::InfoPair<Tp, Operation>>, INFOQUEUE::VectorAdapter<INFOQUEUE::InfoPair<Tp, Operation>>>;\n}\n#endif\n/*\nlib code is above\ntemp code is below\n*/\n#ifdef OY_LOCAL\nusing namespace std;\n#endif\n#define FUNCNAME maximumValueSum\nconstexpr int64_t inf = 0x3f3f3f3f3f3f3f3f;\nstruct Top2 {\n    pair<int64_t, int> val[2];\n    Top2() = default;\n    Top2(int64_t v, int row) {\n        val[0] = {v, row};\n        val[1] = {-inf, -1};\n    }\n    Top2 operator+(const Top2 &rhs) const {\n        Top2 res;\n        if (val[0] > rhs.val[0]) {\n            res.val[0] = val[0], res.val[1] = max(val[1], rhs.val[0]);\n        } else {\n            res.val[0] = rhs.val[0], res.val[1] = max(rhs.val[1], val[0]);\n        }\n        return res;\n    }\n};\nstatic constexpr int N = 500;\nint lfix[N][N], rfix[N][N];\nTop2 L[N][N], R[N][N];\nclass Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>> &a) {\n        int m = a.size(), n = a[0].size();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                lfix[i][j] = j == 0 ? a[i][j] : max(lfix[i][j - 1], a[i][j]);\n            }\n            for (int j = n - 1; j >= 0; j--) {\n                rfix[i][j] = j == n - 1 ? a[i][j] : max(rfix[i][j + 1], a[i][j]);\n            }\n        }\n        for (int j = 1; j + 1 < n; j++) {\n            OY::GlobalInfoQueue<Top2, plus<>, 2000> Q;\n            for (int i = 0; i < m; i++) Q.push({lfix[i][j - 1], i});\n            for (int i = 0; i < m; i++) {\n                Q.pop();\n                L[i][j] = Q.query_all();\n                Q.push({lfix[i][j - 1], i});\n            }\n        }\n        for (int j = 1; j + 1 < n; j++) {\n            OY::GlobalInfoQueue<Top2, plus<>, 2000> Q;\n            for (int i = 0; i < m; i++) Q.push({rfix[i][j + 1], i});\n            for (int i = 0; i < m; i++) {\n                Q.pop();\n                R[i][j] = Q.query_all();\n                Q.push({rfix[i][j + 1], i});\n            }\n        }\n        int64_t ans = -inf;\n        for (int i = 0; i < m; i++) {\n            for (int j = 1; j + 1 < n; j++) {\n                if (L[i][j].val[0].second != R[i][j].val[0].second)\n                    ans = max(ans, a[i][j] + L[i][j].val[0].first + R[i][j].val[0].first);\n                if (L[i][j].val[0].second != R[i][j].val[1].second)\n                    ans = max(ans, a[i][j] + L[i][j].val[0].first + R[i][j].val[1].first);\n                if (L[i][j].val[1].second != R[i][j].val[0].second)\n                    ans = max(ans, a[i][j] + L[i][j].val[1].first + R[i][j].val[0].first);\n            }\n        }\n        return ans;\n    }\n};\n#ifdef OY_LOCAL\nint main() {\n    REGISTER_CONSTRUCTOR_SOLUTION;\n    REGISTER_MEMBERFUNCTION_SOLUTION(FUNCNAME);\n    while (true) {\n        executor.constructSolution();\n        executor.executeSolution();\n    }\n}\n#endif\n",
    "submit_ts": "1723906516",
    "subm_id": "556320149"
}