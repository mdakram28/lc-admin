{
    "username": "fmota",
    "submission": "class Solution {\npublic:\n    int minimumSum(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        auto g = grid;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < m; j++){\n                if(i) g[i][j] += g[i - 1][j];\n                if(j) g[i][j] += g[i][j - 1];\n                if(i && j) g[i][j] -= g[i - 1][j - 1];\n            }\n        }\n        auto get = [&](int a, int b, int c, int d){\n            int res = g[c][d];\n            if(a) res -= g[a - 1][d];\n            if(b) res -= g[c][b - 1];\n            if(a && b) res += g[a - 1][b - 1];\n            return res;\n        };\n        struct rect {\n            int a, b, c, d;  \n        };\n        int res = n * m;\n        auto get_x_axis = [&](rect r, int x){\n            if(r.a <= x && x <= r.c){\n                return get(x, r.b, x, r.d);\n            }  \n            return 0;\n        };\n        auto get_y_axis = [&](rect r, int y){\n            if(r.b <= y && y <= r.d){\n                return get(r.a, y, r.c, y);\n            }  \n            return 0;\n        };\n        auto intersect = [&](rect a, rect b){\n            if(a.c < b.a) return false;\n            if(b.c < a.a) return false;\n            if(a.d < b.b) return false;\n            if(b.d < a.b) return false;\n            return true;\n        };\n        vector<int> in_row(n), in_col(m);\n        for(int i = 0; i < n; i++){\n            in_row[i] = get(i, 0, i, m - 1);\n        }\n        for(int i = 0; i < m; i++){\n            in_col[i] = get(0, i, n - 1, i);\n        }\n        auto area = [&](rect r){\n            return (r.c - r.a + 1) * (r.d - r.b + 1);  \n        };\n        auto is_inside = [&](rect r, int x, int y){\n            return r.a <= x && x <= r.c && r.b <= y && y <= r.d;  \n        };\n        auto is_covered = [&](vector<rect> pick, int x, int y){\n            bool is = false;\n            if(pick.size() > 0) is |= is_inside(pick[0], x, y);\n            if(pick.size() > 1) is |= is_inside(pick[1], x, y);\n            return is;\n        };\n        auto print = [&](rect r){\n            cout << r.a << ' ' << r.b << ' ' << r.c << ' ' << r.d << \" = \" << area(r) << endl;  \n        };\n        function<void(vector<rect>&, int)> brute = [&](vector<rect> &pick, int ptr){\n            int at = 0;\n            for(auto r : pick) at += area(r);\n            if(at > res) return;\n            if(pick.size() == 2){\n                int min_x = n, min_y = m, max_x = -1, max_y = -1;\n                for(int i = ptr; i < n; i++){\n                    if(get_x_axis(pick[0], i) + get_x_axis(pick[1], i) != in_row[i]){\n                        min_x = i;\n                        max_x = i;\n                        break;\n                    }\n                }\n                for(int i = n - 1; i > min_x; i--){\n                    if(get_x_axis(pick[0], i) + get_x_axis(pick[1], i) != in_row[i]){\n                        max_x = i;\n                        break;\n                    }\n                }\n                for(int i = 0; i < m; i++){\n                    if(get_y_axis(pick[0], i) + get_y_axis(pick[1], i) != in_col[i]){\n                        min_y = i;\n                        max_y = i;\n                        break;\n                    }\n                }\n                for(int i = m - 1; i > min_y; i--){\n                    if(get_y_axis(pick[0], i) + get_y_axis(pick[1], i) != in_col[i]){\n                        max_y = i;\n                        break;\n                    }\n                }\n                if(max_x == -1){\n                    return;\n                }\n                rect cur = (rect){min_x, min_y, max_x, max_y};\n                if(intersect(pick[0], cur) || intersect(pick[1], cur)) {\n                    return;\n                }\n                int S = area(cur) + area(pick[0]) + area(pick[1]);\n                // print(pick[0]);\n                // print(pick[1]);\n                // print(cur);\n                res = min(res, S);\n                return;\n            }\n            while(ptr < n){\n                int t = 0;\n                if(pick.size()) t += get_x_axis(pick[0], ptr);\n                if(t == in_row[ptr]){\n                    ptr++;\n                } else {\n                    break;\n                }\n            }\n            if(ptr == n){\n                int S = 0;\n                for(auto r : pick) S += area(r);\n                S += (3 - pick.size());\n                res = min(res, S);\n                return;\n            }\n            int y = 0;\n            while(!grid[ptr][y] || is_covered(pick, ptr, y)) y++;\n            for(int nx = ptr; nx < n; nx++){\n                rect r = (rect){ptr, y, nx, y};\n                for(int ly = y; ly >= 0; ly--){\n                    r.b = ly;\n                    r.d = y;\n                    if(pick.size() && intersect(pick[0], r)) break;\n                    int lst = -1;\n                    for(int hy = y; hy < m; hy++){\n                        r.d = hy;\n                        if(pick.size() && intersect(pick[0], r)) break;\n                        int got = get(ptr, ly, nx, hy);\n                        if(got > lst){\n                            lst = got;\n                            pick.push_back(r);\n                            brute(pick, ptr);\n                            pick.pop_back();\n                        }\n                    }\n                }\n            }\n        };\n        vector<rect> z;\n        brute(z, 0);\n        // cout << res << endl;\n        return res;\n    }\n};",
    "submit_ts": 1719113486.0
}