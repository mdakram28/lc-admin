{
    "username": "Silken",
    "submission": "class Solution {\npublic:\n    int minimumDistance(vector<vector<int>>& _points) {\n        \n        vector<pair<int, int>> points;\n        for(vector<int>& point : _points) {\n            points.emplace_back(point[0], point[1]);\n        }\n        \n        sort(begin(points), end(points));\n        \n        vector<pair<int, int>> plus, minus;\n        int n = points.size();\n        for(int i=0; i < n; i++) {\n            auto& point = points[i];\n            plus.emplace_back(point.first + point.second, i);\n            minus.emplace_back(point.first - point.second, i);\n        }\n        \n        sort(begin(plus), end(plus));\n        sort(begin(minus), end(minus));\n        \n        auto try_erase = [&](int index) {\n            int smallPlus = INT_MAX, largePlus = INT_MIN, smallMinus = INT_MAX, largeMinus = INT_MIN;\n            for(auto& a : plus) {\n                if(a.second != index) {\n                    smallPlus = min(smallPlus, a.first);\n                    largePlus = max(largePlus, a.first);\n                }\n            }\n            for(auto& a : minus) {\n                if(a.second != index) {\n                    smallMinus = min(smallMinus, a.first);\n                    largeMinus = max(largeMinus, a.first);\n                }\n            }\n            \n            return max(largePlus - smallPlus, largeMinus - smallMinus);\n        };\n        \n        return min({try_erase(plus[0].second), try_erase(plus[n-1].second), try_erase(minus[0].second), try_erase(minus[n-1].second)});\n    }\n};"
}