{
    "username": "abz-codes",
    "submission": "class Trie {\n\n    struct TrieNode {\n        int nxt[26];\n        bool endW = false;\n        int cost = 1e6;\n    };\n    public:\n        vector<TrieNode> nodes;\n\n        Trie() {\n            nodes = vector<TrieNode>(1);\n        }\n\n        void insert(const string& word, int cost) {\n            int curr = 0;\n\n            for (const auto& c : word) {\n                if (nodes[curr].nxt[c - sub] == 0) { \n                   nodes[curr].nxt[c - sub] = nodes.size();\n                    nodes.emplace_back();\n                }\n                curr = nodes[curr].nxt[c - sub];\n            }\n            nodes[curr].endW = true;\n            nodes[curr].cost = min(nodes[curr].cost,cost);\n         }\n\t\t\t\t\n\t\t//set \"curr\" if you want to continue traversing from some node\n        int get(const string& word, int curr = 0) const {\n\t\t\t\t\t\tassert(curr < static_cast<int>(nodes.size()) && curr >= 0);\n            for (const auto& c : word) {\n                if (nodes[curr].nxt[c - sub] == 0) return -1;\n                curr = nodes[curr].nxt[c - sub];\n            }\n            return curr;\n        }\n\t\t\t\tint get(const char& c, int curr = 0) const {\n\t\t\t\t\t\tassert(curr < static_cast<int>(nodes.size()) && curr >= 0);\n\t\t\t\t\t\tif (nodes[curr].nxt[c - sub] == 0) return -1;\n\t\t\t\t\t\tcurr = nodes[curr].nxt[c - sub];            \n            return curr;\n        }\n\t\t\t\tvoid clear() {\n\t\t\t\t\tnodes.clear();\n\t\t\t\t\tnodes.emplace_back();\n\t\t\t\t}\n\t\t\t\t\n    private:\n        static constexpr char sub = 'a';\n};\n\nclass Solution {\npublic:\n    long long dp[50005];\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int n = words.size();\n        Trie trie{};\n        for (int i = 0; i < n; i++) {\n            trie.insert(words[i], costs[i]);\n        }\n        int m = target.size();\n        for (int i = 0; i < m; i++) {\n            dp[i+1] = 1e11;\n        }\n        dp[0] = 0;\n        queue<int> tracks; tracks.push(1);\n        while(!tracks.empty()) {\n            auto c = tracks.front(); tracks.pop();\n            int curr = 0;\n            //cout << c << '\\n';\n            for (int v = c-1; v < m; v++) {\n                curr = trie.get(target[v], curr);\n                if (curr == -1) break;\n                if (trie.nodes[curr].endW) {\n                    if (trie.nodes[curr].cost + dp[c-1] < dp[v+1]) {\n                        dp[v+1] = trie.nodes[curr].cost + dp[c-1];\n                        //cout << \"here: \" << v << \", dp[v+1] == \" << dp[v+1] << '\\n';\n                        tracks.push(v+2);\n                    }\n                }\n            }\n        }\n        if (dp[m] == 1e11) {\n            return -1;\n        }\n        return dp[m];\n    }\n};",
    "submit_ts": "1720321339",
    "subm_id": "1312320199"
}