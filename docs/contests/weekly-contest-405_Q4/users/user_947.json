{
    "username": "Akash_S29",
    "submission": "class Solution {\npublic:\n    struct TrieNode {\n        unordered_map<char, TrieNode*> children;\n        vector<int> wordIdxs;\n        vector<int> costs;\n    };\n\n    class Trie {\n    public:\n        TrieNode* root;\n\n        Trie() {\n            root = new TrieNode();\n        }\n\n        void insert(const string& word, int wordIdx, int cost) {\n            TrieNode* currentNode = root;\n            for (char character : word) {\n                if (!currentNode->children.count(character))\n                    currentNode->children[character] = new TrieNode();\n                currentNode = currentNode->children[character];\n            }\n            currentNode->wordIdxs.push_back(wordIdx);\n            currentNode->costs.push_back(cost);\n        }\n    };\n\n    int minimumCost(const string& targetString, const vector<string>& wordList, const vector<int>& costs) {\n        int targetLength = targetString.size();\n        const int inf = 1e9;\n        vector<int> minCost(targetLength + 1, inf);\n        minCost[0] = 0;\n\n        Trie trie = buildTrie(wordList, costs);\n\n        for (int startIndex = 0; startIndex < targetLength; ++startIndex) {\n            if (minCost[startIndex] == inf) continue;\n            updateMinCost(targetString, startIndex, minCost, trie, wordList);\n        }\n        \n        if(minCost[targetLength] == inf) return -1;\n        \n        return minCost[targetLength];\n    }\n\nprivate:\n    Trie buildTrie(const vector<string>& wordList, const vector<int>& costs) {\n        Trie trie;\n        for (int i = 0; i < wordList.size(); ++i) {\n            trie.insert(wordList[i], i, costs[i]);\n        }\n        return trie;\n    }\n\n    void updateMinCost(const string& targetString, int startIndex, vector<int>& minCost, Trie& trie, const vector<string>& wordList) {\n        TrieNode* currentNode = trie.root;\n        for (int currentIndex = startIndex; currentIndex < targetString.size(); ++currentIndex) {\n            if (!currentNode->children.count(targetString[currentIndex])) break;\n            currentNode = currentNode->children[targetString[currentIndex]];\n\n            for (int k = 0; k < currentNode->wordIdxs.size(); ++k) {\n                int wordIdx = currentNode->wordIdxs[k];\n                int cost = currentNode->costs[k];\n                int wordLength = wordList[wordIdx].size();\n\n                if (startIndex + wordLength <= targetString.size()) {\n                    minCost[startIndex + wordLength] = min(minCost[startIndex + wordLength], minCost[startIndex] + cost);\n                }\n            }\n        }\n    }\n};",
    "submit_ts": "1720322531",
    "subm_id": "1312352437"
}