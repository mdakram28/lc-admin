{
    "username": "liouzhou_101",
    "submission": "#ifndef MO_H_\n#define MO_H_\n\n#include <cassert>\n#include <algorithm>\n#include <vector>\n\nnamespace algorithm\n{\n\t// Mo's SQRT decomposition algorithm\n\t// The implementation is based on the order of Hilbert curve,\n\t// which is more efficient than other implementations.\n\tclass Mo\n\t{\n\tprivate:\n\t\tint n, logn;\n\t\tstruct Query\n\t\t{\n\t\t\tint left, right;\n\t\t\tint id;\n\t\t\tint64_t key;\n\t\t\tbool operator < (const Query& rhs) const\n\t\t\t{\n\t\t\t\treturn key < rhs.key;\n\t\t\t}\n\t\t};\n\t\tstd::vector<Query> queries;\n\t\t// HilbertOrder(x, y) denotes the order of (x, y) in the Hilbert curve. \n\t\t// See https://en.wikipedia.org/wiki/Hilbert_curve.\n\t\t// The implementation refers to \n\t\t// https://codeforces.com/blog/entry/61203?#comment-522213.\n\t\tint64_t HilbertOrder(int x, int y)\n\t\t{\n\t\t\tint64_t d = 0;\n\t\t\tfor (int s = 1 << (logn - 1); s; s >>= 1)\n\t\t\t{\n\t\t\t\tbool rx = x & s, ry = y & s;\n\t\t\t\td = d << 2 | rx * 3 ^ ry;\n\t\t\t\tif (!ry)\n\t\t\t\t{\n\t\t\t\t\tif (rx)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = (1 << logn) - x;\n\t\t\t\t\t\ty = (1 << logn) - y;\n\t\t\t\t\t}\n\t\t\t\t\tstd::swap(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn d;\n\t\t}\n\tpublic:\n\t\texplicit Mo(int n) : n(n)\n\t\t{\n\t\t\tfor (logn = 0; 1 << logn <= n; logn++);\n\t\t}\n\t\t// Query [left, right)\n\t\tvoid AddQuery(int left, int right)\n\t\t{\n\t\t\tassert(0 <= left && left < right && right <= n);\n\t\t\tqueries.push_back({ left, right, (int)queries.size(), HilbertOrder(left, right) });\n\t\t}\n\t\tvoid AddQuery(int left, int right, int id)\n\t\t{\n\t\t\tassert(0 <= left && left < right&& right <= n);\n\t\t\tqueries.push_back({ left, right, id, HilbertOrder(left, right) });\n\t\t}\n\t\ttemplate<typename Init, typename Answer, typename AddLeft, typename AddRight, typename DelLeft, typename DelRight>\n\t\tvoid Solve(const Init& init, const Answer& answer, const AddLeft& add_left, const AddRight& add_right, const DelLeft& del_left, const DelRight& del_right)\n\t\t{\n\t\t\tstd::sort(queries.begin(), queries.end());\n\t\t\tint left = 0, right = 0;\n\t\t\tinit(left, right);\n\t\t\tfor (const auto& [x, y, id, key] : queries)\n\t\t\t{\n\t\t\t\twhile (left > x)\n\t\t\t\t\tadd_left(--left, right);\n\t\t\t\twhile (right < y)\n\t\t\t\t\tadd_right(left, ++right);\n\t\t\t\twhile (left < x)\n\t\t\t\t\tdel_left(left++, right);\n\t\t\t\twhile (right > y)\n\t\t\t\t\tdel_right(left, right--);\n\t\t\t\tanswer(x, y, id);\n\t\t\t}\n\t\t}\n\t};\n}\n\n#endif\n\n\nnamespace algorithm {}\nnamespace data_structure {}\n\nusing namespace algorithm;\nusing namespace data_structure;\n\nclass Solution {\npublic:\n\tvector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n\t\tint n = s.size();\n\t\tvector<vector<int>> v(2);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tv[s[i] - '0'].push_back(i);\n\t\t\n\t\tvector pre(n, vector(2, -1));\n\t\tvector nxt(n, vector(2, n));\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (int d = 0; d < 2; ++d)\n\t\t\t{\n\t\t\t\tint j = lower_bound(v[d].begin(), v[d].end(), i) - v[d].begin() + k;\n\t\t\t\tif (j < v[d].size()) nxt[i][d] = v[d][j];\n\t\t\t}\n\t\t\tfor (int d = 0; d < 2; ++d)\n\t\t\t{\n\t\t\t\tint j = upper_bound(v[d].begin(), v[d].end(), i) - v[d].begin() - 1 - k;\n\t\t\t\tif (j >= 0) pre[i][d] = v[d][j];\n\t\t\t}\n\t\t}\n\n\t\tMo mo(n + 1);\n\t\tint m = queries.size();\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint x = queries[i][0], y = queries[i][1];\n\t\t\ty += 1;\n\t\t\tmo.AddQuery(x, y);\n\t\t}\n\n\t\tlong long cur = 0;\n\t\tvector<long long> res(m);\n\n\t\tauto init = [&](int& left, int& right)\n\t\t{\n\t\t\tleft = right = 0;\n\t\t\tcur = 0;\n\t\t};\n\t\tauto answer = [&](int x, int y, int id)\n\t\t{\n\t\t\tres[id] = cur;\n\t\t};\n\t\tauto add_left = [&](int x, int y)\n\t\t{\n\t\t\tcur += min(max(nxt[x][0], nxt[x][1]), y) - x;\n\t\t};\n\t\tauto add_right = [&](int x, int y)\n\t\t{\n\t\t\tcur += y - 1 - max(min(pre[y - 1][0], pre[y - 1][1]), x - 1);\n\t\t};\n\t\tauto del_left = [&](int x, int y)\n\t\t{\n\t\t\tcur -= min(max(nxt[x][0], nxt[x][1]), y) - x;\n\t\t};\n\t\tauto del_right = [&](int x, int y)\n\t\t{\n\t\t\tcur -= y - 1 - max(min(pre[y - 1][0], pre[y - 1][1]), x - 1);\n\t\t};\n\t\tmo.Solve(init, answer, add_left, add_right, del_left, del_right);\n\n\t\treturn res;\n\t}\n};",
    "submit_ts": "1723951260",
    "subm_id": "556404264"
}