{
    "username": "Technical_Guruji",
    "submission": "#include<bits/stdc++.h>\n#include <queue>\n#include <algorithm>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"inline\")\n\n\n#define ff              first\n#define ss              second\n#define all(x)          begin(x), end(x)\n#define pb              push_back\n#define MOD             1000000007\n#define mod             1000000007\n#define INF             1e18\n#define rev(x)          reverse(all(x));\n#define nextP(v)        next_permutation(all(v))\n#define Vmax(x)         (*max_element(all(x)))\n#define Vmin(x)         (*min_element(all(x)))\n#define Vsum(x)         accumulate(all(x),0ll)\n#define lowB(v,x)       (lower_bound(all(v),x)-v.begin())\n#define upB(v,x)        (upper_bound(all(v),x)-v.begin())\n#define cntB(x)         (__builtin_popcountll(x))\n#define cntC(s,x)       ll(count(all(s),x))\n//#define mp              make_pair\n#define nl              cout << \"\\n\";\n#define Yes             cout << \"Yes\\n\"\n#define No              cout << \"No\\n\"\n#define prs(n)          fixed << setprecision(n)\n#define dbg(x)          cout << #x << \" = \" << x << endl;\n#define inpt(v)         For(sz(v)) cin >> v[i];\n#define prt(v)          {for(auto &x:v) cout << x << ' '; nl}\n#define BIG             200005\n#define For(n)          for (ll i = 0; i < n ;i++)\n#define ForR(n)         for (ll i = n; i >= 0; i--)\n#define Forj(n)         for (ll j = 0; j < n; j++)\n#define For1(n)         for (ll i = 1; i < n; ++i)\n#define For2(n)         for (ll i = 2; i < n; i++)\n#define Forl(x,y,z)     for (ll x = y; x < z; x++)\n#define go(i,n)         for (ll i = 0; i <=n; ++i)\n#define rep(i,a,n)      for (ll i = a; i <=n; i++)\n#define loop(j, i, n)   for (ll j = i; j < n; j++)\n\nusing namespace std;\n\n\n\n\ntemplate <class T> using v = vector<T>;\nusing lli = long long int;\nusing ll = long long;\nusing ld = long double;\nusing vl = vector<long long>;\nusing vs  = vector<string>;\nusing vpl = vector<pair<ll,ll>>;\nusing sll = set<ll>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<ld, ld>;\nusing mll = map<ll,ll>;\nusing vvl = vector<vector<ll>>;\nusing vpll = vector<pll>;\n\nconst int alphabet = 'z' - 'a' + 1;\n\n\n\nll lcm(ll a, ll b) { return (a / __gcd(a, b)) * b; }\n\n\nll power(ll a,ll b) {ll r=1; while(b) {if(b&1) r=(r*a)%MOD; a=(a*a)%MOD; b/=2;} return r;}\n\n// we have to add condition that number position where a[i]=1 we have to consider position not number 1\nvl sieve(ll n) {vl a(n+1,1),v; a[0]=a[1]=0; Forl(i,2,n+1) if(a[i]) {v.push_back(i); for(ll j=2*i; j <=n; j+=i) a[j]=0;} return a;}\n\nvl divsr(ll n) {vl a(n+1,1); For(n+1) a[i]=i; Forl(i,2,n+1) if(a[i]==i) {for(ll j=2*i; j<=n; j+=i) a[j]=i;} return a;}\n\n// factorial 0 to n\nvl factorial(ll n) {vl v(n+1,1); Forl(i,2,n+1) v[i] = (v[i-1]*i)%MOD; return v;}\n\n// template function added\n\ntemplate <typename T> bool chkMax(T &x, T y) { return (y > x) ? x = y, 1 : 0; }\n\ntemplate <typename T> bool chkMin(T &x, T y) { return (y < x) ? x = y, 1 : 0; }\n\n// put the class functiion insdie it\n\nclass Solution {\npublic:\n    \n     std::vector<long long int> st;\n\n     \n     \n     \n     \n     \n     \n     void build(int s, int e, int idx, std::vector<long>& arr) {\n     \n     \n     \n     \n     \n     \n     \n     \n     \n        if (s == e) {\n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n            st[idx] = arr[s];\n            return;\n        }\n        int mid = s + (e - s) / 2;\n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n        build(s, mid, 2 * idx + 1, arr);\n     \n     \n     \n     \n     \n     \n     \n     \n     \n        build(mid + 1, e, 2 * idx + 2, arr);\n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n        st[idx] = std::max(st[2 * idx + 1], st[2 * idx + 2]);\n    }\n\n     void update(int s, int e, int idx, int pos, long val) {\n        if (s == e) {\n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n            st[idx] = val;\n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n            return;\n        }\n        int mid = s + (e - s) / 2;\n        if (pos <= mid)\n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n            update(s, mid, 2 * idx + 1, pos, val);\n        else\n     \n     \n     \n     \n     \n     \n            update(mid + 1, e, 2 * idx + 2, pos, val);\n        st[idx] = std::max(st[2 * idx + 1], st[2 * idx + 2]);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n     long query(int s, int e, int idx, int qs, int qe) {\n        if (qs <= s && qe >= e)\n            return st[idx];\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n        if (qs > e || qe < s)\n            return LONG_MIN;\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n        int mid = s + (e - s) / 2;\n        long left = query(s, mid, 2 * idx + 1, qs, qe);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n        long right = query(mid + 1, e, 2 * idx + 2, qs, qe);\n        return std::max(left, right);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    }\n\n    vector<bool> getResults(vector<vector<int>>& qrs) {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n        std::vector<bool> res;\n        std::set<int> points;\n    \n    \n    \n    \n    \n    \n    \n    \n        points.insert(0);\n        points.insert(100000);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n        std::map<int, int> gaps;\n        gaps[0] = 0;\n        gaps[100000] = 100000;\n    \n    \n    \n    \n    \n    \n    \n    \n    \n        st.resize(5 * 100000);\n\n        int k = 0;\n        while (k < qrs.size()) {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n            std::vector<int>& q = qrs[k];\n            if (q[0] == 1) {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n                points.insert(q[1]);\n                int prev = *std::prev(points.lower_bound(q[1]));\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n                int next = *std::next(points.lower_bound(q[1]));\n                gaps[next] = next - q[1];\n                gaps[q[1]] = q[1] - prev;\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n                update(0, 100000, 0, q[1], gaps[q[1]]);\n                update(0, 100000, 0, next, gaps[next]);\n            } else {\n                int prev = *std::prev(points.lower_bound(q[1]));\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n                if (q[1] - prev >= q[2]) {\n                    res.push_back(true);\n                    k++;\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n                    continue;\n                } else if (query(0, 100000, 0, 0, q[1]) >= q[2]) {\n                    res.push_back(true);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n                    k++;\n                    continue;\n                }\n                res.push_back(false);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n            }\n            k++;\n        }\n    \n    \n    \n    \n    \n    \n    \n    \n        return res;\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    }\n\n\n\n\n\n\n\n\n};\n\n\n\n\n\n\n#ifdef LOCAL\nint main() {\n\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tcout << \"Compiled!\" << endl;\n}\n#endif\n",
    "submit_ts": 1716652700.0
}