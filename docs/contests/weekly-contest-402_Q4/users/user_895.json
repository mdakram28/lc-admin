{
    "username": "pham_haerin",
    "submission": "class Solution {\n        class SegmentTree {\n        int[] tree;\n        int[] arr;\n\n        public SegmentTree(int[] arr) {\n            this.arr = arr;\n            int n = arr.length;\n            int size = 1;\n            while (size < n) {\n                size <<= 1;\n            }\n            tree = new int[size * 2];\n            buildTree(0, 0, n - 1);\n        }\n\n        private void buildTree(int node, int start, int end) {\n            if (start == end) {\n                tree[node] = arr[start];\n            } else {\n                int mid = (start + end) / 2;\n                buildTree(node * 2 + 1, start, mid);\n                buildTree(node * 2 + 2, mid + 1, end);\n                tree[node] = tree[node * 2 + 1] + tree[node * 2 + 2];\n            }\n        }\n\n        public int query(int l, int r) {\n            return query(0, 0, arr.length - 1, l, r);\n        }\n\n        private int query(int node, int start, int end, int l, int r) {\n            if (l > end || r < start) {\n                return 0;\n            }\n            if (l <= start && r >= end) {\n                return tree[node];\n            }\n            int mid = (start + end) / 2;\n            return query(node * 2 + 1, start, mid, l, Math.min(r, mid)) +\n                   query(node * 2 + 2, mid + 1, end, Math.max(l, mid + 1), r);\n        }\n\n        public void update(int i, int val) {\n            update(0, 0, arr.length - 1, i, val);\n        }\n\n        private void update(int node, int start, int end, int i, int val) {\n            if (i < start || i > end) {\n                return;\n            }\n            if (start == end) {\n                tree[node] = val;\n                return;\n            }\n            int mid = (start + end) / 2;\n            update(node * 2 + 1, start, mid, i, val);\n            update(node * 2 + 2, mid + 1, end, i, val);\n            tree[node] = tree[node * 2 + 1] + tree[node * 2 + 2];\n        }\n    }\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        int n=nums.length;\n        int[] c1=new int[n];\n        Arrays.fill(c1,0);\n        for(int i=1;i<n;i++){\n            if(nums[i]>nums[i-1]) c1[i]=1;\n        }\n        int[] c2=new int[n];\n        Arrays.fill(c2,0);\n        for(int i=n-2;i>=0;i--){\n            if(nums[i]>nums[i+1]) c2[i]=1;\n        }\n        int[] u=new int[n];\n        for(int i=0;i<n;i++){\n            if(c1[i]==1&&c2[i]==1) u[i]=1;\n            else u[i]=0;\n        }\n        SegmentTree st=new SegmentTree(u);\n        int q=queries.length;\n        List<Integer>res=new ArrayList<>();\n        \n        for(int[] x:queries){\n            if(x[0]==2){\n                nums[x[1]]=x[2];\n                if(x[1]!=0&&x[1]!=n-1&&(nums[x[1]]>nums[x[1]-1]||nums[x[1]]>nums[x[1]+1])) st.update(x[1],1);\n                if(x[1]!=0&&x[1]!=n-1&&(nums[x[1]]<=nums[x[1]-1]||nums[x[1]]<=nums[x[1]+1])){\n                    st.update(x[1],0);\n                }\n                if(x[1]!=0){\n                    if(x[2]>=nums[x[1]-1]){\n                        st.update(x[1]-1,0);\n                    }\n                    if(x[1]>1&&x[2]<nums[x[1]-1]&&nums[x[1]-1]>nums[x[1]-2]) st.update(x[1]-1,1);\n                }\n                if(x[1]!=n-1){\n                    if(x[2]>=nums[x[1]+1]){\n                        st.update(x[1]+1,0);\n                    }\n                    if(x[1]<n-2&&nums[x[1]+1]>x[2]&&nums[x[1]+1]>nums[x[1]+2]) st.update(x[1]+1,1);\n                }\n            }\n            else res.add(st.query(x[1]+1,x[2]-1));\n        }\n        return res;\n    }\n}",
    "submit_ts": "1718507844",
    "subm_id": "1289664187"
}