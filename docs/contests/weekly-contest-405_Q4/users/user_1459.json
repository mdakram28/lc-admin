{
    "username": "shubhamvarshney2000",
    "submission": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ar array\n#define ll long long\n#define ld long double\n#define sza(x) ((int)x.size())\n#define all(a) (a).begin(), (a).end()\n\nconst int MAX_N = 1e5 + 5;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e9;\nconst ld EPS = 1e-9;\n\nlong long pow_m(long long base, long long exp, long long mod) {\n    long long result = 1LL;\n    base = (base % mod);\n        \n    while (exp > 0) {\n        if ((exp & 1LL) == 1LL) result = (result * base) % mod;\n        exp >>= 1LL;\n        base = (base * base) % mod;\n    }\n    return result;\n\n}\nstruct TN {\n        unordered_map<char, TN*> children;\n        vector<pair<int, int>> wordEnds; \n    };\n\n    class T {\n    public:\n        TN* root;\n        T() { root = new TN(); }\n\n        void insert(string& word, int index, int cost) {\n            TN* node = root;\n            for (char c : word) {\n                if (!node->children.count(c))\n                    node->children[c] = new TN();\n                node = node->children[c];\n            }\n            node->wordEnds.push_back({index, cost});\n        }\n    };\nclass DSU {\nprivate:\n    int sz;\n    vector<int> root, rank;\npublic:\n    DSU(int sz){\n        this->sz = sz;\n        root.resize(sz);\n        rank.resize(sz);\n        for(int i = 0; i < sz; i++){\n            root[i] = i;\n            rank[i] = 1;\n        }\n    }\n    \n    int find(int x){\n        if(root[x] == x) return x;\n        return root[x] = find(root[x]);\n    }\n    \n    bool unionSet(int x, int y){\n        int rootX = find(x);\n        int rootY = find(y);\n        if(rootX == rootY)\n            return false;\n        if(rank[rootX] > rank[rootY])\n            root[rootY] = rootX;\n        else if(rank[rootX] < rank[rootY])\n            root[rootX] = rootY;\n        else{\n            root[rootY] = rootX;\n            rank[rootX]++;\n        }\n        return true;\n    }\n\n    void reset() {\n        for(int i = 0; i < sz; i++){\n            root[i] = i;\n            rank[i] = 1;\n        }\n    }\n};\n\n\nclass TreeAncestor {\n    public:\n    vector<vector<int>> vec;\n    vector<int> depth;\n    int h = 18;\n    int n;\n    TreeAncestor(int _n, vector<int>& parent) {\n        n = _n;\n        depth.resize(n,0);\n        vec.resize(h,vector<int>(n+1,-1));\n        for(int i=0;i<n;i++){\n            vec[0][i] = parent[i];\n        }\n        for(int i=1;i<h;i++){\n            for(int j=0;j<n;j++){\n                if(vec[i-1][j] != -1)\n                    vec[i][j] = vec[i-1][vec[i-1][j]];\n            }\n        }\n    }\n    \n    int getKthAncestor(int node, int k) {\n        for(int i=0;i<h;i++){\n            if(k&(1<<i)){\n                node = vec[i][node];\n                if(node == -1){\n                    return -1;\n                }\n            }\n        }\n        return node;\n    }\n    int lca(int a, int b)\n    {\n        if(depth[a] < depth[b])\n            swap(a, b);\n        \n        int diff = depth[a] - depth[b];\n        for(int i = 0; i < 16; i++)\n            if(diff & (1 << i))\n                a = vec[a][i];\n\n        if(a == b)\n            return a;\n        \n        for(int i = 15; i >= 0; i--)\n        {\n            if(vec[a][i] != vec[b][i])\n            {\n                a = vec[a][i];\n                b = vec[b][i];\n            }\n        }\n\n        return vec[a][0];\n    }\n    void dfs(int src, int paren,vector<vector<int>> &g)\n    {\n        for(auto x : g[src])\n        {\n            if(x == paren)\n                continue;\n            depth[x] = depth[src] + 1;\n            dfs(x, src,g);\n        }\n    }\n};\n\nbool help(ll x,ll y,ll sum){\n    ll s = 0;\n    while(x>0 && y>0){\n        if(s>=sum){\n            s= s-2;\n            y--;\n        }\n        else{\n            s += 1;\n            x--;\n        }\n    }\n    if(x<=sum){\n        return 1;\n    }\n    else{\n        return 0;\n    }\n}\n bool subArrayExists(ll arr[], int N)\n{\n    unordered_set<int> sumSet;\n \n    // Traverse through array\n    // and store prefix sums\n    ll sum = 0;\n    for (int i = 0; i < N; i++) {\n        sum += arr[i];\n \n        // If prefix sum is 0 or\n        // it is already present\n        if (sum == 0 || sumSet.find(sum) != sumSet.end())\n            return true;\n \n        sumSet.insert(sum);\n    }\n    return false;\n}\nbool isSubsetSum(ll set[], ll n, ll sum)\n{\n    // The value of subset[i][j] will be true if\n    // there is a subset of set[0..j-1] with sum\n    // equal to i\n    bool subset[n + 1][sum + 1];\n \n    // If sum is 0, then answer is true\n    for (int i = 0; i <= n; i++)\n        subset[i][0] = true;\n \n    // If sum is not 0 and set is empty,\n    // then answer is false\n    for (int i = 1; i <= sum; i++)\n        subset[0][i] = false;\n \n    // Fill the subset table in bottom up manner\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= sum; j++) {\n            if (j < set[i - 1])\n                subset[i][j] = subset[i - 1][j];\n            if (j >= set[i - 1])\n                subset[i][j]\n                    = subset[i - 1][j]\n                      || subset[i - 1][j - set[i - 1]];\n        }\n    }\n \n    return subset[n][sum];\n}\nint solve(string target, vector<string>& words, vector<int>& costs){\n    int n = target.size();\n    \n        vector<int> memo(n + 1, INT_MAX);\n    \n        memo[0] = 0;\n\n        T t;\n    \n        for (int i = 0; i < words.size(); ++i) {\n            t.insert(words[i], i, costs[i]);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            \n            if (memo[i] == INT_MAX) continue;\n            \n            TN* nn = t.root;\n            \n            for (int j = i; j < n; ++j) {\n                \n                if (!nn->children.count(target[j])) break;\n                \n                nn = nn->children[target[j]];\n                \n                for (auto& p : nn->wordEnds) {\n                    \n                    int ind = p.first;\n                    \n                    int cost = p.second;\n                    \n                    int l = words[ind].size();\n                    \n                    if (i + l <= n) {\n                        \n                        memo[i + l] = min(memo[i + l], memo[i] + cost);\n                    }\n                }\n            }\n        }\n\n        return memo[n] == INT_MAX ? -1 : memo[n];\n}\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        return solve(target,words,costs);\n    }\n};",
    "submit_ts": "1720323653",
    "subm_id": "1312380802"
}