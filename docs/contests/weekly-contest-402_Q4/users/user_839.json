{
    "username": "great-johnsonyen",
    "submission": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n \nvoid dbg_out() { cout << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cout << ' ' << H; dbg_out(T...); }\n#define debug(...) cout << '[' << __FILE__ << ':' << __LINE__ << \"] (\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n\n#define all(x) begin(x), end(x)\n#define rall(x) begin(x), end(x)\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\nusing i64 = long long;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<i64, i64>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nconst int inf = INT_MAX / 2 - 100;\nconst i64 infLL = LLONG_MAX / 3;\nconst int MOD = 1e9 + 7;\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};\ntemplate<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;\ntemplate<typename T> using max_heap=priority_queue<T>;\n\ntemplate <class T>\nvoid mkuni(vector<T>& v) {\n    sort(all(v));\n    v.erase(unique(all(v)), v.end());\n}\n\ntemplate <class T>\nint lwb(vector<T>& a, const T& b) {\n    return int(lower_bound(all(a), b) - begin(a));\n}\n\ntemplate <class T>\nint upb(vector<T>& a, const T& b) {\n    return int(upper_bound(all(a), b) - begin(a));\n}\n\nconstexpr int popcount(int x) {\n    return __builtin_popcount(x);\n}\n\nconstexpr int topbit(int x) {\n    return x == 0 ? 0 : 31 - __builtin_clz(x);\n}\n\ntemplate <class T, class U>\nvoid safeErase(T& t, const U& u) {\n    auto it = t.find(u);\n    assert(it != end(t));\n    t.erase(it);\n}\n\ntemplate<class T, class U>\nT fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\n\ntemplate<class T, class U>\nT lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\n\ninline void add_mod(int& x, int y) { x += y; if (x >= MOD) x -= MOD; }\ninline void sub_mod(int& x, int y) { x += MOD - y; if (x >= MOD) x -= MOD; }\n\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    return b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    return a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\n/***\n * \\U0001d4fd\\U0001d4f1\\U0001d4ee \\U0001d4fc\\U0001d4f8\\U0001d4f5\\U0001d4fe\\U0001d4fd\\U0001d4f2\\U0001d4f8\\U0001d4f7 \\U0001d4f8\\U0001d4ef \\U0001d500\\U0001d502\\U0001d4ef0722\n */\n\n\ntemplate <typename T>\nstruct Fenwick {\n    int n;\n    std::vector<T> a;\n    \n    Fenwick(int n_ = 0) {\n        init(n_);\n    }\n    \n    void init(int n_) {\n        n = n_;\n        a.assign(n, T{});\n    }\n    \n    void add(int x, const T &v) {\n        for (int i = x + 1; i <= n; i += i & -i) {\n            a[i - 1] = a[i - 1] + v;\n        }\n    }\n    \n    T sum(int x) {\n        T ans{};\n        for (int i = x; i > 0; i -= i & -i) {\n            ans = ans + a[i - 1];\n        }\n        return ans;\n    }\n    \n    T rangeSum(int l, int r) {\n        return sum(r) - sum(l);\n    }\n    \n    int select(const T &k) {\n        int x = 0;\n        T cur{};\n        for (int i = 1 << std::__lg(n); i; i /= 2) {\n            if (x + i <= n && cur + a[x + i - 1] <= k) {\n                x += i;\n                cur = cur + a[x - 1];\n            }\n        }\n        return x;\n    }\n};\n\n// don't forget to set default value\n// T variable = value\nstruct Info{\n    int x;\n    Info(int x_ = 0):x(x_) {}\n};\nInfo operator+(const Info &a, const Info &b) {\n    return Info{max(a.x, b.x)};\n}\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n\t\tFenwick<int> fen(n);\n\t\tFOR(i, 1, n - 1) {\n\t\t\tif (nums[i - 1] < nums[i] && nums[i] > nums[i + 1]) {\n\t\t\t\tfen.add(i, 1);\n\t\t\t}\t\t\t\n\t\t}\n\t\tvi ans;\n\t\tfor (auto &q : queries) {\n\t\t\tif (q[0] == 1) {\n\t\t\t\tint l = q[1], r = q[2];\n\t\t\t\tif (r - l <= 1) ans.push_back(0);\n\t\t\t\telse {\n\t\t\t\t\tans.push_back(fen.rangeSum(l + 1, r));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint idx = q[1], val = q[2];\n\t\t\t\tif (idx > 0 && idx < n - 1) {\n\t\t\t\t\tif (nums[idx - 1] < nums[idx] && nums[idx] > nums[idx + 1]) {\n\t\t\t\t\t\tfen.add(idx, -1);\n\t\t\t\t\t}\n\t\t\t\t\tif (nums[idx - 1] < val && val > nums[idx + 1]) {\n\t\t\t\t\t\tfen.add(idx, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (idx - 1 > 0 && idx - 1 < n - 1) {\n\t\t\t\t\tif (nums[idx - 2] < nums[idx - 1] && nums[idx - 1] > nums[idx]) {\n\t\t\t\t\t\tfen.add(idx - 1, -1);\n\t\t\t\t\t}\n\t\t\t\t\tif (nums[idx - 2] < nums[idx - 1] && nums[idx - 1] > val) {\n\t\t\t\t\t\tfen.add(idx - 1, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (idx + 1 > 0 && idx + 1 < n - 1) {\n\t\t\t\t\tif (nums[idx] < nums[idx + 1] && nums[idx + 1] > nums[idx + 2]) {\n\t\t\t\t\t\tfen.add(idx + 1, -1);\n\t\t\t\t\t}\n\t\t\t\t\tif (val < nums[idx + 1] && nums[idx + 1] > nums[idx + 2]) {\n\t\t\t\t\t\tfen.add(idx + 1, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnums[idx] = val;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n    }\n};",
    "submit_ts": 1718507986.0
}