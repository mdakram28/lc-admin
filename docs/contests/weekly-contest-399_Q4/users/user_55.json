{
    "username": "SleepyJie",
    "submission": "/********************************************\n * author : Jie Chen (3rd Year CS)\n * school : Rochester Institute of Technology\n * created: 05.25.2024 22:09:39\n*********************************************/\n\nusing i64 = long long;\n\n// Credit: Jiangly\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n \ntemplate<>\nint MInt<0>::Mod = 998'244'353;\n \ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n \nconstexpr int P = 1'000'000'007; // 998'244'353;\nusing Z = MInt<P>;\n\ntemplate <class Info>\nstruct SegmentTree {\n    int n;\n    vector<Info> info;\n    SegmentTree() : n(0) {}\n    SegmentTree(int n_, Info v_ = Info()) {\n        init(n_, v_);\n    }\n    template<class T>\n    SegmentTree(vector<T> init_) {\n        init(init_);\n    }\n    void init(int n_, Info v_ = Info()) {\n        init(vector(n_, v_));\n    }\n    template<class T>\n    void init(vector<T> init_) {\n        n = init_.size();\n        info.assign(4 << __lg(n), Info());\n        function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init_[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = info[2 * p] + info[2 * p + 1];\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info range_query(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        return range_query(2 * p, l, m, x, y) + range_query(2 * p + 1, m, r, x, y);\n    }\n    Info range_query(int l, int r) {\n        return range_query(1, 0, n, l, r);\n    }\n    template<class F>\n    int find_first(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        int res = find_first(2 * p, l, m, x, y, pred);\n        if (res == -1) {\n            res = find_first(2 * p + 1, m, r, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int find_first(int l, int r, F pred) {\n        return find_first(1, 0, n, l, r, pred);\n    }\n    template<class F>\n    int find_last(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        int res = find_last(2 * p + 1, m, r, x, y, pred);\n        if (res == -1) {\n            res = find_last(2 * p, l, m, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int find_last(int l, int r, F pred) {\n        return find_last(1, 0, n, l, r, pred);\n    }\n};\n \nstruct Info {\n    i64 sum_both;\n    i64 sum_right;\n    i64 sum_left;\n    i64 sum_none;\n    Info(): sum_both(0), sum_right(0), sum_left(0), sum_none(0) {}\n    Info(int x): sum_both(x), sum_right(0), sum_left(0), sum_none(0) {}\n};\n \nInfo operator+(const Info& a, const Info& b) {\n    Info c;\n    c.sum_both = max({\n        a.sum_left + b.sum_right,\n        a.sum_both + b.sum_right,\n        a.sum_left + b.sum_both\n    });\n    c.sum_right = max({\n        a.sum_none + b.sum_right,\n        a.sum_right + b.sum_right,\n        a.sum_none + b.sum_both\n    });\n    c.sum_left = max({\n        a.sum_left + b.sum_none,\n        a.sum_left + b.sum_left,\n        a.sum_both + b.sum_none\n    });\n    c.sum_none = max({\n        a.sum_right + b.sum_none,\n        a.sum_none + b.sum_left,\n        a.sum_none + b.sum_none\n    });\n    return c;\n}\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& a, vector<vector<int>>& queries) {\n        int n = a.size(), Q = queries.size();\n\n        vector<Info> init(n);\n        for (int i = 0; i < n; i++) {\n            init[i] = Info(a[i]);\n        }\n\n        SegmentTree<Info> seg(init);\n        Z ans = 0;\n        for (const auto& query : queries) {\n            int pos = query[0];\n            int x = query[1];\n            Info info(x);\n            seg.modify(pos, info);\n            auto res = seg.range_query(0, n);\n            ans += max({res.sum_both, res.sum_left, res.sum_right, res.sum_none});\n        }\n        return ans.val();\n    }\n};\n\n// ~ JustJie",
    "submit_ts": "1716692345",
    "subm_id": "1268050725"
}