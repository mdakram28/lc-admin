{
    "username": "santhoshwon",
    "submission": "#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1; // Number of nodes in tree 1\n        int m = edges2.size() + 1; // Number of nodes in tree 2\n\n        vector<vector<int>> graph1(n);\n        vector<vector<int>> graph2(m);\n        \n        for (auto& edge : edges1) {\n            int u = edge[0], v = edge[1];\n            graph1[u].push_back(v);\n            graph1[v].push_back(u);\n        }\n        \n        for (auto& edge : edges2) {\n            int u = edge[0], v = edge[1];\n            graph2[u].push_back(v);\n            graph2[v].push_back(u);\n        }\n        \n        // Function to find the farthest node and its distance from a start node\n        auto bfs = [&](const vector<vector<int>>& graph, int start, vector<int>& dist) {\n            int n = graph.size();\n            dist.assign(n, -1);\n            queue<int> q;\n            q.push(start);\n            dist[start] = 0;\n            int farthest_node = start;\n            int max_distance = 0;\n            \n            while (!q.empty()) {\n                int node = q.front();\n                q.pop();\n                for (int neighbor : graph[node]) {\n                    if (dist[neighbor] == -1) {\n                        dist[neighbor] = dist[node] + 1;\n                        q.push(neighbor);\n                        if (dist[neighbor] > max_distance) {\n                            max_distance = dist[neighbor];\n                            farthest_node = neighbor;\n                        }\n                    }\n                }\n            }\n            return make_pair(farthest_node, max_distance);\n        };\n        \n        // Find the diameter of the first tree\n        vector<int> dist1(n);\n        auto [u, _] = bfs(graph1, 0, dist1);\n        auto [v, diameter1] = bfs(graph1, u, dist1);\n        \n        // Find the diameter of the second tree\n        vector<int> dist2(m);\n        auto [x, __] = bfs(graph2, 0, dist2);\n        auto [y, diameter2] = bfs(graph2, x, dist2);\n        \n        return max(diameter1, max(diameter2, (diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1));\n    }\n};\n",
    "submit_ts": 1719717373.0
}