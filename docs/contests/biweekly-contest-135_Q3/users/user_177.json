{
    "username": "Romy67",
    "submission": "#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define per(i, a, b) for(int i = a; i > (b); --i)\n#define ar array\n#define sz(x) (int) (x).size()\n#define pii pair<int,int>\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\n#define all(x) (x).begin(), (x).end()\n\ntemplate<typename T>\nvoid min_self(T& A, T B) {\n    A = min(A,B);\n}\ntemplate<typename T>\nvoid max_self(T& A, T B) {\n    A = max(A,B);\n}\n\nstruct FT {\n    vector<ll> s;\n    FT(int n) : s(n) {}\n    void update(int pos, ll dif) { // a[pos] += dif\n        for (; pos < sz(s); pos |= pos + 1) s[pos] += dif;\n    }\n    ll query(int pos) { // sum of values in [0, pos)\n        ll res = 0;\n        for (; pos > 0; pos &= pos - 1) res += s[pos-1];\n        return res;\n    }\n    int lower_bound(ll sum) {// min pos st sum of [0, pos] >= sum\n        // Returns n if no sum is >= sum, or -1 if empty sum is.\n        if (sum <= 0) return -1;\n        int pos = 0;\n        for (int pw = 1 << 25; pw; pw >>= 1) {\n            if (pos + pw <= sz(s) && s[pos + pw-1] < sum)\n                pos += pw, sum -= s[pos-1];\n        }\n        return pos;\n    }\n};\n\nstruct FT2 {\n    vector<vi> ys; vector<FT> ft;\n    FT2(int limx) : ys(limx) {}\n    void fakeUpdate(int x, int y) {\n        for (; x < sz(ys); x |= x + 1) ys[x].push_back(y);\n    }\n    void init() {\n        for (vi& v : ys) sort(all(v)), ft.emplace_back(sz(v));\n    }\n    int ind(int x, int y) {\n        return (int)(lower_bound(all(ys[x]), y) - ys[x].begin()); }\n    void update(int x, int y, ll dif) {\n        for (; x < sz(ys); x |= x + 1)\n            ft[x].update(ind(x, y), dif);\n    }\n    ll query(int x, int y) {\n        ll sum = 0;\n        for (; x; x &= x - 1)\n            sum += ft[x-1].query(ind(x-1, y));\n        return sum;\n    }\n};\n\nclass Solution {\npublic:\n    int minChanges(vector<int>& nums, int k) {\n        FT2 ft2(k+1);\n        map<int,int> mp;\n        rep(i,0,sz(nums)) {\n            int j = sz(nums)-1-i;\n            if(i>j) break;\n            ft2.fakeUpdate(nums[i], nums[j]);\n            mp[abs(nums[i]-nums[j])]++;\n        }\n        ft2.init();\n        rep(i,0,sz(nums)) {\n            int j = sz(nums)-1-i;\n            if(i>j) break;\n            ft2.update(nums[i], nums[j], 1ll);\n        }\n        int ret = sz(nums);\n        for(auto [dif,v]: mp) {\n            int temp = sz(nums)/2 - v;\n            if(k-dif < dif) {\n                int ct = ft2.query(dif,dif);\n                // if(dif>0) {\n                ct -= ft2.query(dif,k-dif+1);\n                ct -= ft2.query(k-dif+1, dif);\n                ct += ft2.query(k-dif+1, k-dif+1);\n                // }\n                temp += ct;\n            }\n            min_self(ret, temp);\n        }\n        return ret;\n    }\n};",
    "submit_ts": "1721487543",
    "subm_id": "1327392645"
}