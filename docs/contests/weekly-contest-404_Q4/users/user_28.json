{
    "username": "lydxlx",
    "submission": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\n    int dfs(int cur, int parent, int& height, vector<vector<int>>& edges) {\n        height = 1;\n        int ans = 0;\n        int maxheight[3] = { 0, 0, 0 };\n        for (auto e : edges[cur]) {\n            if (e == parent) {\n                continue;\n            }\n            int tempheight;\n            int tempans = dfs(e, cur, tempheight, edges);\n            maxheight[2] = tempheight;\n            for (int i = 1; i >= 0; i--) {\n                if (maxheight[i] < maxheight[i + 1]) {\n                    swap(maxheight[i], maxheight[i + 1]);\n                }\n            }\n            ans = max(ans, tempans);\n            height = max(height, tempheight + 1);\n        }\n        ans = max(ans, maxheight[0] + maxheight[1]);\n        return ans;\n    }\n    int getDiameter(int size, vector<vector<int>>& edges) {\n        int temp;\n        return dfs(0, -1, temp, edges);\n    }\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        vector<vector<int>> neighbor1(n);\n        vector<vector<int>> neighbor2(m);\n        for (auto& e1 : edges1) {\n            int a = e1[0];\n            int b = e1[1];\n            neighbor1[a].push_back(b);\n            neighbor1[b].push_back(a);\n        }\n        for (auto& e2 : edges2) {\n            int a = e2[0];\n            int b = e2[1];\n            neighbor2[a].push_back(b);\n            neighbor2[b].push_back(a);\n        }\n        int d1 = getDiameter(n, neighbor1);\n        // cerr << d1 << endl;\n        int d2 = getDiameter(m, neighbor2);\n        // cerr << d2 << endl;\n        int ans = max(d1, d2);\n        ans = max(ans, (d1 + 1) / 2 + (d2 + 1) / 2 + 1);\n        return ans;\n    }\n};\n",
    "submit_ts": 1719715800.0
}