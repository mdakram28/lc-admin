{
    "username": "jfantasy90",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        const int n = edges1.size() + 1;\n        const int m = edges2.size() + 1;\n        vector<vector<int>> next1(n, vector<int>());\n        vector<vector<int>> next2(m, vector<int>());\n        vector<int> dis1(n, 0), res1(n, 0);\n        vector<int> dis2(m, 0), res2(m, 0);\n        \n        buildNext(edges1, n, next1);\n        buildNext(edges2, m, next2);\n        \n        dfs1(next1, 0, -1, dis1);\n        dfs1(next2, 0, -1, dis2);\n        \n        dfs2(next1, 0, -1, 0, dis1, res1);\n        dfs2(next2, 0, -1, 0, dis2, res2);\n        \n        int res = 0;\n        for (int i = 0; i < n; ++i) res = max(res, res1[i]);\n        for (int i = 0; i < m; ++i) res = max(res, res2[i]);\n        \n        int p = res1[0], q = res2[0];\n        for (int i = 0; i < n; ++i) p = min(p, res1[i]);\n        for (int i = 0; i < m; ++i) q = min(q, res2[i]);\n        res = max(res, p + q + 1);\n        \n        \n        return res;\n    }\n    \nprivate:\n    void buildNext(const vector<vector<int>> &edges, int n, vector<vector<int>>& next) {\n        for (const vector<int>& edge : edges) {\n            int x = edge[0], y = edge[1];\n            next[x].push_back(y);\n            next[y].push_back(x);\n        }\n        //return next;\n    }\n    \n    void dfs1(const vector<vector<int>> &next, int current, int parent, vector<int>& dis) {\n        dis[current] = 0;\n        for (int to : next[current]) {\n            if (to == parent) continue;\n            dfs1(next, to, current, dis);\n            dis[current] = max(dis[current], dis[to] + 1);\n        }\n    }\n    \n    void dfs2(const vector<vector<int>> &next, int current, int parent, int k, const vector<int>& dis, vector<int> &res) {\n        res[current] = max(dis[current], k);\n        //cout << current << \" \" << dis[current] << \" \" << k << \" \" << res[current] << endl;\n        int p1 = -1, p2 = -1;\n        for (int to : next[current]) {\n            if (to == parent) continue;\n            if (p1 == -1 || dis[to] > dis[p1]) {\n                p2 = p1;\n                p1 = to;\n            } else if (p2 == -1 || dis[to] > dis[p2]) {\n                p2 = to;\n            }\n        }\n        for (int to : next[current]) {\n            if (to == parent) continue;\n            dfs2(next, to, current, max(to != p1 ? dis[p1] + 2 : (p2 == -1 ? 1 : dis[p2] + 2), k + 1), dis, res);\n        }\n    }\n};",
    "submit_ts": "1719717256",
    "subm_id": "1304386716"
}