{
    "username": "cy171",
    "submission": "from sortedcontainers import SortedList\nclass SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.data = [0] * (4 * n)\n        self.lazy = [0] * (4 * n)\n        self.build(1, 0, n - 1, list(range(n, 0, -1)))\n\n    def build(self, node, start, end, values):\n        if start == end:\n            self.data[node] = values[start]\n        else:\n            mid = (start + end) // 2\n            self.build(2 * node, start, mid, values)\n            self.build(2 * node + 1, mid + 1, end, values)\n            self.data[node] = max(self.data[2 * node], self.data[2 * node + 1])\n\n    def update_range(self, l, r, val, node=1, start=0, end=None):\n        if end is None:\n            end = self.n - 1\n\n        if self.lazy[node] != 0:\n            self.data[node] += self.lazy[node]\n            if start != end:\n                self.lazy[2 * node] += self.lazy[node]\n                self.lazy[2 * node + 1] += self.lazy[node]\n            self.lazy[node] = 0\n\n        if start > r or end < l:\n            return\n\n        if start >= l and end <= r:\n            self.data[node] += val\n            if start != end:\n                self.lazy[2 * node] += val\n                self.lazy[2 * node + 1] += val\n            return\n\n        mid = (start + end) // 2\n        self.update_range(l, r, val, 2 * node, start, mid)\n        self.update_range(l, r, val, 2 * node + 1, mid + 1, end)\n        self.data[node] = max(self.data[2 * node], self.data[2 * node + 1])\n\n    def query_range(self, l, r, node=1, start=0, end=None):\n        if end is None:\n            end = self.n - 1\n\n        if self.lazy[node] != 0:\n            self.data[node] += self.lazy[node]\n            if start != end:\n                self.lazy[2 * node] += self.lazy[node]\n                self.lazy[2 * node + 1] += self.lazy[node]\n            self.lazy[node] = 0\n\n        if start > r or end < l:\n            return -float('inf')\n\n        if start >= l and end <= r:\n            return self.data[node]\n\n        mid = (start + end) // 2\n        left_query = self.query_range(l, r, 2 * node, start, mid)\n        right_query = self.query_range(l, r, 2 * node + 1, mid + 1, end)\n        return max(left_query, right_query)\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        limit = max(item[1] for item in queries)+1\n        tree = SegmentTree(limit)\n        # for i in range(limit):\n        #     print(limit, i, tree.query_range(i,i))\n        block = SortedList()\n        ans = []\n        for item in queries:\n            idx = block.bisect_left(item[1])\n            if idx == 0:\n                pre = 0\n            else:\n                pre = block[idx-1]\n            if item[0] == 1:\n                block.add(item[1])\n                right = tree.query_range(item[1],item[1])\n                tree.update_range(pre, item[1]-1, -right)\n            else:\n                rr = tree.query_range(0,pre-1) if pre> 0 else 0\n                right = tree.query_range(pre,item[1]-1)\n                # print(right, item[2])\n                if item[1] in block:\n                    last = 0\n                else:\n                    last = tree.query_range(item[1],item[1])\n                ans.append(right >= item[2] + last or rr >= item[2])\n        return ans",
    "submit_ts": "1716651083",
    "subm_id": "1267631647"
}