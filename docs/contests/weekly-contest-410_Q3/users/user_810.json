{
    "username": "the_none",
    "submission": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T> using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using omset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\nstatic const int _ = []() {ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0;}();\n\n#define all(x) (x).begin(),(x).end()\n#define uniqque(x) sort(all(x)); x.erase(unique(all(x)),x.end())\n#define sz(x) (int)(x).size()\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n#define endl '\\n'\n#define fo(i,n) for(int i=0;i<n;++i)\n#define forr(i,n) for(int i=n-1;i>=0;--i)\n#define rep(i,a,b) for(int i=a;i<=b;++i)\n#define per(i,a,b) for(int i=b;i>=a;--i)\n\n#define ffs(a) __builtin_ffs(a) // find first set\n#define clz(a) __builtin_clz(a) // count leading zeroes\n#define ctz(a) __builtin_ctz(a) // count trailing zeroes\n#define popc(a) __builtin_popcount(a) // count set bits\n#define popcll(a) __builtin_popcountll(a) //count set bits for long long int\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\n\nconst ll inf = 1e9;\nconst ld eps = 1e-9;\nconst ld pi = acos(-1);\nconst int mod = 1000000007; // 1000000007 998244353\nconst ll lnf = 1e18;\nconst int dx[] = { -1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\n\ntemplate <class T> using pqmin = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> using pqmax = priority_queue<T>;\n\ntemplate<class T, class V> istream& operator>> (istream& is, std::pair<T, V>& p) {is >> p.first >> p.second; return is;}\ntemplate<class T, class V>  ostream& operator<< (ostream& is, std::pair<T, V>& p) {is << p.first << \" \" << p.second; is << endl; return is;}\ntemplate<class T> istream& operator>> (istream& is, std::vector<T>& p) {  for (auto &i : p) {is >> i;} return is;}\ntemplate<class T> ostream& operator<< (ostream& is, std::vector<T>& p) {  for (auto &i : p) {is << i << \" \";} is << endl; return is;}\ntemplate<class T> istream& operator>> (istream& is, std::vector<std::vector<T>>& p) {  for (auto &i : p) {is >> i;} return is;}\ntemplate<class T> ostream& operator<< (ostream& is, std::vector<std::vector<T>>& p) {  for (auto &i : p) {is << i << \" \";} is << endl; return is;}\n\ntemplate<class Fun>class y_combinator_result {Fun fun_; public: template<class T>explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {} template<class ...Args>decltype(auto) operator()(Args &&...args) {return fun_(std::ref(*this), std::forward<Args>(args)...);}};\ntemplate<class Fun>decltype(auto) y_combinator(Fun &&fun) {return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));}\n\nvoid my_erase(omset<int>& t, int v) {t.erase(t.find_by_order(t.order_of_key(v)));}\nvoid my_erase(oset<ll>& t, int v) {t.erase(t.find_by_order(t.order_of_key(v)));}\n\n\n// O(1) query with no updates\nstruct sparseTable {\n  int n, k; vector< vector<long long> > table; vector<long long> logs;\n  void init(int x) {n = x; logs.resize(n + 1); logs[1] = 0; for (int i = 2; i <= n; i++) {logs[i] = logs[i / 2] + 1;} k = *max_element(logs.begin(), logs.end()); table.assign(k + 1, vector<long long> (n + 1, INT_MAX) );}\n  long long operation(long long x, long long y) {return (x & y);}\n  void build(vector<int> &arr) {for (int i = 0; i < arr.size(); i++) {table[0][i] = arr[i];} for (int j = 1; j <= k; j++) {for (int i = 0; i + (1ll << j) <= n; i++) {table[j][i] = operation(table[j - 1][i], table[j - 1][i + (1ll << (j - 1))]);}}}\n  long long query(int l , int r) {int j = logs[r - l + 1]; long long answer = operation(table[j][l], table[j][r - (1ll << j) + 1]); return answer;}\n};\n/* sparseTable sp; sp.init(n); sp.build(a); */\n\n// O(logn) query O(logn) range updates\ntemplate<typename node, typename upd> struct LAZY {\n  vector<node> ST; vector<bool> LT; vector<upd> UT; vector<int> arr; int n, s;\n  LAZY(vector<int> &a) {arr = a, n = a.size(), s = 1; while (s < 2 * n) {s = s << 1;} ST.resize(s); fill(ST.begin(), ST.end(), node()); LT.resize(s); fill(LT.begin(), LT.end(), false); UT.resize(s); fill(UT.begin(), UT.end(), upd()); build(0, n - 1, 1);}\n  void build(int s, int e, int i) {if (s == e)   {ST[i] = node(arr[s]); return;} int m = (s + e) / 2; build(s, m, 2 * i); build(m + 1, e, 2 * i + 1); ST[i].merge(ST[2 * i], ST[2 * i + 1]);}\n  void pushdown(int i, int s, int e) {if (LT[i]) {int m = (s + e) / 2; apply(2 * i, s, m, UT[i]); apply(2 * i + 1, m + 1, e, UT[i]); UT[i] = upd(), LT[i] = 0;}}\n  void apply(int i, int s, int e, upd& u) {if (s != e) {LT[i] = 1, UT[i].comb(u, s, e);} u.apply(ST[i], s, e);}\n  void update(int s, int e, int i, int l, int r, upd& u) {if (s > r || e < l) return; if (s >= l && e <= r) {apply(i, s, e, u); return;} pushdown(i, s, e); int m = (s + e) / 2; update(s, m, 2 * i, l, r, u); update(m + 1, e, 2 * i + 1, l, r, u); ST[i].merge(ST[2 * i], ST[2 * i + 1]);}\n  node query(int s, int e, int i, int l, int r) {if (s > r || e < l) return node(); if (s >= l && e <= r) {pushdown(i, s, e); return ST[i];} pushdown(i, s, e); int m = (s + e) / 2; node ln, rn, ans; ln = query(s, m, 2 * i, l, r); rn = query(m + 1, e, 2 * i + 1, l, r); ans.merge(ln, rn); return ans;}\n  void change(int l, int r, int val) {upd x = upd(val); update(0, n - 1, 1, l, r, x);}\n  node get(int l, int r) {return query(0, n - 1, 1, l, r);}\n};\n// LAZY<int,node,update>sg = LAZY<int,node,update>(a);\n\ntemplate<typename node, typename upd>\nstruct TREE {\n  vector<node> ST; vector<int> arr; int n; int s;\n  TREE(int sz, vector<int> &a) {arr = a, n = sz, s = 1; while (s < 2 * n) {s = s << 1;} ST.resize(s); fill(ST.begin(), ST.end(), node()); build(0, n - 1, 1);}\n  void build(int s, int e, int i)  {if (s == e) {ST[i] = node(arr[s]); return;} int mid = (s + e) / 2; build(s, mid, 2 * i); build(mid + 1, e, 2 * i + 1); ST[i].merge(ST[2 * i], ST[2 * i + 1]);}\n  void update(int s, int e, int i, int qi, upd &u)  {if (s == e) {u.apply(ST[i]); return;} int mid = (s + e) / 2; if (mid >= qi) {update(s, mid, 2 * i, qi, u);} else {update(mid + 1, e, 2 * i + 1, qi, u);} ST[i].merge(ST[2 * i], ST[2 * i + 1]);}\n  node query(int s, int e, int i, int l, int r) { if (s > r || e < l) return node(); if (s >= l && e <= r) return ST[i]; int mid = (s + e) / 2; node ln, rn, ans; ln = query(s, mid, 2 * i, l, r); rn = query(mid + 1, e, 2 * i + 1, l, r); ans.merge(ln, rn); return ans;}\n  void change(int i, int val) {upd x = upd(val); update(0, n - 1, 1, i, x);}\n  node get(int l, int r) {return query(0, n - 1, 1, l, r);}\n};\n// TREE<T, U>sg = TREE<T, U>(n, a);\n\nstruct node {\n  int val;\n  node() {val = 0;}\n  node(int p1) {val = p1;}\n  void merge(node &left, node &right) { val = max(left.val , right.val);}\n};\nstruct update {\n  int val;\n  update() {val = 0;}\n  update(int val1) {val = val1;}\n  void apply(node &a, int s, int e) {a.val += val;}  // range update\n  void apply(node &a) {a.val = val;} // point update\n  void comb(update& x, int s, int e) {val += x.val;}\n};\n\nstruct Compress {\n  vl a; int cnt;\n  Compress() : cnt(0) {}\n  void add(ll x) { a.push_back(x); }\n  void init() {sort(all(a)); a.erase(unique(all(a)), a.end()); cnt = sz(a);}\n  ll to(ll x) {int index = lower_bound(all(a), x) - a.begin(); return index;}\n  ll from(int x) { return a[x]; }\n  int size() { return cnt; }\n};\n\n#ifdef ONLINE_JUDGE\n#include \"debug.h\"\n#define dbg(...)  cerr << __LINE__ << \" :: \", debug::printer(#__VA_ARGS__, __VA_ARGS__)\n#define dbgA(arr, n) cerr << __LINE__ << \" :: \", debug::printerArr(#arr, arr, n)\n#else\n#define dbg(x...)\n#define dbgA(arr, n)\n#endif\n\n// solution\nclass Solution {\n  int n;\n  ll f(ll i, ll p1, ll p2, vector<int> &nums, vector<vector<vector<ll>>> &dp) {\n    if (i == n) {\n      return 1;\n    }\n    if (dp[i][p1 + 1][p2 + 1] != -1) return dp[i][p1 + 1][p2 + 1];\n    ll ans = 0;\n    for (int j = 0; j <= nums[i]; j++) {\n      // j = p1 cha next and nums[i]-j = p2 cha next\n      if (j >= p1 && (nums[i] - j <= p2 || p2 == -1)) {\n        ans = ans + f(i + 1, j, nums[i] - j, nums, dp);\n        ans %= mod;\n      }\n    }\n    return dp[i][p1 + 1][p2 + 1] = ans;\n  }\npublic:\n  int countOfPairs(vector<int>& nums) {\n    n = nums.size();\n      int m = *max_element(all(nums));\n    vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(m+2, vector<ll>(m+2, -1)));\n    return f(0, -1, -1, nums, dp);\n  }\n};\n\nvoid solve() {}\n#ifdef LOCAL\nint32_t main() { solve(); }\n#endif\n",
    "submit_ts": "1723344324",
    "subm_id": "1351531834"
}