{
    "username": "power1011",
    "submission": "using edges_t = vector<vector<int>>;\nclass Solution {\n    auto make_edges(vector<vector<int>>& a)\n    {\n        int n = a.size() + 1;\n        edges_t edges(n);\n        // edges[i] all the neighbor of i\n        for(auto &v:a)\n        {\n            edges[v.at(0)].push_back(v.at(1));\n            edges[v.at(1)].push_back(v.at(0));\n        }\n        return edges;\n    }\n    auto bfs(const edges_t &edges, int st)\n    {\n        int n = edges.size();\n        queue<int> q;\n        vector<int> visited(n);\n        vector<int> dis(n);\n        visited[st] = 1;\n        dis[st] = 0;\n        q.push(st);\n        for(;!q.empty();)\n        {\n            auto v = q.front();\n            q.pop();\n            for(auto &nei:edges.at(v))\n            {\n                if(visited[nei])\n                {\n                    continue;\n                }\n                dis[nei] = dis[v] + 1;\n                visited[nei] = 1;\n                q.push(nei);\n            }\n        }\n        auto it = max_element(dis.begin(), dis.end());\n        return make_pair(it - dis.begin(), *it);\n    }\n    auto find_diameter(const edges_t &edges)\n    {\n        auto first = bfs(edges, 0).first;\n        auto tmp = bfs(edges, first);\n        auto second = tmp.first;\n        auto dis = tmp.second;\n        return dis;\n    }\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        auto d1 = find_diameter(make_edges(edges1));\n        auto d2 = find_diameter(make_edges(edges2));\n        return max((d1 + 1) /2 + (d2 + 1) /2 + 1, max(d1, d2));\n    }\n};",
    "submit_ts": 1719718003.0
}