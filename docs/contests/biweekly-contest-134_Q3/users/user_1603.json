{
    "username": "Joyjeet",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds; // find_by_order, order_of_key\n#define ll long long\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vi vector<int>\n#define vll vector<long long>\n#define vvi vector<vi>\n#define vpii vector<pair<int,int>>\n#define vpll vector<pair<ll,ll>>\n#define mii map<int, int>\n#define si set<int>\n#define sc set<char>\n#define f(i,s,e) for(long long int i=s;i<e;i++)\n#define cf(i,s,e) for(long long int i=s;i<=e;i++)\n#define rf(i,e,s) for(long long int i=e-1;i>=s;i--)\n#define pb push_back\n#define eb emplace_back\n#define yes cout << 'YES' << endl;\n#define no cout << 'NO' << endl;\n#define ff first\n#define ss second\n#define MOD 1000000007\n#define MOD1 998244353\n#define debug(x) cout<<x<<endl\n#define INFI 1E9+10\n#define INFL 1e18\n#define all(v) v.begin(),v.end()\nint lcm(int x,int y){return (x*y)/__gcd(x,y);}\nbool prime(ll a) { if (a==1) return 0; for (int i=2;i<=round(sqrt(a));++i) if (a%i==0) return 0; return 1; }\nvector<ll> sieve(int n) {int*arr = new int[n + 1](); vector<ll> vect; for (int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for (int j = 2 * i; j <= n; j += i)arr[j] = 1;} return vect;}\nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\n#define dbg(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n\ntemplate<typename T>\nvoid _print(T arg) {\n    cerr << arg;\n}\n\ntemplate<typename T>\nvoid _print(const vector<T>& arg) {\n    cerr << \"[\";\n    for (const auto& element : arg) {\n        cerr << element << \", \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename T>\nvoid _print(const set<T>& arg) {\n    cerr << \"[\";\n    for (const auto& element : arg) {\n        cerr << element << \", \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename T>\nvoid _print(const multiset<T>& arg) {\n    cerr << \"[\";\n    for (const auto& element : arg) {\n        cerr << element << \", \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename K, typename V>\nvoid _print(const map<K, V>& arg) {\n    cerr << \"[\";\n    for (const auto& [key, value] : arg) {\n        cerr << \"(\" << key << \"=>\" << value << \"), \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename K, typename V>\nvoid _print(const multimap<K, V>& arg) {\n    cerr << \"[\";\n    for (const auto& [key, value] : arg) {\n        cerr << \"(\" << key << \"=>\" << value << \"), \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename T>\nvoid _print(const unordered_set<T>& arg) {\n    cerr << \"[\";\n    for (const auto& element : arg) {\n        cerr << element << \", \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename T>\nvoid _print(const unordered_multiset<T>& arg) {\n    cerr << \"[\";\n    for (const auto& element : arg) {\n        cerr << element << \", \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename K, typename V>\nvoid _print(const unordered_map<K, V>& arg) {\n    cerr << \"[\";\n    for (const auto& [key, value] : arg) {\n        cerr << \"(\" << key << \"=>\" << value << \"), \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename K, typename V>\nvoid _print(const unordered_multimap<K, V>& arg) {\n    cerr << \"[\";\n    for (const auto& [key, value] : arg) {\n        cerr << \"(\" << key << \"=>\" << value << \"), \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename T1, typename T2>\nvoid _print(const pair<T1, T2>& arg) {\n    cerr << \"(\" << arg.first << \", \" << arg.second << \")\";\n}\n\ntemplate<typename T, typename... Args>\nvoid _print(T arg, Args... args) {\n    cerr << arg << \", \";\n    _print(args...);\n}\n#define MAXN 3000001\nint spf[MAXN];\nint larg[MAXN];\nint primes[MAXN];\nint cnt[MAXN];\nvoid sieve()\n{\n    spf[1] = 1;\n    for (int i = 2; i < MAXN; i++){\n        spf[i] = i;\n    }\n    for (int i = 4; i < MAXN; i += 2)\n        spf[i] = 2;\n    for (int i = 3; i * i < MAXN; i++) {\n        if (spf[i] == i) {\n            for (int j = i * i; j < MAXN; j += i)\n                if (spf[j] == j)\n                    spf[j] = i;\n        }\n    }\n    int cur=0;\n    for(int i=2;i<MAXN;++i){\n        if(spf[i]==i){\n            primes[i]=++cur;\n        }\n        else{\n            larg[i]=i/spf[i];\n        }\n    }\n}\nclass Solution {\npublic:\n    int numberOfAlternatingGroups(vector<int>& colors, int k) {\n      int n=colors.size();\n      int m=n;\n      vi a;\n      for(int i=0;i<2*n;++i){\n        if(i<n){\n          a.pb(colors[i]);\n        }\n        else{\n          a.pb(colors[i-n]);\n        }\n      }\n      int cnt=0;\n      n=a.size();\n      vvi odd(n,vi(2,0)),even(n,vi(2,0));\n      for(int i=0;i<n;++i){\n        if(i%2){\n            if(i-2>=0){\n                odd[i]=odd[i-2];\n            }\n          odd[i][a[i]]++;\n        }\n        else{\n          if(i-2>=0){\n            even[i]=even[i-2];\n            }\n          even[i][a[i]]++;\n        }\n      }\n      for(int i=k-1;i<m+k-1;++i){\n          if(a[i]==a[i-1])  continue;\n        int st=i-(k-1);\n        int up=((st%2==i%2)?2:1),up2=3-up;\n        if(i%2){\n          int x=odd[i][a[i]]-(st-up>=0?odd[st-up][a[i]]:0);\n          int y=even[i-1][a[i-1]]-(st-up2>=0?even[st-up2][a[i-1]]:0);\n          if((x+y)==k){\n            cnt++;\n          }\n        }\n        else{\n          int x=even[i][a[i]]-(st-up>=0?even[st-up][a[i]]:0);\n          int y=odd[i-1][a[i-1]]-(st-up2>=0?odd[st-up2][a[i-1]]:0);\n          if((x+y)==k){\n            cnt++;\n          }\n        }\n      }\n      return cnt;\n    }\n};",
    "submit_ts": "1720279318",
    "subm_id": "1311746388"
}