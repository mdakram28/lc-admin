{
    "username": "tinnamchoi",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define endl '\\n'\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n\nclass SegTree { // max segtree\nprivate:\n    int n;\n    vector<int> tree;\n    \n    void update(int v, int tl, int tr, int i, int val) {\n        if (tl == tr) {\n            tree[v] = val;\n        } else {\n            int tm = (tl + tr) / 2;\n            if (i <= tm) {\n                update(2 * v + 1, tl, tm, i, val);\n            } else {\n                update(2 * v + 2, tm + 1, tr, i, val);\n            }\n            tree[v] = max(tree[2 * v + 1], tree[2 * v + 2]);\n        }\n    }\n    \n    int query(int v, int tl, int tr, int l, int r) {\n        if (l > r) {\n            return 0;\n        }\n        if (l == tl && r == tr) {\n            return tree[v];\n        }\n        int tm = (tl + tr) / 2;\n        return max(query(2 * v + 1, tl, tm, l, min(r, tm)), query(2 * v + 2, tm + 1, tr, max(l, tm + 1), r));\n    }\npublic:\n    SegTree(int n) {\n        this->n = n;\n        tree.resize(4 * n, 0);\n    }\n\n    void update(int i, int val) {\n        update(0, 0, n - 1, i, val);\n    }\n\n    int query(int l, int r) {\n        return query(0, 0, n - 1, l, r);\n    }\n};\n\n#define MAXN 50010\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        set<int> obstacles;\n        \n        SegTree st(MAXN);\n        \n        vector<bool> ans;\n        \n        for (const auto& q : queries) {\n            if (q[0] == 1) {\n                auto after = obstacles.lower_bound(q[1]);\n                if (after != obstacles.end()) {\n                    st.update(*after, *after - q[1]);\n                }\n                if (after != obstacles.begin()) {\n                    auto before = prev(after);\n                    st.update(q[1], q[1] - *before);\n                } else {\n                    st.update(q[1], q[1]);\n                }\n                obstacles.insert(q[1]);\n            } else {\n                int x = q[1], sz = q[2];\n                if (obstacles.lower_bound(x) == obstacles.begin()) {\n                    if (x >= sz) {\n                        ans.push_back(true);\n                    } else {\n                        ans.push_back(false);\n                    }\n                } else {\n                    int before = *prev(obstacles.lower_bound(x));\n                    int r = st.query(0, before);\n                    if (max(r, x - before) >= sz) {\n                        ans.push_back(true);\n                    } else {\n                        ans.push_back(false);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716649111.0
}