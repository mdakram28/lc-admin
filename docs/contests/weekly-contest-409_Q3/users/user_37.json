{
    "username": "wjli",
    "submission": "\n// COPY ALL MACROS BELOW\n\ntypedef long long LL;\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define LB lower_bound\n#define UB upper_bound\n#define SZ(x) ((int)x.size())\n#define LEN(x) ((int)x.length())\n#define ALL(x) begin(x), end(x)\n#define RSZ resize\n#define ASS assign\n#define REV(x) reverse(x.begin(), x.end());\n#define trav(a, x) for (auto& a : x)\ntypedef pair<LL, LL> PL;\ntypedef vector<LL> VL;\ntypedef vector<PL> VPL;\ntypedef vector<VL> VVL;\ntypedef vector<VVL> VVVL;\ntypedef vector<VVVL> VVVVL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PI;\ntypedef vector<int> VI;\ntypedef vector<PI> VPI;\ntypedef vector<vector<int>> VVI;\ntypedef vector<vector<PI>> VVPI;\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\n#define FOR(i, n) for (int i = 0; i < n; i++) \n#define FOR1(i, n) for (int i = 1; i <= n; i++) \n#define SORT(x) sort(x.begin(), x.end())\n#define RSORT(x) sort(x.rbegin(), x.rend())\n#define SUM(x) accumulate(x.begin(), x.end(), 0LL)\n\n\ntemplate <typename T>\nclass segment_tree {\n    vector<T> t;\n    T VERYBIG;\n    bool ISMAXRANGE;\n    int size;\npublic:\n    segment_tree(int n, bool range_max = true) {\n        if (is_same<T, int>::value) VERYBIG = (1 << 30);\n        else if (is_same<T, LL>::value) VERYBIG = (1LL << 60);\n        //else if (is_same<T, PII>::value) VERYBIG = PII({ 1E9, 1E9 });\n        //else if (is_same<T, PLL>::value) VERYBIG = { 1LL << 60, 1LL << 60 };\n\n        ISMAXRANGE = range_max;\n\n        if (ISMAXRANGE) t.assign(4 * n + 1, 0);\n        else t.assign(4 * n + 1, VERYBIG);\n        size = n;\n    }\n\n    void initialize_array(vector<T>& v) {\n        initialize_with_array(1, 0, size - 1, v);\n    }\n\n    void initialize_with_array(int startpos, int l, int r, vector<T>& v) {\n        if (l == r) {\n            t[startpos] = v[l];\n        }\n        else {\n            int m = (l + r) / 2;\n            initialize_with_array(2 * startpos, l, m, v);\n            initialize_with_array(2 * startpos + 1, m + 1, r, v);\n\n            if (ISMAXRANGE == 1) t[startpos] = max(t[startpos * 2], t[startpos * 2 + 1]);\n            else  t[startpos] = min(t[startpos * 2], t[startpos * 2 + 1]);\n        }\n    }\n\n    void update(int index, T val) { // insert val into location index\n        update_full(1, 0, size - 1, index, val);\n    }\n\n    void update_full(int startpos, int l, int r, int index, T val) {\n        if (l == r) {\n            t[startpos] = val;\n        }\n        else {\n            int m = (l + r) / 2;\n            if (index <= m) update_full(2 * startpos, l, m, index, val);\n            else update_full(2 * startpos + 1, m + 1, r, index, val);\n\n            if (ISMAXRANGE) t[startpos] = max(t[startpos * 2], t[startpos * 2 + 1]);\n            else t[startpos] = min(t[startpos * 2], t[startpos * 2 + 1]);\n        }\n    }\n\n    T query(int l, int r) {  // get range min/max between l and r\n        if (l > r) {\n            if (ISMAXRANGE) return 0;\n            else return VERYBIG;\n        }\n        return query_full(1, 0, size - 1, l, r);\n    }\n\n    T query_full(int startpos, int left, int right, int l, int r) {\t // left/right = current range, l/r = intended query range\n        if ((left >= l) && (right <= r)) return t[startpos];\n        int m = (left + right) / 2;\n        T ans;\n        if (ISMAXRANGE) ans = -VERYBIG;\n        else ans = VERYBIG;\n        if (m >= l) {\n            if (ISMAXRANGE) ans = max(ans, query_full(startpos * 2, left, m, l, r));\n            else ans = min(ans, query_full(startpos * 2, left, m, l, r));\n        }\n        if (m + 1 <= r) {\n            if (ISMAXRANGE) ans = max(ans, query_full(startpos * 2 + 1, m + 1, right, l, r));\n            else ans = min(ans, query_full(startpos * 2 + 1, m + 1, right, l, r));\n        }\n        return ans;\n    }\n};\n\n\ntemplate <typename T>\nclass fenwick_tree {\npublic:\n    vector<T> fenw;\n    int n;\n\n    fenwick_tree(int _n) : n(_n) {\n        fenw.resize(n);\n    }\n\n    fenwick_tree() {\n\n    }\n\n    void initialize(int _n) {\n        fenw.assign(_n, 0);\n        n = _n;\n    }\n\n    void update(int x, T v) {\n        while (x < n) {\n            fenw[x] += v;\n            x |= (x + 1);\n            //x += (x & (-x));\n        }\n    }\n\n    T query(int x) {\n        T v{};\n        while (x >= 0) {\n            v += fenw[x];\n            x = (x & (x + 1)) - 1;\n        }\n        return v;\n    }\n\n    T query_full(int a, int b) {\t\t// range query\n        if ((a == 0) || (b == 0) || (a > b)) return 0;\n        return query(b) - ((a <= 1) ? 0 : query(a - 1));\n    }\n};\n\nclass Solution {\npublic:\n\tvector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n\t\tint m = queries.size(), i, j, k, anss = n - 1;\n\t\tVI from(n), to(n), save(n, 0);\n        FOR(i, n) {\n            from[i] = i + 1;\n            to[i] = i - 1;\n        }\n\n        segment_tree<int> stmax(n, true), stmin(n, false);\n        stmax.initialize_array(from);\n        stmin.initialize_array(to);\n\n        fenwick_tree<int> ft(n + 10);\n\n\t\tVI ans(m);\n\t\tFOR(mm, m) {\n\t\t\tint l = queries[mm][0], r = queries[mm][1];\n\n            int lmax = stmax.query(0, l);\n            if (lmax >= r) {\n                ans[mm] = anss;\n                continue;\n            }\n\n            int rmin = stmin.query(r, n - 1);\n            if (rmin <= l) {\n                ans[mm] = anss;\n                continue;\n            }\n\n            int ss = ft.query_full(l + 1, r), delta = r - l - 1 - ss;\n            anss -= delta;\n            ft.update(l + 1, delta);\n\n            from[l] = r;\n            to[r] = l;\n            stmax.update(l, r);\n            stmin.update(r, l);\n\n            ans[mm] = anss;\n\t\t}\n\n        return ans;\n\t}\n};\n",
    "submit_ts": "1722742994",
    "subm_id": "1343781877"
}