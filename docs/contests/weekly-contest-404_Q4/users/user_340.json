{
    "username": "bob314",
    "submission": "class Solution {\npublic:\n    \n    void dfs(int x, int p, vector<vector<int>>& al, vector<int>& dist) {\n        for (int v : al[x]) {\n            if (v == p) continue;\n            dist[v] = dist[x] + 1;\n            dfs(v, x, al, dist);\n        }\n    }\n\n        \n    int findDiam(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vector<vector<int>> al(n);\n        for (auto e : edges) {\n            al[e[0]].push_back(e[1]);\n            al[e[1]].push_back(e[0]);\n        }\n        \n        vector<int> dist(n);\n        \n        dist[0] = 0;\n        dfs(0, -1, al, dist);\n\n        int mxInd = max_element(dist.begin(), dist.end()) - dist.begin();\n        dist[mxInd] = 0;\n        dfs(mxInd, -1, al, dist);\n        \n        return *max_element(dist.begin(), dist.end());\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int diam1 = findDiam(edges1);\n        int diam2 = findDiam(edges2);\n        \n        int ans1 = (diam1 + 1) / 2;\n        int ans2 = (diam2 + 1) / 2;\n        \n        return max({ans1 + ans2 + 1, diam1, diam2});\n    }\n};",
    "submit_ts": "1719717984",
    "subm_id": "1304405809"
}