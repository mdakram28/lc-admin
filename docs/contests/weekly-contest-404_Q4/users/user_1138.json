{
    "username": "jason7708",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1, m = edges2.size() + 1;\n        vector<vector<int>> g1(n), g2(m);\n        vector<int> deg1(n, 0), deg2(m, 0);\n        for(const auto& edge :edges1) {\n            g1[edge[0]].push_back(edge[1]);\n            g1[edge[1]].push_back(edge[0]);\n            deg1[edge[0]]++;\n            deg1[edge[1]]++;\n        }\n        for(const auto& edge :edges2) {\n            g2[edge[0]].push_back(edge[1]);\n            g2[edge[1]].push_back(edge[0]);\n            deg2[edge[0]]++;\n            deg2[edge[1]]++;\n        }\n        int mx1 = 1, mx2 = 1;\n        auto dia = [] (const vector<vector<int>>& g, int& mx) {\n            auto dfs = [&] (auto&& dfs, int cur, int pre) ->int {\n                int ret = 0;\n                for(int node : g[cur]) {\n                    if(node == pre) continue;\n                    auto r = dfs(dfs, node, cur);\n                    mx = max(mx, ret + r);\n                    ret = max(ret, r);\n                }\n                return ret + 1;\n            };\n            dfs(dfs, 0, -1);\n            return mx;\n        };\n\n        auto len1 = dia(g1, mx1);\n        auto len2 = dia(g2, mx2);\n        // cout << len1 << ' ' << len2 << '\\n';\n        auto longest = [] (const vector<vector<int>>& g, vector<int>& deg, int n) {\n            if(n <= 2) {\n                return n;\n            }\n            queue<int> q;\n            // vector<int> l(n, 0);\n            for(int i=0; i<n; i++) {\n                if(deg[i] == 1) {\n                    q.push(i);\n                    // l[i]++;\n                }\n            }\n            // cout << \"q:\" << q.size() << '\\n';\n            \n            int len = 0, cnt = n, mx = 1;\n            while(!q.empty()) {\n                int size = q.size();\n                for(int i=0; i<size; i++) {\n                    int cur = q.front();\n                    q.pop();\n                    // mx = max(mx, l[cur]);\n                    // cout << \"cur:\" << cur << ' ';\n                    cnt--;\n                    for(int node : g[cur]) {\n                        deg[node]--;\n                        if(deg[node] == 1) {\n                            q.push(node);\n                            // l[node] = l[cur] + 1;\n                        }\n                    }\n                }\n                // cout << '\\n';\n                len++;\n                if(cnt == 2) {\n                    // cout << len << '\\n';\n                    return len + 2;\n                }\n            }\n            \n            return len;\n        };\n        auto res1 = longest(g1, deg1, n);\n        auto res2 = longest(g2, deg2, m);\n        // cout << res1 << ' ' <<  res2;\n        // return longest(g1, deg1, n) + longest(g2, deg2, m) - 1;\n        return max(res1 + res2 - 1, max(len1, len2));\n    }\n};",
    "submit_ts": 1719719593.0
}