{
    "username": "anantapaul",
    "submission": "class Solution {\npublic:\n \n    // bool canReachCorner(int X, int Y, vector<vector<int>>& c) {\n    //     int n=c.size();\n    //     for(int i=0;i<n;i++){\n    //     bool left=false;\n    //     bool right=false;\n    //         if(c[i][0]+c[i][2]>=X||c[i][1]+c[i][2]<=0)right=true;\n    //         if(c[i][0]+c[i][2]>=X||c[i][1]+c[i][2]<=0)left=true;\n    //         if(d(c[i][0],c[i][1],0,0)<=c[i][2]||d(c[i][0],c[i][1],X,Y)<=c[i][2])return false;\n    //         for(int j=i+1;j<n;j++){\n    //            if(c[j][0]+c[j][2]>=X||c[j][1]+c[j][2]<=0)right=true;\n    //         if(c[j][0]+c[j][2]>=X||c[j][1]+c[j][2]<=0)right=true;\n    //         if(d(c[j][0],c[j][1],0,0)<=c[j][2]||d(c[j][0],c[j][1],X,Y)<=c[j][2])return false;\n            \n    //         if(left&&right)return false;\n    //         }\n    //     }\n    //     return true;\n    // }\n\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <iostream>\n\nbool bfs(const std::vector<std::vector<int>>& graph, int start, int target1, int target2, int nodes) {\n    std::queue<int> q;\n    std::vector<bool> visited(nodes + 4, false);\n    q.push(start);\n    visited[start] = true;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : graph[u]) {\n            if (!visited[v]) {\n                q.push(v);\n                visited[v] = true;\n            }\n        }\n    }\n    return visited[target1] || visited[target2];\n}\n\nbool canReachCorner(int X, int Y, const std::vector<std::vector<int>>& circles) {\n    int numCircles = circles.size();\n    std::vector<std::vector<int>> graph(numCircles + 4);\n\n    for (int i = 0; i < numCircles; ++i) {\n        int x = circles[i][0];\n        int y = circles[i][1];\n        int r = circles[i][2];\n\n        if (x <= r) {\n            graph[numCircles].push_back(i);\n            graph[i].push_back(numCircles);\n        }\n        if (X - x <= r) {\n            graph[numCircles + 2].push_back(i);\n            graph[i].push_back(numCircles + 2);\n        }\n        if (y <= r) {\n            graph[numCircles + 1].push_back(i);\n            graph[i].push_back(numCircles + 1);\n        }\n        if (Y - y <= r) {\n            graph[numCircles + 3].push_back(i);\n            graph[i].push_back(numCircles + 3);\n        }\n        for (int j = i + 1; j < numCircles; ++j) {\n            int xj = circles[j][0];\n            int yj = circles[j][1];\n            int rj = circles[j][2];\n            long long dx = static_cast<long long>(x) - xj;\n            long long dy = static_cast<long long>(y) - yj;\n            double distance = std::sqrt(dx * dx + dy * dy);\n            int radiusSum = r + rj;\n            if (radiusSum >= distance) {\n                graph[i].push_back(j);\n                graph[j].push_back(i);\n            }\n        }\n    }\n\n    bool isBlocked = false;\n    isBlocked = std::max(isBlocked, bfs(graph, numCircles, numCircles + 1, numCircles + 2, numCircles + 4));  // Check for bottom-left corner\n    isBlocked = std::max(isBlocked, bfs(graph, numCircles + 3, numCircles + 2, numCircles + 1, numCircles + 4));  // Check for top-right corner\n\n    return isBlocked == false;\n}\n\n};",
    "submit_ts": "1722139188",
    "subm_id": "1335810531"
}