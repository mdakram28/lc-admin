{
    "username": "Kitetsu",
    "submission": "class Solution:\n    def bfs(self, graph, start, target1, target2, nodes):\n        q = deque([start])\n        visited = [0] * (nodes + 4)\n        visited[start] = 1\n\n        while q:\n            u = q.popleft()\n            for v in graph[u]:\n                if not visited[v]:\n                    q.append(v)\n                    visited[v] = 1\n        \n        return visited[target1] or visited[target2]\n\n    def create_graph(self, X, Y, circles2):\n        circles = [((x, y), r) for x, y, r in circles2]\n        num_circles = len(circles2)\n        graph = [[] for _ in range(num_circles + 4)]\n\n        for i in range(num_circles):\n            x, y = circles2[i][0], circles2[i][1]\n            r = circles2[i][2]\n\n            self.connect_to_borders(graph, x, y, r, i, X, Y, num_circles)\n            self.connect_overlapping_circles(graph, circles2, i, x, y, r, num_circles)\n        \n        return graph\n\n    def connect_to_borders(self, graph, x, y, r, i, X, Y, num_circles):\n        if x <= r:\n            graph[num_circles].append(i)\n            graph[i].append(num_circles)\n        if X - x <= r:\n            graph[num_circles + 2].append(i)\n            graph[i].append(num_circles + 2)\n        if y <= r:\n            graph[num_circles + 1].append(i)\n            graph[i].append(num_circles + 1)\n        if Y - y <= r:\n            graph[num_circles + 3].append(i)\n            graph[i].append(num_circles + 3)\n\n    def connect_overlapping_circles(self, graph, circles2, i, x, y, r, num_circles):\n        for j in range(i + 1, num_circles):\n            x2, y2 = circles2[j][0], circles2[j][1]\n            r2 = circles2[j][2]\n            distance = math.sqrt((x - x2)**2 + (y - y2)**2)\n            radius_sum = r + r2\n            if radius_sum >= distance:\n                graph[i].append(j)\n                graph[j].append(i)\n\n    def canReachCorner(self, X, Y, circles2):\n        graph = self.create_graph(X, Y, circles2)\n        num_circles = len(circles2)\n\n        is_blocked = 0\n        is_blocked = max(is_blocked, self.bfs(graph, num_circles, num_circles + 1, num_circles + 2, num_circles + 4))  # Check for bottom-left corner\n        is_blocked = max(is_blocked, self.bfs(graph, num_circles + 3, num_circles + 2, num_circles + 1, num_circles + 4))  # Check for top-right corner\n\n        return not is_blocked\n\n",
    "submit_ts": "1722137014",
    "subm_id": "1335751655"
}