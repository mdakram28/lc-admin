{
    "username": "lixiangfan97",
    "submission": "class Solution {\npublic:\n    #define ll long long\n    // map<ll, int> cost1;\n    unordered_map<ll, int> cost2;\n    inline int find_cost(ll h2) {\n        // if (cost1.count(h1) == 0 ||\n        // if (cost2.count(h2) == 0) {\n        //     return -1;\n        // }\n        auto iter =  cost2.find(h2);\n        return (iter == cost2.end()) ? -1 : iter->second;\n        // return cost2[h2];\n    }\n    static constexpr int MAXN = 50010;\n    // ll pre_h1[MAXN];\n    ll pre_h2[MAXN];\n    // ll base1 = 29;\n    ll base2 = 131;\n    // ll MOD1 = 1e9+7;\n    ll MOD2 = 1e9+9;\n\n    ll qpow(ll x, int n, ll MOD) {\n        ll ret = 1;\n        while(n) {\n            if (n & 1) {\n                ret *= x;\n                ret %= MOD;\n            }\n            n >>= 1;\n            x = (x * x) % MOD;\n        }\n        return ret;\n    }\n\n    ll get_hash(int from, int to) {\n        // ll h1 = (pre_h1[to+1] + MOD1 - (pre_h1[from] * qpow(base1, to-from+1, MOD1) % MOD1)) % MOD1;\n        ll h2 = (pre_h2[to+1] + MOD2 - (pre_h2[from] * qpow(base2, to-from+1, MOD2) % MOD2)) % MOD2;\n        // return make_pair(h1, h2);\n        return h2;\n    }\n\n    ll dp[MAXN];\n    const ll INF = 1e18; \n\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        set<int> word_lengths;\n        int idx = 0;\n        for (const auto& w: words) {\n            word_lengths.insert(w.size());\n            ll h1 = 0, h2 = 0;\n            for (const char& c: w) {\n                // h1 = (h1 * base1 + (c - 'a' + 1)) % MOD1;\n                h2 = (h2 * base2 + (c - 'a' + 1)) % MOD2;\n            }\n            // if (cost1.count(h1) == 0) {\n            //     cost1[h1] = costs[idx];\n            // } else {\n            //     cost1[h1] = min(cost1[h1], costs[idx]);\n            // }\n\n            if (cost2.count(h2) == 0) {\n                cost2[h2] = costs[idx];\n            } else {\n                cost2[h2] = min(cost2[h2], costs[idx]);\n            }\n            idx++;\n        }\n        const int n = (int)target.size();\n        pre_h2[0] = 1;\n        for (int i = 0; i < (int)target.size(); ++i) {\n            // pre_h1[i+1] = pre_h1[i] * base1 + (target[i] - 'a' + 1);\n            pre_h2[i+1] = pre_h2[i] * base2 + (target[i] - 'a' + 1);\n            // pre_h1[i+1] %= MOD1;\n            pre_h2[i+1] %= MOD2;\n        }\n        dp[0] = 0;\n        for (int i = 0; i < (int)target.size(); ++i) {\n            dp[i+1] = INF;\n            for (int l: word_lengths) {\n                if (l > i + 1) {\n                    break;\n                }\n                if (dp[i+1-l] < dp[i+1] ) {\n                    auto hp = get_hash(i+1-l, i);\n                    int cost = find_cost(hp);\n                    if (cost > 0) {\n                        dp[i+1] = min(dp[i+1], dp[i+1-l] + cost);\n                    }\n                }\n            }\n        }\n        return (dp[n] >= INF) ? -1 : (int)dp[n];\n    }\n};",
    "submit_ts": "1720322131",
    "subm_id": "1312341555"
}