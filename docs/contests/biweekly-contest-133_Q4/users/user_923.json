{
    "username": "resotto",
    "submission": "class Solution {\n    // private int mod = (int) 1e9 + 7, n;\n    // private Integer[][][] memo;\n    // public int numberOfPermutations(int n, int[][] requirements) {\n    //     this.n = n;\n    //     Arrays.sort(requirements, (a, b) -> a[0] - b[0]); // end index ascending\n    //     memo = new Integer[n][n][402];\n    //     return dfs(0, 0, 0, 0, requirements);\n    // }\n    // private int dfs(int i, int pre, int k, int j, int[][] reqs) {\n    //     if (j < reqs.length && i == reqs[j][0]+1 && k != reqs[j][1]) { // WA: need to have exact count, and i should be end+1\n    //         return 0;\n    //     } else if (i == n) {\n    //         return 1;\n    //     } else if (memo[i][pre][k] == null) {\n    //         int nj = j < reqs.length && i == reqs[j][0]+1 ? j+1 : j;\n    //         int ans = dfs(i+1, i, k, nj, reqs) % mod; // pick n-1th value at n-1th index => no inversion happens\n    //         for (int l = 0; l < i; l++) {\n    //             // pick other values at n-1th index => some inversions happen\n    //             ans = (ans + dfs(i+1, l, Math.min(401, k + l + 1), nj, reqs)) % mod;\n    //         }\n    //         memo[i][pre][k] = ans;\n    //     }\n    //     return memo[i][pre][k];\n    // }    \n    \n    \n    private int mod = (int) 1e9 + 7, n;\n    private Integer[][] memo;\n    public int numberOfPermutations(int n, int[][] requirements) {\n        this.n = n;\n        Arrays.sort(requirements, (a, b) -> a[0] - b[0]); // end index ascending\n        memo = new Integer[n][402];\n        return dfs(0, 0, 0, requirements);\n    }\n    private int dfs(int i, int k, int j, int[][] reqs) {\n        if (j < reqs.length && i == reqs[j][0]+1 && k != reqs[j][1]) { // WA: need to have exact count, and i should be end+1\n            return 0;\n        } else if (i == n) {\n            return 1;\n        } else if (memo[i][k] == null) {\n            int nj = j < reqs.length && i == reqs[j][0]+1 ? j+1 : j;\n            int ans = dfs(i+1, k, nj, reqs) % mod; // pick n-1th value at n-1th index => no inversion happens\n            for (int l = 0; l < i; l++) {\n                // pick other values at n-1th index => some inversions happen\n                ans = (ans + dfs(i+1, Math.min(401, k + l + 1), nj, reqs)) % mod;\n            }\n            memo[i][k] = ans;\n        }\n        return memo[i][k];\n    }    \n    \n    \n    // private int dfs(int i, int k, int j, int[][] reqs) {\n    //     if (j < reqs.length && i == reqs[j][0]+1 && k != reqs[j][1]) { // WA: need to have exact count + i == end+1\n    //         return 0; // didn't satisfy the reqiurement\n    //     } else if (i == n) {\n    //         return 1;\n    //     } else if (memo[i][k] == null) {\n    //         int nj = j < reqs.length && i == reqs[j][0]+1 ? j+1 : j;\n    //         int ans = dfs(i+1, k, nj, reqs) % mod; // pick nth value at n-1th index => no inversion happens\n    //         ans = (ans + ((n-1) - i) * dfs(i+1, k + (n-1) - i, nj, reqs)) % mod; // pick other values at n-1th index => some inversions happen\n    //         memo[i][k] = ans;\n    //     }\n    //     return memo[i][k];\n    // }\n}\n\n/*\n    0-indexed permutation (0 to n-1)\n    DP (intermediate state exists for permutation)  => Integer[n][n]\n    => when pick nth (jth) value, number of nums[i] > nums[j]\n    \n    => whether we place nth value (maximum in n permutations) on n-1th or not\n    \n    [3,2,1,0] => num of inversion = (0,1),(0,2),(0,3),(1,2),(1,3),(2,3) = 6 (4C2)\n    [x,x,x,2] => n-1 (3) - v (2) = 1 (only 3)\n    [x,x,x,1] => n-1 (3) - v (1) = 2 (only 2,3)\n    \n    \n    private int mod = (int) 1e9 + 7, n;\n    private Integer[][] memo;\n    public int numberOfPermutations(int n, int[][] requirements) {\n        this.n = n;\n        Arrays.sort(requirements, (a, b) -> a[0] - b[0]); // end index ascending\n        memo = new Integer[n][401];\n        return dfs(0, 0, 0, requirements);\n    }\n    private int dfs(int i, int k, int j, int[][] reqs) {\n        if (i == n) {\n            return 1;\n        } else if (j < reqs.length && i == reqs[j][0] && k != reqs[j][1]) { // WA: need to have exact count\n            return 0; // didn't satisfy the reqiurement\n        } else if (memo[i][k] == null) {\n            int nj = j < reqs.length && i == reqs[j][0] ? j+1 : j;\n            int ans = dfs(i+1, k, nj, reqs) % mod; // pick nth value at n-1th index => no inversion happens\n            ans = (ans + ((n-1) - i) * dfs(i+1, k + (n-1) - i, nj, reqs)) % mod; // pick other values at n-1th index => some inversions happen\n            memo[i][k] = ans;\n        }\n        return memo[i][k];\n    }    \n    \n    300C2 = 300 * 299 / 2 = 150 * 299\n    \n3\n[[2,0]]\n=> index 1 outofbounds ?\n=> 1 [0,1,2]\n\n\n5\n[[0,0],[1,0],[2,0],[4,1]]\n=> 1 [0,1,2,4,3]\n*/",
    "submit_ts": "1719070650",
    "subm_id": "1296828315"
}