{
    "username": "yzhao1",
    "submission": "class RollingHash {\npublic:\n    RollingHash(const std::string &str, int base = 31, int mod = 1e9 + 7)\n        : s(str), BASE(base), MOD(mod), n(str.length()), prefix_hashes(n + 1, 0), power(n + 1, 1) {\n        computeHashes();\n    }\n\n    const std::vector<long long>& getPrefixHashes() const {\n        return prefix_hashes;\n    }\n\n    long long substringHash(int left, int right) const {\n        if (left < 0 || right >= n || left > right) {\n            throw std::out_of_range(\"Invalid substring range\");\n        }\n        long long hash_value = (prefix_hashes[right + 1] - (prefix_hashes[left] * power[right - left + 1]) % MOD + MOD) % MOD;\n        return hash_value;\n    }\n\n    static long long hash(const std::string &str, int base = 31, int mod = 1e9 + 7) {\n        long long hash_value = 0;\n        long long power = 1;\n        for (char ch : str) {\n            hash_value = (hash_value * base + ch) % mod;\n        }\n        return hash_value;\n    }\n\nprivate:\n    std::string s;\n    int BASE;\n    int MOD;\n    int n;\n    std::vector<long long> prefix_hashes;\n    std::vector<long long> power;\n\n    void computeHashes() {\n        for (int i = 0; i < n; ++i) {\n            prefix_hashes[i + 1] = (prefix_hashes[i] * BASE + s[i]) % MOD;\n            power[i + 1] = (power[i] * BASE) % MOD;\n        }\n    }\n};\n\n\n#define ll long long\nclass Solution {\npublic:\n    int rec(int i, int n, vector<int>& dp, RollingHash& rh, map<ll,pair<int,int>>& m) {\n        if(i==n){\n            return 0;\n        }\n        if(dp[i]!=-1){\n            return dp[i];\n        }\n        dp[i] = 1e9;\n        for (auto& p:m){\n            ll hsh=p.first;\n            int len=p.second.second;\n            int cost=p.second.first;\n            if(i+len-1 >= n){\n                continue;\n            }\n            if(hsh == rh.substringHash(i, i+len-1)) {\n                dp[i]=min(dp[i], rec(i+len, n, dp, rh, m) + cost);\n            }\n        }\n        return dp[i];\n    }\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int n=target.size();\n        RollingHash rh(target);\n        map<ll,pair<int,int>> m;\n        for(int i=0;i<words.size();i++) {\n            ll hsh = rh.hash(words[i]);\n            if(!m.count(hsh)){\n                m[hsh]=make_pair(costs[i],words[i].size());\n            }\n            m[hsh]=min(m[hsh], make_pair(costs[i],(int)words[i].size()));\n        }\n        vector<int> dp(n, -1);\n        int ans = rec(0, n, dp, rh, m);\n        if(ans>=1e9) {\n            return -1;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720323434",
    "subm_id": "1312375476"
}