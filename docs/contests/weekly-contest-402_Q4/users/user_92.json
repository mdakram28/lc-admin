{
    "username": "thirdbest",
    "submission": "template<typename T>\nstruct Tree {\n\tstatic constexpr T unit = 0;\n\tT f(T a, T b) { return (a + b); } // (any associative fn)\n\tvector<T> s; T n;\n\tTree(T n = 0, T def = unit) : s(2 * n, def), n(n) {}\n\tvoid update(T pos, T val) {\n\t\tfor (s[pos += n] = val; pos /= 2;)\n\t\t\ts[pos] = f(s[pos * 2], s[pos * 2 + 1]);\n\t}\n\tT query(T b, T e) { // query [b, e)\n\t\tT ra = unit, rb = unit;\n\t\tfor (b += n, e += n; b < e; b /= 2, e /= 2) {\n\t\t\tif (b % 2) ra = f(ra, s[b++]);\n\t\t\tif (e % 2) rb = f(s[--e], rb);\n\t\t}\n\t\treturn f(ra, rb);\n\t}\n};\n\n\n\nclass Solution {\npublic:\n    \n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& q) {\n        int n = size(a);\n        \n        auto f = [&](int i) -> bool {\n            return (a[i - 1] < a[i] && a[i] > a[i + 1]);\n        };\n        \n        Tree tree(n);\n        for (auto i = 1; i < n - 1; ++i) {\n            if (f(i)) tree.update(i, 1);\n        }\n        vector<int> ans;\n        for (auto& k : q) {\n            int t = k[0], x = k[1], y = k[2];\n            if (t == 1) {\n                int res = tree.query(x + 1, y);\n                ans.push_back(res);\n            } else {\n                a[x] = y;\n                if (x + 1 <= n - 1 && x - 1 >= 0) {\n                    if (f(x)) tree.update(x, 1);\n                    else tree.update(x, 0);\n                }\n                if (x <= n - 1 && x - 2 >= 0) {\n                    if (f(x - 1)) tree.update(x - 1, 1);\n                    else tree.update(x - 1, 0);\n                }\n                if (x + 2 <= n - 1 && x >= 0) {\n                    if (f(x + 1)) tree.update(x + 1, 1);\n                    else tree.update(x + 1, 0);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1718505922",
    "subm_id": "1289600214"
}