{
    "username": "anh_tai",
    "submission": "int tree[50000 * 4 + 1];\nint oo = 1e9; \n\nint get(int root, int l, int r, int lq, int rq){\n    if (lq > r || rq < l){\n        return oo;\n    }\n    if (lq <= l && r <= rq){\n        return tree[root];\n    }\n    \n    int m = (l + r) >> 1;\n    return std::min(get(root * 2 + 1, l, m, lq, rq), \n                    get(root * 2 + 2, m+1, r, lq, rq));\n}\n\nvoid upd(int root, int l, int r, int pos, int val){ \n    if (l == r){\n        tree[root] = val;\n        return;\n    }\n    \n    int m = (l + r) >> 1;\n    if (m >= pos){\n        upd(root * 2 + 1, l, m, pos, val);\n    }\n    else{\n        upd(root * 2 + 2, m + 1, r, pos, val);\n    }\n    tree[root] = std::min(tree[root * 2 + 1], tree[root * 2 + 2]); \n}\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int lq = queries.size();\n        int threshold = min(50000, 3*lq);\n        for (int u = 0; u < threshold * 4; u++){\n            tree[u] = oo; \n        }\n        \n        vector<bool> ans;\n        map<int, set<int>> mp;\n        set<pair<int, int>> segs;\n\n        mp[threshold].insert(threshold);\n        segs.insert(make_pair(0, threshold)); \n        upd(0, 0, threshold, threshold, threshold);\n        \n        for (vector<int> query : queries){\n            if (query[0] == 1){\n                int x = query[1];\n                auto it = segs.lower_bound(make_pair(x, -1));\n                it = prev(it);\n                int start = it->first;\n                int end = it->second;\n                \n                mp[end - start].erase(end);\n                upd(0,0,threshold,end-start,!mp[end-start].size()?oo:*mp[end-start].begin());\n                \n                segs.erase(it);\n                segs.insert(make_pair(start, x));\n                segs.insert(make_pair(x, end));\n                \n                mp[x - start].insert(x);\n                mp[end - x].insert(end);\n                \n                upd(0,0,threshold, x-start,*mp[x-start].begin());\n                upd(0,0,threshold, end-x,*mp[end-x].begin());\n                \n                //cout << x - start << \" \" << *mp[x-start].begin() << \" \" << end - x << \" \" <<  *mp[end-x].begin()<< \"\\n\"; \n            }    \n            else{\n                int x=query[1], sz=query[2];\n                int minEnd=get(0,0,threshold,sz,threshold);\n                // cout << \"segs: \\n\";\n                // for (auto it : segs){\n                //     cout << it.first << \" \" << it.second << \"\\n\";\n                // }\n                // cout << \"end\\n\"; \n                //cout << x << \" \" << sz << \" \" << minEnd << \"\\n\"; \n                if (minEnd<=x){\n                    ans.push_back(true);continue;\n                }\n                \n                auto it = segs.lower_bound(make_pair(x, -1));\n                it = prev(it);\n                int start = it->first;\n                int end = it->second;\n                if (x - start >= sz){\n                    ans.push_back(true);\n                }\n                else{\n                    ans.push_back(false);\n                }\n            }\n        }\n        \n        return ans; \n    }\n};",
    "submit_ts": 1716651370.0
}