{
    "username": "sarvagya2545",
    "submission": "template <typename T>\nclass SegmentTree {\nprivate:\n    // need to only define these values to use this implementation\n    using F = function<T(T&, T&)>;\n    int n;\n    vector<T> seg_tree;\n    T zero_val;\n    F query_func;\n    F update_func;\n\n    void build(vector<T> &nums, int left, int right, int node = 0) {\n        if(left > right) {\n            return;\n        }\n\n        if(left == right) {\n            seg_tree[node] = nums[left];\n            return;\n        }\n\n        int mid = left + (right - left) / 2;\n\n        build(nums, left, mid, 2 * node + 1);\n        build(nums, mid + 1, right, 2 * node + 2);\n        \n        seg_tree[node] = query_func(seg_tree[2 * node + 1], seg_tree[2 * node + 2]);\n    }\n\n    T query(int q_left, int q_right, int st, int en, int node) {\n        if(st > en) {\n            return zero_val;\n        }\n\n        if(st >= q_left and en <= q_right) {\n            return seg_tree[node];\n        }\n\n        if(max(st, q_left) > min(en, q_right)) {\n            return zero_val;\n        }\n\n        int mid = st + (en - st) / 2;\n        T ans_l = query(q_left, q_right, st, mid, 2 * node + 1);\n        T ans_r = query(q_left, q_right, mid + 1, en, 2 * node + 2);\n        return query_func(ans_l, ans_r);\n    }\n\n    void update(int index, int left, int right, int node, T val) {\n        if(right == left) {\n            update_func(seg_tree[node], val);\n            return;\n        }\n\n        int mid = left + (right - left) / 2;\n        if(index <= mid) {\n            update(index, left, mid, 2 * node + 1, val);\n        } else {\n            update(index, mid + 1, right, 2 * node + 2, val);\n        }\n\n        seg_tree[node] = query_func(seg_tree[2 * node + 1], seg_tree[2 * node + 2]);\n    }\n\npublic:\n    SegmentTree(vector<T> nums, F query_func, F update_func, T zero_val): n(nums.size()), query_func(query_func), update_func(update_func), zero_val(zero_val) {\n        seg_tree.resize(4 * n, zero_val);\n        build(nums, 0, n - 1);\n    }\n\n    T query(int left, int right) {\n        return query(left, right, 0, n - 1, 0);\n    }\n\n    void update(int index, T val) {\n        update(index, 0, n - 1, 0, val);\n    }\n};\n\nint query_func(int &a, int &b) {\n    return a + b;\n}\n\nint update_func(int &a, int &b) {\n    return a = b;\n}\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> isPeak(n, 0);\n        auto checkPeak = [&] (int index) -> bool {\n            return (not (index == 0 or index == n - 1)) and nums[index] > nums[index + 1] and nums[index] > nums[index - 1];\n        };\n        \n        for(int i = 1; i < n - 1; i++) {\n            if(checkPeak(i)) isPeak[i] = 1;\n        }\n        \n        SegmentTree<int> st(isPeak, query_func, update_func, 0);\n        vector<int> ans;\n        for(auto query: queries) {\n            if(query[0] == 1) {\n                int l = query[1], r = query[2];\n                if(l + 1 <= r - 1) ans.push_back(st.query(l + 1, r - 1));\n                else ans.push_back(0);\n            } else {\n                int i = query[1], v = query[2];\n                nums[i] = v;\n                \n                if(i != 0) st.update(i - 1, checkPeak(i - 1));\n                st.update(i, checkPeak(i));\n                if(i != n - 1) st.update(i + 1, checkPeak(i + 1));\n            }\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": "1718506686",
    "subm_id": "1289627576"
}