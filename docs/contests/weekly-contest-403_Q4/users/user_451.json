{
    "username": "qingczha",
    "submission": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define REP(i, from, to) for(ll i = from;i<to;i++)\n#define RREP(i, from, to) for(ll i = from;i>=to;i--)\n#define complete_unique(a) a.erase(unique(begin(a),end(a)),end(a))\n#define mst(x, a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define rall(a) rbegin(a),rend(a)\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define bitcnt(x) (__builtin_popcountll(x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define EX0 exit(0);\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing db = double;\nusing ld = long double;\nusing VLL = std::vector<ll>;\nusing VI = std::vector<int>;\nusing PII = std::pair<int, int>;\nusing PLL = std::pair<ll, ll>;\n\nusing namespace __gnu_pbds; //required\nusing namespace std;\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nconst ll mod = 1e9 + 7;\n\n\nstring to_string(string s) { return '\"' + s + '\"'; }\n\nstring to_string(const char *s) { return to_string((string) s); }\n\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\n\ntemplate<typename A, typename B>\nstring to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\n\ntemplate<typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x: v) {\n        if (!first) { res += \", \"; }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifdef LOCAL\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) do {} while(0)\n#endif\n\ntemplate<typename T, typename S>\ninline bool upmin(T &a, const S &b) { return a > b ? a = b, 1 : 0; }\n\ntemplate<typename T, typename S>\ninline bool upmax(T &a, const S &b) { return a < b ? a = b, 1 : 0; }\n\n\null twop(ll x) { return 1ULL << x; }\n\nll MOD(ll a, ll m) {\n    a %= m;\n    if (a < 0)a += m;\n    return a;\n}\n\nll inverse(ll a, ll m) {\n    a = MOD(a, m);\n    if (a <= 1)return a;\n    return MOD((1 - inverse(m, a) * m) / a, m);\n}\n\ntemplate<typename T>\nT sqr(T x) { return x * x; }\n\ntemplate<typename T>\nll sz(const T &x) { return x.size(); }\n\nll fast(ll a, ll b, ll mod) {\n    a %= mod;\n    if (b < 0)a = inverse(a, mod), b = -b;\n    ll ans = 1;\n    while (b) {\n        if (b & 1)ans = ans * a % mod;\n        a = a * a % mod;\n        b /= 2;\n    }\n    return ans % mod;\n}\n\nconst ll N = 31;\nint n, m;\n\nclass Solution {\npublic:\n\n    int lo[2][N][N][N][N];\n    int hi[2][N][N][N][N];\n    int dp[N][N][N][N];\n    bool vis[N][N][N][N];\n\n    void dfs(int i, int j, int a, int b) {\n\n        if (i == a && j == b)return;\n        if (i > a || j > b)return;\n        if (i <= 0 || i > n || j <= 0 || j > m)return;\n        if (a <= 0 || a > n || b <= 0 || b > m)return;\n        if (vis[i][j][a][b]) {\n            return;\n        }\n\n        vis[i][j][a][b] = 1;\n        REP(di, 0, 2) {\n            REP(dj, 0, 2) {\n                REP(da, -1, 1) {\n                    REP(db, -1, 1) {\n\n                        if (i + di >= 1 and j + dj >= 1 and a + da <= n and b + db <= m && i + di <= a + da &&\n                            j + dj <= b + db) {\n                            dfs(i + di, j + dj, a + da, b + db);\n                            upmin(lo[0][i][j][a][b], lo[0][i + di][j + dj][a + da][b + db]);\n                            upmin(lo[1][i][j][a][b], lo[1][i + di][j + dj][a + da][b + db]);\n                            upmax(hi[0][i][j][a][b], hi[0][i + di][j + dj][a + da][b + db]);\n                            upmax(hi[1][i][j][a][b], hi[1][i + di][j + dj][a + da][b + db]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    int minimumSum(vector<vector<int>> &g) {\n        mst(lo, 0x3f);\n        mst(dp, 0x3f);\n        mst(hi, 0xcf);\n        mst(vis, 0);\n        n = sz(g), m = sz(g[0]);\n\n        vector<VI> sum(n + 1, VI(m + 1, 0));\n        REP(i, 0, n) {\n            REP(j, 0, m) {\n                if (g[i][j]) {\n                    sum[i + 1][j + 1]++;\n                    lo[0][i + 1][j + 1][i + 1][j + 1] = i + 1;\n                    hi[0][i + 1][j + 1][i + 1][j + 1] = i + 1;\n                    lo[1][i + 1][j + 1][i + 1][j + 1] = j + 1;\n                    hi[1][i + 1][j + 1][i + 1][j + 1] = j + 1;\n                }\n            }\n        }\n        REP(i, 1, n + 1) {\n            REP(j, 1, m + 1) {\n                sum[i][j] += sum[i - 1][j];\n            }\n        }\n        REP(i, 1, n + 1) {\n            REP(j, 1, m + 1) {\n                sum[i][j] += sum[i][j - 1];\n            }\n        }\n\n        auto get_sum = [&](int l1, int r1, int l2, int r2) {\n            return sum[l2][r2] - sum[l1 - 1][r2] - sum[l2][r1 - 1] + sum[l1 - 1][r1 - 1];\n        };\n        auto get_min_rec = [&](int l1, int r1, int l2, int r2) -> ll {\n            if (get_sum(l1, r1, l2, r2) <= 0)return 1000000000ll;\n            if (hi[0][l1][r1][l2][r2] - lo[0][l1][r1][l2][r2] + 1 < 0) {\n                cout << hi[0][l1][r1][l2][r2] << endl;\n                cout << lo[0][l1][r1][l2][r2] << endl;\n                exit(0);\n            }\n            if (hi[1][l1][r1][l2][r2] - lo[1][l1][r1][l2][r2] + 1 < 0) {\n                cout << hi[1][l1][r1][l2][r2] << endl;\n                cout << lo[1][l1][r1][l2][r2] << endl;\n                exit(0);\n            }\n            return (hi[0][l1][r1][l2][r2] - lo[0][l1][r1][l2][r2] + 1) *\n                   (hi[1][l1][r1][l2][r2] - lo[1][l1][r1][l2][r2] + 1);\n        };\n        ll ans = 1e9;\n\n        REP(i, 1, n + 1) {\n            REP(j, 1, m + 1) {\n                REP(a, i, n + 1) {\n                    REP(b, j, m + 1) {\n                         dfs(i, j, a, b);\n                    }\n                }\n            }\n        }\n        REP(hori, 2, n + 1) {\n            REP(hori2, hori + 1, n + 1) {\n                upmin(ans, get_min_rec(1, 1, hori - 1, m)\n                           + get_min_rec(hori, 1, hori2 - 1, m)\n                           + get_min_rec(hori2, 1, n, m));\n            }\n            REP(vert, 2, m + 1) {\n                upmin(ans, get_min_rec(1, 1, hori - 1, m)\n                           + get_min_rec(hori, 1, n, vert - 1) +\n                           +get_min_rec(hori, vert, n, m));\n                upmin(ans, get_min_rec(hori, 1, n, m)\n                           + get_min_rec(1, 1, hori - 1, vert - 1) +\n                           +get_min_rec(1, vert, hori - 1, m));\n            }\n        }\n        REP(vert, 2, m + 1) {\n            REP(vert2, vert + 1, m + 1) {\n                upmin(ans, get_min_rec(1, 1, n, vert - 1)\n                           + get_min_rec(1, vert, n, vert2 - 1)\n                           + get_min_rec(1, vert2, n, m));\n            }\n            REP(hori, 2, n + 1) {\n                upmin(ans, get_min_rec(1, 1, n, vert - 1)\n                           + get_min_rec(1, vert, hori - 1, m) +\n                           +get_min_rec(hori, vert, n, m));\n                upmin(ans, get_min_rec(1, 1, hori - 1, vert - 1)\n                           + get_min_rec(hori, 1, n, vert - 1) +\n                           +get_min_rec(1, vert, n, m));\n            }\n\n        }\n\n\n        return ans;\n    }\n};\n\n#ifdef LOCAL\n\n\nnamespace SOLVE {\n    void main() {\n\n    }\n}\n\n#ifdef __APPLE__\n#define INPUT_FILE \"/Users/qingczha/ClionProjects/LeetCode/input.txt\"\n#define OUTPUT_FILE \"/Users/qingczha/ClionProjects/LeetCode/output.txt\"\n#elifdef _WIN64\n#define INPUT_FILE \"C:/Users/qingczha/CLionProjects/playground/input.txt\"\n#define OUTPUT_FILE \"C:/Users/qingczha/CLionProjects/playground/output.txt\"\n#elifdef __linux__\n#define INPUT_FILE \"/home/qingczha/proj/Playground/input.txt\"\n#define OUTPUT_FILE \"/home/qingczha/proj/Playground/output.txt\"\n#endif\n\nsigned main() {\n    fr(INPUT_FILE);\n    fw(OUTPUT_FILE);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    int t = 1;\n//    cin >> t;\n    for (int i = 1; i <= t; i++) {\n//        cout<<\"Case #\"<<i<<\": \";\n        SOLVE::main();\n\n    }\n\n\n\n\n\n\n\n\n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n\n\n\n\n\n\n    return 0;\n}\n\n#endif\n",
    "submit_ts": 1719114855.0
}