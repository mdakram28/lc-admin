{
    "username": "SaveVMK",
    "submission": "class Solution {\n    public int minimumDistance(int[][] pts) {\n        int n = pts.length;\n        TreeMap<Integer, ArrayList<Integer>> pl = new TreeMap<>();\n        TreeMap<Integer, ArrayList<Integer>> mi = new TreeMap<>();\n        for (int i = 0; i < n; ++i) {\n            int p = pts[i][0]+pts[i][1];\n            int m = pts[i][0]-pts[i][1];\n            if (!pl.containsKey(p))\n                pl.put(p,new ArrayList<>());\n            if (!mi.containsKey(m))\n                mi.put(m,new ArrayList<>());\n            pl.get(p).add(i);\n            mi.get(m).add(i);\n        }\n        int ind = 0;\n        int[] psort = new int[n];\n        int[] msort = new int[n];\n        for (int k : pl.keySet()) {\n            for (int x : pl.get(k)) {\n                psort[ind++]=x;\n            }\n        }\n        ind = 0;\n        for (int k : mi.keySet()) {\n            for (int x : mi.get(k)) {\n                msort[ind++]=x;\n            }\n        }\n        HashSet<Integer> hs = new HashSet<>();\n        hs.add(psort[0]);\n        hs.add(psort[1]);\n        hs.add(psort[n-2]);\n        hs.add(psort[n-1]);\n        hs.add(msort[0]);\n        hs.add(msort[1]);\n        hs.add(msort[n-2]);\n        hs.add(msort[n-1]);\n        int ans = Integer.MAX_VALUE;\n        for (int x : hs) {\n            int test = 0;\n            for (int y : hs) {\n                for (int z : hs) {\n                    if (y==x||z==x)\n                        continue;\n                    test = Math.max(test,Math.abs(pts[y][0]-pts[z][0])+Math.abs(pts[y][1]-pts[z][1]));\n                }\n            }\n            ans = Math.min(ans,test);\n        }\n        return ans;\n    }\n}"
}