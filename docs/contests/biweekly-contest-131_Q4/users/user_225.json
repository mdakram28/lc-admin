{
    "username": "PyIsTheBestLang",
    "submission": "class RangeSetRangeMaxNonEmpConSubSum:\n    def __init__(self, n, initial=inf):\n        self.n = n\n        self.initial = initial\n        self.cover = [-initial] * (4 * self.n)\n        self.left = [-initial] * (4 * self.n)\n        self.right = [-initial] * (4 * self.n)\n        self.lazy_tag = [initial] * (4 * self.n)\n        self.sum = [0] * (4 * self.n)\n        return\n\n    def _make_tag(self, i, s, t, val):\n        self.cover[i] = val * (t - s + 1) if val > 0 else val\n        self.left[i] = val * (t - s + 1) if val > 0 else val\n        self.right[i] = val * (t - s + 1) if val > 0 else val\n        self.sum[i] = val * (t - s + 1)\n        self.lazy_tag[i] = val\n        return\n\n    def _push_down(self, i, s, m, t):\n        if self.lazy_tag[i] != self.initial:\n            self._make_tag(i << 1, s, m, self.lazy_tag[i])\n            self._make_tag((i << 1) | 1, m + 1, t, self.lazy_tag[i])\n            self.lazy_tag[i] = self.initial\n        return\n\n    def _range_merge_to_disjoint(self, res1, res2):\n        res = [0] * 4\n        res[0] = max(res1[0], res2[0])\n        res[0] = max(res[0], res1[2] + res2[1])\n        res[1] = max(res1[1], res1[3] + res2[1])\n        res[2] = max(res2[2], res2[3] + res1[2])\n        res[3] = res1[3] + res2[3]\n        return res\n\n    def _push_up(self, i):\n        res1 = self.cover[i << 1], self.left[i << 1], self.right[i << 1], self.sum[i << 1]\n        res2 = self.cover[(i << 1) | 1], self.left[(i << 1) | 1], self.right[(i << 1) | 1], self.sum[(i << 1) | 1]\n        self.cover[i], self.left[i], self.right[i], self.sum[i] = self._range_merge_to_disjoint(res1, res2)\n        return\n\n    def build(self, nums):\n        stack = [(0, self.n - 1, 1)]\n        while stack:\n            s, t, i = stack.pop()\n            if i >= 0:\n                if s == t:\n                    self._make_tag(i, s, t, nums[s])\n                    continue\n                stack.append((s, t, ~i))\n                m = s + (t - s) // 2\n                stack.append((s, m, i << 1))\n                stack.append((m + 1, t, (i << 1) | 1))\n            else:\n                i = ~i\n                self._push_up(i)\n        return\n\n    def get(self):\n        stack = [(0, self.n - 1, 1)]\n        nums = [-1] * self.n\n        while stack:\n            s, t, i = stack.pop()\n            if i >= 0:\n                if s == t:\n                    nums[s] = self.sum[i]\n                    continue\n                stack.append((s, t, ~i))\n                m = s + (t - s) // 2\n                self._push_down(i, s, m, t)\n                stack.append((s, m, i << 1))\n                stack.append((m + 1, t, (i << 1) | 1))\n            else:\n                i = ~i\n                self._push_up(i)\n        return nums\n\n    def range_set(self, left, right, val):\n        stack = [(0, self.n - 1, 1)]\n        while stack:\n            s, t, i = stack.pop()\n            if i >= 0:\n                if left <= s and t <= right:\n                    self._make_tag(i, s, t, val)\n                    continue\n                m = s + (t - s) // 2\n                stack.append((s, t, ~i))\n                self._push_down(i, s, m, t)\n                if left <= m:\n                    stack.append((s, m, i << 1))\n                if right > m:\n                    stack.append((m + 1, t, (i << 1) | 1))\n            else:\n                i = ~i\n                self._push_up(i)\n        return\n\n    def point_set(self, ind, val):\n        s, t, i = 0, self.n - 1, 1\n        while True:\n            if s == t == ind:\n                self._make_tag(i, s, t, val)\n                break\n            m = s + (t - s) // 2\n            self._push_down(i, s, m, t)\n            if ind <= m:\n                s, t, i = s, m, i << 1\n            else:\n                s, t, i = m + 1, t, (i << 1) | 1\n        while i > 1:\n            i //= 2\n            self._push_up(i)\n        return\n\n    def range_max_non_emp_con_sub_sum(self, left, right):\n        stack = [(0, self.n - 1, 1)]\n        ans = [-self.initial] * 4\n        while stack:\n            s, t, i = stack.pop()\n            if left <= s and t <= right:\n                cur = [self.cover[i], self.left[i], self.right[i], self.sum[i]]\n                ans = self._range_merge_to_disjoint(cur, ans)\n                continue\n            m = s + (t - s) // 2\n            self._push_down(i, s, m, t)\n            if left <= m:\n                stack.append((s, m, i << 1))\n            if right > m:\n                stack.append((m + 1, t, (i << 1) | 1))\n        return max(ans[0], 0)\n\n\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n\n        ceil = max(ls[1] for ls in queries) + 10\n        ceil *= 2\n        tree = RangeSetRangeMaxNonEmpConSubSum(ceil)\n        nums = [0]*ceil\n        for i in range(1, ceil, 2):\n            nums[i] = 1\n        tree.build(nums)\n        ans = []\n        for ls in queries:\n            if ls[0] == 1:\n                x = ls[1]*2\n                tree.point_set(x, -inf)\n            else:\n                x = ls[1]\n                res = tree.range_max_non_emp_con_sub_sum(0, x*2)\n                ans.append(res >= ls[2])\n        return ans",
    "submit_ts": 1716650664.0
}