{
    "username": "sveng101",
    "submission": "class AhoCorasick:\n    \"\"\"\n    Data structure used for simultaneous matching of multiple\n    patterns in a text, with time complexity O(n + m + z) where\n    n is the length of the string being searched, m is the sum\n    of the lengths of the patterns and z is the total number of\n    matches over all of the patterns in the string.\n    \n    Can use for solution of Leetcode: #139, #140 and Premium Leetcode:\n    #616 and #758 (basically the same problem) and #1065\n    \"\"\"\n\n    def __init__(self, words: List[str]):\n        self.goto = [{}]\n        self.failure = [-1]\n        self.out = [0]\n        self.out_lens = [0]\n        self.words = words\n        self.buildAutomaton()\n\n    def buildAutomaton(self) -> None:\n        for i, w in enumerate(self.words):\n            j = 0\n            for l in w:\n                if l not in self.goto[j].keys():\n                    self.goto[j][l] = len(self.goto)\n                    self.goto.append({})\n                    self.failure.append(0)\n                    self.out.append(0)\n                j = self.goto[j][l]\n            self.out[j] |= 1 << i\n        \n        queue = deque(self.goto[0].values())\n        \n        while queue:\n            j = queue.popleft()\n            for l, j2 in self.goto[j].items():\n                j_f = self.failure[j]\n                while j_f and l not in self.goto[j_f].keys():\n                    j_f = self.failure[j_f]\n                j_f = self.goto[j_f].get(l, 0)\n                self.failure[j2] = j_f\n                self.out[j2] |= self.out[j_f]\n                queue.append(j2)\n        return\n    \n    def _findNext(self, j: int, l: str) -> int:\n        while j and l not in self.goto[j].keys():\n            j = self.failure[j]\n        return self.goto[j].get(l, 0)\n    \n    def search(self, s: str) -> Dict[str, List[int]]:\n        \"\"\"\n        Gives dictionary for the starting index of each occurrence\n        of each of self.words in the string s.\n        \"\"\"\n        j = 0\n        res = {}\n        for i, l in enumerate(s):\n            j = self._findNext(j, l)\n            bm = self.out[j]\n            for idx, w in enumerate(self.words):\n                if not bm: break\n                if bm & 1:\n                    res.setdefault(w, [])\n                    res[w].append(i - len(w) + 1)\n                bm >>= 1\n        return res\n    \n    def searchEndIndices(self, s: str) -> Generator[Tuple[int, List[int]], None, None]:\n        \"\"\"\n        Generator yielding a 2-tuple of each index of s (in ascending order)\n        and a list of the corresponding indies of the patterns in self.words\n        that have a match in s that ends exactly at that index of s.\n        \"\"\"\n        j = 0\n        for i, l in enumerate(s):\n            j = self._findNext(j, l)\n            bm = self.out[j]\n            idx = 0\n            res = []\n            while bm:\n                if bm & 1: res.append(idx)\n                idx += 1\n                bm >>= 1\n            yield (i, res)\n        return\n\nclass Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        words2 = []\n        costs2 = []\n        seen = {}\n        for w, c in zip(words, costs):\n            if w in seen.keys():\n                costs2[seen[w][0]] = min(costs2[seen[w][0]], c)\n            else:\n                seen[w] = [len(words2), c]\n                words2.append(w)\n                costs2.append(c)\n\n        words = words2\n        costs = costs2\n        #print(words)\n        #print(costs)\n        n = len(target)\n\n        ac = AhoCorasick(words)\n        dp = [float(\"inf\")] * (n + 1)\n        dp[0] = 0\n\n        for (i, idx_lst) in ac.searchEndIndices(target):\n            #print(i, idx_lst)\n            for idx in idx_lst:\n                length = len(words[idx])\n                dp[i + 1] = min(dp[i + 1], dp[i - length + 1] + costs[idx])\n        \n        return dp[-1] if isinstance(dp[-1], int) else -1",
    "submit_ts": "1720321361",
    "subm_id": "1312320826"
}