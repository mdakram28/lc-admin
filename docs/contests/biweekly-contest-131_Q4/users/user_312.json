{
    "username": "tttyyy49",
    "submission": "class Solution {\n    public List<Boolean> getResults(int[][] queries) {\n        TreeSet<Integer> obs = new TreeSet<>();\n        obs.add(0);\n        obs.add(50001);\n        \n        int[] a = new int[50002];\n        Arrays.fill(a, 50001);\n        \n        SegmentTree tree = new SegmentTree(a);\n        \n        List<Boolean> res = new ArrayList<>();\n        for (int[] q : queries) {\n            if (q[0] == 1) {\n                int x = q[1];\n                \n                // place an obstacle at x\n                int l = obs.lower(x), r = obs.higher(x);\n                obs.add(x);\n                \n                // System.out.println(\"place\");\n                // System.out.println(l);\n                // System.out.println(r);\n                \n                tree.update(l + 1, x, x - l);\n                tree.update(x + 1, r, r - x);\n                \n            } else {\n                int x = q[1], sz = q[2];\n                \n                int l = obs.lower(x);\n                \n                int max = tree.query(l);\n                max = Math.max(max, x - l);\n                \n                // System.out.println(\"query\");\n                // System.out.println(l);\n                // System.out.println(max);\n                \n                res.add(sz <= max);\n            }\n        }\n        \n        return res;\n    }\n}\n\nclass SegmentTree {\n\n    static int init = 0;\n    static int func(int op1, int op2) {\n        return Math.max(op1, op2);\n    }\n\n    int[] t;\n    int n;\n    boolean[] marked;\n\n    public SegmentTree(int[] a) {\n        n = a.length;\n        t = new int[n * 4];\n        marked = new boolean[n * 4];\n        build(a, 1, 0, n - 1);\n    }\n\n    private void build(int[] a, int v, int tl, int tr) {\n        if (tl == tr) {\n            t[v] = a[tl];\n        } else {\n            int tm = (tl + tr) / 2;\n            build(a, v * 2, tl, tm);\n            build(a, v * 2 + 1, tm + 1, tr);\n            t[v] = func(t[v * 2], t[v * 2 + 1]);\n        }\n    }\n    \n    private void push(int v) {\n        if (marked[v]) {\n            t[v * 2 + 1] = t[v];\n            t[v * 2] = t[v];\n            \n            marked[v * 2 + 1] = true;\n            marked[v * 2] = true;\n            \n            marked[v] = false;\n        }\n    }\n\n    // l and r are both inclusive\n    // int query(int l, int r) {\n    //     return query(1, 0, n - 1, l, r);\n    // }\n    \n    int query(int r) {\n        return query(1, 0, n - 1, 1, r);\n    }\n\n    // private int query(int v, int tl, int tr, int l, int r) {\n    //     if (l > r) return init;\n    //     if (l == tl && r == tr) return t[v];\n    //     int tm = (tl + tr) / 2;\n    //     int op1 = query(v * 2, tl, tm, l, Math.min(r, tm));\n    //     int op2 = query(v * 2 + 1, tm + 1, tr, Math.max(l, tm + 1), r);\n    //     return func(op1, op2);\n    // }\n\n    private int query(int v, int tl, int tr, int l, int r) {\n        if (l > r) return init;\n        if (l == tl && r == tr) return t[v];\n        \n        push(v);\n        \n        int tm = (tl + tr) / 2;\n        int op1 = query(v * 2, tl, tm, l, Math.min(r, tm));\n        int op2 = query(v * 2 + 1, tm + 1, tr, Math.max(l, tm + 1), r);\n        return func(op1, op2);\n    }\n\n    \n    void update(int l, int r, int newVal) {\n        update(1, 0, n - 1, l, r, newVal);\n    }\n\n    // private void update(int v, int tl, int tr, int pos, int newVal) {\n    //     if (tl == tr) {\n    //         t[v] = newVal;\n    //     } else {\n    //         int tm = (tl + tr) / 2;\n    //         if (pos <= tm) {\n    //             update(v * 2, tl, tm, pos, newVal);\n    //         } else {\n    //             update(v * 2 + 1, tm + 1, tr, pos, newVal);\n    //         }\n    //         t[v] = func(t[v * 2], t[v * 2 + 1]);\n    //     }\n    // }\n    \n    private void update(int v, int tl, int tr, int l, int r, int new_val) {\n        if (l > r) \n            return;\n        if (l == tl && tr == r) {\n            t[v] = new_val;\n            marked[v] = true;\n        } else {\n            push(v);\n            int tm = (tl + tr) / 2;\n            update(v * 2, tl, tm, l, Math.min(r, tm), new_val);\n            update(v * 2 + 1, tm + 1, tr, Math.max(l, tm + 1), r, new_val);\n            t[v] = func(t[v*2], t[v*2+1]);\n        }\n    }\n}\n\n/**\nInput:\n[[1,7],[1,8],[2,7,4],[2,12,11]]\nOutput:\n[true,true]\nExpected:\n[true,false]\n**/\n",
    "submit_ts": "1716651988",
    "subm_id": "1267653330"
}