{
    "username": "shrishrajgupta",
    "submission": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace std;\nusing namespace __gnu_pbds; \n\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n#define pb push_back\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define repr(i, k, n) for (int i = k; i >= n; --i)\n#define vl vector<ll>\n#define vi vector<int>\n#define print(ans) printf(\"%.9f\\n\", ans)\n#define all(x) (x).begin(), (x).end()\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update> \n#define MAX(x) *max_element(all(x))\n#define MIN(x) *min_element(all(x))\n#define SUM(x) accumulate(all(x), 0LL)\n#define yes cout<<\"YES\"<<endl\n#define no cout<<\"NO\"<<endl\nstruct custom_hash {static uint64_t splitmix64(uint64_t x) {x += 0x9e3779b97f4a7c15;x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;x = (x ^ (x >> 27)) * 0x94d049bb133111eb;return x ^ (x >> 31);}size_t operator()(uint64_t x) const {static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();return splitmix64(x + FIXED_RANDOM);}};\ntypedef unordered_map<ll, ll,custom_hash> mll; typedef unordered_set<ll,custom_hash> sll; typedef queue<ll> qll;typedef gp_hash_table<ll,ll,custom_hash> table;\n\nclass Solution {\npublic:\n    // unordered_map<int,unordered_map<int,int>> dp;\n\n    vector<int> mx1,mx2;\n\n    void update(int node,ll val){\n        if(mx1[node]<val){\n            mx2[node]=mx1[node];\n            mx1[node]=val;\n        }\n        else if(mx2[node]<val)\n            mx2[node]=val;\n    }\n\n    ll dfs(int par,int node,vector<int> g[],vector<mll> &dp){\n\n        ll time=0;\n        for(auto it:g[node]){\n            if(it==par)\n                continue;\n            dp[node][it]=((it&1)?1:2)+dfs(node,it,g,dp);\n            update(node,dp[node][it]);\n\n            time=max(time,dp[node][it]);\n        }\n        return time;\n    }\n\n    void dfs2(int par,int node,vector<int> g[],vector<mll> &dp){\n\n        if(par!=-1){\n            int b=2;\n            if(par&1)\n                b--;\n            if(dp[par][node]==mx1[par])\n                dp[node][par]=(mx2[par]!=-1?mx2[par]:0)+b;\n            else\n                dp[node][par]=mx1[par]+b;\n            update(node,dp[node][par]);\n        }\n\n        for(auto it:g[node]){\n            if(it==par)\n                continue;\n            dfs2(node,it,g,dp);\n        }\n    }\n\n\n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        int n=edges.size()+1;\n        vector<mll> dp(n);\n        \n        mx1.resize(n,-1);\n        mx2.resize(n,-1);\n        vector<int> g[n];\n        for(auto &it:edges){\n            g[it[0]].push_back(it[1]);\n            g[it[1]].push_back(it[0]);\n        }\n        dfs(-1,0,g,dp);\n        dfs2(-1,0,g,dp);\n        return mx1;       \n        \n    }\n};",
    "submit_ts": "1722700666",
    "subm_id": "1343248926"
}