{
    "username": "htedsv-i",
    "submission": "//#pragma GCC optimize(\"Ofast\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\")\n//#pragma GCC option(\"arch=native\",\"tune=native\",\"no-zero-upper\")\n//#pragma GCC target(\"avx2\")\n#include <bits/stdc++.h>\nusing namespace std;\n//#define INF 2147483647\n#define infL (1LL<<60)\n#define inf (1<<30)\n#define inf9 (1000000000)\n#define MOD  998244353 //1000000007\n#define EPS 1e-9\n#define Gr 9.8\n#define PI acos(-1)\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define REQ(i,n) for(int (i)=1;(i)<=(int)(n);(i)++)\n#define lch (rt<<1)\n#define rch (rt<<1|1)\n#define readmp(n) for(int i=0,u,v;i<n;i++) {scanf(\"%d%d\",&u,&v); mp[u].push_back(v); mp[v].push_back(u);}\ntypedef  long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, vector<int>> piv;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef double ValType;\ntemplate<typename  T> void maxtt(T& t1, T t2) {\n    t1=max(t1,t2);\n}\ntemplate<typename  T> void mintt(T& t1, T t2) {\n    t1=min(t1,t2);\n}\n\n\nbool debug = 0;\nint n,m,k;\nint dx[4] = {0,1,0,-1}, dy[4] = {1,0,-1,0};\nstring direc=\"RDLU\";\nconst ll MOD2 = (ll)MOD * (ll)MOD;\nll ln, lk, lm;\nvoid etp(bool f = 0) {\n    puts(f ?\"YES\" : \"NO\");\n    exit(0);\n}\nvoid addmod(int &x, int y, int mod = MOD){\n    x+=y; if (x>=mod) x-=mod;\n    if(x<0) x+=mod;\n    assert(x>=0 && x<mod);\n}\nvoid et(int x=-1) {\n    printf(\"%d\\n\", x); exit(0);\n}\nll fastPow(ll x, ll y, int mod=MOD) {\n    ll ans = 1;\n    while(y>0) {\n        if(y&1) ans = (x * ans)%mod;\n        x = x*x%mod;\n        y>>=1;\n    }\n    return ans;\n}\nll gcd1(ll x, ll y) {\n    return y?gcd1(y,x%y):x;\n}\n\n//#include <atcoder/all>\n//using mint = atcoder::modint998244353;\n#define MAX (200005)\n\n\nvoid fmain(int tid) {\n//    scanf(\"%d\", &n);\n    int H;\n    scanf(\"%d%d\", &H, &n);\n    vector<int> a(n), c(n);\n    REP(i,n) scanf(\"%d\", &a[i]);\n    REP(i,n) scanf(\"%d\", &c[i]);\n    set<pii> ms;\n    REP(i,n) {\n        ms.insert({1, i});\n    }\n    int ans=1;\n    while(H>0) {\n        int tn = ms.begin()->first;\n        int id = ms.begin()->second;\n        maxtt(ans, tn);\n        H -= a[id];\n        ms.erase(ms.begin());\n        ms.insert({tn+c[id], id});\n    }\n    printf(\"%d\\n\", ans);\n}\n\nint a[MAX];\nconst int MN=(1<<20)+5;\nstruct mb {\n    int M,T[MN];\n    void init(int sz, int val) {\n        for(M=1;sz+2>M;M<<=1);\n        REP(i,M+M+5) T[i]=val;\n    }\n    void upt(int l, int val) {\n        l+=M; T[l]=val;\n        while(l>1) {\n            T[l>>1] = (T[l] + T[l^1]); l>>=1;\n        }\n    }\n    int qy(int l, int r) {\n        int ans = 0;\n        if (l>r) return 0;\n        for(l=l+M-1,r=r+M+1;l^r^1;l>>=1,r>>=1){\n            if(~l&1) ans+=T[l^1];\n            if(r&1) ans +=T[r^1];\n        }\n        return ans;\n    }\n}T;\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        REQ(i,n) a[i]=nums[i-1];\n        a[0]=inf; a[n+1]=inf;\n        T.init(n, 0);\n        REQ(i,n) {\n            if (a[i] > a[i-1] and a[i]>a[i+1]) T.upt(i, 1);\n        }\n        vector<int> ans;\n        for(auto &p: queries) {\n            if (p[0]==2) {\n                int i = p[1]+1;\n                int val = p[2];\n                a[i]=val;\n                for(int j=i-1;j<=i+1;j++) if (j>=1 and j<=n) {\n                    T.upt(j, a[j]>a[j-1] and a[j]>a[j+1] ? 1 : 0);\n                }\n            } else {\n                int l = p[1]+1, r=p[2]+1;\n                int A=T.qy(l+1,r-1);\n                ans.push_back(A);\n            }\n        }\n        return ans;\n    }\n};\nint mai12n() {\n//    f1reopen(\"sample2.in\",\"r\",stdin);\n//    freopen(\"sample2.out\",\"w\",stdout);\n    int t=1;\n//    ios::sync_with_stdio(false);\n//    cin.tie(0); cout.tie(0);\n//    cin>>t;\n    scanf(\"%d\", &t);\n    REQ(i,t) {\n        fmain(i);\n    }\n    return 0;\n}",
    "submit_ts": 1718506271.0
}