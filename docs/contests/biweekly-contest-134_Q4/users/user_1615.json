{
    "username": "miscsb",
    "submission": "class Solution {\n    public long countSubarrays(int[] nums, int k) {\n        // System.out.println();\n        long count = 0;\n        List<int[]> onesValid = enforceOnes(nums, k, List.of(new int[] { 0, nums.length }), 0);\n        for (int[] interval : onesValid) {\n            // System.out.println(Arrays.toString(interval));\n            int L = interval[0]; int R = interval[1];\n            int[][] prefix = new int[32][R - L + 1];\n            for (int b = 0; b < 32; b++) {\n                for (int r = L + 1; r <= R; r++) {\n                    prefix[b][r - L] = prefix[b][r - L - 1] + (1 - ((nums[r-1] >> b) & 1));\n                }\n            }\n            search: for (int l = L; l <= R; l++) {\n                for (int b = 0; b < 32; b++) {\n                    if (((k >> b) & 1) == 1) continue;\n                    if (prefix[b][R - L] - prefix[b][l - L] == 0) {\n                        continue search;\n                    }\n                }\n                int a = l; int b = R;\n                while (a + 1 != b) {\n                    int m = a + (b - a) / 2;\n                    boolean Mvalid = true;\n                    for (int b_ = 0; b_ < 32; b_++) {\n                        if (((k >> b_) & 1) == 1) continue;\n                        if (prefix[b_][m - L] - prefix[b_][l - L] == 0) {\n                            Mvalid = false;\n                            break;\n                        }\n                    }\n                    if (Mvalid) {\n                        b = m;\n                    } else {\n                        a = m;\n                    }\n                }\n                count += R - b + 1;\n            }\n        }\n        return count;\n    }\n    \n    public List<int[]> enforceOnes(int[] nums, int k, List<int[]> valid, int b) {\n        if (b == 32) return valid;\n        if (((k >> b) & 1) == 0) return enforceOnes(nums, k, valid, b + 1);\n        List<int[]> adjusted = new LinkedList<>();\n        for (int[] interval : valid) {\n            int L = interval[0]; int R = interval[1]; int l = L;\n            while (l < R) {\n                while (l < R && ((nums[l] >> b) & 1) == 0) l++;\n                if (l == R) break;\n                int r = l;\n                while (r < R && ((nums[r] >> b) & 1) == 1) r++;\n                adjusted.add(new int[] { l, r });\n                l = r;\n            }\n        }\n        return enforceOnes(nums, k, adjusted, b + 1);\n    }\n}",
    "submit_ts": "1720280909",
    "subm_id": "1311806383"
}