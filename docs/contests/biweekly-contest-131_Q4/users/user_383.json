{
    "username": "Nikolai_Tesla",
    "submission": "/*\n    Compete against yourself\n    Author - comp21823\n*/\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n// #include <dbg.h>\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntemplate<class T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define inf LLONG_MAX\n#define ninf LLONG_MIN\n#define mod(a,b) (((a%b) + b)%b)\n#define pi 3.1415926536\n#define pb              push_back\n#define ff              first\n#define ss              second\n#define mp(x,y)         make_pair(x,y)\n#define all(x)          (x).begin(), (x).end()\n#define precise(x,y)    fixed<<setprecision(y)<<x\n#define NO                 {cout<<\"NO\"<<endl; return;}\n#define YES             {cout<<\"YES\"<<endl; return;}\n#define NEG1             {cout<<\"-1\"<<endl; return;}\n#define setbits(x)      __builtin_popcountll(x)\ntypedef pair<int, int> pii;\n#define pqb             priority_queue<int> // maxheap\n#define pqs             priority_queue<int,vector<int>,greater<int>> // minheap\n#define piipqs          priority_queue<pii,vector<pii>,greater<pii>> // minheap for pair<int,int>\n#define piipqb          priority_queue<pii> // maxheap for pair<int,int>\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<long long> vll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef bitset<32> b32;\ntypedef bitset<64> b64;\ntypedef vector<vector<int>> mati;\ntypedef vector<vector<ll>> matll;\ntypedef vector<bool> vb;\ntypedef queue<int> que;\ntypedef stack<int> stk;\ntypedef long double ld;\ntypedef vector<pii> vp;\n \nint msb(int n){\n    int k = __builtin_clzll(n);\n    return 63 - k;  \n}\n \nll mod = (1e9)+7;\n\nclass Node{\n   public:\n   int val;    \n   int prop; \n   \n   Node(int v){\n      val = v;\n      prop = 0;\n   }\n \n    Node operator+(const Node& b){\n        return Node(max(val,b.val)); \n    }  \n};\n \nclass Segtree{\n   public:  \n    int n;\n    vector<Node> seg;\n    \n    void build(int i,int j,int k){\n        if(i == j){\n            seg[k] = Node(i);\n            return;\n        }\n \n        int mid = (i+j) >> 1;\n        build(i,mid,2*k+1);\n        build(mid+1,j,2*k+2);\n \n        seg[k] = seg[2*k+1] + seg[2*k+2];\n    }\n\n    void init(int n){\n        this -> n = n;\n        seg.resize(8*n,Node(0));\n        build(0,n-1,0);\n    }\n\n    void prop(int i,int j,int k){\n        if(seg[k].prop == 0){\n            return;\n        }\n        \n        seg[k].val -= seg[k].prop;\n        seg[2*k+1].prop += seg[k].prop;\n        seg[2*k+2].prop += seg[k].prop;\n        seg[k].prop = 0;\n    }\n \n    void _update(int l,int r,int x,int i,int j,int k){\n        prop(i,j,k);\n        if(l > j || r < i){\n            return;\n        }\n        \n        if((l <= i)&&(j <= r)){\n            seg[k].prop += x;\n            prop(i,j,k);\n            return;\n        }\n        \n        int mid = (i+j) >> 1;\n        _update(l,r,x,i,mid,2*k+1);\n        _update(l,r,x,mid+1,j,2*k+2);\n        \n        seg[k] = seg[2*k+1] + seg[2*k+2]; \n    }\n    \n    void update(int i,int j,int x){\n        if(i > j){\n            return;\n        }\n        _update(i,j,x,0,n-1,0);\n    }\n    \n    Node _sum(int l,int r,int i,int j,int k){\n        prop(i,j,k);\n        if(l > j || r < i){\n            return Node(0);\n        }\n        \n        if(l <= i && j <= r){\n            return seg[k];\n        }\n        \n        int mid = (i+j) >> 1;\n        return _sum(l,r,i,mid,2*k+1) + _sum(l,r,mid+1,j,2*k+2);\n    }\n    \n    int sum(int l,int r){\n        if(l > r){\n            return 0;\n        }\n        return _sum(l,r,0,n-1,0).val;\n    }\n};\n\n\nconst int N = 5*(1e4);\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        Segtree mn;\n        mn.init(2+N);\n        \n        set<int> obs;\n        obs.insert(0);\n        obs.insert(N+1);\n        \n        vb res; \n\n        for(auto q : queries){\n            if(q[0] == 1){\n               int x = q[1]; \n               auto it = obs.upper_bound(x);\n               int l = *prev(it);\n               int r = *it;\n               int len = x - l;\n               mn.update(x+1,r,len);\n               obs.insert(x);\n            }\n            else{\n               res.pb(mn.sum(0,q[1]) >= q[2]);\n            }\n        }\n\n        return res;\n    }\n};",
    "submit_ts": 1716652168.0
}