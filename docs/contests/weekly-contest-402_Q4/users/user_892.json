{
    "username": "ham--7",
    "submission": "class Solution {\npublic:\n    class TreeNode{\n    public:\n        TreeNode* left = nullptr, *right = nullptr;\n        int l, r, sum = 0;\n        TreeNode(int l, int r) : l(l), r(r) {}\n    };\n    TreeNode* root;\n    int n;\n    TreeNode* buildTree(int l, int r, vector<int>& preSum){\n        TreeNode* ret = new TreeNode(l, r);\n        ret->sum = preSum[r] - preSum[l - 1];\n        //cout<<\"build: \"<<l<<\" , \"<<r<<\" , \"<<ret->sum<<endl;\n        if(l == r) return ret;\n        int mid = (l + r) / 2;\n        ret->left = buildTree(l, mid, preSum);\n        ret->right = buildTree(mid+1, r, preSum);\n        return ret;\n    }\n\n    void update(TreeNode* node, int pos, int delta){\n        //cout<<\"update : \"<<node->l<<\" , \"<<node->r<<\" | \"<<pos<<\" , \"<<delta<<endl;\n        if(node->l > pos || node-> r < pos) return;\n        if(node->l == node->r){\n            node->sum += delta;\n            return;\n        }\n        update(node->left, pos, delta);\n        update(node->right, pos, delta);\n        node->sum = node->left->sum + node->right->sum;\n    }\n\n    int query(TreeNode* node, int lSpace, int rSpace){\n        //cout<<\"query : (\"<<node->l<<\" , \"<<node->r<<\") \"<<lSpace<<\" , \"<<rSpace<<endl;\n        if(node->l > rSpace || node-> r < lSpace) return 0;\n        if(node->l >= lSpace && node->r <= rSpace) return node->sum;\n        return query(node->left, lSpace, rSpace) + query(node->right, lSpace, rSpace);\n    }\n\n    bool judge(int pos, vector<int>& nums){\n        return pos > 0 && pos < n-1 && nums[pos] > nums[pos-1] && nums[pos] > nums[pos+1];\n    }\n\n    vector<int> accumulate(int p, vector<int>& nums){\n        vector<int> ret(3, 0);\n        if(p) ret[0] = judge(p-1, nums);\n        ret[1] = judge(p, nums);\n        if(p != n-1) ret[2] = judge(p+1, nums);\n        return ret;\n    }\n\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        n = nums.size();\n        int cnt = 0;\n        vector<int> ans, preSum = {0};\n        for(int i=0;i<n;i++){\n            if(judge(i, nums)) cnt++;\n            preSum.push_back(cnt);\n        }\n        root = buildTree(1, n, preSum);\n\n        for(const vector<int>& vec : queries){\n            if(vec[0] == 1){\n                if(vec[2] - vec[1] >= 2)\n                    ans.push_back(query(root, vec[1] + 2, vec[2]));\n                else ans.push_back(0);\n            }\n            else{\n                int p = vec[1], v = vec[2];\n                //cout<<\"p = \"<<p<<endl;\n                vector<int> pre = accumulate(p, nums);\n                nums[p] = v;\n                vector<int> last = accumulate(p, nums);\n\n                for(int i=0; i<3; i++){\n                    //cout<<\"pre[\"<<i<<\"] = \"<<pre[i]<<\" last[\"<<i<<\"] = \"<<last[i]<<endl;\n                    if(pre[i] != last[i])\n                        update(root, p+i, last[i] - pre[i]);\n                }\n            }\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": 1718508725.0
}