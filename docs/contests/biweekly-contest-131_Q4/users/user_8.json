{
    "username": "wjli",
    "submission": "\n\n// COPY ALL MACROS BELOW\n\ntypedef long long LL;\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define LB lower_bound\n#define UB upper_bound\n#define SZ(x) ((int)x.size())\n#define LEN(x) ((int)x.length())\n#define ALL(x) begin(x), end(x)\n#define RSZ resize\n#define ASS assign\n#define REV(x) reverse(x.begin(), x.end());\n#define trav(a, x) for (auto& a : x)\ntypedef pair<LL, LL> PL;\ntypedef vector<LL> VL;\ntypedef vector<PL> VPL;\ntypedef vector<VL> VVL;\ntypedef vector<VVL> VVVL;\ntypedef vector<VVVL> VVVVL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PI;\ntypedef vector<int> VI;\ntypedef vector<PI> VPI;\ntypedef vector<vector<int>> VVI;\ntypedef vector<vector<PI>> VVPI;\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\n#define FOR(i, n) for (int i = 0; i < n; i++) \n#define FOR1(i, n) for (int i = 1; i <= n; i++) \n#define SORT(x) sort(x.begin(), x.end())\n#define RSORT(x) sort(x.rbegin(), x.rend())\n#define SUM(x) accumulate(x.begin(), x.end(), 0LL)\n\n\n\ntemplate <typename T>\nclass segment_tree {\n    vector<T> t;\n    T VERYBIG;\n    bool ISMAXRANGE;\n    int size;\npublic:\n    segment_tree(int n, bool range_max = true) {\n        if (is_same<T, int>::value) VERYBIG = (1 << 30);\n        else if (is_same<T, LL>::value) VERYBIG = (1LL << 60);\n        //else if (is_same<T, PII>::value) VERYBIG = PII({ 1E9, 1E9 });\n        //else if (is_same<T, PLL>::value) VERYBIG = { 1LL << 60, 1LL << 60 };\n\n        ISMAXRANGE = range_max;\n\n        if (ISMAXRANGE) t.assign(4 * n + 1, 0);\n        else t.assign(4 * n + 1, VERYBIG);\n        size = n;\n    }\n\n    void initialize_array(vector<T>& v) {\n        initialize_with_array(1, 0, size - 1, v);\n    }\n\n    void initialize_with_array(int startpos, int l, int r, vector<T>& v) {\n        if (l == r) {\n            t[startpos] = v[l];\n        }\n        else {\n            int m = (l + r) / 2;\n            initialize_with_array(2 * startpos, l, m, v);\n            initialize_with_array(2 * startpos + 1, m + 1, r, v);\n\n            if (ISMAXRANGE == 1) t[startpos] = max(t[startpos * 2], t[startpos * 2 + 1]);\n            else  t[startpos] = min(t[startpos * 2], t[startpos * 2 + 1]);\n        }\n    }\n\n    void update(int index, T val) { // insert val into location index\n        update_full(1, 0, size - 1, index, val);\n    }\n\n    void update_full(int startpos, int l, int r, int index, T val) {\n        if (l == r) {\n            t[startpos] = val;\n        }\n        else {\n            int m = (l + r) / 2;\n            if (index <= m) update_full(2 * startpos, l, m, index, val);\n            else update_full(2 * startpos + 1, m + 1, r, index, val);\n\n            if (ISMAXRANGE) t[startpos] = max(t[startpos * 2], t[startpos * 2 + 1]);\n            else t[startpos] = min(t[startpos * 2], t[startpos * 2 + 1]);\n        }\n    }\n\n    T query(int l, int r) {  // get range min/max between l and r\n        if (l > r) {\n            if (ISMAXRANGE) return 0;\n            else return VERYBIG;\n        }\n        return query_full(1, 0, size - 1, l, r);\n    }\n\n    T query_full(int startpos, int left, int right, int l, int r) {\t // left/right = current range, l/r = intended query range\n        if ((left >= l) && (right <= r)) return t[startpos];\n        int m = (left + right) / 2;\n        T ans;\n        if (ISMAXRANGE) ans = -VERYBIG;\n        else ans = VERYBIG;\n        if (m >= l) {\n            if (ISMAXRANGE) ans = max(ans, query_full(startpos * 2, left, m, l, r));\n            else ans = min(ans, query_full(startpos * 2, left, m, l, r));\n        }\n        if (m + 1 <= r) {\n            if (ISMAXRANGE) ans = max(ans, query_full(startpos * 2 + 1, m + 1, right, l, r));\n            else ans = min(ans, query_full(startpos * 2 + 1, m + 1, right, l, r));\n        }\n        return ans;\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int MAXX = min(50010, (int)queries.size() * 3 + 10), i, j, k, x, sz;\n        segment_tree<int> st(MAXX, true);\n\n        vector<bool> ans;\n        set<PI> s;\n        s.insert({ 0, MAXX });\n\n        st.update(0, MAXX);\n\n        for (auto p : queries) {\n            if (p[0] == 1) {\n                x = p[1];\n\n                set<PI>::iterator it = s.upper_bound({ x, 0 });\n                it--;\n\n                int l = it->first, r = it->second;\n                st.update(l, 0);\n                s.erase(it);\n                s.insert({ l, x });\n                s.insert({ x, r});\n                st.update(l, x - l);\n                st.update(x, r - x);\n            }\n            else {\n                x = p[1];\n                sz = p[2];\n\n                int v = st.query(0, x - sz);\n                if (v >= sz) ans.push_back(true);\n\t\t\t\telse ans.push_back(false);\n            }\n        }\n        return ans;\n    }\n};\n",
    "submit_ts": 1716648372.0
}