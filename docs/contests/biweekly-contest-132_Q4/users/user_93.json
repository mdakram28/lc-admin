{
    "username": "VarunR",
    "submission": "class Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {\n        int n = (int)nums.size();\n        map<int, vector<int>> mp;\n        for(auto& x: nums) {\n            mp[x].resize(k + 1);\n        }\n        vector<priority_queue<pair<int, int>>> opt(k + 1); /// priority_queue of transitions\n        vector<vector<int>> dp(n, vector<int>(k + 1, 0));\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j <= k; j++) {\n                dp[i][j] = 1;\n                dp[i][j] = max(dp[i][j], mp[nums[i]][j] + 1);\n                if(j) {\n                    vector<int> rem;\n                    while(!opt[j - 1].empty()) {\n                        auto q = opt[j - 1].top();\n                        if(nums[q.second] == nums[i]) {\n                            rem.push_back(q.second);\n                            opt[j - 1].pop();\n                            continue;\n                        }\n                        // we can do this transition and it is the best one possible since it is at teh top of pq\n                        dp[i][j] = max(dp[i][j], q.first + 1);\n                        break;\n                    }\n                    \n                    while(!rem.empty()) {\n                        int b = rem.back();\n                        rem.pop_back();\n                        //need to add rem back to pq\n                        opt[j - 1].push(make_pair(dp[b][j - 1], b));\n                    }\n                }\n                \n                // need to update mp\n                    mp[nums[i]][j] = max(mp[nums[i]][j], dp[i][j]);\n                    // need to update dp - already beeeeen updated\n                    // need to update opt\n                    int vl = dp[i][j];\n                    // we would need to push in {vl, i}\n                    if(opt[j].empty()) opt[j].push(make_pair(vl, i));\n                    else {\n                        if(nums[opt[j].top().second] == nums[i] and dp[i][j] == mp[nums[i]][j]) {\n                            opt[j].pop();\n                            opt[j].push(make_pair(vl, i));\n                        }\n                        else if(dp[i][j] == mp[nums[i]][j]) {\n                            opt[j].push(make_pair(vl, i));\n                        }\n                    }\n                \n            }\n            \n        }\n        int mx = 0;\n        for(auto& x: dp) {\n            mx = max(mx, *max_element(x.begin(), x.end()));\n        }\n        return mx;\n    }\n};",
    "submit_ts": 1717859855.0
}