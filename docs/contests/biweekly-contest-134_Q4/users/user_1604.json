{
    "username": "Joyjeet",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds; // find_by_order, order_of_key\n#define ll long long\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vi vector<int>\n#define vll vector<long long>\n#define vvi vector<vi>\n#define vpii vector<pair<int,int>>\n#define vpll vector<pair<ll,ll>>\n#define mii map<int, int>\n#define si set<int>\n#define sc set<char>\n#define f(i,s,e) for(long long int i=s;i<e;i++)\n#define cf(i,s,e) for(long long int i=s;i<=e;i++)\n#define rf(i,e,s) for(long long int i=e-1;i>=s;i--)\n#define pb push_back\n#define eb emplace_back\n#define yes cout << 'YES' << endl;\n#define no cout << 'NO' << endl;\n#define ff first\n#define ss second\n#define MOD 1000000007\n#define MOD1 998244353\n#define debug(x) cout<<x<<endl\n#define INFI 1E9+10\n#define INFL 1e18\n#define all(v) v.begin(),v.end()\nint lcm(int x,int y){return (x*y)/__gcd(x,y);}\nbool prime(ll a) { if (a==1) return 0; for (int i=2;i<=round(sqrt(a));++i) if (a%i==0) return 0; return 1; }\nvector<ll> sieve(int n) {int*arr = new int[n + 1](); vector<ll> vect; for (int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for (int j = 2 * i; j <= n; j += i)arr[j] = 1;} return vect;}\nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\n#define dbg(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n\ntemplate<typename T>\nvoid _print(T arg) {\n    cerr << arg;\n}\n\ntemplate<typename T>\nvoid _print(const vector<T>& arg) {\n    cerr << \"[\";\n    for (const auto& element : arg) {\n        cerr << element << \", \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename T>\nvoid _print(const set<T>& arg) {\n    cerr << \"[\";\n    for (const auto& element : arg) {\n        cerr << element << \", \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename T>\nvoid _print(const multiset<T>& arg) {\n    cerr << \"[\";\n    for (const auto& element : arg) {\n        cerr << element << \", \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename K, typename V>\nvoid _print(const map<K, V>& arg) {\n    cerr << \"[\";\n    for (const auto& [key, value] : arg) {\n        cerr << \"(\" << key << \"=>\" << value << \"), \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename K, typename V>\nvoid _print(const multimap<K, V>& arg) {\n    cerr << \"[\";\n    for (const auto& [key, value] : arg) {\n        cerr << \"(\" << key << \"=>\" << value << \"), \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename T>\nvoid _print(const unordered_set<T>& arg) {\n    cerr << \"[\";\n    for (const auto& element : arg) {\n        cerr << element << \", \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename T>\nvoid _print(const unordered_multiset<T>& arg) {\n    cerr << \"[\";\n    for (const auto& element : arg) {\n        cerr << element << \", \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename K, typename V>\nvoid _print(const unordered_map<K, V>& arg) {\n    cerr << \"[\";\n    for (const auto& [key, value] : arg) {\n        cerr << \"(\" << key << \"=>\" << value << \"), \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename K, typename V>\nvoid _print(const unordered_multimap<K, V>& arg) {\n    cerr << \"[\";\n    for (const auto& [key, value] : arg) {\n        cerr << \"(\" << key << \"=>\" << value << \"), \";\n    }\n    cerr << \"]\";\n}\n\ntemplate<typename T1, typename T2>\nvoid _print(const pair<T1, T2>& arg) {\n    cerr << \"(\" << arg.first << \", \" << arg.second << \")\";\n}\n\ntemplate<typename T, typename... Args>\nvoid _print(T arg, Args... args) {\n    cerr << arg << \", \";\n    _print(args...);\n}\n#define MAXN 3000001\nint spf[MAXN];\nint larg[MAXN];\nint primes[MAXN];\nint cnt[MAXN];\nvoid sieve()\n{\n    spf[1] = 1;\n    for (int i = 2; i < MAXN; i++){\n        spf[i] = i;\n    }\n    for (int i = 4; i < MAXN; i += 2)\n        spf[i] = 2;\n    for (int i = 3; i * i < MAXN; i++) {\n        if (spf[i] == i) {\n            for (int j = i * i; j < MAXN; j += i)\n                if (spf[j] == j)\n                    spf[j] = i;\n        }\n    }\n    int cur=0;\n    for(int i=2;i<MAXN;++i){\n        if(spf[i]==i){\n            primes[i]=++cur;\n        }\n        else{\n            larg[i]=i/spf[i];\n        }\n    }\n}\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& v, int k) {\n      ll n=v.size();\n      vvi mark(32,vi(n,0));\n      for(ll i=31;i>=0;--i){\n        for(ll j=0;j<n;++j){\n          ll b=(v[j]>>i)&1;\n          mark[i][j]=b;\n        }\n      }\n      vvi prv(32,vi(n,-1));\n      for(ll i=31;i>=0;--i){\n        ll zro=-1;\n        for(ll j=0;j<n;++j){\n          prv[i][j]=zro;\n          if(mark[i][j]==0){\n            zro=j;\n          }\n        }\n      }\n      ll cnt=0;\n      for(ll i=0;i<n;++i){\n        ll rmn=i,lmx=0,curr=1;\n        for(ll j=0;j<32;++j){\n          ll zro=prv[j][i];\n          ll have=mark[j][i];\n          ll b=(k>>j)&1;\n          if(!b){\n            if(have){\n              if(lmx>zro) {\n                curr=0;break;\n              }\n              rmn=min(rmn,zro);\n            }\n          }\n          else{\n            if(have){\n              if(rmn<zro) {\n                curr=0;break;\n              }\n              lmx=max(lmx,zro+1);\n            }\n            else{\n              curr=0;\n              break;\n            }\n          }\n        }\n        if(!curr)   continue;\n        cnt+=(rmn-lmx+1);\n      }\n      return cnt;\n    }\n};",
    "submit_ts": "1720280777",
    "subm_id": "1311801686"
}