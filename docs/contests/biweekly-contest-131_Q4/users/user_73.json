{
    "username": "warks",
    "submission": "class Solution {\n    private static final int LIMIT = 50_001;\n    public List<Boolean> getResults(int[][] queries) {\n        java.util.NavigableSet<Integer> obstacles = new TreeSet<>();\n        obstacles.add(0);\n        obstacles.add(LIMIT);\n        PurqSegmentTree st = new PurqSegmentTree(LIMIT + 1);\n        st.modify(0, 0);\n        st.modify(LIMIT, LIMIT);\n        \n        List<Boolean> results = new ArrayList<>();\n        for (int[] query : queries) {\n            int x = query[1];\n            switch (query[0]) {\n                case 1:\n                    {\n                        int next = obstacles.higher(x);\n                        int space = next - x;\n                        // System.out.println(\"Q1: \" + x + \" \" + next + \" \" + space);\n                        st.modify(next, space);\n                        int prev = obstacles.lower(x);\n                        space = x - prev;\n                        st.modify(x, space);\n                        // System.out.println(\"Q1: \" + x + \" \" + prev + \" \" + space);\n                        obstacles.add(x);\n                    }\n                    break;\n                case 2:\n                    {\n                        int prev = obstacles.floor(x);\n                        int space = Math.max(\n                            x - prev,\n                            st.rangeMax(0, prev + 1)\n                        );\n                        \n                        results.add(space >= query[2]);\n                        // System.out.println(\"Q2: \" + x + \" \" + prev + \" \" + space);\n                    }\n                    break;\n                default:\n            }\n        }\n        \n        return results;\n    }\n}\n\nclass PurqSegmentTree {\n    int arrayLength;\n    int[] tree;\n\n    PurqSegmentTree(int arrayLength) {\n        this.arrayLength = arrayLength;\n        tree = new int[arrayLength << 1];\n    }\n\n    void modify(int pos, int value) {\n        for (tree[pos += arrayLength] = value; pos > 1; pos >>= 1) {\n            tree[pos >> 1] = Math.max(tree[pos], tree[pos ^ 1]);\n        }\n    }\n\n    // returns max on slice [left, right)\n    int rangeMax(int left, int right) {\n        int max = 0;\n        for (left += arrayLength, right += arrayLength; left < right; left >>= 1, right >>= 1) {\n            if ((left & 1) > 0) {\n                max = Math.max(max, tree[left++]);\n            }\n            if ((right & 1) > 0) {\n                max = Math.max(max, tree[--right]);\n            }\n        }\n        return max;\n    }\n}",
    "submit_ts": 1716649603.0
}