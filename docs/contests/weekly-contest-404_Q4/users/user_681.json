{
    "username": "its_rik",
    "submission": "const int maxn = 200005;\n\nvector<int> adj[maxn];\nint depth[maxn];\nint ans;\n\nvoid find(int root, int par)\n{\n    depth[root] = 0;\n    for (auto child : adj[root])\n    {\n        if (child == par)\n            continue;\n        find(child, root);\n    }\n    for (auto child : adj[root])\n    {\n        if (child == par)\n            continue;\n        depth[root] = max(depth[root], 1 + depth[child]);\n    }\n}\n\nvoid diameter(int root, int par)\n{\n    vector<int> store_depth;\n    for (auto child : adj[root])\n    {\n        if (child == par)\n            continue;\n        store_depth.push_back(depth[child]);\n    }\n    sort(store_depth.begin(), store_depth.end());\n    int n = store_depth.size();\n    if (n == 0){}\n    else if (n == 1)\n    {\n        ans = max(ans, 1 + store_depth[0]);\n    }\n    else\n    {\n        ans = max(ans, 2 + store_depth[n - 1] + store_depth[n - 2]);\n    }\n\n    for (auto child : adj[root])\n    {\n        if (child == par)\n            continue;\n        diameter(child, root);\n    }\n}\nclass Solution {\npublic:\n    int solve(vector<vector<int>>& edges1, vector<vector<int>>& edges2){\n        int ans1 = 0,ans2 = 0;\n        set<int>count1,count2;\n        for(auto i:edges1){ \n            count1.insert(i[0]);count1.insert(i[1]);\n        }\n        int n1 = count1.size();\n         for(auto i:edges2){\n            count2.insert(i[0]);\n            count2.insert(i[1]);\n        }\n        int n2 = count2.size();\n        for(auto i:edges1){\n            int u = i[0], v = i[1];\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        ans = 0;\n        find(0, -1);\n        diameter(0, -1);\n        ans1 = ans;\n        for(int i=0;i<n1+5000;i++)depth[i] = 0,adj[i].clear();\n        \n       \n        for(auto i:edges2){\n            int u = i[0], v = i[1];\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        ans = 0;\n        find(0, -1);\n        diameter(0, -1);\n        ans2 = ans;\n        for(int i=0;i<n2+5000;i++)depth[i] = 0,adj[i].clear();\n        \n        int world_cup = max({ans1,ans2,(ans1+1)/2 + (ans2+1)/2 + 1});\n        return world_cup;\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n         return solve(edges1,edges2);\n    }\n};",
    "submit_ts": 1719719831.0
}