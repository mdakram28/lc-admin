{
    "username": "pramod_krp",
    "submission": "class Solution {\npublic:\n    int x;\n \n// Sets maxCount as maximum distance from node.\nvoid dfsUtil(int node, int count, bool visited[],\n                   int& maxCount, list<int>* adj)\n{\n    visited[node] = true;\n    count++;\n    for (auto i = adj[node].begin(); i != adj[node].end(); ++i) {\n        if (!visited[*i]) {\n            if (count >= maxCount) {\n                maxCount = count;\n                x = *i;\n            }\n            dfsUtil(*i, count, visited, maxCount, adj);\n        }\n    }\n}\n \n// The function to do DFS traversal. It uses recursive\n// dfsUtil()\nvoid dfs(int node, int n, list<int>* adj, int& maxCount)\n{\n    bool visited[n + 1];\n    int count = 0;\n \n    // Mark all the vertices as not visited\n    for (int i = 1; i <= n; ++i)\n        visited[i] = false;\n \n    // Increment count by 1 for visited node\n    dfsUtil(node, count + 1, visited, maxCount, adj);\n}\n \n// Returns diameter of binary tree represented\n// as adjacency list.\nint diameter(list<int>* adj, int n)\n{\n    int maxCount = 0;\n \n    /* DFS from a random node and then see\n    farthest node X from it*/\n    dfs(1, n, adj, maxCount);\n \n    /* DFS from X and check the farthest node\n    from it */\n    dfs(x, n, adj, maxCount);\n \n    return maxCount;\n}\n    int minimumDiameterAfterMerge(vector<vector<int>>& v1, vector<vector<int>>& v2) {\n        int n=v1.size()+1,m=v2.size()+1;\n        vector<bool> vis1(n,0),vis2(m,0);\n        list<int>* adj=new list<int>[n+1];\n        for(auto z : v1){\n            int p=z[0]+1;\n            int q=z[1]+1;\n            adj[p].push_back(q);\n            adj[q].push_back(p);\n        }int cnt1=diameter(adj,n);\n        list<int>* adj2=new list<int>[m+1];\n        for(auto z : v2){\n            int p=z[0]+1;\n            int q=z[1]+1;\n            adj2[p].push_back(q);\n            adj2[q].push_back(p);\n        }int cnt2=diameter(adj2,m);\n        if(cnt1<cnt2) swap(cnt1,cnt2);\n        return max(cnt1-1,((cnt1)/2)+((cnt2)/2)+1);\n    }\n};",
    "submit_ts": 1719719536.0
}