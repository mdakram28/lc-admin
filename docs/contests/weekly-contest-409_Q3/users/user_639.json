{
    "username": "cavetr",
    "submission": "class SegmentTree {\n  private value: number[];\n  private baseLen: number;\n  private deep: number;\n  constructor(arr: number[]) {\n    this.deep = Math.ceil(Math.log2(arr.length));\n    this.baseLen = (2 ** this.deep) - 1;\n    this.value = new Array(this.baseLen).fill(0).concat(arr);\n    this.buildAfter(0);\n  }\n  private buildAfter(idx: number): number {\n    if (idx < Math.floor(this.value.length / 2)) {\n      this.value[idx] = this.buildAfter(idx * 2 + 1) + this.buildAfter(idx * 2 + 2);\n    }\n    return this.value[idx] ?? 0;\n  }\n  private buildBefore(idx: number) {\n    if (idx < Math.floor(this.value.length / 2)) {\n      this.value[idx] = (this.value[idx * 2 + 1] ?? 0) + (this.value[idx * 2 + 2] ?? 0);\n    }\n    if (idx !== 0) {\n      this.buildBefore(Math.floor((idx - 1) / 2));\n    }\n  }\n  get valueStr() {\n    return this.value.join(',');\n  }\n  item(idx: number) {\n    const realIdx = idx + this.baseLen;\n    if (realIdx < this.baseLen || realIdx > this.value.length) {\n      throw new Error('Out of range');\n    }\n    return this.value[realIdx];\n  }\n  update(idx: number, val: number) {\n    const realIdx = idx + this.baseLen;\n    if (realIdx < this.baseLen || realIdx > this.value.length) {\n      throw new Error('Out of range');\n    }\n    this.value[realIdx] = val;\n    this.buildBefore(realIdx);\n  }\n  getRange(l: number, r: number) {\n    l = l + this.baseLen, r = r + this.baseLen;\n    if (l < this.baseLen || r > this.value.length || l > r) {\n      throw new Error('Out of range');\n    }\n    let lastLIsR = false, lastRIsL = false;\n    let sum = 0;\n    let calL = l, calR = r;\n    if (calL === calR) {\n      return this.value[calL];\n    }\n    while (l < r) {\n      sum += lastLIsR ? 0 : this.value[calL] ?? 0;\n      sum += lastRIsL ? 0 : this.value[calR] ?? 0;\n      lastLIsR = l % 2 === 0, lastRIsL = r % 2 === 1;\n      l = Math.floor((l - 1) / 2);\n      r = Math.floor((r - 1) / 2);\n      calL = l * 2 + 2;\n      calR = r * 2 + 1;\n    }\n    return sum;\n  }\n}\nfunction shortestDistanceAfterQueries(n: number, queries: number[][]): number[] {\n  const tree = new SegmentTree(new Array(n).fill(0).map((_, idx) => idx ? 1 : 0));\n  const ans = [];\n  for(const [a, b] of queries) {\n    const value = tree.getRange(0, a);\n    const bb = tree.getRange(0, b);\n    if(!(value < 0 || bb < 0)) {\n      tree.update(a + 1, tree.item(a + 1) - 1e6);\n      tree.update(b, tree.item(b) + 1e6);\n      const diff = bb - 1 - value;\n      tree.update(b, tree.item(b)  - diff);\n    }\n    ans.push(tree.getRange(0, n - 1));\n  }\n  return ans;\n};",
    "submit_ts": "1722742535",
    "subm_id": "552345266"
}