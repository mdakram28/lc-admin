{
    "username": "ruiaikete",
    "submission": "function getResults(queries: number[][]): boolean[] {\n  const N = 50010\n  const tr = new SegTree(N)\n  const bst = new BinarySearchTree()\n  const res: boolean[] = []\n  const set = new Set()\n  for (let [t, x, y] of queries) {\n    if (t === 1) {\n      const left = bst.floor(x - 1) ?? 0,\n        right = bst.ceiling(x + 1)\n      if (right) {\n        tr.update(right, right, right - x)\n      }\n      tr.update(x, x, x - left)\n      set.add(x)\n      bst.insert(x)\n    } else {\n      if (!set.has(x)) {\n        const left = bst.floor(x - 1) ?? 0\n        tr.update(x, x, x - left)\n      }\n      const q = tr.query(0, x)\n      res.push(q >= y)\n      if (!set.has(x)) {\n        tr.update(x, x, 0)\n      }\n    }\n  }\n  return res\n}\n\ntype Node = {\n  left: Node | null\n  right: Node | null\n  val: number\n}\nclass SegTree {\n  private root: Node\n  public update: (x: number, y: number, z: number) => void\n  public query: (x: number, y: number) => number\n  public constructor(private n: number) {\n    this.root = this._newNode()\n\n    this.update = (x: number, y: number, z: number) => {\n      x = Math.max(x, 0)\n      y = Math.min(y, n)\n      this._update(this.root, 0, n, x, y, z)\n    }\n    this.query = (x: number, y: number) => {\n      x = Math.max(x, 0)\n      y = Math.min(y, n)\n      return this._query(this.root, 0, n, x, y)\n    }\n  }\n  private _newNode(val = 0, left = null, right = null) {\n    return { val, left, right }\n  }\n  private _newLeft(node: Node) {\n    if (!node.left) node.left = this._newNode()\n  }\n  private _newRight(node: Node) {\n    if (!node.right) node.right = this._newNode()\n  }\n\n  private _up(node: Node) {\n    const { left, right } = node\n    node.val = Math.max(left?.val ?? -Infinity, right?.val ?? -Infinity)\n  }\n  private _update(node: Node | null, l: number, r: number, x: number, y: number, z: number): void {\n    if (!node) return\n\n    if (l === x && r === y) {\n      node.val = z\n      return\n    }\n\n    const mid = Math.floor((l + r) / 2)\n\n    if (y <= mid) {\n      this._newLeft(node)\n      this._update(node.left, l, mid, x, y, z)\n    } else if (x > mid) {\n      this._newRight(node)\n      this._update(node.right, mid + 1, r, x, y, z)\n    } else {\n      this._newLeft(node)\n      this._newRight(node)\n      this._update(node.left, l, mid, x, mid, z), this._update(node.right, mid + 1, r, mid + 1, y, z)\n    }\n\n    this._up(node)\n  }\n  private _query(node: Node | null, l: number, r: number, x: number, y: number): number {\n    if (y < x) return 0\n    if (!node) return 0\n\n    if (l === x && r === y) return node.val\n\n    let res = 0,\n      mid = Math.floor((l + r) / 2)\n\n    if (y <= mid) {\n      res = this._query(node.left, l, mid, x, y)\n    } else if (x > mid) {\n      res = this._query(node.right, mid + 1, r, x, y)\n    } else {\n      res = Math.max(this._query(node.left, l, mid, x, mid), this._query(node.right, mid + 1, r, mid + 1, y))\n    }\n\n    return res\n  }\n}\n\ninterface BSTNode<T = number> {\n  id: number\n  val: T // \u5f53\u524d\u7ed3\u70b9\u4e2d\u5b58\u7684\u503c\n  size: number // \u5f53\u524d\u5b50\u6811\u4e2d\u5305\u542b\u7684\u5143\u7d20\u4e2a\u6570,\u5305\u62ec\u91cd\u590d\u5143\u7d20\n  height: number\n  count: number // \u5f53\u524d\u7ed3\u70b9\u7684\u91cd\u590d\u5143\u7d20\u8ba1\u6570\n  left: BSTNode<T> | null\n  right: BSTNode<T> | null\n}\n\nclass BinarySearchTree<T = number> {\n  private root: BSTNode<T> | null = null\n  /**\n   * \u4e0d\u91cd\u590d\u6570\u5b57\u7684\u4e2a\u6570\n   */\n  private length = 0\n  private min: T | null = null\n  private max: T | null = null\n  private minCache = true\n  private maxCache = true\n  constructor(...args: T extends number ? [((a: number, b: number) => number)?] : [(a: T, b: T) => number])\n  constructor(private _compare: (a: T, b: T) => number = ((a: number, b: number) => a - b) as any) {\n    this.compare = this.compare.bind(this)\n  }\n  private isT(t: T | undefined | null): t is T {\n    return t !== undefined && t !== null\n  }\n  private compare(a: T | null | undefined, b: T | null | undefined) {\n    const { isT } = this\n    if (isT(a) && isT(b)) return this._compare(a, b)\n\n    if (isT(a)) return 1\n    if (isT(b)) return -1\n    return 0\n  }\n  /** \u5224\u65ad\u662f\u5426\u4e3a\u7a7a\n   */\n  isEmpty() {\n    return !this.root\n  }\n  /** \u83b7\u53d6\u6240\u6709\u5143\u7d20\u4e2a\u6570,\u7edf\u8ba1\u7684\u662f\u5305\u542b\u6240\u6709\u91cd\u590d\u6570\u5b57\u7684\u6570\u91cf\n   */\n  size() {\n    return this.root ? this.root.size : 0\n  }\n  /** \u8fd4\u56de\u6811\u7684 root \u5143\u7d20\n   */\n  getRoot() {\n    return this.root\n  }\n  /** # \u8fd4\u56de\u6700\u5c0f\u503c\n   *  \u5982\u679c\u4e4b\u524d\u53d1\u751f\u5220\u9664,\u5e76\u4e14\u5220\u9664\u7684\u6570\u7b49\u4e8e\u6700\u5c0f\u503c,\u5219\u4f1a\u5728\u4e0b\u6b21\u83b7\u53d6\u6700\u5c0f\u503c\u65f6,\u91cd\u65b0\u67e5\u627e\u6700\u5c0f\u503c,\u5e76\u7f13\u5b58\u6700\u5c0f\u503c\n   *  \u5426\u5219\u76f4\u63a5\u8fd4\u56de\u7f13\u5b58\u4e2d\u7684\u6700\u5c0f\u503c\n   */\n  getMin(): T | null {\n    if (this.minCache) {\n      return this.min\n    }\n    const min = this.searchKth(this.size())\n    this.min = min\n    this.minCache = true\n    return min\n  }\n  /** # \u8fd4\u56de\u6700\u5927\u503c\n   *  \u5982\u679c\u4e4b\u524d\u53d1\u751f\u5220\u9664,\u5e76\u4e14\u5220\u9664\u7684\u6570\u7b49\u4e8e\u6700\u5927\u503c,\u5219\u4f1a\u5728\u4e0b\u6b21\u83b7\u53d6\u6700\u5927\u503c\u65f6,\u91cd\u65b0\u67e5\u627e\u6700\u5927\u503c,\u5e76\u7f13\u5b58\u6700\u5927\u503c\n   *  \u5426\u5219\u76f4\u63a5\u8fd4\u56de\u7f13\u5b58\u4e2d\u7684\u6700\u5927\u503c\n   */\n  getMax(): T | null {\n    if (this.maxCache) {\n      return this.max\n    }\n    const max = this.searchKth(1)\n    this.max = max\n    this.maxCache = true\n    return max\n  }\n\n  //#region balance\n  /**\n   * \u5e73\u8861\u64cd\u4f5c\n   * @param node \u5931\u8861\u7684\u6839\u7ed3\u70b9\n   * @returns \u8fd4\u56de\u5e73\u8861\u4e4b\u540e\u7684\u6839\u7ed3\u70b9\n   */\n  private balance(node: BSTNode<T>): BSTNode<T> {\n    node.height = this.getHeight(node)\n    const blance = this.getBalance(node)\n    // node.height = Math.max(leftH, rightH) + 1\n    let res\n    // \u5e73\u8861\n    if (Math.abs(blance) === 2) {\n      if (blance > 0) {\n        const heightDif = (node.left?.left?.height ?? 0) - (node.left?.right?.height ?? 0)\n        if (heightDif > 0) {\n          // \u5de6\u5de6\n          res = this.rotateRight(node)\n        } else if (heightDif < 0) {\n          // \u5de6\u53f3\n          res = this.rotateLeftRight(node)\n        }\n      } else {\n        const heightDif = (node.right?.left?.height ?? 0) - (node.right?.right?.height ?? 0)\n        if (heightDif > 0) {\n          // \u53f3\u5de6\n          res = this.rotateRightLeft(node)\n        } else if (heightDif < 0) {\n          // \u53f3\u53f3\n          res = this.rotateLeft(node)\n        }\n      }\n    }\n    return res ? res : node\n  }\n  private rotateRight(node: BSTNode<T>) {\n    const left = node.left!\n    const leftRight = left.right\n\n    left.right = node\n    node.left = leftRight\n\n    node.height = this.getHeight(node)\n    left.height = this.getHeight(left)\n    node.size = this.getSize(node)\n    left.size = this.getSize(left)\n\n    return left\n  }\n  private rotateLeft(node: BSTNode<T>) {\n    const right = node.right!\n    const rightLeft = right.left\n\n    right.left = node\n    node.right = rightLeft\n\n    node.height = this.getHeight(node)\n    right.height = this.getHeight(right)\n    node.size = this.getSize(node)\n    right.size = this.getSize(right)\n\n    return right\n  }\n  private rotateLeftRight(node: BSTNode<T>) {\n    node.left = this.rotateLeft(node.left!)\n    return this.rotateRight(node)\n  }\n  private rotateRightLeft(node: BSTNode<T>) {\n    node.right = this.rotateRight(node.right!)\n    return this.rotateLeft(node)\n  }\n\n  //#endregion\n\n  private getBalance(node: BSTNode<T>) {\n    return this.getHeight(node.left) - this.getHeight(node.right)\n  }\n  private getHeight(node: BSTNode<T> | null) {\n    if (!node) return 0\n    return Math.max(node.left?.height ?? 0, node.right?.height ?? 0) + 1\n  }\n  private getSize(node: BSTNode<T> | null) {\n    if (!node) return 0\n    return (node.left?.size ?? 0) + (node.right?.size ?? 0) + node.count\n  }\n\n  private createNode(val: T): BSTNode<T> {\n    return { id: Math.random() * new Date().valueOf(), val, left: null, right: null, size: 1, height: 1, count: 1 }\n  }\n  /** \u63d2\u5165\u5143\u7d20\n   */\n  insert(val: T) {\n    let cur = this.createNode(val)\n    if (this.isEmpty()) {\n      this.root = cur\n      this.length++\n    } else {\n      ;[, cur] = this.insertNode(this.root!, cur)\n    }\n\n    if (this.min === null || this.compare(this.min, val) > 0) {\n      this.min = val\n    }\n    if (this.max === null || this.compare(this.max, val) < 0) {\n      this.max = val\n    }\n  }\n  /**\n   *\n   * @param node \u5f53\u524d\u904d\u5386\u7684\u7ed3\u70b9\n   * @param cur \u9700\u8981\u63d2\u5165\u7684\u7ed3\u70b9\n   * @param parent \u5f53\u524d\u7ed3\u70b9\u7684\u7236\u8282\u70b9\n   * @returns \u8fd4\u56de\u5305\u542b\u4e00\u4e2a boolean \u503c,\u7528\u6765\u6807\u8bb0\u662f\u5426\u9700\u8981\u91cd\u5e73\u8861,\u4ee5\u53ca\u63d2\u5165\u7684 Node,\u5982\u679c\u662f\u91cd\u590d\u503c,\u5219\u8fd4\u56de\u5df2\u7ecf\u5b58\u5728\u7684\u90a3\u4e2a Node\n   */\n  private insertNode(node: BSTNode<T>, cur: BSTNode<T>, parent: BSTNode<T> | null = null): [boolean, BSTNode<T>] {\n    node.size++\n    const compareResult = this.compare(cur.val, node.val)\n    let res: [boolean, BSTNode<T>] | undefined\n    if (compareResult === 0) {\n      // \u8981\u63d2\u5165\u7684\u7ed3\u70b9\u6bd4\u5f53\u524d\u7ed3\u70b9\u76f8\u7b49,\u65e2\u5143\u7d20\u5df2\u5b58\u5728,\u53ea\u9700\u66f4\u65b0 count\n      node.count++\n      // \u53ea\u662f\u589e\u52a0\u8ba1\u6570,\u4e0d\u4f1a\u5bf9\u5e73\u8861\u6027\u9020\u6210\u5f71\u54cd,\u6240\u4ee5\u4e0d\u9700\u8981\u91cd\u65b0\u5e73\u8861\n      return [false, node]\n    } else if (compareResult > 0) {\n      // \u8981\u63d2\u5165\u7684\u7ed3\u70b9\u6bd4\u5f53\u524d\u7ed3\u70b9\u5927,\u5219\u9700\u8981\u63d2\u5165\u5230\u53f3\u5b50\u6811\u4e2d\n      if (node.right) {\n        res = this.insertNode(node.right, cur, node)\n        if (!res[0]) return res\n      } else {\n        node.right = cur\n        this.length++\n        res = [true, cur]\n      }\n    } else {\n      // \u8981\u63d2\u5165\u7684\u7ed3\u70b9\u6bd4\u5f53\u524d\u7ed3\u70b9\u5c0f,\u5219\u9700\u8981\u63d2\u5165\u5230\u5de6\u5b50\u6811\u4e2d\n      if (node.left) {\n        res = this.insertNode(node.left, cur, node)\n        if (!res[0]) return res\n      } else {\n        node.left = cur\n        this.length++\n        res = [true, cur]\n      }\n    }\n\n    // \u5e73\u8861\u64cd\u4f5c\n    // \u4f18\u5316: \u4f7f\u7528 res[0] \u6807\u5fd7\u5224\u65ad\u662f\u5426\u9700\u8981\u8fdb\u884c\u5e73\u8861\n    // \u5bf9\u4e8e\u65b0\u6dfb\u52a0\u7684\u7ed3\u70b9,\u603b\u662f\u9700\u8981\u8fdb\u884c\u5e73\u8861\n    // \u5982\u679c\u53d1\u73b0\u67d0\u4e2a\u5b50\u6811\u5e73\u8861\u524d\u540e\u7684\u6ca1\u6709\u53d8\u5316,\u6811\u7684\u9ad8\u5ea6\u4e5f\u6ca1\u6709\u53d8\u5316,\u5219\u540e\u7eed\u7956\u5148\u7ed3\u70b9\u4e0d\u9700\u8981\u8fdb\u884c\u5e73\u8861\u64cd\u4f5c\n    let preHeight = node.height\n    const newNode = this.balance(node)\n    if (newNode === node && node.height === preHeight) {\n      // \u5f53\u524d\u6839\u7ed3\u70b9\u4ee5\u53ca\u6811\u9ad8\u5ea6\u6ca1\u6709\u53d1\u751f\u53d8\u5316,\u5219\u540e\u7eed\u4e0d\u9700\u8981\u8fdb\u884c\u5e73\u8861\n      res = [false, res[1]]\n    } else if (newNode !== node) {\n      // \u5f53\u524d\u5143\u7d20\u53d1\u751f\u53d8\u5316,\u5bf9\u4e8e\u63d2\u5165\u6765\u8bf4,\u53ea\u4f1a\u8c03\u6574\u4e00\u6b21,\u540e\u7eed\u4e0d\u9700\u8981\u53d8\u5316\n      if (parent) {\n        parent.left === node ? (parent.left = newNode) : (parent.right = newNode)\n      } else {\n        this.root = newNode\n      }\n      res = [false, res[1]]\n    }\n    return res\n  }\n\n  /** \u5220\u9664\u5143\u7d20\n   */\n  delete(val: T) {\n    this.deleteResult = false\n    if (!this.root) return this.deleteResult\n    this.deleteNode(val, this.root, null)\n    return this.deleteResult\n  }\n  private deleteResult: boolean = false\n\n  private deleteNode(val: T, node: BSTNode<T> | null, parent: BSTNode<T> | null): BSTNode<T> | null {\n    if (!node) return null\n\n    let res = this.compare(val, node.val)\n    if (res === 0) {\n      this.deleteResult = true\n      // \u627e\u5230\u8981\u5220\u9664\u7684\u5143\u7d20\n      node.count--\n      node.size--\n      // \u5b58\u5728\u591a\u4e2a\u5f53\u524d\u5143\u7d20,\u6240\u4ee5\u53ea\u662f\u51cf\u53bb\u8ba1\u6570,\u5e76\u4e0d\u9700\u8981\u6539\u53d8\u7ed3\u6784\n      if (node.count > 0) return node\n\n      if (!node.left || !node.right) {\n        if (this.min === val) {\n          this.minCache = false\n        }\n        if (this.max === val) {\n          this.maxCache = false\n        }\n        this.length--\n        // \u53ea\u6709\u4e00\u4e2a\u5b50\u7ed3\u70b9\u6216\u8005\u6ca1\u6709\u5b50\u7ed3\u70b9,\u5219\u76f4\u63a5\u8fd4\u56de\u5b50\u7ed3\u70b9\u5373\u53ef\n        if (!parent) {\n          this.root = node.left ?? node.right!\n          return this.root\n        } else {\n          return node.left ?? node.right!\n        }\n      } else {\n        // \u540c\u65f6\u5b58\u5728\u5de6\u53f3\u7ed3\u70b9,\u5219\u9700\u8981\u627e\u5230\u4e00\u4e2a\u503c\u653e\u5230\u5f53\u524d\u4f4d\u7f6e,\u7136\u540e\u5220\u9664\u90a3\u4e2a\u503c\n        // \u8fd9\u4e2a\u503c\u53ef\u4ee5\u662f\u6bd4\u5f53\u524d\u503c\u5927\u7684\u6700\u5c0f\u503c,\u4e5f\u53ef\u4ee5\u662f\u6bd4\u5f53\u524d\u503c\u5c0f\u7684\u6700\u5927\u503c\n        // \u8fd9\u91cc\u6839\u636e\u5de6\u53f3\u5b50\u6811\u7684\u9ad8\u5ea6\u8fdb\u884c\u9009\u62e9\n        const selectLeft = node.left.height > node.right.height\n        let replaceNode = selectLeft ? this.pre(node)! : this.next(node)!,\n          name: 'left' | 'right' = selectLeft ? 'left' : 'right'\n\n        node.val = replaceNode.val\n        node.count = replaceNode.count\n        replaceNode.count = 0\n        node[name] = this.deleteNode(replaceNode.val, node[name], node)\n      }\n    } else if (res > 0) {\n      node.right = this.deleteNode(val, node.right, node)\n    } else {\n      node.left = this.deleteNode(val, node.left, node)\n    }\n\n    // \u91cd\u65b0\u8ba1\u7b97 size\n    node.size = this.getSize(node)\n\n    let preHeight = node.height\n    const newNode = this.balance(node)\n    if (parent) {\n      parent.left === node ? (parent.left = newNode) : (parent.right = newNode)\n    } else {\n      this.root = newNode\n    }\n\n    return newNode\n  }\n  // \u5220\u9664\u64cd\u4f5c\u65f6,\u83b7\u53d6\u66ff\u4ee3\u5f53\u524d\u7ed3\u70b9\u7684\u7ed3\u70b9\n  private next(node: BSTNode<T>) {\n    let next = node.right\n    while (next?.left) {\n      next = next.left\n    }\n    return next\n  }\n  private pre(node: BSTNode<T>) {\n    let pre = node.left\n    while (pre?.right) {\n      pre = pre.right\n    }\n    return pre\n  }\n\n  search(val: T, compare?: (a: T, b: T) => number) {\n    if (this.isEmpty()) {\n      return null\n    }\n    const [, node] = this.searchCeilingNode(this.root!, val, compare ?? this.compare)\n    return node.val\n  }\n\n  private searchCeilingNode(\n    node: BSTNode<T>,\n    val: T,\n    compare: (a: T, b: T) => number,\n    parent: BSTNode<T> | null = null,\n  ): [BSTNode<T> | null, BSTNode<T>] {\n    const res = compare(val, node.val)\n    if (res === 0) {\n      return [parent, node]\n    } else if (res > 0) {\n      if (node.right) {\n        return this.searchCeilingNode(node.right, val, compare, node)\n      } else {\n        return [parent, node]\n      }\n    } else {\n      if (node.left) {\n        const [p, value] = this.searchCeilingNode(node.left, val, compare, node)\n        if (compare(value.val, val) < 0) {\n          return [parent, node]\n        } else {\n          return [p, value]\n        }\n      } else {\n        return [parent, node]\n      }\n    }\n  }\n  /** \u83b7\u53d6\u5927\u4e8e\u7b49\u4e8e val \u7684\u6700\u5c0f\u503c\n   */\n  ceiling(val: T) {\n    if (this.isEmpty()) {\n      return null\n    }\n    const [, node] = this.searchCeilingNode(this.root!, val, this.compare)\n    return this.compare(node.val, val) >= 0 ? node.val : null\n  }\n\n  private searchFloorNode(\n    node: BSTNode<T>,\n    val: T,\n    compare: (a: T, b: T) => number,\n    parent: BSTNode<T> | null = null,\n  ): [BSTNode<T> | null, BSTNode<T>] {\n    const res = compare(val, node.val)\n    if (res === 0) {\n      return [parent, node]\n    } else if (res > 0) {\n      if (node.right) {\n        const [p, value] = this.searchFloorNode(node.right, val, compare, node)\n        if (compare(value.val, val) > 0) {\n          return [parent, node]\n        } else {\n          return [p, value]\n        }\n      } else {\n        return [parent, node]\n      }\n    } else {\n      if (node.left) {\n        return this.searchFloorNode(node.left, val, compare, node)\n      } else {\n        return [parent, node]\n      }\n    }\n  }\n  /** \u83b7\u53d6\u5c0f\u4e8e\u7b49\u4e8e val \u7684\u6700\u5927\u503c\n   */\n  floor(val: T) {\n    if (this.isEmpty()) {\n      return null\n    }\n    const [, node] = this.searchFloorNode(this.root!, val, this.compare)\n    return this.compare(node.val, val) <= 0 ? node.val : null\n  }\n\n  /** \u83b7\u53d6\u7b2c k \u4e2a\u5143\u7d20\u7684\u503c,k \u4ece 1 \u5f00\u59cb,\u5982\u679c k \u8d85\u51fa\u8fb9\u754c,\u8fd4\u56de null\n   */\n  searchKth(k: number) {\n    if (this.isEmpty()) {\n      return null\n    }\n    if (k <= 0 || k > this.size()) {\n      return null\n    }\n    const node = this.searchNodeKth(this.root!, k)\n    return node.val\n  }\n  private searchNodeKth(node: BSTNode<T>, k: number): BSTNode<T> {\n    const rSize = node.right?.size ?? 0\n    if (rSize === k - 1 || (rSize < k && rSize + node.count >= k)) return node\n    if (node.right && rSize > k - 1) return this.searchNodeKth(node.right, k)\n    else return this.searchNodeKth(node.left!, k - (node.right?.size ?? 0) - node.count)\n  }\n\n  /** \u7edf\u8ba1\u5927\u4e8e\u7b49\u4e8e val \u7684\u4e2a\u6570\n   * @param val \u9700\u8981\u7edf\u8ba1\u7684\u503c\n   */\n  countGreaterThanEq(val: T) {\n    if (!this.root) return 0\n    return this.countCompare(val, (a, b) => this._compare(a, b), this.root)\n  }\n  private countCompare(val: T, compare: (a: T, b: T) => number, node: BSTNode<T>, pre = 0): number {\n    const res = compare(val, node.val)\n    if (res === 0) {\n      return pre + (node.right?.size ?? 0) + node.count\n    } else if (res > 0) {\n      if (node.right) {\n        return this.countCompare(val, compare, node.right, pre)\n      } else {\n        return pre\n      }\n    } else {\n      let count = pre + (node.right?.size ?? 0) + node.count\n      if (node.left) {\n        return this.countCompare(val, compare, node.left, count)\n      } else {\n        return count\n      }\n    }\n  }\n\n  /** \u5c06 BST \u8f6c\u6210\u6570\u7ec4,\u6309\u5347\u5e8f\u6392\u5217\u8fd4\u56de\n   */\n  toArray(): T[] {\n    if (!this.root) return []\n    const res: T[] = []\n    const dfs = (node: BSTNode<T>) => {\n      if (node.left) dfs(node.left)\n      res.push(node.val)\n      if (node.right) dfs(node.right)\n    }\n    dfs(this.root)\n    return res\n  }\n}",
    "submit_ts": 1716648999.0
}