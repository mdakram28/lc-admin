{
    "username": "Ujimatsu_Chiya",
    "submission": "# include <bits/stdc++.h>\n# define mem(a,b) memset(a,b,sizeof(a))\n# define lb(x) ((x) & -(x))\n# define pi pair<int,int>\n# define X first\n# define Y second\n# ifdef LOCAL\n# include \"leetcode.h\"\n# endif // LOCAL\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};\n\ntemplate<typename T>\nostream & operator << (ostream &out,const set<T>&obj){out<<\"set(\";for(auto it=obj.begin();it!=obj.end();it++) out<<(it==obj.begin()?\"\":\", \")<<*it;out<<\")\";return out;}\ntemplate<typename T>\nostream & operator << (ostream &out,const unordered_set<T>&obj){out<<\"unordered_set(\";for(auto it=obj.begin();it!=obj.end();it++) out<<(it==obj.begin()?\"\":\", \")<<*it;out<<\")\";return out;}\ntemplate<typename T1,typename T2>\nostream & operator << (ostream &out,const map<T1,T2>&obj){out<<\"map(\";for(auto it=obj.begin();it!=obj.end();it++) out<<(it==obj.begin()?\"\":\", \")<<it->first<<\": \"<<it->second;out<<\")\";return out;}\ntemplate<typename T1,typename T2>\nostream & operator << (ostream &out,const unordered_map<T1,T2>&obj){out<<\"unordered_map(\";for(auto it=obj.begin();it!=obj.end();it++) out<<(it==obj.begin()?\"\":\", \")<<it->first<<\": \"<<it->second;out<<\")\";return out;}\ntemplate<typename T1,typename T2>\nostream & operator << (ostream &out,const pair<T1,T2>&obj){out<<\"<\"<<obj.first<<\", \"<<obj.second<<\">\";return out;}\ntemplate<typename T>\nostream & operator << (ostream &out,const vector<T>&obj){out<<\"vector(\";for(auto it=obj.begin();it!=obj.end();it++) out<<(it==obj.begin()?\"\":\", \")<<*it;out<<\")\";return out;}\n\ntemplate <typename T>\nstruct HashTable {\n  vector<T> val;\n  void add(T x) { val.push_back(x); }\n  void init() {\n    sort(ALL(val));\n    val.erase(unique(ALL(val)), val.end());\n  }\n  int query(T x) { return lower_bound(ALL(val), x) - val.begin() + 1; }\n  T operator[](const int t) const { return val[t - 1]; }\n  int size() { return val.size(); }\n  void clear(){val.clear();}\n};\nll mod=1e9+7;\nvoid add(int &x, int y) {\n    (x += y) >= mod && (x -= mod);\n}\nvoid sub(int &x, int y) {\n    (x -= y) < 0 && (x += mod);\n}\n\nstruct MaxFlowMinCost{\n    static const int N=1024,M=300004;\n    struct E{\n        int next,to;\n        ll val,cost;\n    }e[M<<1];\n    int head[N],tot=0,st,ed;\n    void add(int x,int y,ll z,ll c, bool is_directed = true){\n        e[tot]=E{y,head[x],z,c};\n        head[x]=tot++;\n        ll nz = is_directed ? 0 : z;\n        e[tot]=E{x,head[y],nz,-c};\n        head[y]=tot++;\n    }\n    ll flow=0,ans=0;\n    bool vis[N];\n    int pre[N];\n    ll incf[N],d[N];\n    ll INF=0xbfbfbfbfbfbfbfbf;\n    void update(){\n        int x=ed;\n        while(x!=st){\n            int i=pre[x];\n            e[i].val-=incf[ed];\n            e[i^1].val+=incf[ed];\n            x=e[i^1].next;\n        }\n        //cout << incf[ed] << ' ' << d[ed] << endl;\n        flow += incf[ed];\n        ans += d[ed]*incf[ed];\n    }\n    bool spfa(){\n        queue<int>q;mem(d,0xbf);mem(vis,0);\n        q.push(st);d[st]=0;vis[st]=1;\n        incf[st]=-INF;\n        while(!q.empty()){\n            int u=q.front();vis[u]=0;q.pop();\n            for(int i=head[u];~i;i=e[i].to){\n                if(!e[i].val) continue;\n                int v=e[i].next;\n                // \u8d39\u7528\u6700\u5c0f\uff0c\u5982\u679c\u8d39\u7528\u6700\u5927\u90a3\u4e48\u6539\u6210>\u3002\n                if(d[u]+e[i].cost>d[v]){\n                    d[v]=d[u]+e[i].cost;\n                    incf[v]=min(incf[u],e[i].val);\n                    pre[v]=i;\n                    if(!vis[v]){\n                        vis[v]=1;q.push(v);\n                    }\n                }\n            }\n        }\n        return d[ed]!=INF;\n    }\n    void init(int s,int e){\n        mem(head,-1);tot=0;\n        flow=ans=0;\n        st=s;ed=e;\n    }\n    auto run(){\n        while(spfa()) update();\n        return make_pair(ans,flow);\n    }\n}sol;\n\nclass Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& a) {\n        int s=1002,e=1003;\n        sol.init(s,e);\n        int us=1012,ue=1013;\n        int n=a.size(),m=a[0].size();\n        for(int i=0;i<n;i++){\n            sol.add(us,i,1,0);\n        }\n        for(int j=0;j<m;j++){\n            sol.add(n+j,ue,1,0);\n        }\n        sol.add(s,us,3,0);\n        sol.add(ue,e,3,0);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                sol.add(i,n+j,1,a[i][j]);\n            }\n        }\n        auto [c, fl] = sol.run();\n        //cout << c << ' ' << fl <<endl;\n        return c;\n    }\n};\n",
    "submit_ts": "1723906483",
    "subm_id": "556318713"
}