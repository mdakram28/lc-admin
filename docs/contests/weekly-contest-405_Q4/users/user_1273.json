{
    "username": "pyjuan91",
    "submission": "// Trie node class\nclass TrieNode {\npublic:\n  // A map to store children nodes\n  std::unordered_map<char, std::unique_ptr<TrieNode>> children;\n  // Flag to mark the end of a word\n  bool isEndOfWord = false;\n  int cost = 1e9;\n  // Method to get the next TrieNode given a character\n  TrieNode* getNextNode(char c) {\n    if (children.count(c)) {\n      return children[c].get();\n    }\n    return nullptr;\n  }\n};\n\n// Trie class\nclass Trie {\nprivate:\n  std::unique_ptr<TrieNode> root;\n\npublic:\n  // Constructor\n  Trie() : root(std::make_unique<TrieNode>()) {}\n\n  TrieNode* getRoot() {\n    return root.get();\n  }\n  // Function to insert a word into the Trie\n  void insert(const std::string& word, int cost) {\n    TrieNode* node = root.get();\n    for (char ch : word) {\n      if (!node->children.count(ch)) {\n        node->children[ch] = std::make_unique<TrieNode>();\n      }\n      node = node->children[ch].get();\n    }\n    node->isEndOfWord = true;\n    node->cost = min(node->cost, cost);\n  }\n\n  // Function to search for a word in the Trie\n  bool search(const std::string& word) const {\n    TrieNode* node = root.get();\n    for (char ch : word) {\n      if (!node->children.count(ch)) {\n        return false;\n      }\n      node = node->children[ch].get();\n    }\n    return node->isEndOfWord;\n  }\n\n  // Function to check if there is any word in the Trie that starts with the\n  // given prefix\n  bool startsWith(const std::string& prefix) const {\n    TrieNode* node = root.get();\n    for (char ch : prefix) {\n      if (!node->children.count(ch)) {\n        return false;\n      }\n      node = node->children[ch].get();\n    }\n    return true;\n  }\n};\n\nclass Solution {\npublic:\n  int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n    int m = target.size(), n = words.size();\n    auto trie = new Trie();\n    for (int i = 0; i < n; i++) {\n      trie->insert(words[i], costs[i]);\n    }\n\n    vector<int> dp(m + 1, 1e9);\n    dp[0] = 0, target = \" \" + target;\n    for (int i = 1; i <= m; i++) {\n      if (dp[i - 1] == 1e9) continue;\n      TrieNode* node = trie->getRoot();\n      for (int j = i; j <= m; j++) {\n        node = node->getNextNode(target[j]);\n        if (!node) break;\n        dp[j] = min(dp[j], dp[i - 1] + node->cost);\n      }\n    }\n    return dp[m] == 1e9 ? -1 : dp[m];\n  }\n};",
    "submit_ts": "1720322533",
    "subm_id": "1312352484"
}