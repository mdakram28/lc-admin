{
    "username": "Xiaomeng Yang",
    "submission": "using i64 = long long;\n\nconstexpr int MAXV = 2048;\nconstexpr int MAXE = 1000010;\nconstexpr int F_INF = 0x3F3F3F3F;\nconstexpr i64 C_INF = 0x3F3F3F3F3F3F3F3FLL;\n\ntemplate <typename F = int, typename C = i64>\nstruct MinCostFlow {\n  struct Edge {\n    int u, v, nxt;\n    F flow;\n    C cost;\n    Edge() {}\n    Edge(int _u, int _v, int n, const F& f, const C& c)\n        : u(_u), v(_v), nxt(n), flow(f), cost(c) {}\n  } edge[MAXE];\n\n  int head[MAXV], nV, nE;\n  int pre[MAXV], que[MAXV * MAXV * 2], front, rear;\n  F his[MAXV];\n  C dis[MAXV];\n  bool vis[MAXV];\n\n  void init(int v) {\n    memset(head, -1, sizeof(head));\n    nV = v;\n    nE = 0;\n  }\n\n  void addEdge(int a, int b, const F& f, const C& c) {\n    edge[nE] = Edge(a, b, head[a], f, c);\n    head[a] = nE++;\n    edge[nE] = Edge(b, a, head[b], 0, -c);\n    head[b] = nE++;\n  }\n\n  F minCostFlow(int src, int dst, C& netCost, bool isFeasible = false) {\n    int i, x, y;\n    F totFlow = 0;\n\n    for (netCost = 0;;) {\n      fill(dis, dis + nV, C_INF);\n      memset(vis, 0, sizeof(vis));\n      front = rear = nV;\n      dis[src] = 0;\n      his[src] = F_INF;\n      vis[que[rear++] = src] = true;\n      while (front < rear) {\n        for (vis[x = que[front++]] = false, i = head[x]; ~i; i = edge[i].nxt) {\n          if (edge[i].flow && dis[y = edge[i].v] > dis[x] + edge[i].cost) {\n            dis[y] = dis[x] + edge[i].cost;\n            pre[y] = i;\n            his[y] = min(his[x], edge[i].flow);\n            if (!vis[y]) {\n              if (front < rear && dis[y] < dis[que[front]])\n                que[--front] = y;\n              else\n                que[rear++] = y;\n              vis[y] = true;\n            }\n          }\n        }\n      }\n      if (dis[dst] >= C_INF) break;\n      if (isFeasible && dis[dst] >= 0) break;\n      totFlow += his[dst];\n      netCost += dis[dst] * his[dst];\n      for (i = dst; i != src; i = edge[pre[i]].u) {\n        edge[pre[i]].flow -= his[dst];\n        edge[pre[i] ^ 1].flow += his[dst];\n      }\n    }\n\n    return totFlow;\n  }\n};\n\nMinCostFlow<> graph;\n\nclass Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& board) {\n      int m = board.size(), n = board[0].size();\n      int v = m + n + 3, x = v - 3, src = v - 2, dst = v - 1;\n      graph.init(v);\n      for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n          graph.addEdge(i, m + j, 1, -board[i][j]);\n        }\n      }\n      for (int i = 0; i < m; ++i) {\n        graph.addEdge(x, i, 1, 0);\n      }\n      for (int i = 0; i < n; ++i) {\n        graph.addEdge(m + i, dst, 1, 0);\n      }\n      graph.addEdge(src, x, 3, 0);\n      i64 ret = 0;\n      graph.minCostFlow(src, dst, ret);\n      return -ret;\n    }\n};",
    "submit_ts": "1723905839",
    "subm_id": "1359021721"
}