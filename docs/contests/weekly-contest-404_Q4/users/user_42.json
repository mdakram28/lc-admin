{
    "username": "MvKaio",
    "submission": "class Solution {\n    pair<int, int> bfs(vector<vector<int>>& g, int s) {\n        queue<int> q; q.push(s);\n        vector<int> d(g.size(), 1e9);\n        d[s] = 0;\n        int last = s;\n        while (q.size()) {\n            int v = q.front(); q.pop();\n            last = v;\n            for (auto u : g[v]) if (d[u] > d[v] + 1) {\n                d[u] = d[v] + 1;\n                q.push(u);\n            }\n        }\n        return {last, d[last]};\n    }\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        vector<vector<int>> t1(edges1.size() + 1), t2(edges2.size() + 1);\n        for (auto e : edges1) {\n            t1[e[0]].push_back(e[1]);\n            t1[e[1]].push_back(e[0]);\n        }\n        \n        for (auto e : edges2) {\n            t2[e[0]].push_back(e[1]);\n            t2[e[1]].push_back(e[0]);\n        }\n        \n        auto [v1, _] = bfs(t1, 0);\n        auto [___, d1] = bfs(t1, v1);\n        \n        auto [v2, __] = bfs(t2, 0);\n        auto [____, d2] = bfs(t2, v2);\n\n        return max({d1, d2, (d1+1)/2 + (d2+1)/2 + 1});\n    }\n};",
    "submit_ts": "1719715482",
    "subm_id": "1304337942"
}