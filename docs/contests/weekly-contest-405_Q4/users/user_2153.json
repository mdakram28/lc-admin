{
    "username": "L0KI_29",
    "submission": "class Solution{public:    struct TrieNode    {        unordered_map<char, TrieNode *> children;        vector<pair<int, int>> wordEnds;    };\n    class Trie    {    public:        TrieNode *root;        Trie() { root = new TrieNode(); }\n        void insert(string &word, int index, int cost)        {            TrieNode *node = root;            for (char c : word)            {                if (!node->children.count(c))                    node->children[c] = new TrieNode();                node = node->children[c];            }            node->wordEnds.push_back({index, cost});        }    };\n    int minimumCost(string target, vector<string> &words, vector<int> &costs)    {        int n = target.size();        vector<int> dp(n + 1, INT_MAX);        dp[0] = 0;\n        Trie trie;        for (int i = 0; i < words.size(); ++i)        {            trie.insert(words[i], i, costs[i]);        }\n        for (int i = 0; i < n; ++i)        {            if (dp[i] == INT_MAX)                continue;\n            TrieNode *node = trie.root;            for (int j = i; j < n; ++j)            {                if (!node->children.count(target[j]))                    break;                node = node->children[target[j]];                for (auto &p : node->wordEnds)                {                    int wordIndex = p.first;                    int wordCost = p.second;                    int len = words[wordIndex].size();                    if (i + len <= n)                    {                        dp[i + len] = min(dp[i + len], dp[i] + wordCost);                    }                }            }        }\n        return dp[n] == INT_MAX ? -1 : dp[n];    }};",
    "submit_ts": "1720323161",
    "subm_id": "1312368804"
}