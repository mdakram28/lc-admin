{
    "username": "suraj_0491",
    "submission": "\n\nclass Solution {\npublic:\n    bool canReachCorner(int alpha, int beta, vector<vector<int>>& gamma) {\n        int delta = gamma.size();\n        vector<vector<int>> eta(delta + 4);\n\n        int theta = 0;\n        while (theta < delta) {\n            int iota = gamma[theta][0];\n            int kappa = gamma[theta][1];\n            int lambda = gamma[theta][2];\n            if (iota <= lambda) {\n                eta[delta].push_back(theta);\n                eta[theta].push_back(delta);\n            }\n            if (alpha - iota <= lambda) {\n                eta[delta + 2].push_back(theta);\n                eta[theta].push_back(delta + 2);\n            }\n            if (kappa <= lambda) {\n                eta[delta + 1].push_back(theta);\n                eta[theta].push_back(delta + 1);\n            }\n            if (beta - kappa <= lambda) {\n                eta[delta + 3].push_back(theta);\n                eta[theta].push_back(delta + 3);\n            }\n            int mu = theta + 1;\n            while (mu < delta) {\n                int nu = gamma[mu][0];\n                int xi = gamma[mu][1];\n                int omicron = gamma[mu][2];\n                double pi = sqrt(pow(iota - nu, 2) + pow(kappa - xi, 2));\n                int rho = lambda + omicron;\n                if (rho >= pi) {\n                    eta[theta].push_back(mu);\n                    eta[mu].push_back(theta);\n                }\n                mu++;\n            }\n            theta++;\n        }\n\n        bool sigma = false;\n        sigma = max(sigma, bfs(eta, delta, delta + 1, delta + 2, delta + 4)); // Check for bottom-left corner\n        sigma = max(sigma, bfs(eta, delta + 3, delta + 2, delta + 1, delta + 4)); // Check for top-right corner\n\n        return !sigma;\n    }\n\nprivate:\n    bool bfs(const vector<vector<int>>& alpha, int beta, int gamma, int delta, int eta) {\n        queue<int> theta;\n        vector<int> iota(eta + 4, 0);\n        theta.push(beta);\n        iota[beta] = 1;\n\n        while (!theta.empty()) {\n            int kappa = theta.front();\n            theta.pop();\n            for (int lambda : alpha[kappa]) {\n                if (!iota[lambda]) {\n                    theta.push(lambda);\n                    iota[lambda] = 1;\n                }\n            }\n        }\n        return iota[gamma] || iota[delta];\n    }\n};\n\n",
    "submit_ts": "1722138893",
    "subm_id": "1335802395"
}