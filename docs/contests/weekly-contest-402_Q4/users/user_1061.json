{
    "username": "MalharGadge",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long double lld;\ntypedef long long ll;\n#define fr(a,b,i) for (int i=a;i<b;i++)\n#define rfr(a,b,i) for(int i=a;i>=b;i--)\n#define rep(i,n) fr(0,n,i)\n#define ff first\n#define ss second\n#define pb push_back\n#define endl '\\n'\n#define inf LLONG_MAX\n#define all(c) (c).begin(), (c).end()\nconst ll mod = 1000000007;\n\ntemplate <typename T>\nvoid chmin(T &f, T s){ f = min(f, s); }\ntemplate <typename T>\nvoid chmax(T &f, T s){ f = max(f, s); }\nll expo(ll a, ll b, ll mod) {ll res = 1; while (b > 0)\n{if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}\nll modinv(ll a, ll b) {return expo(a, b - 2, b);}\nll modadd(ll a, ll b, ll m) { return ( a % m + b % m) % m;}\nll modmul(ll a, ll b, ll m) { return ( a % m * b % m) % m;}\nll modsub(ll a, ll b, ll m) { return ((a%m - b%m)+ m) % m;}\nll moddiv(ll a, ll b, ll m) { return modmul(a, modinv(b, m), m) % m ;}\n\ntemplate<typename T>\nstruct SegmentTree {\n    vector<T> tree;\n    ll n;\n    T default_value;\n    function<T(T, T)> combine;\n\n    SegmentTree(vector<T>& data, T default_val, function<T(T, T)> comb)\n        : n(data.size()), default_value(default_val), combine(comb) {\n        tree.resize(4 * n);\n        build(data, 0, 0, n - 1);\n    }\n\n    void build(vector<T>& data, ll node, ll start, ll end) {\n        if (start == end) {\n            tree[node] = data[start];\n        } else {\n            ll mid = (start + end) / 2;\n            build(data, 2 * node + 1, start, mid);\n            build(data, 2 * node + 2, mid + 1, end);\n            tree[node] = combine(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    void update(ll idx, T value) {\n        update(0, 0, n - 1, idx, value);\n    }\n\n    void update(ll node, ll start, ll end, ll idx, T value) {\n        if (start == end) {\n            tree[node] = value;\n        } else {\n            ll mid = (start + end) / 2;\n            if (idx <= mid) {\n                update(2 * node + 1, start, mid, idx, value);\n            } else {\n                update(2 * node + 2, mid + 1, end, idx, value);\n            }\n            tree[node] = combine(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    T query(ll l, ll r) {\n        return query(0, 0, n - 1, l, r);\n    }\n\n    T query(ll node, ll start, ll end, ll l, ll r) {\n        if (r < start || end < l) {\n            return default_value;\n        }\n        if (l <= start && end <= r) {\n            return tree[node];\n        }\n        ll mid = (start + end) / 2;\n        T left_result = query(2 * node + 1, start, mid, l, r);\n        T right_result = query(2 * node + 2, mid + 1, end, l, r);\n        return combine(left_result, right_result);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        vector<int> isPeak(n, 0);\n        vector<ll> pre(n, 0);\n\n        fr(1, n-1, i) {\n            if(a[i] > a[i-1] && a[i] > a[i+1]) {\n                isPeak[i] = 1;\n            }\n        }\n\n        SegmentTree<int> segmentTree(isPeak, 0, [](int a, int b) { return a + b; });\n\n        vector<int> ans;\n\n        for(auto& query : q) {\n            if(query[0] == 1) {\n                int l = query[1], r = query[2];\n                ans.pb(segmentTree.query(l + 1, r - 1));\n            } else {\n                int index = query[1], val = query[2];\n                a[index] = val;\n\n                if(index > 0 && index < n-1) {\n                    updatePeakStatus(segmentTree, isPeak, a, index);\n                }\n\n                if(index - 1 > 0) {\n                    updatePeakStatus(segmentTree, isPeak, a, index - 1);\n                }\n\n                if(index + 1 < n - 1) {\n                    updatePeakStatus(segmentTree, isPeak, a, index + 1);\n                }\n            }\n        }\n\n        return ans;\n    }\n\n    void updatePeakStatus(SegmentTree<int>& segmentTree, vector<int>& isPeak, vector<int>& a, int index) {\n        bool wasPeak = isPeak[index];\n        bool isNowPeak = (index > 0 && index < a.size() - 1 && a[index] > a[index - 1] && a[index] > a[index + 1]);\n        if(wasPeak != isNowPeak) {\n            isPeak[index] = isNowPeak ? 1 : 0;\n            segmentTree.update(index, isPeak[index]);\n        }\n    }\n};\n",
    "submit_ts": "1718509119",
    "subm_id": "1289699900"
}