{
    "username": "Agnimandur",
    "submission": "#define ll long long\n\nclass Solution {\npublic:\n    struct SegmentTree {\n        vector<vector<ll>> tree;\n        int n;\n        vector<ll> NONE = {-10000000,0,0,0}; //set this manually\n\n        SegmentTree(int n) {\n            this->n=n;\n            tree.assign(4*n+1,NONE);\n        }\n\n        //set this manually\n        vector<ll> merge(vector<ll>& a, vector<ll>& b) {\n            //{XX,XT,TX,TT}\n            // cout << a[0] << ' ' << a[1] << ' ' << a[2] << ' ' << a[3] << '\\n';\n            // cout << b[0] << ' ' << b[1] << ' ' << b[2] << ' ' << b[3] << '\\n';\n            ll xx = max(a[0] + max(b[0],b[2]),a[1] + b[0]);\n            ll xt = max(a[0] + max(b[3],b[1]), a[1]+b[1]);\n            ll tx = max(a[2] + max(b[0],b[2]), a[3] + b[0]);\n            ll tt = max(a[3] + b[1], a[2] + max(b[3],b[1]));\n            // cout << xx << ' ' << xt << ' ' << tx << ' ' << tt << '\\n';\n            // cout << '\\n';\n            return {xx,xt,tx,tt};\n        }\n        \n        void initialize(int t, int L, int R, vector<int>& nums) {\n            if (L == R) {\n                tree[t] = {0, 0, 0, max(0LL,(ll)nums[L])};\n                return;\n            }\n            int M = (L+R)/2;\n            initialize(2*t,L,M,nums);\n            initialize(2*t+1,M+1,R,nums);\n            tree[t] = merge(tree[2*t],tree[2*t+1]);\n        }\n        \n        void update(int t, int L, int R, int p, vector<ll>& value) {\n            if (L == R) {\n                tree[t] = value;\n                return;\n            }\n            int M = (L+R)/2;\n            if (p <= M) update(2*t,L,M,p,value);\n            else update(2*t+1,M+1,R,p,value);\n            \n            tree[t] = merge(tree[2*t],tree[2*t+1]);\n        }\n\n        void update(int p, ll v) {\n            vector<ll> value = {0, 0, 0, max(0LL,v)};\n            update(1,0,n-1,p,value);\n        }\n\n        vector<ll> q(int t, int L, int R, int l, int r) {\n            if (r < L || l > R) return NONE;\n            if (l <= L && R <= r) return tree[t];\n            \n            int M = (L+R)/2;\n            vector<ll> left = q(2*t,L,M,l,r);\n            vector<ll> right = q(2*t+1,M+1,R,l,r);\n            return merge(left,right);\n        }\n\n        ll query(int l, int r) {\n            vector<ll> value = q(1,0,n-1,l,r);\n            return max(max(value[0],value[1]),max(value[2],value[3]));\n        }\n    };\n    \n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        SegmentTree st(n);\n        // for (int i = 0; i < n; i++) {\n        //     st.update(i,nums[i]);\n        // }\n        st.initialize(1,0,n-1,nums);\n        ll ans = 0;\n        for (vector<int> q: queries) {\n            st.update(q[0],q[1]);\n            ans += st.query(0,n-1);\n        }\n        return (int)(ans % (1000000007));\n    }\n};",
    "submit_ts": 1716695285.0
}