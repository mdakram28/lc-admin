{
    "username": "ghmtech",
    "submission": "class Solution {\nclass PeakCounter {\npublic:\n    PeakCounter(const std::vector<int>& nums) : nums(nums), n(nums.size()) {\n        peaks.assign(n, false);\n        segmentTree.assign(4 * n, 0);\n        build(0, n - 1, 0);\n    }\n\n    void update(int index, int value) {\n        nums[index] = value;\n        updatePeak(index);\n        updatePeak(index - 1);\n        updatePeak(index + 1);\n    }\n\n    int countPeaks(int l, int r) {\n        if (l >= r - 1) return 0; // No peaks possible\n        return query(0, n - 1, l + 1, r - 1, 0);\n    }\n\nprivate:\n    std::vector<int> nums;\n    std::vector<bool> peaks;\n    std::vector<int> segmentTree;\n    int n;\n\n    bool isPeak(int i) {\n        return i > 0 && i < n - 1 && nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    }\n\n    void updatePeak(int i) {\n        if (i <= 0 || i >= n - 1) return;\n        bool wasPeak = peaks[i];\n        bool nowPeak = isPeak(i);\n        if (wasPeak != nowPeak) {\n            peaks[i] = nowPeak;\n            updateSegmentTree(0, n - 1, i, nowPeak ? 1 : -1, 0);\n        }\n    }\n\n    void build(int l, int r, int pos) {\n        if (l == r) {\n            if (isPeak(l)) {\n                peaks[l] = true;\n                segmentTree[pos] = 1;\n            } else {\n                segmentTree[pos] = 0;\n            }\n            return;\n        }\n        int mid = l + (r - l) / 2;\n        build(l, mid, 2 * pos + 1);\n        build(mid + 1, r, 2 * pos + 2);\n        segmentTree[pos] = segmentTree[2 * pos + 1] + segmentTree[2 * pos + 2];\n    }\n\n    void updateSegmentTree(int l, int r, int idx, int value, int pos) {\n        if (idx < l || idx > r) return;\n        if (l == r) {\n            segmentTree[pos] += value;\n            return;\n        }\n        int mid = l + (r - l) / 2;\n        updateSegmentTree(l, mid, idx, value, 2 * pos + 1);\n        updateSegmentTree(mid + 1, r, idx, value, 2 * pos + 2);\n        segmentTree[pos] = segmentTree[2 * pos + 1] + segmentTree[2 * pos + 2];\n    }\n\n    int query(int l, int r, int ql, int qr, int pos) {\n        if (ql > r || qr < l) return 0;\n        if (ql <= l && qr >= r) return segmentTree[pos];\n        int mid = l + (r - l) / 2;\n        return query(l, mid, ql, qr, 2 * pos + 1) + query(mid + 1, r, ql, qr, 2 * pos + 2);\n    }\n};\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int>ans;\n        \n         PeakCounter pc1(nums);\n    for (const auto& query : queries) {\n        if (query[0] == 1) {\n            ans.push_back(pc1.countPeaks(query[1], query[2]));\n        } else if (query[0] == 2) {\n            pc1.update(query[1], query[2]);\n        }\n    }\n        return ans;\n    }\n};",
    "submit_ts": "1718507943",
    "subm_id": "1289667117"
}