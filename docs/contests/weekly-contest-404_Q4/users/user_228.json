{
    "username": "bnlvv",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        \n        def bfs(u, graph): \n            \"\"\"Return \"\"\"\n            ans = 0 \n            queue = deque([(u, -1)])\n            while queue:\n                ans += 1\n                for _ in range(len(queue)): \n                    u, p = queue.popleft()\n                    for v in graph[u]: \n                        if v != p: \n                            queue.append((v, u))\n            return ans, u\n        \n        def fn(edges): \n            \"\"\"Return \"\"\"\n            n = len(edges)+1\n            graph = [[] for _ in range(n)]\n            for u, v in edges: \n                graph[u].append(v)\n                graph[v].append(u)\n            _, u = bfs(0, graph)\n            dia, uu = bfs(u, graph)\n            # print(u, uu, dia)\n            return dia\n        \n        cnt1 = fn(edges1)\n        cnt2 = fn(edges2)\n        return max(cnt1-1, cnt2-1, cnt1//2+cnt2//2+1)\n",
    "submit_ts": 1719717897.0
}