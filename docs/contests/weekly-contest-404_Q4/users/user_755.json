{
    "username": "MinhBaoSoCool",
    "submission": "class Solution {\npublic:\n    \n    int M[100005];\n    \n    vector<vector<int>> buildGraph(vector<vector<int>>& edges){\n        int n=edges.size()+1;\n        vector<vector<int>> g;\n        for(int i=0;i<n;++i) {\n            g.push_back(vector<int>());\n        }\n        for(vector<int> e: edges){\n            g[e[0]].push_back(e[1]);\n            g[e[1]].push_back(e[0]);\n        }\n        return g;\n    }\n    \n    vector<int> getRank(vector<vector<int>>& g){\n        vector<int> a;\n        for(int i=0;i<g.size();++i) a.push_back(g[i].size());\n        return a;\n    }\n    \n    void cleanM(int n){\n        for(int i=0;i<n;++i){\n            M[i]=0;\n        }\n    }\n    \n    int findMinLenFromPointToAllPoints(vector<vector<int>>& edges){\n        vector<vector<int>> g=buildGraph(edges);\n        vector<int> rank=getRank(g);\n        int n=g.size();\n        cleanM(n);\n        queue<int> q;\n        for(int i=0;i<n;++i){\n            if(rank[i]==1) {\n                M[i]=1;\n                q.push(i);\n            }\n        }\n        int ans=1;\n        while(q.size()>0){\n            int u=q.front();\n            rank[u]-=1;\n            q.pop();\n            for(int v: g[u]){\n                if(rank[v]<=0) continue;\n                rank[v]-=1;\n                if(rank[v]<=1) {\n                    M[v]=max(M[v], M[u]+1);\n                    q.push(v);\n                    ans=max(ans, M[v]);\n                }\n            }\n        }\n        // for(int i=0;i<n;++i){\n        //     cout<<\"M[\"<<i<<\"] = \"<<M[i]<<\"\\n\";\n        // }\n        return ans;\n    }\n    \n    int findMaxLen2(int u, int p, vector<vector<int>>& g){\n        vector<int> lens;\n        for(int v: g[u]){\n            if(v==p) continue;\n            lens.push_back(findMaxLen2(v, u, g));\n        }\n        \n        sort(lens.begin(), lens.end(), greater<int>());\n        int l1=(lens.size()>0 ? lens[0] : 0);\n        int l2=(lens.size()>1 ? lens[1] : 0);\n        M[u]=l1+l2+1;\n        return l1+1;\n    }\n    \n     int findMaxLen(vector<vector<int>>& edges){\n        vector<vector<int>> g=buildGraph(edges);\n         int n=g.size();\n        cleanM(n);\n         int ans=0;\n        findMaxLen2(0, -1, g);\n         for(int i=0;i<n;++i){\n             ans=max(ans, M[i]);\n         }\n         return ans;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int minLen=findMinLenFromPointToAllPoints(edges1);\n        int minLen2=findMinLenFromPointToAllPoints(edges2);\n        int dia1=findMaxLen(edges1)-1;\n        int dia2=findMaxLen(edges2)-1;\n        // cout<<\"minLen = \"<<minLen<<\", minLen2 = \"<<minLen2<<\"\\n\";\n        int dia=max(dia1, dia2);\n        return max(minLen+minLen2-1, dia);\n    }\n};",
    "submit_ts": 1719719222.0
}