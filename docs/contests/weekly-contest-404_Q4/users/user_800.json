{
    "username": "dovchindorj",
    "submission": "class Solution {\npublic:\n    void dfs(int node, int parent, vector<vector<int>>& adj, vector<int>& dist, vector<int>& parentNode) {\n        for (int neighbor : adj[node]) {\n            if (neighbor != parent) {\n                dist[neighbor] = dist[node] + 1;\n                parentNode[neighbor] = node;\n                dfs(neighbor, node, adj, dist, parentNode);\n            }\n        }\n    }\n    vector<int> findTreeDiameter(vector<vector<int>>& adj, int n) {\n        vector<int> dist(n, 0);\n        vector<int> parentNode(n, -1);\n        dfs(0, -1, adj, dist, parentNode);\n\n        int farthestNode = max_element(dist.begin(), dist.end()) - dist.begin();\n\n        fill(dist.begin(), dist.end(), 0);\n        fill(parentNode.begin(), parentNode.end(), -1);\n        dfs(farthestNode, -1, adj, dist, parentNode);\n\n        int otherEnd = max_element(dist.begin(), dist.end()) - dist.begin();\n\n        vector<int> diameterPath;\n        for (int v = otherEnd; v != -1; v = parentNode[v]) {\n            diameterPath.push_back(v);\n        }\n        return diameterPath;\n    }\n    int solve(int connect1, int connect2, vector<vector<int>> edges1, vector<vector<int>> edges2, int n, int m) {\n        vector<vector<int>> adj(n + m);\n        for (int i = 0; i < n - 1; i++) {\n            int u = edges1[i][0];\n            int v = edges1[i][1];\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        for (int i = 0; i < m - 1; i++) {\n            int u = edges2[i][0] + n;\n            int v = edges2[i][1] + n;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        adj[connect1].push_back(connect2);\n        adj[connect2].push_back(connect1);\n        vector<int> diameterPath = findTreeDiameter(adj, n + m);\n        // cout << connect1 << \" \" << connect2 << endl;\n        // for (int i = 0; i < diameterPath.size(); i++) cout << diameterPath[i] << \" \"; cout << endl;\n        return diameterPath.size() - 1;\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        if (edges1.size() == 0 && edges2.size() == 0) return 1;\n        if (edges1.size() == 0 || edges2.size() == 0) {\n            if (edges1.size() == 0) {\n                int n = edges1.size() + 1;\n                int m = edges2.size() + 1;\n                vector<vector<int>> adj2(m);\n                for (int i = 0; i < m - 1; ++i) {\n                    int u = edges2[i][0];\n                    int v = edges2[i][1];\n                    adj2[u].push_back(v);\n                    adj2[v].push_back(u);\n                }\n                vector<int> diameterPath2 = findTreeDiameter(adj2, m);\n                int connect1 = 0, connect2 = diameterPath2[diameterPath2.size() / 2] + n;\n                return solve(connect1, connect2, edges1, edges2, n, m);\n            } else { // edges2.size() == 0\n                int n = edges1.size() + 1;\n                int m = edges2.size() + 1;\n                vector<vector<int>> adj1(n);\n                for (int i = 0; i < n - 1; ++i) {\n                    int u = edges1[i][0];\n                    int v = edges1[i][1];\n                    adj1[u].push_back(v);\n                    adj1[v].push_back(u);\n                }\n                vector<int> diameterPath1 = findTreeDiameter(adj1, n);\n                int connect1 = diameterPath1[diameterPath1.size() / 2], connect2 = n;\n                return solve(connect1, connect2, edges1, edges2, n, m);\n            }\n        }\n        int n = edges1.size() + 1;\n        vector<vector<int>> adj1(n);\n        for (int i = 0; i < n - 1; ++i) {\n            int u = edges1[i][0];\n            int v = edges1[i][1];\n            adj1[u].push_back(v);\n            adj1[v].push_back(u);\n        }\n        vector<int> diameterPath1 = findTreeDiameter(adj1, n);\n        int m = edges2.size() + 1;\n        vector<vector<int>> adj2(m);\n        for (int i = 0; i < m - 1; ++i) {\n            int u = edges2[i][0];\n            int v = edges2[i][1];\n            adj2[u].push_back(v);\n            adj2[v].push_back(u);\n        }\n        vector<int> diameterPath2 = findTreeDiameter(adj2, m);\n        int connect1 = -1, connect2 = -1;\n        if ((diameterPath1.size() & 1) || (diameterPath2.size() & 1)) {\n            connect1 = diameterPath1[diameterPath1.size() / 2];\n            connect2 = diameterPath2[diameterPath2.size() / 2] + n;\n            return solve(connect1, connect2, edges1, edges2, n, m);\n        } else {\n            connect1 = diameterPath1[diameterPath1.size() / 2];\n            connect2 = diameterPath2[diameterPath2.size() / 2] + n;\n            int res = solve(connect1, connect2, edges1, edges2, n, m);\n            connect1 = diameterPath1[diameterPath1.size() / 2];\n            connect2 = diameterPath2[diameterPath2.size() / 2 - 1] + n;\n            res = min(res, solve(connect1, connect2, edges1, edges2, n, m));\n            connect1 = diameterPath1[diameterPath1.size() / 2 - 1];\n            connect2 = diameterPath2[diameterPath2.size() / 2] + n;\n            res = min(res, solve(connect1, connect2, edges1, edges2, n, m));\n            connect1 = diameterPath1[diameterPath1.size() / 2 - 1];\n            connect2 = diameterPath2[diameterPath2.size() / 2 - 1] + n;\n            res = min(res, solve(connect1, connect2, edges1, edges2, n, m));\n            return res;\n        }\n        return 0;\n    }\n};",
    "submit_ts": 1719719776.0
}