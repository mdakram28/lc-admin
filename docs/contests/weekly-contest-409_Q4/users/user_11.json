{
    "username": "OTTFF",
    "submission": "typedef long long LL;\n\ntemplate<typename T> struct GetZero { T operator()() const { return T(0); } };\ntemplate<typename T,\n         typename OpPlus=plus<T>,typename OpMinus=minus<T>,\n         typename Zero=GetZero<T> >\nstruct BIT {\n  static int lowbit(int x) { return x&(-x); }\n  constexpr static OpPlus opp{};\n  constexpr static OpMinus opm{};\n  constexpr static Zero zero{};\n  int n;\n  vector<T> tree; // tree[i] -> sum of [i-lowbit(i)+1,i]\n  BIT(int n_=0):n(n_),tree(n+1,zero()) {}\n  void init(int n_) { n=n_; tree.assign(n+1,zero()); }\n  void init(const vector<T> &vec) { // v[0 ~ n_-1]\n    n=vec.size();\n    vector<T> tmp(n+1,zero());\n    for(int i=1;i<=n;i++) tmp[i]=opp(tmp[i-1],vec[i-1]);\n    for(int i=1;i<=n;i++) tree[i]=opm(tmp[i],tmp[i-lowbit(i)]);\n  }\n  void add(int p,T v) { \n    for(;p<=n;p+=lowbit(p)) tree[p]=opp(tree[p],v);\n  }\n  T sum(int p) {\n    T ans=zero();\n    for(;p;p-=lowbit(p)) ans=opp(ans,tree[p]);\n    return ans;\n  }\n  T sum(int l,int r) { return opm(sum(r),sum(l-1)); }\n};\n\nclass Solution {\npublic:\n/*\n -> cnt[sz]: + 1\n -> cnt[sz + 1]: + 2\n*/\n    vector<int> numberOfAlternatingGroups(vector<int>& col, vector<vector<int>>& queries) {\n        int n = col.size();\n        \n        set<int> pos;\n        pos.insert(n);\n\n        BIT<int> bitcnt(n);\n        BIT<LL> bitsum(n);\n\n        auto add = [&](int i, int j) {\n            pos.insert(i);\n            int len = j - i + 1;\n            bitcnt.add(len, 1);\n            bitsum.add(len, len);\n        };\n        auto del = [&](int i, int j) {\n            pos.erase(i);\n            int len = j - i + 1;\n            bitcnt.add(len, -1);\n            bitsum.add(len, -len);\n        };\n\n        for (int i = 0; i < n; ) {\n            int j = i + 1;\n            while (j < n && col[j - 1] != col[j]) {\n                j++;\n            }\n            add(i, j - 1);\n            i = j;\n        }\n\n        auto getfirst = [&]() -> int {\n            auto it = pos.begin();\n            it++;\n            return *it;\n        };\n\n        auto getlast = [&]() -> int {\n            auto it = pos.end(); \n            it--; // -> n\n            it--; // last pos\n            return n - (*it);\n        };\n\n        auto show = [&]() -> void {\n            cout << \"pos: \";\n            for (int i : pos) cout << i << ' ';\n            cout << '\\n';\n\n            cout << \"cnt: \";\n            for (int i = 1; i <= n; i++) cout << bitcnt.sum(i, i) << ' ';\n            cout << '\\n';\n            cout << \"sum: \";\n            for (int i = 1; i <= n; i++) cout << bitsum.sum(i, i) << ' '; \n            cout << '\\n';\n\n            cout << endl;\n        };\n\n        // show();\n\n        vector<int> ans;\n        for (auto&& q : queries) {\n            // show();\n            if (q[0] == 1) { // query\n                int qsz = q[1];\n                if (pos.size() == 2 && col[0] != col[n - 1]) { // all\n                    ans.push_back(n);\n                    continue;\n                }\n                int nans = bitsum.sum(qsz, n) - 1LL * bitcnt.sum(qsz, n) * (qsz - 1);\n                if (col[0] != col[n - 1]) { // diff!\n                    int fi = getfirst();\n                    if (fi >= qsz) {\n                        nans -= fi - qsz + 1;\n                    }\n                    int ls = getlast();\n                    if (ls >= qsz) {\n                        nans -= ls - qsz + 1;\n                    }\n                    int len = fi + ls;\n                    cout << \"here \" << fi << ' ' << ls << ' ' << len << endl;\n                    if (len >= qsz) {\n                        nans += len - qsz + 1;\n                    }\n                }\n                ans.push_back(nans);\n            } else { // q[0] == 2 // change\n                int p = q[1], v = q[2];\n                if (col[p] == v) continue;\n\n                if (p == 0) {\n                    if (col[p] == col[p + 1]) { // original 2 parts.\n                        auto it = pos.begin();\n                        it++; // 1\n                        it++;\n                        int r = (*it) - 1;\n                        del(0, 0);\n                        del(1, r);\n                        add(0, r);\n                    } else { // original 1 part.\n                        auto it = pos.begin();\n                        it++;\n                        int r = (*it) - 1;\n                        del(0, r);\n                        add(0, 0);\n                        add(1, r);\n                    }\n                } else if (p == n - 1) {\n                    if (col[p - 1] == col[p]) { // original 2 parts.\n                        auto it = pos.end();\n                        it--; // n\n                        it--; // n - 1\n                        it--; // l\n                        int l = *it;\n                        del(l, n - 2);\n                        del(n - 1, n - 1);\n                        add(l, n - 1);\n                    } else { // original 1 part.\n                        auto it = pos.end();\n                        it--; // n\n                        it--; // l\n                        int l = *it;\n                        del(l, n - 1);\n                        add(l, n - 2);\n                        add(n - 1, n - 1);\n                    }\n                } else {\n                    if (col[p - 1] == col[p] && col[p + 1] == col[p]) { // merge all\n                        // original [l, p-1][p, p][p + 1]\n                        auto it = pos.upper_bound(p); // p + 1;\n                        it++;\n                        int r = (*it) - 1;\n                        it--; // p + 1\n                        it--; // p\n                        it--;\n                        int l = *it;\n                        del(l, p - 1);\n                        del(p, p);\n                        del(p + 1, r);\n                        add(l, r);\n                    } else if (col[p - 1] != col[p] && col[p + 1] == col[p]) { // split left, merge to right\n                        // original [l, p][p + 1, r]\n                        auto it = pos.upper_bound(p); // p + 1;\n                        it++;\n                        int r = (*it) - 1;\n                        it--; // p + 1\n                        it--;\n                        int l = *it;\n                        del(p + 1, r);\n                        del(l, p);\n                        add(l, p - 1);\n                        add(p, r);\n                    } else if (col[p - 1] == col[p] && col[p + 1] != col[p]) { // merge left, split right\n                        // original [l, p - 1][p, r]\n                        auto it = pos.upper_bound(p); \n                        int r = (*it) - 1;\n                        it--; // p\n                        it--;\n                        int l = *it;\n                        del(l, p - 1);\n                        del(p, r);\n                        add(l, p);\n                        add(p + 1, r);\n                    } else { // split all\n                        // original [l, r]\n                        auto it = pos.upper_bound(p);\n                        int r = (*it) - 1;\n                        it--;\n                        int l = *it;\n                        del(l, r);\n                        add(l, p - 1);\n                        add(p, p);\n                        add(p + 1, r);\n                    }\n                }\n\n                col[p] = v;\n            }\n        }\n        // show();\n        return ans;\n    }\n};\n\n/*\nexp [0,3,2]\n*/",
    "submit_ts": "1722742193",
    "subm_id": "1343763231"
}