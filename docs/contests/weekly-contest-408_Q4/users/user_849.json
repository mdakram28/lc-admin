{
    "username": "Astitva5",
    "submission": "\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n    vector<vector<int>> graph(n + 4);\n\n    auto add_edge = [&](int u, int v) {\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    };\n\n    for (int i = 0; i < n; ++i) {\n        if (circles[i][0] <= circles[i][2] && circles[i][1] <= Y) {\n            add_edge(n, i);\n        }\n        if (circles[i][1] <= circles[i][2] && circles[i][0] <= X) {\n            add_edge(n + 3, i);\n        }\n        if (abs(circles[i][0] - X) <= circles[i][2] && circles[i][1] <= Y) {\n            add_edge(n + 2, i);\n        }\n        if (abs(circles[i][1] - Y) <= circles[i][2] && circles[i][0] <= X) {\n            add_edge(n + 1, i);\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (sqrt(pow(circles[i][0] - circles[j][0], 2) + pow(circles[i][1] - circles[j][1], 2)) <= circles[i][2] + circles[j][2]) {\n                add_edge(i, j);\n            }\n        }\n    }\n\n    auto bfs = [&](int start) {\n        vector<int> dist(n + 4, -1);\n        queue<int> q;\n        q.push(start);\n        dist[start] = 0;\n\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n\n            for (int neighbor : graph[cur]) {\n                if (dist[neighbor] == -1) {\n                    dist[neighbor] = dist[cur] + 1;\n                    q.push(neighbor);\n                }\n            }\n        }\n\n        return dist;\n    };\n\n    vector<int> dist1 = bfs(n);\n    if (dist1[n + 3] != -1 || dist1[n + 2] != -1) {\n        return false;\n    }\n\n    vector<int> dist2 = bfs(n + 1);\n    if (dist2[n + 3] != -1 || dist2[n + 2] != -1) {\n        return false;\n    }\n\n    return true;\n    }\n};",
    "submit_ts": "1722138795",
    "subm_id": "1335799851"
}