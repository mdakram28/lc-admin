{
    "username": "SimardeepSingh1450",
    "submission": "class SegmentTree{\n  public:\n    vector<int> seg;\n    int n;\n    \n    SegmentTree(vector<int> &arr){\n        n = arr.size();\n        seg.resize(4*n);\n        build(arr,0,0,n-1);\n    }\n    \n    void build(vector<int> &arr,int ind,int low,int high){\n        //base case\n        if(low==high){\n            seg[ind]=arr[low];\n            return;\n        }\n        \n        int mid = (low+high)/2;\n        build(arr,2*ind+1,low,mid);//left\n        build(arr,2*ind+2,mid+1,high);//right\n\n        //back-tracking for storing bitwise AND of left and right branch in the tree\n        seg[ind] = seg[2*ind+1] & seg[2*ind+2];\n    }\n\n    int query(int ind,int low,int high,int l,int r){\n        if(low>=l && high<=r){\n            return seg[ind];\n        }\n        \n        //Will not contribute to the answer\n        if(high<l || low>r){\n            return INT32_MAX;\n        }\n        \n        int mid = (low+high)/2;\n        int q1 = query(2*ind+1,low,mid,l,r);\n        int q2 = query(2*ind+2,mid+1,high,l,r);\n        \n        return q1&q2;\n    }\n};\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        SegmentTree st(nums);\n        \n        int ans = INT32_MAX;\n        int n = nums.size();\n        for(int i=0;i<nums.size();i++){\n            int l = i-1, r = n-1;\n            \n            //binary search\n            while(r-l>1){\n                int mid = l + (r-l)/2;\n                if(st.query(0,0,n-1,i,mid) >= k){\n                    l = mid;\n                }else{\n                    r = mid;\n                }\n            }\n            if(l!=i-1){\n                ans = min(ans,abs(st.query(0,0,n-1,i,l)-k));\n            }\n            \n            //right ke liye toh hai hi possible\n            ans = min(ans,abs(st.query(0,0,n-1,i,r)-k));\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1717299851.0
}