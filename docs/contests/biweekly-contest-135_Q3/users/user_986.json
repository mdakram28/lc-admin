{
    "username": "pcwuu",
    "submission": "class Solution {\npublic:\n    int minChanges(vector<int>& nums, int k) {\n        vector<int> cntDiff(k + 1);\n        vector<int> cntSpace(k + 1);\n        int n = nums.size();\n        for(int i = 0; i < n / 2; i++) {\n            int space1 = max(nums[i] - 0, k - nums[i]);\n            int space2 = max(nums[n - 1 - i] - 0, k - nums[n - 1 - i]);\n            cntSpace[max(space1, space2)]++;\n            \n            cntDiff[abs(nums[n - 1 - i] - nums[i])]++;\n        }\n        \n        vector<int> presumOfCntSpace(k + 1);\n        presumOfCntSpace[0] = cntSpace[0];\n        for(int i = 1; i <= k; i++)\n            presumOfCntSpace[i] = presumOfCntSpace[i - 1] + cntSpace[i];     \n        \n        int l = 0, r = n;\n        while(l < r) {\n            int m = l + (r - l) / 2;\n            \n            bool f = false;\n            for(int diff = 0; diff <= k; diff++) {\n                int changeBoth = ((diff == 0)? 0 : presumOfCntSpace[diff - 1]);\n                int changeSingle = presumOfCntSpace[k] - changeBoth;\n                int changes = changeBoth * 2 + changeSingle * 1 - cntDiff[diff];\n                if(changes <= m) {\n                    f = true;\n                    break;\n                }    \n            }\n            \n            if(f)\n                r = m;\n            else\n                l = m + 1; \n        }\n        return l;\n        \n    }\n};\n\n/*\n\n\n(1) binary search on steps\nwe need an efficient way to check whether it's possible to change all pairs diff to a certain number\n => ** in each pair, the number closer to 0 or k is better **\n*/",
    "submit_ts": "1721489315",
    "subm_id": "1327449628"
}