{
    "username": "ankur145",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& e1, vector<vector<int>>& e2) {\n        auto toAdjacencyList = [](const vector<vector<int>>& edges, int n) {\n            vector<vector<int>> adj(n);\n            for (const auto& e : edges) {\n                adj[e[0]].push_back(e[1]);\n                adj[e[1]].push_back(e[0]);\n            }\n            return adj;\n        };\n        \n        int n = e1.size() + 1;\n        int m = e2.size() + 1;\n        vector<vector<int>> a1 = toAdjacencyList(e1, n);\n        vector<vector<int>> a2 = toAdjacencyList(e2, m);\n\n        auto dfs = [](const vector<vector<int>>& adj, int start, int& farthest) {\n            int n = adj.size();\n            vector<int> dist(n, -1);\n            function<void(int, int)> visit = [&](int u, int d) {\n                dist[u] = d;\n                if (d > dist[farthest]) {\n                    farthest = u;\n                }\n                for (int v : adj[u]) {\n                    if (dist[v] == -1) {\n                        visit(v, d + 1);\n                    }\n                }\n            };\n            farthest = start;\n            visit(start, 0);\n            return dist[farthest];\n        };\n\n        int f1 = 0;\n        dfs(a1, 0, f1);\n        int d1 = dfs(a1, f1, f1);\n\n        int f2 = 0;\n        dfs(a2, 0, f2);\n        int d2 = dfs(a2, f2, f2);\n\n        int minD = max(d1, d2);\n        int h1 = (d1 + 1) / 2;\n        int h2 = (d2 + 1) / 2;\n        minD = max(minD, h1 + h2 + 1);\n        return minD;\n    }\n};\n",
    "submit_ts": "1719717458",
    "subm_id": "1304392054"
}