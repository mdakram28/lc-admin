{
    "username": "tomarint",
    "submission": "#[derive(Clone)]\nstruct UnionFind {\n    n: usize,\n    parent: Vec<i64>,\n}\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        Self {\n            n,\n            parent: vec![-1; n + 1],\n        }\n    }\n    fn root(&mut self, a: usize) -> usize {\n        if self.parent[a] < 0 {\n            return a;\n        }\n        self.parent[a] = self.root(self.parent[a] as usize) as i64;\n        return self.parent[a] as usize;\n    }\n    fn size(&mut self, a: usize) -> usize {\n        let r = self.root(a);\n        return -self.parent[r] as usize;\n    }\n    fn connect(&mut self, a: usize, b: usize) -> bool {\n        let a = self.root(a);\n        let b = self.root(b);\n        if a == b {\n            return false;\n        }\n        if self.size(a) > self.size(b) {\n            self.parent[a] += self.parent[b];\n            self.parent[b] = a as i64;\n        } else {\n            self.parent[b] += self.parent[a];\n            self.parent[a] = b as i64;\n        }\n        return true;\n    }\n    fn same(&mut self, a: usize, b: usize) -> bool {\n        return self.root(a) == self.root(b);\n    }\n}\n\nimpl Solution {\n    pub fn can_reach_corner(x: i32, y: i32, circles: Vec<Vec<i32>>) -> bool {\n        let n = circles.len();\n        let mut uf = UnionFind::new(n+2);\n        let x = x as i64;\n        let y = y as i64;\n        let circles: Vec<(i64, i64, i64)> = circles.iter().map(|c| (c[0] as i64, c[1] as i64, c[2] as i64)).collect();\n        fn distance_le_val(\n            x1: i64,\n            y1: i64,\n            x2: i64,\n            y2: i64,\n            val: i64\n        ) -> bool {\n            let dx = x1 - x2;\n            let dy = y1 - y2;\n            dx * dx + dy * dy <= val * val\n        }\n        for i in 0..n {\n            let c1 = &circles[i];\n            if distance_le_val(c1.0, c1.1, 0, 0, c1.2) {\n                return false;\n            }\n            if distance_le_val(c1.0, c1.1, x, y, c1.2) {\n                return false;\n            }\n            for j in 0..i {\n                let c2 = &circles[j];\n                if distance_le_val(c1.0, c1.1, c2.0, c2.1, c1.2 + c2.2) {\n                    uf.connect(i, j);\n                }\n            }\n            if c1.0 <= c1.2 {\n                uf.connect(i, n);\n            }\n            if c1.0 + c1.2 >= x {\n                uf.connect(i, n+1);\n            }\n            if c1.1 <= c1.2 {\n                uf.connect(i, n+1);\n            }\n            if c1.1 + c1.2 >= y {\n                uf.connect(i, n);\n            }\n        }\n        !uf.same(n, n+1)\n    }\n}",
    "submit_ts": "1722136137",
    "subm_id": "1335724953"
}