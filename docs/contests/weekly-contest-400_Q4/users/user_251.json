{
    "username": "spike02",
    "submission": "// bitwise and is decreasing\n// so prefix array of bitwise ands are sorted in decreaing order\n\nclass Solution {\nprivate:\n    void build(int l, int r, int i, vector<int>& nums, vector<int>& segtree) {\n        if (l == r) {\n            segtree[i] = nums[l];\n            return;\n        }\n        int m = (l+r)/2;\n        build(l, m, 2*i+1, nums, segtree);\n        build(m+1, r, 2*i+2, nums, segtree);\n        segtree[i] = segtree[2*i+1] & segtree[2*i+2];\n        return;\n    }\n    int query(int lq, int rq, int l, int r, int i, vector<int>& segtree) {\n        if (r < lq || l > rq) return INT_MAX;\n        else if (lq <= l && r <= rq) return segtree[i];\n        else {\n            int m = (l+r)/2;\n            int v1 = query(lq, rq, l, m, 2*i+1, segtree);\n            int v2 = query(lq, rq, m+1, r, 2*i+2, segtree);\n            return v1 & v2;\n        } \n    }\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> segtree(4*n+1);\n        build(0, n-1, 0, nums, segtree);\n        int ans = INT_MAX;\n        for (int i=0; i<n; i++) {\n            //find closest subarray using binary search starting from i\n            int l = i;\n            int r = n-1;\n            while (l+1 < r) {\n                int m = (l+r)/2;\n                int pref = query(i, m, 0, n-1, 0, segtree);\n                if (pref > k) {\n                    // decreasing prefix\n                    l = m;\n                }\n                else {\n                    r = m;\n                }\n            }\n            ans = min(ans, abs(k-query(i, l, 0, n-1, 0, segtree)));\n            if (l+1 < n) ans = min(ans, abs(k-query(i, l+1, 0, n-1, 0, segtree)));\n\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1717298023.0
}