{
    "username": "d11235813",
    "submission": "class Solution {\npublic:\n\n    struct trie{\n        struct node;\n\n        struct node{\n            //node(): nexts(26, vector<node>()){}\n            bool end = false;\n            int cost = -1;\n            //std::unordered_map<char, node*> nexts;\n            std::vector<node*> nexts{26};\n        };\n\n        trie(vector<string>& words, vector<int>& costs){\n            int ind = 0;\n            root = new node;\n            for(auto& word: words){\n                node* curr = root;\n                for(int i = 0; i < word.size(); i++){\n                    node* temp = curr->nexts[toi(word[i])];\n                    if(temp == nullptr){\n                        curr->nexts[toi(word[i])] = new node();\n                    }\n                    curr = curr->nexts[toi(word[i])];\n                    if(i == word.size() -1){\n                        curr->end = true;\n                        if(curr->cost == -1){\n                            curr->cost = costs[ind];\n                        }\n                        else{\n                            curr->cost = std::min(curr->cost, costs[ind]);\n                        }\n                    }\n                }\n                ++ind;\n            }\n        }\n        ~trie(){\n            delete root;\n        }\n\n\n        node* root;\n    };\n        static int toi(char c){\n            return c - 'a';\n        }\n\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        //can be same one over and over\n        //might not be possible\n\n        trie t(words, costs);\n        std::vector<int> cache(target.size(), -2);\n        return helper(target, 0, words, costs, t, cache);\n    }\n\n    int helper(std::string& target, int ind, auto& words, auto& costs, trie& t, auto& cache){\n        //also store best cost by ind\n        \n        //std::cout << \"helper \" << ind << std::endl;\n        if(ind == target.size()){\n            //std::cout << \"RETURN\" << std::endl;\n            return 0;\n        }\n        if(cache[ind] != -2){\n            return cache[ind];\n        }\n\n\n        trie::node* curr = t.root;\n        int best = -1;\n        for(int i = ind; i < target.size(); i++){\n            //std::cout << \"iter \"<< target[i] << std::endl;\n            curr = curr->nexts[toi(target[i])];\n            if(curr == nullptr){\n                break;\n            }\n            if(curr->end == true){\n                //std::cout << \"end\" << std::endl;\n                auto val =  helper(target, i+1, words, costs, t, cache);\n                if(val != -1){\n                    if(best == -1){\n                        best = curr->cost + val;\n                    }\n                    best = std::min(best, curr->cost + val);\n                }\n            }\n        }\n        cache[ind] = best;\n        return best;\n    }\n};",
    "submit_ts": "1720323457",
    "subm_id": "1312376064"
}