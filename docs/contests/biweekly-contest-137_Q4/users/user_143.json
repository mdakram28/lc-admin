{
    "username": "AB-IN",
    "submission": "'''\nAuthor: NEFU AB-IN\nDate: 2024-08-17 22:12:44\nFilePath: \\LeetCode\\CP137_2\\c\\c.py\nLastEditTime: 2024-08-17 23:11:38\n'''\n# 3.8.19 import\nimport random\nfrom collections import Counter, defaultdict, deque\nfrom datetime import datetime, timedelta\nfrom functools import lru_cache, reduce\nfrom heapq import heapify, heappop, heappush, nlargest, nsmallest\nfrom itertools import combinations, compress, permutations, starmap, tee\nfrom math import ceil, comb, fabs, floor, gcd, hypot, log, perm, sqrt\nfrom string import ascii_lowercase, ascii_uppercase\nfrom sys import exit, setrecursionlimit, stdin\nfrom typing import Any, Callable, Dict, List, Optional, Tuple, TypeVar, Union\n\n# Constants\nTYPE = TypeVar('TYPE')\nN = int(2e5 + 10)\nM = int(20)\nINF = int(1e12)\nOFFSET = int(100)\nMOD = int(1e9 + 7)\n\n# Set recursion limit\nsetrecursionlimit(int(2e9))\n\n\nclass Arr:\n    array = staticmethod(lambda x=0, size=N: [x() if callable(x) else x for _ in range(size)])\n    array2d = staticmethod(lambda x=0, rows=N, cols=M: [Arr.array(x, cols) for _ in range(rows)])\n    graph = staticmethod(lambda size=N: [[] for _ in range(size)])\n\n\nclass Math:\n    max = staticmethod(lambda a, b: a if a > b else b)\n    min = staticmethod(lambda a, b: a if a < b else b)\n\n\nclass IO:\n    input = staticmethod(lambda: stdin.readline().strip())\n    read = staticmethod(lambda: map(int, IO.input().split()))\n    read_list = staticmethod(lambda: list(IO.read()))\n    read_mixed = staticmethod(lambda *types: [t(v) for t, v in zip(types, IO.input().split())])\n\n\nclass Std:\n    pass\n\n# \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Division line \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        row_dict = defaultdict(list)\n        col_dict = defaultdict(list)\n\n        for i in range(m):\n            for j in range(n):\n                value = board[i][j]\n\n                if len(row_dict[i]) < 4:\n                    row_dict[i].append((value, i, j))\n                    row_dict[i].sort(reverse=True, key=lambda x: x[0])\n                elif value > row_dict[i][-1][0]:\n                    row_dict[i][-1] = (value, i, j)\n                    row_dict[i].sort(reverse=True, key=lambda x: x[0])\n\n                if len(col_dict[j]) < 4:\n                    col_dict[j].append((value, i, j))\n                    col_dict[j].sort(reverse=True, key=lambda x: x[0])\n                elif value > col_dict[j][-1][0]:\n                    col_dict[j][-1] = (value, i, j)\n                    col_dict[j].sort(reverse=True, key=lambda x: x[0])\n\n        row_max_set = set()\n        for i in range(m):\n            row_max_set.update(row_dict[i])\n        for j in range(n):\n            row_max_set.update(col_dict[j])\n\n        row_max = list(row_max_set)\n        row_max.sort(reverse=True, key=lambda x: x[0])\n\n        res = -INF\n        for i in range(len(row_max)):\n            v1, r1, c1 = row_max[i]\n            for j in range(i + 1, len(row_max)):\n                v2, r2, c2 = row_max[j]\n                if c1 == c2 or r1 == r2:\n                    continue\n                for k in range(j + 1, len(row_max)):\n                    v3, r3, c3 = row_max[k]\n                    if r2 != r3 and r1 != r3 and c2 != c3 and c1 != c3:\n                        res = Math.max(res, v1 + v2 + v3)\n                        break\n\n        return res\n",
    "submit_ts": "1723907535",
    "subm_id": "556326113"
}