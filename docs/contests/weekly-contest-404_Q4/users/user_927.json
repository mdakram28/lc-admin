{
    "username": "h_bugw7",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, a, b) for (int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define RSORT(v) sort((v).rbegin(),(v).rend())\n#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())\n#define REVERSE(v) reverse(ALL(v))\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\ntypedef pair<int, pii> pip;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<pair<int, int>> vpii;\n\nint dx[] = {0, 0, -1, 1, -1, -1, 1, 1};\nint dy[] = {-1, 1, 0, 0, -1, 1, -1, 1};\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int r1 = solve(edges1);\n        int r2 = solve(edges2);\n        int d1 = diameter(edges1);\n        int d2 = diameter(edges2);\n        return max(max(d1, d2), r1 + r2 + 1);\n    }\n\n    void dfs(int node, int parent, int depth, int& maxDepth, int& farthestNode, const vii& graph) {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            farthestNode = node;\n        }\n        for (int neighbor : graph[node]) {\n            if (neighbor != parent) {\n                dfs(neighbor, node, depth + 1, maxDepth, farthestNode, graph);\n            }\n        }\n    }\n\n    int diameter(vector<vector<int>>& edges) {\n        int N = edges.size() + 1;\n        vii graph(N);\n        vi edgesCount(N, 0);\n        \n        for (auto& e : edges) {\n            int u = e[0], v = e[1];\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n            edgesCount[u]++;\n            edgesCount[v]++;\n        }\n        \n        // First DFS to find one endpoint of the longest path\n        int maxDepth = 0;\n        int farthestNode = 0;\n        dfs(0, -1, 0, maxDepth, farthestNode, graph);\n        \n        // Second DFS to find the actual longest path from the found endpoint\n        maxDepth = 0;\n        dfs(farthestNode, -1, 0, maxDepth, farthestNode, graph);\n        \n        return maxDepth;\n    }\n\n    int solve(vector<vector<int>>& edges) {\n        const int N = edges.size() + 1;\n        if(N == 1) return 0;\n        vii graph(N);\n        vi edgesCount(N, 0);\n        for(auto& e: edges) {\n            int u = e[0], v = e[1];\n            graph[u].pb(v);\n            graph[v].pb(u);\n            edgesCount[u]++;\n            edgesCount[v]++;\n        }\n        queue<int> q;\n        REP(i, N) {\n            if(edgesCount[i] == 1) q.push(i);\n        }\n        int mid = -1;\n        while(!q.empty()) {\n            int u = q.front();\n            q.pop();\n            edgesCount[u] = 0;\n            for(auto& v: graph[u]) {\n                if(!edgesCount[v]) continue;\n                if(edgesCount[v] == 1) {\n                    mid = v;\n                    break;\n                }\n                edgesCount[v]--;\n                if(edgesCount[v] == 1) q.push(v);\n            }\n        }\n        vi dist(N, 1000000);\n        while(!q.empty()) q.pop();\n        dist[mid] = 0;\n        q.push(mid);\n        while(!q.empty()) {\n            int u = q.front();\n            q.pop();\n            for(auto& v: graph[u]) {\n                if(dist[v] > dist[u] + 1) {\n                    dist[v] = dist[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n        int diam = 0;\n        REP(i, N) diam = max(diam, dist[i]);\n        // if(diam == INT_MAX) return -1;\n        return diam;\n    }\n};",
    "submit_ts": "1719719853",
    "subm_id": "1304452223"
}