{
    "username": "uwi",
    "submission": "\tclass Solution {\n\t\tvoid go(int ind, LST lst, int[] fs, int n, LST ff, int[] c)\n\t\t{\n\t\t\tif(ind > 0) {\n\t\t\t\tint pre = lst.prev(ind - 1);\n\t\t\t\tint nex = lst.next(pre+1);\n\t\t\t\tif(nex == -1)nex = 2*n;\n\t\t\t\tif (pre != -1 && pre < n && --fs[nex - pre] == 0) {\n\t\t\t\t\tff.unset(nex - pre);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(lst.get(ind)){\n\t\t\t\tint pre = ind;\n\t\t\t\tint nex = lst.next(ind+1);\n\t\t\t\tif(nex == -1)nex = 2*n;\n\t\t\t\tif (pre != -1 && pre < n && --fs[nex - pre] == 0) {\n\t\t\t\t\tff.unset(nex - pre);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(lst.get(ind+1)){\n\t\t\t\tint pre = ind+1;\n\t\t\t\tint nex = lst.next(ind+2);\n\t\t\t\tif(nex == -1)nex = 2*n;\n\t\t\t\tif (pre != -1 && pre < n && --fs[nex - pre] == 0) {\n\t\t\t\t\tff.unset(nex - pre);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlst.unset(ind);\n\t\t\tlst.unset(ind+1);\n\t\t\tc[ind] ^= 1;\n\t\t\tif(ind > 0 && c[ind] != c[ind-1]){\n\t\t\t\tlst.set(ind);\n\t\t\t}\n\t\t\tif(ind+1 < c.length && c[ind+1] != c[ind]){\n\t\t\t\tlst.set(ind+1);\n\t\t\t}\n\n\t\t\tif(ind > 0) {\n\t\t\t\tint pre = lst.prev(ind - 1);\n\t\t\t\tint nex = lst.next(pre+1);\n\t\t\t\tif(nex == -1)nex = 2*n;\n\t\t\t\tif (pre != -1 && pre < n && ++fs[nex - pre] == 1) {\n\t\t\t\t\tff.set(nex - pre);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(lst.get(ind)){\n\t\t\t\tint pre = ind;\n\t\t\t\tint nex = lst.next(ind+1);\n\t\t\t\tif(nex == -1)nex = 2*n;\n\t\t\t\tif (pre != -1 && pre < n && ++fs[nex - pre] == 1) {\n\t\t\t\t\tff.set(nex - pre);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(lst.get(ind+1)){\n\t\t\t\tint pre = ind+1;\n\t\t\t\tint nex = lst.next(ind+2);\n\t\t\t\tif(nex == -1)nex = 2*n;\n\t\t\t\tif (pre != -1 && pre < n && ++fs[nex - pre] == 1) {\n\t\t\t\t\tff.set(nex - pre);\n\t\t\t\t}\n\t\t\t}\n//\t\t\ttr(\"IF\", c, lst, ind, fs);\n\t\t}\n\n\t\tpublic List<Integer> numberOfAlternatingGroups(int[] colors, int[][] queries) {\n\t\t\tint n = colors.length;\n\t\t\tint[] c = new int[2*n];\n\t\t\tfor(int i = 0;i < 2*n;i++){\n\t\t\t\tc[i] = colors[i%n] ^ (i % 2 == 0 ? 0 : 1);\n\t\t\t}\n\n\t\t\tLST lst = new LST(2*n+3);\n\t\t\tfor(int i = 1;i < 2*n;i++){\n\t\t\t\tif(c[i] != c[i-1]){\n\t\t\t\t\tlst.set(i);\n\t\t\t\t}\n\t\t\t}\n//\t\t\ttr(colors);\n//\t\t\ttr(c);\n//\t\t\ttr(lst);\n\t\t\tint[] fs = new int[2*n+1];\n\t\t\tLST ff = new LST(2*n+1);\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tif(lst.get(i)){\n\t\t\t\t\tint ne = lst.next(i+1);\n\t\t\t\t\tif(ne == -1)ne = 2*n;\n\t\t\t\t\tfs[ne-i]++;\n\t\t\t\t\tff.set(ne-i);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 110010\n\t\t\t// 100111\n\n\t\t\tList<Integer> ans = new ArrayList<>();\n\t\t\tfor(int[] q : queries){\n\t\t\t\tif(q[0] == 1){\n\t\t\t\t\tif(lst.next(0) == -1){\n\t\t\t\t\t\tans.add(n);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tint lans = 0;\n\t\t\t\t\t\tfor (int i = ff.next(q[1]); i != -1; i = ff.next(i + 1)) {\n\t\t\t\t\t\t\tlans += (i - q[1] + 1) * fs[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(c[2*n-1] != c[0]){\n\t\t\t\t\t\t\tint f = lst.next(0);\n\t\t\t\t\t\t\tif(f >= q[1]) {\n\t\t\t\t\t\t\t\tlans += (f - q[1]+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tans.add(lans);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tint ind = q[1], val = q[2];\n\t\t\t\t\tif(colors[ind] == val)continue;\n\t\t\t\t\tcolors[ind] ^= 1;\n\n\t\t\t\t\tgo(ind, lst, fs, n, ff, c);\n\t\t\t\t\tgo(ind+n, lst, fs, n, ff, c);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic static class LST {\n\t\t\tpublic long[][] set;\n\t\t\tpublic int n;\n\t\t\t//\tpublic int size;\n\n\t\t\tpublic LST(int n) {\n\t\t\t\tthis.n = n;\n\t\t\t\tint d = 1;\n\t\t\t\tfor(int m = n;m > 1;m>>>=6, d++);\n\n\t\t\t\tset = new long[d][];\n\t\t\t\tfor(int i = 0, m = n>>>6;i < d;i++, m>>>=6){\n\t\t\t\t\tset[i] = new long[m+1];\n\t\t\t\t}\n\t\t\t\t//\t\tsize = 0;\n\t\t\t}\n\n\t\t\t// [0,r)\n\t\t\tpublic LST setRange(int r)\n\t\t\t{\n\t\t\t\tfor(int i = 0;i < set.length;i++, r=r+63>>>6){\n\t\t\t\t\tfor(int j = 0;j < r>>>6;j++){\n\t\t\t\t\t\tset[i][j] = -1L;\n\t\t\t\t\t}\n\t\t\t\t\tif((r&63) != 0)set[i][r>>>6] |= (1L<<r)-1;\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// [0,r)\n\t\t\tpublic LST unsetRange(int r)\n\t\t\t{\n\t\t\t\tif(r >= 0){\n\t\t\t\t\tfor(int i = 0;i < set.length;i++, r=r+63>>>6){\n\t\t\t\t\t\tfor(int j = 0;j < r+63>>>6;j++){\n\t\t\t\t\t\t\tset[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((r&63) != 0)set[i][r>>>6] &= -(1L << r);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tpublic LST set(int pos)\n\t\t\t{\n\t\t\t\tif(pos >= 0 && pos < n){\n\t\t\t\t\t//\t\t\tif(!get(pos))size++;\n\t\t\t\t\tfor(int i = 0;i < set.length;i++, pos>>>=6){\n\t\t\t\t\t\tset[i][pos>>>6] |= 1L<<pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tpublic LST unset(int pos)\n\t\t\t{\n\t\t\t\tif(pos >= 0 && pos < n){\n\t\t\t\t\t//\t\t\tif(get(pos))size--;\n\t\t\t\t\tfor(int i = 0;i < set.length && (i == 0 || set[i-1][pos] == 0L);i++, pos>>>=6){\n\t\t\t\t\t\tset[i][pos>>>6] &= ~(1L<<pos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tpublic boolean get(int pos)\n\t\t\t{\n\t\t\t\treturn pos >= 0 && pos < n && set[0][pos>>>6]<<~pos<0;\n\t\t\t}\n\n\t\t\tpublic LST toggle(int pos)\n\t\t\t{\n\t\t\t\treturn get(pos) ? unset(pos) : set(pos);\n\t\t\t}\n\n\t\t\tpublic int prev(int pos)\n\t\t\t{\n\t\t\t\tfor(int i = 0;i < set.length && pos >= 0;i++, pos>>>=6, pos--){\n\t\t\t\t\tint pre = prev(set[i][pos>>>6], pos&63);\n\t\t\t\t\tif(pre != -1){\n\t\t\t\t\t\tpos = pos>>>6<<6|pre;\n\t\t\t\t\t\twhile(i > 0)pos = pos<<6|63-Long.numberOfLeadingZeros(set[--i][pos]);\n\t\t\t\t\t\treturn pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tpublic int next(int pos)\n\t\t\t{\n\t\t\t\tfor(int i = 0;i < set.length && pos>>>6 < set[i].length;i++, pos>>>=6, pos++){\n\t\t\t\t\tint nex = next(set[i][pos>>>6], pos&63);\n\t\t\t\t\tif(nex != -1){\n\t\t\t\t\t\tpos = pos>>>6<<6|nex;\n\t\t\t\t\t\twhile(i > 0)pos = pos<<6|Long.numberOfTrailingZeros(set[--i][pos]);\n\t\t\t\t\t\treturn pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tprivate static int prev(long set, int n)\n\t\t\t{\n\t\t\t\tlong h = set<<~n;\n\t\t\t\tif(h == 0L)return -1;\n\t\t\t\treturn -Long.numberOfLeadingZeros(h)+n;\n\t\t\t}\n\n\t\t\tprivate static int next(long set, int n)\n\t\t\t{\n\t\t\t\tlong h = set>>>n;\n\t\t\t\tif(h == 0L)return -1;\n\t\t\t\treturn Long.numberOfTrailingZeros(h)+n;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString()\n\t\t\t{\n\t\t\t\tList<Integer> list = new ArrayList<>();\n\t\t\t\tfor(int pos = next(0);pos != -1;pos = next(pos+1)){\n\t\t\t\t\tlist.add(pos);\n\t\t\t\t}\n\t\t\t\treturn list.toString();\n\t\t\t}\n\t\t}\n\n\t}\n",
    "submit_ts": "1722743662",
    "subm_id": "1343796878"
}