{
    "username": "jupiterepoch",
    "submission": "class Solution:\n\n    def cuts(self, circle, dirs, X, Y):\n        (x, y, r) = circle\n        if dirs == 0:\n            return r >= abs(Y - y)# and r ** 2 <= max(x**2+(Y-y)**2, (X-x)**2+(Y-y)**2)\n        if dirs == 1:\n            return r >= abs(X - x)# and r ** 2 <= max((X-x)**2+y**2, (X-x)**2+(Y-y)*2)\n        if dirs == 2:\n            return r >= abs(y)# and r ** 2 <= max(x**2+y**2, (X-x)**2+y*2)\n        if dirs == 3:\n            return r >= abs(x)# and r ** 2 <= max(x**2+y**2, x**2+(Y-y)*2)\n        \n    def intersect(self, c1, c2):\n        x1, y1, r1 = c1\n        x2, y2, r2 = c2\n        dist2 = (x1 - x2)**2 + (y1 - y2)**2\n        if ((r1+r2)**2 < dist2):\n            return False\n        if math.sqrt(dist2) + r1 < r2 or math.sqrt(dist2) + r2 < r1:\n            return False\n        return True\n\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        border = [set() for _ in range(4)]\n        dead = [(0, 1), (0, 2), (1, 3), (2, 3)]\n        for i, circle in enumerate(circles):\n            ds = []\n            for d in range(4):\n                if self.cuts(circle, d, X, Y):\n                    border[d].add(i)\n                    ds.append(d)\n            if len(ds) >= 2:\n                for d1 in ds:\n                    for d2 in ds:\n                        if tuple(sorted([d1, d2])) in dead:\n                            return False\n        adj_list = {}\n        for i in range(len(circles)):\n            for j in range(i+1, len(circles)):\n                if self.intersect(circles[i], circles[j]):\n                    if i not in adj_list:\n                        adj_list[i] = []\n                    if j not in adj_list:\n                        adj_list[j] = []\n                    adj_list[i].append(j)\n                    adj_list[j].append(i)\n        for d in range(4):\n            for circ in border[d]:\n                bfs = collections.deque([circ])\n                visited = set([circ])\n                while bfs:\n                    cur = bfs.popleft()\n                    if cur not in adj_list:\n                        continue\n                    for nex in adj_list[cur]:\n                        for dd in range(4):\n                            if nex in border[dd] and tuple(sorted([d, dd])) in dead:\n                                return False\n                        if nex not in visited:\n                            visited.add(nex)\n                            bfs.append(nex)\n        return True\n\n        ",
    "submit_ts": "1722138472",
    "subm_id": "1335791644"
}