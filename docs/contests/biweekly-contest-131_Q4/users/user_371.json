{
    "username": "kluicer",
    "submission": "class SegmentTree {\n private:\n  int n;\n  vector<int> tree;\n  vector<int> lazy;\n\n  void build(vector<int>& arr, int node, int start, int end) {\n    if (start == end) {\n      tree[node] = arr[start];\n      return;\n    }\n\n    int mid = (start + end) / 2;\n    build(arr, 2 * node, start, mid);\n    build(arr, 2 * node + 1, mid + 1, end);\n    tree[node] = max(tree[2 * node], tree[2 * node + 1]);\n  }\n\n  void updateRange(int node, int start, int end, int l, int r, int val) {\n    if (lazy[node] != 0) {\n      tree[node] += lazy[node];\n\n      if (start != end) {\n        lazy[2 * node] += lazy[node];\n        lazy[2 * node + 1] += lazy[node];\n      }\n\n      lazy[node] = 0;\n    }\n\n    if (start > end || start > r || end < l) {\n      return;\n    }\n\n    if (start >= l && end <= r) {\n      tree[node] += val;\n\n      if (start != end) {\n        lazy[2 * node] += val;\n        lazy[2 * node + 1] += val;\n      }\n\n      return;\n    }\n\n    int mid = (start + end) / 2;\n    updateRange(2 * node, start, mid, l, r, val);\n    updateRange(2 * node + 1, mid + 1, end, l, r, val);\n    tree[node] = max(tree[2 * node], tree[2 * node + 1]);\n  }\n\n  int queryRange(int node, int start, int end, int l, int r) {\n    if (start > end || start > r || end < l) {\n      return INT_MIN;\n    }\n\n    if (lazy[node] != 0) {\n      tree[node] += lazy[node];\n\n      if (start != end) {\n        lazy[2 * node] += lazy[node];\n        lazy[2 * node + 1] += lazy[node];\n      }\n\n      lazy[node] = 0;\n    }\n\n    if (start >= l && end <= r) {\n      return tree[node];\n    }\n\n    int mid = (start + end) / 2;\n    int left = queryRange(2 * node, start, mid, l, r);\n    int right = queryRange(2 * node + 1, mid + 1, end, l, r);\n    return max(left, right);\n  }\n\n public:\n  SegmentTree(vector<int>& arr) {\n    n = arr.size();\n    tree.resize(4 * n);\n    lazy.resize(4 * n);\n    build(arr, 1, 0, n - 1);\n  }\n\n  void update(int l, int r, int val) { updateRange(1, 0, n - 1, l, r, val); }\n\n  int query(int l, int r) { return queryRange(1, 0, n - 1, l, r); }\n};\n\nclass Solution {\n public:\n  vector<bool> getResults(vector<vector<int>>& queries) {\n    vector<bool> ans;\n    int n = 1e5 + 5;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) arr[i] = i;\n    SegmentTree tree(arr);\n    set<int> st;\n\n    for (auto i : queries) {\n      if (i[0] == 1) {\n        int l = i[1];\n        int r = n;\n        if(st.lower_bound(l) != st.end()) r = *st.lower_bound(l);\n        st.insert(l);\n        int sz = tree.query(l, l);\n        // cout <<\"sz:\" << sz <<\" \"<<r<< endl;\n        tree.update(l+1, r, -1 * sz);\n      } else {\n        int r = i[1], sz = i[2];\n        int mx = tree.query(0, r);\n        // cout <<\"mx:\"<<mx<<endl;\n        if (mx >= sz)\n          ans.push_back(true);\n        else\n          ans.push_back(false);\n      }\n    }\n    return ans;\n  }\n};",
    "submit_ts": 1716652749.0
}