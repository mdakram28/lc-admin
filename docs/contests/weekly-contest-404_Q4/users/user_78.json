{
    "username": "balakrishnan_v",
    "submission": "#define MAXN 200000\nclass Solution {\npublic:\n    vector<int> E[MAXN+2];\n    int max_depth[MAXN+2];\n    int dfs(int par,int u,int& max_dia) {\n\n        vector<int> depths;\n        max_depth[u]=0;\n        for(int v : E[u]) {\n            if (v==par) continue;\n            int curr = dfs(u,v,max_dia);\n            depths.push_back(curr);\n            sort(depths.begin(),depths.end(),greater<int>());\n            while (depths.size()>2) {\n                depths.pop_back();\n            }\n            max_depth[u]=max(max_depth[u],curr+1);\n        }\n        int ret=0;\n        for(int d : depths) {\n            ret = max(ret, 1+d);\n        }\n        if (depths.size()>=1) \n            max_dia=max(max_dia,depths[0]+1);\n        if (depths.size()>=2) {\n            max_dia=max(max_dia,depths[0]+depths[1]+2);\n        }\n        return ret;\n    }\n    \n    int construct_tree(const vector<vector<int>>& edges) {\n        int n=edges.size()+1;\n        for(int i=0;i<n;i++) E[i].clear();\n        for(auto tmp : edges) {\n            int u = tmp[0];\n            int v = tmp[1];\n            E[u].push_back(v);\n            E[v].push_back(u);\n        }\n        return n;\n    }\n    \n    \n    int max_to_leaf[MAXN+2];\n    void dfs2(int par,int u, int curr_longest) {\n        max_to_leaf[u]=max(max_depth[u],curr_longest);\n        set<pair<int,int>> max_depths;\n        for(int v : E[u]) {\n            if (v==par) continue;\n            max_depths.insert({max_depth[v],v});\n        }\n        \n        for(int v : E[u]) {\n            if (v==par) continue;\n            max_depths.erase({max_depth[v],v});\n            int new_curr_longest = curr_longest+1;\n            if (!max_depths.empty()) new_curr_longest=max(new_curr_longest,max_depths.rbegin()->first+2);\n            dfs2(u,v,new_curr_longest);\n            max_depths.insert({max_depth[v],v});\n        }\n        \n    }\n    \n    pair<int,int> get_dia(const vector<vector<int>>& edges) {\n        int n = construct_tree(edges);\n        int max_dia=0;\n        dfs(-1,0,max_dia);\n        dfs2(-1,0,0);\n        int min_max_to_leaf=1e9;\n        for(int u=0;u<n;u++) {\n            min_max_to_leaf=min(min_max_to_leaf,max_to_leaf[u]);\n        }\n        \n        return {max_dia, min_max_to_leaf};\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        pair<int,int> a1 = get_dia(edges1);\n        pair<int,int> a2 = get_dia(edges2);\n        return max(max(a1.first,a2.first),a1.second+a2.second+1);\n        \n        \n    }\n};",
    "submit_ts": "1719716212",
    "subm_id": "1304358110"
}