{
    "username": "megaspazz",
    "submission": "class Solution {\n    public long minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n//         IndexNum[] horiz = new IndexNum[horizontalCut.length + 1];\n//         for (int i = 1; i < horiz.length; ++i) {\n//             horiz[i] = new IndexNum(i, horizontalCut[i - 1]);\n//         }\n        \n//         IndexNum[] vert = new IndexNum[verticalCut.length + 1];\n//         for (int i = 1; i < vert.length; ++i) {\n//             vert[i] = new IndexNum(i, verticalCut[i - 1]);\n//         }\n        \n        List<Cut> cuts = new ArrayList<>();\n        for (int i = 0; i < horizontalCut.length; ++i) {\n            cuts.add(new Cut(horizontalCut[i], HORIZ));\n        }\n        for (int i = 0; i < verticalCut.length; ++i) {\n            cuts.add(new Cut(verticalCut[i], VERT));\n        }\n        Collections.sort(cuts, new Comparator<Cut>() {\n            @Override\n            public int compare(Cut a, Cut b) {\n                int da = Long.compare(b.amount, a.amount);\n                if (da != 0) {\n                    return da;\n                }\n                return Integer.compare(a.type, b.type);\n            }\n        });\n        \n        long ans = 0;\n        long rows = 1;\n        long cols = 1;\n        for (Cut c : cuts) {\n            if (c.type == HORIZ) {\n                ans += c.amount * cols;\n                ++rows;\n            } else {\n                ans += c.amount * rows;\n                ++cols;\n            }\n        }\n        return ans;\n        \n//         SparseTable.Merger<IndexNum> merger = new SparseTable.Merger<>() {\n//             @Override\n//             public IndexNum merge(IndexNum a, IndexNum b) {\n//                 if (a == null) {\n//                     return b;\n//                 }\n//                 if (b == null) {\n//                     return a;\n//                 }\n//                 if (a.value < b.value) {\n//                     return a;\n//                 }\n//                 if (b.value < a.value) {\n//                     return b;\n//                 }\n//                 if (a.index < b.index) {\n//                     return a;\n//                 }\n//                 return b;\n//             }\n//         };\n//         SparseTable<IndexNum> sth = new SparseTable(horiz, merger);\n//         SparseTable<IndexNum> stv = new SparseTable(vert, merger);\n//         Queue<Matrix> q = new Queue<>();\n//         long vMult = 1;\n//         long hMult = 1;\n//         q.offer(new Matrix(0, 0, m, n));\n//         long ans = 0;\n//         while (!q.isEmpty()) {\n            \n//         }\n//         return ans;\n    }\n    \n    private static final int HORIZ = 0;\n    private static final int VERT = 1;\n    \n    record Cut(long amount, int type) {}\n    \n    record IndexNum(int index, int value) {}\n    record Matrix(int r0, int c0, int rf, int cf) {}\n\n\t/**\n\t * Sparse table initializes in O(N log N) time, but performs queries in O(1) time.\n\t * Queries must be performed on non-empty ranges within the table's range of [0, n).\n\t * \n\t * NOTE: Prefer using PrimitiveSparseTable, as performance is much better than generics.\n\t */\n\tpublic static class SparseTable<T> {\n\t\tprivate ArrayList<T[]> table;\n\t\tprivate Merger<T> merger;\n\n\t\tpublic SparseTable(T[] a, Merger<T> merger) {\n\t\t\tint n = a.length;\n\t\t\tint p = Math.max(1, Integer.SIZE - Integer.numberOfLeadingZeros(n));\n\n\t\t\tthis.table = new ArrayList<>(p);\n\t\t\tthis.merger = merger;\n\n\t\t\tthis.table.add(Arrays.copyOf(a, n));\n\t\t\tfor (int j = 1; j < p; j++) {\n\t\t\t\tint off = (1 << (j - 1));\n\t\t\t\tT[] prev = this.table.get(j - 1);\n\t\t\t\tT[] curr = Arrays.copyOf(a, n);\n\t\t\t\tfor (int i = 0; i + off < n; i++) {\n\t\t\t\t\tcurr[i] = this.merger.merge(prev[i], prev[i + off]);\n\t\t\t\t}\n\t\t\t\tthis.table.add(curr);\n\t\t\t}\n\t\t}\n\n\t\tpublic T get(int lowerInclusive, int upperInclusive) {\n\t\t\tint k = 31 - Integer.numberOfLeadingZeros(upperInclusive - lowerInclusive + 1);\n\t\t\tint off = (1 << k);\n\t\t\treturn merger.merge(table.get(k)[lowerInclusive], table.get(k)[upperInclusive - off + 1]);\n\t\t}\n\n\t\tpublic static interface Merger<T> {\n\t\t\tpublic T merge(T a, T b);\n\t\t}\n\t}\n}",
    "submit_ts": "1720926462",
    "subm_id": "1320287013"
}