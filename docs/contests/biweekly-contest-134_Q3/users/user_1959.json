{
    "username": "lickcock",
    "submission": "#include <bits/stdc++.h> \n\n#define DEBUG_ON\n#define TERRORIST\n\n#ifdef TERRORIST\nusing namespace std;\n#define int64_t wadwafesfesfes21321300242142104210321\nusing int64_t = long long;\nusing pii = pair<int,int>;\nusing pil = pair<int,int64_t>;\nusing pli = pair<int64_t,int>;\nusing pll = pair<int64_t,int64_t>;\n#define PI 3.14159265358979323846\n#define umap unordered_map\n#define uset unordered_set\n#define all(x) x.begin(), x.end()\n#define allr(x) x.rbegin(), x.rend()\n#define emp_back emplace_back\n#define bitcount(x) __builtin_popcount((x))\n#define mbin(val, cap) bitset<64>(val).to_string().substr(64 - cap)\n#ifdef DEBUG_ON\n    #define debug(x) cout << \"[ \" << #x << \" ]: \" << x << \"\\n\";\n    #define e_ cout << \"\\n\";\n#else\n    #define debug(x)\n    #define e_\n#endif\n\ntemplate<typename F, typename S> ostream& operator<<(ostream &cout, pair<F, S> const &p) { return cout << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate<typename T> ostream& operator<<(ostream &cout, vector<T> const &v) {\n    cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\";\n}\ntemplate <typename K, typename V> ostream& operator<<(ostream& cout, const map<K, V>& omp) {\n    for(auto& [k, v] : omp){ cout << \"(\" << k << \": \" << v << \")\"; if(&v != &omp.rbegin()->second) cout << \", \";} return cout;\n}\ntemplate<typename T> ostream& operator << (ostream& cout, const set<T>& ost) {\n    cout << \"{\";  for(auto& v : ost){ cout << v; if(v != *ost.rbegin()) cout << \", \"; } return cout << \"}\";\n}\ntemplate<typename T, typename Cmp = less<T>>\noptional<vector<T>> get_unique(vector<T>& who, bool in_place = true, Cmp compare = Cmp()){\n    if(in_place){ sort(all(who), compare); who.erase(unique(all(who)), who.end()); return nullopt;}\n    vector<T> ret = who; sort(all(ret), compare); ret.erase(unique(all(ret)), ret.end()); return ret;\n}\nmt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate <typename T>\nT mrand(T begin, T end) {\n    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } \n    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }\n}\nint fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();\n//down, right, up, left, upleft, downright, upright, downleft, stay\nconstexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};\nconstexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};\n#endif\n\nconst int nax = 3'000'00;\nint pref1[nax][2];\nint pref2[nax][2];\nint stat1[2];\nint stat2[2];\n\nclass Solution {\npublic:\n    int numberOfAlternatingGroups(vector<int>& nums, int k) {\n        const int n = nums.size();\n        const bool is_odd = k & 1;\n        nums.insert(nums.end(), all(nums));\n\n        fill(pref1[0], pref1[0] + 2, 0);\n        fill(pref2[0], pref2[0] + 2, 0);\n        for(int i = 0; i < n * 2; i++){\n            if(i){\n                memcpy(pref1[i], pref1[i - 1], sizeof(pref1[i]));\n                memcpy(pref2[i], pref2[i - 1], sizeof(pref2[i]));\n            }\n\n            if(i % 2 == 0)\n                pref1[i][nums[i]]++;\n            else\n                pref2[i][nums[i]]++;\n        }\n\n        auto getP = [&](int begin, int end, int* stat, int (*pref)[2]) -> void {\n            memcpy(stat, pref[end], sizeof(pref[end]));\n            begin--;\n            if(begin < 0) return;\n            for(int i = 0; i <= 1; i++)\n                stat[i] -= pref[begin][i];\n        };\n\n        auto calc = [&](int start, int (*one)[2], int (*two)[2]) -> int {\n            int ans = 0;\n            for(int i = start; i < n; i += 2){\n                getP(i, i + k - 1, stat1, one);\n                getP(i, i + k - 1, stat2, two);\n\n                int should1 = k / 2 + is_odd;\n                int should2 = k / 2;\n\n                int delta1 = abs(stat1[0] - stat1[1]);\n                int delta2 = abs(stat2[0] - stat2[1]);\n                if(delta1 != should1 || delta2 != should2)\n                    continue;\n\n                bool ok = false;\n                if(stat1[0] == should1 && stat2[1] == should2)\n                    ok = true;\n                else if(stat1[1] == should1 && stat2[0] == should2)\n                    ok = true;\n\n                ans += ok;\n            }\n\n            return ans;\n        };\n\n        return calc(0, pref1, pref2) + calc(1, pref2, pref1);\n    }\n};\n\n// #define MAIN_ACTIVE\n#ifdef MAIN_ACTIVE\nvoid solve() {}\nint main() {\n    int test_case;\n    cin >> test_case;\n    while(test_case--)\n        solve();\n\n    return EXIT_SUCCESS;\n}\n#endif",
    "submit_ts": "1720279494",
    "subm_id": "1311753447"
}