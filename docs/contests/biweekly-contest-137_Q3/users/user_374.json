{
    "username": "Wilsano",
    "submission": "class Solution {\npublic:\n    vector<vector<int>> prefix_top_left;\n    vector<vector<int>> prefix_top_right;\n    vector<vector<int>> prefix_bottom_left;\n    vector<vector<int>> prefix_bottom_right;\n    vector<vector<int>> prefix_max;\n    vector<vector<int>> suffix_max;\n\n    vector<vector<int>> get_pair(int r, int target_c, const vector<vector<int>>& prefix){\n        int first_idx = -1, fisrt_val = -1e9;\n        int second_idx = -1, second_val = -1e9;\n        int m = prefix.size();\n        int n = prefix[0].size();\n        for(int i = 0; i < m; ++i){\n            if(i == r)  continue;\n            int val = prefix[i][target_c];\n            if(val >= fisrt_val){\n                second_idx = first_idx;\n                second_val = fisrt_val;\n                first_idx = i;\n                fisrt_val = val;\n            }\n            else if(val >= second_val){\n                second_idx = i;\n                second_val = val;\n            }\n        }\n        return {{first_idx, fisrt_val}, {second_idx, second_val}};\n    }\n\n    long long find(int i, int j, vector<vector<int>>& board){\n        long long val = LLONG_MIN;\n        int m = board.size(), n = board[0].size();\n        if(i != 0 && i != m - 1 && j != 0 && j != n - 1){\n            val = max(val, (long long)board[i][j] + prefix_top_left[i - 1][j - 1] + prefix_bottom_right[i + 1][j + 1]);\n            val = max(val, (long long)board[i][j] + prefix_top_right[i - 1][j + 1] + prefix_bottom_left[i + 1][j - 1]);\n        }\n        \n        // take (i, j) as the center cell, try all possible combimation\n        if(1 <= j && j <= n - 2){\n            vector<vector<int>> pair_1 = get_pair(i, j - 1, prefix_max);\n            vector<vector<int>> pair_2 = get_pair(i, j + 1, suffix_max);\n\n            if(pair_1[0][0] != pair_2[0][0]){\n                val = max(val, (long long)board[i][j] + pair_1[0][1] + pair_2[0][1]);\n            }\n            else{\n                val = max(val, (long long)board[i][j] + pair_1[0][1] + pair_2[1][1]);\n                val = max(val, (long long)board[i][j] + pair_1[1][1] + pair_2[0][1]);\n            }\n        }\n\n        return val;\n    }\n\n    void initialize_2(int m, int n, vector<vector<int>>& board){\n        prefix_max.resize(m, vector<int>(n, -1e9));\n        suffix_max.resize(m, vector<int>(n, -1e9));\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                prefix_max[i][j] = max(prefix_max[i][max(0, j - 1)], board[i][j]);\n            }\n            for(int j = n - 1; j >= 0; --j){\n                suffix_max[i][j] = max(suffix_max[i][min(n - 1, j + 1)], board[i][j]);\n            }\n        }\n    }\n    \n    void initialize(int m, int n, vector<vector<int>>& board){\n        prefix_top_left.resize(m, vector<int>(n, -1e9));\n        prefix_top_right.resize(m, vector<int>(n, -1e9));\n        prefix_bottom_left.resize(m, vector<int>(n, -1e9));\n        prefix_bottom_right.resize(m, vector<int>(n, -1e9));\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                prefix_top_left[i][j] = board[i][j];\n                if(i >= 1)      prefix_top_left[i][j] = max(prefix_top_left[i][j], prefix_top_left[i - 1][j]);\n                if(j >= 1)      prefix_top_left[i][j] = max(prefix_top_left[i][j], prefix_top_left[i][j - 1]);\n            }\n        }\n        \n        for(int i = 0; i < m; ++i){\n            for(int j = n - 1; j >= 0; --j){\n                prefix_top_right[i][j] = board[i][j];\n                if(i >= 1)       prefix_top_right[i][j] = max(prefix_top_right[i][j], prefix_top_right[i - 1][j]);\n                if(j + 1 < n)    prefix_top_right[i][j] = max(prefix_top_right[i][j], prefix_top_right[i][j + 1]);\n            }\n        }\n        \n        for(int i = m - 1; i >= 0; --i){\n            for(int j = 0; j < n; ++j){\n                prefix_bottom_left[i][j] = board[i][j];\n                if(i + 1 < m)    prefix_bottom_left[i][j] = max(prefix_bottom_left[i][j], prefix_bottom_left[i + 1][j]);\n                if(j >= 1)       prefix_bottom_left[i][j] = max(prefix_bottom_left[i][j], prefix_bottom_left[i][j - 1]);\n            }\n        }\n        \n        for(int i = m - 1; i >= 0; --i){\n            for(int j = n - 1; j >= 0; --j){\n                prefix_bottom_right[i][j] = board[i][j];\n                if(i + 1 < m)    prefix_bottom_right[i][j] = max(prefix_bottom_right[i][j], prefix_bottom_right[i + 1][j]);\n                if(j + 1 < n)    prefix_bottom_right[i][j] = max(prefix_bottom_right[i][j], prefix_bottom_right[i][j + 1]);\n            }\n        }\n    }\n\n    long long maximumValueSum(vector<vector<int>>& board) {\n        // find prefix max for [0:0] ~ [i:j]\n        int m = board.size();\n        int n = board[0].size();\n        initialize(m, n, board);\n        initialize_2(m, n, board);\n\n        long long max_val = LLONG_MIN;\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                long long val = find(i, j, board);\n                max_val = max(max_val, val);\n            }\n        }\n\n        return max_val;\n    }\n};",
    "submit_ts": "1723908937",
    "subm_id": "1359173137"
}