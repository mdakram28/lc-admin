{
    "username": "dennis753951",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        \n        function<int(vector<vector<int>>&)> f = [&](vector<vector<int>>& edges) {\n            int n = edges.size() + 1;\n            \n            vector<int> *adj = new vector<int>[n];\n            \n            for(auto &v : edges) {\n                adj[v[0]].push_back(v[1]);\n                adj[v[1]].push_back(v[0]);\n            }\n            \n            queue<int> q;\n            \n            bool *vis = new bool[n]{};\n            \n            q.push(0);\n            vis[0] = true;\n            \n            int u, start;\n            while(!q.empty()) {\n                u = q.front();\n                q.pop();\n                \n                start = u;\n                \n                for(int &v : adj[u]) {\n                    if(vis[v]) continue;\n                    \n                    vis[v] = true;\n                    q.push(v);\n                }\n            }\n            \n            memset(vis, false, n * sizeof(bool));\n            q.push(start);\n            \n            \n            int size, step = 0;\n            while(!q.empty()) {\n                size = q.size();\n                \n                for(int r = 0; r != size; ++r) {\n                    u = q.front();\n                    q.pop();\n\n                    start = u;\n\n                    for(int &v : adj[u]) {\n                        if(vis[v]) continue;\n\n                        vis[v] = true;\n                        q.push(v);\n                    }\n                }\n                ++step;\n            }\n            \n            return step;\n        };\n        \n        int a = f(edges1);\n        int b = f(edges2);\n        \n        // cout << a << \", \" << b << \"\\n\";\n        \n        return max(max(a - 1, b - 1), (a / 2 + b / 2) + 1);\n    }\n};",
    "submit_ts": 1719716393.0
}