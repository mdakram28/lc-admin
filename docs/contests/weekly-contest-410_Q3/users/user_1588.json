{
    "username": "VYOM_GOYAL",
    "submission": "#include <bits/stdc++.h>\n#define ll long long\n#define MOD 1000000007\n#define arr_inp  long long arr[n]; for(long long i=0;i<n;i++){cin>>arr[i];}\n#define vec_inp vector<long long>arr(n); for(int i=0;i<n;i++){ int x; cin>>x; arr[i] = x;}\n#define arr_vec_output for(int i=0;i<n;i++){ cout<<arr[i]<<\" \";} cout<<endl;\n#define map_arr_inp  unordered_map<long long, long long>mp; long long arr[n]; for(long long i=0;i<n;i++){cin>>arr[i]; mp[arr[i]]++;}\n#define str_inp string s; cin>>s;\n#define vecint(arr) vector<int>arr\n#define vecll(arr) vector<long long>arr\n#define umpint(mp) unordered_map<int, int>mp\n#define umpll(mp) unordered_map<long long, long long>mp\n#define mpint(mp) map<int, int>mp\n#define mpll(mp) map<long long, long long>mp\n#define pb push_back\n#define ppb pop_back\n#define w(x) long long x; cin>>x; while(x--)\n#define out_YES cout<<\"YES\\n\";\n#define out_Yes cout<<\"Yes\\n\";\n#define out_yes cout<<\"yes\\n\";\n#define out_NO cout<<\"NO\\n\";\n#define out_No cout<<\"No\\n\";\n#define out_no cout<<\"no\\n\";\n#define print(v) ({for(auto x:v) cout<<x<<\" \";})\n#define sortarr(v) sort(v.begin(),v.end())\n#define reverse(v) reverse(v.begin(), v.end())\n#define vmax(v)  *max_element(v.begin(),v.end())\n#define vmin(v) *min_element(v.begin(),v.end())\n#define acc(v)  accumulate(v.begin(), v.end(), 0)\n#define f0(n) for(int i=0;i<n;i++)\n#define f1(n) for(int i=1;i<n;i++)\n#define fn2(n) for(int i=n-2;i>=0;i--)\n#define dis(x) cout<<x<<\" \"\n#define rt return true\n#define rf return false\n#define fio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#pragma GCC optimize(\"03\", \"unroll-loops\")\nusing namespace std;\nclass Node\n{\npublic:\n    Node* links[26];\n    bool flag = false;\n\n    bool containsKey(char ch)\n    {\n        return (links[ch-'a']!=NULL);\n    }\n\n    void putChar(char ch, Node* node)\n    {\n        links[ch-'a'] = node;\n    }\n\n    Node* getChar(char ch)\n    {\n        return links[ch-'a'];\n    }\n\n    void setEnd()\n    {\n        flag = true;\n    }\n\n    bool isEnd()\n    {\n        return flag;\n    }\n};\n\nclass Trie\n{\nprivate:\n    Node* root;\npublic:\n    Trie()\n    {\n        root = new Node();\n    }\n\n    void insertWord(string word)\n    {\n        Node* node = root;\n        for(int i=0; i<word.size(); i++)\n        {\n            if(!node->containsKey(word[i]))\n            {\n                node->putChar(word[i], new Node());\n            }\n            node = node->getChar(word[i]);\n        }\n        node->setEnd();\n    }\n\n    bool searchWord(string word)\n    {\n        Node* node = root;\n        for(int i=0; i<word.size(); i++)\n        {\n            if(!node->containsKey(word[i]))\n            {\n                return false;\n            }\n            node = node->getChar(word[i]);\n        }\n        return node->isEnd();\n    }\n};\n\nclass DisjointSet\n{\n    vector<int>rank, parent, size;\npublic:\n    DisjointSet(int n)\n    {\n        rank.resize(n+1, 0);\n        parent.resize(n+1);\n        for(int i=0; i<=n; i++)\n        {\n            parent[i] = i;\n        }\n        size.resize(n+1, 1);\n    }\n\n    int findUpar(int node)\n    {\n        if(node == parent[node])\n        {\n            return node;\n        }\n        return parent[node] = findUpar(parent[node]);\n    }\n\n    void UnionByRank(int u, int v)\n    {\n        int ulp_u = findUpar(u);\n        int ulp_v = findUpar(v);\n\n        if(ulp_u == ulp_v)\n        {\n            return ;\n        }\n        else if(rank[ulp_u] < rank[ulp_v])\n        {\n            parent[ulp_u] = ulp_v;\n        }\n        else if(rank[ulp_v] < rank[ulp_u])\n        {\n            parent[ulp_v] = ulp_u;\n        }\n        else\n        {\n            parent[ulp_v] = ulp_u;\n            rank[ulp_u]++;\n        }\n    }\n\n    void UnionBySize(int u, int v)\n    {\n        int ulp_u = findUpar(u);\n        int ulp_v = findUpar(v);\n\n        if(ulp_u == ulp_v)\n        {\n            return ;\n        }\n        else if(size[ulp_u] < size[ulp_v])\n        {\n            parent[ulp_u] = ulp_v;\n            size[ulp_v]+=size[ulp_u];\n        }\n        else{\n            parent[ulp_v] = ulp_u;\n            size[ulp_u]+=size[ulp_v];\n        }\n    }\n};\n\n\n\nconst int LIMIT = 200000;\nset<int> primes;\nbool isPrime[LIMIT + 1];\n\nvoid sieveOfEratosthenes(int n)\n{\n    fill(isPrime, isPrime + n + 1, true);\n    isPrime[0] = isPrime[1] = false;\n\n    for (int p = 2; p * p <= n; ++p)\n    {\n        if (isPrime[p])\n        {\n            for (int i = p * p; i <= n; i += p)\n            {\n                isPrime[i] = false;\n            }\n        }\n    }\n\n    for (int p = 2; p <= n; ++p)\n    {\n        if (isPrime[p])\n        {\n            primes.insert(p);\n        }\n    }\n}\n\nclass Solution {\npublic:\n    int findAns(vector<int>&nums, vector<vector<vector<int>>>& dp, int i, int j, int k) {\n        if (i == 0) {\n            return 1; \n        }\n        if (dp[i][j][k] != -1) {\n            return dp[i][j][k];\n        }\n        int ans = 0;\n        for (int l = 0; l <= j; l++) {\n            int new_k = nums[i - 1] - l;\n            if (new_k >= k && new_k <= 50) {\n                ans = (ans + findAns(nums, dp, i - 1, l, new_k)) % MOD;\n            }\n        }\n        return dp[i][j][k] = ans;\n    }\n    int countOfPairs(vector<int>& nums) {\n        int n = nums.size();\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(51, vector<int>(51, -1)));\n        int ans = 0;\n        for (int i = 0; i <= nums[n-1]; i++) {\n            int j = nums[n-1] - i;\n            ans = (ans + findAns(nums, dp, n-1, i, j)) % MOD;\n        }\n        return ans;\n    }\n};\nauto init = []()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    return 'c';\n}\n();",
    "submit_ts": "1723346280",
    "subm_id": "1351574124"
}