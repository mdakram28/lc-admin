{
    "username": "BeruboIV",
    "submission": "template <typename T = long long>\nclass RMQ{\n\npublic:\n    int N = 2e5;\n    vector<int> LOG2;    //Quick lookup table for floor(log2(i)), 1 <= i <= N\n    vector<T> dp[26];    //dp[i][j] = [j, j + (1 << i) ) --> Notice the open interval\n    vector<T> arr;\n\n    RMQ(){\n        LOG2.resize(N + 1);\n        arr.resize(N + 1);\n        for(int i = 0; i < 26; i++){\n            dp[i].resize(N + 1);\n        }\n\n        for(int i = 2; i <= N; i++)\n            LOG2[i] = 1 + LOG2[i/2];\n    }\n\n    RMQ(int N)\n        : N(N){\n        LOG2.resize(N + 1);\n        arr.resize(N + 1);\n        for(int i = 0; i < 26; i++){\n            dp[i].resize(N + 1);\n        }\n        \n        for(int i = 2; i <= N; i++)\n            LOG2[i] = 1 + LOG2[i/2];\n    }\n\n    RMQ (vector<T> &a){\n        N = (a.empty() ? N : a.size());\n        LOG2.resize(N + 1);\n        arr.resize(N + 1);\n        for(int i = 0; i < 26; i++){\n            dp[i].resize(N + 1);\n        }\n\n        for(int i = 2; i <= N; i++)\n            LOG2[i] = 1 + LOG2[i/2];\n\n        if(!a.empty())\n            build(a);\n    }\n\n    void build(vector<T> &a){\n        int n = a.size();\n        for(int i = 0; i < n; i++)\n            arr[i] = a[i];\n\n        //Filling first row\n        for(int i = 0; i < n; i++){\n            dp[0][i] = i;\n        }\n\n        // Note: Breaks ties by choosing the largest index\n        int P = LOG2[n];\n        for(int p = 1; p <= P; p++){\n            for(int i = 0; i + (1 << p) <= n; i++){\n                T left = dp[p - 1][i];\n                T right = dp[p - 1][i + (1 << (p - 1))];\n                if(arr[left] < arr[right])\n                    dp[p][i] = left;\n                else\n                    dp[p][i] = right;\n\n            }\n        }\n    }\n\n    //Query the smallest element in the range [l, r], O(1)\n    T query_val(int l, int r){\n        if(l > r){\n            return 1e18;\n        }\n        int len = r - l + 1;\n        int p = LOG2[len];\n        T left = arr[dp[p][l]];\n        T right = arr[dp[p][r - (1 << p) + 1]];\n        return min(left, right);\n    }\n\n    //Query the smallest element in the range [l, r] by doing\n    //a cascading min query, O(log2(n));\n    //This function can be used to return sum of ranges also\n    T CascadingQuery(int l, int r){\n        T min_val = 1e18;\n        for(int p = LOG2[r - l + 1]; l <= r; p = LOG2[r - l + 1]){\n            min_val = min(min_val, arr[dp[p][l]]);\n            l += (1 << p);\n        }\n        return min_val;\n    }\n\n    int query_idx(int l, int r){\n        if(l > r){\n            return N + 1;\n        }\n        int len = r - l + 1;\n        int p = LOG2[len];\n        int left = dp[p][l];\n        int right = dp[p][r - (1 << p) + 1];\n        return (arr[left] < arr[right] ? left : right);\n    }\n\n};\n\nclass Solution {\nprivate:\n    long long cnt(int l, int r, RMQ<long long> &rmq, vector<long long> &nums, long long ans = 0) {\n        if(l > r)\n            return 0;\n        int idx = rmq.query_idx(l, r);\n        long long temp = max(0ll, nums[idx] - ans);\n        return max(0ll, nums[idx] - ans) + cnt(l, idx - 1, rmq, nums, ans + temp) + cnt(idx + 1, r, rmq, nums, ans + temp);\n    }\npublic:\n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n        int N = nums.size();\n        vector<long long> possDiff(N), negDiff(N);\n        \n        \n        for(int i = 0; i < N; i++) {\n            if(target[i] > nums[i])\n                possDiff[i] = target[i] - nums[i];\n            else\n                negDiff[i] = nums[i] - target[i];\n        }\n        \n        long long ans = 0;\n        \n        int l = 0, r = 0;\n        RMQ<long long> rmq1(possDiff), rmq2(negDiff);\n        \n        for(int i = 0; i < N; i++) {\n            if(possDiff[i] > 0) {\n                r++;\n            }\n            else {\n                ans += cnt(l, r, rmq1, possDiff);\n                l = i;\n                r = i;\n            }\n        }\n        ans += cnt(l, N - 1, rmq1, possDiff);\n        \n        l = 0, r = 0;\n        for(int i = 0; i < N; i++) {\n            if(negDiff[i] > 0) {\n                r++;\n            }\n            else {\n                ans += cnt(l, r, rmq2, negDiff);\n                l = i;\n                r = i;\n            }\n        }\n        ans += cnt(l, N - 1, rmq2, negDiff);\n        \n        return ans;\n    }\n};",
    "submit_ts": "1721533029",
    "subm_id": "1327999642"
}