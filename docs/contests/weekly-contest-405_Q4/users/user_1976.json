{
    "username": "kirya2604",
    "submission": "const int k = 26;\n\nstruct Vertex {\n    Vertex *to[k] = {0}, *go[k] = {0};\n    Vertex *link = 0, *p;\n    int pch;\n    bool terminal = false;\n    int ID_in_vector = -1;\n    Vertex (int _pch, Vertex *_p) { pch = _pch, p = _p; }\n};\nVertex *root = new Vertex(-1, 0);\n\nvoid freeMem(Vertex* root)\n{\n    for (int i = 0; i < k; i ++)\n        if (root -> to[i])\n            freeMem(root -> to[i]);\n    delete root;\n}\n\nvoid add_string(string &s, int _id) {\n    Vertex *v = root;\n    for (char _c : s) {\n        int c = int(_c - 'a');\n        if (!v->to[c])\n            v->to[c] = new Vertex(c, v);\n        v = v->to[c];\n    }\n    v -> terminal = true;\n    v -> ID_in_vector = _id;\n}\n\n// \u043d\u0430\u043c \u043d\u0443\u0436\u043d\u043e \u043e\u0431\u044a\u044f\u0432\u0438\u0442\u044c \u0434\u0432\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438, \u0441\u0441\u044b\u043b\u0430\u044e\u0449\u0438\u0435\u0441\u044f \u0434\u0440\u0443\u0433 \u043d\u0430 \u0434\u0440\u0443\u0433\u0430\nVertex* go(Vertex *v, int c);\n\nVertex* link(Vertex *v) {\n    if (!v->link) {\n        // \u0434\u043b\u044f \u0441\u0442\u0440\u043e\u043a \u0434\u043b\u0438\u043d\u044b \u043c\u0435\u043d\u044c\u0448\u0435 \u0434\u0432\u0443\u0445 \u0441\u0443\u0444\u0444\u0438\u043a\u0441\u043d\u0430\u044f \u0441\u0441\u044b\u043b\u043a\u0430 \u044d\u0442\u043e \u043a\u043e\u0440\u0435\u043d\u044c\n        if (v == root || v->p == root)\n            v->link = root;\n        else // \u0432 \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0445 \u0441\u043b\u0443\u0447\u0430\u044f\u0445 \u0444\u043e\u0440\u043c\u0443\u043b\u0430 \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442\n            v->link = go(link(v->p), v->pch);\n    }\n    return v->link;\n}\n\nVertex* go(Vertex *v, int c) {\n    if (!v->go[c]) {\n        // \u0435\u0441\u043b\u0438 \u043f\u0435\u0440\u0435\u0445\u043e\u0434 \u0435\u0441\u0442\u044c, \u0442\u043e \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u043d\u044b\u0439 \u0434\u043e\u043b\u0436\u0435\u043d \u0432\u0435\u0441\u0442\u0438 \u0442\u0443\u0434\u0430 \u0436\u0435\n        if (v->to[c])\n            v->go[c] = v->to[c];\n        // \u0435\u0441\u043b\u0438 \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0430 \u043d\u0435\u0442, \u043d\u043e \u0432\u0435\u0440\u0448\u0438\u043d\u0430 \u043a\u043e\u0440\u0435\u043d\u044c, \u0442\u043e \u043d\u0443\u0436\u043d\u043e \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u043f\u0435\u0442\u043b\u044e\n        else if (v == root)\n            v->go[c] = root;\n        else // \u0432 \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0445 \u0441\u043b\u0443\u0447\u0430\u044f\u0445 \u0444\u043e\u0440\u043c\u0443\u043b\u0430 \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442\n            v->go[c] = go(link(v), c);\n    }\n    return v->go[c];\n}\n\nvector<string> pattern;\nvector<int> occurences[50100];\n\nvoid check(Vertex* v,int i){\n    for(Vertex* u=v ; u!= nullptr && u != root ;u = link(u)){\n        if (u -> terminal) {\n            occurences[i-pattern[u -> ID_in_vector].length() + 1].push_back(u -> ID_in_vector);\n            //cout << i-pattern[u -> ID_in_vector].length() + 1 <<\" \";\n            //cout <<pattern[u -> ID_in_vector] <<endl;\n        }\n    }\n}\n\nvoid find_all_pos(const string& s){\n    Vertex* u = root;\n    for(int i=0;i<s.length();i++){\n\n        u = go( u , s[i]-'a' );\n        check(u,i+1);\n    }\n}\n\nclass Solution {\n\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        //if (root != nullptr) freeMem(root);\n\n        root = new Vertex(-1, 0);\n        pattern.resize(0);\n\n        vector< pair<int, string> > toSort;\n        for (int i = 0; i < words.size(); i ++)\n            toSort.push_back({-costs[i], words[i]});\n        sort(toSort.begin(), toSort.end());\n\n        pattern.assign(words.size(), \"\");\n        for (int i = 0; i < words.size(); i ++)\n        {\n            //if (i > 0 && toSort[i].second == toSort[i - 1].second) continue;\n            add_string(toSort[i].second, i);\n            pattern[i] = toSort[i].second;\n            words[i] = toSort[i].second;\n            costs[i] = -toSort[i].first;\n        }\n\n\n        find_all_pos(target);\n        target = \"#\" + target;\n\n        vector<int> dp(target.length(), 0);\n        for (int i = 1; i < target.length(); i ++) dp[i] = (1 << 30);\n        \n        for (int i = 0; i + 1 < target.length(); i ++)\n        {\n            if (occurences[i + 1].size() > 0)\n            {\n                for (int id : occurences[i + 1])\n                {\n                    int id2 = i + words[id].length();\n                    if (id2 < target.length()) {\n                        dp[id2] = min(dp[id2], dp[i] + costs[id]);\n                        //cout << id2 << \" \" << dp[id2] << \" from \" << i << \" \" << dp[i] << endl;\n                    }\n                }\n            }\n        }\n\n        int rr = (dp[target.length() - 1] == (1 << 30) ? -1 : dp[target.length() - 1]);\n        if (root != nullptr) freeMem(root);\n        for (int i = 0; i < target.length(); i++)\n            occurences[i].resize(0);\n        return rr;\n    }\n};",
    "submit_ts": "1720324711",
    "subm_id": "1312406126"
}