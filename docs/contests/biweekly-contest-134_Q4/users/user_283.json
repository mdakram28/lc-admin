{
    "username": "aadritoD",
    "submission": "template<typename ValueType, class Updater, bool range_update = false>\nclass SegmentTree {\n\npublic:\n\n    uint32_t N;\n\n    explicit SegmentTree(std::vector<ValueType>&& data) : N(data.size()), _height(get_height(data.size())), _tree(data.size()) {\n        _data = std::vector<ValueType>(std::move(data));\n        if constexpr (!range_update) build_range(N, 2 * N - 1);\n    }\n\n    explicit SegmentTree(const std::vector<ValueType>& data) : N(data.size()), _height(get_height(data.size())), _tree(data.size()) {\n        _data = std::vector<ValueType>(data);\n        if constexpr (!range_update) build_range(N, 2 * N - 1);\n    }\n\n    explicit SegmentTree(uint32_t size) : N(size), _height(get_height(size)), _tree(size) {\n        _data = std::vector<ValueType>(size);\n        if constexpr (!range_update) build_range(N, 2 * N - 1);\n    }\n\n\n    template <typename... Args>\n    void update_range(uint32_t L, uint32_t R, Args&&... args) {\n        Updater updater;\n        if constexpr (is_lazy()) {\n            updater = Updater(std::forward<Args>(args)...);\n        }\n\n        L += N;\n        R += N;\n\n        const uint32_t orig_L = L, orig_R = R;\n\n        if constexpr (is_lazy()) {\n            push_range(L, L + 1);\n            push_range(R, R + 1);\n        }\n\n        while (L <= R) {\n\n            if constexpr (is_lazy()) {\n\n                if (is_left_child(R)) {\n                    apply_lazy(R, updater);\n                    R--;\n                }\n\n                if (is_right_child(L)) {\n                    apply_lazy(L, updater);\n                    L++;\n                }\n\n            }\n            else {\n                if (is_left_child(R)) {\n                    apply(R, std::forward<Args>(args)...);\n                    R--;\n                }\n\n                if (is_right_child(L)) {\n                    apply(L, std::forward<Args>(args)...);\n                    L++;\n                }\n            }\n\n            L = parent(L);\n            R = parent(R);\n        }\n\n        if constexpr (is_lazy()) {\n            build_range(orig_L, orig_L + 1);\n            build_range(orig_R, orig_R + 1);\n        }\n    }\n\n    ValueType query_range(uint32_t L, uint32_t R) {\n\n        L += N;\n        R += N;\n\n        if constexpr (is_lazy()) {\n            push_range(L, L + 1);\n            push_range(R, R + 1);\n        }\n\n        ValueType retval_L{}, retval_R{};\n        bool started_L = false, started_R = false;\n\n        while (L <= R) {\n\n            if (is_left_child(R)) {\n                if (started_R) {\n                    ValueType temp = access(R);\n                    Updater::accumulate(temp, retval_R);\n                    retval_R = temp;\n                }\n                else {\n                    retval_R = access(R);\n                    started_R = true;\n                }\n                R--;\n            }\n\n            if (is_right_child(L)) {\n                if (started_L) {\n                    Updater::accumulate(retval_L, access(L));\n                }\n                else {\n                    retval_L = access(L);\n                    started_L = true;\n                }\n                L++;\n            }\n\n            R = parent(R);\n            L = parent(L);\n        }\n\n        if (!started_L) {\n            return retval_R;\n        }\n\n        if (!started_R) {\n            return retval_L;\n        }\n\n        Updater::accumulate(retval_L, retval_R);\n\n        return retval_L;\n    }\n\n    ValueType query(uint32_t index) {\n        if constexpr (is_lazy()) {\n            return query_range(index, index);\n        }\n        index += N;\n        ValueType retval = access(index);\n        index = parent(index);\n        while (index > 0) {\n            Updater::accumulate(retval, _tree[index].value);\n            index = parent(index);\n        }\n        return retval;\n    }\n\n    template <typename... Args>\n    void update(uint32_t index, Args&&... args) {\n        if constexpr (is_lazy()) {\n            return update_range(index, index, std::forward<Args>(args)...);\n        }\n        Updater::update(_data[index], std::forward<Args>(args)...);\n        index += N;\n        index = parent(index);\n        while (index > 0) {\n            recalc(index);\n            index = parent(index);\n        }\n    }\n\n\nprivate:\n\n\n    void build_range(uint32_t L, uint32_t R) {\n        while (L > 1) {\n            L = parent(L);\n            R = parent(R);\n            for (uint32_t i = R; i >= L; i--) { //reverse ordering to handle overlaps from arbitrary indexing\n                recalc(i);\n            }\n        }\n    }\n\n    void push_range(uint32_t L, uint32_t R) {\n        for (uint32_t layer = _height; layer > 0; layer--) {\n            for (uint32_t i = L >> layer; i <= R >> layer; i++) {\n                if (i >= N) break;\n                apply_lazy(left_child(i), _tree[i].lazy_data);\n                apply_lazy(right_child(i), _tree[i].lazy_data);\n                _tree[i].lazy_data = Updater();\n            }\n        }\n    }\n\n    void push(uint32_t index) {\n        if constexpr (!is_lazy()) return;\n        if (index < N) {\n            apply_lazy(left_child(index), _tree[index].lazy_data);\n            apply_lazy(right_child(index), _tree[index].lazy_data);\n            _tree[index].lazy_data = Updater();\n        }\n    }\n\n    void apply_lazy(uint32_t index, const Updater& updater) {\n        if (index < N) _tree[index].lazy_data.compose(updater);\n        updater.update(access(index));\n    }\n\n    template<typename... Args>\n    inline void apply(uint32_t index, Args&&... args) {\n        Updater::update(access(index), std::forward<Args>(args)...);\n    }\n    \n\n    void recalc(uint32_t index) {\n        if (index < N) {\n            ValueType left = access(left_child(index));\n            Updater::accumulate(left, access(right_child(index)));\n            _tree[index].value = std::move(left);\n            if constexpr (is_lazy()) {\n                _tree[index].lazy_data.update(_tree[index].value);\n            }\n        }\n    }\n\n    inline ValueType& access(uint32_t index) {\n        if (index < N) {\n            return _tree[index].value;\n        }\n        else {\n            return _data[index - N];\n        }\n    }\n\n#ifdef __GNUC__\n    static inline constexpr uint32_t clz(uint32_t x) {\n        return __builtin_clz(x);\n    }\n#elif defined(_MSVC_LANG)\n    static inline constexpr uint32_t clz(uint32_t x) {\n        return __lzcnt(x);\n    }\n#else\n    static inline constexpr uint32_t clz(uint32_t x) {\n        x |= (x >> 1);\n        x |= (x >> 2);\n        x |= (x >> 4);\n        x |= (x >> 8);\n        x |= (x >> 16);\n        return 32 - std::bitset<32>(x).count();\n    }\n#endif\n\n    inline constexpr uint32_t get_height(uint32_t size) {\n        return sizeof(int) * 8 - clz(size);\n    }\n\n    inline constexpr bool is_left_child(uint32_t node) {\n        return node % 2 == 0;\n    }\n\n    inline constexpr bool is_right_child(uint32_t node) {\n        return node % 2 == 1;\n    }\n\n    inline constexpr uint32_t parent(uint32_t node) {\n        return node / 2;\n    }\n\n    inline constexpr uint32_t left_child(uint32_t node) {\n        return node * 2;\n    }\n\n    inline constexpr uint32_t right_child(uint32_t node) {\n        return node * 2 + 1;\n    }\n\n    constexpr static bool is_lazy() {\n        return !std::is_empty_v<Updater>;\n    }\n\n    struct Node {\n\n        Updater lazy_data;\n        ValueType value;\n\n        Node() : lazy_data(), value() {}\n\n    };\n\n    std::vector<Node> _tree;\n    std::vector<ValueType> _data;\n    uint32_t _height;\n\n};\n\nusing ll = long long;\n\nstruct AND_QUERY {\n\n    static void accumulate(int& a, int b) {\n        a &= b;\n    }\n\n};\n\nclass Solution {\npublic:\n\n    bool is_super_mask(int k, int candidate) {\n        return ((k & candidate) == k) && (candidate != k);\n    }\n\n    //query first non strict super-mask\n    int search_first(SegmentTree<int, AND_QUERY>& ds, int k, int L, int R) {\n        if (is_super_mask(k, ds.query_range(L, R))) {\n            return -1;\n        }\n        int start = L;\n        int mid = (L + R) / 2;\n        while (L < mid && mid < R) {\n            int val = ds.query_range(start, mid);\n            if (is_super_mask(k, val)) {\n                L = mid + 1;\n            } else {\n                R = mid;\n            }\n            mid = (L + R) / 2;\n        }\n        if (is_super_mask(k, ds.query_range(start, L))) {\n            return R;\n        } else {\n            return L;\n        }\n    }\n\n    int search_last_k(SegmentTree<int, AND_QUERY>& ds, int k, int begin, int L, int R) {\n        assert(ds.query_range(begin, L) == k);\n        int mid = (L + R) / 2;\n        while (L < mid && mid < R) {\n            int val = ds.query_range(begin, mid);\n            if (val == k) {\n                L = mid;\n            } else {\n                R = mid - 1;\n            }\n            mid = (L + R) / 2;\n        }\n        if (ds.query_range(begin, R) == k) {\n            return R;\n        } else {\n            return L;\n        }\n    }\n\n    long long countSubarrays(vector<int>& nums, int k) {\n        \n        SegmentTree<int, AND_QUERY> ds(nums);\n        long long cnt = 0;\n        int N = nums.size();\n\n        for (int i = 0; i < N; i++) {\n\n            int L = search_first(ds, k, i, N - 1);\n            if (L == -1) continue;\n            if (ds.query_range(i, L) != k) continue;\n\n            int R = search_last_k(ds, k, i, L, N - 1);\n\n            cnt += (R - L + 1);\n\n        }\n\n        return cnt;\n\n    }\n};",
    "submit_ts": "1720278675",
    "subm_id": "1311719445"
}