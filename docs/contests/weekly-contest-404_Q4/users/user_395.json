{
    "username": "Q4IYURYDjU",
    "submission": "class Solution:\n    from collections import deque, defaultdict\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:        \n\n\n        def bfs_farthest_node(start, tree):\n            n = len(tree)\n            dist = [-1] * n\n            queue = deque([start])\n            dist[start] = 0\n            farthest_node = start\n            max_dist = 0\n\n            while queue:\n                node = queue.popleft()\n                for neighbor in tree[node]:\n                    if dist[neighbor] == -1:\n                        dist[neighbor] = dist[node] + 1\n                        queue.append(neighbor)\n                        if dist[neighbor] > max_dist:\n                            max_dist = dist[neighbor]\n                            farthest_node = neighbor\n            return farthest_node, max_dist\n\n\n        def find_tree_diameter(tree):\n            # Find one endpoint of the diameter\n            u, _ = bfs_farthest_node(0, tree)\n            # Find the other endpoint of the diameter\n            v, diameter = bfs_farthest_node(u, tree)\n            return diameter\n\n\n        def build_tree(edges, n):\n            tree = defaultdict(list)\n            for u, v in edges:\n                tree[u].append(v)\n                tree[v].append(u)\n            return tree\n\n\n        def min_diameter_after_connection(n, edges1, m, edges2):\n            tree1 = build_tree(edges1, n)\n            tree2 = build_tree(edges2, m)\n\n            diameter1 = find_tree_diameter(tree1)\n            diameter2 = find_tree_diameter(tree2)\n\n            new_diameter = max(diameter1, diameter2, (diameter1 + 1) // 2 + (diameter2 + 1) // 2 + 1)\n            return new_diameter\n        \n        n = len(edges1) + 1\n        m = len(edges2) + 1\n        if(n == 1 == m):\n            return 1\n        \n        if(n == 1):\n            tree = build_tree(edges2, m)\n            if(m == 2):\n                return find_tree_diameter(tree) + 1\n            else:\n                return find_tree_diameter(tree)\n        elif (m == 1):\n            #print(\"lol\")\n            tree = build_tree(edges1, n)\n            if(n == 2):\n                return find_tree_diameter(tree) + 1\n            else:\n                return find_tree_diameter(tree)\n            \n        \n        return(min_diameter_after_connection(n, edges1, m, edges2))\n\n\n",
    "submit_ts": 1719717261.0
}