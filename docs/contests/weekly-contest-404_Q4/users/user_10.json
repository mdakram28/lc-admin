{
    "username": "DylanSmith",
    "submission": "typedef long long ll;\n \n#define pb push_back\n#define sz(x) (int)x.size()\n#define all(x) begin(x),end(x)\n#define lb(x,y) lower_bound(all(x),y)-begin(x)\nnamespace AllRoots {\n    struct Edge { int u, v, cost; };\n    struct Node {\n        int mx = 0;\n        Node merge(Node o) {\n            return {max(mx, o.mx)};\n        }\n        Node promote(Node u, Edge e) {\n            return {mx + 1};\n        }\n    };\n    Edge rev(Edge e) { swap(e.u, e.v); return e; }\n    static vector<Node> solve(vector<Node> nodes, vector<Edge> edges) {\n        int N = sz(nodes);\n        vector<vector<int>> adj(N);\n        vector<Edge> par(N);\n        for (Edge e : edges) {\n            adj[e.u].pb(e.v);\n            adj[e.v].pb(e.u);\n        }\n        queue<int> q; q.push(0);\n        vector<int> srt, pos(N);\n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            pos[u] = sz(srt);\n            srt.pb(u);\n            for (int v : adj[u]) {\n                adj[v].erase(find(all(adj[v]), u));\n                q.push(v);\n            }\n        }\n        for (Edge e : edges) {\n            if (pos[e.u] < pos[e.v]) swap(e.u, e.v);\n            par[e.u] = e;\n        }\n        reverse(all(srt));\n        vector<Node> down(N);\n        for (int u : srt) for (int v : adj[u])\n            down[u] = down[u].merge(down[v].promote(nodes[v], par[v]));\n        reverse(all(srt));\n        vector<Node> up(N), res(N);\n        for (int u : srt) {\n            vector<Node> left(sz(adj[u])), right(sz(adj[u]));\n            for (int i = 0; i < sz(adj[u]); i++) {\n                int v = adj[u][i];\n                left[i] = right[i] = down[v].promote(nodes[v], par[v]);\n            }\n            for (int i = 1; i < sz(adj[u]); i++)\n                left[i] = left[i - 1].merge(left[i]);\n            for (int i = sz(adj[u]) - 2; i >= 0; i--)\n                right[i] = right[i].merge(right[i + 1]);\n            Node p = up[u].promote(nodes[par[u].v], rev(par[u]));\n            for (int i = 0; i < sz(adj[u]); i++) {\n                int v = adj[u][i];\n                if (u > 0) up[v] = up[v].merge(p);\n                if (i > 0) up[v] = left[i - 1].merge(up[v]);\n                if (i + 1 < sz(adj[u])) up[v] = up[v].merge(right[i + 1]);\n            }\n            res[u] = down[u];\n            if (u > 0) res[u] = res[u].merge(p);\n        }\n        return res;\n    }\n}\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        vector<AllRoots::Edge> e1, e2;\n        for (vector<int> e : edges1) e1.pb({e[0], e[1]});\n        for (vector<int> e : edges2) e2.pb({e[0], e[1]});\n        vector<AllRoots::Node> n1(sz(edges1) + 1), n2(sz(edges2) + 1);\n        vector<AllRoots::Node> r1 = AllRoots::solve(n1, e1), r2 = AllRoots::solve(n2, e2);\n        int d1 = INT_MAX, d2 = INT_MAX;\n        int di1 = 0, di2 = 0;\n        for (auto &n : r1) {\n            d1 = min(d1, n.mx);\n            di1 = max(di1, n.mx);\n        }\n        for (auto &n : r2) {\n            d2 = min(d2, n.mx);\n            di2 = max(di2, n.mx);\n        }\n        return max(d1 + d2 + 1, max(di1, di2));\n    }\n};",
    "submit_ts": 1719715757.0
}