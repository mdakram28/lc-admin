{
    "username": "StackEnqueue2",
    "submission": "class Solution {\npublic:\n    pair<int, int> dfs(int node, const vector<int> adj[], vector<bool> &visited, int dist) {\n    visited[node] = true;\n    pair<int, int> farthest = {node, dist};\n\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            pair<int, int> result = dfs(neighbor, adj, visited, dist + 1);\n            if (result.second > farthest.second) {\n                farthest = result;\n            }\n        }\n    }\n\n    return farthest;\n}\n\n// Function to calculate the diameter of the tree\nint f(int n, const vector<int> adj[]) {\n    // Perform first DFS from node 0 (or any node)\n    vector<bool> visited(n, false);\n    pair<int, int> farthestFromStart = dfs(0, adj, visited, 0);\n\n    // Perform second DFS from the farthest node found in the first DFS\n    fill(visited.begin(), visited.end(), false);\n    pair<int, int> farthestFromFarthest = dfs(farthestFromStart.first, adj, visited, 0);\n\n    // The distance to the farthest node in the second DFS is the diameter of the tree\n    return farthestFromFarthest.second;\n}\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& aa, vector<vector<int>>& bb) {\n        int n=aa.size(),m=bb.size();\n        n++,m++;\n        vector<int> a[n],b[m];\n        for(auto i:aa)\n        {\n            a[i[0]].push_back(i[1]);\n            a[i[1]].push_back(i[0]);\n        }\n        for(auto i:bb)\n        {\n            b[i[0]].push_back(i[1]);\n            b[i[1]].push_back(i[0]);\n        }\n        int fi=f(n,a),se=f(m,b);\n        // cout<<fi<<\" \"<<se<<\"\\n\";\n        int ans=max({fi,se,1+fi/2+fi%2+se/2+se%2});\n        return ans;\n    }\n};",
    "submit_ts": 1719718087.0
}