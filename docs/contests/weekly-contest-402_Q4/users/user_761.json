{
    "username": "bill10391",
    "submission": "class Solution {\npublic:\n    #define ll long long\nstruct segtree {\n    vector<ll> seg;\n    int n, sz;\n\n    segtree(int N, vector<ll> &v) {\n        n = N;\n        sz = 1;\n        while (sz < 4 * n) sz *= 2;\n        seg.assign(sz, 0);\n        build(0, 0, n - 1, v);\n    }\n\n    void build(int idx, int l, int r, vector<ll> &v) {\n        if (l == r) {\n            seg[idx] = v[l];\n            return;\n        }\n        int mp = (l + r) / 2;\n        build(2 * idx + 1, l, mp, v);\n        build(2 * idx + 2, mp + 1, r, v);\n        seg[idx] = seg[2 * idx + 1] + seg[2 * idx + 2];\n    }\n\n    void set(int idx, ll v) {\n        set(0, 0, n - 1, idx, v);\n    }\n\n    void set(int idx, int l, int r, int setIdx, ll v) {\n        if (l == r) {\n            seg[idx] = v;\n            return;\n        }\n        int mp = (l + r) / 2;\n        if (setIdx <= mp) set(2 * idx + 1, l, mp, setIdx, v);\n        else set(2 * idx + 2, mp + 1, r, setIdx, v);\n        seg[idx] = seg[2 * idx + 1] + seg[2 * idx + 2];\n    }\n\n    ll get(int l, int r) {\n        return get(0, 0, n - 1, l, r);\n    }\n\n    ll get(int idx, int l, int r, int ql, int qr) {\n        if (l > qr || r < ql) return 0;\n        else if (l >= ql && r <= qr) return seg[idx];\n        int mp = (l + r) / 2;\n        return get(2 * idx + 1, l, mp, ql, qr) + get(2 * idx + 2, mp + 1, r, ql, qr);\n    }\n};\n\nvoid checkUpdate(vector<int>& nums, segtree &seg, vector<ll> &peaks, int idx, int n) {\n    if (0 < idx && idx < n - 1 && nums[idx - 1] < nums[idx] && nums[idx] > nums[idx + 1]) {\n        peaks[idx] = 1;\n    } else {\n        peaks[idx] = 0;\n    }\n    seg.set(idx, peaks[idx]);\n}\n\nvector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n    int n = nums.size();\n    vector<ll> peaks(n);\n    for (int i = 1; i < n - 1; i++) {\n        if (nums[i - 1] < nums[i ] && nums[i] > nums[i + 1]) peaks[i] = 1;\n    }\n\n    segtree seg(n, peaks);\n    int Q = queries.size();\n    vector<int> res;\n    for (int q = 0; q < Q; q++) {\n        if (queries[q][0] == 1) {\n            int l = queries[q][1], r = queries[q][2];\n            int ans = seg.get(l, r);\n            if (peaks[l]) ans--;\n            if (l != r && peaks[r]) ans--;\n            res.push_back(ans);\n        } else {\n            int idx = queries[q][1], val = queries[q][2];\n            nums[idx] = val;\n            for (int i = max(0, idx - 1); i < min(idx + 2, n); i++) {\n                checkUpdate(nums, seg, peaks, i, n);\n            }\n        }\n    }\n    return res;\n\n}\n};",
    "submit_ts": 1718508102.0
}