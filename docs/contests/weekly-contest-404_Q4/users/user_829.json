{
    "username": "_drifter",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n\n        auto d = [] (vector<vector<int>> &edges) -> pair<int, int> {\n\n            int n = edges.size() + 1;\n\n            if (n == 1) {\n                return {0, 0};\n            }\n\n            if (n == 2) {\n                return {1, 1};\n            }\n\n            vector<int> deg(n, 0);\n            vector<vector<int>> graph(n);\n\n            for (const vector<int> &edge : edges) {\n                ++deg[edge.front()];\n                ++deg[edge.back()];\n                graph[edge.front()].push_back(edge.back());\n                graph[edge.back()].push_back(edge.front());\n            }\n\n            queue<int> que;\n            for (int i = 0; i < n; i++) {\n\n                if (deg[i] == 1) {\n                    que.push(i);\n                }\n            }\n\n            unordered_set<int> us;\n            for (int i = 0; i < n; i++) {\n                us.insert(i);\n            }\n\n            while (!que.empty()) {\n\n                int vertex = que.front();\n                que.pop();\n                us.erase(vertex);\n\n                for (int next_vertex : graph[vertex]) {\n\n                    if (--deg[next_vertex] == 1) {\n                        if (2 < (int) us.size()) {\n                            que.push(next_vertex);\n                        }\n                    }\n                }\n            }\n\n            assert ((int) us.size() <= 2);\n\n            int sx = *us.begin();\n\n            vector<int> dist(n, -1);\n            while (!que.empty()) {\n                que.pop();\n            }\n\n            que.push(sx);\n            dist[sx] = 0;\n\n            while (!que.empty()) {\n\n                int vertex = que.front();\n                que.pop();\n\n                for (int next_vertex : graph[vertex]) {\n\n                    if (dist[next_vertex] != -1) {\n                        continue;\n                    }\n\n                    dist[next_vertex] = dist[vertex] + 1;\n                    que.push(next_vertex);\n                }\n            }\n\n            auto pt = max_element(dist.begin(), dist.end());\n            int sx2 = pt - dist.begin();\n\n            vector<int> dist2(n, -1);\n            dist2[sx2] = 0;\n\n            while (!que.empty()) {\n                que.pop();\n            }\n\n            que.push(sx2);\n\n            while (!que.empty()) {\n\n                int vertex = que.front();\n                que.pop();\n\n                for (int next_vertex : graph[vertex]) {\n\n                    if (dist2[next_vertex] != -1) {\n                        continue;\n                    }\n\n                    dist2[next_vertex] = dist2[vertex] + 1;\n                    que.push(next_vertex);\n                }\n            }\n\n            auto pt2 = max_element(dist2.begin(), dist2.end());\n\n            return {*pt, *pt2};\n        };\n\n\n        pair<int, int> res1 = d(edges1);\n        pair<int, int> res2 = d(edges2);\n        int ans = res1.first + res2.first + 1;\n        ans = max(ans, res1.second);\n        ans = max(ans, res2.second);\n\n        return ans;\n    }\n};",
    "submit_ts": "1719719943",
    "subm_id": "1304454672"
}