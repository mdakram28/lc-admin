{
    "username": "piyusus",
    "submission": "class DisjointSet {\n        public:\n\n    vector<int> rank, parent, sizee;\n    DisjointSet(int n) {\n        rank.resize(n + 1, 0);\n        parent.resize(n + 1);\n        sizee.resize(n + 1);\n        for (int i = 0; i <= n; i++) {\n            parent[i] = i;\n            sizee[i] = 1;\n        }\n    }\n\n    int findUPar(int node) {\n        if (node == parent[node])\n            return node;\n        return parent[node] = findUPar(parent[node]);\n    }\n\n    void unionByRank(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (rank[ulp_u] < rank[ulp_v]) {\n            parent[ulp_u] = ulp_v;\n        }\n        else if (rank[ulp_v] < rank[ulp_u]) {\n            parent[ulp_v] = ulp_u;\n        }\n        else {\n            parent[ulp_v] = ulp_u;\n            rank[ulp_u]++;\n        }\n    }\n\n    void unionBySize(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (sizee[ulp_u] < sizee[ulp_v]) {\n            parent[ulp_u] = ulp_v;\n            sizee[ulp_v] += sizee[ulp_u];\n        }\n        else {\n            parent[ulp_v] = ulp_u;\n            sizee[ulp_u] += sizee[ulp_v];\n        }\n    }\n\n    int sizeOfComponent(int ult_p){\n        return sizee[ult_p];\n    }\n\n    vector<int> askSize(){\n        return sizee;\n    }\n\n    vector<int> askParent(){\n        return parent;\n    }\n\n};\nclass SegmentTree {\npublic:\n    SegmentTree(int n):n(n) {\n        tree.resize(4*n,0);\n    }\n    void update(int idx, int value) {\n        update(0,0,n-1,idx,value);\n    }\n    int query(int left, int right) {\n        return query(0,0,n-1,left,right);\n    }\nprivate:\n    int n;\n    vector<int> tree;\n    void update(int node, int start, int end, int idx, int value) {\n        if(start==end)tree[node]=value;\n        else {\n            int mid = (start + end) / 2;\n            if(idx<=mid) {\n                update(2*node+1,start,mid,idx,value);\n            }\n            else{\n                update(2*node+2,mid+1,end,idx,value);\n            }\n            tree[node]=max(tree[2*node+1],tree[2*node+2]);\n        }\n    }\n\n    int query(int node, int start, int end, int left, int right) {\n        if (right<start||end<left)return 0;\n        if (left<=start&&end<=right)return tree[node];\n        int mid=(start+end)/2;\n        return max(query(2*node+1,start,mid,left,right),\n                   query(2*node+2,mid+1,end,left,right));\n    }\n};\n\nclass Solution {\npublic:\nusing ll                               = long long;\nusing lld                              = long double;\nusing ull                              = unsigned long long;\nusing sg                               = string;\n \n//Constants\nconst lld                              pi= 3.141592653589793238;\n//const                                INF= LONG_LONG_MAX;\nconst ll                               M=1e9+7;\n \n//TypeDEf\ntypedef                                 pair<ll,ll> pll;\ntypedef                                 vector<ll> vll;\ntypedef                                 vector<pll> vpll;\ntypedef                                 vector<string> vss;\ntypedef                                 vector<char> vcc;\ntypedef                                 unordered_map<ll,ll> umll;\ntypedef                                 map<ll,ll> mll;\ntypedef                                 vector<int> vii;\ntypedef                                 vector<bool> vbb;\ntypedef                                 set<ll> sll;\n \n \n \n// Macros\n#define ff                               first\n#define ss                               second\n#define pb                               push_back\n#define pbb                              pop_back\n#define mp                               make_pair\n#define fl(i,n)                          for(int i=0;i<n;i++)\n#define rl(i,m,n)                        for(int i=n;i>=m;i--)\n#define haa                              cout<<\"YES\\n\";\n#define m1                               cout<<\"-1\\n\";\n#define ipl(n)                           ll n;cin>>n;\n#define ips(n)                           string n;cin>>n;\n#define nahi                             cout<<\"NO\\n\";\n#define flp(i,a,b)                       for(int i = a; i <= b; i++)\n#define all(v)                           v.begin(),v.end()\n#define rall(v)                          v.end(),v.begin()\n\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& q){\n         vector<int>okked(n);vector<int>r;set<int> p;\n        flp(i,1,n-1)okked[i]=okked[i-1]+1;\n        fl(i,n)p.insert(i);\n        // SegmentTree segTree(n);\n    // vector<int>ans;\n    // for(int i=0;i<n-1;i++)segTree.update(i,i+1);\n\n    // for(auto& it:q) {\n    //     int u=it[0],v=it[1];\n    //     segTree.update(u,max(segTree.query(u,u),v));\n    //     int cur=0,steps=0;\n    //     while(cur<n-1) {\n    //         cur=segTree.query(cur, cur);\n    //         steps++;\n    //     }\n    //     ans.push_back(steps);\n    // }\n    // return ans;\n        int flag=0;\n        for (auto&qi:q) {\n            // for(autoi t:r){\n            //     cout<<it<<\" \";\n            // }\n            int it1=qi[0];\n            int it2=qi[1];\n            int temp=1,res=1;\n            p.erase(p.lower_bound(it1+(2-1)),p.lower_bound(it2));\n            // cout<<*p.begin();  \n            int qq=p.size();\n            r.pb(qq- 1);\n            temp++;\n            //\n    //         for(auto& it:q) {\n    //     int u=it[0],v=it[1];\n    //     segTree.update(u,max(segTree.query(u,u),v));\n    //     int cur=0,steps=0;\n    //     while(cur<n-1) {\n    //         cur=segTree.query(cur, cur);\n    //         steps++;\n    //     }\n    //     ans.push_back(steps);\n    // }\n    // return ans;\n            //\n            res--;\n            flag++;\n        }\n        if(flag<0)return {};\n        return r;\n    }\n};",
    "submit_ts": "1722743999",
    "subm_id": "1343804854"
}