{
    "username": "atm314",
    "submission": "using i8 = int8_t;\nusing u8 = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\n\nusing f32 = float;\nusing f64 = double;\n\n#define all(x) (x).begin(), (x).end()\n#define ll long long int\n#define VI vector<ll>\n#define VVI vector<VI>\n\n#define ISD true\n#define debug(x) \\\n    if (ISD)     \\\n    cout << #x << \": \" << x << endl\n#define DEBUG(x) cout << #x << \": \" << x << endl\n\ntemplate <typename C>\ni64 SIZE(const C &c)\n{\n    return static_cast<i64>(c.size());\n}\n\ntemplate <typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\ntemplate <typename T, typename U, typename Comp = less<>>\nbool chmax(T &xmax, const U &x, Comp comp = {})\n{\n    if (comp(xmax, x))\n    {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T, typename U, typename Comp = less<>>\nbool chmin(T &xmin, const U &x, Comp comp = {})\n{\n    if (comp(x, xmin))\n    {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x, y) CPP_CAT_I(x, y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x, y) x##y\n\n#define ASSERT(expr...) assert((expr))\n\n// }}}\n\nconstexpr i64 INF = 1'010'000'000'000'000'017LL;\n\nconstexpr i64 MOD = 998244353LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n#define M5 100007\n#define M9 1000000000\n\n#define F first\n#define S second\n\n// util {{{\n#define FOR(i, start, end) for (i64 i = (start), CPP_CAT(i, xxxx_end) = (end); i < CPP_CAT(i, xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n/// @brief Union-Find \u6728\n/// @note 1.1 \u30b7\u30f3\u30d7\u30eb\u306a\u5b9f\u88c5\n/// @see https://zenn.dev/reputeless/books/standard-cpp-for-competitive-programming/viewer/union-find\nclass UnionFind\n{\npublic:\n    UnionFind() = default;\n\n    /// @brief Union-Find \u6728\u3092\u69cb\u7bc9\u3057\u307e\u3059\u3002\n    /// @param n \u8981\u7d20\u6570\n    explicit UnionFind(size_t n)\n        : m_parents(n)\n    {\n        std::iota(m_parents.begin(), m_parents.end(), 0);\n    }\n\n    /// @brief \u9802\u70b9 i \u306e root \u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u8fd4\u3057\u307e\u3059\u3002\n    /// @param i \u8abf\u3079\u308b\u9802\u70b9\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n    /// @return \u9802\u70b9 i \u306e root \u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n    int find(int i)\n    {\n        if (m_parents[i] == i)\n        {\n            return i;\n        }\n\n        // \u7d4c\u8def\u5727\u7e2e\n        return (m_parents[i] = find(m_parents[i]));\n    }\n\n    /// @brief a \u306e\u30b0\u30eb\u30fc\u30d7\u3068 b \u306e\u30b0\u30eb\u30fc\u30d7\u3092\u7d71\u5408\u3057\u307e\u3059\u3002\n    /// @param a \u4e00\u65b9\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n    /// @param b \u4ed6\u65b9\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n    void merge(int a, int b)\n    {\n        a = find(a);\n        b = find(b);\n\n        if (a != b)\n        {\n            m_parents[b] = a;\n        }\n    }\n\n    /// @brief a \u3068 b \u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u304b\u3092\u8fd4\u3057\u307e\u3059\u3002\n    /// @param a \u4e00\u65b9\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n    /// @param b \u4ed6\u65b9\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n    /// @return a \u3068 b \u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u5834\u5408 true, \u305d\u308c\u4ee5\u5916\u306e\u5834\u5408\u306f false\n    bool connected(int a, int b)\n    {\n        return (find(a) == find(b));\n    }\n\nprivate:\n    // m_parents[i] \u306f i \u306e \u89aa,\n    // root \u306e\u5834\u5408\u306f\u81ea\u8eab\u304c\u89aa\n    std::vector<int> m_parents;\n};\n\nclass Solution\n{\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>> &circles)\n    {\n        int N = circles.size();\n        UnionFind uf(N + 2);\n        REP(i, N)\n        {\n            ll lx = circles[i][0] - circles[i][2];\n            ll rx = circles[i][0] + circles[i][2];\n            ll ly = circles[i][1] - circles[i][2];\n            ll ry = circles[i][1] + circles[i][2];\n            if (lx <= 0 || ry >= Y)\n                uf.merge(0, i + 1);\n            if (rx >= X || ly <= 0)\n                uf.merge(N + 1, i + 1);\n        }\n\n        REP(i, N - 1)\n        {\n            FOR(j, i + 1, N)\n            {\n                ll x = circles[j][0] - circles[i][0];\n                ll y = circles[j][1] - circles[i][1];\n                ll r = circles[j][2] + circles[i][2];\n                if (x * x + y * y <= r * r)\n                {\n                    uf.merge(i + 1, j + 1);\n                }\n            }\n        }\n        return !uf.connected(0, N + 1);\n    }\n};",
    "submit_ts": "1722137243",
    "subm_id": "1335758220"
}