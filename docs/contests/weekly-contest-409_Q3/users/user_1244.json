{
    "username": "utpalraj2003",
    "submission": "#include <vector>\n#include <set>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        int dist = n - 1;  // Initial shortest path from 0 to n-1\n        vector<int> answer;\n        \n        // Set to keep track of active segments\n        set<pair<int, int>> activeSegments;\n        for (int i = 0; i < n - 1; ++i) {\n            activeSegments.emplace(i, i + 1);\n        }\n        \n        for (const auto& query : queries) {\n            int ui = query[0];\n            int vi = query[1];\n            \n            // Calculate the number of segments in the range [ui, vi]\n            int countInRange = 0;\n            vector<pair<int, int>> segmentsToRemove;\n            \n            for (auto it = activeSegments.lower_bound({ui, ui + 1}); it != activeSegments.end() && it->first < vi; ++it) {\n                if (it->first >= ui && it->second <= vi) {\n                    ++countInRange;\n                    segmentsToRemove.push_back(*it);\n                }\n            }\n            \n            // Update the shortest path length only if the new query actually covers new ground\n            if (countInRange > 0) {\n                dist = dist - countInRange + 1;\n\n                // Remove the segments that are covered by the new road\n                for (const auto& segment : segmentsToRemove) {\n                    activeSegments.erase(segment);\n                }\n\n                // Add the new segment\n                activeSegments.emplace(ui, vi);\n            }\n            \n            // Store the result\n            answer.push_back(dist);\n        }\n        \n        return answer;\n    }\n};",
    "submit_ts": "1722743863",
    "subm_id": "1343801368"
}