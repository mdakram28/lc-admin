{
    "username": "g0rez",
    "submission": "class Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        SegmentTree segTree(nums);\n        vector<int> answer;\n        \n        for (auto& query : queries) {\n            if (query[0] == 1) {\n                int li = query[1];\n                int ri = query[2];\n                if (li + 1 < ri) {\n                    answer.push_back(segTree.query(li + 1, ri - 1));\n                } else {\n                    answer.push_back(0);\n                }\n            } else if (query[0] == 2) {\n                int indexi = query[1];\n                int vali = query[2];\n                segTree.update(indexi, vali);\n            }\n        }\n        \n        return answer;\n    }\n    \nprivate:\n    class SegmentTree {\n    private:\n        vector<int> tree;\n        vector<int> nums;\n        int n;\n        \n        bool isPeak(int idx) {\n            if (idx <= 0 || idx >= n - 1) return false;\n            return nums[idx] > nums[idx - 1] && nums[idx] > nums[idx + 1];\n        }\n        \n        void build(int node, int start, int end) {\n            if (start == end) {\n                tree[node] = isPeak(start) ? 1 : 0;\n            } else {\n                int mid = (start + end) / 2;\n                build(2 * node, start, mid);\n                build(2 * node + 1, mid + 1, end);\n                tree[node] = tree[2 * node] + tree[2 * node + 1];\n            }\n        }\n        \n        void updateRange(int node, int start, int end, int idx) {\n            if (start == end) {\n                tree[node] = isPeak(start) ? 1 : 0;\n            } else {\n                int mid = (start + end) / 2;\n                if (start <= idx && idx <= mid) {\n                    updateRange(2 * node, start, mid, idx);\n                } else {\n                    updateRange(2 * node + 1, mid + 1, end, idx);\n                }\n                tree[node] = tree[2 * node] + tree[2 * node + 1];\n            }\n        }\n        \n        int queryRange(int node, int start, int end, int l, int r) {\n            if (r < start || end < l) {\n                return 0;\n            }\n            if (l <= start && end <= r) {\n                return tree[node];\n            }\n            int mid = (start + end) / 2;\n            int leftQuery = queryRange(2 * node, start, mid, l, r);\n            int rightQuery = queryRange(2 * node + 1, mid + 1, end, l, r);\n            return leftQuery + rightQuery;\n        }\n        \n    public:\n        SegmentTree(vector<int>& arr) {\n            nums = arr;\n            n = nums.size();\n            tree.resize(4 * n, 0);\n            build(1, 0, n - 1);\n        }\n        \n        void update(int index, int newVal) {\n            nums[index] = newVal;\n            if (index > 0) updateRange(1, 0, n - 1, index - 1);\n            updateRange(1, 0, n - 1, index);\n            if (index < n - 1) updateRange(1, 0, n - 1, index + 1);\n        }\n        \n        int query(int l, int r) {\n            return queryRange(1, 0, n - 1, l, r);\n        }\n    };\n};\n",
    "submit_ts": "1718506924",
    "subm_id": "539778137"
}