{
    "username": "john0312acc223",
    "submission": "class Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        map<int, int> blocks;\n        blocks[0] = 0x0FFFFFFF;\n\n        for (const auto& q : queries) {\n            if (q[0] == 1) {\n                assert(q.size() == 2);\n                int loc = q[1];\n                assert(blocks.count(loc) == 0);\n                auto last_itr = blocks.lower_bound(loc);\n                assert(last_itr != blocks.begin());\n                last_itr--;\n\n                int last_pos = last_itr->first;\n                int last_size = last_itr->second;\n\n                int first_size = loc - last_pos;\n                int second_size = last_size - first_size;\n                assert(first_size > 0);\n                assert(second_size > 0);\n                blocks.erase(last_itr);\n                blocks[last_pos] = first_size;\n                blocks[loc] = second_size;\n            }\n        }\n\n        map<int, int> block_stack; // x -> size, increasing x results in increasing size\n        auto add_block = [&block_stack] (int end, int size) {\n            while (true) {\n                auto itr1 = block_stack.lower_bound(end);\n                if (itr1 == block_stack.end()) {\n                    if (block_stack.size() == 0) {\n                        block_stack[end] = size;\n                    } else {\n                        itr1--;\n                        if (size > itr1->second) {\n                            block_stack[end] = size;\n                        }\n                    }\n                    return;\n                }\n                if (itr1 == block_stack.begin()) {\n                    while (true) {\n                        auto itr_start = block_stack.begin();\n                        if (itr_start->second <= size) {\n                            block_stack.erase(itr_start);\n                        } else{\n                            break;\n                        }\n                    }\n                    block_stack[end] = size;\n                    return;\n                }\n                \n                auto prev_itr = itr1;\n                prev_itr--;\n                if (prev_itr->second >= size) {\n                    // No need.\n                    return;\n                }\n\n                auto itr2 = itr1;\n                if (itr2->second <= size) {\n                    block_stack.erase(itr2);\n                    continue;\n                }\n                block_stack[end] = size;\n                break;\n            }\n        };\n\n        for (auto itr1 = blocks.begin(); itr1 != blocks.end(); itr1++) {\n            add_block(itr1->first+itr1->second, itr1->second);\n        }\n\n        vector<bool> res;\n        for (int i = queries.size()-1; i >= 0; i--) {\n            const auto& q = queries[i]; \n            if (q[0] == 1) {\n                // Reverse merge the block.\n                int loc = q[1];\n                auto itr2 = blocks.find(loc);\n                assert(itr2 != blocks.end());\n                assert(itr2 != blocks.begin());\n                auto prev_itr = itr2;\n                prev_itr--;\n\n                int prev_loc = prev_itr->first;\n                int prev_size = prev_itr->second;\n                int curr_loc = itr2->first;\n                int curr_size = itr2->second;\n\n                blocks.erase(itr2);\n                blocks[prev_loc] = prev_size + curr_size;\n                add_block(prev_loc+prev_size+curr_size, prev_size+curr_size);\n            } else if (q[0] == 2) {\n                assert(q.size() == 3);\n                int loc = q[1];\n                int sz = q[2];\n\n                auto itr3 = block_stack.upper_bound(loc);\n                bool found = false;\n                if (itr3 != block_stack.begin()) {\n                    auto itr4 = itr3;\n                    itr4--;\n                    if (itr4->second >= sz) found = true;\n                }\n\n                // Check if current block is OK.\n                auto curr_block = blocks.lower_bound(loc);\n                assert(curr_block != blocks.begin());\n                curr_block--;\n                assert(loc>= curr_block->first);\n                if (loc-curr_block->first >= sz) {\n                    found = true;\n                }\n\n                res.push_back(found);\n            }\n        }\n        std::reverse(res.begin(), res.end());\n        return res;\n    }\n};",
    "submit_ts": 1716651835.0
}