{
    "username": "hayasaka-ai",
    "submission": "template<class Operation, class Mark>\nstruct SegTree{\n    const int n;\n    vector<Operation> op;\n    vector<Mark> mrk;\n \n    SegTree(int n) : n(n), op(4 << __lg(n)), mrk(4 << __lg(n)) {\n        function<void(int, int, int)> build = [&](int u, int l, int r){\n            op[u] = Operation();\n            if(l == r) return;\n            int mid = l + r >> 1;\n            build(u << 1, l, mid);\n            build(u << 1 | 1, mid + 1, r);\n            pushup(u);\n        };\n \n        build(1, 1, n);\n    }\n \n    void pushup(int u){\n        op[u] = op[u << 1] + op[u << 1 | 1];\n    }\n \n    void modify(int u, const Mark &mk){\n        // op[u].modify(mk);\n        // mrk[u].modify(mk);\n    }\n \n    void pushdown(int u) {\n        modify(u << 1, mrk[u]);\n        modify(u << 1 | 1, mrk[u]);\n        mrk[u] = Mark();\n    }\n \n    void update(int u, int l, int r, int x, const Operation &v) {\n        if(l == r){\n            op[u] = v;\n            return;\n        }\n        int m = (l + r) >> 1;\n//         pushdown(u);\n \n        if(x <= m){\n            update(u << 1, l, m, x, v);\n        } \n        else{\n            update(u << 1 | 1, m + 1, r, x, v);\n        }\n        pushup(u);\n    }\n \n    void update(int u, const Operation &v) {\n        update(1, 1, n, u, v);\n    }\n \n    Operation query(int u, int l, int r, int x, int y) {\n        if(x <= l && r <= y){\n            return op[u];\n        }\n        \n        int m = (l + r) >> 1;\n        Operation cur;\n        // pushdown(u);\n        if(x <= m){\n            cur = query(u << 1, l, m, x, y);\n        }\n        if(y > m){\n            cur = cur + query(u << 1 | 1, m + 1, r, x, y);\n        }\n       \n        return cur;\n    }\n \n    Operation query(int l, int r) {\n        return query(1, 1, n, l, r);\n    }\n \n    void range_update(int u, int l, int r, int x, int y, const Mark &v) {\n        if(l >= x && r <= y){\n            modify(u, v);\n            return;\n        }\n \n        int m = (l + r) >> 1;\n        // pushdown(u);\n        if(x <= m){\n            range_update(u << 1, l, m, x, y, v);\n        }\n        if(y > m){\n            range_update(u << 1 | 1, m + 1, r, x, y, v);\n        }\n        pushup(u);\n    }\n \n    void range_update(int l, int r, const Mark &v) {\n        return range_update(1, 1, n, l, r, v);\n    }\n};\n \nstruct Mark{\n    void modify(const Mark &v){\n\n    }\n};\n \nstruct Operation {\n    int opr = -1;   \n    Operation(int p = -1){\n        opr = p;\n    }\n    \n    void modify(const Mark &v){\n\n    }\n};\n \nOperation operator+(Operation a, Operation b) {\n    if(a.opr == -1) return b;\n    return {a.opr & b.opr};\n}\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        int n = nums.size();\n        \n        SegTree<Operation, Mark> tr(n + 1);\n        \n        for(int i = 1; i <= n; i++){\n            tr.update(i, {nums[i - 1]});\n        }\n        \n        auto p = tr.query(2, 2);\n        cout << p.opr << endl;\n        \n        long long qwq = 0;\n        for(int i = 0; i < n; i++){\n            int l = i, r = n;\n            while(l < r){\n                int mid = l + r >> 1;\n                if(tr.query(i + 1, mid + 1).opr <= k) r = mid;\n                else l = mid + 1;\n            }\n            qwq -= l;\n            \n            l = i, r = n;\n            while(l < r){\n                int mid = l + r >> 1;\n                if(tr.query(i + 1, mid + 1).opr < k) r = mid;\n                else l = mid + 1;\n            }\n            qwq += l; \n        }\n        return qwq;\n    }\n};",
    "submit_ts": "1720279103",
    "subm_id": "544565961"
}