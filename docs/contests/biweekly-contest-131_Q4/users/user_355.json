{
    "username": "code_everywhere",
    "submission": "class SegmentTree {\nprivate:\n    std::vector<int> tree;\n    int n;\n\n    // Function to build the segment tree\n    void build(const std::vector<int>& data, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = data[start];\n        } else {\n            int mid = (start + end) / 2;\n            int left_child = 2 * node + 1;\n            int right_child = 2 * node + 2;\n            build(data, left_child, start, mid);\n            build(data, right_child, mid + 1, end);\n            tree[node] = std::max(tree[left_child], tree[right_child]);\n        }\n    }\n\n    // Function to perform point update\n    void update(int node, int start, int end, int idx, int value) {\n        if (start == end) {\n            tree[node] = value;\n        } else {\n            int mid = (start + end) / 2;\n            int left_child = 2 * node + 1;\n            int right_child = 2 * node + 2;\n            if (start <= idx && idx <= mid) {\n                update(left_child, start, mid, idx, value);\n            } else {\n                update(right_child, mid + 1, end, idx, value);\n            }\n            tree[node] = std::max(tree[left_child], tree[right_child]);\n        }\n    }\n\n    // Function to query the maximum in a range\n    int query(int node, int start, int end, int L, int R) {\n        if (R < start || end < L) {\n            return INT_MIN;\n        }\n        if (L <= start && end <= R) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int left_child = 2 * node + 1;\n        int right_child = 2 * node + 2;\n        int left_query = query(left_child, start, mid, L, R);\n        int right_query = query(right_child, mid + 1, end, L, R);\n        return std::max(left_query, right_query);\n    }\n\npublic:\n    SegmentTree(const std::vector<int>& data) {\n        n = data.size();\n        tree.resize(4 * n);\n        build(data, 0, 0, n - 1);\n    }\n\n    void update(int idx, int value) {\n        update(0, 0, n - 1, idx, value);\n    }\n\n    int query(int L, int R) {\n        return query(0, 0, n - 1, L, R);\n    }\n};\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        set<int> obs;\n        obs.insert(0);\n        vector<int> v(50001,0);\n        SegmentTree st(v);\n        vector<bool> ans;\n        for(auto it:queries){\n            if(it[0]==1){\n                obs.insert(it[1]);\n                auto ite = obs.lower_bound(it[1]);\n                auto next = ite;++next;\n                if(next != obs.end()){\n                    v[*next] = (*next-it[1]);\n                    st.update(*next,*next-it[1]);\n                }\n                if(ite!=obs.begin()){\n                    auto prev = ite;--prev;\n                    v[it[1]] = (it[1]-*prev);\n                    st.update(it[1],it[1]-*prev);\n                }\n                else {\n                    v[it[1]]=it[1];\n                    st.update(it[1],it[1]);\n                }\n            }\n            else{\n                int maxi = st.query(0,it[1]);\n                auto ite = obs.lower_bound(it[1]);\n                if(ite!=obs.begin()){\n                    auto prev = ite;--prev;\n                    maxi=max(maxi,it[1]-*prev);\n                }\n                ans.push_back(maxi>=it[2]);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716651424.0
}