{
    "username": "avinashyadav16",
    "submission": "class Solution {\npublic:\n    int bfs(vector<vector<int>> &graph, int start, int source, int desti, int totalNodes)\n    {\n        queue<int> q;\n        vector<int> visited(totalNodes + 4, 0);\n        q.push(start);\n        visited[start] = 1;\n\n        while (!q.empty())\n        {\n            int currentNode = q.front();\n            q.pop();\n\n            for (int neighbor : graph[currentNode])\n            {\n                if (!visited[neighbor])\n                {\n                    q.push(neighbor);\n                    visited[neighbor] = 1;\n                }\n            }\n        }\n\n        return visited[source] || visited[desti];\n    }\n\n    bool canReachCorner(int X, int Y, vector<vector<int>> &circles)\n    {\n        vector<pair<pair<int, int>, int>> circlevpp(circles.size());\n        vector<vector<int>> graph(circles.size() + 4);\n\n        int circleSize = circles.size();\n\n        for (int i = 0; i < circleSize; ++i)\n        {\n            circlevpp[i].first.first = circles[i][0];\n            circlevpp[i].first.second = circles[i][1];\n            circlevpp[i].second = circles[i][2];\n        }\n\n        for (int i = 0; i < circleSize; ++i)\n        {\n            if (circlevpp[i].first.first <= circlevpp[i].second)\n            {\n                graph[circleSize].push_back(i);\n                graph[i].push_back(circleSize);\n            }\n\n            if (X - circlevpp[i].first.first <= circlevpp[i].second)\n            {\n                graph[circleSize + 2].push_back(i);\n                graph[i].push_back(circleSize + 2);\n            }\n\n            if (circlevpp[i].first.second <= circlevpp[i].second)\n            {\n                graph[circleSize + 1].push_back(i);\n                graph[i].push_back(circleSize + 1);\n            }\n\n            if (Y - circlevpp[i].first.second <= circlevpp[i].second)\n            {\n                graph[circleSize + 3].push_back(i);\n                graph[i].push_back(circleSize + 3);\n            }\n\n            for (int j = i + 1; j < circleSize; ++j)\n            {\n                double distance = sqrt(pow(circlevpp[i].first.first - circlevpp[j].first.first, 2) +\n                                       pow(circlevpp[i].first.second - circlevpp[j].first.second, 2));\n                int radiusSum = circlevpp[i].second + circlevpp[j].second;\n                if (radiusSum >= distance)\n                {\n                    graph[i].push_back(j);\n                    graph[j].push_back(i);\n                }\n            }\n        }\n\n        int notPresent = 0;\n\n        notPresent = max(notPresent, bfs(graph, circleSize, circleSize + 1, circleSize + 2, circleSize + 4));\n        notPresent = max(notPresent, bfs(graph, circleSize + 3, circleSize + 2, circleSize + 1, circleSize + 4));\n\n        if (notPresent)\n        {\n            return false;\n        }\n        \n        return true;\n    }\n};\n",
    "submit_ts": "1722136934",
    "subm_id": "1335749261"
}