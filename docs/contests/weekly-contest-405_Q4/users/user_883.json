{
    "username": "RubiksProgrammer",
    "submission": "class Solution {\npublic:\n    vector<int> computeLPSArray(const string &pattern) {\n    int m = pattern.length();\n    vector<int> lps(m, 0);\n    int length = 0;\n    int i = 1;\n\n    while (i < m) {\n        if (pattern[i] == pattern[length]) {\n            length++;\n            lps[i] = length;\n            i++;\n        } else {\n            if (length != 0) {\n                length = lps[length - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n\n    return lps;\n}\n\nvector<int> KMPSearch(const string &text, const string &pattern) {\n    int n = text.length();\n    int m = pattern.length();\n    vector<int> lps = computeLPSArray(pattern);\n    vector<int> result;\n    int i = 0;\n    int j = 0;\n\n    while (i < n) {\n        if (pattern[j] == text[i]) {\n            i++;\n            j++;\n        }\n\n        if (j == m) {\n            result.push_back(i - j);\n            j = lps[j - 1];\n        } else if (i < n && pattern[j] != text[i]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n\n    return result;\n}\n    \n    int inf = 1e9;\n    vector<int> memo;\n    \n    int rec(int i, const string& target, const vector<string>& words, const vector<int>& costs, const vector<vector<int>>& b) {\n        \n        \n        if(i>= target.length()) return 0;\n        \n        // go through every option for current index, take one which is min\n        int &ans = memo[i];\n        if(ans != -1) return ans;\n        ans = inf;\n        for(int j: b[i]) {\n            ans = min(ans,costs[j] + rec(i + words[j].length(), target, words, costs, b));\n        }\n        return ans;\n        \n    }\n    \n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        \n        vector<int> newc;\n        vector<string> neww;\n        \n        unordered_map<string, int> m;\n        for(int i = 0;i < words.size(); i++) {\n            if(!m.count(words[i])) {\n                m[words[i]] = costs[i];\n            }else {\n                m[words[i]] = min(m[words[i]], costs[i]);\n            }\n        }\n        \n        for(auto &[k, v]: m) {\n            neww.push_back(k);\n            newc.push_back(v);\n        }\n        \n        int n = target.length();\n        vector<vector<int>> b(n);\n        \n        memo.resize(n, -1);\n        for(int i = 0; i < neww.size(); i++) {\n            vector<int> t = KMPSearch(target, neww[i]);\n            for(int j:t) {\n                b[j].push_back(i);   \n            }\n        }\n        \n        int ans = rec(0, target, neww, newc, b);\n        return ans >= inf ? -1 : ans;\n        \n        \n    }\n};",
    "submit_ts": "1720323028",
    "subm_id": "1312365473"
}