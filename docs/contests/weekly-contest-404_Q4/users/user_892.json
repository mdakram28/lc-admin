{
    "username": "Zellon",
    "submission": "class Solution {\npublic:\n    int bfs(int start, const vector<vector<int>>& edges, vector<int>& dist) {\n        queue<pair<int, int>> Q;\n        Q.push(make_pair(start, 0));\n        dist[start] = 0;\n        while (!Q.empty()) {\n            auto [cur, d] = Q.front();\n            Q.pop();\n            for (const auto nxt: edges[cur]) {\n                if (dist[nxt] == -1) {\n                    dist[nxt] = d + 1;\n                    Q.push(make_pair(nxt, d + 1));\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < edges.size(); ++i) {\n            if (dist[i] > dist[res]) {\n                res = i;\n            }\n        }\n        return res;\n    }\n    \n    int max_res = 0;\n    \n    int find_smallest_longest_dist(const vector<vector<int>>& edge_pairs) {\n        int n = -1;\n        for (const auto & e: edge_pairs) {\n            n = max(n, max(e[0], e[1]));\n        }\n        if (n == -1) return 0;\n        n++;\n        vector<vector<int>> edges(n);\n        for (const auto & e: edge_pairs) {\n            edges[e[0]].push_back(e[1]);\n            edges[e[1]].push_back(e[0]);\n        }\n        \n        vector<int> dist(n, -1);\n        int end1 = bfs(0, edges, dist);\n\n        vector<int> dist1(n, -1);\n        int end2 = bfs(end1, edges, dist1);\n        vector<int> dist2(n, -1);\n        bfs(end2, edges, dist2);\n        int res = 1<<20;\n        for (int i = 0; i < n; ++i) {\n            dist[i] = max(dist1[i], dist2[i]);\n            max_res = max(dist[i], max_res);\n            res = min(res, dist[i]);\n        }\n        return res;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int d1 = find_smallest_longest_dist(edges1);\n        int d2 = find_smallest_longest_dist(edges2);\n        return max(max_res, d1 + d2 + 1);\n    }\n};",
    "submit_ts": "1719719948",
    "subm_id": "1304454807"
}