{
    "username": "unknown_ajay",
    "submission": "#define dbg(v) for(auto it:v) cout<<it<<\" \"; cout<<\"\\n\";\n\nclass node\n{\n    \npublic:\n    int sum;\n    int mx;\n    int mn;\n    node(int x,int y,int z) : sum(x),mx(y),mn(z) {}\n    \n    node() {\n        sum = 0;\n        mx = INT_MIN;\n        mn = INT_MAX;\n    }\n};\n\nnode mergelogic(node &a,node &b)\n{\n    node ans;\n    ans.mx = max(a.mx , b.mx);\n    ans.mn = min(a.mn , b.mn);\n    ans.sum = a.sum + b.sum;\n    return ans;\n}\n\nnode neutral;\n\nclass SegmentTree\n{\n    \npublic:\n    int size;\n    vector< node > tree;\n    vector<int> v;\n    \n    SegmentTree(int _size,vector<int> _v) : size(_size) {\n        tree.resize(4*_size);\n        v = _v;\n    };\n    \n    node base(int idx) {\n        return node(v[idx],v[idx],v[idx]);\n    }\n    \n    void build(int cur,int l,int r)\n    {\n        if(l==r)\n        {\n            tree[cur] = base(l);\n            return;\n        }\n        \n        int mid = (l+r)/2;\n        build(2*cur,    l     , mid);\n        build(2*cur+1 , mid+1 , r  );\n        tree[cur] = mergelogic( tree[2*cur] , tree[2*cur+1] );\n    }\n    \n    void update(int cur,int l,int r,int idx,int delta)\n    {\n        /* no intersection */\n        if( idx<l || idx>r ) return;\n        \n        /* l==r==idx */\n        if( l==idx && r==idx )\n        {\n            updateNode(cur,delta);\n            return;\n        }\n        int mid = (l+r)/2;\n        update(2*cur,    l     , mid, idx , delta);\n        update(2*cur+1 , mid+1 , r  , idx , delta);\n        tree[cur] = mergelogic( tree[2*cur] , tree[2*cur+1] );\n    }\n    \n    node query(int cur,int l,int r,int lq,int rq)\n    {\n        /* no intersection */\n        if( rq<l || lq > r ) {\n            return neutral;\n        }\n        \n        /* query range ke andar */\n        if( lq<=l && r<=rq ) return tree[cur];\n        \n        int mid = (l+r)/2;\n        node lft = query(2*cur, l, mid, lq, rq);\n        node rgt = query(2*cur+1, mid+1, r, lq, rq);\n        node ans = mergelogic( lft,rgt);\n        return ans;\n        \n    }\n    \n    void updateNode(int cur,int val)        // Depends on how to modify\n    {\n        tree[cur].sum = val;\n    }\n    \n};\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& v, vector<vector<int>>& q)\n    {\n        int n = (int)v.size();\n        \n        vector<int> op(n,0);\n        \n        for(int i=1;i<n-1;i++)\n        {\n            if( v[i] > v[i-1] && v[i] > v[i+1] ) op[i] = 1;\n        }\n        \n        SegmentTree st(n, op);\n\n        int cur = 1; // resposible for 0 to n-1\n        int resl = 0 , resr = n-1;\n\n        st.build(cur,resl,resr);\n        \n        vector<int> ans;\n        for(auto it:q)\n        {\n            int type = it[0] , l = it[1] , r = it[2];\n            \n            if(type == 1)\n            {\n                if( l == r )\n                {\n                    ans.push_back(0);\n                }else\n                {\n                    node ret = st.query(cur,resl,resr, l+1, r-1);\n                    ans.push_back(ret.sum);\n                }\n                \n            }else\n            {\n                int idx = l , val = r;\n                v[idx] = val;\n                \n                \n                vector<int> tobeChecked = { idx-1, idx  , idx+1 };\n                \n                for(auto i:tobeChecked)\n                {\n                    \n                    if( i-1 < 0 || i + 1 >= n ) continue;\n                    \n                    // update i\n                    if( v[i] > v[i-1] && v[i] > v[i+1] )\n                    {\n                        st.update(cur,resl,resr,i,1LL);\n                    }else st.update(cur,resl,resr,i,0LL);\n                    \n                }\n                \n            }\n        }\n        \n//        node ret = st.query(cur,resl,resr, l, r);\n//        st.update(cur,resl,resr, , );\n        // dbg(ans);\n        return ans;\n    }\n};\n",
    "submit_ts": 1718507104.0
}