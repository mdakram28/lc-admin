{
    "username": "admiring-matsumotomgs",
    "submission": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n// #define endl '\\n'\n#define len(x) ((int)((x).size()))\n#define all(x) (x).begin(),(x).end()\n#define PQ priority_queue\n\nusing ll = long long;\nusing ld = long double;\nusing i128 = __int128_t;\n\nconst array<int, 8> dx{0, -1, 0, 1, 1, 1, -1, -1};\nconst array<int, 8> dy{1, 0, -1, 0, 1, -1, 1, -1};\n\nstd::ostream &operator<<(std::ostream &os, i128 n) {\n    std::string s;\n    while (n) {\n        s += '0' + n % 10;\n        n /= 10;\n    }\n    std::reverse(s.begin(), s.end());\n    return os << s;\n}\ntemplate<class Info>\nstruct SegmentTree {\n    int n;\n    vector<Info> info;\n    SegmentTree(int n) : n(n), info(4 * n) {}\n    template <typename T>\n    SegmentTree(vector<T> init) : SegmentTree(init.size()) {\n        auto build = [&](auto build, int id, int l, int r) -> void {\n            if (r == l) {\n                info[id] = init[l];\n                return;\n            }\n            int m = l + r >> 1;\n            build(build, id << 1, l, m);\n            build(build, id << 1 | 1, m + 1, r);\n            pull(id);\n        };\n        build(build, 1, 0, n - 1);\n    }\n    void pull(int id) {\n        info[id] = info[id << 1] + info[id << 1 | 1];\n    }\n    void modify(int id, int l, int r, int p, const Info &v) {\n        if (r == l) {\n            info[id] += v;\n            return;\n        }\n        int m = l + r >> 1;\n        if (p <= m) {\n            modify(id << 1, l, m, p, v);\n        } else {\n            modify(id << 1 | 1, m + 1, r, p, v);\n        }\n        pull(id);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n - 1, p, v);\n    }\n    Info rangeQuery(int id, int l, int r, int ql, int qr) {\n        if (qr < l || r < ql) {\n            return Info();\n        }\n        if (ql <= l && r <= qr) {\n            return info[id];\n        }\n        int m = l + r >> 1;\n\n        return rangeQuery(id << 1, l, m, ql, qr) + rangeQuery(id << 1 | 1, m + 1, r, ql, qr);\n    }\n    Info rangeQuery(int ql, int qr) {\n        return rangeQuery(1, 0, n - 1, ql, qr);\n    }\n\n};\n\n//\u5b58\u653e\u8282\u70b9\u6570\u636e,\u6ce8\u610f\u521d\u59cb\u5316\nstruct Info {\n    int val = 0;\n    Info() {\n\n    }\n    Info(int x) {\n        val = x;\n    }\n};\n// \u76f8\u5f53\u4e8e\u4e24\u4e2a\u533a\u95f4\u7684\u5408\u5e76\nInfo operator+(Info a, Info b) {\n    return Info(a.val + b.val);\n}\n// \u5355\u70b9\u4fee\u6539\u7684\u903b\u8f91\nInfo &operator+=(Info &a, Info b) {\n    a = b;\n    return a;\n}\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& q) {\n        int M = len(q);\n        int N = len(a);\n        SegmentTree<Info> seg(N);\n        for (int i = 1; i < N - 1; i++) {\n            if (a[i] > max(a[i - 1], a[i + 1])) {\n                seg.modify(i, Info(1));\n            }\n        }\n        vector<int> ans;\n        for (int i = 0; i < M; i++) {\n            int op = q[i][0];\n            if (op == 1) {\n                int l = q[i][1];\n                int r = q[i][2];\n                ans.push_back(seg.rangeQuery(l+1, r-1).val);\n            } else {\n                int index = q[i][1];\n                int x = q[i][2];\n                a[index] = x;\n\n                for (int j = -1; j <= 1; j++) {\n                    if (index + j >= 0 && index + j < N) {\n                        int cur = index + j;\n                        if(cur+1<N&&cur-1>=0){\n                            if(a[cur]>max(a[cur-1],a[cur+1]))\n                            seg.modify(cur,Info(1));\n                            else seg.modify(cur,Info(0));\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718506053.0
}