{
    "username": "sansaryadav777",
    "submission": "class Solution {\npublic:\n    \n    void buildTree(vector<int> &arr, vector<int> &segTree) {\n        int n = arr.size();\n        for(int i = 0; i < n; i++) {\n            segTree[n + i] = arr[i];\n        }\n        for(int i = n - 1; i > 0; i--){\n            segTree[i] = segTree[2*i + 1] + segTree[2*i];\n        }\n    }\n    \n    void updateSegTree(vector<int>& segTree, int idx, int val) {\n        int n = segTree.size()/2;\n        segTree[idx + n] += val;\n        int temp = (idx + n)/2;\n        while(temp > 0) {\n            segTree[temp] = segTree[2*temp] + segTree[2*temp + 1];\n            temp /= 2;\n        }\n    }\n    \n    int findSum(vector<int>& segTree, int l, int r) {\n        int n = segTree.size()/2;\n        if(r - l < 0) {\n            return 0;\n        }\n        int ans = 0;\n        l += n; r +=n;\n        while(l <= r) {\n            if(l % 2) {\n                ans += segTree[l];\n                l++;\n            }\n            if(r%2 == 0) {\n                ans += segTree[r];\n                r--;\n            }\n            l /= 2; r /= 2;\n        }\n        return ans;\n    }\n    \n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> isPeak(n, 0);\n        for(int i = 1; i < n - 1; i++) {\n            if(nums[i] > nums[i + 1] && nums[i] > nums[i - 1]) {\n                isPeak[i] = 1;\n            }\n        }\n        \n        vector<int> segTree(2*n, 0);\n        buildTree(isPeak, segTree);\n        \n        vector<int> ans;\n        for(int i = 0; i < queries.size(); i++) {\n            if(queries[i][0] == 1) {\n                int l = queries[i][1] + 1, r = queries[i][2] - 1;\n                ans.push_back(findSum(segTree, l, r));\n            } else {\n                int idx = queries[i][1], val = queries[i][2];\n                nums[idx] = val;\n                for(int delta = -1; delta <= 1; delta++) {\n                    if(idx + delta > 0 && idx + delta < n - 1 && nums[idx + delta - 1] < nums[idx + delta] && nums[idx + delta + 1] < nums[idx + delta]) {\n                        if(isPeak[idx + delta] != 1) {\n                            isPeak[idx + delta] = 1;\n                            updateSegTree(segTree, idx + delta, 1);\n                        }\n                    } else {\n                        if(idx + delta > 0 && idx + delta < n - 1 && isPeak[idx + delta] != 0) {\n                            isPeak[idx + delta] = 0;\n                            updateSegTree(segTree, idx + delta, -1);\n                        }\n                    }\n                }\n            }\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": 1718508502.0
}