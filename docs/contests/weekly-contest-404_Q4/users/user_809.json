{
    "username": "rahulk84",
    "submission": "const int N=200005;\nclass Solution {\npublic:\n     vector<int> adj[200005];\npair<int, int> bfs(int n) {\n\tvector<int> vis(200005, 0);\n\tvis[n] = 1;\n\tqueue<pair<int, int>> q;\n\tq.push({n, 0});\n\tpair<int, int> u;\n\twhile (!q.empty()) {\n \n\t\tu = q.front();\n \n\t\tq.pop();\n\t\tfor (auto c : adj[u.first]) {\n\t\t\tif (vis[c] == 0) {\n\t\t\t\tvis[u.first] = 1;\n\t\t\t\tq.push({c, u.second + 1});\n\t\t\t}\n\t\t}\n\t}\n\treturn u;\n}\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int x=0,x1=0;\n        for(auto it:edges1){\n            adj[it[0]].push_back(it[1]);\n            adj[it[1]].push_back(it[0]);\n        }\n       \n        pair<int, int> end1 = bfs(0);\n\tpair<int, int> end2 = bfs(end1.first);\n\tx=end2.second;\n\n         for(int i=0;i<N;i++){\n            adj[i].clear();\n        }\n         for(auto it:edges2){\n            adj[it[0]].push_back(it[1]);\n            adj[it[1]].push_back(it[0]);\n        }\n        end1 = bfs(0);\n        end2 = bfs(end1.first);\n        x1=end2.second;\n        cout<<x<<\" \"<<x1<<endl;\n       \n        return max({((x+1)/2+(x1+1)/2+1),x,x1});\n    }\n};\n",
    "submit_ts": "1719719827",
    "subm_id": "1304451560"
}