{
    "username": "Conrad_123",
    "submission": "class Solution {\npublic:\n    \n    void Get_Path(std::vector<std::vector<int>>& graph,int target, int node,int parent, std::vector<int>& current, std::vector<int>& result){\n        \n        if(node == target){\n            result = current;\n            return;\n        }\n        \n        for(int i = 0; i < graph[node].size() && result.empty(); i++){\n            \n            if(graph[node][i] == parent) continue;\n            \n            current.push_back(graph[node][i]);\n            Get_Path(graph, target, graph[node][i], node, current, result);\n            current.pop_back();\n        }\n    }\n    \n    std::pair<int, int> Get_Farthest_Node_From_Root(std::vector<std::vector<int>>& graph, int root){\n        \n        std::queue<std::pair<int, int>> node_queue;\n        std::vector<bool> visited_nodes(graph.size(), false);\n        \n        int result = root;\n        int max_distance = 0;\n        visited_nodes[root] = true;\n        node_queue.push({root, 0});\n        \n        while(!node_queue.empty()){\n            \n            int node = node_queue.front().first;\n            int distance = node_queue.front().second;\n            node_queue.pop();\n            \n            if(distance > max_distance){\n                result = node;\n                max_distance = distance;\n            }\n            \n            for(int i = 0; i < graph[node].size(); i++){\n                \n                if(visited_nodes[graph[node][i]]) continue;\n                visited_nodes[graph[node][i]] = true;\n                node_queue.push({graph[node][i], distance + 1});\n            }\n        }\n        \n        return {result, max_distance};\n    }\n    \n    int minimumDiameterAfterMerge(std::vector<std::vector<int>>& edges1, std::vector<std::vector<int>>& edges2) {\n        \n        std::vector<std::vector<int>> graph_1(edges1.size() + 1);\n        std::vector<std::vector<int>> graph_2(edges2.size() + 1);\n        \n        for(int i = 0; i < edges1.size(); i++){\n            graph_1[edges1[i][0]].push_back(edges1[i][1]);\n            graph_1[edges1[i][1]].push_back(edges1[i][0]);\n        }\n        \n        for(int i = 0; i < edges2.size(); i++){\n            graph_2[edges2[i][0]].push_back(edges2[i][1]);\n            graph_2[edges2[i][1]].push_back(edges2[i][0]);\n        }\n        \n        std::pair<int, int> node_1 = Get_Farthest_Node_From_Root(graph_1, 0);\n        std::pair<int, int> node_2 = Get_Farthest_Node_From_Root(graph_2, 0);\n        \n        std::pair<int, int> farthest_node_1 = Get_Farthest_Node_From_Root(graph_1, node_1.first);\n        std::pair<int, int> farthest_node_2 = Get_Farthest_Node_From_Root(graph_2, node_2.first);\n        \n        int daimeter_1 = farthest_node_1.second;\n        int daimeter_2 = farthest_node_2.second;\n        std::vector<int> path_1;\n        std::vector<int> path_2;\n        std::vector<int> current;\n        \n        //Get_Path(graph_1, farthest_node_1.first, node_1.first, -1, current, path_1);\n        //Get_Path(graph_2, farthest_node_2.first, node_2.first, -1, current, path_2);\n        \n        int option = (daimeter_1+1)/2 + (daimeter_2+1)/2 + 1;\n        std::cout<<daimeter_1<<\" \"<<daimeter_2<<\" \"<<option<<'\\n';\n                \n        return max(option, max(daimeter_1, daimeter_2));\n    }\n};",
    "submit_ts": 1719719826.0
}