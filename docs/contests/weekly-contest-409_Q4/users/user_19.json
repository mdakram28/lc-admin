{
    "username": "liouzhou_101",
    "submission": "#ifndef FENWICKTREE_H_\n#define FENWICKTREE_H_\n\n#include <cassert>\n\n#include <algorithm>\n#include <functional>\n#include <type_traits>\n#include <vector>\n\nnamespace data_structure\n{\n\ttemplate<typename T>\n\tconstexpr auto lowbit(T x)\n\t{\n\t\treturn x & -x;\n\t}\n\t// 0-indexed fenwick tree.\n\t// Operation can be:\n\t//     std::plus, std::bit_xor, decltype(std::min), decltype(std::max).\n\t// The corresponding init_value can be\n\t//     0, 0, INF, -INF\n\t// Currently only std::plus is checked.\n\ttemplate<typename ValueType, typename Operation = std::plus<ValueType>>\n\tclass FenwickTree\n\t{\n\tprivate:\n\t\tValueType init_value;\n\t\tOperation operation;\n\t\tstd::vector<ValueType> values;\n\t\t// Build in linear time.\n\t\tvoid Build()\n\t\t{\n\t\t\tfor (int i = 1; i <= (int)values.size(); ++i)\n\t\t\t\tfor (int j = lowbit(i) >> 1, pos = i ^ lowbit(i); j; j >>= 1)\n\t\t\t\t\tvalues[i - 1] = operation(std::move(values[i - 1]), values[(pos += j) - 1]);\n\t\t}\n\tpublic:\n\t\texplicit FenwickTree(int size, const Operation& operation = Operation(), const ValueType& init_value = 0) :\n\t\t\tvalues(size, init_value), operation(operation), init_value(init_value) { }\n\t\ttemplate<typename InputIt>\n\t\texplicit FenwickTree(InputIt first, InputIt last, const Operation& operation = Operation(), const ValueType& init_value = ValueType()) :\n\t\t\tvalues(first, last), operation(operation), init_value(init_value)\n\t\t{\n\t\t\tBuild();\n\t\t}\n\t\tValueType Get(int pos)\n\t\t{\n\t\t\tif (!(0 <= pos && pos < (int)values.size())) return init_value;\n\t\t\tValueType res(init_value);\n\t\t\tfor (pos += 1; pos; pos ^= lowbit(pos))\n\t\t\t\tres = operation(std::move(res), values[pos - 1]);\n\t\t\treturn res;\n\t\t}\n\t\tvoid Add(int pos, ValueType value)\n\t\t{\n\t\t\tassert(0 <= pos && pos < (int)values.size());\n\t\t\tfor (pos += 1; pos <= values.size(); pos += lowbit(pos))\n\t\t\t\tvalues[pos - 1] = operation(std::move(values[pos - 1]), value);\n\t\t}\n\t\t\n\t\ttemplate<typename T = ValueType>\n\t\tstd::enable_if_t<std::is_same_v<Operation, std::plus<T>>, std::vector<T>> GetPlain()\n\t\t{\n\t\t\tstd::vector<ValueType> res = values;\n\t\t\tfor (int i = (int)values.size(); i >= 1; --i)\n\t\t\t{\n\t\t\t\tint k = lowbit(i);\n\t\t\t\tfor (int j = 1, pos = i - 1; j < k; pos ^= j, j <<= 1)\n\t\t\t\t\tres[i - 1] -= res[pos - 1];\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\ttemplate<typename T = ValueType>\n\t\tstd::enable_if_t<std::is_same_v<Operation, std::bit_xor<T>>, std::vector<T>> GetPlain()\n\t\t{\n\t\t\tstd::vector<ValueType> res = values;\n\t\t\tfor (int i = (int)values.size(); i >= 1; --i)\n\t\t\t{\n\t\t\t\tint k = lowbit(i);\n\t\t\t\tfor (int j = 1, pos = i - 1; j < k; pos ^= j, j <<= 1)\n\t\t\t\t\tres[i - 1] ^= res[pos - 1];\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t};\n}\n\n#endif\n\n\nnamespace algorithm {}\nnamespace data_structure {}\n\nusing namespace algorithm;\nusing namespace data_structure;\n\n\nclass Solution {\npublic:\n    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {\n        using ll = long long;\n\n        int n = colors.size();\n        set<pair<int, int>> H;\n        for (int i = 0; i < n; ++i)\n            H.insert(pair(i, i));\n\n        vector<int> a(n);\n        FenwickTree<int> f(n);\n        FenwickTree<ll> g(n);\n\n        auto erase = [&](int a, int b)\n        {\n            H.erase({ a, b });\n            f.Add(n - (b - a + 1), -1);\n            g.Add(n - (b - a + 1), -(b - a + 1));\n        };\n\n        auto insert = [&](int a, int b)\n        {\n            H.insert({ a, b });\n            f.Add(n - (b - a + 1), 1);\n            g.Add(n - (b - a + 1), b - a + 1);\n        };\n\n        auto gg = [&](int x, int c)\n        {\n            a[x] = c;\n            auto it = H.lower_bound(pair(x + 1, x));\n            it = prev(it);\n            int a = it->first, b = it->second;\n            if (a == b)\n            {\n                auto nit = next(it);\n                if (it != H.begin() && nit != H.end())\n                {\n                    auto pit = prev(it);\n                    int pa = pit->first, pb = pit->second;\n                    int na = nit->first, nb = nit->second;\n                    erase(a, b);\n                    erase(pa, pb);\n                    erase(na, nb);\n                    insert(pa, nb);\n                    //H.erase({ a, b });\n                    //H.erase({ pa, pb });\n                    //H.erase({ na, nb });\n                    //H.insert({ pa, nb });\n                }\n                else if (it != H.begin())\n                {\n                    auto pit = prev(it);\n                    int pa = pit->first, pb = pit->second;\n                    erase(a, b);\n                    erase(pa, pb);\n                    insert(pa, b);\n                    //H.erase({ a, b });\n                    //H.erase({ pa, pb });\n                    //H.insert({ pa, b });\n                }\n                else\n                {\n                    int na = nit->first, nb = nit->second;\n                    erase(a, b); // H.erase({ a, b });\n                    erase(na, nb); // H.erase({ na, nb });\n                    insert(a, nb); // H.insert({ a, nb });\n                }\n            }\n            else if (a == x)\n            {\n                if (it != H.begin())\n                {\n                    auto pit = prev(it);\n                    int pa = pit->first, pb = pit->second;\n                    erase(pa, pb); // H.erase({ pa, pb });\n                    erase(a, b); // H.erase({ a, b });\n                    if (a + 1 <= b) insert(a + 1, b); // H.insert({ a + 1, b });\n                    insert(pa, a); // H.insert({ pa, a });\n                }\n                else\n                {\n                    erase(a, b); // H.erase({ a, b });\n                    insert(a, a); // H.insert({ a, a });\n                    if (a + 1 <= b) insert(a + 1, b); // H.insert({ a + 1, b });\n                }\n            }\n            else if (b == x)\n            {\n                if (auto nit = next(it); nit != H.end())\n                {\n                    int na = nit->first, nb = nit->second;\n                    erase(na, nb); // H.erase({ na, nb });\n                    erase(a, b); // H.erase({ a, b });\n                    if (a <= b - 1) insert(a, b - 1); // H.insert({ a, b - 1 });\n                    insert(b, nb); // H.insert({ b, nb });\n                }\n                else\n                {\n                    erase(a, b); // H.erase({ a, b });\n                    if (a <= b - 1) insert(a, b - 1); // H.insert({ a, b - 1 });\n                    insert(b, b); // H.insert({ b, b });\n                }\n            }\n            else\n            {\n                erase(a, b); // H.erase({ a, b });\n                insert(a, x - 1); // H.insert({ a, x - 1 });\n                insert(x, x); // H.insert({ x, x });\n                insert(x + 1, b); // H.insert({ x + 1, b });\n            }\n        };\n\n        auto go = [&](int x, int c)\n        {\n            gg(x, c);\n            //gg(x + n, c);\n        };\n\n        auto query = [&](int s) -> int\n        {\n            if (H.size() == 1 && a[0] != a[n - 1])\n            {\n                return n;\n            }\n            if (a[0] != a[n - 1])\n            {\n                int a = H.begin()->first, b = H.begin()->second;\n                int c = H.rbegin()->first, d = H.rbegin()->second;\n                f.Add(n - (b - a + 1), -1);\n                g.Add(n - (b - a + 1), -(b - a + 1));\n                f.Add(n - (d - c + 1), -1);\n                g.Add(n - (d - c + 1), -(d - c + 1));\n                f.Add(n - (b - a + 1 + d - c + 1), 1);\n                g.Add(n - (b - a + 1 + d - c + 1), (b - a + 1 + d - c + 1));\n            }\n\n            int fv = f.Get(n - s);\n            ll gv = g.Get(n - s);\n\n            if (a[0] != a[n - 1])\n            {\n                int a = H.begin()->first, b = H.begin()->second;\n                int c = H.rbegin()->first, d = H.rbegin()->second;\n                f.Add(n - (b - a + 1), 1);\n                g.Add(n - (b - a + 1), (b - a + 1));\n                f.Add(n - (d - c + 1), 1);\n                g.Add(n - (d - c + 1), (d - c + 1));\n                f.Add(n - (b - a + 1 + d - c + 1), -1);\n                g.Add(n - (b - a + 1 + d - c + 1), -(b - a + 1 + d - c + 1));\n            }\n\n            return gv - (ll)fv * (s - 1);\n        };\n\n        for (int i = 0; i < n; ++i)\n        {\n            if (colors[i])\n            {\n                go(i, 1);\n            }\n        }\n\n        vector<int> res;\n        for (auto& e : queries)\n        {\n            if (e[0] == 1)\n            {\n                int x = e[1];\n                res.push_back(query(x));\n            }\n            else\n            {\n                int x = e[1], y = e[2];\n                if (a[x] != y)\n                {\n                    go(x, y);\n                }\n            }\n        }\n\n        return res;\n    }\n};",
    "submit_ts": "1722742923",
    "subm_id": "552347733"
}