{
    "username": "ruchit2801",
    "submission": "#include <iostream>\n#include <utility>\n#include<vector>\n#include<queue>\n#include <map>\n#include <stack>\n#include <set>\n#include <cmath>\n#include <bitset>\n#include <algorithm>\n#include<numeric>\n#include<unordered_set>\n#include<float.h>\n\n#define mod 1000000007\n#define ll long long\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define eb emplace_back\n#define pii pair<int, int>\n#define inf INT_MAX\n#define minf INT_MIN\n#define linf LONG_LONG_MAX\n#define mlinf LONG_LONG_MIN\n\nusing namespace std;\n\ntemplate <typename T1, typename T2>void debug(const vector<pair<T1, T2>>& vec) {cout << \"[ \";for (const auto& p : vec) {cout << \"(\" << p.first << \", \" << p.second << \") \";}cout << \"]\" << endl;}\ntemplate <typename KeyType, typename ValueType>void debug(const map<KeyType, ValueType>& myMap) {cout << \"{ \";for (const auto& pair : myMap) {cout << \"(\" << pair.first << \": \" << pair.second << \") \";}cout << \"}\" << endl;}\ntemplate <typename ElementType>void debug(const vector<ElementType>& myVector) {cout << \"[ \";for (const auto& element : myVector) {cout << element << \" \";}cout << \"]\" << endl;}\ntemplate <typename T>void debug(const vector<vector<T>>& matrix) {cout << \"[\\n\";for (const auto& row : matrix) {cout << \"  [ \";for (const auto& element : row) {cout << element << \" \";}cout << \"]\\n\";}cout << \"]\" << endl;}\ntemplate <typename T1, typename T2, typename T3>void debug(const map<pair<T1, T2>, T3>& myMap) {cout << \"Debugging map<pair<\" << typeid(T1).name() << \", \" << typeid(T2).name() << \">, \" << typeid(T3).name() << \">:\" << endl;for (const auto& pair : myMap) {cout << \"{(\" << pair.first.first << \", \" << pair.first.second << \"), \" << pair.second << \"}\" << endl;}}\ntemplate <typename T>void debug(const T& value) {cout << value << endl;}\ntemplate <typename T>string numToBinaryString(T number) {static_assert(is_arithmetic<T>::value, \"T must be a numeric type\");if (number == 0) {return \"0\";}string binary = \"\";while (number > 0) {binary = (number % 2 == 0 ? \"0\" : \"1\") + binary;number /= 2;}return binary;}\ntemplate <typename T>void debug(const unordered_set<T>& set) {for (const auto& value : set) {cout << value << \" \";}cout << endl;}\ntemplate <typename T>void debug(const multiset<T>& multiset) {for (const auto& elem : multiset) {cout << elem << \" \";}cout << endl;}\n\nvoid debug(map<int, pair<int, int>>& mp){for(auto x: mp){printf(\"%d: %d %d\\n\", x.first, x.second.first, x.second.second);}printf(\"\\n\");}\nvoid debug(int n){printf(\"%d \\n\", n);}\nvoid debug(set<int>& st){for(int x: st){printf(\"%d \", x);}printf(\"\\n\");}\n\nint gcd(int a, int b) {while (b != 0) {int temp = b;b = a % b;a = temp;}return a;}\nint powerModulo(int base, int exponent, int modulo) {if (modulo == 1) return 0;int result = 1;base = base % modulo;while (exponent > 0) {if (exponent % 2 == 1) {result = (int)((1LL * result * base) % modulo);}base = (int)((1LL * base * base) % modulo);exponent /= 2;}return result;}\nvector<int> getPrimesSieve(int n) {vector<bool> isPrime(n, true);vector<int> primes;for (int p = 2; p * p < n; ++p) {if (isPrime[p]) {for (int i = p * p; i < n; i += p) {isPrime[i] = false;}}}for (int p = 2; p < n; ++p) {if (isPrime[p]) {primes.push_back(p);}}return primes;}\nbool isPrime(int n){if (n <= 1)return false;for (int i = 2; i <= n / 2; i++)if (n % i == 0)return false;return true;}\n\nvoid computeLPSArray(string pat, int M, int* lps){int len = 0;lps[0] = 0;int i = 1;while (i < M) {if (pat[i] == pat[len]) {len++;lps[i] = len;i++;}else{if (len != 0) {len = lps[len - 1];}else{lps[i] = 0;i++;}}}}\nbool KMPSearch(string pat, string txt){int M = pat.length();int N = txt.length();int lps[M];computeLPSArray(pat, M, lps);int i = 0;int j = 0;while ((N - i) >= (M - j)) {if (pat[j] == txt[i]) {j++;i++;}if (j == M) {return true;j = lps[j - 1];}else if (i < N && pat[j] != txt[i]) {if (j != 0)j = lps[j - 1];else i = i + 1;}}return false;}\n\n\nclass Solution {\npublic:\n    int goal;\n\n    map<pair<pii, bool>, int> dp;\n\n    int solve(int posit, bool prev, int jump){\n        if(posit > 1 + goal) return 0; \n        if(dp.find({{posit, jump}, prev}) != dp.end())return dp[{{posit, jump}, prev}];\n        if(posit == goal){\n            if(!prev){\n                return dp[{{posit, jump}, prev}] = 1 + solve(posit - 1, true, jump) + solve(posit + (int)pow(2, jump), false, jump + 1);\n            } else {\n                return dp[{{posit, jump}, prev}] = 1 + solve(posit + (int)pow(2, jump), false, jump + 1);\n            }\n        } else {\n            if(!prev){\n                return dp[{{posit, jump}, prev}] = solve(posit - 1, true, jump) + solve(posit + (int)pow(2, jump), false, jump + 1);\n            } else {\n                return dp[{{posit, jump}, prev}] = solve(posit + (int)pow(2, jump), false, jump + 1);\n            }\n        }\n    }\n\n    int waysToReachStair(int k) {\n        goal = k;\n        return solve(1, false, 0);\n    }\n};\n\n//4194302",
    "submit_ts": 1716088643.0
}