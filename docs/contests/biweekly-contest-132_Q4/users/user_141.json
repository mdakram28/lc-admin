{
    "username": "loxa_",
    "submission": "class Solution {\npublic:\n    //MAX SEGMENT TREE\n    template<typename T>\n    class ST{\n    public:\n        int n, n_;\n        T null_element;\n        vector<T> st, lazy;\n        ST(int n, T null_element):n_(n), null_element(null_element){\n            while((n&(n-1))!=0) n++;\n            this->n = n;\n            // INITIALIZE NULL ELEMENTS PROPERLY(initialize -INF for max, INF for min, 0 for sum)\n            st = vector<T>(2*n-1, null_element);\n            lazy = vector<T>(2*n-1, null_element);\n        }\n        T operation(T a, T b){\n            // CHANGE OPERATION ACCORDING TO REQUIREMENT\n            return max(a, b); // creating segment tree which maintains max over ranges\n        }\n        void build(vector<T>& a){\n            _build(0, 0, n-1, a);\n        }\n        // x is the node index in segment tree array which will have 2*n-1 nodes\n        // lx, rx is the range node x corresponds to in the original array \n        void _build(int x, int lx, int rx, vector<T>& a){\n            if(lx==rx){\n                if(lx<n_) st[x] = a[lx];\n                return;\n            }\n            int mid = (lx+rx)/2;\n            _build(2*x+1, lx, mid, a);\n            _build(2*x+2, mid+1, rx, a);\n            st[x] = operation(st[2*x+1], st[2*x+2]);\n        }\n        void _propagate(int x, int lx, int rx){\n            // CHANGE PROPAGATION LOGIC ACCORDING TO REQUIREMENT\n            if(lazy[x]!=null_element){ // if lazy array is set at this node only then propagate\n                // updates max segment tree range by setting all elements in the range to \"f\"\n                st[2*x+1] = lazy[x];\n                st[2*x+2] = lazy[x];\n                // stores update value in the lazy array at this node for future propagation\n                lazy[2*x+1] = lazy[x];\n                lazy[2*x+2] = lazy[x];\n            }\n            lazy[x] = null_element; // reset lazy array at this node\n        }\n        T query(int l, int r){\n            return _query(0, l, r, 0, n-1);\n        }\n        // l, r is the range in the original array on which the query is made\n        // query is in range [l:r+1], indices from l to r(including r)\n        T _query(int x, int l, int r, int lx, int rx){\n            if(lx>r || rx<l) return null_element; // SET NULL ELEMENTS PROPERLY(set -INF for max, INF for min, 0 for sum)\n            else if(lx>=l && rx<=r) return st[x];\n            _propagate(x, lx, rx);\n            int mid = (lx+rx)/2;\n            T ql = _query(2*x+1, l, r, lx, mid);\n            T qr = _query(2*x+2, l, r, mid+1, rx);\n            T res = operation(ql, qr);\n            return res;\n        }\n        void update(int l, int r, T f){\n            _update(0, l, r, f, 0, n-1);\n        }\n        void _update(int x, int l, int r, T f, int lx, int rx){\n            if(lx>r || rx<l) return;\n            else if(lx>=l && rx<=r){\n                // CHANGE UPDATE LOGIC ACCORDING TO REQUIREMENT\n                lazy[x] = f; // stores update value in the lazy array at this node for future propagation\n                st[x] = f; // updates max segment range by setting all elements in the range by \"f\"\n                return;\n            }\n            _propagate(x, lx, rx);\n            int mid = (lx+rx)/2;\n            _update(2*x+1, l, r, f, lx, mid);\n            _update(2*x+2, l, r, f, mid+1, rx);\n            st[x] = operation(st[2*x+1], st[2*x+2]);\n        }\n    };\n\n\n    int maximumLength(vector<int>& nums, int k) {\n        int n = nums.size();\n        set<int> s(nums.begin(), nums.end());\n        vector<int> idx(s.begin(), s.end());\n        vector<vector<int>> dp(n, vector<int>(k+1));\n        int n_ = idx.size(), INF = 1e9+7;\n        vector<ST<int>> st(k+1, ST<int>(n_, -INF));\n        for(int i=0; i<n; i++){\n            // dp[i][j]\n            for(int j=0; j<=k; j++){\n                int res = 1, z = lower_bound(idx.begin(), idx.end(), nums[i])-idx.begin();\n                if(j>0){\n                    int save = st[j-1].query(z, z);\n                    st[j-1].update(z, z, -INF);\n                    res = max(res, st[j-1].query(0, n_-1)+1);\n                    st[j-1].update(z, z, save);\n                }\n                res = max(res, st[j].query(z, z)+1);\n                dp[i][j] = res;  \n                st[j].update(z, z, res);\n                // cout << dp[i][j] << ' ';\n            }\n            // cout << '\\n';\n        }\n        int res = 0;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<=k; j++){\n                res = max(res, dp[i][j]);\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1717860403.0
}