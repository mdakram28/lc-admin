{
    "username": "chenreddy0207",
    "submission": "class Solution {\n\n    int DFS(int idx, int parent, vector<vector<int>>& Adj, vector<int>& subTreeScore)\n    {\n        int score=0;\n        for(auto&x:Adj[idx])\n        {\n            if(x==parent)   continue;\n            if(x%2==0)\n            {\n                score=max(score,2+DFS(x,idx,Adj,subTreeScore));\n            }\n            else\n            {\n                score=max(score,1+DFS(x,idx,Adj,subTreeScore));\n            }\n        }\n        return subTreeScore[idx]=score;\n    }\n\n    void DFS2(int idx, int parent, vector<vector<int>>& Adj, vector<int>& subTreeScore, vector<int>& ans, int parentScore)\n    {\n        //first calculate the current answer\n        int score=parentScore;\n        vector<int> scores;\n        scores.push_back(parentScore);\n        scores.push_back(0);\n        for(auto&x:Adj[idx])\n        {\n            if(x==parent)   continue;\n            if(x%2==0)\n            {\n                score=max(score,2+subTreeScore[x]);\n                scores.push_back(2+subTreeScore[x]);\n            }\n            else\n            {\n                score=max(score,1+subTreeScore[x]);\n                scores.push_back(1+subTreeScore[x]);\n            }\n        }\n        ans[idx]=score;\n        make_heap(scores.begin(),scores.end());\n        //find the top 2\n        pop_heap(scores.begin(),scores.end());\n        int max1=scores.back();\n        scores.pop_back();\n        pop_heap(scores.begin(),scores.end());\n        int max2=scores.back();\n        scores.pop_back();\n\n        //pass the correct parentScore to children\n        int offset=1;\n        if(idx%2==0)    offset=2;\n        for(auto&x:Adj[idx])\n        {\n            if(x==parent)   continue;\n            if(x%2==0)\n            {\n                if(max1==2+subTreeScore[x])\n                {\n                    DFS2(x,idx,Adj,subTreeScore,ans,max2+offset);\n                }\n                else\n                {\n                    DFS2(x,idx,Adj,subTreeScore,ans,max1+offset);\n                }\n            }\n            else\n            {\n                if(max1==1+subTreeScore[x])\n                {\n                    DFS2(x,idx,Adj,subTreeScore,ans,max2+offset);\n                }\n                else\n                {\n                    DFS2(x,idx,Adj,subTreeScore,ans,max1+offset);\n                }\n            }\n        }\n    }\n\npublic:\n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        int n=edges.size()+1;\n        vector<int> subTreeScore(n,0);\n        vector<vector<int>> Adj(n);\n        for(auto&e:edges)\n        {\n            int a=e[0];\n            int b=e[1];\n            Adj[a].push_back(b);\n            Adj[b].push_back(a);\n        }\n\n        DFS(0,-1,Adj,subTreeScore);\n        vector<int> ans(n,0);\n\n        DFS2(0,-1,Adj,subTreeScore,ans,0);\n\n        return ans;\n    }\n};",
    "submit_ts": "1722699786",
    "subm_id": "1343222329"
}