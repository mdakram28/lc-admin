{
    "username": "hungrycarpet",
    "submission": "class Solution {\npublic:\n    // Helper function to mark the graph with connections\n    void markGraph(vector<vector<int>>& adjList, vector<pair<int, int>>& circles, int radius, int nodeIndex, int maxX, int maxY, int numCircles) {\n        if (circles[nodeIndex].first <= radius) {\n            adjList[numCircles].push_back(nodeIndex);\n            adjList[nodeIndex].push_back(numCircles);\n        }\n        if (maxX - circles[nodeIndex].first <= radius) {\n            adjList[numCircles + 2].push_back(nodeIndex);\n            adjList[nodeIndex].push_back(numCircles + 2);\n        }\n        if (circles[nodeIndex].second <= radius) {\n            adjList[numCircles + 1].push_back(nodeIndex);\n            adjList[nodeIndex].push_back(numCircles + 1);\n        }\n        if (maxY - circles[nodeIndex].second <= radius) {\n            adjList[numCircles + 3].push_back(nodeIndex);\n            adjList[nodeIndex].push_back(numCircles + 3);\n        }\n    }\n\n    // BFS function to check if two targets are reachable\n    bool bfsCheck(vector<vector<int>>& adjList, int start, int target1, int target2, int numNodes) {\n        vector<bool> visited(numNodes, false);\n        queue<int> q;\n        q.push(start);\n        visited[start] = true;\n\n        while (!q.empty()) {\n            int currentNode = q.front();\n            q.pop();\n\n            for (int neighbor : adjList[currentNode]) {\n                if (!visited[neighbor]) {\n                    if (neighbor == target1 || neighbor == target2) return true;\n                    q.push(neighbor);\n                    visited[neighbor] = true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    // Function to determine if it's possible to reach any corner\n    bool canReachCorner(int width, int height, vector<vector<int>>& obstacles) {\n        int numCircles = obstacles.size();\n        vector<pair<int, int>> circles(numCircles);\n        vector<vector<int>> adjList(numCircles + 4);\n\n        for (int i = 0; i < numCircles; ++i) {\n            circles[i] = {obstacles[i][0], obstacles[i][1]};\n        }\n\n        for (int i = 0; i < numCircles; ++i) {\n            int radius = obstacles[i][2];\n            markGraph(adjList, circles, radius, i, width, height, numCircles);\n\n            for (int j = i + 1; j < numCircles; ++j) {\n                double distance = sqrt(pow(circles[i].first - circles[j].first, 2) + pow(circles[i].second - circles[j].second, 2));\n                int sumRadii = radius + obstacles[j][2];\n                if (sumRadii >= distance) {\n                    adjList[i].push_back(j);\n                    adjList[j].push_back(i);\n                }\n            }\n        }\n\n        bool isBlocked = bfsCheck(adjList, numCircles, numCircles + 1, numCircles + 2, numCircles + 4) ||\n                         bfsCheck(adjList, numCircles + 3, numCircles + 2, numCircles + 1, numCircles + 4);\n\n        return !isBlocked;\n    }\n};",
    "submit_ts": "1722137604",
    "subm_id": "1335768524"
}