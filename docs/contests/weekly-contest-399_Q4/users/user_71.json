{
    "username": "lokeshrajput5473",
    "submission": "const long long mod = 1e9 + 7;\n\n\nclass Node {\n    public:\n    int leftTakenRightNotTaken, rightTakenLeftNotTaken, bothTaken, bothNotTaken;\n\n    Node(){\n        leftTakenRightNotTaken = rightTakenLeftNotTaken = bothTaken = bothNotTaken = 0;\n    }\n\n    void print() {\n        cout << leftTakenRightNotTaken << \n        \" \" << rightTakenLeftNotTaken << \n        \" \" << bothTaken << \" \" << bothNotTaken << endl;\n    }\n\n    int getMax(){\n        return max(\n            max(\n                leftTakenRightNotTaken,rightTakenLeftNotTaken\n            ),\n            max(\n                bothTaken, bothNotTaken\n            )\n        );\n    }\n};\n\nclass SegTree {\n    private:\n\n\n    public:\n\n    vector<Node> tree;\n    int n;\n\n        SegTree(long long size, vector<int> &arr) : n(size) {\n            tree.resize(10 * n);\n            for(int i=0;i<arr.size();i++) {\n                update(i, 0, 0, n-1, arr[i]);\n            }\n        }\n    int add(int a, int b) {\n    return (a + 0ll + b) % mod;\n}\n\n    void update(long long idx, long long v, long long tl, long long tr, int value) {\n        if (tl > tr) return;\n        if (idx < tl || idx > tr) return; \n        if (tl == tr) {\n            tree[v].bothTaken = value;\n            return;\n        }\n        long long tmid = (tl + tr) / 2;\n        update(idx, v * 2 + 1, tl, tmid, value);\n        update(idx, v * 2 + 2, tmid + 1, tr, value);\n        Node left = tree[v*2 + 1], right = tree[v * 2 + 2];\n        tree[v].leftTakenRightNotTaken = max( \n            add(left.leftTakenRightNotTaken , max(right.bothNotTaken, right.leftTakenRightNotTaken)),\n            add(left.bothTaken , right.bothNotTaken)\n        );\n        tree[v].rightTakenLeftNotTaken = max(\n            add(right.rightTakenLeftNotTaken , max(left.bothNotTaken, left.rightTakenLeftNotTaken)),\n            add(right.bothTaken , left.bothNotTaken)\n        );\n        tree[v].bothTaken = max(\n            max(\n                add(left.leftTakenRightNotTaken , max(right.bothTaken, right.rightTakenLeftNotTaken)),\n                add(left.bothTaken , right.rightTakenLeftNotTaken)\n            ),\n            max(\n                add(right.rightTakenLeftNotTaken , max(left.bothTaken, left.leftTakenRightNotTaken)),\n                add(right.bothTaken , left.leftTakenRightNotTaken)\n            )\n        );\n        tree[v].bothNotTaken = max(\n            max(\n                add(left.rightTakenLeftNotTaken , right.bothNotTaken),\n                add(left.bothNotTaken , max(right.bothNotTaken, right.leftTakenRightNotTaken))    \n            ),\n            max(\n                add(right.leftTakenRightNotTaken , left.bothNotTaken),\n                add(right.bothNotTaken , max(left.bothNotTaken, left.rightTakenLeftNotTaken))\n            )\n        );\n    }\n\n    // Node getMaxm(long long idx, long long v, long long tl, long long tr, Node temp) {\n    //     if(tl > tr) return temp;\n    //     if (idx < tl) return temp;\n    //     // if(idx)  \n\n    //     // cout << tl << \" \" << tr << endl;\n    //     if(idx >= tr){\n    //         tree[v].print();\n    //         return tree[v];\n    //     }\n    //     // cout << idx << endl;\n\n    //     long long tmid = (tl + tr)/2;\n    //     cout << \"Level \" << v << \" \" << tmid << endl;\n    //     Node left = getMaxm(idx, v*2 + 1, tl, tmid, temp);\n    //     Node right = getMaxm(idx, v*2 + 2, tmid+1, tr, temp);\n    //     Node ans;\n    //     ans.left = left.left == (tmid - tl + 1)? left.left + right.left : left.left;\n    //     ans.right = right.right == (tr - tmid) ? left.right + right.right : right.right;\n    //     ans.maxm = max(left.maxm, max(right.maxm, \n    //     (left.right != (tmid-tl+1))\n    //     ? left.right+right.left+1 \n    //     : left.right+right.left));\n\n    //     cout << ans.maxm << \" \" << ans.left << \" \" << ans.right << \" \" << \"level \" << v << \" \" << tr  << endl;\n    //     return ans;\n    // }\n};\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        SegTree sTree(n, nums);\n        // sTree.tree[0].print();\n        \n        int ans = 0;\n        for(auto i:queries) {\n            sTree.update(i[0], 0, 0, n-1, i[1]);\n            ans = (ans + 0ll + sTree.tree[0].getMax()) % mod;\n        }\n        return ans;\n\n    }\n};",
    "submit_ts": 1716693762.0
}