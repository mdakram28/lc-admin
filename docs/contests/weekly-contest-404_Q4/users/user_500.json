{
    "username": "huntermarchi17_03",
    "submission": "class Solution {\n    fun minimumDiameterAfterMerge(edges1: Array<IntArray>, edges2: Array<IntArray>): Int {\n        val size1 = edges1.size + 1\n        val size2 = edges2.size + 1\n        val graph1 = Array(size1) { mutableListOf<Int>() }\n        val graph2 = Array(size2) { mutableListOf<Int>() }\n        \n        for (edge in edges1) {\n            graph1[edge[0]].add(edge[1])\n            graph1[edge[1]].add(edge[0])\n        }\n        \n        for (edge in edges2) {\n            graph2[edge[0]].add(edge[1])\n            graph2[edge[1]].add(edge[0])\n        }\n        \n        fun dfs(graph: Array<MutableList<Int>>, start: Int): Pair<Int, Int> {\n            val n = graph.size\n            val distance = IntArray(n) { -1 }\n            var furthestNode = start\n            var maxDistance = 0\n            \n            fun dfsVisit(node: Int, dist: Int) {\n                distance[node] = dist\n                if (dist > maxDistance) {\n                    maxDistance = dist\n                    furthestNode = node\n                }\n                for (neighbor in graph[node]) {\n                    if (distance[neighbor] == -1) {\n                        dfsVisit(neighbor, dist + 1)\n                    }\n                }\n            }\n            \n            dfsVisit(start, 0)\n            return Pair(furthestNode, maxDistance)\n        }\n        \n        val node1Start = dfs(graph1, 0).first\n        val diameter1 = dfs(graph1, node1Start).second\n        \n        val node2Start = dfs(graph2, 0).first\n        val diameter2 = dfs(graph2, node2Start).second\n        \n        var minDiameter = maxOf(diameter1, diameter2)\n        val half1 = (diameter1 + 1) / 2\n        val half2 = (diameter2 + 1) / 2\n        \n        minDiameter = maxOf(minDiameter, half1 + half2 + 1)\n        \n        return minDiameter\n    }\n}\n",
    "submit_ts": "1719719493",
    "subm_id": "1304443284"
}