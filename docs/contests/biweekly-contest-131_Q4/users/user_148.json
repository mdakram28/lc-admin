{
    "username": "ye_che",
    "submission": "class Solution {\npublic:\n    using ll=long long;\n    int n, t, l, r, x;\n    vector<int> w;\n    struct Node{\n        ll l, r, M;\n    };\n    vector<Node> tr;\n\n    void pushup(Node & x, Node & l, Node & r)\n    {\n        // x.sum = l.sum + r.sum;\n        // x.d = __gcd(l.d, r.d);\n        x.M = max(l.M,r.M);\n    }\n\n    void pushup(ll x)\n    {\n        pushup(tr[x], tr[x << 1], tr[x << 1 | 1]);\n    }\n\n    void build(ll u, ll l, ll r)\n    {\n        if(l == r) tr[u] = {l, r, 0};\n        else\n        {\n            tr[u] = {l, r};\n            ll mid = l + r >> 1;\n            build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);\n            pushup(u);\n        }\n    }\n\n    Node query(ll u, ll l, ll r)\n    {\n        if(l > r) return {0};\n        if(l <= tr[u].l && tr[u].r <= r) return tr[u];\n        else\n        {\n            ll mid = tr[u].l + tr[u].r >> 1;\n            if(mid < l) return query(u << 1 | 1, l, r);\n            else if(r <= mid) return query(u << 1, l, r);\n            else\n            {\n                Node res, left = query(u << 1, l, r), right = query(u << 1 | 1, l , r);\n                pushup(res, left, right);\n                return res;\n            }\n        }\n    }\n\n    void modify(ll u, ll x, ll v)\n    {\n        if(tr[u].l == tr[u].r) tr[u].M=v;\n        else\n        {\n            ll mid = tr[u].l + tr[u].r >> 1;\n            if(x <= mid) modify(u << 1, x, v);\n            if(x > mid) modify(u << 1 | 1, x, v);\n            pushup(u);\n        }\n    }\n    vector<bool> getResults(vector<vector<int>>& q) {\n        int cnt=1;\n        map<int,int> p,rp;\n        vector<bool> res;\n        set<int> ss;\n        for (auto &x:q){\n            if (x[0]==1)ss.insert(x[1]);\n        }\n        p[0]=cnt,rp[cnt++]=0;\n        for(auto&x:ss) p[x]=cnt,rp[cnt++]=x;\n        tr=vector<Node>(cnt*4+10);\n        // w=vector<int>(cnt+1,0);\n        build(1,1,cnt);\n        set<int> s;\n        s.insert(0);\n        for (auto &x:q){\n            if (x[0]==1){\n                auto it=s.lower_bound(x[1]);\n                int ne = 1e9;\n                if (it!=s.end()){\n                    ne=*it;\n                }\n                it--;\n                int now=(*it);\n                s.insert(x[1]);\n                if (ne!=1e9){\n                    modify(1,p[ne],ne-x[1]);\n                }\n                modify(1,p[x[1]],x[1]-now);\n            }\n            else {\n                auto it=s.lower_bound(x[1]);\n                if (it!=s.end()&&(*it)==x[1]) res.push_back(query(1,1,p[x[1]]).M>=x[2]);\n                else {\n                    it--;\n                    res.push_back(query(1,1,p[*it]).M>=x[2]||x[1]-(*it)>=x[2]);\n                }\n            }\n        }\n        return res;\n        \n        \n//         long long r = 1e15;\n//         vector<bool> res;\n        // map<int,int> p,rp;\n        // set<int> s;\n        // for (auto &x:q){\n        //     if (x[0]==1)s.insert(x[1]);\n        // }\n        // int cnt=1;\n        // for(auto&x:s) p[x]=cnt,rp[cnt++]=x;\n//         cnt+=2;\n//         vector<int> tr(cnt*4+1,0),l(cnt*4+1,0),r(cnt*4+1,0);\n//         function<void(int,int,int)> build=[&](int u,int L,int R){\n//             if (L>=R)l[u]=r[u]=L;\n//             else{\n//                 int mid=L+R>>1;\n//                 build(u<<1,L,mid);\n//                 build(u<<1|1,mid+1,R);\n//                 pushup()\n//             }\n//         }\n//         for (auto &x:q){\n//             if (x[0]==1){\n                \n//             }\n//             else{\n                \n//             }\n//         }\n    }\n};",
    "submit_ts": 1716650193.0
}