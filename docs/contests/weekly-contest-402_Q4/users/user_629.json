{
    "username": "Dengxj",
    "submission": "class Tree {\npublic:\n    Tree(vector<int> A): N(A.size()), nodes(N * 4) {\n        build(1, 0, N - 1, A);\n    }\n\n    void update(int i, int val) {\n        update(1, 0, N - 1, i, val);\n    }\n\n    int query(int s, int e) {\n        return query(1, 0, N - 1, s, e);\n    }\nprivate:\n    int N;\n    vector<int> nodes;\n\n    void build(int u, int lf, int rt, vector<int>& A) {\n        if (lf == rt) {\n            nodes[u] = A[lf];\n        } else if (lf < rt) {\n            int mid = (lf + rt) / 2;\n            build(2 * u, lf, mid, A);\n            build(2 * u + 1, mid + 1, rt, A);\n            nodes[u] = nodes[u * 2] + nodes[u * 2 + 1];\n        }\n    }\n\n    void update(int u, int lf, int rt, int i, int val) {\n        if (i < lf || rt < i)\n            return;\n        if (lf == rt) {\n            nodes[u] = val;\n        } else {\n            int mid = (lf + rt) / 2;\n            update(u * 2, lf, mid, i, val);\n            update(u * 2 + 1, mid + 1, rt, i, val);\n            nodes[u] = nodes[u * 2] + nodes[u * 2 + 1];\n        }\n    }\n\n    int query(int u, int lf, int rt, int s, int e) {\n        if (s <= lf && rt <= e) {\n            return nodes[u];\n        } else if (lf <= e && rt >= s) {\n            int mid = (lf + rt) / 2;\n            return query(u * 2, lf, mid, s, e) + query(u * 2 + 1, mid + 1, rt, s, e);\n        }\n        return 0;\n    }\n};\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> A(n);\n        for (int i = 1; i + 1 < n; ++i) {\n            if (nums[i - 1] < nums[i] && nums[i] > nums[i + 1]) {\n                A[i] = 1;\n            }\n        }\n        auto tree = Tree(A);\n        vector<int> res;\n        for (const auto& q: queries) {\n            if (q[0] == 1) {\n                res.push_back(tree.query(q[1], q[2]) - A[q[1]] - (q[1] != q[2] ? A[q[2]] : 0));\n            } else {\n                nums[q[1]] = q[2];\n                for (int i = q[1] - 1; i <= q[1] + 1; ++i) {\n                    if (i - 1 >= 0 && i + 1 < n) {\n                        A[i] = nums[i - 1] < nums[i] && nums[i] > nums[i + 1];\n                        tree.update(i, A[i]);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1718508377.0
}