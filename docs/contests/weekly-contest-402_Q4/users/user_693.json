{
    "username": "brijeshsiwach93",
    "submission": "#include<bits/stdc++.h>\n//#include <sys/resource.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<ll,ll> pl;\ntypedef vector<pl> vpl;\n \n#define all(x) x.begin(), x.end()\n#define nl cout<<\"\\n\"\n#define ar  array\n#define PRECISION 9\n#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)\n#define clock() cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\"\n#define size(x) x.size()\n#define pb push_back\n#define fr(i,j,k) for(int i=j;i<k;i++)\n#define rf(i,j,k) for(int i=k-1;i>j;i--)\n\n#ifdef LOCAL\n#include \"../Library/debug.h\"\n#else \n#define dbg(...) \"UNEMPLOYED\"\n#endif\n\n//#define STACK_INCREASE\n\ntemplate<class T> \nclass SegmentTree{\npublic:\n    int N; // this should be (b.size()-1)\n    vector<T> t;\n \n    SegmentTree(int n, vector<int> b):N(n),t(4*n+1){ \n        build(1, 1, N, b);\n    }\n     \n     SegmentTree(int n):N(n), t(4*n+2){}\n\n    T merge(T a, T b){\n        return a+b;\n    }\n    \n \n    void build(int i, int l, int r, vector<int> &b){\n        if(l > r) return;\n        if(l == r){\n            t[i] = b[l];\n            return;\n        }\n        int mid = (l+r) >> 1;\n        build(2*i, l, mid, b);\n        build(2*i+1, mid+1, r, b);\n        t[i] = merge(t[2*i],t[2*i + 1]);\n    }\n \n    void print(){\n        for(int i = 0; i < 4*N; i++){\n            cout << t[i] << \" \";\n        }\n    }\n \n \n    void update(int i, int l, int r, int pos, T val){\n        if(l > pos || r < pos) return;\n        if(l == pos && r == pos){\n            t[i] = val;\n            return;\n        }\n        int mid = (l+r)>>1;\n        update(2*i, l, mid, pos, val);\n        update(2*i +1, mid+1, r, pos, val);\n        t[i] = merge(t[2*i], t[2*i+1]);\n    }\n \n    T query(int i, int l, int r, int ql, int qr){\n        if(l > qr || r < ql) return 0;\n        if(l >=ql && r <= qr) return t[i];\n        int mid = (l+r)>>1;\n        return merge(query(2*i, l, mid, ql, qr), query(2*i+1, mid+1, r, ql, qr));\n    }\n \n    void update(int pos, T val){\n        update(1, 1, N, pos, val);\n    }\n \n    T query(int ql, int qr){\n        return query(1, 1, N, ql, qr);\n    }\n \n};\n// check for the update, do you want t[u] += val or t[u] = val;\n// also note that the starting index of the segment tree is 1.\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& b) {\n        int n=size(a);\n        SegmentTree<int>seg{n};\n        fr(i,1,n-1){\n            if(a[i]>a[i-1]&&a[i]>a[i+1]){\n                seg.update(i+1,1);\n            }\n        }\n        vi res;\n        auto set_ind=[&](int i){\n            if(i-1>=0 and i+1<n){\n                if(a[i]>a[i-1]and a[i]>a[i+1]){\n                    seg.update(i+1,1);\n                }\n                else{\n                    seg.update(i+1,0);\n                }\n            }\n            if(i==0){\n                if(a[i+1]>a[i]and a[i+2]<a[i+1]){\n                    seg.update(i+2,1);\n                }\n                else{\n                    seg.update(i+2,0);\n                }\n            }\n            if(i==n-1){\n                if(a[i-1]>a[i]and a[i-1]>a[i-2]){\n                    seg.update(i,1);\n                }\n                else{\n                    seg.update(i,0);\n                }\n            }\n        };\n        fr(i,0,size(b)){\n            int t=b[i][0];\n            if(t==1){\n                int l=b[i][1],r=b[i][2];\n                int ans=seg.query(l+2,r);\n                res.pb(ans);\n            }\n            else{\n                int ind=b[i][1],v=b[i][2];\n                // --ind;\n                a[ind]=v;\n                set_ind(ind);\n                set_ind(ind-1);\n                set_ind(ind+1);\n            }\n        }\n        return res;\n    }\n};\n\n",
    "submit_ts": 1718506772.0
}