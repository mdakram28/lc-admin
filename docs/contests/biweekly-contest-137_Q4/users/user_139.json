{
    "username": "Frank Rodriguez",
    "submission": "class Solution {\n    /*\n        [[70,-16,31],[2,75,37],[67,-95,-44]]\n        expected = 173\n    */\n\n    public long maximumValueSum(int[][] board) {\n        int n = board.length;\n        int m = board[0].length;\n        var max = new Candidate[m][3];\n        for (int i=0; i<m; i++) {\n            max[i] = get3Maxes(board, i);\n        }\n        var segTree = new SegmentTree2D(board);\n\n        long ans = Long.MIN_VALUE;\n        for (int i=0; i<m; i++) {\n            for (int j=i+1; j<m; j++) {\n                for (int ii=0; ii<3; ii++) {\n                    for (int jj=0; jj<3; jj++) {\n                        if (max[i][ii].inx == max[j][jj].inx) {\n                            continue;\n                        }\n                        long base = max[i][ii].val + max[j][jj].val;\n                        int x = Math.min(max[i][ii].inx, max[j][jj].inx);\n                        int y = Math.max(max[i][ii].inx, max[j][jj].inx);\n                        if (max[i][ii].inx != 0) {\n                            ans = Math.max(ans, base + segTree.query(0, x-1, j+1, m-1)); \n                        }\n\n                        if (x + 1 != y) {\n                            ans = Math.max(ans, base + segTree.query(x+1, y-1, j+1, m-1)); \n                        }\n\n                        if (y != n-1) {\n                            ans = Math.max(ans, base + segTree.query(y+1, n-1, j+1, m-1)); \n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n\n    record Candidate(long val, int inx) {};\n\n    Candidate[] get3Maxes(int[][] board, int col) {\n        var pq = new PriorityQueue<Candidate>((a,b)->Long.compare(a.val, b.val));\n        for (int i=0; i<board.length; i++) {\n            pq.offer(new Candidate(board[i][col], i));\n            if (pq.size() > 3) {\n                pq.poll();\n            }\n        }\n        var ret = new Candidate[3];\n        ret[2] = pq.poll();\n        ret[1] = pq.poll();\n        ret[0] = pq.poll();\n        return ret;\n    }\n\n    class SegmentTree2D {\n        private int[][] grid;\n        private int[][] tree;\n        private int n, m;\n\n        public SegmentTree2D(int[][] grid) {\n            this.grid = grid;\n            this.n = grid.length;\n            this.m = grid[0].length;\n            this.tree = new int[4 * n][4 * m];\n            buildX(1, 0, n - 1);\n        }\n\n        private void buildY(int nodeX, int startX, int endX, int nodeY, int startY, int endY) {\n            if (startY == endY) {\n                if (startX == endX) {\n                    tree[nodeX][nodeY] = grid[startX][startY];\n                } else {\n                    tree[nodeX][nodeY] = Math.max(tree[nodeX * 2][nodeY], tree[nodeX * 2 + 1][nodeY]);\n                }\n            } else {\n                int midY = (startY + endY) / 2;\n                buildY(nodeX, startX, endX, nodeY * 2, startY, midY);\n                buildY(nodeX, startX, endX, nodeY * 2 + 1, midY + 1, endY);\n                tree[nodeX][nodeY] = Math.max(tree[nodeX][nodeY * 2], tree[nodeX][nodeY * 2 + 1]);\n            }\n        }\n\n        private void buildX(int nodeX, int startX, int endX) {\n            if (startX != endX) {\n                int midX = (startX + endX) / 2;\n                buildX(nodeX * 2, startX, midX);\n                buildX(nodeX * 2 + 1, midX + 1, endX);\n            }\n            buildY(nodeX, startX, endX, 1, 0, m - 1);\n        }\n\n        public int query(int lX, int rX, int lY, int rY) {\n            return queryX(1, 0, n - 1, lX, rX, lY, rY);\n        }\n\n        private int queryY(int nodeX, int nodeY, int startY, int endY, int lY, int rY) {\n            if (lY > endY || rY < startY) {\n                return Integer.MIN_VALUE;\n            }\n            if (lY <= startY && endY <= rY) {\n                return tree[nodeX][nodeY];\n            }\n            int midY = (startY + endY) / 2;\n            return Math.max(queryY(nodeX, nodeY * 2, startY, midY, lY, rY),\n                            queryY(nodeX, nodeY * 2 + 1, midY + 1, endY, lY, rY));\n        }\n\n        private int queryX(int nodeX, int startX, int endX, int lX, int rX, int lY, int rY) {\n            if (lX > endX || rX < startX) {\n                return Integer.MIN_VALUE;\n            }\n            if (lX <= startX && endX <= rX) {\n                return queryY(nodeX, 1, 0, m - 1, lY, rY);\n            }\n            int midX = (startX + endX) / 2;\n            return Math.max(queryX(nodeX * 2, startX, midX, lX, rX, lY, rY),\n                            queryX(nodeX * 2 + 1, midX + 1, endX, lX, rX, lY, rY));\n        }\n    }\n}",
    "submit_ts": "1723907832",
    "subm_id": "1359126264"
}