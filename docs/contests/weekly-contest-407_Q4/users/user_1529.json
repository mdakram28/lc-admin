{
    "username": "Maaxle",
    "submission": "#include <bits/stdc++.h>\n\n#define range(it, a, b) for (ll it = a; it < b; it++)\n#define all(x) begin(x), end(x)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define INF64 ((ll) 1 << 62)\n#define INF32 (1 << 30)\n#define mset multiset\n#define uset unordered_set\n#define umap unordered_map \n#define pqueue priority_queue \n#define ptr(A) shared_ptr<A>\n#define v(x) vector<x>\n\nusing namespace std;\n\nstruct SegTree {\n    struct Node {\n        Node* lt;\n        Node* rt;\n\n        ll l, r;\n        ll lazy = 0;\n        ll mini, maxi;\n        ll m() { return (l+r)/2; } \n    };\n\n    v(int)& arr;\n    Node* rt;\n\n    SegTree(v(int)& a) : arr(a) {\n        rt = new Node;\n        rt->l = 0;\n        rt->r = a.size()-1;\n        build(rt);\n    }\n\n    void build (Node* nd) {\n        if (nd->l == nd->r) {\n            nd->mini = arr[nd->l];\n            nd->maxi = arr[nd->l];\n            return;\n        }\n\n        nd->lt = new Node;\n        nd->lt->l = nd->l;\n        nd->lt->r = nd->m();\n        build(nd->lt);\n\n        nd->rt = new Node;\n        nd->rt->l = nd->m()+1;\n        nd->rt->r = nd->r;\n        build(nd->rt);\n\n        nd->mini = min(nd->lt->mini, nd->rt->mini);\n        nd->maxi = max(nd->lt->maxi, nd->rt->maxi);\n    }\n\n    void push(Node* nd) {\n        if (!nd->lazy)\n            return;\n        nd->lt->mini += nd->lazy;\n        nd->lt->maxi += nd->lazy;\n        nd->rt->mini += nd->lazy;\n        nd->rt->maxi += nd->lazy;\n        nd->lt->lazy += nd->lazy;\n        nd->rt->lazy += nd->lazy;\n        nd->lazy = 0;\n    }\n    \n    ll query_min (ll l, ll r) { return query_min(rt, l, r); }\n    ll query_min (Node* nd, ll l, ll r) {\n        if (nd->l == l && nd->r == r)\n            return nd->mini;\n        \n        push(nd);\n        ll ans = INF64;\n        if (l <= nd->m())\n            ans = min(ans, query_min(nd->lt, l, min(r, nd->m())));\n        if (r > nd->m())\n            ans = min(ans, query_min(nd->rt, max(l, nd->m()+1), r));\n        return ans;\n    }\n\n    ll query_max (ll l, ll r) { return query_max(rt, l, r); }\n    ll query_max (Node* nd, ll l, ll r) {\n        if (nd->l == l && nd->r == r)\n            return nd->maxi;\n        \n        push(nd);\n        ll ans = -INF64;\n        if (l <= nd->m())\n            ans = max(ans, query_max(nd->lt, l, min(r, nd->m())));\n        if (r > nd->m())\n            ans = max(ans, query_max(nd->rt, max(l, nd->m()+1), r));\n        return ans;\n    }\n\n    void update(ll l, ll r, ll d) { update(rt, l, r, d); }\n    void update(Node* nd, ll l, ll r, ll d) {\n        if (nd->l == l && nd->r == r) {\n            nd->maxi += d;\n            nd->mini += d;\n            nd->lazy += d;\n            return;\n        }\n\n        push(nd);\n        if (l <= nd->m())\n            update(nd->lt, l, min(r, nd->m()), d);\n        if (r > nd->m())\n            update(nd->rt, max(l, nd->m()+1), r, d);\n    }\n};\n\nclass Solution {\npublic:\n    ll minimumOperations(v(int)& nums, v(int)& target) {\n        ll n = nums.size();\n        v(int) dif (n);\n\n        range(i, 0, n)\n            dif[i] = target[i] - nums[i];\n        \n        ll ans = 0;\n        SegTree st (dif);\n\n        range(i, 0, n) {\n            ll a = st.query_max(i, i);\n\n            if (a > 0) {\n                ll j = i;\n                while (j < n-1 && st.query_max(j+1, j+1) > 0)\n                    j++;\n                \n                ll mini = st.query_min(i, j);\n                ans += mini;\n                st.update(i, j, -mini);\n                i--;\n                continue;\n            }\n            if (a < 0) {\n                ll j = i;\n                while (j < n-1 && st.query_max(j+1, j+1) < 0)\n                    j++;\n                \n                ll maxi = st.query_max(i, j);\n                ans -= maxi;\n                st.update(i, j, -maxi);\n                i--;\n                continue;\n            }\n        }\n        return ans;\n    }\n};\n\n// IT'S TOUGH, I KNOW\n// BUT YOU'D RATHER DIE FIGHTING THAN LIVE ON YOUR KNEES\n// THOUGH YOU WON'T DO NEITHER OF THOSE\n// IMPOSSIBLE, AS IT'S AGAINST YOUR NATURE\n// AS YOU ALREADY WON\n// I SEE YOUR MEDAL HANGING FROM YOUR NECK\n// SHINING AS NOTHING YOU'VE EVER HAD\n\n// THOUSANDS AND THOUSANDS OF LINES\n// YOU AREADY MADE IT THIS FAR\n// AND WHO COULD TELL HOW FAR YOU WILL GET...\n// BUT YOU?\n\n// THEN COME ON, YOU BASTARD!\n// GO CLEAR YOUR MIND AND STAND\n// AS EACH OF THOSE LINES IS A STEP CLOSER\n// CLOSER TO THE GREATNESS YOU PURSUE\n// CLOSER TO THE GREATNESS YOU ALREADY HAVE",
    "submit_ts": "1721532679",
    "subm_id": "1327991514"
}