{
    "username": "thirdcook",
    "submission": "#define ll long long\nvoid build1(vector<int>&a,vector<int>&s,int i, int low, int high){\n    if(low==high){\n        s[i] = a[low] ;\n        return  ;\n    }\n    int mid = (low+high)>>1 ;\n    build1(a,s,2*i+1,low,mid) ;\n    build1(a,s,2*i+2,mid+1,high) ; \n    s[i] = min(s[2*i+1],s[2*i+2]) ;\n}\nint query(vector<int>&s, int i, int low, int high, int l , int r){\n    if(low>r || high<l)return 1e9 ;\n    if(low>=l && high<=r)return s[i] ;\n    int mid = (low+high)>>1 ;\n    return min(query(s,2*i+1,low,mid,l,r),query(s,2*i+2,mid+1,high,l,r)) ;\n}\nvoid update(vector<int>&s,int i, int low, int high, int l, int x){\n    if(low==high){\n        s[i] = min(s[i],x) ;\n        return  ;\n    }\n    int mid = (low+high)>>1 ;\n    if(l>mid)update(s,2*i+2,mid+1,high,l,x) ;\n    else update(s,2*i+1,low,mid,l,x) ;\n    s[i] = min(s[2*i+1],s[2*i+2]) ;\n}\nvoid build(vector<int>& arr, vector<ll>& segTree, int node, int start, int end) {\n    if (start == end) {\n        segTree[node] = arr[start];\n    } else {\n        int mid = (start + end) / 2;\n        build(arr, segTree,  2 * node + 1, start, mid);\n        build(arr, segTree,  2 * node + 2, mid + 1, end);\n        segTree[node] = segTree[2 * node + 1] + segTree[2 * node + 2];\n    }\n}\n\nvoid updateRange(vector<ll>& segTree, vector<ll>& lazy, int node, int start, int end, int l, int r, ll val) {\n    if (lazy[node] != 0) {\n        segTree[node] += (end - start + 1) * lazy[node];\n        if (start != end) {\n           \n            lazy[2 * node + 1] += lazy[node];\n            lazy[2 * node + 2] += lazy[node];\n        }\n        lazy[node] = 0; \n    }\n    \n    if (start > end || start > r || end < l) {\n        return;\n    }\n\n    if (start >= l && end <= r) {\n        segTree[node] += (end - start + 1) * val;\n        if (start != end) {\n            lazy[2 * node + 1] += val;\n            lazy[2 * node + 2] += val;\n        }\n        return;\n    }\n\n    int mid = (start + end) / 2;\n    updateRange(segTree, lazy, 2 * node + 1, start, mid, l, r, val);\n    updateRange(segTree, lazy, 2 * node + 2, mid + 1, end, l, r, val);\n    segTree[node] = segTree[2 * node + 1] + segTree[2 * node + 2];\n}\n\nll queryRange(vector<ll>& segTree, vector<ll>& lazy, int node, int start, int end, int l, int r) {\n    if (start > end || start > r || end < l) {\n        return 0;\n    }\n\n    if (lazy[node] != 0) {\n        segTree[node] += (end - start + 1) * lazy[node];\n        if (start != end) {\n            lazy[2 * node + 1] += lazy[node];\n            lazy[2 * node + 2] += lazy[node];\n        }\n        lazy[node] = 0; \n    }\n\n    if (start >= l && end <= r) {\n        return segTree[node];\n    }\n\n    int mid = (start + end) / 2;\n    ll p1 = queryRange(segTree, lazy, 2 * node + 1, start, mid, l, r);\n    ll p2 = queryRange(segTree, lazy, 2 * node + 2, mid + 1, end, l, r);\n    return p1 + p2;\n}\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int>arr(n) ;\n        vector<int>mn(n),s(4*n) ;\n        for(int i =0;i<n;i++)arr[i] = i,mn[i] = max(0,i-1) ;\n        vector<ll>seg(4*n), lazy(4*n) ;\n        build(arr,seg,0,0,n-1) ;\n        build1(mn,s,0,0,n-1) ;\n        vector<int> ans ;\n        for(auto q:queries){\n            int st = q[0] ;\n            int en = q[1] ;\n            int mini = query(s,0,0,n-1,en,n-1) ;\n            if(mini>st){\n                ll dis1 = queryRange(seg,lazy,0,0,n-1,0,st)-queryRange(seg,lazy,0,0,n-1,0,st-1) ;\n                ll dis2 = queryRange(seg,lazy,0,0,n-1,0,en)-queryRange(seg,lazy,0,0,n-1,0,en-1) ;\n            \n                ll d = dis2-dis1-1 ;\n                updateRange(seg,lazy,0,0,n-1,en,n-1,-d) ;\n            }\n            update(s,0,0,n-1,en,st) ;\n            ll dist = queryRange(seg,lazy,0,0,n-1,0,n-1)-queryRange(seg,lazy,0,0,n-1,0,n-1-1) ;\n            ans.push_back(dist) ;\n        }\n        return ans ;\n\n    }\n};",
    "submit_ts": "1722742109",
    "subm_id": "1343761220"
}