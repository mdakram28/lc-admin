{
    "username": "martin0327",
    "submission": "struct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n\n  private:\n    int _n;\n    std::vector<int> parent_or_size;\n};\n\nusing ll = long long;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing pii = pair<ll,ll>;\nusing vp = vector<pii>;\nusing ti3 = tuple<ll,ll,ll>;\nusing vti3 = vector<ti3>;\nusing vs = vector<string>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T>\nusing max_pq = priority_queue<T>;\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& qr) {\n        dsu d(n);\n        map<int,int> mxmap;\n        for (int i=0; i<n; i++) mxmap[i] = i;\n        vector<int> res;\n        int ans = n-1;\n        auto merge = [&] (int i, int j) {\n            i = d.leader(i);\n            j = d.leader(j);\n            if (d.same(i,j)) {\n                return mxmap[d.leader(i)];\n            }\n            int sz1 = d.size(i);\n            int sz2 = d.size(j);\n            if (sz1 > 1) ans += sz1-1;\n            if (sz2 > 1) ans += sz2-1;\n            int mxi = mxmap[i];\n            int mxj = mxmap[j];\n            d.merge(i,j);\n            int l = d.leader(i);\n            int sz = d.size(l);\n            ans -= sz - 1;\n            mxmap[l] = max(mxi,mxj);\n            return mxmap[l];\n        };\n        for (auto uv : qr) {\n            int u = uv[0], v = uv[1];\n            u++;\n            int tg = mxmap[d.leader(v)];\n            while (u < tg) {\n                u = merge(u,u+1);\n            }\n            res.push_back(ans);\n            // debug(d.groups());\n        }\n        return res;\n    }\n};",
    "submit_ts": "1722740787",
    "subm_id": "1343728726"
}