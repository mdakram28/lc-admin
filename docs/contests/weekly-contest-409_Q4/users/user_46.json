{
    "username": "lucifer1006",
    "submission": "int lowbit(int x) { return x & -x; }\n\nclass FenwickTree {\nprivate:\n  vector<int> sums_;\n\npublic:\n  FenwickTree(int n) : sums_(n + 1, 0) {}\n\n  void update(int i, int delta) {\n    while (i < sums_.size()) {\n      sums_[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  int query(int i) const {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums_[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n};\n\nclass Solution {\npublic:\n  vector<int> numberOfAlternatingGroups(vector<int> &colors,\n                                        vector<vector<int>> &queries) {\n    set<pair<int, int>> segs; // (start_pos, end_pos)\n    int n = colors.size();\n\n    FenwickTree ft(n), fts(n);\n\n    int l = 0;\n    for (int r = 1; r < n; ++r) {\n      if (colors[r] == colors[r - 1]) {\n        segs.insert({l, r - 1});\n        ft.update(r - l, 1);\n        fts.update(r - l, r - l);\n        l = r;\n      }\n    }\n    segs.insert({l, n - 1});\n    ft.update(n - l, 1);\n    fts.update(n - l, n - l);\n\n    vector<int> ans;\n    for (auto &q : queries) {\n      if (q.size() == 2) {\n        // is query\n        int th = q[1];\n          \n        if (colors[0] != colors[n - 1] && ((segs.size() == 1 || (segs.size() == 2 && n % 2 == 0)))) {\n          // special case: full loop\n          ans.push_back(n);\n          continue;\n        }\n\n        int num_groups = 0, sum_groups = 0;\n        num_groups = ft.query(n) - ft.query(th - 1);\n        sum_groups = fts.query(n) - fts.query(th - 1);\n          \n\n        // Handle first and last\n        if (segs.size() >= 2 && colors[0] != colors[n - 1]) {\n          if (segs.begin()->second - segs.begin()->first + 1 >= th) {\n            num_groups--;\n            sum_groups -= segs.begin()->second - segs.begin()->first + 1;\n          }\n\n          if (segs.rbegin()->second - segs.rbegin()->first + 1 >= th) {\n            num_groups--;\n            sum_groups -= segs.rbegin()->second - segs.rbegin()->first + 1;\n          }\n\n            int combined_length = segs.begin()->second - segs.begin()->first +\n                                  1 + segs.rbegin()->second -\n                                  segs.rbegin()->first + 1;\n            if (combined_length >= th) {\n              num_groups++;\n              sum_groups += combined_length;\n            }\n        }\n\n        ans.push_back(sum_groups - num_groups * (th - 1));\n      } else {\n        // is update\n        int idx = q[1], c = q[2];\n        if (c == colors[idx]) {\n          continue;\n        }\n        colors[idx] = c;\n\n        // Find the group idx belongs to\n        auto it = segs.lower_bound({idx, idx});\n        if (it == segs.end() || it->first > idx) {\n          it--;\n        }\n\n        int l = it->first, r = it->second;\n        vector<pair<int, int>> to_insert, to_erase;\n        to_erase.push_back(*it);\n        if (l == r) {\n          // Try merge with left and right\n          if (it != segs.begin()) {\n            to_erase.push_back(*prev(it));\n            l = prev(it)->first;\n          }\n\n          if (*it != *segs.rbegin()) {\n            to_erase.push_back(*next(it));\n            r = next(it)->second;\n          }\n\n          to_insert.push_back({l, r});\n        } else if (l == idx) {\n          // Split and merge with left\n          if (it != segs.begin()) {\n            to_erase.push_back(*prev(it));\n            l = prev(it)->first;\n          }\n          to_insert.push_back({idx + 1, r});\n          to_insert.push_back({l, idx});\n        } else if (r == idx) {\n          // Split and merge with right\n          if (*it != *segs.rbegin()) {\n            to_erase.push_back(*next(it));\n            r = next(it)->second;\n          }\n          to_insert.push_back({l, idx - 1});\n          to_insert.push_back({idx, r});\n        } else {\n          // Split into 3 parts\n          to_insert.push_back({l, idx - 1});\n          to_insert.push_back({idx, idx});\n          to_insert.push_back({idx + 1, r});\n        }\n\n        for (auto &p : to_erase) {\n          ft.update(p.second - p.first + 1, -1);\n          fts.update(p.second - p.first + 1, -(p.second - p.first + 1));\n          segs.erase(p);\n        }\n\n        for (auto &p : to_insert) {\n          ft.update(p.second - p.first + 1, 1);\n          fts.update(p.second - p.first + 1, p.second - p.first + 1);\n          segs.insert(p);\n        }\n      }\n        \n      // // debug segs\n      // for (auto [l, r] : segs) {\n      //     cout << \"(\" << l << \",\" << r << \"), \";\n      // }\n      // cout << endl;\n    }\n\n    return ans;\n  }\n};",
    "submit_ts": "1722742764",
    "subm_id": "552346737"
}