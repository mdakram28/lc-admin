{
    "username": "user5860c",
    "submission": "typedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double, double> pdd;\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define FOR(i, to) for (int i = 0; i < (to); ++i)\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<pair<int, int> > vpi;\ntypedef pair<ll,ll> pll;\ntypedef vector<string> vs;\n\n#define MOD 1000000007\n\ntemplate<int MODX>\nstruct ModInt {\n  unsigned x;\n  ModInt() : x(0) { }\n  ModInt(signed sig) : x(((sig%MODX)+MODX)%MODX) {  }\n  ModInt(signed long long sig) : x(((sig%MODX)+MODX)%MODX) { }\n  int get() const { return (int)x; }\n  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }\n \n  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MODX) x -= MODX; return *this; }\n  ModInt &operator-=(ModInt that) { if ((x += MODX - that.x) >= MODX) x -= MODX; return *this; }\n  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MODX; if (x < 0) x += MODX; return *this; }\n  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MODX - 2); }\n \n  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n  bool operator<(ModInt that) const { return x < that.x; }\n  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }\n};\ntypedef ModInt<MOD> mint;\n\nmint best[303][401];\n\nclass Solution {\npublic:\n    int numberOfPermutations(int n, vector<vector<int>>& r) {\n\n        best[0][0] = 1;\n        map<int,int> h;\n\n        for (auto &x : r) {\n            h[x[0]] = x[1];\n            if (x[0] == 0 && x[1] != 0) return 0;\n        }\n        for (int i=1;i<n;++i) {\n            for (int j=0;j<=400;++j) {\n                if (best[i-1][j].x == 0) continue;\n                for (int k=0;k<=i;++k) {\n                    if (j + k <= 400) {\n                        best[i][j+k] += best[i-1][j];\n                    }\n                }\n            }\n            if (h.find(i) != h.end()) {\n                FOR(j, 401) {\n                    if (h[i] != j) {\n                        best[i][j] = 0;\n                    }\n                }\n            }\n        }\n\n        mint ret = 0;\n        FOR(j, 401) {\n            ret += best[n-1][j];\n        }\n        FOR(i, n) {\n          FOR(j, 401) {\n            best[i][j] = 0;\n          }\n        }\n        return ret.x;\n        \n    }\n};",
    "submit_ts": "1719067306",
    "subm_id": "1296718966"
}