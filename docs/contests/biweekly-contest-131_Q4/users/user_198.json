{
    "username": "Rudranil_Acharya",
    "submission": "class Solution {\npublic:\n    class SGtree{\npublic:\n    vector<int> seg;\npublic:\n\n    SGtree(int n){\n        seg.resize(4*n+1);\n    }\n    void combine(int id){\n        seg[id]=max(seg[2*id],seg[(2*id)+1]);\n        return;\n    }\n    void build(int id,int l,int r,vector<int> &a){\n        if(r-l==1){\n\n            seg[id]=a[l];\n            return;\n        }\n\n        int mid=((int)l+r)/2;\n\n        build(2*id,l,mid,a);\n        build(2*id+1,mid,r,a);\n\n\n        combine(id);\n\n        return;\n    }\n\n    int query(int id,int x,int y,int l,int r){\n     if(l>=x and r<=y){\n\n        return seg[id];\n    }\n    else if(l>=y or r<=x){\n\n\n        int use=0;\n        return use;\n    }\n\n    int mid=((int)l+r)/2;\n\n\n    int left=query(2*id,x,y,l,mid);\n    int right=query(2*id+1,x,y,mid,r);\n    return max(left,right);\n}\n\nvoid update(int id,int l,int r,int index,int value){\n\n   if(r<=index or l>index){\n    return;\n}\nif((r-l)==1){\n    if(index==l){\n        seg[id]=value;\n    }\n    return;\n\n}\n\nint mid=(int)l+r;\nmid=mid/2;\nupdate(2*id,l,mid,index,value);\nupdate((2*id)+1,mid,r,index,value);\ncombine(id);\nreturn;\n}\n\n};\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        multiset<int> s;\n        set<int> points;\n        points.insert(0);\n        int maxn=(int)1e5;\n        SGtree s1(maxn);\n        vector<int> a(maxn,0);\n        s1.build(1,0,maxn,a);\n            vector<bool> v;\n        for(int i=0;i<queries.size();i++){\n            int type=queries[i][0];\n            if(type==1){\n                int x=queries[i][1];\n                //build the obstacle\n                \n                auto it=points.lower_bound(x);\n                it--;\n                int prev=*it;\n                //now gap will come into play\n                int new_gap1=x-prev;\n                s1.update(1,0,maxn,x,new_gap1);\n                auto it2=points.upper_bound(x);\n                if(it2!=points.end()){\n                    int after=*it2;\n                    int new_gap2=after-x;\n                    s1.update(1,0,maxn,after,new_gap2);\n                    \n                    \n                    \n                }\n                \n            \n                \n                \n                points.insert(x);\n                \n            }\n            else{\n                int x=queries[i][1];\n                int sz=queries[i][2];\n                if(points.size()==1){\n                    if(sz<=x){\n                        v.push_back(true);\n                    }\n                    else{\n                        v.push_back(false);\n                    }\n                    continue;\n                }\n                int last=*points.rbegin();\n                if(x>=last){\n                    int mb=x-last;\n                    if(mb>=sz){\n                        v.push_back(true);\n                        continue;\n                    }\n                }\n                auto it=points.lower_bound(x);\n                // if(it==points.end()){\n                //     cout<<\"ho \"<<endl;\n                // }\n                it--;\n                int dist=x-*it;\n                if(dist>=sz){\n                    v.push_back(true);\n                    continue;\n                }\n                int check=s1.query(1,0,x+1,0,maxn);\n                if(check>=sz){\n                    v.push_back(true);\n                }\n                else{\n                    v.push_back(false);\n                }\n                \n                \n            }\n        }\n        \n        return v;\n        \n    }\n};",
    "submit_ts": 1716650149.0
}