{
    "username": "Sariabell",
    "submission": "using LL = long long;\n\n// \u524d\u7f00\u548c\ntemplate<typename T>\nvector<T> to_prefix(const vector<T>& v) {\n    vector<T> ans(v.size() + 1);\n    for (int i = 0;i < v.size();++i)\n        ans[i + 1] = ans[i] + v[i];\n    return ans;\n}\n\n// [l, r)\ntemplate<typename T>\nT range_sum(const vector<T>& prefix, int l, int r) {\n    return prefix[r] - prefix[l];\n}\n\nclass Solution {\npublic:\n    struct SegTreeNode {\n        int val;\n        int min;\n    };\n\n    vector<SegTreeNode> nodes;\n\n    void build(int o, int l, int r, vector<int>& v) {\n        if (l == r) {\n            nodes[o].val = v[l - 1];\n        }\n        else {\n            int mid = l + (r - l) / 2;\n            build(o * 2, l, mid, v);\n            build(o * 2 + 1, mid + 1, r, v);\n        }\n\n        maintain(o, l, r);\n    }\n\n    void maintain(int o, int l, int r) {\n        if (l == r) {\n            nodes[o].min = nodes[o].val;\n        }\n        else {\n            nodes[o].min = min(nodes[o * 2].min, nodes[o * 2 + 1].min);\n        }\n    }\n\n    int range_min(int o, int l, int r, int ql, int qr) {\n        if (qr < l || r < ql) return INT_MAX;\n        if (ql <= l && r <= qr) return nodes[o].min;\n        int mid = l + (r - l) / 2;\n        return min(range_min(o * 2, l, mid, ql, qr), range_min(o * 2 + 1, mid + 1, r, ql, qr));\n    }\n\n    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n        LL n = s.size();\n        LL l = 0;\n        LL n1 = 0;\n        LL n0 = 0;\n        vector<int> vl(n);\n        nodes.resize(4 * n);\n\n        vector<LL> vans(n);\n\n        for (LL r = 0; r < n; ++r) {\n            if (s[r] == '0')\n                ++n0;\n            else\n                ++n1;\n\n            while (k < n0 && k < n1) {\n                if (s[l] == '0')\n                    --n0;\n                else\n                    --n1;\n                ++l;\n            }\n            vl[r] = l;\n            vans[r] = r - l + 1;\n        }\n\n        build(1, 1, n, vl);\n\n        auto prefix = to_prefix(vans);\n\n        vector<LL> ans;\n        for (auto& q : queries) {\n            LL cans = 0;\n            for (LL r = q[0]; r <= q[1]; ++r) {\n                if (q[0] <= range_min(1, 1, n, r + 1, q[1] + 1)) {\n                    cans += range_sum(prefix, r, q[1] + 1);\n                    break;\n                } else {\n                    cans += r - max<LL>(q[0], vl[r]) + 1LL;\n                }\n            }\n            ans.push_back(cans);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1723953268",
    "subm_id": "556416528"
}