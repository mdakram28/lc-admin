{
    "username": "qb_2008",
    "submission": "class Solution {\npublic:\n    int max_dist_in_tree;\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        max_dist_in_tree = 0;\n        int height1 = getMinHeight(edges1);\n        int height2 = getMinHeight(edges2);\n        int d = height1 - 1 + height2 - 1 + 1;\n        return max(d, max_dist_in_tree);\n    }\n    \n    int getMinHeight(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vector<vector<int>> neighbor(n);\n        for (vector<int>& e : edges) {\n            neighbor[e[0]].push_back(e[1]);\n            neighbor[e[1]].push_back(e[0]);\n        }\n        // use 0 as root.\n        vector<int> height(n, 0);\n        vector<int> parent(n, -1);\n        int min_height = calHeight(0, neighbor, parent, height);\n        \n        // cal max dist in tree.\n        int m_dist_in_tree = getMaxDistInTree(0, neighbor, parent, height);\n        max_dist_in_tree = max(max_dist_in_tree, m_dist_in_tree);\n        \n        // try using child of 0 as new root. See if will have better height.\n        int cur_root = 0;\n        int other_dist = 0;\n        //printf(\"n = %d\\n\", n);\n        //printf(\"root = 0, min_height = %d\\n\", min_height);\n        while (true) {\n            // try children of cur_root.\n            vector<int> hs;\n            int max_sub_h = -1;\n            int max_sub_h_node = -1;\n            for (int n : neighbor[cur_root]) {\n                if (n == parent[cur_root]) {\n                    continue;\n                }\n                hs.push_back(height[n]);\n                if (height[n] > max_sub_h) {\n                    max_sub_h = height[n];\n                    max_sub_h_node = n;\n                }\n            }\n            sort(hs.begin(), hs.end());\n            if (hs.empty()) {\n                break;\n            }\n            int h1 = hs.back();\n            int h2 = other_dist;\n            if (hs.size() > 1) {\n                h2 = max(other_dist, hs[hs.size() - 2]);\n            }\n            int top_h = h2 + 2;\n            int new_h = max(h1, top_h);\n            if (new_h >= min_height) {\n                break;\n            }\n            min_height = new_h;\n            other_dist = h2 + 1;\n            cur_root = max_sub_h_node;\n            //printf(\"cur_root = %d, min_height = %d\\n\", cur_root, min_height);\n        }\n        return min_height;\n    }\n    \n    int calHeight(int root, const vector<vector<int>>& neighbor, vector<int>& parent, vector<int>& height) {\n        int h = 0;\n        for (int n : neighbor[root]) {\n            if (n == parent[root]) {\n                continue;\n            }\n            parent[n] = root;\n            int cur_h = calHeight(n, neighbor, parent, height);\n            h = max(h, cur_h);\n        }\n        height[root] = h + 1;\n        return height[root];\n    }\n    \n    int getMaxDistInTree(int root, const vector<vector<int>>& neighbor, vector<int>& parent, vector<int>& height) {\n        int res = 0;\n        vector<int> hs;\n        for (int n : neighbor[root]) {\n            if (n == parent[root]) {\n                continue;\n            }\n            hs.push_back(height[n]);\n            int d = getMaxDistInTree(n, neighbor, parent, height);\n            res = max(res, d);\n        }\n        if (hs.size() == 1) {\n            res = max(res, hs[0]);\n        } else if (hs.size() > 1) {\n            sort(hs.begin(), hs.end());\n            int d = hs.back() + hs[hs.size() - 2];\n            res = max(res, d);\n        }\n        return res;\n    }\n};",
    "submit_ts": "1719718383",
    "subm_id": "1304415845"
}