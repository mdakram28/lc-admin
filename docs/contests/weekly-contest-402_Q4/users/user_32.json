{
    "username": "OTTFF",
    "submission": "template<typename T> struct GetZero { T operator()() const { return T(0); } };\ntemplate<typename T,\n         typename OpPlus=plus<T>,typename OpMinus=minus<T>,\n         typename Zero=GetZero<T> >\nstruct BIT {\n  static int lowbit(int x) { return x&(-x); }\n  constexpr static OpPlus opp{};\n  constexpr static OpMinus opm{};\n  constexpr static Zero zero{};\n  int n;\n  vector<T> tree; // tree[i] -> sum of [i-lowbit(i)+1,i]\n  BIT(int n_=0):n(n_),tree(n+1,zero()) {}\n  void init(int n_) { n=n_; tree.assign(n+1,zero()); }\n  void init(const vector<T> &vec) { // v[0 ~ n_-1]\n    n=vec.size();\n    vector<T> tmp(n+1,zero());\n    for(int i=1;i<=n;i++) tmp[i]=opp(tmp[i-1],vec[i-1]);\n    for(int i=1;i<=n;i++) tree[i]=opm(tmp[i],tmp[i-lowbit(i)]);\n  }\n  void add(int p,T v) { \n      // cout << \"add \" << p << ' ' << v << endl;\n    for(;p<=n;p+=lowbit(p)) tree[p]=opp(tree[p],v);\n  }\n  T sum(int p) {\n    T ans=zero();\n    for(;p;p-=lowbit(p)) ans=opp(ans,tree[p]);\n    return ans;\n  }\n  T sum(int l,int r) { return opm(sum(r),sum(l-1)); }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& qs) {\n        int n = a.size();\n        \n        BIT<int> bit(n);\n        \n        for (int i = 1; i < n - 1; i++) {\n            if (a[i] > a[i - 1] && a[i] > a[i + 1]) {\n                bit.add(i, 1);\n            }\n        }\n        \n        vector<int> ans;\n        \n        for (auto q : qs) {\n            if (q[0] == 1) { // query\n                int l = q[1], r = q[2];\n                l++;\n                r--;\n                if (l > r) ans.push_back(0);\n                else ans.push_back(bit.sum(l, r));\n            } else { // q[0] == 2 change\n                int p = q[1], v = q[2];\n                for (int i = max(1, p - 1); i <= min(n - 2, p + 1); i++) {\n                    if (a[i] > a[i - 1] && a[i] > a[i + 1]) {\n                        bit.add(i, -1);\n                    }\n                }\n                a[p] = v;\n                for (int i = max(1, p - 1); i <= min(n - 2, p + 1); i++) {\n                    if (a[i] > a[i - 1] && a[i] > a[i + 1]) {\n                        bit.add(i, 1);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718506096.0
}