{
    "username": "tanakat01",
    "submission": "import types\n\n_atcoder_code = \"\"\"\n# Python port of AtCoder Library.\n\n__version__ = '0.0.1'\n\"\"\"\n\natcoder = types.ModuleType('atcoder')\nexec(_atcoder_code, atcoder.__dict__)\n\n_atcoder__bit_code = \"\"\"\ndef _ceil_pow2(n: int) -> int:\n    x = 0\n    while (1 << x) < n:\n        x += 1\n\n    return x\n\n\ndef _bsf(n: int) -> int:\n    x = 0\n    while n % 2 == 0:\n        x += 1\n        n //= 2\n\n    return x\n\"\"\"\n\natcoder._bit = types.ModuleType('atcoder._bit')\nexec(_atcoder__bit_code, atcoder._bit.__dict__)\n\n\n_atcoder_segtree_code = \"\"\"\nimport typing\n\n# import atcoder._bit\n\n\nclass SegTree:\n    def __init__(self,\n                 op: typing.Callable[[typing.Any, typing.Any], typing.Any],\n                 e: typing.Any,\n                 v: typing.Union[int, typing.List[typing.Any]]) -> None:\n        self._op = op\n        self._e = e\n\n        if isinstance(v, int):\n            v = [e] * v\n\n        self._n = len(v)\n        self._log = atcoder._bit._ceil_pow2(self._n)\n        self._size = 1 << self._log\n        self._d = [e] * (2 * self._size)\n\n        for i in range(self._n):\n            self._d[self._size + i] = v[i]\n        for i in range(self._size - 1, 0, -1):\n            self._update(i)\n\n    def set(self, p: int, x: typing.Any) -> None:\n        assert 0 <= p < self._n\n\n        p += self._size\n        self._d[p] = x\n        for i in range(1, self._log + 1):\n            self._update(p >> i)\n\n    def get(self, p: int) -> typing.Any:\n        assert 0 <= p < self._n\n\n        return self._d[p + self._size]\n\n    def prod(self, left: int, right: int) -> typing.Any:\n        assert 0 <= left <= right <= self._n\n        sml = self._e\n        smr = self._e\n        left += self._size\n        right += self._size\n\n        while left < right:\n            if left & 1:\n                sml = self._op(sml, self._d[left])\n                left += 1\n            if right & 1:\n                right -= 1\n                smr = self._op(self._d[right], smr)\n            left >>= 1\n            right >>= 1\n\n        return self._op(sml, smr)\n\n    def all_prod(self) -> typing.Any:\n        return self._d[1]\n\n    def max_right(self, left: int,\n                  f: typing.Callable[[typing.Any], bool]) -> int:\n        assert 0 <= left <= self._n\n        assert f(self._e)\n\n        if left == self._n:\n            return self._n\n\n        left += self._size\n        sm = self._e\n\n        first = True\n        while first or (left & -left) != left:\n            first = False\n            while left % 2 == 0:\n                left >>= 1\n            if not f(self._op(sm, self._d[left])):\n                while left < self._size:\n                    left *= 2\n                    if f(self._op(sm, self._d[left])):\n                        sm = self._op(sm, self._d[left])\n                        left += 1\n                return left - self._size\n            sm = self._op(sm, self._d[left])\n            left += 1\n\n        return self._n\n\n    def min_left(self, right: int,\n                 f: typing.Callable[[typing.Any], bool]) -> int:\n        assert 0 <= right <= self._n\n        assert f(self._e)\n\n        if right == 0:\n            return 0\n\n        right += self._size\n        sm = self._e\n\n        first = True\n        while first or (right & -right) != right:\n            first = False\n            right -= 1\n            while right > 1 and right % 2:\n                right >>= 1\n            if not f(self._op(self._d[right], sm)):\n                while right < self._size:\n                    right = 2 * right + 1\n                    if f(self._op(self._d[right], sm)):\n                        sm = self._op(self._d[right], sm)\n                        right -= 1\n                return right + 1 - self._size\n            sm = self._op(self._d[right], sm)\n\n        return 0\n\n    def _update(self, k: int) -> None:\n        self._d[k] = self._op(self._d[2 * k], self._d[2 * k + 1])\n\"\"\"\n\natcoder.segtree = types.ModuleType('atcoder.segtree')\natcoder.segtree.__dict__['atcoder'] = atcoder\natcoder.segtree.__dict__['atcoder._bit'] = atcoder._bit\nexec(_atcoder_segtree_code, atcoder.segtree.__dict__)\nSegTree = atcoder.segtree.SegTree\n\nfrom typing import List\n# from atcoder.segtree import SegTree\nclass Solution:\n    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        MOD = 1000000007\n        # !l!r, !rl, r!l, rl\n        def op(a, b):\n            # don't use leftmost and rightmost\n            ans0 = max(max(0, b[0], b[1]), a[0] + max(b[0], b[1]), a[2] + b[0])\n            # use leftmost, no rightmost\n            ans1 = max(max(0, a[1], a[3]), a[1] + max(b[0], b[1]), a[3] + b[0])\n            # no leftmost, use rightmost\n            ans2 = max(max(0, b[2], b[3]), b[2] + max(a[0], a[2]), b[3] + a[0])\n            # use leftmost, use rightmost\n            ans3 = max(max(0, a[1], a[3]), a[3] + b[2], a[1] + b[3])\n            #print(f'op({(a, b)}) = {(ans0, ans1, ans2, ans3)}')\n            return (ans0, ans1, ans2, ans3)\n        st = SegTree(op=op, e = (0, 0, 0, 0), v = [(0, 0, 0, nums[i]) for i in range(n)])\n        ans = 0\n        #print(f'st={[st.get(i) for i in range(n)]}, all_prod={st.all_prod()}')\n        for pos, x in queries:\n            st.set(pos, (0, 0, 0, x))\n            #print(f'st={[st.get(i) for i in range(n)]}, all_prod={st.all_prod()}')\n            ans = (ans + max(st.all_prod())) % MOD\n        return ans            \n",
    "submit_ts": "1716693120",
    "subm_id": "1268075966"
}