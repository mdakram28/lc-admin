{
    "username": "yadavdipesh",
    "submission": "class Solution {\n    public long countSubarrays(int[] nums, int k) {\n        int n = nums.length;\n        Integer[] arr = new Integer[n];\n        Arrays.setAll(arr , i -> nums[i]);\n        SegTree st = new SegTree<>(arr , (A , B) -> A & B , Integer.MAX_VALUE);\n        \n        Set<Integer> set = new HashSet<>();\n        for(int i = 0 ; i < 31 ; i++){\n            int x = (k & (1 << i));\n            if(x > 0){\n                set.add(i);\n            }\n        }\n        \n        long ans = 0;\n        int l = -1;\n        int first = -1;\nol:     for(int r = 0 ; r < n ; r++){\n            int z = nums[r];\n            for(int i : set){\n                int y = z & (1 << i);\n                if(y == 0){\n                    if(l == -1) continue ol;\n                    Integer prod = (Integer)st.prod(l , r);\n                    \n                    if((int)prod != k){\n                        l = -1;\n                        continue ol;\n                    }\n                    \n                    for(int x = l ; x < r ; x++){\n                        int L = x-1 , R = r;\n                        \n                        while(R - L > 1){\n                            int m = (L + R) / 2;\n                            \n                            Integer Val = (Integer)st.prod(x , m+1);\n                            // System.out.println(x + \" \" + m + \" \" + Val);\n                            if((int)Val != k){\n                                L = m;\n                            }\n                            else R = m;\n                        }\n                        if(R == x && nums[x] != k) continue;\n                        // System.out.println(\"later \" + \" \" + R + \" \" + r + \" \" + st.prod(x , R+1));\n                        if((Integer)st.prod(x , R+1) != (int)k) continue;\n                        ans += r - R;\n                    }\n                    \n                    l = -1;\n                    continue ol;\n                }\n            }\n            \n            if(l == -1){\n                l = r;\n            }\n        }\n        \n        // System.out.println(ans + \" \" + l);\n        if(l != -1){\n            Integer AN = (Integer)st.prod(l , n);\n            if((int)AN != k){\n                \n            }\n            else{\n                for(int x = l ; x < n ; x++){\n                    int L = x-1 , R = n;\n\n                    while(R - L > 1){\n                        int m = (L + R) / 2;\n\n                        Integer Val = (Integer)st.prod(x , m+1);\n                        if(Val != (int)k){\n                            L = m;\n                        }\n                        else R = m;\n                    }\n\n                    // System.out.println(\"R \" + \" \" + n + \" \" + R);\n                    if(R == x && nums[x] != k) continue;\n                    // if((Integer)st.prod(x , R+1) != (int)k) continue;\n                    ans += n - R;\n                }\n            }\n        }\n        return ans;        \n    }\n}\n\nclass SegTree<S> {\n    final int MAX;\n\n    final int N;\n    final java.util.function.BinaryOperator<S> op;\n    final S E;\n\n    final S[] data;\n\n    @SuppressWarnings(\"unchecked\")\n    public SegTree(int n, java.util.function.BinaryOperator<S> op, S e) {\n        this.MAX = n;\n        int k = 1;\n        while (k < n) k <<= 1;\n        this.N = k;\n        this.E = e;\n        this.op = op;\n        this.data = (S[]) new Object[N << 1];\n        java.util.Arrays.fill(data, E);\n    }\n\n    public SegTree(S[] dat, java.util.function.BinaryOperator<S> op, S e) {\n        this(dat.length, op, e);\n        build(dat);\n    }\n\n    private void build(S[] dat) {\n        int l = dat.length;\n        System.arraycopy(dat, 0, data, N, l);\n        for (int i = N - 1; i > 0; i--) {\n            data[i] = op.apply(data[i << 1 | 0], data[i << 1 | 1]);\n        }\n    }\n\n    public void set(int p, S x) {\n        exclusiveRangeCheck(p);\n        data[p += N] = x;\n        p >>= 1;\n        while (p > 0) {\n            data[p] = op.apply(data[p << 1 | 0], data[p << 1 | 1]);\n            p >>= 1;\n        }\n    }\n\n    public S get(int p) {\n        exclusiveRangeCheck(p);\n        return data[p + N];\n    }\n\n    public S prod(int l, int r) {\n        if (l > r) {\n            throw new IllegalArgumentException(\n                String.format(\"Invalid range: [%d, %d)\", l, r)\n            );\n        }\n        inclusiveRangeCheck(l);\n        inclusiveRangeCheck(r);\n        S sumLeft = E;\n        S sumRight = E;\n        l += N; r += N;\n        while (l < r) {\n            if ((l & 1) == 1) sumLeft = op.apply(sumLeft, data[l++]);\n            if ((r & 1) == 1) sumRight = op.apply(data[--r], sumRight);\n            l >>= 1; r >>= 1;\n        }\n        return op.apply(sumLeft, sumRight);\n    }\n\n    public S allProd() {\n        return data[1];\n    }\n\n    public int maxRight(int l, java.util.function.Predicate<S> f) {\n        inclusiveRangeCheck(l);\n        if (!f.test(E)) {\n            throw new IllegalArgumentException(\"Identity element must satisfy the condition.\");\n        }\n        if (l == MAX) return MAX;\n        l += N;\n        S sum = E;\n        do {\n            l >>= Integer.numberOfTrailingZeros(l);\n            if (!f.test(op.apply(sum, data[l]))) {\n                while (l < N) {\n                    l = l << 1;\n                    if (f.test(op.apply(sum, data[l]))) {\n                        sum = op.apply(sum, data[l]);\n                        l++;\n                    }\n                }\n                return l - N;\n            }\n            sum = op.apply(sum, data[l]);\n            l++;\n        } while ((l & -l) != l);\n        return MAX;\n    }\n\n    public int minLeft(int r, java.util.function.Predicate<S> f) {\n        inclusiveRangeCheck(r);\n        if (!f.test(E)) {\n            throw new IllegalArgumentException(\"Identity element must satisfy the condition.\");\n        }\n        if (r == 0) return 0;\n        r += N;\n        S sum = E;\n        do {\n            r--;\n            while (r > 1 && (r & 1) == 1) r >>= 1;\n            if (!f.test(op.apply(data[r], sum))) {\n                while (r < N) {\n                    r = r << 1 | 1;\n                    if (f.test(op.apply(data[r], sum))) {\n                        sum = op.apply(data[r], sum);\n                        r--;\n                    }\n                }\n                return r + 1 - N;\n            }\n            sum = op.apply(data[r], sum);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n    private void exclusiveRangeCheck(int p) {\n        if (p < 0 || p >= MAX) {\n            throw new IndexOutOfBoundsException(\n                String.format(\"Index %d out of bounds for the range [%d, %d).\", p, 0, MAX)\n            );\n        }\n    }\n\n    private void inclusiveRangeCheck(int p) {\n        if (p < 0 || p > MAX) {\n            throw new IndexOutOfBoundsException(\n                String.format(\"Index %d out of bounds for the range [%d, %d].\", p, 0, MAX)\n            );\n        }\n    }\n\n    /* // **************** DEBUG **************** //\n\n    private int indent = 6;\n\n    public void setIndent(int newIndent) {\n        this.indent = newIndent;\n    }\n\n    @Override\n    public String toString() {\n        return toSimpleString();\n    }\n\n    public String toDetailedString() {\n        return toDetailedString(1, 0);\n    }\n\n    private String toDetailedString(int k, int sp) {\n        if (k >= N) return indent(sp) + data[k];\n        String s = \"\";\n        s += toDetailedString(k << 1 | 1, sp + indent);\n        s += \"\\n\";\n        s += indent(sp) + data[k];\n        s += \"\\n\";\n        s += toDetailedString(k << 1 | 0, sp + indent);\n        return s;\n    }\n\n    private static String indent(int n) {\n        StringBuilder sb = new StringBuilder();\n        while (n --> 0) sb.append(' ');\n        return sb.toString();\n    }\n\n    public String toSimpleString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append('[');\n        for (int i = 0; i < N; i++) {\n            sb.append(data[i + N]);\n            if (i < N - 1) sb.append(',').append(' ');\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n    \n    */\n}",
    "submit_ts": "1720280891",
    "subm_id": "1311805734"
}