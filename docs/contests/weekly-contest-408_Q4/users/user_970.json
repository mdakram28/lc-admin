{
    "username": "shubhamrawat2894",
    "submission": "class Circle {\npublic:\n    int cx, cy, r;\n};\n\nbool overlap(const Circle& a, const Circle& b) {\n    long long dx = a.cx - b.cx;\n    long long dy = a.cy - b.cy;\n    long long distanceSq = dx * dx + dy * dy;\n    long long radiusSum = a.r + b.r;\n    return distanceSq <= radiusSum * radiusSum;\n}\n\nbool touchesLeftBorder(const Circle& a) {\n    return a.cx - a.r <= 0;\n}\n\nbool touchesRightBorder(const Circle& a, int X) {\n    return a.cx + a.r >= X;\n}\n\nbool touchesBottomBorder(const Circle& a) {\n    return a.cy - a.r <= 0;\n}\n\nbool touchesTopBorder(const Circle& a, int Y) {\n    return a.cy + a.r >= Y;\n}\n\nbool bfsTraversal(vector<vector<int>>& graph, int start, int end, int N) {\n    vector<bool> visited(N + 4, false);\n    queue<int> bfsQueue;\n    bfsQueue.push(start);\n    visited[start] = true;\n\n    while (!bfsQueue.empty()) {\n        int curr = bfsQueue.front();\n        bfsQueue.pop();\n\n        for (auto& neighbor : graph[curr]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                bfsQueue.push(neighbor);\n                if (neighbor == end) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n        vector<Circle> circlesstore(n);\n        for (int i = 0; i < n; i++) {\n            circlesstore[i].cx = circles[i][0];\n            circlesstore[i].cy = circles[i][1];\n            circlesstore[i].r = circles[i][2];\n        }\n\n        vector<vector<int>> graph(n + 4);\n        for (int i = 0; i < n; i++) {\n            if (touchesLeftBorder(circlesstore[i])) {\n                graph[n].push_back(i);\n                graph[i].push_back(n);\n            }\n            if (touchesRightBorder(circlesstore[i], X)) {\n                graph[n + 1].push_back(i);\n                graph[i].push_back(n + 1);\n            }\n            if (touchesBottomBorder(circlesstore[i])) {\n                graph[n + 2].push_back(i);\n                graph[i].push_back(n + 2);\n            }\n            if (touchesTopBorder(circlesstore[i], Y)) {\n                graph[n + 3].push_back(i);\n                graph[i].push_back(n + 3);\n            }\n            for (int j = i + 1; j < n; j++) {\n                if (overlap(circlesstore[i], circlesstore[j])) {\n                    graph[i].push_back(j);\n                    graph[j].push_back(i);\n                }\n            }\n        }\n        bool leftToRight = bfsTraversal(graph, n, n + 1, n);\n        bool bottomToTop = bfsTraversal(graph, n + 2, n + 3, n);\n        bool bottomToLeft = bfsTraversal(graph,n+2,n,n);\n        bool topToRight = bfsTraversal(graph,n+3,n+1,n);\n\n        if(leftToRight == false && bottomToTop == false && bottomToLeft == false && topToRight == false)    return true;\n        return false;\n    }\n};",
    "submit_ts": "1722138560",
    "subm_id": "1335793857"
}