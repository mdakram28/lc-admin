{
    "username": "leoyu0813",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        auto a = helper (edges1);\n        auto b = helper (edges2);\n        int ans = max (a, b);\n        ans = max (ans, 1 + (a+1)/2 + (b+1)/2);\n        return ans;\n    }\n\n    int helper (const vector<vector<int>>& edges)\n    {\n        if (edges.empty ())\n            return 0;\n        int n = edges.size () + 1;\n        vector <vector <int>> adj (n);\n        for (const vector <int>& e : edges)\n        {\n            adj [e[0]].push_back (e[1]);\n            adj [e[1]].push_back (e[0]);\n        }\n\n        auto temp = bfs_farthest_node (0, n, adj);\n        auto res = bfs_farthest_node (temp.first, n, adj);\n        // cout << temp.first << \" ~ \" << res.first << \" = \" << res.second << \"\\n\";\n        return res.second;\n    }\n\n    pair <int, int> bfs_farthest_node (int start, int n, const vector <vector <int>>& adj)\n    {\n        vector <bool> vis (n, false);\n        queue <pair <int, int>> q;\n        q.push ({start, 0});\n        vis [start] = true;\n        int farthest_node = start;\n        int max_distance = 0;\n        \n        while (q.size ())\n        {\n            auto [i, distance] = q.front ();\n            q.pop ();\n            for (int j : adj [i])\n            {\n                if (!vis[j])\n                {\n                    vis[j] = true;\n                    q.push ({j, distance + 1});\n                    \n                    if (distance + 1 > max_distance){\n                        max_distance = distance + 1;\n                        farthest_node = j;\n                    }\n                }\n            }\n        }\n        return {farthest_node, max_distance};\n    }\n\n};",
    "submit_ts": 1719719770.0
}