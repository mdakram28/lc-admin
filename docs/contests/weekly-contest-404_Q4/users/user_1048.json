{
    "username": "agrim07",
    "submission": "#define MOD 1000000007\n#define INF 1000000010\n#define endl \"\\n\"\n#define pb push_back\n#define ppb pop_back\n#define ff first\n#define ss second\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n\nclass Solution {\npublic:\n    int n, m;\n    vector<vector<int>> adj1, adj2, adj;\n    vector<int> dist;\n\n    // Centroid decomposition code attributed to https://usaco.guide/plat/centroid?lang=cpp\n\n    bool getDiameterPath(int vertex,\n                        int targetVertex,\n                        int parent,\n                        vector<int>& path)\n    {\n        if (vertex == targetVertex) {\n\n            path.push_back(vertex);\n            return true;\n        }\n\n        for (auto i : adj[vertex]) {\n            if (i == parent)\n                continue;\n            if (getDiameterPath(i, targetVertex,\n                                vertex, path)) {\n                path.push_back(vertex);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    void farthestNode(int vertex, int parent,\n                    int height, int& maxHeight,\n                    int& maxHeightNode)\n    {\n        if (height > maxHeight) {\n            maxHeight = height;\n            maxHeightNode = vertex;\n        }\n\n        for (auto i : adj[vertex]) {\n            if (i == parent)\n                continue;\n            farthestNode(i, vertex,\n                        height + 1,\n                        maxHeight,\n                        maxHeightNode);\n        }\n    }\n\n    int findCenter(int n)\n    {\n        int maxHeight = -1;\n        int maxHeightNode = -1;\n\n        farthestNode(0, -1, 0, maxHeight,\n                    maxHeightNode);\n\n        int leaf1 = maxHeightNode;\n        maxHeight = -1;\n        farthestNode(maxHeightNode,\n                    -1, 0, maxHeight,\n                    maxHeightNode);\n\n        int leaf2 = maxHeightNode;\n        vector<int> path;\n\n        getDiameterPath(leaf1, leaf2,\n                        -1, path);\n\n        int pathSize = path.size();\n\n\n\n        if (pathSize % 2) {\n            return path[pathSize / 2];\n        }\n        else {\n            return path[(pathSize - 1) / 2];\n            // cout << path[pathSize / 2]\n            //     << \", \"\n            //     << path[(pathSize - 1) / 2]\n            //     << endl;\n        }\n    }\n\n    void dfs(int u, int par = -1) {\n        for(auto &v: adj[u]) {\n            if(v == par)\n                continue;\n            dist[v] = dist[u] + 1;\n            dfs(v, u);\n        }\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        n = sz(edges1) + 1;\n        m = sz(edges2) + 1;\n\n        adj1.clear(); adj1.resize(n);\n        adj2.clear(); adj2.resize(m);\n\n        for(auto &edge: edges1) {\n            int u = edge[0], v = edge[1];\n\n            adj1[u].pb(v);\n            adj1[v].pb(u);\n        }\n\n        for(auto &edge: edges2) {\n            int u = edge[0], v = edge[1];\n            \n            adj2[u].pb(v);\n            adj2[v].pb(u);\n        }\n\n        adj = adj1;\n        int c1 = findCenter(0);\n\n        adj = adj2;\n        int c2 = findCenter(0) + n;\n\n        adj.clear(); adj.resize(n + m);\n        for(auto &edge: edges1) {\n            int u = edge[0], v = edge[1];\n\n            adj[u].pb(v);\n            adj[v].pb(u);\n        }\n\n        for(auto &edge: edges2) {\n            int u = edge[0], v = edge[1];\n\n            adj[u + n].pb(v + n);\n            adj[v + n].pb(u + n);\n        }\n\n        adj[c1].pb(c2);\n        adj[c2].pb(c1);\n\n        dist.clear(); dist.resize(n + m);\n        dfs(0);\n\n        int farthest = 0;\n        for(int i = 0; i < n + m; i++) {\n            if(dist[i] > dist[farthest]) {\n                farthest = i;\n            }\n        }\n\n        dist.clear(); dist.resize(n + m);\n        dfs(farthest);\n\n        int diameter = 0;\n        for(int i = 0; i < n + m; i++) {\n            diameter = max(diameter, dist[i]);\n        }\n\n        return diameter;        \n    }\n};",
    "submit_ts": 1719719001.0
}