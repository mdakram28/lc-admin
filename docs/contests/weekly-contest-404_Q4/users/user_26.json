{
    "username": "ryanguorocket",
    "submission": "typedef pair<int, int> pi;\n\nstruct Tree {\n    int n, lgv; // size, log val\n    vector<vector<int>> adj;\n    vector<vector<int>> sparse;\n    vector<int> par, dep, si;\n\n    Tree() {}\n    Tree(int nsi, vector<pi>& edges) {\n        n = nsi;\n        lgv = 32 - __builtin_clz(n); // floor(log_2(nsi)) + 1\n        adj.resize(n);\n        for(auto [i, j]: edges) {\n            adj[i].push_back(j);\n            adj[j].push_back(i);\n        }\n        sparse = vector<vector<int>>(lgv, vector<int>(n));\n        par.resize(n);\n        dep.resize(n);\n        si.resize(n);\n        root(0);\n    }\n\n    void root(int r) {\n        par[r] = -1;\n        dep[r] = 0;\n        dfs(r);\n        initSparse();\n    }\n    void dfs(int p) {\n        si[p] = 1;\n        for(int i: adj[p]) {\n            if(i == par[p]) continue;\n            par[i] = p;\n            dep[i] = dep[p] + 1;\n            dfs(i);\n            si[p] += si[i];\n        }\n    }\n    void initSparse() {\n        for(int i = 0; i < n; i++) sparse[0][i] = par[i];\n        for(int i = 1; i < lgv; i++) {\n            for(int j = 0; j < n; j++) {\n                int m = sparse[i - 1][j];\n                if(m == -1) continue;\n                sparse[i][j] = sparse[i - 1][m];\n            }\n        }\n    }\n\n    int kthAncestor(int p, int k) {\n        if(dep[p] < k) return -1; // ???\n        int ret = p;\n        for(int i = 0; i < lgv; i++) if(k & (1 << i)) ret = sparse[i][ret];\n        return ret;\n    }\n    int lca(int a, int b) {\n        if (dep[a] < dep[b]) swap(a, b);\n        int dd = dep[a] - dep[b];\n        for(int i = 0; i < lgv; i++) if(dd & (1 << i)) a = sparse[i][a];\n        if(a == b) return a;\n        for(int i = lgv - 1; i >= 0; i--) {\n            if(sparse[i][a] != sparse[i][b]) {\n                a = sparse[i][a];\n                b = sparse[i][b];\n            }\n        }\n        return par[a];\n    }\n    int dist(int a, int b) {\n        int lcav = lca(a, b);\n        return dep[a] + dep[b] - 2 * dep[lcav];\n    }\n};\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        auto dia = [&](int s, const vector<vector<int>>& edges) {\n            vector<pi> e;\n            for(int i = 0; i < s - 1; i++) {\n                int a = edges[i][0];\n                int b = edges[i][1];\n                e.push_back({a, b});\n            }\n            Tree ds(s, e);\n            ds.root(0);\n            int md = 0, mi = 0;\n            for(int i = 0; i < s; i++) {\n                if(ds.dep[i] > md) {\n                    md = ds.dep[i];\n                    mi = i;\n                }\n            }\n            //std::cout << \"???\" << md << \" \" << mi << \"\\n\";\n            ds.root(mi);\n            int ret = 0;\n            for(int i = 0; i < s; i++) {\n                ret = max(ret, ds.dep[i]);\n            }\n            return ret;\n        };\n        int v1 = dia(n, edges1);\n        int v2 = dia(m, edges2);\n        //cout << v1 << \" \" << v2 << \"\\n\";\n        int outp = (v1 + 1) / 2 + (v2 + 1) / 2 + 1;\n        outp = max(outp, v1);\n        outp = max(outp, v2);\n        return outp;\n    }\n};",
    "submit_ts": "1719715924",
    "subm_id": "1304350110"
}