{
    "username": "mhwg",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n/*\n\n\nYou are given an integer array rewardValues of length n, representing the values of rewards.\n\nInitially, your total reward x is 0, and all indices are unmarked. You are allowed to perform the following operation any number of times:\n\n    Choose an unmarked index i from the range [0, n - 1].\n    If rewardValues[i] is greater than your current total reward x, then add rewardValues[i] to x (i.e., x = x + rewardValues[i]), and mark the index i.\n\nReturn an integer denoting the maximum total reward you can collect by performing the operations optimally.\n\n \n\nExample 1:\n\nInput: rewardValues = [1,1,3,3]\n\nOutput: 4\n\nExplanation:\n\nDuring the operations, we can choose to mark the indices 0 and 2 in order, and the total reward will be 4, which is the maximum.\n\nExample 2:\n\nInput: rewardValues = [1,6,4,3,2]\n\nOutput: 11\n\nExplanation:\n\nMark the indices 0, 2, and 1 in order. The total reward will then be 11, which is the maximum.\n\n \n\nConstraints:\n\n    1 <= rewardValues.length <= 5 * 104\n    1 <= rewardValues[i] <= 5 * 104\n\n\n*/\nconstexpr int MV = 100000;\nclass Solution {\npublic:\n    int maxTotalReward(vector<int>& r) {\n        int n = r.size();\n        sort(r.begin(), r.end());\n        bitset<MV+1> dp;\n        dp[0] = 1;\n        for (int i = 0; i < n; ++i) {\n            // only flip bits at positions less then r[i]\n            int shift = ((MV+1)-r[i]);\n            dp |= ((dp << shift) >> shift) << r[i];\n        }\n        for (int v = MV; v >= 0; --v) {\n            if (dp[v] == 1) return v;\n        }\n        return 0;\n        \n    }\n};",
    "submit_ts": "1717902641",
    "subm_id": "1282311272"
}