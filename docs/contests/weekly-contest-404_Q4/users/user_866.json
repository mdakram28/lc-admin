{
    "username": "3n9ct6mjnp",
    "submission": "class Solution { \npublic: \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) { \n        int size1 = edges1.size() + 1; \n        int size2 = edges2.size() + 1; \n        vector<vector<int>> graph1(size1); \n        vector<vector<int>> graph2(size2); \n         \n        for (const auto& edge : edges1) { \n            graph1[edge[0]].push_back(edge[1]); \n            graph1[edge[1]].push_back(edge[0]); \n        } \n         \n        for (const auto& edge : edges2) { \n            graph2[edge[0]].push_back(edge[1]); \n            graph2[edge[1]].push_back(edge[0]); \n        } \n         \n        auto dfs = [&] (const vector<vector<int>>& graph, int start, int& furthestNode) { \n            int n = graph.size(); \n            vector<int> distance(n, -1); \n            function<void(int, int)> dfsVisit = [&] (int node, int dist) { \n                distance[node] = dist; \n                if (dist > distance[furthestNode]) { \n                    furthestNode = node; \n                } \n                for (int neighbor : graph[node]) { \n                    if (distance[neighbor] == -1) { \n                        dfsVisit(neighbor, dist + 1); \n                    } \n                } \n            }; \n            furthestNode = start; \n            dfsVisit(start, 0); \n            return distance[furthestNode]; \n        }; \n         \n        int node1 = 0; \n        dfs(graph1, 0, node1); \n        int diameter1 = dfs(graph1, node1, node1); \n         \n        int node2 = 0; \n        dfs(graph2, 0, node2); \n        int diameter2 = dfs(graph2, node2, node2); \n         \n        int minDiameter = max(diameter1, diameter2); \n        int half1 = (diameter1 + 1) / 2; \n        int half2 = (diameter2 + 1) / 2; \n        minDiameter = max(minDiameter, half1 + half2 + 1); \n         \n        return minDiameter; \n    } \n};",
    "submit_ts": 1719719885.0
}