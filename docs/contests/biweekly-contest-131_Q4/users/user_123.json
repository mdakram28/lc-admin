{
    "username": "MerryLeopard",
    "submission": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.TreeSet;\n\nclass Solution {\n    public List<Boolean> getResults(int[][] queries) {\n        int n=50001;\n        int[] arr=new int[n];\n        SegmentTreeRMQ tree=new SegmentTreeRMQ(arr,n);\n        TreeSet<Integer> set=new TreeSet<>();\n        set.add(0);\n        List<Boolean> list=new ArrayList<>();\n        for (int[] q:queries){\n            int x=q[1];\n            if (q[0]==1 && !set.contains(x)){\n                int prev=set.floor(x);\n                tree.update(0,0,n,x,x-prev,arr);\n                Integer next=set.ceiling(x);\n                if (next!=null){\n                    tree.update(0,0,n,next,next-x,arr);\n                }\n                set.add(x);\n            }\n            else{\n                int max=tree.query(0,0,n,0,x);\n                int cur=0;\n                int prev= set.floor(Math.max(x-1,0));\n                if (arr[x]==0)\n                    cur=x-prev;\n                    \n                max=Math.max(cur,max);\n                if (q[2]<=max || max==0 && q[2]<=x)\n                    list.add(true);\n                else list.add(false);\n            }\n        }\n        return list;\n    }\n}\nclass SegmentTreeRMQ\n{\n    int[] tree;\n    void build(int node,int start,int end,int a[])\n    {\n        if(start==end)\n        {\n            tree[node]=a[start];\n        }\n        else\n        {\n            int mid=(start+end)/2;\n            build(2*node+1,start,mid,a);\n            build(2*node+2,mid+1,end,a);\n            tree[node]=Math.max(tree[2*node+1],tree[2*node+2]);\n        }\n    }\n\n    void update(int node,int start,int end,int idx,int val,int a[])\n    {\n\n        if(start==end)\n        {\n            a[idx]=val;\n            tree[node]=val;\n        }\n\n        else\n        {\n            int mid=(start+end)/2;\n            if(idx>=start&&idx<=mid)\n            {\n                update(2*node+1,start,mid,idx,val,a);\n            }\n            else\n            {\n                update(2*node+2,mid+1,end,idx,val,a);\n            }\n            tree[node]=Math.max(tree[2*node+1],tree[2*node+2]);\n        }\n    }\n    int query(int node,int start,int end,int l,int r)\n    {\n        if(l>end||start>r)\n        {\n            return Integer.MIN_VALUE;\n        }\n        if(l<=start&&r>=end)\n        {\n            return tree[node];\n        }\n        int q1,q2;\n        int mid=(start+end)/2;\n        q1=query(2*node+1,start,mid,l,r);\n        q2=query(2*node+2,mid+1,end,l,r);\n        return(Math.max(q1,q2));\n    }\n    SegmentTreeRMQ(int[] arr,int n){\n        int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));\n\n        //Maximum size of segment tree\n        int max_size = 2 * (int) Math.pow(2, x) - 1;\n        tree = new int[max_size];\n        build(0,0,n-1,arr);\n    }\n\n}\n",
    "submit_ts": 1716649953.0
}