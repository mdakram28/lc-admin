{
    "username": "nameless-chessfoot",
    "submission": "class TMP {\nprivate:\n    static const int df=0,n=100000;\n    int op(int a,int b){\n        return max(a,b);\n    }\n    int t[4*n]={};\n\n    void build(int l,int r,int idx,vector<int> &nums){\n        if(l==r){\n            t[idx]=nums[l-1];\n            return;\n        }\n\n        int m=l+(r-l)/2;\n        build(l,m,idx*2,nums);\n        build(m+1,r,idx*2+1,nums);\n        t[idx]=op(t[idx*2],t[idx*2+1]);\n    }\n    void mod(int idx,int f,int t,int l,int r,int val){\n        if(f>r||t<l) return;\n        if(l<=f&&t<=r){\n            (this->t)[idx]=val;\n            return;\n        }\n        int m=f+(t-f)/2;\n        (this->t)[idx]=df;\n        if(f<=m){\n            mod(idx*2,f,m,l,r,val);\n            (this->t)[idx]=op((this->t)[idx],(this->t)[idx*2]);\n        }\n        if(m+1<=t){\n            mod(idx*2+1,m+1,t,l,r,val);\n            (this->t)[idx]=op((this->t)[idx],(this->t)[idx*2+1]);\n        }\n    }\n    int get(int idx,int f,int t,int l,int r){\n        if(f>r||t<l) return 0;\n        if(l<=f&&t<=r){\n            return (this->t)[idx];\n        }\n        int m=f+(t-f)/2;\n        return op(get(idx*2,f,m,l,r),get(idx*2+1,m+1,t,l,r));\n    }\npublic:\n    int pn;\n    TMP(vector<int>& nums) {\n        pn=nums.size();\n        if(1<=pn){\n            build(1,pn,1,nums);\n        }\n    }\n    \n    void update(int index, int val) {\n        mod(1,1,pn,index+1,index+1,val);\n    }\n    \n    int sumRange(int left, int right) {\n        return get(1,1,pn,left+1,right+1);\n    }\n};\nclass TAP {\nprivate:\n    static const int df=0,n=100003;\n    int op(int a,int b){\n        return a+b;\n    }\n    int t[4*n]={};\n\n    void build(int l,int r,int idx,vector<int> &nums){\n        if(l==r){\n            t[idx]=nums[l-1];\n            return;\n        }\n\n        int m=l+(r-l)/2;\n        build(l,m,idx*2,nums);\n        build(m+1,r,idx*2+1,nums);\n        t[idx]=t[idx*2]+t[idx*2+1];\n    }\n    void mod(int idx,int f,int t,int l,int r,int val){\n        if(f>r||t<l) return;\n        if(l<=f&&t<=r){\n            (this->t)[idx]=val;\n            return;\n        }\n        int m=f+(t-f)/2;\n        (this->t)[idx]=df;\n        if(f<=m){\n            mod(idx*2,f,m,l,r,val);\n            (this->t)[idx]=op((this->t)[idx],(this->t)[idx*2]);\n        }\n        if(m+1<=t){\n            mod(idx*2+1,m+1,t,l,r,val);\n            (this->t)[idx]=op((this->t)[idx],(this->t)[idx*2+1]);\n        }\n    }\n    int get(int idx,int f,int t,int l,int r){\n        if(f>r||t<l) return 0;\n        if(l<=f&&t<=r){\n            return (this->t)[idx];\n        }\n        int m=f+(t-f)/2;\n        return op(get(idx*2,f,m,l,r),get(idx*2+1,m+1,t,l,r));\n    }\npublic:\n    int pn;\n    TAP(vector<int>& nums) {\n        pn=nums.size();\n        if(1<=pn){\n            build(1,pn,1,nums);\n        }\n    }\n    \n    void update(int index, int val) {\n        mod(1,1,pn,index+1,index+1,val);\n    }\n    \n    int sumRange(int left, int right) {\n        return get(1,1,pn,left+1,right+1);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int> vtmp, vltmp(n);\n        for(int i=0;i<n;++i) vtmp.push_back(i+1);\n        TMP tmp(vtmp);\n        TAP tap(vltmp);\n        vector<int> ans;\n        for(auto &qr:queries){\n            int u=qr[0], v=qr[1];\n            if(tmp.sumRange(0,u)>=v){\n                // cout<<tmp.sumRange(0,u)<<\"covered!\"<<endl;\n                ans.push_back(ans.back());\n                continue;\n            }\n            int ms=v-u-1;\n            int mids=tap.sumRange(u,v-1);\n            // cout<<\"Saved \"<<ms<<\", pre \"<<mids<<endl;\n            ms-=mids;\n            tmp.update(u,v);\n            vltmp[u]+=ms;\n            tap.update(u,vltmp[u]);\n            ans.push_back(n-1-tap.sumRange(0,n-1));\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722742281",
    "subm_id": "552343636"
}