{
    "username": "Rudranil_Acharya",
    "submission": "class Solution {\npublic:\nclass SGtree{\npublic:\n    vector<int> seg;\npublic:\n\n    SGtree(int n){\n        seg.resize(4*n+1);\n    }\n    void combine(int id){\n        seg[id]=((int)seg[2*id]&seg[(2*id)+1]);\n        return;\n    }\n    void build(int id,int l,int r,vector<int> &a){\n        if(r-l==1){\n\n            seg[id]=a[l];\n            return;\n        }\n\n        int mid=((int)l+r)/2;\n\n        build(2*id,l,mid,a);\n        build(2*id+1,mid,r,a);\n\n\n        combine(id);\n\n        return;\n    }\n\n    int query(int id,int x,int y,int l,int r){\n     if(l>=x and r<=y){\n\n        return seg[id];\n    }\n    else if(l>=y or r<=x){\n\n\n\n        int use=2147483647;\n        return use;\n    }\n\n    int mid=((int)l+r)/2;\n\n\n    int left=query(2*id,x,y,l,mid);\n    int right=query(2*id+1,x,y,mid,r);\n    return ((int)left&right);\n}\n\nvoid update(int id,int l,int r,int index,int value){\n\n   if(r<=index or l>index){\n    return;\n}\nif((r-l)==1){\n    if(index==l){\n        seg[id]=value;\n    }\n    return;\n\n}\n\nint mid=(int)l+r;\nmid=mid/2;\nupdate(2*id,l,mid,index,value);\nupdate((2*id)+1,mid,r,index,value);\ncombine(id);\nreturn;\n}\n\n};\n// int bs(vector<int> &nums,int n,int left,int right,int k){\n//     int l=left;\n//     int r=right;\n//     while(l<=r){\n//         int mid=(int)l+r;\n//         mid=mid/2;\n//         int val=\n//     }\n// }\n    long long countSubarrays(vector<int>& nums, int k) {\n        int n=nums.size();\n        SGtree s1(n);\n        vector<int> a=nums;\n       s1.build(1,0,n,a);\n       long long ans=0;\n\n        for(int i=0;i<n;i++){\n            //int contri=bs(nums,n,0,i,k);\n            int l=0;\n            int r=i;\n            int index=i+1;\n            int flag1=0;\n            while(l<=r){\n                int mid=(int)l+r;\n                mid=mid/2;\n                int val=s1.query(1,mid,i+1,0,n);\n                if(val>=k){\n                    if(val==k){\n                        flag1=1;\n                        index=min(index,mid);\n                    }\n                    r=mid-1;\n\n                }\n                else{\n                    l=mid+1;\n                }\n            }\n\n            if(flag1==1){\n                //yes index is where bitwise and is equal to k\n                int mn=index;\n                int mx=index;\n\n\n                l=index;\n                r=i;\n                flag1=0;\n                index=-1;\n                while(l<=r){\n                int mid=(int)l+r;\n                mid=mid/2;\n                int val=s1.query(1,mid,i+1,0,n);\n                if(val>k){\n                    \n                    r=mid-1;\n\n                }\n                else{\n                    if(val==k){\n                        flag1=1;\n                        index=max(index,mid);\n                    }\n                    l=mid+1;\n                }\n            }\n\n            if(flag1==1){\n                int contri=index-mn+1;\n                ans=(long long)ans+contri;\n            }\n            else{\n                ans=(long long)ans+1;\n            }\n\n            }\n\n        }\n        return ans;\n        \n    }\n};",
    "submit_ts": "1720278199",
    "subm_id": "1311698794"
}