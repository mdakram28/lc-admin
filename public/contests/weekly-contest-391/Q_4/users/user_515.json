{
    "username": "Wibo",
    "submission": "class Solution {\npublic:\n    int minimumDistance(vector<vector<int>>& points) {\n        int n = points.size();\n        \n        vector<int> ys(n);\n        for (int i=0; i<n; i++) ys[i] = points[i][1];\n        sort(ys.begin(), ys.end());\n        ys.resize(unique(ys.begin(), ys.end()) - ys.begin());\n        auto idy = [&](int y) -> int {\n            return lower_bound(ys.begin(), ys.end(), y) - ys.begin();  \n        };\n        \n        vector<pair<int, int>> tu, td;\n        auto update = [&](auto self, vector<pair<int, int>> &tree, int pos, pair<int, int> val, int l, int r, int v) -> void {\n            if (l == r) tree[v] = max(tree[v], val);\n            else {\n                int mid = (l+r)/2;\n                if (pos <= mid) self(self, tree, pos, val, l, mid, v*2);\n                else self(self, tree, pos, val, mid+1, r, v*2+1);\n                tree[v] = max(tree[v*2], tree[v*2+1]);\n            }\n        };\n        auto query = [&](auto self, vector<pair<int, int>> &tree, int ql, int qr, int l, int r, int v) -> pair<int, int> {\n            if (r < ql || l > qr || ql > qr) return {-1e9, -1};\n            if (l >= ql && r <= qr) return tree[v];\n            int mid = (l+r)/2;\n            return max(self(self, tree, ql, qr, l, mid, v*2), self(self, tree, ql, qr, mid+1, r, v*2+1));\n        };\n        \n        auto calc = [&](vector<vector<int>> &points) -> tuple<int, int, int> {\n            tu.assign(4*n, {-1e9, -1}); td.assign(4*n, {-1e9, -1});\n            sort(points.begin(), points.end());\n            tuple<int, int, int> ret = {-1e9, -1, -1};\n            for (int i=0; i<(int)points.size(); i++) {\n                int id = idy(points[i][1]);\n                auto mxd = query(query, td, 0, id, 0, n-1, 1);\n                mxd.first += points[i][0] + points[i][1];\n                auto mxu = query(query, tu, id, n-1, 0, n-1, 1);\n                mxu.first += points[i][0] - points[i][1];\n                if (mxd.first > get<0>(ret)) ret = {mxd.first, mxd.second, i};\n                if (mxu.first > get<0>(ret)) ret = {mxu.first, mxu.second, i};\n                update(update, td, id, {- points[i][0] - points[i][1], i}, 0, n-1, 1);\n                update(update, tu, id, {- points[i][0] + points[i][1], i}, 0, n-1, 1);\n            }\n            return ret;\n        };\n        \n        auto [mx, i1, i2] = calc(points);\n        // cout << mx << ' ' << i1 << ' ' << i2 << '\\n';\n        auto points1 = points; points1.erase(points1.begin() + i1);\n        auto points2 = points; points2.erase(points2.begin() + i2);\n        return min(get<0>(calc(points1)), get<0>(calc(points2)));\n    }\n};"
}