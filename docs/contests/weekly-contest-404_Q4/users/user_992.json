{
    "username": "raghu30",
    "submission": "class Solution {\npublic:\n    typedef long long ll;\n    int getDia(vector<vector<int>> &edges1) {\n        if(edges1.size() == 0) {\n            return 0;\n        }\n        vector<vector<int>> adj(edges1.size()+1);\n        for(auto &pr:edges1) {\n            int u = pr[0];\n            int v = pr[1];\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        \n        ll node1 = -1;\n        ll maxDepth = 0;\n        function <void(ll, ll, ll)> dfs = [&](ll cur, ll prev, ll depth) {\n            if(depth > maxDepth) {\n                maxDepth = depth;\n                node1 = cur;\n            }\n            for(auto el:adj[cur]) {\n                if(el == prev) continue;\n                dfs(el, cur, depth+1);\n            }\n        };\n\n        dfs(0, -1, 0);\n        ll st = node1;\n        node1 = -1;\n        maxDepth = 0;\n\n        dfs(st, -1, 0);\n        \n        return maxDepth;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int d1 = getDia(edges1);\n        int d2 = getDia(edges2);\n        \n        return max({d1, d2, (d1+1)/2 + (d2+1)/2 + 1});\n    }\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "submit_ts": 1719716939.0
}