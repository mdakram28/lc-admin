{
    "username": "codescannner",
    "submission": "class Solution {\n    public static int diameter(List<List<Integer>> adj, int node) {\n        int fartest = bfs(adj, node)[1];\n        return bfs(adj, fartest)[0];\n    }\n\n    // 0 - maxNodesInFarthestPath, 1 - FarthestNodeIndex\n    public static int[] bfs(List<List<Integer>> adj, int n) {\n        Queue<int[]> q = new LinkedList<>();\n        q.offer(new int[] { n, -1, 0 });\n        int maxIdx = n;\n        int max = 0;\n        while (!q.isEmpty()) {\n            int node[] = q.poll();\n            for (int next : adj.get(node[0])) {\n                if (next != node[1]) {\n                    if (max < node[2] + 1) {\n                        max = node[2] + 1;\n                        maxIdx = next;\n                    }\n                    q.offer(new int[] { next, node[0], node[2] + 1 });\n                }\n            }\n        }\n\n        return new int[] { max, maxIdx };\n\n    }\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        List<List<Integer>> adj1 = adjList(edges1);\n        List<List<Integer>> adj2 = adjList(edges2);\n        int d1 = diameter(adj1, 0);\n        int d2 = diameter(adj2, 0);\n\n        return Math.max(Math.max(d1, d2), (d1 + 1)/2 + (d2 + 1)/2 + 1);\n\n    }\n\n\n    public List<List<Integer>> adjList(int[][] edges){\n        int n = edges.length + 1;\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            adj.add(new ArrayList<>());\n\n        for(int i = 0;i <edges.length; i++){\n            int a = edges[i][0], b = edges[i][1];\n            adj.get(a).add(b);\n            adj.get(b).add(a);\n        }\n        return adj;\n    }\n}",
    "submit_ts": 1719719381.0
}