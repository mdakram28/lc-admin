{
    "username": "plyusnovdmitrii",
    "submission": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\n/* clang-format off */\n\n/* TYPES  */\n#define ll long long\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vi vector<int>\n#define vll vector<long long>\n#define vpii vector<pair<int, int>>\n#define vpii vector<pair<int, int>>\n#define vvpii vector<vector<pair<int, int>>>\n#define vpll vector<pair<long long, long long>>\n#define vvpll vector<vector<pair<long long, long long>>>\n#define vvi vector<vector<int>>\n#define vvll vector<vector<long long>>\n#define mii map<int, int>\n#define si set<int>\n#define sc set<char>\n\n\n\n/* FUNCTIONS */\n#define feach(el, v) for(auto &el: v)\n#define rep(i, n) for(int i=0;i<n;i++)\n#define factloop(i, s, n) for(long long i=s;i*i<=n;i++)\n#define reprv(i, n) for(int i=n-1;i>=0;i--)\n#define reps(i, s, e) for(int i=s;i<e;i++)\n#define reprve(i, e, s) for(int i=e-1;i>=s;i--)\n#define repe(x, y) for (auto &x: y)\n#define repe2(x, a, y) for (auto &[x,a]: y)\n\n\n\nconst ll mod = 1000000007;\n\ntemplate<ll mod = 1000000007>\nstruct ModInt {\n    ll p;\n\n    ModInt() : p(0) {}\n\n    ModInt(ll x) { p = x >= 0 ? x % mod : x + (-x + mod - 1) / mod * mod; }\n\n    ModInt &operator+=(const ModInt &y) {\n        p = p + *y - ((p + *y) >= mod ? mod : 0);\n        return *this;\n    }\n\n    ModInt &operator-=(const ModInt &y) {\n        p = p - *y + (p - *y < 0 ? mod : 0);\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &y) {\n        p = (p * *y) % mod;\n        return *this;\n    }\n\n    ModInt &operator%=(const ModInt &y) {\n        if (y)p %= *y;\n        return *this;\n    }\n\n    ModInt operator+(const ModInt &y) const {\n        ModInt x = *this;\n        return x += y;\n    }\n\n    ModInt operator-(const ModInt &y) const {\n        ModInt x = *this;\n        return x -= y;\n    }\n\n    ModInt operator*(const ModInt &y) const {\n        ModInt x = *this;\n        return x *= y;\n    }\n\n    ModInt operator%(const ModInt &y) const {\n        ModInt x = *this;\n        return x %= y;\n    }\n\n    ModInt binpow(const ModInt &y, ll pow) const {\n        pow %= mod - 1;\n        ModInt res = 1, a = y;\n        while (pow) {\n            if (pow & 1) res *= a;\n            a *= a, pow >>= 1;\n        }\n        return res;\n    }\n\n    ModInt inv() const { return binpow(*this, mod - 2); }\n\n    ModInt &operator/=(const ModInt &y) {\n        p = (p * y.inv().p) % mod;\n        return *this;\n    }\n\n    ModInt operator/(const ModInt &y) const {\n        ModInt x = *this;\n        return x /= y;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int v;\n        is >> v;\n        a = ModInt(v);\n        return is;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &a) { return os << a.p; }\n\n    ModInt &operator++() {\n        p = (p + 1) % mod;\n        return *this;\n    }\n\n    ModInt &operator--() {\n        p = (p - 1 + mod) % mod;\n        return *this;\n    }\n\n    bool operator==(const ModInt &y) const { return p == *y; }\n\n    bool operator!=(const ModInt &y) const { return p != *y; }\n\n    const ll &operator*() const { return p; }\n\n    ll &operator*() { return p; }\n\n};\n\nusing Mint = ModInt<>;\n#define vmint vector<Mint>\n\n\n#pragma GCC target(\"popcnt\")\n#define IO ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\ntypedef tree<ll, null_type, less<>, rb_tree_tag, tree_order_statistics_node_update> oSet;\n//#define int long long int\n\n/////////////////////////////////\n\n\nclass Solution {\npublic:\n    int numberOfAlternatingGroups(vector<int>& colors, int k) {\n        int n = colors.size();\n        rep(i, n) colors.push_back(colors[i]);rep(i, n) colors.push_back(colors[i]);\n        set<int> breaks;\n        rep(i, 3*n - 1) if (colors[i] == colors[i + 1]) breaks.insert(i);\n\n        int ans = 0;\n        rep(i, n) {\n            int last = i + k - 2;\n\n            auto src = breaks.upper_bound(last);\n            if (src == breaks.begin()) {\n                ++ans;\n            } else {\n                --src;\n                int val = *src;\n                if (val < i) ++ans;\n            }\n        }\n        return ans;\n    }\n};\n",
    "submit_ts": "1720277199",
    "subm_id": "1311652337"
}