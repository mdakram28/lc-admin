{
    "username": "Sad_Bus",
    "submission": "class Solution {\npublic:\n    struct segtree {\n        int s, e;\n        int mn, mx, sum;\n        bool lset;\n        int add_val, set_val;\n        segtree *l, *r;\n        segtree (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\n            if (A == NULL) return;\n            if (s == e) mn = mx = sum = A[s];\n            else {\n                l = new segtree(s, (s+e)>>1, A), r = new segtree((s+e+2)>>1, e, A);\n                combine();\n            }\n        }\n        void create_children() {\n            if (s == e) return;\n            if (l != NULL) return;\n            int m = (s+e)>>1;\n            l = new segtree(s, m);\n            r = new segtree(m+1, e);\n        }\n        void self_set(int v) {\n            lset = 1;\n            mn = mx = set_val = v;\n            sum = v * (e-s+1);\n            add_val = 0;\n        }\n        void self_add(int v) {\n            if (lset) { self_set(v + set_val); return; }\n            mn += v, mx += v, add_val += v;\n            sum += v*(e-s+1);\n        }\n        void lazy_propagate() {\n            if (s == e) return;\n            if (lset) {\n                l->self_set(set_val), r->self_set(set_val);\n                lset = 0;\n                set_val = 0;\n            }   \n            if (add_val != 0) {\n                l->self_add(add_val), r->self_add(add_val);\n                add_val = 0;\n            }\n        }\n        void combine() {\n            if (l == NULL) return;\n            sum = l->sum + r->sum;\n            mn = min(l->mn, r->mn);\n            mx = max(l->mx, r->mx);\n        }\n        void add(int x, int y, int v) {\n            if (s == x && e == y) { self_add(v); return; }\n            int m = (s+e)>>1;\n            create_children(); lazy_propagate();\n            if (x <= m) l->add(x, min(y, m), v);\n            if (y > m) r->add(max(x, m+1), y, v);\n            combine();\n        }\n        void set(int x, int y, int v) {\n            if (s == x && e == y) { self_set(v); return; }\n            int m = (s+e)>>1;\n            create_children(); lazy_propagate();\n            if (x <= m) l->set(x, min(y, m), v);\n            if (y > m) r->set(max(x, m+1), y, v);\n            combine();\n        }\n        int range_sum(int x, int y) {\n            if (s == x && e == y) return sum;\n            if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\n            int m = (s+e)>>1;\n            lazy_propagate();\n            if (y <= m) return l->range_sum(x, y);\n            if (x > m) return r->range_sum(x, y);\n            return l->range_sum(x, m) + r->range_sum(m+1, y);\n        }\n        int range_min(int x, int y) {\n            if (s == x && e == y) return mn;\n            if (l == NULL || lset) return mn;\n            int m = (s+e)>>1;\n            lazy_propagate();\n            if (y <= m) return l->range_min(x, y);\n            if (x > m) return r->range_min(x, y);\n            return min(l->range_min(x, m), r->range_min(m+1, y));\n        }\n        int range_max(int x, int y) {\n            if (s == x && e == y) return mx;\n            if (l == NULL || lset) return mx;\n            int m = (s+e)>>1;\n            lazy_propagate();\n            if (y <= m) return l->range_max(x, y);\n            if (x > m) return r->range_max(x, y);\n            return max(l->range_max(x, m), r->range_max(m+1, y));\n        }\n        ~segtree() {\n            if (l != NULL) delete l;\n            if (r != NULL) delete r;\n        }\n    };\n    \n    bool isPeak(vector<int>& arr, int n, int idx){\n        if(idx <= 0 || idx >= n-1){\n            return false;\n        }\n        \n        if(arr[idx] <= arr[idx-1]){\n            return false;\n        }\n        if(arr[idx] <= arr[idx+1]){\n            return false;\n        }\n        \n        return true;\n    }\n    \n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        \n        segtree seg = segtree(0, n+1);\n        \n        for(int i = 1; i < n-1; i++){\n            if(nums[i] > nums[i-1] && nums[i] > nums[i+1]){\n                seg.set(i, i, 1);\n            }\n        }\n        \n        int q = queries.size();\n        \n        vector<int> ans;\n        \n        for(int i = 0; i < q; i++){\n            int t = queries[i][0];\n            \n            if(t == 1){\n                int l = queries[i][1];\n                int r = queries[i][2];\n                \n                ans.push_back(max(0, seg.range_sum(l+1, r-1)));\n            }\n            else{\n                int idx = queries[i][1];\n                int val = queries[i][2];\n                \n                nums[idx] = val;\n                \n                if(seg.range_sum(idx, idx) == 1){\n                    if(!isPeak(nums, n, idx)){\n                        seg.set(idx, idx, 0);\n                    }\n                }\n                else{\n                    if(isPeak(nums, n, idx)){\n                        seg.set(idx, idx, 1);\n                    }\n                }\n                \n                if(idx > 0){\n                    if(seg.range_sum(idx-1, idx-1) == 1){\n                        if(!isPeak(nums, n, idx-1)){\n                            seg.set(idx-1, idx-1, 0);\n                        }\n                    }\n                    else{\n                        if(isPeak(nums, n, idx-1)){\n                            seg.set(idx-1, idx-1, 1);\n                        }\n                    }\n                }\n                \n                if(idx < n-1){\n                    if(seg.range_sum(idx+1, idx+1) == 1){\n                        if(!isPeak(nums, n, idx+1)){\n                            seg.set(idx+1, idx+1, 0);\n                        }\n                    }\n                    else{\n                        if(isPeak(nums, n, idx+1)){\n                            seg.set(idx+1, idx+1, 1);\n                        }\n                    }\n                }\n            }\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": "1718507793",
    "subm_id": "1289662660"
}