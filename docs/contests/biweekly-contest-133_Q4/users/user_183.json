{
    "username": "dumbunny8128",
    "submission": "MOD = 1_000_000_007\n\nclass Solution:\n    '''Notes\n    * n <= 300, so O(N^3) or better is needed.\n    * See examples. Can sort requirements.\n      * See if inversion count at start can be multiplicative with next step.\n        * If we introduce one new number, it adds one inversion for each number it is smaller than.\n        * If we introduce two new numbers, they can themselves add an inversion or not, and they can \n          be added in some way.\n        * Each added element adds a particular value. So a counts is fine.\n        \n    '''\n    def numberOfPermutations(self, n: int, requirements: List[List[int]]) -> int:\n        reqs = requirements\n        del requirements\n        reqs = dict(reqs)  # endIdx, invCnt values.\n        vals0 = defaultdict(int)\n        vals0[0] = 1  # No inversions for single element\n        if 0 in reqs and reqs[0] != 0:\n            return 0\n        for i0 in range(1, n):  # i0 in [1, 2]; i1 in [2, 3].\n            i1 = i0 + 1  # i0 is the old size, i1 is the new size\n            vals1 = defaultdict(int)\n            for j in range(i1):  # shift over j times\n                for k0, v0 in vals0.items():\n                    if k0 + j <= 400:\n                        vals1[k0 + j] += v0\n            vals0 = defaultdict(int)\n            if i0 in reqs:\n                reqCount = reqs[i0]\n                vals0[reqCount] = vals1[reqCount] % MOD\n            else:\n                for k1, v1 in vals1.items():\n                    vals0[k1] = v1 % MOD\n                \n        # print(f'reqs={reqs}, vals0={vals0}')\n        return vals0[reqs[n - 1]]\n        \n        \n        \n        ",
    "submit_ts": "1719069411",
    "subm_id": "1296795797"
}