{
    "username": "Albert_Zhang",
    "submission": "\"\"\" === Method 1. use a Segment tree\n(1) We can use a segment tree of a 0-1 array, where 0 represents not a peak, and 1 represents a peak.\n(2) For each point update, we need to update at most 3 slots in the tree: i - 1, i and i + 1.\n(3) For each query [l, r], we just need to check the sum of [l + 1, r - 1].\n\"\"\"\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        isPeaks = self.getIsPeaks(nums)\n        tree = SegmentTree(isPeaks)\n        results = []\n        for query in queries:\n            if query[0] == 1: # get value\n                left = query[1]\n                right = query[2]\n                results.append(0 if right - left <= 1 else tree.queryRange(left + 1, right - 1))\n            else: # update\n                index = query[1]\n                newValue = query[2]\n                nums[index] = newValue\n                for i in range(index - 1, index + 2):\n                    self.updatePeaks(nums, i, isPeaks, tree)\n            # print(isPeaks)\n        return results\n    \n    def getIsPeaks(self, nums):\n        isPeaks = [0] * len(nums)\n        for i in range(1, len(nums) - 1):\n            if nums[i - 1] < nums[i] > nums[i + 1]:\n                isPeaks[i] = 1\n        return isPeaks\n    \n    def updatePeaks(self, nums, i, isPeaks, tree):\n        if i <= 0 or i >= len(nums) - 1: # not update\n            return\n        # print(i, nums)\n        if nums[i - 1] < nums[i] > nums[i + 1]:\n            isPeaks[i] = 1\n        else:\n            isPeaks[i] = 0\n        tree.updateTo(i, isPeaks[i])\n        \n        \n        \n\nclass SegmentTree:\n    \"\"\"\n    This is a simple version of sum segment tree, which doesn't have lazy propagatioin within.\n    That is, we can query range sum with this tree.\n    If we want to implement segment tree of max, min, etc.,\n    we only need to override: \\n\n    (1) _setOperator() method \\n\n    (2) _setQueryValue() method. \\n\n    Notice: If we need to apply lazy propagation for range modifications, \n    please use the following class instead: CompleteSegmentTree.\n    \"\"\"\n\n    def __init__(self, array):\n        \"\"\"\n        initialize the segment tree. Here we use an array to implement it. \\n\n        O(n) time | O(n) space - where n is the length of the initial array.\n        \"\"\"\n        self.operator = self._setOperator()\n        self.initialLength = len(array)\n        self.tree = self._populateTree(array) # length: 2n\n\n    def _setOperator(self):\n        # For sum. we need to change the value if query max or min, with max() or min(), resectively.\n        return lambda x, y: x + y \n\n    def _setQueryValue(self):\n        # For sum. we need to change the value if query max or min, with float(\"inf\") or float(\"-inf\"), resectively.\n        return 0 \n\n    def _populateTree(self, array):\n        tree = [0] * self.initialLength + array\n        for idx in reversed(range(1, self.initialLength)):\n            leftChild = tree[idx * 2]\n            rightChild = tree[idx * 2 + 1]\n            tree[idx] = self.operator(leftChild, rightChild)\n        return tree\n\n    def updateTo(self, idx, newValue):\n        \"\"\"\n        updateTo(self, idx, newValue) method can set array[idx] to newValue.\n        If you want to increment array[idx] by a value, please substract the difference,\n        or use the .updateBy() method! \\n\n        O(log(n)) time | O(1) space - where n is the length of the initial array.\n        \"\"\"\n        if not 0 <= idx < self.initialLength:\n            raise IndexError(\"The index is out of range!\")\n        treeIdx = idx + self.initialLength\n        self.tree[treeIdx] = newValue\n        treeIdx >>= 1 # to its parent\n        while treeIdx: # the treeIdx is not the dummy head\n            leftChild = self.tree[treeIdx << 1] # treeIdx * 2\n            rightChild = self.tree[treeIdx << 1 | 1] # treeIdx * 2 + 1\n            self.tree[treeIdx] = self.operator(leftChild, rightChild)\n            treeIdx >>= 1 # go to its parent\n\n    def updateBy(self, idx, newValue):\n        \"\"\"\n        updateBy(self, idx, newValue) method can increment array[idx] by newValue. \\n\n        O(log(n)) time | O(1) space - where n is the length of the initial array.\n        \"\"\"\n        if not 0 <= idx < self.initialLength:\n            raise IndexError(\"The index is out of range!\")\n        treeIdx = idx + self.initialLength\n        self.tree[treeIdx] += newValue\n        treeIdx >>= 1 # to its parent\n        while treeIdx: # the treeIdx is not the dummy head\n            leftChild = self.tree[treeIdx << 1] # treeIdx * 2\n            rightChild = self.tree[treeIdx << 1 | 1] # treeIdx * 2 + 1\n            self.tree[treeIdx] = self.operator(leftChild, rightChild)\n            treeIdx >>= 1 # go to its parent\n\n    def queryRange(self, startIdx, endIdx):\n        \"\"\"\n        queryRange(self, startIdx, endIdx) method can query range (sum, max, etc.) of [startIdx, endIdx]\n        inclusively. \\n\n        O(log(n)) time | O(1) space - where n is the length of the initial array.\n        \"\"\"\n        if not 0 <= startIdx <= endIdx < self.initialLength:\n            raise IndexError(\"The index is out of range!\")\n        result = self._setQueryValue()\n        leftIdx = startIdx + self.initialLength\n        rightIdx = endIdx + self.initialLength\n        while leftIdx <= rightIdx:\n            if leftIdx & 1: # right child of its parent. We need to add it to the result.\n                result = self.operator(result, self.tree[leftIdx])\n                leftIdx += 1\n            if rightIdx & 1 == 0: # left child of its parent. We need to add it to the result.\n                result = self.operator(result, self.tree[rightIdx])\n                rightIdx -= 1\n            leftIdx >>= 1 # go to its parent\n            rightIdx >>= 1\n        return result\n\n    def queryValueAt(self, idx):\n        \"\"\"\n        queryValueAt(self, idx) method can query the value of initial array[idx]. \n        It is a trivial method in this class, but it would be much more complicate\n        for the CompleteSegmentTree class. \\n\n        O(1) time | O(1) space\n        \"\"\"\n        if not 0 <= idx < self.initialLength:\n            raise IndexError(\"The index is out of range!\")\n        return self.tree[idx + self.initialLength]\n\n\n\nclass SumSegmentTree(SegmentTree):\n    \"\"\"\n    This is a sum segment tree. It is a subclass of SegmentTree.\n    That is, we can query range sum with this tree.\n    Actually, the SegmentTree class we define above is exactly a sum segment tree, so we don't need to\n    change anything here.\n    \"\"\"\n\n    def _setOperator(self):\n        # We override the _setOperator() method to apply the sum operations.\n        return lambda x, y: x + y \n\n    def _setQueryValue(self):\n        # We override the _setQueryValue method to apply the sum operations.\n        # That is, we use it to initialize the result for queryRange operations.\n        return 0 \n\n\n        \nclass MaxSegmentTree(SegmentTree):\n    \"\"\"\n    This is a max segment tree. It is a subclass of SegmentTree.\n    That is, we can query range max with this tree.\n    \"\"\"\n\n    def _setOperator(self):\n        # We override the _setOperator() method to apply the max operations.\n        return lambda x, y: max(x, y)\n\n    def _setQueryValue(self):\n        # We override the _setQueryValue method to apply the max operations.\n        # That is, we use it to initialize the result for queryRange operations.\n        return float(\"-inf\")  \n\n\n\nclass MinSegmentTree(SegmentTree):\n    \"\"\"\n    This is a min segment tree. It is a subclass of SegmentTree.\n    That is, we can query range min with this tree.\n    \"\"\"\n\n    def _setOperator(self):\n        # We override the _setOperator() method to apply the min operations.\n        return lambda x, y: min(x, y)\n\n    def _setQueryValue(self):\n        # We override the _setQueryValue method to apply the min operations.\n        # That is, we use it to initialize the result for queryRange operations.\n        return float(\"inf\")  \n\n",
    "submit_ts": "1718507109",
    "subm_id": "1289641451"
}