{
    "username": "antwomen_1998",
    "submission": "class Solution {\npublic:\n     pair<int, int>rec(int start,const vector<vector<int>>&a) {\n    int n = a.size();\n    vector<int> dist(n, -1);\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n    int f = start;\n    int maxDist = 0;\n    \n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        for (int neighbor : a[node]) {\n            if (dist[neighbor] == -1) {\n                dist[neighbor] = dist[node] + 1;\n                q.push(neighbor);\n                if (dist[neighbor] >dist[f]) {\n                    maxDist = dist[neighbor];\n                    f = neighbor;\n                }\n            }\n        }\n    }\n    return {f, dist[f]};\n}\n\n// Function to find the diameter and heights of all nodes in the tree\npair<int, vector<int>> findDiameterAndHeights(const vector<vector<int>>& adj) {\n    auto [farthestNode, _] = rec(0, adj);\n    auto [otherFarthest, diameter] = rec(farthestNode, adj);\n    \n    // Perform BFS from one endpoint of the diameter to find heights\n    int n = adj.size();\n    vector<int> height(n, -1);\n    queue<int> q;\n    q.push(otherFarthest);\n    height[otherFarthest] = 0;\n    \n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        for (int neighbor : adj[node]) {\n            if (height[neighbor] == -1) {\n                height[neighbor] = height[node] + 1;\n                q.push(neighbor);\n            }\n        }\n    }\n    return {diameter, height};\n}\n\nint minDiameterAfterAddingEdge(int n, int m, vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n    \n    \n    vector<vector<int>> res1(n+1), res2(m+2);\n    \n    for ( auto edge : edges1) {\n        res1[edge[0]].push_back(edge[1]);\n        res1[edge[1]].push_back(edge[0]);\n    }\n    \n    for ( auto it : edges2) {\n        res2[it[0]].push_back(it[1]);\n        res2[it[1]].push_back(it[0]);\n    }\n    \n    auto c=rec(0,res2);\n    auto a=rec(0,res1);\n    \n    auto b=rec(a.first,res1);\n    \n    auto d=rec(c.first,res2);\n    \n    \n    \n    \n//     auto [diameter1, height1] = findDiameterAndHeights(adj1);\n//     auto [diameter2, height2] = findDiameterAndHeights(adj2);\n    \n//     int minDiameter = INT_MAX;\n    \n//     for (int i = 0; i < n; ++i) {\n//         for (int j = 0; j < m; ++j) {\n//             int newDiameter = max({diameter1, diameter2, height1[i] + height2[j] + 1});\n//             minDiameter = min(minDiameter, newDiameter);\n//         }\n//     }\n    \n    int p=b.second+1;\n    \n    int z=d.second+1;\n    \n    int s=p/2+z/2+1;\n    \n    int t=max(p-1,z-1);\n    \n    \n    int p1=max(s,t);\n    \n    return p1;\n}\n\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n         \n        int n=edges1.size(),m=edges2.size();\n        return minDiameterAfterAddingEdge(n,m,edges1,edges2);\n\n        \n    }\n};",
    "submit_ts": 1719718522.0
}