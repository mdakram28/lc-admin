{
    "username": "ocavue",
    "submission": "# Only use this if you need to update a range of values in the segment tree.\n# Otherwise, use binary indexed tree.\nfrom typing import List\n\n\nclass SegmentTreeSum:\n    def __init__(self, n):\n        self.n = n\n        self._tree = [0] * (4 * self.n)\n        self._lazy = [-1] * (4 * self.n)  # Lazy propagation array\n\n    def build(self, nums: List[int]):\n        self._build(nums, 0, self.n, 0)\n\n    def _build(self, nums: List[int], lo: int, hi: int, i: int):\n        assert 0 <= lo < hi <= self.n\n\n        if lo + 1 == hi:\n            self._tree[i] = nums[lo]\n            return self._tree[i]\n\n        mi = (lo + hi) // 2\n        v1 = self._build(nums, lo, mi, i * 2 + 1)\n        v2 = self._build(nums, mi, hi, i * 2 + 2)\n        self._tree[i] = v1 + v2\n        return self._tree[i]\n\n    # Internal method to push the lazy value down to children\n    def _push_lazy(self, lo: int, hi: int, i: int):\n        assert 0 <= lo < hi <= self.n\n        if self._lazy[i] != -1:\n            self._tree[i] = (hi - lo) * self._lazy[i]\n            if lo + 1 < hi:  # If not a leaf node\n                self._lazy[i * 2 + 1] = self._lazy[i]\n                self._lazy[i * 2 + 2] = self._lazy[i]\n            self._lazy[i] = -1\n\n    def query(self, q_lo: int, q_hi: int):\n        assert q_lo < q_hi\n        return self._query(q_lo, q_hi, 0, self.n, 0)\n\n    def _query(self, q_lo: int, q_hi: int, lo: int, hi: int, i: int):\n        assert 0 <= lo < hi <= self.n\n        assert 0 <= q_lo < q_hi <= self.n\n\n        self._push_lazy(lo, hi, i)  # Push the lazy value before querying\n\n        if q_hi <= lo or hi <= q_lo:\n            return 0\n        if q_lo <= lo and hi <= q_hi:\n            return self._tree[i]\n        mi = (lo + hi) // 2\n        v1 = self._query(q_lo, q_hi, lo, mi, i * 2 + 1)\n        v2 = self._query(q_lo, q_hi, mi, hi, i * 2 + 2)\n        return v1 + v2\n\n    # Set 'val' to all elements in range [q_lo, q_hi)\n    def update_range(self, q_lo, q_hi, val):\n        assert q_lo < q_hi\n        self._update_range(q_lo, q_hi, val, 0, self.n, 0)\n\n    def _update_range(self, q_lo, q_hi, val, lo, hi, i):\n        assert lo < hi\n\n        self._push_lazy(lo, hi, i)\n\n        if q_hi <= lo or hi <= q_lo:\n            return\n        if q_lo <= lo and hi <= q_hi:\n            self._lazy[i] = val  # Set the lazy value\n            self._push_lazy(lo, hi, i)  # Push it immediately to this node\n            return\n\n        mi = (lo + hi) // 2\n        self._update_range(q_lo, q_hi, val, lo, mi, i * 2 + 1)\n        self._update_range(q_lo, q_hi, val, mi, hi, i * 2 + 2)\n        v1 = self._tree[i * 2 + 1]\n        v2 = self._tree[i * 2 + 2]\n        self._tree[i] = v1 + v2\n\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        tree = SegmentTreeSum(n)\n        tree.build([1] * n)\n        result = []\n        for u, v in queries:\n            if v - u >= 2:\n                tree.update_range(u + 1, v, 0)\n            result.append(tree.query(0, n) - 1)\n        return result\n ",
    "submit_ts": "1722740880",
    "subm_id": "1343731070"
}