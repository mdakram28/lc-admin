{
    "username": "jwseph",
    "submission": "template<class T>\nstruct Tree {\n    T def{};\n    T f(T a, T b) { return a+b; }\n    vector<T> t; int n;\n    Tree(int n): t(2*n, def), n(n) {}\n    void update(int i, T v) {\n        for (t[i += n] = v; i /= 2;) t[i] = f(t[i*2], t[i*2+1]);\n    }\n    T query(int l, int r) {\n        T al = def, ar = def;\n        for (l += n, r += n; l < r; l /= 2, r /= 2) {\n            if (l&1) al = f(al, t[l++]);\n            if (r&1) ar = f(t[--r], ar);\n        }\n        return f(al, ar);\n    }\n};\n\nusing ll = long long;\n\nstruct Node {\n    ll ls, rs, w, bs;\n    bool bad;\n    Node(): ls(0), rs(0), w(0), bs(0), bad(0) {}\n    Node(ll ls, ll rs, ll width, ll bs, bool bad): ls(ls), rs(rs), w(width), bs(max(bs, max(ls, rs))), bad(bad) {}\n    friend Node operator+(const Node& a, const Node& b) {\n        return {!b.bad && a.ls == a.w ? a.w+b.ls : a.ls,\n                !b.bad && b.rs == b.w ? b.w+a.rs : b.rs,\n                a.w+b.w,\n                max({a.bs, b.bs, a.rs, b.ls, !b.bad ? a.rs+b.ls : 0}),\n                a.bad};\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& Q) {\n        int n = 1;\n        for (auto& q: Q) {\n            n = max(n, q[1]+5);\n        }\n        Tree<Node> tr(n);\n        for (int i = 0; i < n; ++i) {\n            tr.update(i, Node(1, 1, 1, 1, 0));\n        }\n        vector<bool> res;\n        for (auto& q: Q) {\n            int t = q[0], i = q[1];\n            if (t == 1) {\n                tr.update(i, Node(1, 1, 1, 1, 1));\n                continue;\n            }\n            int k = q[2];\n            res.push_back(k <= tr.query(0, i).bs);\n        }\n        return res;\n    }\n};",
    "submit_ts": 1716649336.0
}