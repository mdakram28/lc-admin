{
    "username": "cuiaoxiang",
    "submission": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const multiset<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntemplate <class T> auto vect(const T& v, int n) { return vector<T>(n, v); }\ntemplate <class T, class... D> auto vect(const T& v, int n, D... m) {\n  return vector<decltype(vect(v, m...))>(n, vect(v, m...));\n}\n\nusing int64 = long long;\nusing int128 = __int128_t;\nusing ii = pair<int, int>;\n#define SZ(x) (int)((x).size())\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nmt19937_64 mrand(random_device{}());\nint64 rnd(int64 x) { return mrand() % x; }\nconstexpr inline int lg2(int64 x) { return x == 0 ? -1 : sizeof(int64) * 8 - 1 - __builtin_clzll(x); }\nconstexpr inline int64 p2ceil(int64 x) { return 1LL << (lg2(x - 1) + 1); }\ntemplate <class T> void out(const vector<T>& a) { for (int i = 0; i < SZ(a); ++i) cout << a[i] << \" \\n\"[i + 1 == SZ(a)]; }\ntemplate <class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate <class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate <class T> void dedup(vector<T>& v) { sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); }\ninline void add_mod(int& x, int y) { x += y; if (x >= MOD) x -= MOD; }\ninline void sub_mod(int& x, int y) { x += MOD - y; if (x >= MOD) x -= MOD; }\ninline int mod(int x) { return x >= MOD ? x - MOD : x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\ntemplate<size_t N,\n         class T,\n         T (*op)(const T&, const T&),\n         T (*e)(),\n         class F,\n         T (*apply)(const F&, const T&),\n         F (*composition)(const F&, const F&),\n         F (*id)()>\nstruct SegmentTree {\n  struct Node {\n    Node *left, *right;\n    T val;\n    F tag;\n    void update(int a, int b, F c) {\n      val = apply(c, val);\n      // val = apply(c * (b - a), val);\n      tag = composition(c, tag);\n    }\n    void pushup() { val = op(left->val, right->val); }\n    void pushdown(int a, int b) {\n      if (tag != id()) {\n        int mid = (a + b) / 2;\n        left->update(a, mid, tag);\n        right->update(mid, b, tag);\n        tag = id();\n      }\n    }\n  };\n  Node pool[N << 1], *last, *rt;\n  int n;\n  SegmentTree(const vector<T>& v): n(SZ(v)) {\n    last = pool;\n    rt = build(0, n, v);\n  }\n  SegmentTree(int n): SegmentTree(vector<T>(n, e())) {}\n  Node* build(int a, int b, const vector<T>& v) {\n    Node* ret = last++;\n    ret->tag = id();\n    if (a + 1 == b) { ret->val = v[a]; return ret; }\n    int mid = (a + b) / 2;\n    ret->left = build(a, mid, v);\n    ret->right = build(mid, b, v);\n    ret->pushup();\n    return ret;\n  }\n  void insert(int ll, int rr, F c) {\n    trace(ll, rr, c);\n    return insert(rt, 0, n, ll, rr, c);\n  }\n  void insert(Node* cur, int a, int b, int ll, int rr, F c) {\n    if (ll >= rr || a >= rr || b <= ll) return;\n    if (a >= ll && b <= rr) { cur->update(a, b, c); return; }\n    cur->pushdown(a, b);\n    int mid = (a + b) / 2;\n    insert(cur->left, a, mid, ll, rr, c);\n    insert(cur->right, mid, b, ll, rr, c);\n    cur->pushup();\n  }\n  void set(int pos, T val) { return set(rt, 0, n, pos, val); }\n  void set(Node* cur, int a, int b, int pos, T val) {\n    if (pos < a || pos >= b) return;\n    if (a + 1 == b) { cur->val = val; return; }\n    cur->pushdown(a, b);\n    int mid = (a + b) / 2;\n    set(cur->left, a, mid, pos, val);\n    set(cur->right, mid, b, pos, val);\n    cur->pushup();\n  }\n  T query(int ll, int rr) { return query(rt, 0, n, ll, rr); }\n  T query(Node* cur, int a, int b, int ll, int rr) {\n    if (ll >= rr || a >= rr || b <= ll) return e();\n    if (a >= ll && b <= rr) return cur->val;\n    cur->pushdown(a, b);\n    int mid = (a + b) / 2;\n    return op(query(cur->left, a, mid, ll, rr), query(cur->right, mid, b, ll, rr));\n  }\n};\n\nconst int N = 2e5 + 10;\n\ntemplate<typename T> T op(const T& a, const T& b) { return max(a, b); }\ntemplate<typename T> T e() { return -inf<T>; }\ntemplate<typename T> T add(const T& a, const T& b) { return a + b; }\ntemplate<typename T> T id() { return T(); }\nusing segtree = SegmentTree<\n  N, int, op, e,\n  int, add, add, id>;\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector<bool> ret;\n        set<int> pos;\n        pos.insert(0);\n        int n = 0;\n        for (auto& v : queries) n = max(n, v[1]);\n        n += 1;\n        trace(n);\n        vector<int> V(n);\n        iota(V.begin(), V.end(), 0);\n        segtree tr(V);\n        trace(V);\n        for (auto& v : queries) {\n            int op = v[0];\n            if (op == 1) {\n                int x = v[1];\n                auto v = pos.upper_bound(x);\n                auto u = std::prev(v);\n                int L = *u, R = v == pos.end() ? n : *v;\n                trace(x + 1, R + 1, L - x);\n                tr.insert(x + 1, R + 1, L - x);\n                pos.insert(x);\n            } else {\n                int x = v[1], len = v[2];\n                trace(x, len);\n                if (len > x) {\n                    ret.push_back(0);\n                    continue;\n                }\n                auto it = pos.upper_bound(x);\n                --it;\n                trace(x, *it, len);\n                if (x - *it >= len) {\n                    ret.push_back(1);\n                    continue;\n                }\n                ret.push_back(tr.query(0, *it + 1) >= len);\n            }\n        }\n        return ret;\n    }\n};\n",
    "submit_ts": 1716649291.0
}