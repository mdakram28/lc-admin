{
    "username": "brianlaw100",
    "submission": "#include <algorithm>\n#include <utility>\n#include <vector>\n\ntemplate <typename F>\nclass YCombinator {\n\nprivate:\n\n    const F f = nullptr;\n\npublic:\n\n    explicit YCombinator(F&& f) : f(f) {}\n\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const {\n\n        return f(*this, std::forward<Args>(args)...);\n\n    }\n\n};\n\ntemplate <typename F>\nYCombinator(F) -> YCombinator<F>;\n\nclass Solution {\n\npublic:\n\n    auto minimumDiameterAfterMerge(\n        std::vector<std::vector<int>>& edges_1, std::vector<std::vector<int>>& edges_2\n    ) {\n\n        const auto get = [](const std::vector<std::vector<int>>& edges) {\n            const auto sz = static_cast<int>(std::size(edges)) + 1;\n            auto adj = std::vector<std::vector<int>>(sz);\n            for (const auto& x : edges) {\n                adj[x[0]].push_back(x[1]);\n                adj[x[1]].push_back(x[0]);\n            }\n            auto dists_1 = std::vector<int>(sz);\n            auto dists_2 = std::vector<int>(sz);\n            const auto search_1 = YCombinator(\n                [&](const auto& search_1, int node, int parent) -> void {\n                    auto& distance_1 = dists_1[node];\n                    auto& distance_2 = dists_2[node];\n                    for (auto x : adj[node]) {\n                        if (x != parent) {\n                            search_1(x, node);\n                            if (dists_1[x] >= distance_1) {\n                                distance_2 = distance_1;\n                                distance_1 = dists_1[x] + 1;\n                            } else if (dists_1[x] >= distance_2) {\n                                distance_2 = dists_1[x] + 1;\n                            }\n                        }\n                    }\n                }\n            );\n            search_1(0, -1);\n            auto dists_3 = std::vector<int>(sz);\n            const auto search_2 = YCombinator(\n                [&](const auto& search_2, int node, int parent) -> void {\n                    if (node) {\n                        dists_3[node] = std::max(\n                            dists_3[parent] + 1,\n                            (\n                                dists_1[node] != dists_1[parent] - 1 ? dists_1 : dists_2\n                            )[parent] + 1\n                        );\n                    }\n                    for (auto x : adj[node]) {\n                        if (x != parent) {\n                            search_2(x, node);\n                        }\n                    }\n                }\n            );\n            search_2(0, -1);\n            for (auto i = 0; i < sz; ++i) {\n                dists_1[i] = std::max(dists_1[i], dists_3[i]);\n            }\n            return dists_1;\n        };\n\n        const auto dists_1 = get(edges_1);\n        const auto dists_2 = get(edges_2);\n\n        const auto [mn_it_1, mx_it_1] = std::minmax_element(std::begin(dists_1), std::end(dists_1));\n        const auto [mn_it_2, mx_it_2] = std::minmax_element(std::begin(dists_2), std::end(dists_2));\n\n        return std::max({*mx_it_1, *mx_it_2, *mn_it_1 + *mn_it_2 + 1});\n\n    }\n\n};\n",
    "submit_ts": "1719717561",
    "subm_id": "1304394805"
}