{
    "username": "faultybiscuit",
    "submission": "class Solution {\npublic:\n    vector<int> MaxDist(vector<vector<int> >& A, int N)\n{\n\tvector<pair<int,int>> V(N), V1(N);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tV[i] = {A[i][0] + A[i][1],i};\n\t\tV1[i] = {A[i][0] - A[i][1],i};\n\t}\n\n\t// Sorting both the vectors\n\tsort(V.begin(), V.end());\n\tsort(V1.begin(), V1.end());\n    int mx1=V.back().first - V.front().first;\n    int mx2=V1.back().first - V1.front().first;\n\tif(mx1>mx2)\n    {\n        return {V.back().second, V.front().second,mx1};\n    }\n    else\n    {\n//         if(mx1==mx2)\n//         {\n\n//         }\n//         else\n//         {\n            return {V1.back().second, V1.front().second,mx2};\n        // }\n    }\n        return {-1,-1};\n}\n    int minimumDistance(vector<vector<int>>& points) {\n        int n=points.size();\n        vector<int>temp=MaxDist(points,n);\n        int p1=temp[0],p2=temp[1];\n        // cout<<p1<<\" \"<<p2<<endl;\n        vector<vector<int>>v1,v2;\n        for(int i=0;i<n;i++)\n        {\n            if(i!=p1)\n            v1.push_back(points[i]);\n            if(i!=p2)\n                v2.push_back(points[i]);\n        }\n        return min(MaxDist(v1,n-1)[2],MaxDist(v2,n-1)[2]);\n    }\n};"
}