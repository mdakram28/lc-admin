{
    "username": "anhoavu",
    "submission": "class Solution {\npublic:\n    // Obvious subproblem of target[i..end]\n    int minimumCost(string target, vector<string>& words, vector<int>& costs, int i, int total_cost) {\n        if (i == target.length())\n            return total_cost;\n        \n        auto mc = -1;\n        for(int k = 0; k < words.size(); k++) {\n            auto& w = words[k];\n            int wl = w.length();\n\n            if (i + wl > target.length())\n                continue;\n\n            bool starts_with_w = true;\n            for(int j = 0; j < wl; j++) {\n                if (w[j] != target[i + j]) { // we could get out of range here\n                    starts_with_w = false;\n                    break;\n                }\n            }\n\n            if (starts_with_w) {\n                int mcw = minimumCost(target, words, costs, i + wl, total_cost + costs[k]);\n                if (mc == -1)\n                    mc = mcw;\n                else if (mcw != -1)\n                    mc = min(mc, mcw);\n            }\n        }\n\n        return mc;\n    }\n\n    struct TreeNode {\n        TreeNode(int c) {\n            cost = c;\n        }\n\n        map<char, TreeNode*> children;\n\n        int cost;\n\n        void insert(string &word, int cost, int i) {\n            if (i == word.length()) {\n                if (this->cost == -1)\n                    this->cost = cost;\n                else\n                    this->cost = min(cost, this->cost);\n                return;\n            }\n\n            char c = word[i];\n            if (children.find(c) == children.end()) {\n                children[c] = new TreeNode(-1);\n            }\n            children[c]->insert(word, cost, i+1);\n        }\n    };\n\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        // return minimumCost(target, words, costs, 0, 0);\n        TreeNode root(-1);\n        for(int i = 0; i < words.size(); i++)\n            root.insert(words[i], costs[i], 0);\n\n        // Turning recursion into DP\n        int n = target.length();\n\n        // M[i] = minimum cost for the substring target[i..]\n        vector<int> M(n + 1);\n        M[n] = 0;\n\n        for(int i = n - 1; i >= 0; i--) {\n            // cout << \"Computing M[\" << i << \", \" << target.substr(i) << \"]\" << endl;\n\n            // Find word that target[i] starts from\n            int mc = -1;\n            int j = i;\n            TreeNode *curr = &root;\n            while (j <= n && curr != nullptr) {\n                if (curr->cost != -1 && M[j] != -1) {\n                    int mcw = curr->cost + M[j];\n                    mc = (mc == -1) ? mcw : min(mc, mcw);\n                    // cout << \"    Found new optimal cost \" << mc << endl;\n                }\n\n                if (j == n)\n                    break;\n\n                if (curr->children.find(target[j]) != curr->children.end()) {\n                    // cout << \"    Find character \" << target[j] << endl;\n                    curr = curr->children[target[j]];\n                } else\n                    curr = nullptr; // cannot proceed any further\n\n                j++;\n            }\n\n            M[i] = mc;\n        }\n\n        return M[0];\n    }\n};",
    "submit_ts": "1720324251",
    "subm_id": "1312395086"
}