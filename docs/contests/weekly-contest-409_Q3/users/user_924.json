{
    "username": "tepamid",
    "submission": "\n#define fo(i, n) for (int i = 0; i < n; ++i)\n#define foback(i, n) for (int i = n - 1; i >= 0; --i)\n#define fo1(i, n) for (ll i = 1; i <= n; ++i)\n\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define makeunique(x) sort(all(x)), (x).resize(unique(all(x)) - (x).begin())\n\ntypedef long long ll;\n\n\nstruct Segtree_RangeAdd_RangeSum {\n    struct node {\n        ll set;\n        ll val;\n    };\n\n    ll NO_OPERATION = LLONG_MIN;\n    ll ZERO = 1e9;\n\n    vector<node> tree;\n    int size;\n\n    ll op_modify(ll a, ll b) {\n        if (b == NO_OPERATION) {\n            return a;\n        }\n\n        if (a == NO_OPERATION) {\n            return b;\n        }\n\n        return a+b;\n    }\n\n    ll op_modify_value(ll val, ll b, int len) {\n        if (b == NO_OPERATION) {\n            return val;\n        }\n    // cout << \"op_modify_value \" << val +b << \" at len \" << len <<endl;\n        return val + b;// *len;\n    }\n\n    ll op_get(ll a, ll b) {\n        return min(a, b);\n    }\n\n    void init(int n) {\n        size = 1;\n        while (size < n)\n            size *= 2;\n        tree.resize(2 * size - 1, {NO_OPERATION, 0});\n        // build(0, 0, size);\n    }\n\n    void propagate(int x, int lx, int rx) {\n        if (tree[x].set == NO_OPERATION || rx - lx == 1) {\n            return;\n        }\n\n        int m = (lx + rx) / 2;\n        tree[getLeftChild(x)].set = op_modify(tree[getLeftChild(x)].set, tree[x].set);\n        tree[getLeftChild(x)].val = op_modify_value(tree[getLeftChild(x)].val, tree[x].set, m-lx);\n\n        tree[getRightChild(x)].set = op_modify(tree[getRightChild(x)].set, tree[x].set);\n        tree[getRightChild(x)].val = op_modify_value(tree[getRightChild(x)].val, tree[x].set, rx-m);\n        tree[x].set = NO_OPERATION;\n    }\n\n    void modify(int l, int r, ll v) {\n        modify(l, r, v, 0, 0, size);\n    }\n\n    void modify(int l, int r, ll v, int x, int lx, int rx) {\n        propagate(x, lx, rx);\n\n        if (lx >= r || l >= rx) {\n            return;\n        }\n\n        if (lx >= l && rx <= r) {\n            tree[x].set = op_modify(tree[x].set, v);\n            tree[x].val = op_modify_value(tree[x].val, v, rx-lx);\n\n            return;\n        }\n\n        int m = (lx + rx) / 2;\n        modify(l, r, v, getLeftChild(x), lx, m);\n        modify(l, r, v, getRightChild(x), m, rx);\n\n        tree[x].val = op_get(tree[getLeftChild(x)].val,\n                             tree[getRightChild(x)].val);\n    }\n\n    ll get(int l, int r) {\n        return get(l, r, 0, 0, size);\n    }\n\n    ll get(int l, int r, int x, int lx, int rx) {\n        propagate(x, lx, rx);\n\n        if (lx >= r || l >= rx) {\n            return ZERO;\n        }\n        if (lx >= l && rx <= r) {\n            return tree[x].val;\n        }\n\n        int m = (lx + rx) / 2;\n        ll valL = get(l, r, getLeftChild(x), lx, m);\n        ll valR = get(l, r, getRightChild(x), m, rx);\n\n        return op_get(valL, valR);\n    }\n\n    int getLeftChild(int x) {\n        return 2 * x + 1;\n    }\n\n    int getRightChild(int x) {\n        return 2 * x + 2;\n    }\n};\n\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& qs) {\n        int q = qs.size();\n        vector<int> ans(q);    \n        \n        vector<vector<int>> g(n);\n        for(int i=0; i+1<n; i++) {\n            g[i].push_back(i+1);\n        }\n        \n        Segtree_RangeAdd_RangeSum st;\n        st.init(n);\n        for(int i=0; i<n; i++) {\n            st.modify(n-1-i, n-1-i +1, i);\n\n        }\n        // for(int i=0; i<n; i++) cout << st.get(i, i+1) << \" \"; cout << endl;\n        \n        for(int qi=0; qi<q; qi++) {\n            auto u = qs[qi][0];\n            auto v = qs[qi][1];\n            \n            g[u].push_back(v);\n            \n            int nd = st.get(v,v+1) + 1;\n            int curd = st.get(u,u+1);\n            int diff = curd - nd;\n            \n            if (curd > nd) {\n                int l = -1; // not needed\n                int r = u; // [u,u] we do for sure\n                \n                while (l+1<r) {\n                    int m = (l+r)/2;\n                    \n                    int x = st.get(m,u+1);\n                    int newValueAtM = curd;// + (u-m);\n                    if (x < newValueAtM) {\n                        l=m;\n                    } else {\n                        r=m;\n                    }\n                }  \n                \n                st.modify(r, u+1, -diff);\n                // cout << \"update \" << r << \" .. \" << u+1 << \" with \" << -diff << endl; \n            }\n            \n            \n            ans[qi] = st.get(0,1) ;// d[0];\n\n            // for(int i=0; i<n; i++) cout << st.get(i, i+1) << \" \"; cout << endl;\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": "1722743255",
    "subm_id": "1343787872"
}