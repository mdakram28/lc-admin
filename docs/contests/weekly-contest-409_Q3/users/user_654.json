{
    "username": "pi3rr0t",
    "submission": "class SegmentTree:\n    def __init__(self, a):\n        self.n = len(a)\n        self.t = [0] * (4 * self.n)  # Segment tree array\n        self.lazy = [None] * (4 * self.n)  # Lazy propagation array\n        self.build(a, 1, 0, self.n - 1)\n    \n    def build(self, a, v, tl, tr):\n        if tl == tr:\n            self.t[v] = a[tl]\n        else:\n            tm = (tl + tr) // 2\n            self.build(a, v * 2, tl, tm)\n            self.build(a, v * 2 + 1, tm + 1, tr)\n            self.t[v] = self.t[v * 2] + self.t[v * 2 + 1]\n    \n    def push(self, v, tl, tr):\n        if self.lazy[v] is not None:\n            # Apply the pending update to the current node\n            self.t[v] = (tr - tl + 1) * self.lazy[v]\n            if tl != tr:\n                # Propagate the pending update to the children\n                self.lazy[v * 2] = self.lazy[v]\n                self.lazy[v * 2 + 1] = self.lazy[v]\n            # Clear the current node's lazy value\n            self.lazy[v] = None\n\n    def update(self, l, r, new_val):\n        self._update(1, 0, self.n - 1, l, r, new_val)\n\n    def _update(self, v, tl, tr, l, r, new_val):\n        self.push(v, tl, tr)\n        if l > r:\n            return\n        if l == tl and tr == r:\n            self.lazy[v] = new_val\n            self.push(v, tl, tr)\n        else:\n            tm = (tl + tr) // 2\n            self._update(v * 2, tl, tm, l, min(r, tm), new_val)\n            self._update(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, new_val)\n            self.t[v] = self.t[v * 2] + self.t[v * 2 + 1]\n    \n    def query(self, l, r):\n        return self._query(1, 0, self.n - 1, l, r)\n\n    def _query(self, v, tl, tr, l, r):\n        self.push(v, tl, tr)\n        if l > r:\n            return 0\n        if l == tl and tr == r:\n            return self.t[v]\n        else:\n            tm = (tl + tr) // 2\n            left_sum = self._query(v * 2, tl, tm, l, min(r, tm))\n            right_sum = self._query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r)\n            return left_sum + right_sum\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        ans = []\n        segtree = SegmentTree([1]*n)\n        for l, r in queries:\n            segtree.update(l+1, r-1, 0)\n            ans.append(segtree.query(0, n-1)-1)\n        return ans",
    "submit_ts": "1722741999",
    "subm_id": "1343758564"
}