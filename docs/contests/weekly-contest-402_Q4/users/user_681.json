{
    "username": "shashanknani1312",
    "submission": "class Solution {\n     private int[] nums;\n    private int[] segTree;\n    private int n;\n\n    public Solution() {\n    }\n\n    // Build the segment tree\n    private void buildTree(int[] nums, int left, int right, int pos) {\n        if (left == right) {\n            segTree[pos] = isPeak(nums, left) ? 1 : 0;\n            return;\n        }\n        int mid = (left + right) / 2;\n        buildTree(nums, left, mid, 2 * pos + 1);\n        buildTree(nums, mid + 1, right, 2 * pos + 2);\n        segTree[pos] = segTree[2 * pos + 1] + segTree[2 * pos + 2];\n    }\n\n    // Check if a position is a peak\n    private boolean isPeak(int[] arr, int i) {\n        if (i <= 0 || i >= n - 1) return false;\n        return arr[i] > arr[i - 1] && arr[i] > arr[i + 1];\n    }\n\n    // Update the segment tree\n    private void updateTree(int left, int right, int index, int pos) {\n        if (left == right) {\n            segTree[pos] = isPeak(nums, index) ? 1 : 0;\n            return;\n        }\n        int mid = (left + right) / 2;\n        if (index <= mid) {\n            updateTree(left, mid, index, 2 * pos + 1);\n        } else {\n            updateTree(mid + 1, right, index, 2 * pos + 2);\n        }\n        segTree[pos] = segTree[2 * pos + 1] + segTree[2 * pos + 2];\n    }\n\n    // Range query to get the peak count\n    private int rangeQuery(int left, int right, int qLeft, int qRight, int pos) {\n        if (qLeft > right || qRight < left) return 0; // no overlap\n        if (qLeft <= left && qRight >= right) return segTree[pos]; // total overlap\n        int mid = (left + right) / 2;\n        return rangeQuery(left, mid, qLeft, qRight, 2 * pos + 1) +\n               rangeQuery(mid + 1, right, qLeft, qRight, 2 * pos + 2); // partial overlap\n    }\n\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        this.nums = nums;\n        this.n = nums.length;\n        this.segTree = new int[4 * n];\n        List<Integer> result = new ArrayList<>();\n\n        // Build the initial segment tree\n        buildTree(nums, 0, n - 1, 0);\n\n        for (int[] query : queries) {\n            if (query[0] == 2) {  // Update query\n                int index = query[1];\n                int newValue = query[2];\n                nums[index] = newValue;\n\n                // Update affected positions in the segment tree\n                if (index > 0) updateTree(0, n - 1, index - 1, 0);\n                updateTree(0, n - 1, index, 0);\n                if (index < n - 1) updateTree(0, n - 1, index + 1, 0);\n\n            } else if (query[0] == 1) {  // Count query\n                int li = query[1];\n                int ri = query[2];\n                result.add(rangeQuery(0, n - 1, li + 1, ri - 1, 0));\n            }\n        }\n\n        return result;\n    }\n}",
    "submit_ts": 1718507319.0
}