{
    "username": "maybk",
    "submission": "class Solution {\n    #define all(v) v.begin(), v.end()\n    template<typename Node>\nstruct sparse {\n\tvector<vector<Node>> table;\n\tvector<int> logValues;\n\tint n;\n\tint maxLog;\n\tvector<int> a;\n\tsparse(int n1, vector<int> &arr) {\n\t\tn = n1;\n\t\ta = arr;\n\t\ttable.resize(n);\n\t\tlogValues.resize(n + 1);\n\t\tmaxLog = log2(n);\n\t\tlogValues[1] = 0;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tlogValues[i] = logValues[i / 2] + 1;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ttable[i].resize(maxLog + 1);\n\t\t\tfill(all(table[i]), Node());\n\t\t}\n\t\tbuild();\n\t}\n\tvoid build() {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ttable[i][0] = Node(a[i]);\n\t\t}\n\t\tfor (int i = 1; i <= maxLog; i++) {\n\t\t\tfor (int j = 0; (j + (1 << i)) <= n; j++) {\n\t\t\t\ttable[j][i].merge(table[j][i - 1], table[j + (1 << (i - 1))][i - 1]);\n\t\t\t}\n\t\t}\n\t}\n\tNode queryNormal(int left, int right) {\n\t\tNode ans = Node();\n\t\tfor (int j = logValues[right - left + 1]; j >= 0; j--) {\n\t\t\tif ((1 << j) <= right - left + 1) {\n\t\t\t\tans.merge(ans, table[left][j]);\n\t\t\t\tleft += (1 << j);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tNode queryIdempotent(int left, int right) {        //min, max, gcd, and, or\n\t\tint j = logValues[right - left + 1];\t   //xor is not idempotent\n\t\tNode ans = Node();\n\t\tans.merge(table[left][j], table[right - (1 << j) + 1][j]);\n\t\treturn ans;\n\t}\n};\nstruct Node1 {\n\tint val; // store more info if required\n\tNode1() { // Identity Element\n\t\tval = 0;\n\t}\n\tNode1(int v) {\n\t\tval = v;\n\t}\n\tvoid merge(Node1 &l, Node1 &r) {\n\t\tval = l.val & r.val;\n\t}\n};\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        int n=nums.size();\n        nums.insert(nums.begin(),0ll);\n        sparse<Node1>st(nums.size(),nums);\n        int ans=1e9;\n        for(int i=1;i<=n;i++){\n            int lo=1,hi=i;\n            int l=-1,r=-1;\n            auto check=[&](int m){\n                return st.queryIdempotent(m,i).val>=k;\n            };\n            while(hi-lo>1){\n                int mid=hi+lo>>1;\n                if(check(mid))hi=mid;else lo=mid+1;\n            }if(check(lo))l=lo;else if(check(hi))l=hi;\n            lo=1;hi=i;\n            while(hi-lo>1){\n                int mid=hi+lo>>1;\n                if(!check(mid))lo=mid;else hi=mid-1;\n            }if(!check(hi))r=hi;else if(!check(lo))r=lo;\n            if(l!=-1){\n                ans=min(ans,st.queryIdempotent(l,i).val-k);\n            }\n            if(r!=-1){\n                ans=min(ans,k-st.queryIdempotent(r,i).val);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1717297882",
    "subm_id": "1274759278"
}