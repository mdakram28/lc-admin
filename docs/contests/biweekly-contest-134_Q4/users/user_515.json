{
    "username": "Timid_Tom",
    "submission": "class Solution {\npublic:\n    // SEGMENT TREE\n    class SegTree {\n        vector<int> tree;\n        vector<int> lazy;\n\n    public:\n        SegTree(int n) {\n            tree.resize(4 * n + 1, 0);\n            lazy.resize(4 * n + 1, 0);\n        }\n\n        void buildTree(int node, int start, int end, vector<int>& A) {\n            if (start == end) {\n                tree[node] = A[end];\n                return;\n            }\n\n            int mid = (start + end) / 2;\n\n            buildTree(2 * node, start, mid, A);\n            buildTree(2 * node + 1, mid + 1, end, A);\n\n            tree[node] = (tree[2 * node] & tree[2 * node + 1]);\n        }\n\n        void updateTree(int node, int start, int end, int idx, int val) {\n            if (start == end) {\n                tree[node] = val;\n                return;\n            }\n\n            int mid = (start + end) / 2;\n\n            if (idx <= mid)\n                updateTree(2 * node, start, mid, idx, val);\n            else\n                updateTree(2 * node + 1, mid + 1, end, idx, val);\n\n            tree[node] = tree[2 * node] & tree[2 * node + 1];\n        }\n\n        int query(int node, int start, int end, int L, int R) {\n            // The Range which we are currently in : [start, end]\n            // The Range of which we have to compute the answer : [L, R]\n\n            // Outside Range\n            if (R < start || L > end)\n                return INT_MAX; // need to return something that can be avoided\n\n            // In Range\n            if (start >= L && end <= R)\n                return tree[node];\n\n            // Partial Overlap\n            int mid = (start + end) / 2;\n            int leftans = query(2 * node, start, mid, L, R);\n            int rightans = query(2 * node, mid + 1, end, L, R);\n\n            return (leftans & rightans); // do whatever operation you want to do\n        }\n    };\n\n#define ll long long\n\n    long long countSubarrays(vector<int>& nums, int k) {\n        int n = nums.size();\n        unordered_map<ll, ll> mp;\n        ll ans = 0;\n        for (auto it : nums) {\n            unordered_map<ll, ll> mp1;\n            for (auto it1 : mp) {\n                ll cnt1 = it1.first & it;\n                mp1[cnt1] += it1.second;\n            }\n            mp1[it] += 1;\n            mp = mp1;\n            ans += mp[k];\n        }\n        return ans;\n    }\n};\n",
    "submit_ts": "1720279466",
    "subm_id": "1311752330"
}