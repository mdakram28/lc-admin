{
    "username": "asdfanuiu",
    "submission": "/**\n * @param {number} n\n * @param {number[][]} queries\n * @return {number[]}\n */\nclass Fenwick {\n    constructor(arr) {\n        this.arr = arr;\n    }\n    \n    query(index) {\n        let sum = 0;\n        while (index > 0) {\n            sum += this.arr[index];\n            index -= (index & -index);\n        }\n        return sum;\n    }\n    \n    update(index, delta) {\n        while (index < this.arr.length) {\n            this.arr[index] += delta;\n            index += (index & (-index));\n        }\n    }\n}\n\nclass SegmentNode {\n    constructor(a, b) {\n        this.start = a;\n        this.end = b;\n        this.info = 0;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass SegmentTree {\n    constructor(root) {\n        this.root = root;\n    }\n\n    constructTree(node, a, b) {\n        let nums = this.nums;\n        if (a === b) {\n            return;\n        }\n        let mid = a + Math.floor((b - a) / 2);  \n        node.left = new SegmentNode(a, mid);\n        node.right = new SegmentNode(mid + 1, b);\n        this.constructTree(node.left, a, mid);\n        this.constructTree(node.right, mid + 1, b);\n        node.info = Math.max(node.left.info, node.right.info);\n    }\n\n    update(node, index, val) {\n\t\t\t\tif (!node) return;\n        if (node.start > index || node.end < index) return;\n        if (node.start === index && node.end === index) {\n            node.info = val;\n            return;\n        }\n        this.update(node.left, index, val);\n        this.update(node.right, index, val);\n        node.info = Math.max(node.left.info, node.right.info);\n    }\n\n    query(node, a, b) {\n\t\t\t\tif (!node) return 0;\n        if (a > node.end || b < node.start) {\n            return 0;\n        }\n        if (a <= node.start && b >= node.end) {\n            return node.info;\n        }\n        return Math.max(this.query(node.left, a, b), this.query(node.right, a, b));\n    }\n}\n\n \nvar shortestDistanceAfterQueries = function(n, queries) {\n    let res = [];\n    let helper = Array.from({length: n + 1}).map((a, b) => 0);\n    let arr = new Array(n + 1).fill(0);\n    let tree = new Fenwick(arr);\n    let arr2 = new Array(n + 1).fill(0);\n    let root = new SegmentNode(0, n - 1);\n    let tree2 = new SegmentTree(root);\n    tree2.constructTree(root, 0, n - 1);\n    for (let i = 0; i < n; i++) {\n        tree2.update(root, i, i);\n    }\n    let max = Array.from({length: n}).map((a, b) => b);\n    let copy = [];\n    for (let [a, b] of queries) {\n        let tempMax = tree2.query(root, 0, a);\n        // console.log(tempMax);\n        if (tempMax > b) {\n            copy.push(null);\n        } else {\n            copy.push([a, b]);\n            max[a] = Math.max(max[a], b);\n            tree2.update(root, a, max[a]);\n        }\n    }\n    queries = copy;\n    console.log(copy, max)\n    for (let i = 0; i < queries.length; i++) {\n        if (queries[i] === null) {\n            res.push(res[res.length - 1]);\n            continue;\n        }\n        let [a, b] = queries[i];\n        let diff = b - a;\n        let minV = 1 - diff - (tree.query(b) - tree.query(a + 1));\n        if (minV < helper[b]) {\n            diff = minV - helper[b];\n            helper[b] = Math.min(helper[b], minV);\n            tree.update(b + 1, diff);\n        }\n        res.push(tree.query(n) + n - 1);\n    }\n    // console.log(helper)\n    return res;\n};\n//8\n//[[1,6],[2,5]]\n//[3, 3]",
    "submit_ts": "1722742929",
    "subm_id": "1343780321"
}