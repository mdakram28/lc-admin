{
    "username": "U_U",
    "submission": "class Solution {\npublic:\n    int m;\n    int n;\n    int maxVal;\n    vector<int> reps;\n    int mem[100005][4];\n    int minFlips(vector<vector<int>>& grid) {\n        m = grid.size();\n        n = grid[0].size();\n        maxVal = m * n * 2;\n        reps = vector<int>(m * n, -1);\n\n        for (int r = 0; r <  m; ++r)\n        {\n            int lo = 0;\n            int hi = n - 1;\n            while (lo < hi)\n            {\n                Union(reps, r * n + lo, r * n + hi);\n                ++lo;\n                --hi;                                \n            }\n        }\n\n        for (int c = 0; c < n; ++c)\n        {\n            int lo = 0;\n            int hi = m - 1;\n            while (lo < hi)\n            {\n                Union(reps, lo * n + c, hi * n + c);\n                ++lo;\n                --hi;\n            }\n        }\n\n        unordered_map<int, vector< pair<int, int> > > dict;\n        for (int r = 0; r < m; ++r)\n            for (int c = 0; c < n; ++c)\n            {\n                dict[ findRep(reps, r * n + c) ].push_back( {r, c} );\n            }\n\n        int res = 0;\n        vector< vector<int> > cnts;\n        for (auto& item : dict)\n        {\n            vector< pair<int, int> > vec = item.second;\n            int ones = 0;\n            int zeros = 0;\n            for (auto& cur : vec)\n            {\n                if (grid[cur.first][cur.second] == 0) ++zeros;\n                if (grid[cur.first][cur.second] == 1) ++ones;\n            }\n            cnts.push_back( {zeros, ones} );           \n        }\n\n        for (int i = 0; i < cnts.size(); ++i)        \n        {\n            mem[i][0] = -1;\n            mem[i][1] = -1;\n            mem[i][2] = -1;\n            mem[i][3] = -1;\n        }\n\n        int existingOnes = 0;\n        for (int r = 0; r < m; ++r)\n            for (int c = 0; c < n; ++c) if (grid[r][c] == 1) ++existingOnes;\n\n        return dp(0, existingOnes % 4, cnts);\n    }\n\n    int dp(int index, int oneMod, vector< vector<int> >& cnts)\n    {        \n        if (index == cnts.size())\n        {\n            if (oneMod != 0) return maxVal;\n            return 0;\n        }\n        if (mem[index][oneMod] != -1) return mem[index][oneMod];\n      //  cout << index << \",\" << cnts[index][0] << \",\" << cnts[index][1] << endl;\n\n        vector<int>& vec = cnts[index];\n        int ret = maxVal;\n        if (vec[0] == 0 && vec[1] > 0)\n        {\n            ret = min(ret, dp(index + 1, oneMod, cnts));\n            ret = min(ret, vec[1] + dp(index + 1, (oneMod + 4 - vec[1]) % 4, cnts));\n        }\n        else if (vec[0] > 0 && vec[1] == 0)\n        {\n            ret = min(ret, dp(index + 1, oneMod, cnts));\n            ret = min(ret, vec[0] + dp(index + 1, (oneMod + vec[0]) % 4, cnts));\n        }\n        else \n        {\n            ret = min(ret, vec[1] + dp(index + 1, (oneMod + 4 - vec[1]) % 4, cnts));\n            ret = min(ret, vec[0] + dp(index + 1, (oneMod + vec[0]) % 4, cnts));\n        }\n\n       // cout << index << \",\" << oneMod << \"|\" << ret << endl;\n       mem[index][oneMod] = ret;\n        return ret;\n    }\n\n    int findRep(vector<int>& reps, int i)\n    {\n        if (reps[i] == -1) return i;\n        int ret = findRep(reps, reps[i]);\n        reps[i] = ret;\n        return ret;\n    }\n\n    void Union(vector<int>& reps, int i, int t)\n    {\n        int iRep = findRep(reps, i);\n        int tRep = findRep(reps, t);\n        if (tRep != iRep)\n        {\n            reps[tRep] = iRep;\n        }\n    }\n}; ",
    "submit_ts": "1722697337",
    "subm_id": "1343142910"
}