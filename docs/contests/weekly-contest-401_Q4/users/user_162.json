{
    "username": "curiosity-10",
    "submission": "class Solution {\npublic:\n    int maxTotalReward(vector<int>& rewardValues) {\n        int n = rewardValues.size();\n        \n        // Sort rewardValues in ascending order\n        sort(rewardValues.begin(), rewardValues.end());\n        \n        int mx = rewardValues[n - 1];\n        vector<long long> dp(mx + 1, -1);\n\n        // Initialize dp array for values present in rewardValues\n        for (int num : rewardValues) {\n            dp[num] = 1;\n        }\n\n        // Recursive function to calculate dp values\n        function<int(int)> foo = [&](int i) -> int {\n            if (dp[i] != -1) return dp[i];\n\n            // Find the largest element in rewardValues that is less than i\n            auto it = lower_bound(rewardValues.begin(), rewardValues.end(), i); \n            if (it != rewardValues.begin()) {\n                --it;\n                while (true) {\n                    int y = *it;\n                    if (y * 2 <= i) {\n                        return dp[i] = 0;\n                    }\n                    if (foo(i - y)) {\n                        return dp[i] = 1;\n                    }\n                    if (it == rewardValues.begin()) {\n                        break;\n                    }\n                    --it;\n                }\n            }\n            return dp[i] = 0;\n        };\n\n        // Iterate from mx-1 to 1 to find the maximum total reward\n        for (int i = mx - 1; i > 0; --i) {\n            if (foo(i)) return i + mx;\n        }\n\n        // If no valid combination is found, return mx\n        return mx;\n    }\n};",
    "submit_ts": "1717905252",
    "subm_id": "1282384535"
}