{
    "username": "Swayam Sah",
    "submission": "class Solution {\npublic:\n    // Arrays to store intermediate results for dynamic programming\n    char dp[100001][7];\n    char dp_non_zero[100001][7];\n    int nxt_mod[100001][7];\n    int non_zero_nxt_mod[100001][7];\n    \n    // Function to find the largest palindrome for given n and k\n    string largestPalindrome(int n, int k) {\n        // If k is 1, 3, or 9, return the largest possible palindrome composed of '9's\n        if (k == 1 || k == 3 || k == 9) {\n            return string(n, '9');\n        }\n        \n        // Handle the case where k is 2\n        if (k == 2) {\n            if (n == 1) {\n                return \"8\";  // Special case for n = 1\n            }\n            string result(n, '9');  // Create a string with '9's\n            result[0] = '8';  // Set the first and last character to '8'\n            result[n - 1] = '8';\n            return result;\n        }\n        \n        // Handle the case where k is 5\n        if (k == 5) {\n            if (n == 1) {\n                return \"5\";  // Special case for n = 1\n            }\n            string result(n, '9');\n            result[0] = '5';  // Set the first and last character to '5'\n            result[n - 1] = '5';\n            return result;\n        }\n        \n        // Handle the case where k is 4\n        if (k == 4) {\n            if (n <= 3) {\n                return string(n, '8');  // If n is small, use '8's\n            }\n            string result(n, '9');\n            result[0] = '8';  // Set specific positions to '8'\n            result[n - 1] = '8';\n            result[1] = '8';\n            result[n - 2] = '8';\n            return result;\n        }\n        \n        // Handle the case where k is 8\n        if (k == 8) {\n            if (n <= 5) {\n                return string(n, '8');  // If n is small, use '8's\n            }\n            string result(n, '9');\n            result[0] = '8';\n            result[n - 1] = '8';\n            result[1] = '8';\n            result[n - 2] = '8';\n            result[2] = '8';\n            result[n - 3] = '8';\n            return result;\n        }\n        \n        // Handle the case where k is 6\n        if (k == 6) {\n            if (n == 1) {\n                return \"6\";  // Special case for n = 1\n            }\n            if (n == 2) {\n                return \"66\";  // Special case for n = 2\n            }\n            if (n == 3) {\n                return \"888\";  // Special case for n = 3\n            }\n            string result(n, '9');\n            result[0] = '8';  // Set specific positions to '8'\n            result[n - 1] = '8';\n            if (n % 2 == 1) {\n                result[n / 2] = '8';  // If n is odd, set the middle to '8'\n            } else {\n                result[n / 2] = '7';  // If n is even, set the middle to '77'\n                result[(n / 2) - 1] = '7';\n            }\n            return result;\n        }\n        \n        // Handle the case where k is 7\n        if (k == 7) {\n            if (n == 1) {\n                return \"7\";  // Special case for n = 1\n            }\n            // Initialize dp arrays to 0\n            fill(&dp[0][0], &dp[0][0] + sizeof(dp), 0);\n            fill(&dp_non_zero[0][0], &dp_non_zero[0][0] + sizeof(dp_non_zero), 0);\n\n            // Initialize dp for single digit numbers\n            for (int i = 1; i < 10; ++i) {\n                dp[1][i % 7] = '0' + i;\n                if (i != 0) {\n                    dp_non_zero[1][i % 7] = '0' + i;\n                }\n            }\n\n            int base_mod = 10 % 7;\n            for (int i = 0; i <= 100000 - 2; ++i) {\n                for (int j = 0; j < 7; ++j) { // Current palindrome mod\n                    if ((i == 0 && j != 0) || (i > 0 && dp[i][j] == 0)) {\n                        continue;\n                    }\n                    for (int k = 9; k >= 0; --k) { // New digit, starting from largest to smallest\n                        int new_mod = (base_mod * k + k + j * 10) % 7;\n                        if (dp[i + 2][new_mod] == 0 || dp[i + 2][new_mod] < '0' + k) {\n                            dp[i + 2][new_mod] = '0' + k;\n                            nxt_mod[i + 2][new_mod] = j;\n                        }\n                        if (k == 0) continue;\n                        if (dp_non_zero[i + 2][new_mod] == 0 || dp_non_zero[i + 2][new_mod] < '0' + k) {\n                            dp_non_zero[i + 2][new_mod] = '0' + k;\n                            non_zero_nxt_mod[i + 2][new_mod] = j;\n                        }\n                    }\n                }\n                base_mod = (base_mod * 10) % 7;\n            }\n            \n            // Build the palindrome\n            int q = n;\n            string front(1, dp_non_zero[q][0]);\n            string back(1, dp_non_zero[q][0]);\n            int mod = non_zero_nxt_mod[q][0];\n            q -= 2;\n            while (q) {\n                front += dp[q][mod];\n                if (q > 1) back += dp[q][mod];\n                else break;\n                mod = nxt_mod[q][mod];\n                q -= 2;\n            }\n            reverse(back.begin(), back.end());\n            string ans = front + back;\n            return ans;\n        }\n\n        return \"\"; // Default return if no conditions are met\n    }\n};\n",
    "submit_ts": "1723953453",
    "subm_id": "1359821647"
}