{
    "username": "Ayanerru",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def subtree(edge):\n            if len(edge) <= 1:\n                return len(edge)\n            n = len(edge) + 1\n            e = collections.defaultdict(list)\n            indeg = [0] * n\n            for u, v in edge:\n                e[u].append(v)\n                e[v].append(u)\n                indeg[u] += 1\n                indeg[v] += 1\n            \n            remain = set([i for i in range(n)])\n            dq = [i for i in range(n) if indeg[i] == 1]\n            for node in dq:\n                remain.remove(node)\n            # print('dq: ', dq)\n            step = 0\n            while dq:\n                step += 1\n                nxt_dq = []\n                for node in dq:\n                    for neibor in e[node]:\n                        if neibor in remain:\n                            indeg[neibor] -= 1\n                            indeg[node] -= 1\n                        if indeg[neibor] == 1:\n                            nxt_dq.append(neibor)\n                # print('indeg:', indeg)\n                # print('next_dq', nxt_dq)\n                for node in nxt_dq:\n                    remain.remove(node)\n                \n                if len(remain) == 0:\n                    if len(nxt_dq) == 1:\n                        return step * 2\n                    elif len(nxt_dq) == 2:\n                        return step * 2 + 1\n                dq = nxt_dq\n                \n            return -1\n        \n        \n        e1 = subtree(edges1)\n        e2 = subtree(edges2)\n        # print('e1:', e1, ', e2:', e2)\n        # 3->2\n        # 4->2\n        \n        return max(e1, e2, 1 + (e1+1)//2 + (e2+1) // 2)",
    "submit_ts": "1719717776",
    "subm_id": "1304400464"
}