{
    "username": "ard001",
    "submission": "class Solution {\npublic:\n    void dfs1(int u,int p,vector<vector<int>> &tree,vector<int>&height,vector<vector<int>>&who){\n        height[u] = 0 ;\n        for(int v: tree[u])if(v!=p){\n            dfs1(v,u,tree,height,who);\n            height[u] = max(height[u], height[v]+1);\n            if(who[u][0] == -1) who[u][0] = v;\n            else if(height[who[u][0]]<=height[v]) who[u][1] = who[u][0], who[u][0] = v;\n            else if(who[u][1]==-1 || height[who[u][1]]<height[v]) who[u][1] = v;\n        }\n    }\n    void dfs2(int u,int p,int pa,vector<vector<int>>&tree,vector<vector<int>>&who,vector<int>&height,vector<int>&ans){\n        ans[u] = max(ans[u], pa);\n        for(int v: tree[u])if(v!=p){\n            int npa = pa+1;\n            if(who[u][0] == v) npa = max(npa, who[u][1] == -1 ? 0 : height[who[u][1]]+2);\n            else npa = max(npa, height[who[u][0]]+2);\n            dfs2(v,u,npa,tree,who,height,ans);\n        }\n    }\n    pair<int,int> work(const vector<vector<int>> &edges){\n        const int n = edges.size()+1;\n        vector<vector<int>> tree(n,vector<int>());\n        for(auto edge: edges){\n            tree[edge[0]].push_back(edge[1]);\n            tree[edge[1]].push_back(edge[0]);\n        }\n        vector<vector<int>> who(n,vector<int>(2,-1));\n        vector<int> height(n);\n        dfs1(0,0,tree,height,who);\n        vector<int> ans = height;\n        dfs2(0,0,0,tree,who,height,ans);\n        return make_pair(*min_element(begin(ans), end(ans)), *max_element(begin(ans), end(ans)));\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        auto u = work(edges1);\n        auto v = work(edges2);\n        int ans = max({ u.second , v.second, u.first + v.first +1});\n        return ans;\n    }\n};",
    "submit_ts": 1719717638.0
}