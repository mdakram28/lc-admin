{
    "username": "SR3mix",
    "submission": "typedef long long ll;\nclass Solution {\npublic:\n    vector<array<int, 2>>all;\n    int n;\n    vector<array<ll, 3>>v,w;\n    map<int, int>mv,mw;\n    ll compute(array<ll, 3>&a1, array<ll, 3>&a2) {\n        return max(abs(a1[0] - a2[0]), abs(a1[1] - a2[1]));\n    }\n    bool check(int m) {\n        if (compute(v[0], v[n-1]) <= m && compute(w[0], w[n-1]) <= m) return true;\n        if (compute(v[0], v[n-1]) > m && compute(v[1], v[n-1]) <= m) {\n            int wi = mw[v[0][2]];\n            if (wi == 0 && compute(w[1], w[n-1]) <= m) return true;\n            else if (wi == n-1 && compute(w[0], w[n-2]) <= m) return true;\n            else if (wi > 0 && wi < n-1 && compute(w[0], w[n-1]) <= m) return true;\n            \n        }\n        else if (compute(v[0], v[n-1]) > m && compute(v[0], v[n-2]) <= m) {\n            int wi = mw[v[n-1][2]];\n            if (wi == 0 && compute(w[1], w[n-1]) <= m) return true;\n            else if (wi == n-1 && compute(w[0], w[n-2]) <= m) return true;\n            else if (wi > 0 && wi < n-1 && compute(w[0], w[n-1]) <= m) return true;\n        }\n        swap(v,w); swap(mv,mw);\n        if (compute(v[0], v[n-1]) > m && compute(v[1], v[n-1]) <= m) {\n            int wi = mw[v[0][2]];\n            if (wi == 0 && compute(w[1], w[n-1]) <= m) return true;\n            else if (wi == n-1 && compute(w[0], w[n-2]) <= m) return true;\n            else if (wi > 0 && wi < n-1 && compute(w[0], w[n-1]) <= m) return true;\n            \n        }\n        else if (compute(v[0], v[n-1]) > m && compute(v[0], v[n-2]) <= m) {\n            int wi = mw[v[n-1][2]];\n            if (wi == 0 && compute(w[1], w[n-1]) <= m) return true;\n            else if (wi == n-1 && compute(w[0], w[n-2]) <= m) return true;\n            else if (wi > 0 && wi < n-1 && compute(w[0], w[n-1]) <= m) return true;\n        }\n        swap(v,w); swap(mv,mw);\n        return false;\n    }\n    int minimumDistance(vector<vector<int>>& points) {\n        n = points.size();\n        for (int i = 0; i < points.size(); i++) {\n            int x = points[i][0], y = points[i][1];\n            v.push_back({x + y, x - y, i});\n            w.push_back({x - y, x + y, i});\n        }\n        sort(v.begin(), v.end());\n        sort(w.begin(), w.end());\n        int idx =0 ;\n        for (auto &[x,y,z] : v) {\n            mv[z] = idx; idx++;\n        }\n        idx = 0;\n        for (auto &[x,y,z] : w) {\n            mw[z] = idx; idx++;\n        }\n        ll ans = max(compute(v[0], v[n-1]), compute(w[0], w[n-1]));\n        vector<ll>idxs = {v[0][2], v[n-1][2],w[0][2],w[n-1][2]};\n        for (auto idx : idxs) {\n            vector<array<ll, 3>>t1,t2;\n            for (int i = 0; i < points.size(); i++) {\n                if (i == idx) continue;\n                int x = points[i][0], y = points[i][1];\n                t1.push_back({x + y, x - y, i});\n                t2.push_back({x - y, x + y, i});\n            }\n            sort(t1.begin(), t1.end());\n            sort(t2.begin(), t2.end());\n            ans = min(ans, max(compute(t1[0], t1[n-2]), compute(t2[0], t2[n-2])));\n        }\n        return ans;\n        \n        // ll l = 0, r = LLONG_MAX;\n        // while (l < r) {\n        //     ll m = l + (r-l)/2;\n        //     if (check(m)) r = m;\n        //     else l = m+1;\n        // }\n        // return l;\n    }\n};"
}