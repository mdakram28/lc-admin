{
    "username": "knarf",
    "submission": "class Solution {\n    HashMap<Integer,Integer> hm = new HashMap<>();\n    HashMap<Integer,Integer> rhm = new HashMap<>();\n    int m;\n    int[][] p;\n    class SegmentTree {\n        int type,left,right,mid,value;\n        SegmentTree l,r;\n        SegmentTree(int l,int r,int type) {\n            if(type==1) {\n                value = Integer.MAX_VALUE/2;\n            } else {\n                value = Integer.MIN_VALUE/2;\n            }\n            left = l;\n            right = r;\n            mid = l+(r-l)/2;\n            this.type = type;\n            if(l<r) {\n                this.l = new SegmentTree(l,mid,type);\n                this.r = new SegmentTree(mid+1,r,type);    \n            }\n        }\n        void update(int pos,int v) {\n            if(pos<left || pos>right) return;\n            if(type == 1) {\n                this.value = Math.min(v,this.value);\n            } else {\n                this.value = Math.max(v,this.value);\n            }\n            if(this.left<this.right) {\n                this.l.update(pos,v);\n                this.r.update(pos,v);    \n            }\n        }\n        \n        int query(int left,int right) {\n            if(left>=this.left && right<=this.right) {\n                return this.value;\n            }\n            if(right<this.left || left>this.right) {\n                if(type == 1) {\n                    return Integer.MAX_VALUE;\n                } else {\n                    return Integer.MIN_VALUE;\n                }\n            }\n            int v1 = this.l.query(left,right);\n            int v2 = this.r.query(left,right);\n            if(type == 1) {\n                return Math.min(v1,v2);\n            } else {\n                return Math.max(v1,v2);\n            }\n        }\n        void output(String s) {\n            System.out.println(String.format(\"%s %d %d %d\",s,left,right,value));\n            if(this.l != null) this.l.output(s);\n            if(this.r != null) this.r.output(s);\n        }\n    }\n    public int minimumDistance(int[][] points) {\n        Arrays.sort(points,(o1,o2)->Integer.compare(o1[0],o2[0]));\n        System.out.println(Arrays.deepToString(points));\n        TreeSet<Integer> ts = new TreeSet<>();\n        for(int[] p:points) ts.add(p[1]);\n        int index = 0;\n        for(Integer v:ts) {\n            hm.put(v,index);\n            rhm.put(index,v);\n            index++;\n        }\n        m = index;\n        this.p = points;\n        int[] r = calc(-1);\n        int p1 = r[0],p2 = -1;\n        for(int i=0;i<p.length;i++) {\n            if(i==p1) continue;\n            int l = Math.abs(p[p1][0]-p[i][0])+Math.abs(p[p1][1]-p[i][1]);\n            if(l == r[1]) {\n                p2 = i;\n                break;\n            }\n        }\n        return Math.min(calc(p1)[1],calc(p2)[1]);\n    }\n    \n    int[] calc(int skip) {\n        int max = Integer.MIN_VALUE;\n        SegmentTree st1 = new SegmentTree(0,m-1,1);\n        SegmentTree st2 = new SegmentTree(0,m-1,2);\n        int maxp = -1;\n        for(int i=0;i<p.length;i++) {\n            if(i==skip) continue;\n            int[] tp = p[i];\n            int vp = hm.get(tp[1]);\n            int v1 = st1.query(0,vp);\n            int v2 = st2.query(vp+1,m-1);\n            int max1 = 0;\n            max1 = Math.max(max,tp[0]+tp[1]-v1);\n            max1 = Math.max(max1,tp[0]-tp[1]+v2);\n            if(max1>max) {\n                maxp = i;\n                max = max1;\n            }\n            st1.update(vp,tp[0]+tp[1]);\n            st2.update(vp,tp[1]-tp[0]);\n            // System.out.println(String.format(\"%d %d %d %d %d\",i,vp,tp[0],tp[1],st1.value));\n        }\n        // st1.output(\"st1\");\n        // st2.output(\"st2\");\n        return new int[]{maxp,max};\n    }\n}"
}