{
    "username": "megaspazz",
    "submission": "class Solution {\n    private static final int MOD = 1_000_000_007;\n    \n    public int countOfPairs(int[] nums) {\n        long[] dp = new long[51];\n        for (int x = 0; x <= 50; ++x) {\n            int y = nums[0] - x;\n            if (!valid(y)) {\n                continue;\n            }\n            dp[x] = 1;\n        }\n        \n        // System.out.println(Arrays.toString(dp));\n        \n        for (int i = 1; i < nums.length; ++i) {\n            long[] next = new long[51];\n            for (int x0 = 0; x0 <= 50; ++x0) {\n                int y0 = nums[i - 1] - x0;\n                for (int xf = x0; xf <= 50; ++xf) {\n                    int yf = nums[i] - xf;\n                    if (!valid(yf) || yf > y0) {\n                        continue;\n                    }\n                    next[xf] = add(next[xf], dp[x0]);\n                }\n            }\n            dp = next;\n            // System.out.format(\"i = %d, dp = %s%n\", i, Arrays.toString(dp));\n        }\n        \n        long ans = 0;\n        for (long x : dp) {\n            ans = add(ans, x);\n        }\n        return (int) ans;\n    }\n    \n    private static boolean valid(int x) {\n        return x >= 0 && x <= 50;\n    }\n    \n    private static final long RAW_MULTIPLY_MAX = 3037000499L;\n\n    private static final int CHUNK_SIZE = Long.SIZE - Long.numberOfLeadingZeros(Long.MAX_VALUE / MOD) - 1;\n    private static final long CHUNK_MASK = (1L << CHUNK_SIZE) - 1;\n\n    @SuppressWarnings(\"unused\")\n    public static long multiply(long a, long b) {\n        if (MOD <= RAW_MULTIPLY_MAX) {\n            return a * b % MOD;\n        }\n        return multiplyInternal(a, b);\n    }\n\n    public static long multiply(long... arr) {\n        long ans = 1;\n        for (long x : arr) {\n            ans = multiply(ans, x);\n        }\n        return ans;\n    }\n\n    public static long add(long a, long b) {\n        long ans = a + b;\n        if (ans >= MOD) {\n            ans -= MOD;\n        }\n        return ans;\n    }\n\n    public static long add(long... arr) {\n        long ans = 0;\n        for (long x : arr) {\n            ans = add(ans, x);\n        }\n        return ans;\n    }\n\n    public static long subtract(long a, long b) {\n        return add(a, MOD - b);\n    }\n\n    private static long normalize(long x) {\n        if (x <= -MOD || x >= MOD) {\n            x %= MOD;\n        }\n        if (x < 0) {\n            x += MOD;\n        }\n        return x;\n    }\n\n    /**\n     * Computes the value of (b ^ e) % MOD.\n     */\n    public static long modPow(long b, long e) {\n        long p = b;\n        long ans = 1;\n        while (e > 0) {\n            if ((e & 1) == 1) {\n                ans = multiply(ans, p);\n            }\n            p = multiply(p, p);\n            e >>= 1;\n        }\n        return ans;\n    }\n\n    /**\n     * Computes the modular inverse, such that: ak % MOD = 1, for some k.\n     * See this page for details:  http://rosettacode.org/wiki/Modular_inverse\n     */\n    public static long modInverse(long a) {\n        long b = MOD;\n        long x0 = 0, x1 = 1;\n        long t, q;\n\n        while (a > 1) {\n            q = a / b;\n\n            t = b;\n            b = a % b;\n            a = t;\n\n            t = x0;\n            x0 = x1 - q * x0;\n            x1 = t;\n        }\n\n        if (x1 < 0) {\n            x1 += MOD;\n        }\n        return x1;\n    }\n\n    private static long multiplyInternal(long a, long b) {\n        if (a > b) {\n            return multiplyInternal(b, a);\n        }\n        if (a == 0) {\n            return 0;\n        }\n\n        long ans = 0;\n        while (a > 0) {\n            long mask = a & CHUNK_MASK;\n            if (mask > 0) {\n                ans = add(ans, (mask * b) % MOD);\n            }\n            b = (b << CHUNK_SIZE) % MOD;\n            a >>= CHUNK_SIZE;\n        }\n        return ans;\n    }\n}",
    "submit_ts": "1723344558",
    "subm_id": "1351537174"
}