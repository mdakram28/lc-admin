{
    "username": "KR_HayoungSong",
    "submission": "#include <bits/stdc++.h>\n\n#pragma optimization_level 3\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma GCC optimize(\"Ofast\")//Comment optimisations for interactive problems (use endl)\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimization (\"unroll-loops\")\n\nusing namespace std;\n\nstruct PairHash {inline std::size_t operator()(const std::pair<long long, long long> &v) const { return v.first * 31ll + v.second; }};\n\n// speed\n#define Code ios_base::sync_with_stdio(false);\n#define By ios::sync_with_stdio(0);\n#define Sumfi cout.tie(NULL);\n\n// alias\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\n\n// constants\nconst ld PI = acosl(-1.0);  /* pi */\nconst ll INF = 1e18;\nconst ld EPS = 1e-9;\nconst ll MAX_N = 101010;\nconst ll mod = 1e9+7;\n\n// typedef\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<pll> vpll;\ntypedef array<int,3> ai3;\ntypedef array<ll,3> all3;\ntypedef array<ll,4> all4;\ntypedef array<ll,5> all5;\ntypedef vector<all3> vall3;\ntypedef vector<all4> vall4;\ntypedef vector<all5> vall5;\ntypedef pair<ld, ld> pld;\ntypedef vector<pld> vpld;\ntypedef vector<ld> vld;\ntypedef vector<ll> vll;\ntypedef vector<ull> vull;\ntypedef vector<vll> vvll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef deque<ll> dqll;\ntypedef deque<pll> dqpll;\ntypedef pair<string, string> pss;\ntypedef vector<pss> vpss;\ntypedef vector<string> vs;\ntypedef vector<vs> vvs;\ntypedef unordered_set<ll> usll;\ntypedef unordered_set<pll, PairHash> uspll;\ntypedef unordered_map<ll, ll> umll;\ntypedef unordered_map<pll, ll, PairHash> umpll;\n\n// macros\n#define precision(x) cout<<fixed;cout.precision(x);\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,m,n) for(ll i=n;i>=m;i--)\n#define all(a) begin(a), end(a)\n#define rall(a) rbegin(a), rend(a)\n#define uniq(a) sort(all(a)), a.erase(unique(all(a)),end(a))\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define INF(a) memset(a,0x3f3f3f3f3f3f3f3fLL,sizeof(a))\n#define NEGINF(a) memset(a,0xcf,sizeof(a))\n#define ASCEND(a) iota(all(a),0)\n#define sz(x) ll((x).size())\n#define BIT(a,i) ((a>>i)&1)\n#define BITSHIFT(a,i,n) (((a<<i) & ((1ll<<n) - 1)) | (a>>(n-i)))\n#define MAXBIT(a) (64ll - __builtin_clzll(a) - 1ll)\n#define MINBIT(a) (__builtin_ctzll(a))\n#define pyes cout<<\"YES\\n\";\n#define pno cout<<\"NO\\n\";\n#define endl \"\\n\"\n#define pneg1 cout<<\"-1\\n\";\n#define ppossible cout<<\"possible\\n\";\n#define pimpossible cout<<\"impossible\\n\";\n#define TC(x) cout<<\"Case #\"<<x<<\": \";\n#define X first\n#define Y second\n\n// debug\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename A>\nvoid __print(const A &x);\ntemplate <typename A, typename B>\nvoid __print(const pair<A, B> &p);\ntemplate <typename... A>\nvoid __print(const tuple<A...> &t);\ntemplate <typename T>\nvoid __print(stack<T> s);\ntemplate <typename T>\nvoid __print(queue<T> q);\ntemplate <typename T, typename... U>\nvoid __print(priority_queue<T, U...> q);\ntemplate <typename A>\nvoid __print(const A &x) {\n    bool first = true;\n    cerr << '{';\n    for (const auto &i : x) {\n        cerr << (first ? \"\" : \",\"), __print(i);\n        first = false;\n    }\n    cerr << '}';\n}\ntemplate <typename A, typename B>\nvoid __print(const pair<A, B> &p) {\n    cerr << '(';\n    __print(p.first);\n    cerr << ',';\n    __print(p.second);\n    cerr << ')';\n}\ntemplate <typename... A>\nvoid __print(const tuple<A...> &t) {\n    bool first = true;\n    cerr << '(';\n    apply([&first](const auto &...args) { ((cerr << (first ? \"\" : \",\"), __print(args), first = false), ...); }, t);\n    cerr << ')';\n}\ntemplate <typename T>\nvoid __print(stack<T> s) {\n    vector<T> debugVector;\n    while (!s.empty()) {\n        T t = s.top();\n        debugVector.push_back(t);\n        s.pop();\n    }\n    reverse(debugVector.begin(), debugVector.end());\n    __print(debugVector);\n}\ntemplate <typename T>\nvoid __print(queue<T> q) {\n    vector<T> debugVector;\n    while (!q.empty()) {\n        T t = q.front();\n        debugVector.push_back(t);\n        q.pop();\n    }\n    __print(debugVector);\n}\ntemplate <typename T, typename... U>\nvoid __print(priority_queue<T, U...> q) {\n    vector<T> debugVector;\n    while (!q.empty()) {\n        T t = q.top();\n        debugVector.push_back(t);\n        q.pop();\n    }\n    __print(debugVector);\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid _print(const Head &H, const Tail &...T) {\n    __print(H);\n    if (sizeof...(T))\n        cerr << \", \";\n    _print(T...);\n}\n#ifndef ONLINE_JUDGE\n#define debug(...) cerr << \"Line:\" << __LINE__ << \" [\" << #__VA_ARGS__ << \"] = [\"; _print(__VA_ARGS__);\n#else\n#define debug(...)\n#endif\n\n// utility functions\ntemplate <typename T>\nvoid print(T &&t)  { cout << t << \"\\n\"; }\ntemplate<typename T>\nvoid printv(vector<T>v){ll n=v.size();rep(i,0,n){cout<<v[i];if(i+1!=n)cout<<' ';}cout<<endl;}\ntemplate<typename T>\nvoid printvv(vector<vector<T>>v){ll n=v.size();rep(i,0,n)printv(v[i]);}\ntemplate<typename T>\nvoid printvln(vector<T>v){ll n=v.size();rep(i,0,n)cout<<v[i]<<endl;}\nvoid fileIO(string in = \"input.txt\", string out = \"output.txt\") {freopen(in.c_str(),\"ma\",stdin); freopen(out.c_str(),\"w\",stdout);}\nvoid hackercupIO(string in) {fileIO(\"/Users/hayoungsong/Downloads/\" + in, \"/Users/hayoungsong/Downloads/solution.txt\");}\nvoid readf() {freopen(\"\", \"rt\", stdin);}\ntemplate <typename... T>\nvoid in(T &...a) { ((cin >> a), ...); }\ntemplate<typename T>\nvoid in(vector<T>& v){rep(i,0,sz(v)) in(v[i]);}\ntemplate<typename T>\nvoid in(deque<T>& v){rep(i,0,sz(v)) in(v[i]);}\ntemplate<typename T, typename U>\nvoid in(pair<T,U>& A) {in(A.first, A.second);}\ntemplate<typename T, typename U>\nvoid in(vector<pair<T,U>>& A) {rep(i,0,sz(A)) in(A[i]); }\ntemplate<typename T, std::size_t N>\nvoid in(vector<array<T,N>>& A) {rep(i,0,sz(A)) rep(j,0,sz(A[i])) in(A[i][j]); }\ntemplate<typename T>\nvoid in(vector<vector<T>>& A) {rep(i,0,sz(A)) in(A[i]);}\n\nstruct Combination {\n    vll fac, inv;\n    ll n, MOD;\n\n    ll modpow(ll n, ll x, ll MOD = mod) { if(!x) return 1; ll res = modpow(n,x>>1,MOD); res = (res * res) % MOD; if(x&1) res = (res * n) % MOD; return res; }\n\n    Combination(ll _n, ll MOD = mod): n(_n + 1), MOD(MOD) {\n        inv = fac = vll(n,1);\n        rep(i,1,n) fac[i] = fac[i-1] * i % MOD;\n        inv[n - 1] = modpow(fac[n - 1], MOD - 2, MOD);\n        rrep(i,1,n - 2) inv[i] = inv[i + 1] * (i + 1) % MOD;\n    }\n\n    ll fact(ll n) {return fac[n];}\n    ll nCr(ll n, ll r) {\n        if(n < r or n < 0 or r < 0) return 0;\n        return fac[n] * inv[r] % MOD * inv[n-r] % MOD;\n    }\n};\n\nstruct Matrix {\n    ll r,c,MOD;\n    vvll matrix;\n    Matrix(ll r, ll c, ll v = 0, ll MOD = mod): r(r), c(c), matrix(vvll(r,vll(c,v))), MOD(MOD) {}\n    Matrix(vvll m, ll MOD = mod) : r(sz(m)), c(sz(m[0])), matrix(m), MOD(MOD) {}\n\n    vector<ll>& operator[](ll pos) {return matrix[pos];}\n    Matrix operator*(const Matrix& B) const {\n        Matrix res(r, B.c, 0,MOD);\n        rep(i,0,r) rep(j,0,B.c) rep(k,0,B.r) {\n                    res[i][j] = (res[i][j] + matrix[i][k] * B.matrix[k][j] % MOD) % MOD;\n                }\n        return res;\n    }\n\n    Matrix copy() {\n        Matrix copy(r,c,0,MOD);\n        copy.matrix = matrix;\n        return copy;\n    }\n\n\n    Matrix pow(ll n) {\n        assert(r == c);\n        Matrix res(r,r, 0,MOD);\n        Matrix now = copy();\n        rep(i,0,r) res[i][i] = 1;\n        while(n) {\n            if(n & 1) res = res * now;\n            now = now * now;\n            n /= 2;\n        }\n        return res;\n    }\n\n    ll det() {\n        if(r == 1) return matrix[0][0];\n        if(r == 2) return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];\n        ll res = 0;\n        rep(p,0,c) {\n            Matrix mat(c-1,c-1);\n            rep(i,1,r) rep(j,0,c) {\n                    if(j == p) continue;\n                    mat[i][j - (j >= p)] = matrix[i][j];\n                }\n            res += matrix[0][p] * (p & 1 ? -1 : 1) * mat.det();\n        }\n        return res;\n    }\n};\n\n// geometry data structures\ntemplate <typename T>\nstruct Point {\n    T y,x;\n    Point(T y, T x) : y(y), x(x) {}\n    Point(pair<T,T> p) : y(p.first), x(p.second) {}\n    Point() {}\n    void input() {cin>>y>>x;}\n    friend ostream& operator<<(ostream& os, const Point<T>& p) { os<<p.y<<' '<<p.x<<'\\n'; return os;}\n    Point<T> operator+(Point<T>& p) {return Point<T>(y + p.y, x + p.x);}\n    Point<T> operator-(Point<T>& p) {return Point<T>(y - p.y, x - p.x);}\n    Point<T> operator*(ll n) {return Point<T>(y*n,x*n); }\n    Point<T> operator/(ll n) {return Point<T>(y/n,x/n); }\n    bool operator==(const Point<T> &a) {return x == a.x && y == a.y;}\n    bool operator!=(const Point<T> &a) {return x != a.x or y != a.y;}\n    bool operator<(const Point &other) const {if (x == other.x) return y < other.y;return x < other.x;}\n    Point<T> rotate(Point<T> center, ld angle) {\n        ld si = sin(angle * PI / 180.), co = cos(angle * PI / 180.);\n        ld y = this->y - center.y;\n        ld x = this->x - center.x;\n\n        return Point<T>(y * co - x * si + center.y, y * si + x * co + center.x);\n    }\n    ld distance(Point<T> other) {\n        T dy = abs(this->y - other.y);\n        T dx = abs(this->x - other.x);\n        return sqrt(dy * dy + dx * dx);\n    }\n\n    T norm() { return x * x + y * y; }\n};\n\ntemplate<typename T>\nstruct Line {\n    Point<T> A, B;\n    Line(Point<T> A, Point<T> B) : A(A), B(B) {}\n    Line() {}\n\n    void input() {\n        A = Point<T>();\n        B = Point<T>();\n        A.input();\n        B.input();\n    }\n\n    T ccw(Point<T> &a, Point<T> &b, Point<T> &c) {\n        T res = a.x * b.y + b.x * c.y + c.x * a.y;\n        res -= (a.x * c.y + b.x * a.y + c.x * b.y);\n        return res;\n    }\n\n    bool on(Point<T> x) {\n        return ccw(A,x,B) == 0;\n    }\n\n    bool isIntersect(Line<T> o) {\n        T p1p2 = ccw(A,B,o.A) * ccw(A,B,o.B);\n        T p3p4 = ccw(o.A,o.B,A) * ccw(o.A,o.B,B);\n        if (p1p2 == 0 && p3p4 == 0) {\n            pair<T,T> p1(A.y, A.x), p2(B.y,B.x), p3(o.A.y, o.A.x), p4(o.B.y, o.B.x);\n            if (p1 > p2) swap(p2, p1);\n            if (p3 > p4) swap(p3, p4);\n            return p3 <= p2 && p1 <= p4;\n        }\n        return p1p2 <= 0 && p3p4 <= 0;\n    }\n\n    pair<bool,Point<ld>> intersection(Line<T> o) {\n        if(!this->intersection(o)) return {false, {}};\n        ld det = 1. * (o.B.y-o.A.y)*(B.x-A.x) - 1.*(o.B.x-o.A.x)*(B.y-A.y);\n        ld t = ((o.B.x-o.A.x)*(A.y-o.A.y) - (o.B.y-o.A.y)*(A.x-o.A.x)) / det;\n        return {true, {A.y + 1. * t * (B.y - A.y), B.x + 1. * t * (B.x - A.x)}};\n    }\n\n    //@formula for : y = ax + pre\n    //@return {a,pre};\n    pair<ld, ld> formula() {\n        T y1 = A.y, y2 = B.y;\n        T x1 = A.x, x2 = B.x;\n        if(y1 == y2) return {0, (ld)y1};\n        if(x1 == x2) return {INF, (ld)x1};\n        ld a = 1. * (y2 - y1) / (x2 - x1);\n        ld b = -x1 * a + y1;\n        return {a, b};\n    }\n};\n\ntemplate<typename T>\nstruct Circle {\n    Point<T> center;\n    T radius;\n    Circle(T y, T x, T radius) : center(Point<T>(y,x)), radius(radius) {}\n    Circle(Point<T> center, T radius) : center(center), radius(radius) {}\n    Circle() {}\n\n    void input() {\n        center = Point<T>();\n        center.input();\n        cin>>radius;\n    }\n\n    bool circumference(Point<T> p) {\n        return (center.x - p.x) * (center.x - p.x) + (center.y - p.y) * (center.y - p.y) == radius * radius;\n    }\n\n    bool intersect(Circle<T> c) {\n        T d = (center.x - c.center.x) * (center.x - c.center.x) + (center.y - c.center.y) * (center.y - c.center.y);\n        return (radius - c.radius) * (radius - c.radius) <= d and d <= (radius + c.radius) * (radius + c.radius);\n    }\n\n    bool include(Circle<T> c) {\n        T d = (center.x - c.center.x) * (center.x - c.center.x) + (center.y - c.center.y) * (center.y - c.center.y);\n        return d <= radius * radius;\n    }\n};\n\nll __gcd(ll x, ll y) { return !y ? x : __gcd(y, x % y); }\nall3 __exgcd(ll x, ll y) { if(!y) return {x,1,0}; auto [g,x1,y1] = __exgcd(y, x % y); return {g, y1, x1 - (x/y) * y1}; }\nll __lcm(ll x, ll y) { return x / __gcd(x,y) * y; }\nll modpow(ll n, ll x, ll MOD = mod) {if(x<0){return modpow(modpow(n,-x,MOD),MOD-2,MOD);}n%=MOD;ll res=1;while(x){if(x&1){res=res*n%MOD;}n=n*n%MOD;x>>=1;}return res;}\nll __xor(ll n) {return n%4==0?n:n%4==1?1:n%4==2?n+1:0;}\nll __rangexor(ll l, ll r) {return __xor(r)^__xor(l-1);}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Solution {\n    ll dfs1(vvll& adj, vll& dp, ll u, ll par) {\n        ll& res = dp[u] = 0;\n        for(auto& v : adj[u]) {\n            if(v == par) continue;\n            res = max(res, dfs1(adj,dp,v,u) + 1);\n        }\n        return res;\n    }\n    void dfs2(vvll& adj, vll& dp, ll u, ll par, ll val) {\n        dp[u] = max(dp[u], val);\n        vpll best{{val,par}};\n        for(auto& v : adj[u]) {\n            if(v == par) continue;\n            best.push_back({dp[v] + 1, v});\n            sort(rall(best));\n            if(sz(best) > 2) best.pop_back();\n        }\n        auto who = [&](ll u) {\n            for(auto& [d,n] : best) {\n                if(n != u) return d;\n            }\n            return 0ll;\n        };\n        for(auto& v : adj[u]) {\n            if(v == par) continue;\n            dfs2(adj,dp,v,u,who(v) + 1);\n        }\n    }\n    pll helper(vvi& E) {\n        ll n = sz(E) + 1;\n        vvll adj(n);\n        rep(i,0,sz(E)) {\n            ll u = E[i][0], v = E[i][1];\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        vll dp(n,0);\n\n        dfs1(adj,dp,0,-1);\n        dfs2(adj,dp,0,-1,0);\n        ll res = min_element(all(dp)) - begin(dp);\n        return {res, dp[res]};\n    }\n    pll dfs3(vvll& adj, ll u, ll par) {\n        pll res{0,u};\n        for(auto& v : adj[u]) {\n            if(v == par) continue;\n            auto [dis , who] = dfs3(adj,v,u);\n            res = max(res, {dis + 1, who});\n        }\n        return res;\n    }\n    ll helper2(vvi& A) {\n        vvll adj(sz(A) + 1);\n        rep(i,0,sz(A)) {\n            ll u = A[i][0], v = A[i][1];\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        ll u = dfs3(adj,0,-1).second;\n        return dfs3(adj,u,-1).first;\n    }\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& A, vector<vector<int>>& B) {\n        int u1 = helper(A).first, u2 = helper(B).first;\n        int n = sz(A) + 1, m = sz(B) + 1;\n        vvi E{{u1,n + u2}};\n        rep(i,0,sz(A)) {\n            E.push_back(A[i]);\n        }\n        rep(i,0,sz(B)) {\n            E.push_back({B[i][0] + n, B[i][1] + n});\n        }\n        return helper2(E);\n    }\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "submit_ts": 1719716820.0
}