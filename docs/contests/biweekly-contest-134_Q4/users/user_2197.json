{
    "username": "chrehall68",
    "submission": "class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        # brute force is n^2\n        # in a valid subarray of length l, there must be\n        # l occurrences of all the digits in k\n        # well we know how to check for subarrays of length l and bitwise and of k\n        # in linear time\n        # but we'd have to do that n times, leading to n^2 time still\n\n        # can we binarysearch?\n        # how can we validate that a given solution is valid\n        # has to be less than total # of subarrays (ie < n^2)\n        # has to be \n\n        # as soon as it's k, then all further subarrays are valid\n        # until you hit a number that's missing one of the bits in k\n        # so we can store indices of items that are missing bits in k\n        # if not missing bits in k, then num & k == k\n        # else, num&k < k\n        breaker_indices = deque()\n        for index in range(len(nums)):\n            if nums[index] & k < k:\n                breaker_indices.append(index)\n        set_breaker_indices = set(breaker_indices)\n        breaker_indices.append(len(nums))  # for edge case handling\n\n        # then, sort of brute force?\n        # maybe instead, we look for indices of numbers that don't have\n        # certain bits\n        # assuming this worked, it'd be 32 * n\n        # nums_without_bit only stores items that have at least all bits in k\n        nums_without_bit = defaultdict(deque)  # each list is sorted\n        # should map bit (1, 2, 4, 8, 16, 32, ...) to a list of indices with numbers without that bit\n        for index in range(len(nums)):\n            if index in set_breaker_indices:\n                continue  # doesn't have all of k's bits\n\n            for bit in range(32):  # 10^9 is like 2^30\n                b = 1 << bit  # 1, 2, 4, 8, ...\n                if nums[index] & b != b:\n                    # doesn't have the bit\n                    nums_without_bit[b].append(index)\n\n        # find bits that k doesn't have\n        k_not_bits = []\n        for bit in range(32):\n            b = 1 << bit\n            if k & b != b:\n                # k doesn't have the bit\n                k_not_bits.append(b)\n        # print(nums_without_bit)\n        # print(k_not_bits)\n\n        # so now, for each element in the array, try to get rid of all its bits\n        ret = 0\n        for index in range(len(nums)):\n            if index in set_breaker_indices:\n                continue  # doesn't have all of k's bits\n\n            # get next breaker index\n            while breaker_indices[0] < index:\n                breaker_indices.popleft()\n            next_breaker_index = breaker_indices[0]\n            \n            # has at least all of k's bits, maybe more\n            if nums[index] == k:\n                # then we have a case where all subarrays until the next breaker index\n                # are valid subarrays\n                # all subarrays from [here, next_breaker_index) are valid\n                n_valid = next_breaker_index - index\n                ret += n_valid\n            else:\n                # has more than k's bits\n                # so first, reduce to only k's bits\n                last_idx = index\n                val = nums[index]\n                for extra_bit in k_not_bits:\n                    # each of the items in nums_without_bit is guaranteed to keep all the bits in k\n                    # but get rid of at least the bit that they are in\n                    # so we can just keep bitwise anding and use the last index we find\n\n                    if extra_bit & val != extra_bit:\n                        # doesn't have the bit, skip\n                        continue\n                    # has the bit, get the nearest index\n                    d = nums_without_bit[extra_bit]\n                    while len(d) > 0 and d[0] < index:\n                        d.popleft()\n                    if len(d) == 0:\n                        # can't do anything, so we can't\n                        # remove this bit\n                        # so no valid subarrays start here\n                        break\n                    # else, we can remove the bit\n                    val &= nums[d[0]]  # remove the bit\n                    last_idx = max(last_idx, d[0])  # move last_idx accordingly\n                    \n                # don't accidentally include invalids\n                if val == k and next_breaker_index > last_idx:  \n                    n_valid = next_breaker_index - last_idx\n                    ret += n_valid\n\n        return ret\n\n",
    "submit_ts": "1720281302",
    "subm_id": "1311820207"
}