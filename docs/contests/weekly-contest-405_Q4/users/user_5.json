{
    "username": "jerryxu20",
    "submission": "#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n// https://github.com/kth-competitive-programming/kactl/blob/main/content/strings/Hashing.h\ntypedef uint64_t ull;\nstruct H {\n\tull x; H(ull x=0) : x(x) {}\n\tH operator+(H o) { return x + o.x + (x + o.x < x); }\n\tH operator-(H o) { return *this + ~o.x; }\n\tH operator*(H o) { auto m = (__uint128_t)x * o.x;\n\t\treturn H((ull)m) + (ull)(m >> 64); }\n\tull get() const { return x + !~x; }\n\tbool operator==(H o) const { return get() == o.get(); }\n\tbool operator<(H o) const { return get() < o.get(); }\n};\nstatic const H C = (ll)1e11+3; // (order ~ 3e9; random also ok)\n\nstruct HashInterval {\n\tvector<H> ha, pw;\n\tHashInterval(string& str) : ha(sz(str)+1), pw(ha) {\n\t\tpw[0] = 1;\n\t\trep(i,0,sz(str))\n\t\t\tha[i+1] = ha[i] * C + str[i],\n\t\t\tpw[i+1] = pw[i] * C;\n\t}\n\tH hashInterval(int a, int b) { // hash [a, b)\n\t\treturn ha[b] - ha[a] * pw[b - a];\n\t}\n};\n\nvector<H> getHashes(string& str, int length) {\n\tif (sz(str) < length) return {};\n\tH h = 0, pw = 1;\n\trep(i,0,length)\n\t\th = h * C + str[i], pw = pw * C;\n\tvector<H> ret = {h};\n\trep(i,length,sz(str)) {\n\t\tret.push_back(h = h * C + str[i] - pw * str[i-length]);\n\t}\n\treturn ret;\n}\n\nH hashString(string& s){H h{}; for(char c:s) h=h*C+c;return h;}\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& co) {\n        set<int> len;\n        map<ull, int> costs;\n        for (int i = 0; i < sz(words); i++) {\n            len.insert(sz(words[i]));\n            ull h = hashString(words[i]).get();\n            if (costs.count(h)) costs[h] = min(costs[h], co[i]);\n            else costs[h] = co[i];\n        }\n        \n        vector<int> L(all(len));\n        \n        int n = target.size();\n        vector<int> dp(n + 1, INT_MAX);\n        dp[0] = 0;\n        \n        HashInterval ha(target);\n        \n        for (int i = 1; i <= n; i++) {\n            if (dp[i - 1] == INT_MAX) continue;\n            \n            for (int &l: L) {\n                int left = i - 1;\n                int right= left + l - 1;\n                \n                if (right >= n) break;\n                \n                ull h = ha.hashInterval(left, right + 1).get();\n                if (costs.count(h)) {\n                    dp[right + 1] = min(dp[right + 1], dp[i - 1] + costs[h]);\n                }\n            }\n        }\n        \n        if (dp.back() == INT_MAX) return -1;\n        return dp.back();\n        \n        \n        \n        \n    }\n};",
    "submit_ts": "1720320410",
    "subm_id": "1312293285"
}