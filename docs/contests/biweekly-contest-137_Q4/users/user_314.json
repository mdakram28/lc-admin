{
    "username": "quyse",
    "submission": "using ll = long long;\nint const inf = 0x7fffffff;\nll const llinf = 0x7fffffffffffffffLL;\n\ntemplate <typename T>\nstruct MinTree\n{\n  int n;\n  vector<T> q;\n  T inf;\n  MinTree(int m, T inf):inf(inf)\n  {\n    for(n = 2; n < m; n *= 2);\n    q.assign(n * 2 - 1, inf);\n  }\n  T get(int i) const\n  {\n    return q[i + n - 1];\n  }\n  void set(int i, T t)\n  {\n    i += n - 1;\n    q[i] = t;\n    do\n    {\n      i = (i - 1) / 2;\n      q[i] = min(q[i * 2 + 1], q[i * 2 + 2]);\n    }\n    while(i > 0);\n  }\n  T range(int l, int r) const\n  {\n    return range(l, r, 0, 0, n);\n  }\n  T range(int l, int r, int i, int a, int b) const\n  {\n    if(a >= l && b <= r) return q[i];\n    if(a >= r || b <= l) return inf;\n    int m = (a + b) / 2;\n    return min(range(l, r, i * 2 + 1, a, m), range(l, r, i * 2 + 2, m, b));\n  }\n};\n\nstruct Graph\n{\n  struct Edge\n  {\n    int to;\n    int inv;\n    int cap;\n    ll price;\n    int flow = 0;\n  };\n\n  int n;\n  vector<vector<Edge>> e;\n\n  Graph(int n):n(n),e(n){}\n\n  void addEdge(int a, int b, int cap, ll price)\n  {\n    e[a].push_back(Edge\n    {\n      .to = b,\n      .inv = (int)e[b].size(),\n      .cap = cap,\n      .price = price,\n    });\n    e[b].push_back(Edge\n    {\n      .to = a,\n      .inv = (int)e[a].size() - 1,\n      .cap = 0,\n      .price = -price,\n    });\n  };\n\n  ll maxFlow(int source, int sink)\n  {\n    for(;;)\n    {\n      MinTree<tuple<bool, ll, int>> q(n, { true, llinf, inf });\n      vector<int> from(n, -1);\n      for(int i = 0; i < n; ++i)\n        q.set(i, {false, llinf, i});\n      q.set(source, {false, 0, source});\n      for(;;)\n      {\n        auto [f, d, i] = q.range(0, n);\n        if(f || d >= llinf) break;\n        q.set(i, {true, d, i});\n        if(i == sink) break;\n        for(int j = 0; j < (int)e[i].size(); ++j)\n        {\n          if(e[i][j].flow < e[i][j].cap)\n          {\n            auto [f1, d1, i1] = q.get(e[i][j].to);\n            if(!f1 && d1 > d + e[i][j].price)\n            {\n              q.set(i1, {f1, min(d1, d + e[i][j].price), i1});\n              from[i1] = e[i][j].inv;\n            }\n          }\n        }\n      }\n      if(!get<0>(q.get(sink))) break;\n      for(int i = sink; i != source; i = e[i][from[i]].to)\n      {\n        --e[i][from[i]].flow;\n        ++e[e[i][from[i]].to][e[i][from[i]].inv].flow;\n      }\n    }\n    ll r = 0;\n    for(int i = 0; i < n; ++i)\n      for(int j = 0; j < (int)e[i].size(); ++j)\n        r += e[i][j].flow * e[i][j].price;\n    return r;\n  }\n};\n\nclass Solution {\npublic:\n  ll maximumValueSum(vector<vector<int>>& board) {\n    int n = board.size();\n    int m = board[0].size();\n    Graph g(n * m + m + n + 4);\n    int begins = n * m;\n    int ends = begins + m;\n    int source1 = ends + n;\n    int source2 = source1 + 1;\n    int sink1 = source2 + 1;\n    int sink2 = sink1 + 1;\n    for(int i = 0; i < n; ++i)\n      g.addEdge(ends + i, sink1, 1, 0);\n    for(int j = 0; j < m; ++j)\n      g.addEdge(source2, begins + j, 1, 0);\n    g.addEdge(source1, source2, 3, 0);\n    g.addEdge(sink1, sink2, 3, 0);\n\n    ll minval = llinf;\n    for(int i = 0; i < n; ++i)\n      for(int j = 0; j < m; ++j)\n        minval = min(minval, (ll)-board[i][j]);\n\n    for(int i = 0; i < n; ++i)\n      for(int j = 0; j < m; ++j)\n      {\n        g.addEdge(begins + j, i * m + j, 1, -board[i][j] - minval);\n        g.addEdge(i * m + j, ends + i, 1, 0);\n      }\n    ll gg = g.maxFlow(source1, sink2);\n    return -gg / 2 - minval * 3;\n  }\n};",
    "submit_ts": "1723909206",
    "subm_id": "1359183643"
}