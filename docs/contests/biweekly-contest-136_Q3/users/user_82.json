{
    "username": "non_deterministic",
    "submission": "#define lld long long\n#define rep(i,a,n) for(lld i = (a); i <= (n); ++i)\n#define repI(i,a,n) for(int i = (a); i <= (n); ++i)\n#define repD(i,a,n) for(lld i = (a); i >= (n); --i)\n#define repDI(i,a,n) for(int i = (a); i >= (n); --i)\n#define all(c) (c).begin(), (c).end()\n#define sz(a) ((int)a.size())\n\n#define Error(x...) { cout << \"(\" << #x << \")\" << \" = ( \"; printIt(x); }\ntemplate <typename T1> void printIt(T1 t1) { cout << t1 << \" )\" << endl; }\ntemplate <typename T1, typename... T2>\nvoid printIt(T1 t1, T2... t2) { cout << t1 << \" , \"; printIt(t2...); }\n#define errorpair(a) cout<<#a<<\" = ( \"<<((a).first)<<\" , \"<<((a).second)<<\" )\\n\";\n\nclass Solution {\npublic:\n    int minFlips(vector<vector<int>>& grid) {\n        int ans = 0;\n        int n = grid.size();\n        int m = grid[0].size();\n        int fullOnes = 0, halfOnes = 0;\n        repI(i, 0, (n + 1) / 2  - 1) {\n            repI(j, 0, (m + 1) / 2 - 1) {\n                vector<int> v;\n                map<array<int, 2>, int> taken;\n                v.push_back(grid[i][j]);\n                taken[{i, j}] = 1;\n                if(taken.find({n - i - 1, j}) == taken.end()) {\n                    v.push_back(grid[n - i - 1][j]);\n                    taken[{n - i - 1, j}] = 1;\n                }\n                if(taken.find({i, m - j - 1}) == taken.end()) {\n                    v.push_back(grid[i][m - j - 1]);\n                    taken[{i, m - j - 1}] = 1;\n                }\n                if(taken.find({n - i - 1, m - j - 1}) == taken.end()) {\n                    v.push_back(grid[n - i - 1][m - j - 1]);\n                    taken[{n - i - 1, m - j - 1}] = 1;\n                }\n                int zero = 0, one = 0;\n                for(auto x : v) {\n                    if(x == 0) zero++;\n                    else one++;\n                }\n                // Error(i, j, zero, one);\n                ans += min(zero, one);\n                if(taken.size() == 1) {\n                    ans += (one == 1);\n                }\n                if(taken.size() == 2) {\n                    fullOnes += (one == 2);\n                    halfOnes += (one == 1);\n                }\n            }\n        }\n        if(fullOnes % 2 == 1) {\n            ans += 2 * (halfOnes == 0);\n        }\n        // if(n % 2 == 1 && m % 2 == 1) {\n        //     int middleEle = grid[n / 2][m / 2];\n        //     ans += (middleEle == 1);\n        // }\n        return ans;\n    }\n};",
    "submit_ts": "1722697941",
    "subm_id": "1343164366"
}