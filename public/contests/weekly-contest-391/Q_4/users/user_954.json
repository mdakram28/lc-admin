{
    "username": "vanwisd",
    "submission": "impl Solution {\n    pub fn minimum_distance(points: Vec<Vec<i32>>) -> i32 {\n        let n = points.len();\n        let mut kmk = vec![(0, 0); n];\n        for i in 0..n {\n            kmk[i].0 = points[i][1] - points[i][0];\n            kmk[i].1 = points[i][1] + points[i][0];\n        }\n        let mut ik: Vec<_> = (0..n).collect();\n        ik.sort_unstable_by_key(|&i| kmk[i].0);\n        let mut imk: Vec<_> = (0..n).collect();\n        imk.sort_unstable_by_key(|&i| kmk[i].1);\n        \n        let dk = kmk[ik[n-1]].0 - kmk[ik[0]].0;\n        let dmk = kmk[imk[n-1]].1 - kmk[imk[0]].1;\n        \n        if dk >= dmk {\n            let mut d = [kmk[ik[n-1]].0 - kmk[ik[1]].0, kmk[ik[n-2]].0 - kmk[ik[0]].0];\n            let mut idx = [0, n-1];\n            for j in 0..=1 {\n                if ik[idx[j]] == imk[n-1] {\n                    d[j] = d[j].max(kmk[imk[n-2]].1 - kmk[imk[0]].1);\n                } else if ik[idx[j]] == imk[0] {\n                    d[j] = d[j].max(kmk[imk[n-1]].1 - kmk[imk[1]].1)\n                } else {\n                    d[j] = d[j].max(kmk[imk[n-1]].1 - kmk[imk[0]].1);\n                }\n            }\n            d[0].min(d[1])\n        } else {\n            let mut d = [kmk[imk[n-1]].1 - kmk[imk[1]].1, kmk[imk[n-2]].1 - kmk[imk[0]].1];\n            let mut idx = [0, n-1];\n            for j in 0..=1 {\n                if imk[idx[j]] == ik[n-1] {\n                    d[j] = d[j].max(kmk[ik[n-2]].0 - kmk[ik[0]].0);\n                } else if imk[idx[j]] == ik[0] {\n                    d[j] = d[j].max(kmk[ik[n-1]].0 - kmk[ik[1]].0);\n                } else {\n                    d[j] = d[j].max(kmk[ik[n-1]].0 - kmk[ik[0]].0);\n                }\n            }\n            d[0].min(d[1])\n        }\n    }\n}"
}