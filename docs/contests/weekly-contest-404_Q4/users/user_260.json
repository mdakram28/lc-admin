{
    "username": "NoahW256",
    "submission": "from collections import deque, defaultdict\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        l_size,l_d=self.find_tree_center(edges1)\n        r_size,r_d=self.find_tree_center(edges2)\n        print(l_size,r_size)\n        return max(1+l_size+r_size,l_d,r_d)\n    def bfs_farthest_node(self,start, graph):\n        visited = set()\n        queue = deque([(start, 0)])\n        farthest_node = start\n        max_distance = 0\n\n        while queue:\n            node, distance = queue.popleft()\n            if node in visited:\n                continue\n            visited.add(node)\n\n            if distance > max_distance:\n                max_distance = distance\n                farthest_node = node\n\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, distance + 1))\n\n        return farthest_node, max_distance\n\n    def find_tree_center(self,edges):\n        # Construct the graph\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        # Step 1: Find the farthest node from an arbitrary starting node (let's start from node 0)\n        node = 0\n        dist=0\n        \n        while True:\n            new_node,new_dist=self.bfs_farthest_node(node, graph)\n            if new_dist==dist:\n                return ((new_dist+1)//2,new_dist)\n            dist=new_dist\n            node=new_node\n",
    "submit_ts": 1719718158.0
}