{
    "username": "turbulentturban",
    "submission": "#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    static const int MOD = 1000000007;\n    static const int MAX_INVERSIONS = 400;\n\n    int numberOfPermutations(int length, vector<vector<int>>& constraints) {\n        unordered_map<int, int> lengthToInversionMap = processConstraints(constraints);\n\n        vector<vector<long>> permutationCount = calculatePermutations(length, lengthToInversionMap);\n\n        return sumPermutationCounts(permutationCount, length);\n    }\n\nprivate:\n    unordered_map<int, int> processConstraints(const vector<vector<int>>& constraints) {\n        unordered_map<int, int> lengthToInversionMap;\n        for (const auto& constraint : constraints) {\n            lengthToInversionMap[constraint[0] + 1] = constraint[1];\n        }\n        return lengthToInversionMap;\n    }\n\n    vector<vector<long>> calculatePermutations(int length, const unordered_map<int, int>& lengthToInversionMap) {\n        vector<vector<long>> permutationCount(length + 1, vector<long>(MAX_INVERSIONS + 1, 0));\n        permutationCount[0][0] = 1;\n\n        for (int currentLength = 1; currentLength <= length; ++currentLength) {\n            for (int inversionCount = 0; inversionCount <= MAX_INVERSIONS; ++inversionCount) {\n                for (int newPosition = 0; newPosition < currentLength; ++newPosition) {\n                    int previousInversionCount = inversionCount - newPosition;\n                    if (previousInversionCount >= 0) {\n                        permutationCount[currentLength][inversionCount] = (permutationCount[currentLength][inversionCount] + permutationCount[currentLength - 1][previousInversionCount]) % MOD;\n                    }\n                }\n            }\n\n            if (lengthToInversionMap.find(currentLength) != lengthToInversionMap.end()) {\n                int requiredInversionCount = lengthToInversionMap.at(currentLength);\n                for (int inversionCount = 0; inversionCount <= MAX_INVERSIONS; ++inversionCount) {\n                    if (inversionCount != requiredInversionCount) {\n                        permutationCount[currentLength][inversionCount] = 0;\n                    }\n                }\n            }\n        }\n\n        return permutationCount;\n    }\n\n    int sumPermutationCounts(const vector<vector<long>>& permutationCount, int length) {\n        long totalCount = 0;\n        for (long count : permutationCount[length]) {\n            totalCount = (totalCount + count) % MOD;\n        }\n        return static_cast<int>(totalCount);\n    }\n};\n",
    "submit_ts": "1719070239",
    "subm_id": "1296818093"
}