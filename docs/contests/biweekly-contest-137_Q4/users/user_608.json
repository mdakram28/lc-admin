{
    "username": "Felipe Vital",
    "submission": "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        \n        m, n = len(board), len(board[0])\n\n        valuePos = []\n        for j in range(m):\n            for i in range(n):\n                valuePos.append((board[j][i], j, i))\n        \n\n        valuePos = sorted(valuePos, reverse = True)\n        print(valuePos)\n\n        import heapq\n        rooks1, rooks2, rooks3 = valuePos[0], valuePos[0], valuePos[0]\n        totalSum = board[rooks1[1]][rooks1[2]] + board[rooks2[1]][rooks2[2]] + board[rooks3[1]][rooks3[2]]\n        heap = [(-totalSum, 0, 0, 0)] # stores the index of the valuePos list\n        seen = set([0,0,0])\n        while heap:\n            totalSum, idxRooks1, idxRooks2, idxRooks3 = heapq.heappop(heap)\n            rooks1, rooks2, rooks3 = valuePos[idxRooks1], valuePos[idxRooks2], valuePos[idxRooks3]\n            totalSum = board[rooks1[1]][rooks1[2]] + board[rooks2[1]][rooks2[2]] + board[rooks3[1]][rooks3[2]]\n            # Check conflict\n            if rooks1[1] != rooks2[1] and rooks2[1] != rooks3[1] and rooks1[1] != rooks3[1] and rooks1[2] != rooks2[2] and rooks2[2] != rooks3[2]  and rooks1[2] != rooks3[2]: # comprarre the j and i indexes\n                # not conflict\n                # print(rooks1, rooks2, rooks3)\n                totalSum = board[rooks1[1]][rooks1[2]] + board[rooks2[1]][rooks2[2]] + board[rooks3[1]][rooks3[2]]\n                return totalSum\n            else:\n                # there is a conflict so we must add the new bests combinations that leads to the highest totalSum, and keep doing a bfs untill we find a pair without conflict\n                if idxRooks1+1 < len(valuePos) and (idxRooks1+1, idxRooks2, idxRooks3) not in seen: \n                    rooks1_, rooks2_, rooks3_ = valuePos[idxRooks1+1], valuePos[idxRooks2], valuePos[idxRooks3]\n                    totalSum = board[rooks1_[1]][rooks1_[2]] + board[rooks2_[1]][rooks2_[2]] + board[rooks3_[1]][rooks3_[2]]\n                    heapq.heappush(heap, (-totalSum, idxRooks1+1, idxRooks2, idxRooks3))\n                if idxRooks2+1 < len(valuePos) and (idxRooks1, idxRooks2+1, idxRooks3) not in seen: \n                    rooks1_, rooks2_, rooks3_ = valuePos[idxRooks1], valuePos[idxRooks2+1], valuePos[idxRooks3]\n                    totalSum = board[rooks1_[1]][rooks1_[2]] + board[rooks2_[1]][rooks2_[2]] + board[rooks3_[1]][rooks3_[2]]\n                    heapq.heappush(heap, (-totalSum, idxRooks1, idxRooks2+1, idxRooks3))\n                if idxRooks3+1 < len(valuePos) and (idxRooks1, idxRooks2, idxRooks3+1) not in seen: \n                    rooks1_, rooks2_, rooks3_ = valuePos[idxRooks1], valuePos[idxRooks2], valuePos[idxRooks3+1]\n                    totalSum = board[rooks1_[1]][rooks1_[2]] + board[rooks2_[1]][rooks2_[2]] + board[rooks3_[1]][rooks3_[2]]\n                    heapq.heappush(heap, (-totalSum, idxRooks1, idxRooks2, idxRooks3+1))\n                seen.add((idxRooks1+1, idxRooks2, idxRooks3))\n                seen.add((idxRooks1, idxRooks2+1, idxRooks3))\n                seen.add((idxRooks1, idxRooks2, idxRooks3+1))\n\n        return 0\n\n",
    "submit_ts": "1723910383",
    "subm_id": "1359228568"
}