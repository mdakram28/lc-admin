{
    "username": "Maruzensky",
    "submission": "class Solution:\n    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:\n        def func(pack):  # (11, 01, 10, 00)\n            # print(pack)\n            left, right = pack\n            # print(left, right)\n            no_left = max([0, left[1] + right[1], left[1] + right[3], left[3] + right[0]])\n            no_right = max([0, left[0] + right[3], left[2] + right[2], left[2] + right[3]])\n            no_both = max([0, left[1] + right[3], left[3] + right[2], left[3] + right[3]])\n            left_right = max([no_left, no_right, no_both, left[0] + right[1], left[2] + right[0]])\n            return (left_right, no_left, no_right, no_both)\n            \n        class SegmentTree:\n            def __init__(self, arr=None, default=(0, 0, 0, 0)):\n                self.seg = [[(max(0, x), 0, 0, 0) for x in arr]]\n                self.n = len(arr)\n\n                while len(self.seg[-1]) > 1:\n                    # print(self.seg)\n                    temp = []\n                    for idx in range(0, len(self.seg[-1]) - 1, 2):\n                        temp.append(func(self.seg[-1][idx:idx + 2]))\n\n                    self.seg.append(temp)\n\n                self.depth = len(self.seg)\n                self.func = func\n                self.default = default\n\n            def update(self, idx, num):\n                \"\"\"Change the value of segment tree at index idx to num.\n                If self.func is additive, consider implement something more light-weighted.\n                Arguments:\n                idx: The position in the segment tree\n                num: The new value at idx\"\"\"\n                self.seg[0][idx] = (max(0, num), 0, 0, 0)\n                idx >>= 1\n\n                for i in range(1, self.depth):\n                    if idx == len(self.seg[i]):\n                        return\n\n                    self.seg[i][idx] = self.func(self.seg[i - 1][2 * idx:2 * idx + 2])\n                    idx >>= 1\n                    \n        n = min([(1 << i) for i in range(22) if (1 << i) >= len(nums)])\n        nums.extend([0] * (n - len(nums)))\n        \n        seg = SegmentTree(arr=nums)\n        answer = 0\n        mod = 10**9 + 7\n        \n        for pos, val in queries:\n            seg.update(pos, val)\n            answer += seg.seg[-1][-1][0]\n            \n            # print(seg.seg, answer)\n            \n        return answer % mod\n        ",
    "submit_ts": "1716693537",
    "subm_id": "1268089440"
}