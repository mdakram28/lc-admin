{
    "username": "megaspazz",
    "submission": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        Node[] T1 = makeTree(edges1);\n        Node[] T2 = makeTree(edges2);\n        \n        int d1 = diameterNodes(T1);\n        int d2 = diameterNodes(T2);\n        \n        // System.out.format(\"d1 = %d, d2 = %d%n\", d1, d2);\n        \n        return mergeDiameters(d1, d2) - 1;\n    }\n    \n    private static int mergeDiameters(int x, int y) {\n        if (x > y) {\n            return mergeDiameters(y, x);\n        }\n        \n        int xFoldedSize = 1 + (x / 2);\n        int yFoldedSize = 1 + (y / 2);\n        \n        int ySmallArm = (y - 1) / 2;\n        int yBigArm = y - 1 - ySmallArm;\n        int ySmallUpdated = Math.max(ySmallArm, xFoldedSize);\n        \n        return 1 + yBigArm + ySmallUpdated;\n            \n        // System.out.format(\"x = %d, y = %d, xFolded = %d, yFolded = %d%n\", x, y, xFoldedSize, yFoldedSize);\n        // if (xFoldedSize < yFoldedSize) {\n        //     return y;\n        // } else {\n        //     return y + 1;\n        // }\n    }\n    \n    private static Node[] makeTree(int[][] edges) {\n        final int N = edges.length + 1;\n        \n        Node[] nodes = new Node[N];\n        for (int i = 0; i < N; ++i) {\n            nodes[i] = new Node();\n            nodes[i].id = i;\n        }\n        \n        for (int[] e : edges) {\n            int u = e[0];\n            int v = e[1];\n            nodes[u].children.add(nodes[v]);\n            nodes[v].children.add(nodes[u]);\n        }\n        return nodes;\n    }\n    \n    private static int diameterNodes(Node[] nodes) {\n        nodes[0].root(null);\n        nodes[0].getDiameter(0);\n        \n        int ans = 0;\n        for (Node u : nodes) {\n            ans = Math.max(ans, u.diameter);\n        }\n        return ans;\n    }\n    \n    private static class Node {\n        public int id = -1;\n        public List<Node> children = new LinkedList<>();\n        public int height = -1;\n        public TopTwoInt maxHeights = new TopTwoInt(0);\n        public int diameter = -1;\n        \n        public void root(Node p) {\n            children.remove(p);\n            for (Node u : children) {\n                u.root(this);\n            }\n        }\n        \n        public int getHeight() {\n            if (height < 0) {\n                height = 1;\n                for (Node u : children) {\n                    int childHeight = u.getHeight();\n                    height = Math.max(height, 1 + childHeight);\n                    maxHeights.add(childHeight);\n                }\n            }\n            return height;\n        }\n        \n        public void getDiameter(int parentLen) {\n            getHeight();\n            \n            TopTwoInt arms = new TopTwoInt(0);\n            arms.add(parentLen);\n            arms.add(maxHeights.first);\n            arms.add(maxHeights.second);\n            \n            diameter = arms.first + arms.second + 1;\n            \n            // System.out.format(\"node = %d, diameter = %d%n\", id, diameter);\n            \n            for (Node u : children) {\n                int nextParentLen = parentLen;\n                if (u.getHeight() == maxHeights.first) {\n                    nextParentLen = Math.max(nextParentLen, maxHeights.second);\n                } else {\n                    nextParentLen = Math.max(nextParentLen, maxHeights.first);\n                }\n                u.getDiameter(1 + nextParentLen);\n            }\n        }\n    }\n\n\t/**\n\t * Keeps track of the top two elements inserted.\n\t * If `first` and `second` are initialized, `count` will only include elements that were strictly greater than the initial `second` value.\n\t */\n\tpublic static class TopTwoInt {\n\t\tpublic int count;\n\t\tpublic int first;\n\t\tpublic int second;\n\n\t\tpublic TopTwoInt() {\n\t\t\tthis(Integer.MIN_VALUE);\n\t\t}\n\n\t\tpublic TopTwoInt(int init) {\n\t\t\tthis(init, init);\n\t\t}\n\n\t\tpublic TopTwoInt(int first, int second) {\n\t\t\tthis.first = Math.max(first, second);\n\t\t\tthis.second = Math.min(first, second);\n\t\t}\n\n\t\tpublic void add(int x) {\n\t\t\tif (x < second) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (x > first) {\n\t\t\t\tsecond = first;\n\t\t\t\tfirst = x;\n\t\t\t} else {\n\t\t\t\tsecond = x;\n\t\t\t}\n\t\t\tcount = Math.min(2, count + 1);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"[\" + first + \", \" + second + \"]\";\n\t\t}\n\t}\n}",
    "submit_ts": "1719717837",
    "subm_id": "1304402021"
}