{
    "username": "prakharrrr4",
    "submission": "\n#define ll long long\ntemplate<class S,\n\tS(*op)(S, S),\n\tS(*e)(),\n\tclass F,\n\tS(*mapping)(F, S),\n\tF(*composition)(F, F),\n\tF(*id)()>\n\tstruct lazy_segtree {\n\n\tprivate:\n\t\tint s, _n;\n\t\tvector<S> st;\n\t\tvector<F> lt;\n\t\tvoid construct(int pos, int l, int r, vector<S>& ind)\n\t\t{\n\n\t\t\tif (l == r)\n\t\t\t{\n\t\t\t\tst[pos] = ind[l];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint mid = (l + r) / 2;\n\t\t\tconstruct(pos * 2 + 1, l, mid, ind);\n\t\t\tconstruct(pos * 2 + 2, mid + 1, r, ind);\n\t\t\tst[pos] = op(st[pos * 2 + 1], st[pos * 2 + 2]);\n\t\t}\n\t\tvoid update(int i, int j, int l, int r, F val, int pos)\n\t\t{\n\n\t\t\tst[pos] = mapping(lt[pos], st[pos]);\n\t\t\tif (l != r)\n\t\t\t{\n\t\t\t\tlt[pos * 2 + 1] = composition(lt[pos], lt[pos * 2 + 1]);\n\t\t\t\tlt[pos * 2 + 2] = composition(lt[pos], lt[pos * 2 + 2]);\n\t\t\t}\n\t\t\tlt[pos] = id();\n\n\n\n\t\t\tif (l > r || l > j || r < i)\n\t\t\t\treturn;\n\n\t\t\tif (i <= l && j >= r)\n\t\t\t{\n\t\t\t\tst[pos] = mapping(val, st[pos]);\n\t\t\t\tif (l != r)\n\t\t\t\t{\n\t\t\t\t\tlt[pos * 2 + 1] = composition(val, lt[pos * 2 + 1]);\n\t\t\t\t\tlt[pos * 2 + 2] = composition(val, lt[pos * 2 + 2]);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint mid = (l + r) / 2;\n\t\t\tupdate(i, j, l, mid, val, 2 * pos + 1);\n\t\t\tupdate(i, j, mid + 1, r, val, 2 * pos + 2);\n\t\t\tst[pos] = op(st[pos * 2 + 1], st[pos * 2 + 2]);\n\t\t}\n\t\tvoid update(int i, int j, int l, int r, S val, int pos)\n\t\t{\n\n\n\t\t\tst[pos] = mapping(lt[pos], st[pos]);\n\t\t\tif (l != r)\n\t\t\t{\n\t\t\t\tlt[pos * 2 + 1] = composition(lt[pos], lt[pos * 2 + 1]);\n\t\t\t\tlt[pos * 2 + 2] = composition(lt[pos], lt[pos * 2 + 2]);\n\t\t\t}\n\t\t\tlt[pos] = id();\n\n\n\n\t\t\tif (l > r || l > j || r < i)\n\t\t\t\treturn;\n\n\t\t\tif (l == r)\n\t\t\t{\n\t\t\t\tst[pos] = val;\n\t\t\t\treturn;\n\t\t\t}\n\n\n\t\t\tint mid = (l + r) / 2;\n\t\t\tupdate(i, j, l, mid, val, 2 * pos + 1);\n\t\t\tupdate(i, j, mid + 1, r, val, 2 * pos + 2);\n\t\t\tst[pos] = op(st[pos * 2 + 1], st[pos * 2 + 2]);\n\t\t}\n\t\tS query(int i, int j, int l, int r, int pos)\n\t\t{\n\t\t\tst[pos] = mapping(lt[pos], st[pos]);\n\t\t\tif (l != r)\n\t\t\t{\n\t\t\t\tlt[pos * 2 + 1] = composition(lt[pos], lt[pos * 2 + 1]);\n\t\t\t\tlt[pos * 2 + 2] = composition(lt[pos], lt[pos * 2 + 2]);\n\t\t\t}\n\t\t\tlt[pos] = id();\n\n\n\t\t\tif (l > r || l > j || r < i)\n\t\t\t\treturn e();\n\t\t\tif (i <= l && j >= r)\n\t\t\t\treturn st[pos];\n\t\t\tint mid = (l + r) / 2;\n\t\t\treturn  op(query(i, j, l, mid, pos * 2 + 1), query(i, j, mid + 1, r, pos * 2 + 2));\n\n\t\t}\n\n\t\t/*\n\t\t* bs() will function as follows:-\n\t\t* For a range (l,r)\n\t\t* we will consider following terms:\n\t\t* op(l,l), op(l,l+1), op(l,l+2).... op(l,l+r)\n\t\t* [True,True,False,False...False]\n\t\t* It will then return the index on which first false value occurs\n\t\t*/\n\t\tvoid bs(int i, int j, int l, int r, int pos, bool(*fun)(S), int& ans)\n\t\t{\n\t\t\tassert(l >= 0 && l < _n);\n\t\t\tassert(r >= 0 && r < _n);\n\t\t\tassert(r >= l);\n\n\t\t\tst[pos] = mapping(lt[pos], st[pos]);\n\t\t\tif (l != r)\n\t\t\t{\n\t\t\t\tlt[pos * 2 + 1] = composition(lt[pos], lt[pos * 2 + 1]);\n\t\t\t\tlt[pos * 2 + 2] = composition(lt[pos], lt[pos * 2 + 2]);\n\t\t\t}\n\t\t\tlt[pos] = id();\n\n\n\n\t\t\tif (l > r || l > j || r < i)\n\t\t\t\treturn;\n\n\t\t\tif (l == r)\n\t\t\t{\n\t\t\t\tif (fun(st[pos]) == false)\n\n\t\t\t\t{\n\t\t\t\t\n\t\t\t\t\tans = min(ans, r);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (i <= l && j >= r)\n\t\t\t{\n\t\t\t\tif (fun(st[pos]) == false)\n\t\t\t\t{\n\t\t\t\t\t \n\t\t\t\t\tans = min(ans, r);\n\n\t\t\t\t\tint mid = (l + r) / 2;\n\t\t\t\t\t\n\t\t\t\t\tif (fun(mapping(lt[pos*2+1],st[pos*2+1])) == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tbs(i, j, l, mid, 2 * pos + 1, fun, ans);\n\t\t\t\t\t}\n\t\t\t\t\telse if (fun(mapping(lt[pos * 2 + 2], st[pos * 2 + 2])) == false) bs(i, j, mid + 1, r, 2 * pos + 2, fun, ans);\n\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\n\t\t\tint mid = (l + r) / 2;\n\t\t\tbs(i, j, l, mid, 2 * pos + 1, fun, ans);\n\t\t\tbs(i, j, mid + 1, r, 2 * pos + 2, fun, ans);\n\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* rbs() will function as follows:-\n\t\t* For a range (l,r)\n\t\t* we will consider following terms:\n\t\t* op(l,r), op(l+1,r), op(l+3,r).... op(r,r)\n\t\t* [False,False,True,True,True]\n\t\t* It will then return the index on which last false value occurs\n\t\t*/\n\t\tvoid rbs(int i, int j, int l, int r, int pos, bool(*fun)(S), int& ans)\n\t\t{\n\t\t\tassert(l >= 0 && l < _n);\n\t\t\tassert(r >= 0 && r < _n);\n\t\t\tassert(r >= l);\n\n\t\t\tst[pos] = mapping(lt[pos], st[pos]);\n\t\t\tif (l != r)\n\t\t\t{\n\t\t\t\tlt[pos * 2 + 1] = composition(lt[pos], lt[pos * 2 + 1]);\n\t\t\t\tlt[pos * 2 + 2] = composition(lt[pos], lt[pos * 2 + 2]);\n\t\t\t}\n\t\t\tlt[pos] = id();\n\n\n\n\t\t\tif (l > r || l > j || r < i)\n\t\t\t\treturn;\n\n\t\t\tif (l == r)\n\t\t\t{\n\t\t\t\tif (fun(st[pos]) == false)\n\t\t\t\t\tans = max(ans, l);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (i <= l && j >= r)\n\t\t\t{\n\t\t\t\tif (fun(st[pos]) == false)\n\t\t\t\t{\n\t\t\t\t\tans = max(ans, l);\n\n\t\t\t\t\tint mid = (l + r) / 2;\n\t\t\t\t\tif (fun(mapping(lt[pos*2+2],st[pos*2+2])) == false) rbs(i, j, l, mid, 2 * pos + 2, fun, ans);\n\t\t\t\t\telse if(fun(mapping(lt[pos * 2 + 1], st[pos * 2 + 1]))==false) rbs(i, j, mid + 1, r, 2 * pos + 1, fun, ans);\n\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\n\t\t\tint mid = (l + r) / 2;\n\t\t\trbs(i, j, mid + 1, r, 2 * pos + 2, fun, ans);\n\t\t\trbs(i, j, l, mid, 2 * pos + 1, fun, ans);\n\n\n\t\t\treturn;\n\t\t}\n\tpublic:\n\t\tlazy_segtree() :lazy_segtree(0) {}\n\t\tlazy_segtree(int n) : lazy_segtree(vector<S>(n, e())) {}\n\t\tlazy_segtree(vector<S>& v) : _n(int(v.size())) {\n\t\t\tassert(_n > 0);\n\t\t\tint s = ceil(log2(_n));\n\t\t\ts = pow(2, s + 1) - 1;\n\t\t\tst.clear();\n\t\t\tst.resize(s, e());\n\t\t\tconstruct(0, 0, _n - 1, v);\n\t\t\tlt.clear();\n\t\t\tlt.resize(s, id());\n\t\t}\n\t\tvoid update(int i, F val)\n\t\t{\n\t\t\tassert(i >= 0 && i < _n);\n\t\t\tupdate(i, i, 0, _n - 1, val, 0);\n\t\t}\n\t\tvoid set(int i, S val)\n\t\t{\n\t\t\tassert(i >= 0 && i < _n);\n\t\t\tupdate(i, i, 0, _n - 1, val, 0);\n\t\t}\n\t\tvoid update(int i, int j, F val)\n\t\t{\n\t\t\tassert(i >= 0 && i < _n);\n\t\t\tassert(i <= j && j >= 0 && j < _n);\n\t\t\tupdate(i, j, 0, _n - 1, val, 0);\n\t\t}\n\t\tS query(int i)\n\t\t{\n\t\t\tassert(i >= 0 && i < _n);\n\t\t\treturn query(i, i, 0, _n - 1, 0);\n\t\t}\n\t\tS query(int i, int j)\n\t\t{\n\t\t\tassert(i >= 0 && i < _n);\n\t\t\tassert(i <= j && j >= 0 && j < _n);\n\t\t\treturn query(i, j, 0, _n - 1, 0);\n\t\t}\n\t\ttemplate<bool (*fun)(S)>int bs(int l, int r)\n\t\t{\n\t\t\tassert(l >= 0 && l < _n);\n\t\t\tassert(r >= l && r >= 0 && r < _n);\n\t\t\tassert(fun(e()) == true);\n\t\t\tint ans = r + 1;\n\t\t\tbs(l, r, 0, _n - 1, 0, fun, ans);\n\t\t\treturn ans;\n\t\t}\n\t\ttemplate<bool (*fun)(S)>int rbs(int l, int r)\n\t\t{\n\t\t\tassert(l >= 0 && l < _n);\n\t\t\tassert(r >= l && r >= 0 && r < _n);\n\t\t\tassert(fun(e()) == true);\n\t\t\tint ans = l - 1;\n\t\t\trbs(l, r, 0, _n - 1, 0, fun, ans);\n\t\t\treturn ans;\n\t\t}\n\n};\nstruct S\n{\n\tll sum, len; \n};\nstruct F\n{\n\tll a,b;\n};\nS op(S l, S r)\n{\n\treturn S{ l.sum+r.sum,l.len+r.len };\n}\nS e()\n{\n\treturn S{0,0};\n}\nS mapping(F l, S r)\n{\n\tll a = r.sum*l.a + r.len * l.b;\n\treturn S{ a,r.len };\n}\nF composition(F l, F r)\n{\n\tll a, b;\n\ta = l.a * r.a;\n\tb = l.a * r.b + l.b;\n\treturn F{ a,b };\n}\nF id() {\n\treturn F{1,0};\n}\n\n\nclass Solution {\npublic:\n    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>> queries) {\n    \n        vector<long long> result(queries.size());\n        int n =  (int)(s.size());\n        vector<int> p(n), q(n), sum(n);\n        \n        for(int i=0;i<n;i++)\n        {\n            if(s[i]=='0')\n                p[i] = 1;\n            else\n                q[i] = 1;\n            if(i-1>=0)\n            {\n                p[i] += p[i-1];\n                q[i] += q[i-1];\n            }\n        }\n        vector<S> node(n,S{0,1});\n        lazy_segtree<S,op,e,F,mapping,composition,id> seg(node);\n        map<int,vector<pair<int,int>>> qq;\n        for(int i=0;i<queries.size();i++)\n        {\n            qq[queries[i][1]].push_back({queries[i][0],i});\n        }\n        for(int i=0;i<n;i++)\n        {\n            int l =0;\n            int r =i;\n            while(l<r)\n            {\n                int m = (l+r)/2;\n                if(p[i]-(m-1<0?0:p[m-1]) <= k or q[i]-(m-1<0?0:q[m-1]) <= k )\n                    r = m;\n                else\n                    l = m + 1;\n            }\n            // update\n            seg.update(l,i,F{1,1});\n            \n            for(auto x : qq[i])\n            {\n                // query\n                result[x.second]+= seg.query(x.first,i).sum;\n            }\n        }\n        \n        return result;\n        \n    }\n};\n",
    "submit_ts": "1723950596",
    "subm_id": "1359750063"
}