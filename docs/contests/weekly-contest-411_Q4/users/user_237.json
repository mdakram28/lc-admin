{
    "username": "Hughstudy",
    "submission": "class Solution {\n    class SegmentTree {\n        long[] tree;\n        int n;\n        public SegmentTree(int[] nums) {\n            if (nums.length > 0) {\n                n = nums.length;\n                tree = new long[n * 2];\n                buildTree(nums);\n            }\n        }\n        private void buildTree(int[] nums) {\n            for (int i = n, j = 0;  i < 2 * n; i++,  j++)\n                tree[i] = nums[j];\n            for (int i = n - 1; i > 0; --i)\n                tree[i] = tree[i * 2] + tree[i * 2 + 1];\n        }\n\n        public long sumRange(int l, int r) {\n            l += n;\n            r += n;\n            long sum = 0;\n            while (l <= r) {\n                if ((l % 2) == 1) {\n                    sum += tree[l];\n                    l++;\n                }\n                if ((r % 2) == 0) {\n                    sum += tree[r];\n                    r--;\n                }\n                l /= 2;\n                r /= 2;\n            }\n            return sum;\n        }\n    }\n\n\n    public long[] countKConstraintSubstrings(String s, int k, int[][] queries) {\n        int[] count = {0,0};\n        int len = s.length(), st = 0;\n        int[] mem = new int[len];\n        for (int i = 0; i < s.length(); ++i) {\n            count[s.charAt(i) - '0'] += 1;\n            while (count[0] > k && count[1] > k) {\n                count[s.charAt(st++) - '0'] -= 1;\n            }\n            mem[i] = st;\n        }\n\n        SegmentTree tree = new SegmentTree(mem);\n        long[] res = new long[queries.length];\n        for (int i = 0; i < queries.length; ++i) {\n            long q0 = queries[i][0], q1 = queries[i][1];\n            int firstBig = binarySearch(mem, queries[i][0]);\n            if (firstBig <= q1) {\n                long right = firstBig - 1;\n                if (right >= q0) res[i] = (right - q0 + 1 + 1) * (right - q0 + 1) / 2;\n                res[i] += (firstBig + q1 + 2) * (q1 - firstBig + 1) / 2 - tree.sumRange(firstBig, (int) q1);\n            } else {\n                res[i] = (q1 - q0 + 1 + 1) * (q1 - q0 + 1) / 2;\n            }\n        }\n        return res;\n    }\n\n    private int binarySearch(int[] mem, int st) {\n        int p0 = 0, p1 = mem.length;\n        while (p0 < p1) {\n            int mid = (p0 + p1) / 2;\n            if (mem[mid] <= st) {\n                p0 = mid + 1;\n            } else {\n                p1 = mid;\n            }\n        }\n        return p0;\n    }\n}",
    "submit_ts": "1723950721",
    "subm_id": "556400870"
}