{
    "username": "uwu",
    "submission": "#[cfg(debug_assertions)]\nuse crate::*;\n\nimpl Solution {\n    pub fn minimum_difference(nums: Vec<i32>, k: i32) -> i32 {\n        let n = nums.len();\n        let st = SegmentTree::from_slice(&nums, i32::MAX, |&x, &y| x & y);\n        let mut ans = i32::MAX;\n        for i in 0..n {\n            let mut l = i;\n            let mut cur = nums[i];\n            loop {\n                ans = ans.min(cur.abs_diff(k) as i32);\n                let r = st.search_right(l, |&x| cur & x == cur);\n                //assert_eq!(cur, st.query(i, r));\n                if r == n {\n                    break;\n                }\n                l = r;\n                //assert_ne!(cur, cur & nums[r]);\n                cur &= nums[r];\n            }\n        }\n        ans\n    }\n}\n\npub struct SegmentTree<T, F> {\n    n: usize,\n    p: usize,\n    a: Vec<T>,\n    t: T,\n    op: F,\n}\n\nimpl<T, F> SegmentTree<T, F>\nwhere\n    T: Clone,\n    F: Fn(&T, &T) -> T,\n{\n    pub fn new(n: usize, t: T, op: F) -> Self {\n        assert!(n > 0);\n        let p = n.next_power_of_two();\n        let a = vec![t.clone(); 2 * p];\n        SegmentTree { n, p, a, t, op }\n    }\n\n    pub fn from_slice(src: &[T], t: T, op: F) -> Self {\n        let n = src.len();\n        let p = n.next_power_of_two();\n        let mut a = vec![t.clone(); 2 * p];\n        a[p..p + n].clone_from_slice(src);\n        for i in (1..p).rev() {\n            a[i] = op(&a[2 * i], &a[2 * i + 1]);\n        }\n        SegmentTree { n, p, a, t, op }\n    }\n\n    pub fn root(&self) -> T {\n        self.a[1].clone()\n    }\n\n    pub fn get(&self, index: usize) -> T {\n        assert!(index < self.n);\n        self.a[index + self.p].clone()\n    }\n\n    pub fn set(&mut self, index: usize, value: T) {\n        assert!(index < self.n);\n        let mut i = index + self.p;\n        self.a[i] = value;\n        i >>= 1;\n        while i > 0 {\n            self.a[i] = (self.op)(&self.a[2 * i], &self.a[2 * i + 1]);\n            i >>= 1;\n        }\n    }\n\n    pub fn query(&self, l: usize, r: usize) -> T {\n        assert!(l <= r);\n        assert!(r <= self.n);\n        let mut l = l + self.p;\n        let mut r = r + self.p;\n        let mut x = self.t.clone();\n        let mut y = self.t.clone();\n        while l < r {\n            if l % 2 != 0 {\n                x = (self.op)(&x, &self.a[l]);\n                l += 1;\n            }\n            if r % 2 != 0 {\n                r -= 1;\n                y = (self.op)(&self.a[r], &y);\n            }\n            l >>= 1;\n            r >>= 1;\n        }\n        (self.op)(&x, &y)\n    }\n\n    // maximum r s.t. f(a[l..r]) = true\n    pub fn search_right(&self, l: usize, mut f: impl FnMut(&T) -> bool) -> usize {\n        assert!(l <= self.n);\n        assert!(f(&self.t));\n        if l == self.n {\n            return self.n;\n        }\n        let mut index = l + self.p;\n        let mut cur = self.t.clone();\n        loop {\n            while index % 2 == 0 {\n                index >>= 1;\n            }\n            let next = (self.op)(&cur, &self.a[index]);\n            if f(&next) {\n                cur = next;\n                index += 1;\n                if index.is_power_of_two() {\n                    return self.n;\n                }\n            } else {\n                while index < self.p {\n                    index <<= 1;\n                    let next = (self.op)(&cur, &self.a[index]);\n                    if f(&next) {\n                        cur = next;\n                        index += 1;\n                    }\n                }\n                return index - self.p;\n            }\n        }\n    }\n\n    // minimum l s.t. f(a[l..r]) = true\n    pub fn search_left(&self, r: usize, mut f: impl FnMut(&T) -> bool) -> usize {\n        assert!(r <= self.n);\n        assert!(f(&self.t));\n        if r == 0 {\n            return 0;\n        }\n        let mut index = r + self.p;\n        let mut cur = self.t.clone();\n        loop {\n            index -= 1;\n            while index > 1 && index % 2 == 1 {\n                index >>= 1;\n            }\n            let next = (self.op)(&self.a[index], &cur);\n            if f(&next) {\n                cur = next;\n                if index.is_power_of_two() {\n                    return 0;\n                }\n            } else {\n                while index < self.p {\n                    index <<= 1;\n                    index += 1;\n                    let next = (self.op)(&self.a[index], &cur);\n                    if f(&cur) {\n                        cur = next;\n                        index -= 1;\n                    }\n                }\n                return index + 1 - self.p;\n            }\n        }\n    }\n}\n",
    "submit_ts": 1717298019.0
}