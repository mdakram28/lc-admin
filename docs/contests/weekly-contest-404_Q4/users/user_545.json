{
    "username": "anushka_dwivedi_",
    "submission": "class Solution:\n    def findLongestPath(self, node: int, prev: int, adj: List[List[int]], diameter: int) -> int:\n        maxPath1, maxPath2 = 0, 0\n        for neighbor in adj[node]:\n            if neighbor != prev:\n                pathLength = 1 + self.findLongestPath(neighbor, node, adj,diameter)\n                if pathLength > maxPath1:\n                    maxPath2 = maxPath1\n                    maxPath1 = pathLength\n                elif pathLength > maxPath2:\n                    maxPath2 = pathLength\n        diameter[0] = max(diameter[0], maxPath1 + maxPath2)\n        return maxPath1\n\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        n, m = len(edges1) + 1, len(edges2) + 1\n        adj1, adj2 = [[] for _ in range(n)], [[] for _ in range(m)]\n        for edge in edges1:\n            adj1[edge[0]].append(edge[1])\n            adj1[edge[1]].append(edge[0])\n        for edge in edges2:\n            adj2[edge[0]].append(edge[1])\n            adj2[edge[1]].append(edge[0])\n\n        diameter1, diameter2 = [0], [0]\n        self.findLongestPath(0, -1, adj1, diameter1)\n        self.findLongestPath(0, -1, adj2, diameter2)\n\n        return max(diameter1[0], diameter2[0], (diameter1[0] + 1) // 2 + (diameter2[0] + 1) // 2 + 1)",
    "submit_ts": 1719718393.0
}