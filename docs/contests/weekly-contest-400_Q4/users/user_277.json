{
    "username": "anna-hcj",
    "submission": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\n\n// Sliding window\n// Once the bitwise AND is smaller than k, there is no point to continue.\n// Move up the left pointer until the bitwise AND is bigger than or equal to k.\n// Find bitwise AND of a range.\n\nvar minimumDifference = function(nums, k) {\n  let n = nums.length, andVal = nums[0], minDiff = Infinity;\n  let segTree = new SegmentTree(nums);\n  for (let j = 0, i = 0; j < n; j++) {\n    andVal &= nums[j];\n    while (andVal < k) {\n      minDiff = Math.min(minDiff, Math.abs(andVal - k));\n      andVal = segTree.bitwiseANDRange(i + 1, j);\n      i++;\n    }\n    minDiff = Math.min(minDiff, Math.abs(andVal - k));\n  }\n  return minDiff;\n};\n\nclass SegmentTree {\n  constructor(arr) {\n    let n = arr.length;\n    this.size = n;\n    this.segTree = Array(n * 2).fill(0);\n    this.build(arr);\n  }\n  build(arr) {\n    let n = this.size;\n    for (let i = n; i < n * 2; i++) {\n      this.segTree[i] = arr[i - n]; // populate leaf values\n    }\n    for (let i = n - 1; i > 0; i--) {\n      this.segTree[i] = this.segTree[i * 2] & this.segTree[i * 2 + 1];\n    }\n  }\n  bitwiseANDRange(left, right) {\n    let n = this.size, andVal = (2 ** 32) - 1;\n    let left_idx = left + n, right_idx = right + n;\n    while (left_idx <= right_idx) {\n      if (left_idx % 2 === 1) andVal &= this.segTree[left_idx++];\n      if (right_idx % 2 === 0) andVal &= this.segTree[right_idx--];\n      left_idx = Math.floor(left_idx / 2);\n      right_idx = Math.floor(right_idx / 2);\n    }\n    return andVal;\n  }\n}",
    "submit_ts": 1717298133.0
}