{
    "username": "ruts",
    "submission": "class Solution {\npublic:\nstruct pair_hash {\n    template <class T1, class T2>\n    std::size_t operator()(const std::pair<T1, T2>& p) const {\n        auto hash1 = std::hash<T1>{}(p.first);\n        auto hash2 = std::hash<T2>{}(p.second);\n        // Combining the two hash values\n        return hash1 ^ (hash2 + 0x9e3779b9 + (hash1 << 6) + (hash1 >> 2));\n    }\n};\n\n// Custom hash function for std::pair<std::pair<long long, int>, int>\nstruct nested_pair_hash {\n    std::size_t operator()(const std::pair<std::pair<long long, int>, int>& p) const {\n        auto hash1 = pair_hash{}(p.first);\n        auto hash2 = std::hash<int>{}(p.second);\n        // Combining the hash of the inner pair with the hash of the outer integer\n        return hash1 ^ (hash2 + 0x9e3779b9 + (hash1 << 6) + (hash1 >> 2));\n    }\n};\n\n// Equality function for std::pair<std::pair<long long, int>, int>\nstruct nested_pair_equal {\n    bool operator()(const std::pair<std::pair<long long, int>, int>& p1, const std::pair<std::pair<long long, int>, int>& p2) const {\n        return p1.first == p2.first && p1.second == p2.second;\n    }\n};\n    std::unordered_map<std::pair<std::pair<long long, int>, int>, int, nested_pair_hash, nested_pair_equal> dp;\n    int k;\n    int res = 0;\n    int solve(int i , int mv , int can) {\n        if(mv > 30) {\n            return 0;\n        }\n        if(dp.find({{i,mv},can}) != dp.end()) {\n            return dp[{{i,mv},can}];\n        }\n        int ans = 0;\n        if(i == k) {\n            ++ans;\n        }\n        if(can && i != 0) {\n            ans += solve(i-1,mv,0);\n        }\n        long long goTo = i + (1LL << mv);\n        ans += solve(goTo,mv+1,1);\n        // if(mv > 60) {\n        //     return 0;\n        // }\n        \n        // int ans = 0;\n        // if(i == k) {\n        //     ans = 1;\n        // }\n        // if(can && i != 0) {\n        //     ans += solve(i-1,mv,0);\n        // } else {\n        //     long long goTo = i + (1LL << mv);\n        //     ans += solve(goTo,mv+1,1);\n        // }\n        return dp[{{i,mv},can}] = ans;\n    }\n    \n    int waysToReachStair(int K) {\n       k = K;\n       return solve(1,0,1);\n    }\n};",
    "submit_ts": 1716087777.0
}