{
    "username": "john0312acc223",
    "submission": "\n\n// https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/\n\n/*         n --> No. of elements present in input array.  \n    BITree[0..n] --> Array that represents Binary Indexed Tree. \n    arr[0..n-1] --> Input array for which prefix sum is evaluated. */\n  \n// Returns sum of arr[0..index]. This function assumes \n// that the array is preprocessed and partial sums of \n// array elements are stored in BITree[]. \nint getSum(int BITree[], int index) \n{ \n    int sum = 0; // Initialize result \n  \n    // index in BITree[] is 1 more than the index in arr[] \n    index = index + 1; \n  \n    // Traverse ancestors of BITree[index] \n    while (index>0) \n    { \n        // Add current element of BITree to sum \n        sum += BITree[index]; \n  \n        // Move index to parent node in getSum View \n        index -= index & (-index); \n    } \n    return sum; \n} \n  \n// Updates a node in Binary Index Tree (BITree) at given index \n// in BITree. The given value 'val' is added to BITree[i] and  \n// all of its ancestors in tree. \nvoid updateBIT(int BITree[], int n, int index, int val) \n{ \n    // index in BITree[] is 1 more than the index in arr[] \n    index = index + 1; \n  \n    // Traverse all ancestors and add 'val' \n    while (index <= n) \n    { \n    // Add 'val' to current node of BI Tree \n    BITree[index] += val; \n  \n    // Update index to that of parent in update View \n    index += index & (-index); \n    } \n} \n  \n// Constructs and returns a Binary Indexed Tree for given \n// array of size n. \nint *constructBITree(int arr[], int n) \n{ \n    // Create and initialize BITree[] as 0 \n    int *BITree = new int[n+1]; \n    for (int i=1; i<=n; i++) \n        BITree[i] = 0; \n  \n    // Store the actual values in BITree[] using update() \n    for (int i=0; i<n; i++) \n        updateBIT(BITree, n, i, arr[i]); \n  \n    // Uncomment below lines to see contents of BITree[] \n    //for (int i=1; i<=n; i++) \n    //     cout << BITree[i] << \" \"; \n  \n    return BITree; \n} \n\nint peak_accu[1024*256];\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        memset(peak_accu, 0, sizeof(peak_accu));\n        int n = nums.size()+100;\n        auto clearNum = [&] (int pos) {\n            if (pos <= 0 || pos >= nums.size()-1) return;\n            if (nums[pos] > nums[pos-1] && nums[pos] > nums[pos+1]) {\n                updateBIT(peak_accu, n, pos+10, -1);\n            }\n        };\n        auto addNum = [&] (int pos) {\n            if (pos <= 0 || pos >= nums.size()-1) return;\n            if (nums[pos] > nums[pos-1] && nums[pos] > nums[pos+1]) {\n                updateBIT(peak_accu, n, pos+10, 1);\n            }\n        };\n\n        for (int i = 0; i < nums.size(); i++) {\n            addNum(i);\n        }\n\n        vector<int> res;\n        for (const auto& q : queries) {\n            assert(q.size() == 3);\n            if (q[0] == 1) {\n                int li = q[1];\n                int ri = q[2];\n                if (li == ri) {\n                    res.push_back(0);\n                    continue;\n                }\n                clearNum(li);\n                clearNum(ri);\n                int li_sum = getSum(peak_accu, li+10-1);\n                int ri_sum = getSum(peak_accu, ri+10);\n                addNum(li);\n                addNum(ri);\n                res.push_back(ri_sum-li_sum);\n            } else if (q[0] == 2) {\n                int idx = q[1];\n                int val = q[2];\n                for (int p = idx-1; p <= idx+1; p++) clearNum(p);\n                nums[idx] = val;\n                for (int p = idx-1; p <= idx+1; p++) addNum(p);\n            } else {\n                assert(false);\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1718507890.0
}