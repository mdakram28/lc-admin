{
    "username": "OTTFF",
    "submission": "struct UF {\n  int n;\n  int ns; // number of set\n  vector<int> fa,sz;\n  UF(int n_=0):n(n_),ns(n_),fa(n_),sz(n_,1) { \n    for(int i=0;i<n;i++) fa[i]=i;\n  }\n  void init(int n_) {\n    n=ns=n_; fa.assign(n,0); sz.assign(n,1);\n    for(int i=0;i<n;i++) fa[i]=i;\n  }\n  int find(int x) { return x==fa[x] ? x : fa[x]=find(fa[x]); }\n  bool same(int x,int y) { return find(x)==find(y); }\n  bool merge(int x,int y) {\n    x=find(x); y=find(y);\n    if(x==y) return false;\n    if(sz[x]>sz[y]) swap(x,y);\n    sz[y]+=sz[x]; fa[x]=y; ns--;\n    return true;\n  }\n  vector<vector<int>> getgrps() {\n    vector<int> id(n, -1);\n    vector<vector<int> > grps;\n    for (int i = 0; i < n; i++) {\n      if (id[find(i)] == -1) {\n        id[find(i)] = grps.size();\n        grps.emplace_back();\n      }\n      grps[id[find(i)]].push_back(i);\n    }\n    return grps;\n  }\n};\n\ntypedef long long LL;\ninline int sgn(LL x) { return (x > 0) - (x < 0); }\ninline LL sqr(LL x) { return x * x; }\n\nstruct Point {\n  int x, y;\n  Point operator-() const { return {-x, -y}; }\n  Point operator+(const Point& B) const { return {x + B.x, y + B.y}; }\n  Point operator-(const Point& B) const { return {x - B.x, y - B.y}; }\n  Point operator*(int v) const { return {x * v, y * v}; }\n  Point operator/(int v) const { return {x / v, y / v}; }\n  LL operator*(const Point& B) const { return 1LL * x * B.x + 1LL * y * B.y; }\n  LL operator^(const Point& B) const { return 1LL * x * B.y - 1LL * y * B.x; }\n  bool operator==(const Point& B) const { return x == B.x && y == B.y; }\n  bool operator!=(const Point& B) const { return x != B.x || y != B.y; }\n  friend istream& operator>>(istream& in, Point& A) {\n    in >> A.x >> A.y; return in; }\n  friend ostream& operator<<(ostream& out, const Point& A) {\n    out << \"(\" << A.x << \", \" << A.y << \")\"; return out; }\n};\n\nstruct Circle {\n  Point o;\n  int r;\n  Circle(int x, int y, int r) : o(x, y), r(r) {}\n    \n  void print() { cout << o.x << ' ' << o.y << ' ' << r << endl; }\n};\n\nLL dis2(const Point& a, const Point& b) {\n    return sqr(a.x - b.x) + sqr(a.y - b.y);\n}\n\nbool pointInCircle(const Point& a, const Circle& c) {\n    return dis2(a, c.o) <= sqr(c.r);\n}\n\nbool circleInter(const Circle& a, const Circle& b) {\n    return dis2(a.o, b.o) <= sqr(a.r + b.r);\n}\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n        Point st(0, 0), ed(X, Y);\n        \n        vector<Circle> cs;\n        for (auto&& c : circles) {\n            cs.push_back({c[0], c[1], c[2]});\n        }\n        \n        // for (auto c : cs) {\n        //     c.print();\n        // }\n        \n        // start and end not in any circle\n        for (int i = 0; i < n; i++) {\n            if (pointInCircle(st, cs[i]) || pointInCircle(ed, cs[i])) {\n                return false;\n            }\n        }\n        \n        vector<int> touchbr(n), touchtl(n);\n        \n        // bot\n        for (int i = 0; i < n; i++) {\n            int x = cs[i].o.x;\n            int y = cs[i].o.y;\n            int r = cs[i].r;\n            // cs[i].print();\n            int d = abs(0 - y);\n            if (d > r) continue;\n            LL len2 = sqr(r) - sqr(d);\n            \n            // lb = x - sqrt(len2)\n            // rb = x + sqrt(len2)\n            \n            // lb < 0 || X < rb \n            // lb < 0 -> x - sqrt(len2) < 0\n            // X < rb -> X < x + sqrt(len2)\n            \n            if (sqr(x) < len2 || X > x && sqr(X - x) < len2) continue;\n            touchbr[i] = 1;\n        }\n        // top\n        for (int i = 0; i < n; i++) {\n            int x = cs[i].o.x;\n            int y = cs[i].o.y;\n            int r = cs[i].r;\n            // cs[i].print();\n            int d = abs(Y - y);\n            if (d > r) continue;\n            LL len2 = sqr(r) - sqr(d);\n            \n            // lb = x - sqrt(len2)\n            // rb = x + sqrt(len2)\n            \n            // lb < 0 || X < rb \n            // lb < 0 -> x - sqrt(len2) < 0\n            // X < rb -> X < x + sqrt(len2)\n            \n            if (sqr(x) < len2 || X > x && sqr(X - x) < len2) continue;\n            touchtl[i] = 1;\n        }\n        \n        // l\n        for (int i = 0; i < n; i++) {\n            int x = cs[i].o.x;\n            int y = cs[i].o.y;\n            int r = cs[i].r;\n            // cs[i].print();\n            int d = abs(0 - x);\n            if (d > r) continue;\n            LL len2 = sqr(r) - sqr(d);\n            \n            // lb = x - sqrt(len2)\n            // rb = x + sqrt(len2)\n            \n            // lb < 0 || X < rb \n            // lb < 0 -> x - sqrt(len2) < 0\n            // X < rb -> X < x + sqrt(len2)\n            \n            if (sqr(y) < len2 || Y > y && sqr(Y - y) < len2) continue;\n            touchtl[i] = 1;\n        }\n        // r\n        for (int i = 0; i < n; i++) {\n            int x = cs[i].o.x;\n            int y = cs[i].o.y;\n            int r = cs[i].r;\n            // cs[i].print();\n            int d = abs(X - x);\n            if (d > r) continue;\n            LL len2 = sqr(r) - sqr(d);\n            \n            // lb = x - sqrt(len2)\n            // rb = x + sqrt(len2)\n            \n            // lb < 0 || X < rb \n            // lb < 0 -> x - sqrt(len2) < 0\n            // X < rb -> X < x + sqrt(len2)\n            \n            if (sqr(y) < len2 || Y > y && sqr(Y - y) < len2) continue;\n            touchbr[i] = 1;\n        }\n        \n        \n        // for (int i : touchtl) cout << i << ' ';\n        // cout << endl;\n        // for (int i : touchbr) cout << i << ' ';\n        // cout << endl;\n        \n        UF uf(n + 1);\n        for (int i = 0; i < n; i++) {\n            if (touchbr[i]) uf.merge(i, n);\n        }\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (circleInter(cs[i], cs[j])) {\n                    uf.merge(i, j);\n                }\n            }\n        }\n        \n        for (int j = 0; j < n; j++) {\n            if (touchtl[j] && uf.find(j) == uf.find(n)) return false;\n        }\n        \n        return true;\n    }\n};",
    "submit_ts": "1722137643",
    "subm_id": "1335769641"
}