{
    "username": "hakonleung",
    "submission": "const AvlTree = (() => {\n    var t = {},\n        e = {};\n    class r {\n        constructor(t) {\n            (this._value = t),\n                (this._left = null),\n                (this._right = null),\n                (this._parent = null);\n        }\n        setValue(t) {\n            return (this._value = t), this;\n        }\n        getValue() {\n            return this._value;\n        }\n        setLeft(t) {\n            if (t && !(t instanceof r))\n                throw new Error(\"setLeft expects a BinarySearchTreeNode\");\n            return (this._left = t || null), this;\n        }\n        getLeft() {\n            return this._left;\n        }\n        hasLeft() {\n            return this._left instanceof r;\n        }\n        setRight(t) {\n            if (t && !(t instanceof r))\n                throw new Error(\n                    \"setRight expects a BinarySearchTreeNode or null\"\n                );\n            return (this._right = t || null), this;\n        }\n        getRight() {\n            return this._right;\n        }\n        hasRight() {\n            return this._right instanceof r;\n        }\n        setParent(t) {\n            if (t && !(t instanceof r))\n                throw new Error(\n                    \"setParent expects a BinarySearchTreeNode or null\"\n                );\n            return (this._parent = t || null), this;\n        }\n        getParent() {\n            return this._parent;\n        }\n        hasParent() {\n            return this._parent instanceof r;\n        }\n        isRoot() {\n            return null === this._parent;\n        }\n        isLeaf() {\n            return !this.hasLeft() && !this.hasRight();\n        }\n    }\n    e.BinarySearchTreeNode = r;\n    const { BinarySearchTreeNode: i } = e,\n        s = (t, e) => (t === e ? 0 : t > e ? 1 : -1);\n    t.BinarySearchTree = class {\n        constructor(t, e) {\n            if (t && \"function\" != typeof t)\n                throw new Error(\n                    \"BinarySearchTree constructor expects a compare function\"\n                );\n            (this._compare = t || s),\n                (this._options = e || {}),\n                (this._root = null),\n                (this._count = 0);\n        }\n        insert(t) {\n            const e = new i(t),\n                r = (i) => {\n                    const s = this._compare(e.getValue(), i.getValue());\n                    s < 0\n                        ? i.hasLeft()\n                            ? r(i.getLeft())\n                            : (i.setLeft(e.setParent(i)), (this._count += 1))\n                        : s > 0\n                        ? i.hasRight()\n                            ? r(i.getRight())\n                            : (i.setRight(e.setParent(i)), (this._count += 1))\n                        : i.setValue(t);\n                };\n            return (\n                null === this._root\n                    ? ((this._root = e), (this._count += 1))\n                    : r(this._root),\n                this\n            );\n        }\n        has(t) {\n            const e = (r) => {\n                if (null === r) return !1;\n                const i = this._compare(t, r.getValue());\n                return 0 === i || e(i < 0 ? r.getLeft() : r.getRight());\n            };\n            return e(this._root);\n        }\n        hasKey(t) {\n            if (void 0 === this._options.key || null === this._options.key)\n                throw new Error(\"Missing key prop name in constructor options\");\n            return this.has({ [this._options.key]: t });\n        }\n        find(t) {\n            const e = (r) => {\n                if (null === r) return null;\n                const i = this._compare(t, r.getValue());\n                return 0 === i ? r : e(i < 0 ? r.getLeft() : r.getRight());\n            };\n            return e(this._root);\n        }\n        findKey(t) {\n            if (void 0 === this._options.key || null === this._options.key)\n                throw new Error(\"Missing key prop name in constructor options\");\n            return this.find({ [this._options.key]: t });\n        }\n        max(t = this._root) {\n            return null === t\n                ? null\n                : t.hasRight()\n                ? this.max(t.getRight())\n                : t;\n        }\n        min(t = this._root) {\n            return null === t ? null : t.hasLeft() ? this.min(t.getLeft()) : t;\n        }\n        lowerBound(t, e = !0) {\n            let r = null;\n            const i = (s) => {\n                if (null === s) return r;\n                const n = this._compare(t, s.getValue());\n                return n > 0 || (e && 0 === n)\n                    ? ((null === r ||\n                          this._compare(r.getValue(), s.getValue()) <= 0) &&\n                          (r = s),\n                      i(s.getRight()))\n                    : i(s.getLeft());\n            };\n            return i(this._root);\n        }\n        floor(t, e = !0) {\n            return this.lowerBound(t, e);\n        }\n        upperBound(t, e = !0) {\n            let r = null;\n            const i = (s) => {\n                if (null === s) return r;\n                const n = this._compare(t, s.getValue());\n                return n < 0 || (e && 0 === n)\n                    ? ((null === r ||\n                          this._compare(r.getValue(), s.getValue()) >= 0) &&\n                          (r = s),\n                      i(s.getLeft()))\n                    : i(s.getRight());\n            };\n            return i(this._root);\n        }\n        ceil(t, e = !0) {\n            return this.upperBound(t, e);\n        }\n        root() {\n            return this._root;\n        }\n        count() {\n            return this._count;\n        }\n        remove(t) {\n            const e = (t, r) => {\n                if (null === r) return !1;\n                const i = this._compare(t, r.getValue());\n                if (i < 0) return e(t, r.getLeft());\n                if (i > 0) return e(t, r.getRight());\n                if (r.isLeaf())\n                    return (\n                        r.isRoot()\n                            ? (this._root = null)\n                            : this._compare(t, r.getParent().getValue()) < 0\n                            ? r.getParent().setLeft(null)\n                            : r.getParent().setRight(null),\n                        (this._count -= 1),\n                        !0\n                    );\n                if (!r.hasRight())\n                    return (\n                        r.isRoot()\n                            ? (this._root = r.getLeft())\n                            : this._compare(t, r.getParent().getValue()) < 0\n                            ? r.getParent().setLeft(r.getLeft())\n                            : r.getParent().setRight(r.getLeft()),\n                        r.getLeft().setParent(r.getParent()),\n                        (this._count -= 1),\n                        !0\n                    );\n                if (!r.hasLeft())\n                    return (\n                        r.isRoot()\n                            ? (this._root = r.getRight())\n                            : this._compare(t, r.getParent().getValue()) < 0\n                            ? r.getParent().setLeft(r.getRight())\n                            : r.getParent().setRight(r.getRight()),\n                        r.getRight().setParent(r.getParent()),\n                        (this._count -= 1),\n                        !0\n                    );\n                const s = this.min(r.getRight());\n                return r.setValue(s.getValue()), e(s.getValue(), s);\n            };\n            return e(t, this._root);\n        }\n        traverseInOrder(t, e) {\n            if (\"function\" != typeof t)\n                throw new Error(\".traverseInOrder expects a callback function\");\n            const r = (i) => {\n                null === i ||\n                    (e && e()) ||\n                    (r(i.getLeft()), (e && e()) || (t(i), r(i.getRight())));\n            };\n            r(this._root);\n        }\n        traversePreOrder(t, e) {\n            if (\"function\" != typeof t)\n                throw new Error(\n                    \".traversePreOrder expects a callback function\"\n                );\n            const r = (i) => {\n                null === i ||\n                    (e && e()) ||\n                    (t(i), r(i.getLeft()), r(i.getRight()));\n            };\n            r(this._root);\n        }\n        traversePostOrder(t, e) {\n            if (\"function\" != typeof t)\n                throw new Error(\n                    \".traversePostOrder expects a callback function\"\n                );\n            const r = (i) => {\n                null === i ||\n                    (e && e()) ||\n                    (r(i.getLeft()), r(i.getRight()), (e && e()) || t(i));\n            };\n            r(this._root);\n        }\n        clear() {\n            (this._root = null), (this._count = 0);\n        }\n    };\n    var n = {},\n        h = {};\n    const a = (t, e) => (t === e ? 0 : t > e ? 1 : -1);\n    class o {\n        constructor(t, e) {\n            if (e && \"function\" != typeof e)\n                throw new Error(\n                    \"AvlTreeNode constructor expects a compare function\"\n                );\n            (this._value = t),\n                (this._compare = e || a),\n                (this._left = null),\n                (this._right = null),\n                (this._parent = null),\n                (this._height = 1);\n        }\n        setValue(t) {\n            return (this._value = t), this;\n        }\n        getValue() {\n            return this._value;\n        }\n        setLeft(t) {\n            if (t && !(t instanceof o))\n                throw new Error(\"setLeft expects an AvlTreeNode\");\n            return (this._left = t || null), this;\n        }\n        getLeft() {\n            return this._left;\n        }\n        hasLeft() {\n            return this._left instanceof o;\n        }\n        setRight(t) {\n            if (t && !(t instanceof o))\n                throw new Error(\"setRight expects a AvlTreeNode or null\");\n            return (this._right = t || null), this;\n        }\n        getRight() {\n            return this._right;\n        }\n        hasRight() {\n            return this._right instanceof o;\n        }\n        setParent(t) {\n            if (t && !(t instanceof o))\n                throw new Error(\"setParent expects an AvlTreeNode\");\n            return (this._parent = t || null), this;\n        }\n        getParent() {\n            return this._parent;\n        }\n        hasParent() {\n            return this._parent instanceof o;\n        }\n        isRoot() {\n            return null === this._parent;\n        }\n        isLeaf() {\n            return !this.hasLeft() && !this.hasRight();\n        }\n        rotateLeft() {\n            const t = this._right;\n            return (\n                null !== t &&\n                    (t.hasLeft() && t.getLeft().setParent(this),\n                    (this._right = t.getLeft()),\n                    t.setLeft(this),\n                    t.setParent(this._parent)),\n                this.hasParent() &&\n                    null !== t &&\n                    (this._compare(this._parent.getValue(), t.getValue()) < 0\n                        ? this._parent.setRight(t)\n                        : this._parent.setLeft(t)),\n                (this._parent = t),\n                this.updateHeight(),\n                this.hasParent() && this._parent.updateHeight(),\n                this\n            );\n        }\n        rotateRight() {\n            const t = this._left;\n            return (\n                null !== t &&\n                    (t.hasRight() && t.getRight().setParent(this),\n                    (this._left = t.getRight()),\n                    t.setRight(this),\n                    t.setParent(this._parent)),\n                this.hasParent() &&\n                    null !== t &&\n                    (this._compare(this._parent.getValue(), t.getValue()) > 0\n                        ? this._parent.setLeft(t)\n                        : this._parent.setRight(t)),\n                (this._parent = t),\n                this.updateHeight(),\n                this.hasParent() && this._parent.updateHeight(),\n                this\n            );\n        }\n        rotateLeftRight() {\n            return (\n                this.hasLeft() && this._left.rotateLeft(),\n                this.rotateRight(),\n                this\n            );\n        }\n        rotateRightLeft() {\n            return (\n                this.hasRight() && this._right.rotateRight(),\n                this.rotateLeft(),\n                this\n            );\n        }\n        getLeftHeight() {\n            return this.hasLeft() ? this.getLeft().getHeight() : 0;\n        }\n        getRightHeight() {\n            return this.hasRight() ? this.getRight().getHeight() : 0;\n        }\n        updateHeight() {\n            return (\n                (this._height =\n                    Math.max(this.getLeftHeight(), this.getRightHeight()) + 1),\n                this\n            );\n        }\n        getHeight() {\n            return this._height;\n        }\n        getBalance() {\n            return this.getLeftHeight() - this.getRightHeight();\n        }\n        isBalanced() {\n            const t = this.getBalance();\n            return t >= -1 && t <= 1;\n        }\n    }\n    h.AvlTreeNode = o;\n    const { BinarySearchTree: g } = t,\n        { AvlTreeNode: u } = h;\n    n.AvlTree = class extends g {\n        constructor(t, e) {\n            if (t && \"function\" != typeof t)\n                throw new Error(\n                    \"AvlTree constructor expects a compare function\"\n                );\n            super(t, e);\n        }\n        _balanceNode(t) {\n            if (!t) return;\n            t.updateHeight();\n            const e = t.getBalance();\n            e > 1\n                ? t.getLeft().hasLeft()\n                    ? t.rotateRight()\n                    : t.getLeft().hasRight() && t.rotateLeftRight()\n                : e < -1 &&\n                  (t.getRight().hasRight()\n                      ? t.rotateLeft()\n                      : t.getRight().hasLeft() && t.rotateRightLeft()),\n                (e < -1 || e > 1) &&\n                    t === this._root &&\n                    (this._root = t.getParent());\n        }\n        insert(t) {\n            const e = new u(t, this._compare),\n                r = (i) => {\n                    const s = this._compare(t, i.getValue());\n                    s < 0\n                        ? i.hasLeft()\n                            ? (r(i.getLeft()), this._balanceNode(i))\n                            : (e.setParent(i),\n                              i.setLeft(e).updateHeight(),\n                              (this._count += 1))\n                        : s > 0\n                        ? i.hasRight()\n                            ? (r(i.getRight()), this._balanceNode(i))\n                            : (e.setParent(i),\n                              i.setRight(e).updateHeight(),\n                              (this._count += 1))\n                        : i.setValue(t);\n                };\n            return (\n                null === this._root\n                    ? ((this._root = e), (this._count += 1))\n                    : r(this._root),\n                this\n            );\n        }\n        remove(t) {\n            const e = (t, r) => {\n                if (null === r) return !1;\n                const i = this._compare(t, r.getValue());\n                if (i < 0) {\n                    const i = e(t, r.getLeft());\n                    return this._balanceNode(r), i;\n                }\n                if (i > 0) {\n                    const i = e(t, r.getRight());\n                    return this._balanceNode(r), i;\n                }\n                if (r.isLeaf())\n                    return (\n                        r.isRoot()\n                            ? (this._root = null)\n                            : this._compare(t, r.getParent().getValue()) < 0\n                            ? r.getParent().setLeft(null).updateHeight()\n                            : r.getParent().setRight(null).updateHeight(),\n                        (this._count -= 1),\n                        !0\n                    );\n                if (!r.hasRight())\n                    return (\n                        r.isRoot()\n                            ? (this._root = r.getLeft())\n                            : this._compare(t, r.getParent().getValue()) < 0\n                            ? r.getParent().setLeft(r.getLeft()).updateHeight()\n                            : r\n                                  .getParent()\n                                  .setRight(r.getLeft())\n                                  .updateHeight(),\n                        r.getLeft().setParent(r.getParent()),\n                        (this._count -= 1),\n                        !0\n                    );\n                if (!r.hasLeft())\n                    return (\n                        r.isRoot()\n                            ? (this._root = r.getRight())\n                            : this._compare(t, r.getParent().getValue()) < 0\n                            ? r.getParent().setLeft(r.getRight()).updateHeight()\n                            : r\n                                  .getParent()\n                                  .setRight(r.getRight())\n                                  .updateHeight(),\n                        r.getRight().setParent(r.getParent()),\n                        (this._count -= 1),\n                        !0\n                    );\n                const s = this.min(r.getRight()),\n                    n = e(s.getValue(), s);\n                return r.setValue(s.getValue()), this._balanceNode(r), n;\n            };\n            return e(t, this._root);\n        }\n    };\n    const { BinarySearchTree: l } = t,\n        { BinarySearchTreeNode: c } = e,\n        { AvlTree: f } = n,\n        { AvlTreeNode: _ } = h;\n    var p = {\n            BinarySearchTree: l,\n            BinarySearchTreeNode: c,\n            AvlTree: f,\n            AvlTreeNode: _,\n        },\n        R = p.AvlTree,\n        L = p.AvlTreeNode,\n        d = p.BinarySearchTree,\n        P = p.BinarySearchTreeNode;\n    return R;\n})();\n\nclass SegmentTree_Simple {\n    constructor(size, mergeVal) {\n        this.size = size\n        this.mergeVal = mergeVal\n        this.tree = {}\n    }\n    modify (lazy, l, r, idx = 0, tl = 0, tr = this.size - 1) {\n        if (tl > r || tr < l) return\n        if (tl >= l && tr <= r) return this.tree[idx] = lazy\n        this.modify(lazy, l, r, (idx << 1) + 1, tl, (tl + tr) >> 1)\n        this.modify(lazy, l, r, (idx << 1) + 2, ((tl + tr) >> 1) + 1, tr)\n        this.tree[idx] = this.mergeVal(\n            this.tree[(idx << 1) + 1],\n            this.tree[(idx << 1) + 2]\n        )\n    }\n    query (l, r, idx = 0, tl = 0, tr = this.size - 1) {\n        if (tl > r || tr < l) return 0\n        if (tl >= l && tr <= r) return this.tree[idx] || 0\n        return this.mergeVal(\n            this.query(l, r, (idx << 1) + 1, tl, (tl + tr) >> 1),\n            this.query(l, r, (idx << 1) + 2, ((tl + tr) >> 1) + 1, tr)\n        )\n    }\n}\n/**\n * @param {number} n\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar shortestDistanceAfterQueries = function(n, queries) {\n    const avl = new AvlTree()\n    const rMap = {}\n    const ans = []\n    let t = n - 1\n    queries.forEach(([a, b]) => {\n        const contain = avl.lowerBound(a, true)\n        if (contain && rMap[contain._value] >= b) {\n            return ans.push(t)\n        }\n        let sum = 0, pre = a, cur\n        while (cur = avl.upperBound(a, true)) {\n            cur = cur._value\n            if (cur >= b) break\n            sum += cur - pre + 1\n            pre = rMap[cur]\n            avl.remove(cur)\n        }\n        // console.log(sum, pre)\n        sum += b - pre\n        t = t - sum + 1\n        rMap[a] = b\n        avl.insert(a)\n        ans.push(t)\n    })\n    return ans\n};\n",
    "submit_ts": "1722742591",
    "subm_id": "552345618"
}