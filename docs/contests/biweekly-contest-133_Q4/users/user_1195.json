{
    "username": "pandeysujal04",
    "submission": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n      const int MOD = 1e9 + 7;\n    int n;\n    vector<vector<int>> requirements;\n    vector<int> permutation;\n    vector<bool> used;\n    int count;\n  vector<vector<long long>> st; \n\n//  void solve(int idx) {\n//         if (idx == n) {\n//             if (check()) {\n//                 count = (count + 1) % MOD;\n//             }\n//             return;\n//         }\n\n//         for (int i = 0; i < n; ++i) {\n//             if (!used[i]) {\n//                 used[i] = true;\n//                 permutation[idx] = i;\n//                 sole(idx + 1);\n//                 used[i] = false;\n//             }\n//         }\n//     }\n\n//     bool check() {\n//         for (auto& req : requirements) {\n//             int endIdx = req[0];\n//             int invCount = req[1];\n\n//             int inversions = 0;\n//             for (int i = 0; i <= endIdx; ++i) {\n//                 for (int j = i + 1; j <= endIdx; ++j) {\n//                     if (permutation[i] > permutation[j]) {\n//                         inversions++;\n//                     }\n//                 }\n//             }\n\n//             if (inversions != invCount) {\n//                 return false;\n//             }\n//         }\n//         return true;\n//     }\n    int numberOfPermutations(int n, vector<vector<int>>& requirements) {\n   this->n = n;\n        this->requirements = requirements;\n        permutation.resize(n);\n        used.assign(n, false);\n        count = 0;\n   unordered_map<int, int> mp;\n        for (auto& req : requirements) {\n            mp[req[0] + 1] = req[1];\n        }\n\n        //dfs(0);\n  st = vector<vector<long long>>(n + 1, vector<long long>(401, 0));\n        st[0][0] = 1;\n\n        for (int i=1; i<=n;i++) {\n          //   vector<vector<long long>> newSt(i + 1, vector<long long>(401, 0));\n\n            for (int j=0; j<401; j++) {\n                st[i][j] = 0;\n                for (int k= 0; k<i; k++) {\n                    int req = j-k;\n                    if (req >= 0) {\n                        st[i][j] = (st[i][j]+st[i-1][req]) % MOD;\n                    }\n                }\n            }\n\n//              if (mp.count(i) > 0) {\n//         int requiredInversions = mp[i];\n        \n//         // Copy values from newSt[i] to st[i] considering the required inversions\n//         for (int j = 0; j < 401; ++j) {\n//             if (j <= requiredInversions) {\n//                 st[i][j] = newSt[i][j];\n//             } else {\n//                 st[i][j] = 0;\n//             }\n//         }\n//     } else {\n//         // If no requirement for inversions, simply copy newSt[i] to st[i]\n//         st[i] = newSt[i];\n//     }\n// }\n\n            if (mp.count(i) > 0) {\n                int check =mp[i];\n                for (int k=0; k<401; k++) {\n                    if (k!= check) {\n                        st[i][k] = 0;\n                    }\n                }\n            }\n        }\n\n\n        long long ans = 0;\n        for (int i=0;i<401;i++) {\n            ans = (ans+st[n][i]) % MOD;\n        }\n\n        return static_cast<int>(ans);\n\n     //return count\n    \n   \n    }\n};\n\n\n",
    "submit_ts": 1719071833.0
}