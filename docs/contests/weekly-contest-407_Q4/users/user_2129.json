{
    "username": "therealchainman",
    "submission": "const int INF = 1e9;\nstruct SegmentTree {\n    int size;\n    vector<int> nodes, index;\n\n    void init(int num_nodes) {\n        size = 1;\n        while (size < num_nodes) size *= 2;\n        nodes.assign(size * 2, 0);\n        index.assign(size * 2, 0);\n    }\n\n    int func(int x, int y) {\n        return min(x, y);\n    }\n\n    void ascend(int segment_idx) {\n        while (segment_idx > 0) {\n            int left_segment_idx = 2 * segment_idx, right_segment_idx = 2 * segment_idx + 1;\n            int left_min = nodes[left_segment_idx], right_min = nodes[right_segment_idx];\n            if (left_min < right_min) index[segment_idx] = index[left_segment_idx];\n            else index[segment_idx] = index[right_segment_idx];\n            nodes[segment_idx] = func(nodes[left_segment_idx], nodes[right_segment_idx]);\n            segment_idx >>= 1;\n        }\n    }\n\n    void update(int segment_idx, int idx, int val) {\n        segment_idx += size;\n        nodes[segment_idx] = val;\n        index[segment_idx] = idx;\n        segment_idx >>= 1;\n        ascend(segment_idx);\n    }\n\n    pair<int, int> query(int left, int right) {\n        left += size, right += size;\n        int res = INF, idx = 0;\n        while (left <= right) {\n            if (left & 1) {\n                if (nodes[left] < res) {\n                    idx = index[left];\n                    res = nodes[left];\n                }\n                left++;\n            }\n            if (~right & 1) {\n                if (nodes[right] < res) {\n                    res = nodes[right];\n                    idx = index[right];\n                }\n                right--;\n            }\n            left >>= 1, right >>= 1;\n        }\n        return make_pair(res, idx);\n    }\n};\n\nSegmentTree seg;\n\nlong long calc(int l, int r, long long p) {\n    long long res = 0;\n    if (l > r) return res;\n    auto [val, idx] = seg.query(l, r);\n    long long delta = val - p;\n    // assert(delta >= 0);\n    res += delta;\n    res += calc(l, idx - 1, p + delta) + calc(idx + 1, r, p + delta);\n    return res;\n}\n\nclass Solution {\npublic:\n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n        int N = nums.size();\n        seg.init(N);\n        long long ans = 0;\n        vector<int> diff(N, 0);\n        for (int i = 0; i < N; i++) {\n            diff[i] = target[i] - nums[i];\n        }\n        vector<pair<int, int>> ranges;\n        int sign = 0, last = 0;\n        for (int i = 0; i < N; i++) {\n            int d = diff[i];\n            seg.update(i, i, abs(d));\n            // cout << d << \" \";\n            if (d > 0) {\n                if (sign <= 0) {\n                    if (sign < 0) ranges.emplace_back(last, i - 1);\n                    last = i;\n                    sign = 1;\n                }\n            } else if (d < 0) {\n                if (sign >= 0) {\n                    if (sign > 0) ranges.emplace_back(last, i - 1);\n                    last = i;\n                    sign = -1;\n                }\n            } else {\n                if (sign != 0) ranges.emplace_back(last, i - 1);\n                sign = 0;\n                last = i;\n            }\n        }\n        if (sign != 0) ranges.emplace_back(last, N - 1);\n        // cout << endl;\n        for (auto [l, r] : ranges) {\n            // cout << l << \" \" << r << endl;\n            ans += calc(l, r, 0);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1721532828",
    "subm_id": "1327995004"
}