{
    "username": "st019",
    "submission": "class Solution {\npublic:\n    pair<int,int> minDist(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        if(n == 1) return {0, 0};\n        if(n == 2 || n == 3) return {1, 0};\n        unordered_map<int, unordered_set<int>> m;\n        vector<int> deg(n, 0);\n        for(auto& edge : edges) {\n            m[edge[0]].insert(edge[1]);\n            m[edge[1]].insert(edge[0]);\n            deg[edge[0]]++;\n            deg[edge[1]]++;\n        }\n        queue<int>q;\n        for(int i=0;i<n;i++) {\n            if(deg[i]==1) {\n                q.push(i);\n            }\n        }\n        int cnt = 0;\n        int level = -1;\n        while(!q.empty()) {\n            cnt = 0;\n            ++level;\n            int sz = q.size();\n            for(int i = 0; i < sz; ++i) {\n                int curr = q.front();\n                q.pop();\n                ++cnt;\n                for(auto neigh : m[curr]) {\n                    --deg[neigh];\n                    if(deg[neigh] == 1) {\n                        q.push(neigh);\n                    }\n                }\n            }\n\n        }\n        return (cnt == 2) ? make_pair(level, 1) : make_pair(level, 0);\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        auto [dist1, add1] = minDist(edges1);\n        auto [dist2, add2] = minDist(edges2);\n        int newDiam = dist1 + add1 + dist2 + add2 + 1;\n        int oldDiam = max(dist1 * 2 + add1, dist2 * 2 + add2);\n        return max(oldDiam, newDiam);\n\n    }\n};",
    "submit_ts": 1719718429.0
}