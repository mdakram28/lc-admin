{
    "username": "cuiwanyun",
    "submission": "class Solution:\n    def largestPalindrome(self, n: int, k: int) -> str:\n        mod = [[0 for _ in range(10)] for _ in range(n)]\n        for i in range(10):\n            mod[0][i] = i % k\n        for i in range(1,n):\n            for j in range(10):\n                mod[i][j] = (mod[i-1][j] * 10) % k\n        \n        f = [[[-1,-1] for _ in range(k)] for _ in range(n)]\n        mod_ranked = [0] # order\n        for i in range((n+1) // 2):\n            mod_ranked_t = []\n            for prev_mod in mod_ranked:\n                for j in reversed(range(10)):\n                    if j==0 and i == 0:\n                        continue\n                    if i == (n+1) // 2 - 1 and n % 2 == 1:\n                        mod_j = (prev_mod + mod[i][j]) % k\n                    else:\n                        mod_j = (prev_mod + mod[i][j] + mod[n-1-i][j]) % k\n            \n                    #print(i, j, mod_j, prev_mod)\n                    if f[i][mod_j][0] == -1:\n                        f[i][mod_j][0] = j\n                        f[i][mod_j][1] = prev_mod\n                        mod_ranked_t.append(mod_j)\n            mod_ranked = mod_ranked_t\n            #print(f[i])\n            #print(mod_ranked)\n        \n        ret = [\"t\" for _ in range(n)]\n        i = (n+1) // 2 - 1\n        mod_j = 0\n        while i>=0:\n            ret[i] = str(f[i][mod_j][0])\n            ret[n-1-i] = str(f[i][mod_j][0])\n            mod_j = f[i][mod_j][1]\n            i -= 1\n        return \"\".join(ret)\n                    \n        ",
    "submit_ts": "1723950955",
    "subm_id": "556402352"
}