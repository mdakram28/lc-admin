{
    "username": "ashu_2211",
    "submission": "class Solution {\npublic:\n    \n    \n    void dfs(int cur, int par , int &diameter , vector<vector<int>>&tree, int height[] ){\n        int max1 = 0;\n        int max2 = 0;\n        for (auto u : tree[cur]) {\n            if (u == par)\n                continue;\n            dfs(u, cur, diameter,tree , height );\n\n            height[cur] = max(height[cur], height[u]);\n            if (height[u] >= max1) {\n                max2 = max1;\n                max1 = height[u];\n            }\n            else if (height[u] > max2) {\n                max2 = height[u];\n            }\n        }\n        height[cur] += 1;\n        diameter = max(diameter, height[cur]);\n        diameter = max(diameter, max1 + max2 + 1);\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1 ; \n        int m = edges2.size() + 1 ; \n        vector<vector<int>> graph1(n) , graph2(m);\n        for(auto i : edges1  ){\n            graph1[i[0]].push_back(i[1]);\n            graph1[i[1]].push_back(i[0]);\n        }\n        for(auto i : edges2 ){\n            graph2[i[0]].push_back(i[1]);\n            graph2[i[1]].push_back(i[0]);\n        }\n        int diameter1 = 0 ; int diameter2 = 0 ; \n        int height1[100005] ;int height2[100005] ;\n        memset(height1 , 0 , sizeof(height1));\n        memset(height2 , 0 , sizeof(height2));\n        dfs(0 ,-1, diameter1 , graph1 , height1) ;\n        dfs(0 ,-1, diameter2 , graph2 , height2) ;\n        int ans = max({diameter1 - 1 , diameter2 - 1 ,((diameter1 )/2 + (diameter2)/2 + 1)  });\n        return ans;\n        \n        \n    }\n};",
    "submit_ts": 1719719471.0
}