{
    "username": "LayCurse",
    "submission": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"inline\")\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<class T> struct cLtraits_identity{\n  using type = T;\n}\n;\ntemplate<class T> using cLtraits_try_make_unsigned =\n  typename conditional<\n    is_integral<T>::value,\n    make_unsigned<T>,\n    cLtraits_identity<T>\n    >::type;\nvoid*wmem;\nchar memarr[96000000];\ntemplate<class S, class T> inline S chmin(S &a, T b){\n  if(a>b){\n    a=b;\n  }\n  return a;\n}\ntemplate<class S, class T> inline S chmax(S &a, T b){\n  if(a<b){\n    a=b;\n  }\n  return a;\n}\ntemplate<class S, class T> inline S divup_L(S a, T b){\n  return (a+b-1)/b;\n}\ntemplate<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){\n  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\n  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );\n  (*arr)=(T*)(*mem);\n  (*mem)=((*arr)+x);\n}\ntemplate<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){\n  walloc1d(arr, x2-x1, mem);\n  (*arr) -= x1;\n}\ninline int Ilog2_f_L(const int n){\n  int res;\n  if(n <= 0){\n    return -1;\n  }\n  res = sizeof(int) * 8 - __builtin_clz(n) - 1;\n  return res;\n}\ninline int Ilog2_f_L(const long long n){\n  int res;\n  if(n <= 0){\n    return -1;\n  }\n  res = sizeof(long long) * 8 - __builtin_clzll(n) - 1;\n  return res;\n}\ntemplate<class T1> void sortI(int N, T1 a[], void *mem = wmem){\n  sort(a, a+N);\n}\ntemplate<class T1, class T2> void sortI(int N, T1 a[], T2 b[], void *mem = wmem){\n  int i;\n  pair<T1, T2>*arr;\n  walloc1d(&arr, N, &mem);\n  for(i=(0);i<(N);i++){\n    arr[i].first = a[i];\n    arr[i].second = b[i];\n  }\n  sort(arr, arr+N);\n  for(i=(0);i<(N);i++){\n    a[i] = arr[i].first;\n    b[i] = arr[i].second;\n  }\n}\ntemplate<class T1, class T2, class T3> void sortI(int N, T1 a[], T2 b[], T3 c[], void *mem = wmem){\n  int i;\n  pair<T1, pair<T2, T3> >*arr;\n  walloc1d(&arr, N, &mem);\n  for(i=(0);i<(N);i++){\n    arr[i].first = a[i];\n    arr[i].second.first = b[i];\n    arr[i].second.second = c[i];\n  }\n  sort(arr, arr+N);\n  for(i=(0);i<(N);i++){\n    a[i] = arr[i].first;\n    b[i] = arr[i].second.first;\n    c[i] = arr[i].second.second;\n  }\n}\ntemplate<class T1, class T2, class T3, class T4> void sortI(int N, T1 a[], T2 b[], T3 c[], T4 d[], void *mem = wmem){\n  int i;\n  pair<pair<T1, T2>, pair<T3, T4> >*arr;\n  walloc1d(&arr, N, &mem);\n  for(i=(0);i<(N);i++){\n    arr[i].first.first = a[i];\n    arr[i].first.second = b[i];\n    arr[i].second.first = c[i];\n    arr[i].second.second = d[i];\n  }\n  sort(arr, arr+N);\n  for(i=(0);i<(N);i++){\n    a[i] = arr[i].first.first;\n    b[i] = arr[i].first.second;\n    c[i] = arr[i].second.first;\n    d[i] = arr[i].second.second;\n  }\n}\ntemplate<class T> inline int sort_helper_getbit(T A[]){\n  return -1;\n}\ntemplate<> inline int sort_helper_getbit(int A[]){\n  return sizeof(int)*8;\n}\ntemplate<> inline int sort_helper_getbit(unsigned A[]){\n  return sizeof(unsigned)*8;\n}\ntemplate<> inline int sort_helper_getbit(long long A[]){\n  return sizeof(long long)*8;\n}\ntemplate<> inline int sort_helper_getbit(unsigned long long A[]){\n  return sizeof(unsigned long long)*8;\n}\ntemplate<> inline int sort_helper_getbit(char A[]){\n  return sizeof(char)*8;\n}\ntemplate<class T> void sortA_1_int_L(int N, T A[], void *mem = wmem){\n  int i;\n  int j;\n  int k;\n  int b;\n  int s;\n  int ok;\n  ok = 1;\n  for(i=(1);i<(N);i++){\n    if(A[i-1] > A[i]){\n      ok = 0;\n      break;\n    }\n  }\n  if(ok){\n    return;\n  }\n  if(N < 128){\n    sort(A,A+N);\n    return;\n  }\n  b = sort_helper_getbit(A);\n  if(b==-1){\n    sort(A,A+N);\n    return;\n  }\n  T mn;\n  T mx;\n  mn = mx = A[0];\n  for(i=(1);i<(N);i++){\n    chmin(mn, A[i]);\n  }\n  for(i=(1);i<(N);i++){\n    chmax(mx, A[i]);\n  }\n  ok = 1;\n  if(mn < 0 && mx > 0 && (mn < -N || mx > N)){\n    ok = 0;\n  }\n  if(ok && mx - mn > N){\n    ok = 0;\n  }\n  if(ok){\n    int*tmp;\n    walloc1d(&tmp, mx-mn+1, &mem);\n    for(i=(0);i<(mx-mn+1);i++){\n      tmp[i] = 0;\n    }\n    for(i=(0);i<(N);i++){\n      tmp[A[i]-mn]++;\n    }\n    k = 0;\n    for(i=(0);i<(mx-mn+1);i++){\n      while(tmp[i] > 0){\n        tmp[i]--;\n        A[k++] = i+mn;\n      }\n    }\n    return;\n  }\n  {\n    typename make_unsigned<T>::type *t[2];\n    typename make_unsigned<T>::type  mask;\n    typename make_unsigned<T>::type  cur;\n    typename make_unsigned<T>::type  one = 1;\n    T tone = 1;\n    int*pos;\n    int nn = 0;\n    int ss;\n    s =Ilog2_f_L(N);\n    if(s > 8){\n      s = (8 + (s-7)/2);\n    }\n    ss = 1;\n    for(;;){\n      if(ss >= b){\n        break;\n      }\n      if( mx >= 0 && (tone << (ss-1)) < mx ){\n        ss++;\n        continue;\n      }\n      if( mn < 0 && -(tone << (ss-1)) >= mn ){\n        ss++;\n        continue;\n      }\n      break;\n    }\n    k =(divup_L(ss,s));\n    s =(divup_L(ss,k));\n    mask = 0;\n    for(i=(0);i<(b);i++){\n      if(i < s*k){\n        mask |= one << i;\n      }\n    }\n    t[0] = (typename make_unsigned<T>::type *) A;\n    walloc1d(&t[1], N, &mem);\n    walloc1d(&pos, (1<<s)+1, &mem);\n    for(j=(0);j<(k);j++){\n      cur = 0;\n      for(i=(0);i<(b);i++){\n        if(s*j <= i && i < s*(j+1) && i < b){\n          cur |= one << i;\n        }\n      }\n      for(i=(0);i<((1<<s)+1);i++){\n        pos[i] = 0;\n      }\n      for(i=(0);i<(N);i++){\n        pos[((t[nn][i]&cur)>>(s*j))+1]++;\n      }\n      for(i=(0);i<((1<<s));i++){\n        pos[i+1] += pos[i];\n      }\n      for(i=(0);i<(N);i++){\n        t[nn^1][pos[(t[nn][i]&cur)>>(s*j)]++] = t[nn][i];\n      }\n      nn ^= 1;\n      mask ^= cur;\n    }\n    if(mn < 0 && mx >= 0){\n      k = 0;\n      for(i=(0);i<(N);i++){\n        if(A[i] < 0){\n          k++;\n        }\n      }\n      for(i=(0);i<(k);i++){\n        t[nn^1][i] = t[nn][N-k+i];\n      }\n      for(i=(k);i<(N);i++){\n        t[nn^1][i] = t[nn][i-k];\n      }\n      nn ^= 1;\n    }\n    if(nn==1){\n      for(i=(0);i<(N);i++){\n        t[0][i] = t[1][i];\n      }\n    }\n    return;\n  }\n  sort(A, A+N);\n}\ntemplate<class T> void sortA_1_nonint_L(int N, T A[], void *mem = wmem){\n  sort(A,A+N);\n}\ntemplate<class T> void sortA_1_call_L(int N, T A[], void *mem = wmem){\n  sortA_1_nonint_L(N, A, mem);\n}\ntemplate<> void sortA_1_call_L(int N, int A[], void *mem){\n  sortA_1_int_L(N, A, mem);\n}\ntemplate<> void sortA_1_call_L(int N, unsigned A[], void *mem){\n  sortA_1_int_L(N, A, mem);\n}\ntemplate<> void sortA_1_call_L(int N, long long A[], void *mem){\n  sortA_1_int_L(N, A, mem);\n}\ntemplate<> void sortA_1_call_L(int N, unsigned long long A[], void *mem){\n  sortA_1_int_L(N, A, mem);\n}\ntemplate<> void sortA_1_call_L(int N, char A[], void *mem){\n  sortA_1_int_L(N, A, mem);\n}\ntemplate<class T1> void sortA(int N, T1 a[], void *mem = wmem){\n  sortA_1_call_L(N, a, mem);\n}\ntemplate<class T1, class T2> void sortA_2_int_L(int N, T1 A[], T2 B[], void *mem = wmem){\n  int i;\n  int b_a;\n  int b_b;\n  int s1;\n  int s2;\n  int so2;\n  T1 mn1;\n  T1 mx1;\n  T2 mn2;\n  T2 mx2;\n  typename cLtraits_try_make_unsigned<T1>::type r1;\n  typename cLtraits_try_make_unsigned<T2>::type r2;\n  so2 = 1;\n  for(i=(1);i<(N);i++){\n    if(A[i-1] > A[i] || (A[i-1]==A[i] && B[i-1] > B[i])){\n      so2 = 0;\n      break;\n    }\n  }\n  if(so2){\n    return;\n  }\n  so2 = 1;\n  for(i=(1);i<(N);i++){\n    if(A[i-1] > A[i]){\n      so2 = 0;\n      break;\n    }\n  }\n  if(so2==1){\n    int k = 0;\n    for(i=(1);i<(N);i++){\n      if(A[i] != A[i-1]){\n        sortA_1_call_L(i-k, B+k, mem);\n        k = i;\n      }\n    }\n    sortA_1_call_L(N-k, B+k, mem);\n    return;\n  }\n  if(N < 128){\n    sortI(N,A,B,mem);\n    return;\n  }\n  b_a = sort_helper_getbit(A);\n  b_b = sort_helper_getbit(B);\n  if(b_a == -1 || b_b == -1){\n    sortI(N,A,B,mem);\n    return;\n  }\n  mn1 = mx1 = A[0];\n  for(i=(1);i<(N);i++){\n    chmin(mn1, A[i]);\n  }\n  for(i=(1);i<(N);i++){\n    chmax(mx1, A[i]);\n  }\n  mn2 = mx2 = B[0];\n  for(i=(1);i<(N);i++){\n    chmin(mn2, B[i]);\n  }\n  for(i=(1);i<(N);i++){\n    chmax(mx2, B[i]);\n  }\n  if(mn1 < -4611686016279904256LL || mn2 < -4611686016279904256LL || mx1 > 4611686016279904256LL || mx2 > 4611686016279904256LL || mx1-mn1 > 4611686016279904256LL || mx2-mn2 > 4611686016279904256LL){\n    sortI(N,A,B,mem);\n    return;\n  }\n  r1 = (typename cLtraits_try_make_unsigned<T1>::type)(mx1) - (typename cLtraits_try_make_unsigned<T1>::type)(mn1);\n  r2 = (typename cLtraits_try_make_unsigned<T2>::type)(mx2) - (typename cLtraits_try_make_unsigned<T2>::type)(mn2);\n  if(r1 == 0){\n    sortA_1_call_L(N, B, mem);\n    return;\n  }\n  if(r2 == 0){\n    sortA_1_call_L(N, A, mem);\n    return;\n  }\n  if(r1 <= N){\n    so2 = 1;\n    for(i=(1);i<(N);i++){\n      if(B[i-1] > B[i]){\n        so2 = 0;\n        break;\n      }\n    }\n    if(so2 == 1){\n      T1*aa;\n      T2*bb;\n      int*pos;\n      int k;\n      walloc1d(&aa,N,&mem);\n      walloc1d(&bb,N,&mem);\n      walloc1d(&pos,r1+2,&mem);\n      for(i=(0);i<(r1+2);i++){\n        pos[i] = 0;\n      }\n      for(i=(0);i<(N);i++){\n        aa[i] = A[i];\n      }\n      for(i=(0);i<(N);i++){\n        bb[i] = B[i];\n      }\n      for(i=(0);i<(N);i++){\n        pos[(typename cLtraits_try_make_unsigned<T1>::type)((typename cLtraits_try_make_unsigned<T1>::type)aa[i]-(typename cLtraits_try_make_unsigned<T1>::type)mn1)+1]++;\n      }\n      for(i=(1);i<(r1+2);i++){\n        pos[i] += pos[i-1];\n      }\n      for(i=(0);i<(N);i++){\n        k = pos[(typename cLtraits_try_make_unsigned<T1>::type)((typename cLtraits_try_make_unsigned<T1>::type)aa[i]-(typename cLtraits_try_make_unsigned<T1>::type)mn1)+0]++;\n        A[k] = aa[i];\n        B[k] = bb[i];\n      }\n      return;\n    }\n  }\n  s1 = s2 = 1;\n  while( s1 < 64 && r1 >= (1ULL<<s1) ){\n    s1++;\n  }\n  while( s2 < 64 && r2 >= (1ULL<<s2) ){\n    s2++;\n  }\n  if(s1 + s2 <= 32){\n    unsigned*tmp;\n    walloc1d(&tmp,N,&mem);\n    for(i=(0);i<(N);i++){\n      tmp[i] = (((unsigned)((int)A[i]-(int)mn1)) << s2) | ((unsigned)((int)B[i]-(int)mn2));\n    }\n    sortA_1_call_L(N, tmp, mem);\n    for(i=(0);i<(N);i++){\n      A[i] = ((int)(tmp[i] >> s2)) + ((int)mn1);\n      B[i] = ((int)(tmp[i] & ((1U<<s2)-1))) + ((int)mn2);\n    }\n    return;\n  }\n  if(s1 + s2 <= 64){\n    unsigned long long*tmp;\n    walloc1d(&tmp,N,&mem);\n    for(i=(0);i<(N);i++){\n      tmp[i] = (((unsigned long long)((long long)A[i]-(long long)mn1)) << s2) | ((unsigned long long)((long long)B[i]-(long long)mn2));\n    }\n    sortA_1_call_L(N, tmp, mem);\n    for(i=(0);i<(N);i++){\n      A[i] = ((long long)(tmp[i] >> s2)) + ((long long)mn1);\n      B[i] = ((long long)(tmp[i] & ((1ULL<<s2)-1))) + ((long long)mn2);\n    }\n    return;\n  }\n  sortI(N,A,B,mem);\n}\ntemplate<class T1, class T2> void sortA_2_nonint_L(int N, T1 A[], T2 B[], void *mem = wmem){\n  sortI(N,A,B,mem);\n}\ntemplate<class T1, class T2> void sortA_2_call_L(int N, T1 A[], T2 B[], void *mem = wmem){\n  sortA_2_nonint_L(N, A, B, mem);\n}\ntemplate<class T2> void sortA_2_call_L(int N, int A[], T2 B[], void *mem){\n  sortA_2_int_L(N, A, B, mem);\n}\ntemplate<class T2> void sortA_2_call_L(int N, unsigned A[], T2 B[], void *mem){\n  sortA_2_int_L(N, A, B, mem);\n}\ntemplate<class T2> void sortA_2_call_L(int N, long long A[], T2 B[], void *mem){\n  sortA_2_int_L(N, A, B, mem);\n}\ntemplate<class T2> void sortA_2_call_L(int N, unsigned long long A[], T2 B[], void *mem){\n  sortA_2_int_L(N, A, B, mem);\n}\ntemplate<class T2> void sortA_2_call_L(int N, char A[], T2 B[], void *mem){\n  sortA_2_int_L(N, A, B, mem);\n}\ntemplate<class T1, class T2> void sortA(int N, T1 a[], T2 b[], void *mem = wmem){\n  sortA_2_call_L(N, a, b, mem);\n}\ntemplate<class T1, class T2, class T3> void sortA(int N, T1 a[], T2 b[], T3 c[], void *mem = wmem){\n  int i;\n  pair<T1, pair<T2, T3> >*arr;\n  walloc1d(&arr, N, &mem);\n  for(i=(0);i<(N);i++){\n    arr[i].first = a[i];\n    arr[i].second.first = b[i];\n    arr[i].second.second = c[i];\n  }\n  sort(arr, arr+N);\n  for(i=(0);i<(N);i++){\n    a[i] = arr[i].first;\n    b[i] = arr[i].second.first;\n    c[i] = arr[i].second.second;\n  }\n}\ntemplate<class T1, class T2, class T3, class T4> void sortA(int N, T1 a[], T2 b[], T3 c[], T4 d[], void *mem = wmem){\n  int i;\n  pair<pair<T1, T2>, pair<T3, T4> >*arr;\n  walloc1d(&arr, N, &mem);\n  for(i=(0);i<(N);i++){\n    arr[i].first.first = a[i];\n    arr[i].first.second = b[i];\n    arr[i].second.first = c[i];\n    arr[i].second.second = d[i];\n  }\n  sort(arr, arr+N);\n  for(i=(0);i<(N);i++){\n    a[i] = arr[i].first.first;\n    b[i] = arr[i].first.second;\n    c[i] = arr[i].second.first;\n    d[i] = arr[i].second.second;\n  }\n}\ntemplate<class T> void Unique(int &N, T A[], int sorted=0, void *mwm = wmem){\n  int i;\n  int k;\n  if(!sorted){\n    sortA(N, A);\n  }\n  k = 0;\n  for(i=(0);i<(N);i++){\n    if(k==0 || A[k-1]!=A[i]){\n      A[k++] = A[i];\n    }\n  }\n  N = k;\n}\ntemplate<class T, class S> void Unique(int &N, T A[], S B[], int sorted=0, void *mem = wmem){\n  int i;\n  int k = 0;\n  if(!sorted){\n    sortA(N, A, B, mem);\n  }\n  for(i=(0);i<(N);i++){\n    if(!k || A[k-1]!=A[i]){\n      A[k] = A[i];\n      B[k] = B[i];\n      k++;\n    }\n    else{\n      B[k-1] += B[i];\n    }\n  }\n  N=k;\n}\ntemplate<class T, class S> inline int vec2arr(vector<T> &v, S arr[]){\n  int i;\n  int N = v.size();\n  for(i=(0);i<(N);i++){\n    arr[i] = v[i];\n  }\n  return N;\n}\ntemplate<class T, class S1, class S2> inline int vec2arr(vector<vector<T>> &v, S1 arr1[], S2 arr2[]){\n  int i;\n  int N = v.size();\n  for(i=(0);i<(N);i++){\n    arr1[i] = v[i][0];\n    arr2[i] = v[i][1];\n  }\n  return N;\n}\ntemplate<class T, class S1, class S2, class S3> inline int vec2arr(vector<vector<T>> &v, S1 arr1[], S2 arr2[], S3 arr3[]){\n  int i;\n  int N = v.size();\n  for(i=(0);i<(N);i++){\n    arr1[i] = v[i][0];\n    arr2[i] = v[i][1];\n    arr3[i] = v[i][2];\n  }\n  return N;\n}\n#define main dummy_main\nint main(){\n  wmem = memarr;\n  return 0;\n}\n#undef main\nclass Solution{\n  public:\n  int maxTotalReward(vector<int>& arr){\n    dummy_main();\n    static int N;\n    static int A[1000000];\n    const int L = 100000+10;\n    int i;\n    int j;\n    int k = 0;\n    int res = 0;\n    bitset<L> bs;\n    bitset<L> mask;\n    N = vec2arr(arr, A);\n    sortA(N,A);\n    Unique(N,A,1);\n    bs.set(0);\n    for(i=(0);i<(N);i++){\n      while(k < A[i]){\n        mask.set(k++);\n      }\n      bs |= ( (bs&mask) << A[i] );\n    }\n    for(i=(L)-1;i>=(0);i--){\n      if(bs[i]){\n        break;\n      }\n    }\n    return i;\n  }\n}\n;\n// cLay version 20240420-1\n\n// --- original code ---\n// #define main dummy_main\n// {}\n// #undef main\n// \n// class Solution {\n// public:\n//   int maxTotalReward(vector<int>& arr) {\n//     dummy_main();\n//     static int N, A[1d6];\n//     const int L = 1d5+10;\n//     int i, j, k = 0, res = 0;\n//     bitset<L> bs, mask;\n// \n//     N = vec2arr(arr, A);\n//     sortA(N,A);\n//     Unique(N,A,1);\n// \n//     bs.set(0);\n// \n//     rep(i,N){\n//       while(k < A[i]) mask.set(k++);\n//       bs |= ( (bs&mask) << A[i] );\n//     }\n// \n//     rrep(i,L) if(bs[i]) break;\n//     return i;\n//   }\n// };\n",
    "submit_ts": 1717901076.0
}