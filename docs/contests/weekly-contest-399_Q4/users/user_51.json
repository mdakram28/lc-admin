{
    "username": "stupidRR",
    "submission": "class Solution {\n    struct node\n    {\n        long long dp[4];\n    };\n     \n    struct Segment_Tree\n    {\n         vector<node> segtree;\n         int n;\n         node identity;\n     \n         void init(int _n)\n         {\n              for(int i=0;i<4;i++)\n                identity.dp[i]=0ll;\n     \n              n=1;\n              while(n<_n)\n                   n=n*2;\n              segtree.resize(2*n);\n         }\n     \n         node merge(node a,node b)\n         {\n                node ans;\n                for(int i=0;i<4;i++)\n                    ans.dp[i]=0ll;\n                for(int i=0;i<4;i++)\n                {\n                    for(int j=0;j<4;j++)\n                    {\n                        int left=i%2;\n                        int right=j/2;\n                        if(i/2 != j%2)\n                            ans.dp[left+right*2]=std::max(ans.dp[left+right*2],a.dp[i]+b.dp[j]);\n                    }\n                }                \n                return ans;\n         }\n     \n         void build(int curr,int left,int right,vector<int>&ar)\n         {\n     \n              if(right-left==1)\n              {\n                   if(left<ar.size())\n                   {\n                        segtree[curr]=identity;\n                        segtree[curr].dp[3]=ar[left];\n                   }\n                   else\n                   {\n                        segtree[curr]=identity;\n                   }\n                   return;\n              }\n     \n              int mid=(left+right)/2;\n              build(2*curr+1,left,mid,ar);\n              build(2*curr+2,mid,right,ar);\n     \n              segtree[curr]=merge(segtree[2*curr+1],segtree[2*curr+2]);\n          }\n     \n        node sum(int lq,int rq,int node,int left,int right)\n        {\n              if(lq>=right || rq<=left)\n                   return identity;\n              if(left>=lq && rq>=right)\n                   return segtree[node];\n     \n              int mid=(left+right)/2;\n              return merge(sum(lq,rq,2*node+1,left,mid),sum(lq,rq,2*node+2,mid,right));\n        }\n     \n        void update(int curr,int left,int right,int ind,int val)\n        {\n              if(right-left==1)\n              {\n                   segtree[curr]=identity;\n                   segtree[curr].dp[3]=val;\n                   return;\n              }\n     \n              int mid=(left+right)/2;\n              if(ind<mid)\n                    update(2*curr+1,left,mid,ind,val);\n              else\n                    update(2*curr+2,mid,right,ind,val);     \n              segtree[curr]=merge(segtree[2*curr+1],segtree[2*curr+2]);\n          }\n     \n    };\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        const int mod=1e9+7;\n        Segment_Tree st;\n        st.init(nums.size());\n        int sz=st.n;\n        st.build(0,0,sz,nums);\n        long long ans=0ll;\n        for(auto query : queries)\n        {\n            st.update(0,0,sz,query[0],query[1]);\n            node curr=st.segtree[0];\n            long long mx=*std::max_element(curr.dp,curr.dp+4);\n            ans=(ans+mx)%mod;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1716693396",
    "subm_id": "1268084990"
}