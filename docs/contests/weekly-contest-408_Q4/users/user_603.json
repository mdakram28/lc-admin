{
    "username": "putti_chethana",
    "submission": "import java.util.*;\n\nclass Solution {\n\n    public int performBFS(List<List<Integer>> adjList, int startNode, int endNode1, int endNode2, int totalNodes) {\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] visitedNodes = new boolean[totalNodes + 4];\n        queue.add(startNode);\n        visitedNodes[startNode] = true;\n        \n        while (!queue.isEmpty()) {\n            int currentNode = queue.poll();\n            for (int neighbor : adjList.get(currentNode)) {\n                if (!visitedNodes[neighbor]) {\n                    queue.add(neighbor);\n                    visitedNodes[neighbor] = true;\n                }\n            }\n        }\n        return visitedNodes[endNode1] || visitedNodes[endNode2] ? 1 : 0;\n    }\n\n    public boolean canReachCorner(int gridWidth, int gridHeight, int[][] obstacles) {\n        List<int[]> obstacleList = new ArrayList<>();\n        List<List<Integer>> adjacencyList = new ArrayList<>();\n        int numberOfObstacles = obstacles.length;\n        \n        for (int i = 0; i < numberOfObstacles + 4; ++i) {\n            adjacencyList.add(new ArrayList<>());\n        }\n        \n        for (int[] obstacle : obstacles) {\n            obstacleList.add(new int[]{obstacle[0], obstacle[1], obstacle[2]});\n        }\n        \n        for (int i = 0; i < numberOfObstacles; ++i) {\n            int obstacleX = obstacleList.get(i)[0];\n            int obstacleY = obstacleList.get(i)[1];\n            int radius = obstacleList.get(i)[2];\n            \n            if (obstacleX <= radius) {\n                adjacencyList.get(numberOfObstacles).add(i);\n                adjacencyList.get(i).add(numberOfObstacles);\n            }\n            if (gridWidth - obstacleX <= radius) {\n                adjacencyList.get(numberOfObstacles + 2).add(i);\n                adjacencyList.get(i).add(numberOfObstacles + 2);\n            }\n            if (obstacleY <= radius) {\n                adjacencyList.get(numberOfObstacles + 1).add(i);\n                adjacencyList.get(i).add(numberOfObstacles + 1);\n            }\n            if (gridHeight - obstacleY <= radius) {\n                adjacencyList.get(numberOfObstacles + 3).add(i);\n                adjacencyList.get(i).add(numberOfObstacles + 3);\n            }\n            for (int j = i + 1; j < numberOfObstacles; ++j) {\n                double distance = Math.sqrt(Math.pow(obstacleX - obstacleList.get(j)[0], 2) + Math.pow(obstacleY - obstacleList.get(j)[1], 2));\n                int combinedRadii = radius + obstacleList.get(j)[2];\n                if (combinedRadii >= distance) {\n                    adjacencyList.get(i).add(j);\n                    adjacencyList.get(j).add(i);\n                }\n            }\n        }\n        \n        int isPathBlocked = 0;\n        isPathBlocked = Math.max(isPathBlocked, performBFS(adjacencyList, numberOfObstacles, numberOfObstacles + 1, numberOfObstacles + 2, numberOfObstacles + 4)); // Check for bottom-left corner\n        isPathBlocked = Math.max(isPathBlocked, performBFS(adjacencyList, numberOfObstacles + 3, numberOfObstacles + 2, numberOfObstacles + 1, numberOfObstacles + 4)); // Check for top-right corner\n        \n        return isPathBlocked == 0;\n    }\n}\n",
    "submit_ts": "1722137414",
    "subm_id": "1335763075"
}