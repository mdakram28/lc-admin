{
    "username": "sharath101",
    "submission": "#define ll long long int\n\nstruct Node\n{\n    long long val;\n    Node(long long one = 0) : val(one) {}\n    void merge(ll &l, ll r){\n        l = (l + r); \n    }\n    Node lazylazyMerge(const Node &rhs){\n        Node a = *this;\n        //a.val=rhs.val; //range assign\n        a.val = rhs.val; //range add\n        return a;\n    }\n    Node seglazyMerge(const Node &rhs, const int &l, const int &r){\n        Node a = *this;\n        a.val = (r - l + 1) * rhs.val; //range add\n        //a.val = (r - l + 1) * rhs.val; //range assign\n        //a.val = rhs.val; //for max/min (range assign)\n        //a.val = a.val + rhs.val; //for max/min (range add) (minchange default query return)\n        return a;\n    }\n    Node segSegMerge(const Node &rhs){\n        Node a = *this;\n        merge(a.val , rhs.val);\n        return a;\n    }\n};\n\ntemplate <typename segNode>\nstruct SegmentTree\n{\n    vector<segNode> Seg, Lazy;\n    vector<segNode> Base;\n    vector<bool> isLazy;\n    int n;\n    SegmentTree(int _n = 2e5){\n        this->n = _n;\n        Seg.resize(4 * _n + 10);\n        Lazy.resize(4 * _n + 10);\n        isLazy.resize(4 * _n + 10);\n    }\n    void merge(segNode &curr, segNode &l, segNode &r){\n        curr = (l , r);\n    }\n    void propagate(int node, int L, int R){\n        if (isLazy[node]){\n            isLazy[node] = false;\n            Seg[node] = Seg[node].seglazyMerge(Lazy[node], L, R);\n            if (L != R){\n                Lazy[2 * node] = Lazy[2 * node].lazylazyMerge(Lazy[node]);\n                Lazy[2 * node + 1] = Lazy[2 * node + 1].lazylazyMerge(Lazy[node]);\n                isLazy[2 * node] = true;\n                isLazy[2 * node + 1] = true;\n            }\n            Lazy[node] = segNode();\n        }\n    }\n    void build(int node, int start, int end){\n        if (start == end){\n            Seg[node] = Base[start];\n            return;\n        }\n        int mid = (start + end) / 2;\n        build(2 * node, start, mid);\n        build(2 * node + 1, mid + 1, end);\n        Seg[node] = Seg[2 * node].segSegMerge(Seg[2 * node + 1]);\n    }\n    void build(vector<segNode> &Arr){\n        Base = Arr;\n        n = Arr.size();\n        Seg.resize(4 * n + 10);\n        Lazy.resize(4 * n + 10);\n        isLazy.resize(4 * n + 10);\n        build(1, 0, n - 1);\n    }\n    segNode Query(int node, int start, int end, int qstart, int qend){\n        propagate(node, start, end);\n        if (qend < start || qstart > end || start > end)\n            return segNode();\n        if (qstart <= start && end <= qend)\n            return Seg[node];\n        int mid = (start + end) / 2;\n        segNode l = Query(2 * node, start, mid, qstart, qend);\n        segNode r = Query(2 * node + 1, mid + 1, end, qstart, qend);\n        return l.segSegMerge(r);\n    }\n    segNode qQuery(int node, int start, int end, int pos){\n        propagate(node, start, end);\n        if (start == end)\n            return Seg[node];\n        int mid = (start + end) / 2;\n        if (pos <= mid)\n            return qQuery(2 * node, start, mid, pos);\n        return qQuery(2 * node + 1, mid + 1, end, pos);\n    }\n    void Update(int node, int start, int end, int qstart, int qend, segNode val){\n        propagate(node, start, end);\n        if (qend < start || qstart > end || start > end)\n            return;\n        if (qstart <= start && end <= qend)\n        {\n            isLazy[node] = true;\n            Lazy[node] = val;\n            propagate(node, start, end);\n            return;\n        }\n        int mid = (start + end) / 2;\n        Update(2 * node, start, mid, qstart, qend, val);\n        Update(2 * node + 1, mid + 1, end, qstart, qend, val);\n        Seg[node] = Seg[2 * node].segSegMerge(Seg[2 * node + 1]);\n    }\n    void pUpdate(int node, int start, int end, int pos, segNode val){\n        propagate(node, start, end);\n        if (start == end)\n        {\n            isLazy[node] = true;\n            Lazy[node] = val;\n            propagate(node, start, end);\n            return;\n        }\n        int mid = (start + end) / 2;\n        if (pos <= mid)\n            pUpdate(2 * node, start, mid, pos, val);\n        else\n            pUpdate(2 * node + 1, mid + 1, end, pos, val);\n        Seg[node] = Seg[2 * node].segSegMerge(Seg[2 * node + 1]);\n    }\n    segNode query(int pos){\n        return qQuery(1, 0, n - 1, pos);\n    }\n    segNode query(int left, int right){\n        return Query(1, 0, n - 1, left, right);\n    }\n    void update(int pos, segNode val){\n        pUpdate(1, 0, n - 1, pos, val);\n    }\n    void update(int start, int end, segNode val){\n        Update(1, 0, n - 1, start, end, val);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        int q = queries.size();\n        vector<int> ans, d(n+1, INT_MAX);\n        d[n] = 0;\n        vector<pair<pair<int, int>, int>> j;\n        for(int i=0;i<n;i++) {\n            j.push_back({{i, i+1}, -1});\n        }\n        sort(j.rbegin(), j.rend());\n        for(auto p: j) {\n            d[p.first.first] = min(d[p.first.first], d[p.first.second]+1);\n        }\n        j.clear();\n        for(int i=0;i<queries.size();i++) {\n            j.push_back({{queries[i][0], queries[i][1]}, i});\n        }\n        SegmentTree<Node> st(n);\n        st.update(0,n-1,1);\n        for(auto qr: j) {\n            int x = qr.first.first, y = qr.first.second;\n            st.update(x+1, y-1,0);\n            ans.push_back(st.query(0,n-1).val-1);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722742399",
    "subm_id": "1343768059"
}