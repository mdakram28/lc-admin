{
    "username": "zhiylu528",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        unordered_map<int, vector<int>> edgemap1;\n        for (vector<int>& e : edges1) {\n            edgemap1[e[0]].push_back(e[1]);\n            edgemap1[e[1]].push_back(e[0]);\n        }\n        unordered_map<int, vector<int>> edgemap2;\n        for (vector<int>& e : edges2) {\n            edgemap2[e[0]].push_back(e[1]);\n            edgemap2[e[1]].push_back(e[0]);\n        }\n        \n        pair<int, int> temp1 = dfs(edgemap1, 0);\n        pair<int, int> d1 = dfs(edgemap1, temp1.first);\n        \n        pair<int, int> temp2 = dfs(edgemap2, 0);\n        pair<int, int> d2 = dfs(edgemap2, temp2.first);\n        \n        int res = (d1.second + 1) / 2 + (d2.second + 1) / 2 + 1;\n        int maxd = max(d1.second, d2.second);\n        \n        return max(res, maxd);\n    }\n    \n    pair<int, int> dfs(unordered_map<int, vector<int>>& edges, int root) {\n        unordered_set<int> been;\n        \n        queue<pair<int, int>> q;\n        q.push({root, 0});\n        \n        int maxlen = 0;\n        int furthest = 0;\n        \n        while(q.size()) {\n            pair<int, int> curr = q.front(); q.pop();\n            \n            if (been.count(curr.first)) continue;\n            been.insert(curr.first);\n            \n            if (curr.second > maxlen) {\n                maxlen = curr.second;\n                furthest = curr.first;\n            }\n            \n            for (int next : edges[curr.first]) {\n                if (!been.count(next)) {\n                    q.push({next, curr.second + 1});\n                }\n            }\n        }\n        \n        return {furthest, maxlen};\n    }\n};",
    "submit_ts": "1719717857",
    "subm_id": "1304402494"
}