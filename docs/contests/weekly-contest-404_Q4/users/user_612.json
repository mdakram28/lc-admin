{
    "username": "peicd7699",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        self.prev_depth = 0\n        \n        \n        # return an arr s.t. arr[i] means the distance to the fartest value\n        def helper(edges):\n            \n            graph = collections.defaultdict(list)\n            for s,e in edges:\n                graph[s] += [e]\n                graph[e] += [s]\n                \n            n = len(edges)\n            res = [0]*(n+1)\n            \n            \n            self.prev_depth = 0 \n            # print(self.prev_depth)\n            def dfs(node, parent, depth):\n                \n                res[node] = max(res[node], depth + self.prev_depth)\n\n                curr = depth\n                for c in graph[node]:\n                    if c!=parent:\n                        dd = dfs(c, node, depth+1)\n                        curr = max(curr, dd)\n                        # print(node, res[node], dd, curr)\n                        res[node] = max(res[node], dd - depth)\n                self.prev_depth = max(self.prev_depth, depth)\n                return curr\n            \n            \n                        \n            \n            for v in graph.values():\n                v.sort()\n            self.prev_depth = 0\n            dfs(0, -1, 0)\n            \n            for v in graph.values():\n                v.sort(reverse=True)\n            self.prev_depth = 0\n            dfs(0, -1, 0)\n            # print(edges, res)\n            return res\n        \n        def helper2(edges):\n            \n            graph = collections.defaultdict(list)\n            for s,e in edges:\n                graph[s] += [e]\n                graph[e] += [s]\n                \n            n = len(edges)\n            res = [0]*(n+1)\n            \n            \n            self.prev_depth = 0 \n            # print(self.prev_depth)\n            def dfs(node, parent, depth):\n                \n                res[node] = max(res[node], depth + self.prev_depth)\n\n                curr = depth\n                pd = depth\n                for c in graph[node]:\n                    if c!=parent:\n                        dd = dfs(c, node, depth+1)\n                        curr = max(curr, dd)\n                        # print(node, res[node], dd, curr)\n                        res[node] = max(res[node], pd-depth + dd - depth, dd + self.prev_depth)\n                self.prev_depth = max(self.prev_depth, depth)\n                return curr\n            \n            \n                        \n            \n            for v in graph.values():\n                v.sort()\n            self.prev_depth = 0\n            dfs(0, -1, 0)\n            \n            for v in graph.values():\n                v.sort(reverse=True)\n            self.prev_depth = 0\n            dfs(0, -1, 0)\n            # print(edges, res)\n            return res\n        \n        \n        def depth(edges):\n            graph = collections.defaultdict(list)\n            for s,e in edges:\n                graph[s] += [e]\n                graph[e] += [s]\n                \n            bfs = [0]\n            seen = set(bfs)\n            d = 0\n            while bfs:\n                new_bfs = []\n                for v in bfs:\n                    for c in graph[v]:\n                        if c not in seen:\n                            seen.add(c)\n                            new_bfs += [c]\n                if not new_bfs:\n                    break\n                bfs = new_bfs\n                d += 1\n            \n            bfs = [bfs[-1]]\n            seen = set(bfs)\n            d = 0\n            while bfs:\n                new_bfs = []\n                for v in bfs:\n                    for c in graph[v]:\n                        if c not in seen:\n                            seen.add(c)\n                            new_bfs += [c]\n                if not new_bfs:\n                    break\n                bfs = new_bfs\n                d += 1\n            return d\n        \n        d1, d2 = depth(edges1), depth(edges2)\n        # print(depth(edges1), depth(edges2),(d1+1//2), (d2+1//2))\n        return max(d1,d2, (d1+1)//2 + 1 + (d2+1)//2)\n            \n                \n                ",
    "submit_ts": "1719718685",
    "subm_id": "1304423524"
}