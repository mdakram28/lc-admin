{
    "username": "PatternMaker",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        \n        # bfs for the diameter\n        \n        def bfs(graph, start, n):\n            visited = [False] * n\n            queue = deque()\n            queue.append(start)\n            d = 0\n            distance = dict()\n            while queue:\n                l = len(queue)\n                for i in range(l):\n                    curr = queue.popleft()\n                    visited[curr] = True\n                    distance[curr] = d\n                    for child in graph[curr]:\n                        if not visited[child]:\n                            queue.append(child)\n                            visited[child] = True\n                d += 1\n            return distance\n        \n        \n        def get_max(distance):\n            k = 0\n            d = -1\n            for key ,val in distance.items():\n                if val > d:\n                    d = val\n                    k = key\n            return k, d\n                \n        def diameter(edges):\n            n = len(edges) + 1\n            graph = defaultdict(list)\n            \n            for edge in edges:\n                start, end = edge\n                graph[start].append(end)\n                graph[end].append(start)\n            \n            dist = bfs(graph, 0, n)\n            \n            node, d = get_max(dist)\n            \n            dist = bfs(graph, node, n)\n            \n            node, d = get_max(dist)\n            \n            \n            return d\n            \n        \n        \n            \n            \n        \n        d1 = diameter(edges1)\n        d2 = diameter(edges2)\n        \n        # return d1\n        dx = max(d1,d2)\n        \n        return max((d1+1)//2 + (d2+1)//2 + 1, dx)\n                \n            \n            \n            \n        \n            ",
    "submit_ts": 1719719909.0
}