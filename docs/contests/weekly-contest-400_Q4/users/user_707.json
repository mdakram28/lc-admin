{
    "username": "sameershreyas13",
    "submission": "#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds; // find_by_order, order_of_key\n \n#define F first\n#define S second\n#define ll long long\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define ld long double\nll mod = 998244353;\n// class DisjointSet {\n//     vector<int> rank, parent, size; \n// public: \n//     DisjointSet(int n) {\n//         rank.resize(n+1, 0); \n//         parent.resize(n+1);\n//         size.resize(n+1); \n//         for(int i = 0;i<=n;i++) {\n//             parent[i] = i; \n//             size[i] = 1; \n//         }\n//     }\n \n//     int findUPar(int node) {\n//         if(node == parent[node])\n//             return node; \n//         return parent[node] = findUPar(parent[node]); \n//     }\n \n//     void unionByRank(int u, int v) {\n//         int ulp_u = findUPar(u); \n//         int ulp_v = findUPar(v); \n//         if(ulp_u == ulp_v) return; \n//         if(rank[ulp_u] < rank[ulp_v]) {\n//             parent[ulp_u] = ulp_v; \n//         }\n//         else if(rank[ulp_v] < rank[ulp_u]) {\n//             parent[ulp_v] = ulp_u; \n//         }\n//         else {\n//             parent[ulp_v] = ulp_u; \n//             rank[ulp_u]++; \n//         }\n//     }\n \n//     void unionBySize(int u, int v) {\n//         int ulp_u = findUPar(u); \n//         int ulp_v = findUPar(v); \n//         if(ulp_u == ulp_v) return; \n//         if(size[ulp_u] < size[ulp_v]) {\n//             parent[ulp_u] = ulp_v; \n//             size[ulp_v] += size[ulp_u]; \n//         }\n//         else {\n//             parent[ulp_v] = ulp_u;\n//             size[ulp_u] += size[ulp_v]; \n//         }\n//     }\n//     int getSize(int u){\n//         int par = findUPar(u);\n//         return size[par];\n//     }\n// }; \n\n \n// ll fact(ll n){\n//     if(n == 0 || n == 1)return 1;\n//     ll ans= 1;\n//     for(ll i = 2; i <= n; i++){\n//         ans = ((ans%mod) * (i%mod)) % mod;\n//     }\n//     return ans%mod;\n// }\n \n// ll Pow(ll n, ll k){\n//     ll ans = 1;\n//     while(k--){\n//         ans = ((ans%mod) * (n%mod))%mod;\n//     }\n//     return ans%mod;\n// }\n\n\n// ll add(ll x, ll y){\n//     return ((x + y) % MOD + MOD) % MOD;\n// }\n\n// ll mul(ll x, ll y){\n//     return x * 1ll * y % MOD;   \n// }\n\n// ll binpow(ll x, ll y){\n//     ll z = 1;\n//     while(y)\n//     {\n//         if(y % 2 == 1) z = mul(z, x);\n//         x = mul(x, x);\n//         y /= 2;\n//     }\n//     return z;\n// }\n\n// ll inv(ll x){\n//     return binpow(x, MOD - 2);    \n// }\n\n// ll divide(ll x, ll y){\n//     return mul(x, inv(y));\n// }\n\n\n// ll fact_mod(ll n){\n//     if(n == 0 || n == 1)return 1;\n//     ll ans= 1;\n//     for(ll i = 2; i <= n; i++){\n//         ans = mul(a, i);\n//     }\n//     return ans;\n// }\n\nclass Solution {\n    const static ll N = 100000;\nll arr[N + 1], seg[4 * (N + 1)];\n\nvoid build(ll ind, ll low, ll high) {\n    if (low == high) {\n        seg[ind] = arr[low];\n        return;\n    }\n    ll mid = (high - low) / 2 + low;\n    build(2 * ind + 1, low, mid);\n    build(2 * ind + 2, mid + 1, high);\n    seg[ind] = (seg[2 * ind + 1] & seg[2 * ind + 2]);\n}\n\nll query(ll ind, ll low, ll high, ll l, ll r) {\n    // If the current segment is completely within the range [l, r]\n    if (low >= l && high <= r) {\n        return seg[ind];\n    }\n    // If the current segment is completely outside the range [l, r]\n    if (high < l || low > r) {\n        return LLONG_MAX;\n    }\n    ll mid = (high - low) / 2 + low;\n    ll left = query(2 * ind + 1, low, mid, l, r);\n    ll right = query(2 * ind + 2, mid + 1, high, l, r);\n    return (left & right);\n}\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        for(ll i = 0; i < nums.size(); i++)arr[i+1] = nums[i];\n        \n        ll n = nums.size();\n        // for(ll i = 1; i <= n; i++)cout << arr[i] << \" \";\n        \n        build(1, 1, n);\n        // cout << query(1, 1, n, 3, 4) << endl;\n        ll si = -1, temp = (LLONG_MAX), ans = (LLONG_MAX);\n        for(ll i = 1; i <= nums.size(); i++){\n            temp &= arr[i];\n            if(si == -1)si = i;\n            while(temp < k && si < i){\n                ans = min(ans, abs(k-temp));\n                temp = query(1, 1, n, si+1, i);\n                ans = min(ans, abs(k-temp));\n                si++;\n            }\n            ans = min(ans, abs(k-temp));\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1717299699.0
}