{
    "username": "Sakura",
    "submission": "class Solution {\n public long[] countKConstraintSubstrings(String s, int k, int[][] queries) {\n        char arr[] = s.toCharArray();\n        int n = s.length();\n        PriorityQueue<int[]> q = new PriorityQueue<>((a, b)->a[0] - b[0]);\n        int m = queries.length;\n        for(int i = 0; i < m; ++i) {\n            q.offer(new int[]{queries[i][0], queries[i][1], i});\n        }\n        long ans[] = new long[m];\n        int dp[] = new int[n];\n        int dp1[] = new int[n];\n        int ll = 0;\n        int cnt = 0;\n        for(int i = 0; i < n; ++i) {\n            cnt += arr[i] - '0';\n            while(cnt > k && i - ll + 1 - cnt > k) {\n                cnt -= arr[ll++] - '0';\n            }\n            dp[i] = i - ll + 1;\n            //l - i\n        }\n        int rr = n - 1;\n        cnt = 0;\n        for(int i = n - 1; i >= 0; --i) {\n            cnt += arr[i] - '0';\n            while(cnt > k && rr - i + 1 - cnt > k) {\n                cnt -= arr[rr--] - '0';\n            }\n            dp1[i] = rr - i + 1;\n            //l - i\n        }\n        lazyTrie tree = new lazyTrie(dp);\n        for(int i = 0; i < n; ++i) {\n            while(!q.isEmpty() && q.peek()[0] == i) {\n                int x[] = q.poll();\n                int l = x[0], r = x[1], t = x[2];\n                ans[t] = tree.queryRange(1, 1, n, l + 1, r + 1);\n            }\n            tree.updateRange(1, 1, n, i + 1, dp1[i] + i, -1);\n        }\n        return ans;\n    }\n    public class lazyTrie {\n        public int n;//\u533a\u95f4\u7aef\u70b9\u4e2a\u6570\n        public long cnt[];//\u4fdd\u5b58\u7ed3\u70b9\u5bf9\u5e94\u533a\u95f4\u7684\u503c(\u6700\u5927\u503c,\u548c...)\n        public long lazy[];//\u61d2\u6807\u8bb0\n        public int nums[];\n        public lazyTrie(int nums[]){\n            this.n = nums.length;\n            this.nums = nums;\n            cnt = new long[4 * n];\n            lazy = new long[4 * n];\n            build(1, 1, n);\n        }\n        //\u5efa\u6811\n        public void build(int o, int l, int r) {\n            if(l == r) {\n                cnt[o] = nums[l - 1];\n                return;\n            }\n            int mid = (l + r) / 2;\n            build(2 * o, l, mid);\n            build(2 * o + 1, mid + 1, r);\n            mantain(o);\n        }\n\n        //\u533a\u95f4\u7ef4\u62a4\n        public void mantain(int o) {\n            cnt[o] = cnt[2 * o] + cnt[2 * o + 1];\n        }\n\n        public void todo(int o, int l, int r, long val) {\n            lazy[o] += val;\n            cnt[o] += (long)(r - l + 1) * val;\n        }\n\n        //\u533a\u95f4\u66f4\u65b0\n        public void updateRange(int o, int l, int r, int L, int R, int val) {\n            if(l >= L && r <= R) {\n                todo(o, l, r, val);\n                return;\n            }\n            int mid = (l + r) >> 1;\n            if(lazy[o] != 0) {\n                todo(2 * o, l, mid, lazy[o]);\n                todo(2 * o + 1, mid + 1, r, lazy[o]);\n                lazy[o] = 0;\n            }\n            if(mid >= L) {\n                updateRange(2 * o, l, mid, L, R, val);\n            }\n            if(mid < R) {\n                updateRange(2 * o + 1, mid + 1, r, L, R, val);\n            }\n            mantain(o);\n        }\n\n        //\u533a\u95f4\u67e5\u8be2\n        public long queryRange(int o, int l, int r, int L, int R) {\n            if(l >= L && r <= R) {\n                return cnt[o];\n            }\n            int mid = (l + r) >> 1;\n            if(lazy[o] != 0) {\n                todo(2 * o, l, mid, lazy[o]);\n                todo(2 * o + 1, mid + 1, r, lazy[o]);\n                lazy[o] = 0;\n            }\n            long ans = 0;\n            if(mid >= L) {\n                ans += queryRange(2 * o, l, mid, L, R);\n            }\n            if(mid < R) {\n                ans += queryRange(2 * o + 1, mid + 1, r, L, R);\n            }\n            mantain(o);\n            return ans;\n        }\n\n        //\u5355\u70b9\u66f4\u65b0\n        public void updateSingle(int o, int l, int r, int i, int val) {\n            if(l == r) {\n                cnt[o] = val;\n                return;\n            }\n            int mid = (l + r) >> 1;\n            if(lazy[o] != 0) {\n                todo(2 * o, l, mid, lazy[o]);\n                todo(2 * o + 1, mid + 1, r, lazy[o]);\n                lazy[o] = 0;\n            }\n            if(mid >= i) {\n                updateSingle(2 * o, l, mid, i, val);\n            }\n            if(mid < i) {\n                updateSingle(2 * o + 1, mid + 1, r, i, val);\n            }\n            mantain(o);\n        }\n\n        //\u5355\u70b9\u67e5\u8be2\n        public long querySingle(int o, int l, int r, int i) {\n            if (l == r) {\n                return cnt[o];\n            }\n            int mid = (l + r) >> 1;\n            if(lazy[o] != 0) {\n                todo(2 * o, l, mid, lazy[o]);\n                todo(2 * o + 1, mid + 1, r, lazy[o]);\n                lazy[o] = 0;\n            }\n            long ans = 0;\n            if (mid >= i) {\n                ans += querySingle(2 * o, l, mid, i);\n            }\n            if (mid < i) {\n                ans += querySingle(2 * o + 1, mid + 1, r, i);\n            }\n            mantain(o);\n            return ans;\n        }\n    }\n}",
    "submit_ts": "1723952107",
    "subm_id": "556409633"
}