{
    "username": "lympanda",
    "submission": "#define lim 200\n#define _int64 long long\n\nstd::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());\n_int64 mo = rng() % 1000000000 + 123456;\n\n_int64 pow1(int x,int y)\n{\n\tint i;\n\t_int64 ret;\n\tret=1;\n\tfor (i=30;i>=0;i--)\n\t{\n\t\tret=ret*ret%mo;\n\t\tif (((1<<i)&y)!=0) ret=ret*x%mo;\n\t}\n\treturn ret;\n}\n\n_int64 h[51000];\n_int64 d[51000];\nvector<pair<int,vector<int> > > tr;\n\nvoid add1(string s,int v)\n{\n    int i,x,p;\n    p=0;\n    for (i=0;i<s.length();i++)\n    {\n        x=s[i]-'a';\n        if (tr[p].second[x]==-1)\n        {\n            tr[p].second[x]=tr.size();\n            tr.push_back(make_pair((1<<30),vector<int>(26,-1)));\n        }\n        p=tr[p].second[x];\n        \n    }\n    tr[p].first=min(tr[p].first,v);\n}\n\n_int64 geth(int x,int y)\n{\n    _int64 ans;\n    ans=h[x+y];\n    ans-=h[x]*pow1(27,y);\n    ans%=mo;\n    if (ans<0) ans+=mo;\n    return ans;\n}\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int i,j,k,n,p,x;\n        _int64 tmp;\n        vector<pair<_int64,pair<_int64,_int64> > > aa;\n        n=target.length();\n        h[0]=0;\n        for (i=0;i<n;i++)\n        {\n            h[i+1]=h[i]*27+target[i]-'a'+1;\n            h[i+1]%=mo;\n        }\n        tr.clear();\n        tr.push_back(make_pair((1<<30),vector<int>(26,-1)));\n        aa.clear();\n        for (i=0;i<words.size();i++)\n        {\n            if (words[i].length()>lim)\n            {\n                tmp=0;\n                for (j=0;j<words[i].length();j++)\n                {\n                    tmp*=27;\n                    tmp+=words[i][j]-'a'+1;\n                    tmp%=mo;\n                }\n                aa.push_back(make_pair(words[i].length(),make_pair(tmp,costs[i])));\n            }\n            else\n                add1(words[i],costs[i]);\n        }\n        for (i=0;i<=n;i++)\n            d[i]=(1LL<<60);\n        d[0]=0;\n        for (i=0;i<n;i++)\n        {\n            if (d[i]==(1LL<<60)) continue;\n            for (j=0;j<aa.size();j++)\n            {\n                if ((i+aa[j].first<=n)&&(geth(i,aa[j].first)==aa[j].second.first))\n                {\n                    d[i+aa[j].first]=min(d[i+aa[j].first],d[i]+aa[j].second.second);\n                }\n            }\n            p=0;\n            for (j=i;j<n;j++)\n            {\n                x=target[j]-'a';\n                if (tr[p].second[x]==-1) break;\n                p=tr[p].second[x];\n                if (tr[p].first!=(1<<30))\n                {\n                    d[j+1]=min(d[j+1],d[i]+tr[p].first);\n                }\n            }\n        }\n        if (d[n]==(1LL<<60)) return -1;\n        else return d[n];\n    }\n};",
    "submit_ts": "1720320922",
    "subm_id": "1312308398"
}