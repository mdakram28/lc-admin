{
    "username": "DarkDuel012",
    "submission": "#include<iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double  dbl;\n#define minPq  priority_queue <ll, vector<ll>, greater<ll>> ;\n\nclass Solution {\npublic:\n    void buildSegTree(vector<ll>&vc,vector<ll>&sg,int st,int en,int node)\n{\n    //base case\n    if(st==en)\n    {\n        sg[node]=vc[st];\n        return;\n    }\n    //cal\n    ll mid=(st+en)/2;\n    //call on left\n    buildSegTree(vc,sg,st,mid,2*node);\n    //call on right\n    buildSegTree(vc,sg,mid+1,en,2*node+1);\n    sg[node]=max(sg[node*2],sg[node*2+1]);\n}\nvoid updateTree(vector<ll>&sg,ll st,ll en,ll node,ll val,ll index)\n{\n    //base case\n    if(st==en)\n    {\n        sg[node]=val;\n        return;\n    }\n    //cal\n    ll mid=(st+en)/2;\n    if(index<=mid)\n    {\n        //left part calling\n        updateTree(sg,st,mid,2*node,val,index);\n    }\n    else\n    updateTree(sg,mid+1,en,2*node+1,val,index); //calling on right part\n    sg[node]=max(sg[2*node],sg[2*node+1]);\n    \n}\nll queryAns(vector<ll>&seg,ll st,ll en,ll qs,ll qe,ll node)\n{\n    if(st>qe || en<qs)\n    return 0;\n    if(st==en)\n    return seg[node];\n    if(qs<=st && qe>=en)        \n    return seg[node];\n    ll mid=(st+en)/2;\n    ll ans1=queryAns(seg,st,mid,qs,qe,2*node);\n    ll ans2=queryAns(seg,mid+1,en,qs,qe,2*node+1);\n    return max(ans1,ans2);\n\n}\n    vector<bool> getResults(vector<vector<int>>& q) {\n        \n\n\n        //building segment tree\n        vector<ll>vc(6e4);\n        vc[0]=INT_MAX;\n        vector<ll>sg(4*vc.size()+1);\n        buildSegTree(vc,sg,0,vc.size()-1,1); //always use 4n space for segment tree for smooth functioning ,1 based segment tree\n        // updateTree(sg,0,vc.size()-1,1,10,2);\n        vector<bool>fans;\n        map<ll,ll>crnt;crnt[0]=INT_MAX;\n        crnt[INT_MAX]=0;\n        for(ll i=0;i<q.size();i++)\n        {\n            if(q[i].size()==2)//have to make few updates\n            {\n                ll x=q[i][1];\n                auto it=crnt.upper_bound(x);\n               vc[x]=it->first-x; updateTree(sg,0,vc.size()-1,1,it->first-x,x);//fill value\n               it--;\n               vc[it->first]=x-it->first; updateTree(sg,0,vc.size()-1,1,x-it->first,it->first);//fill value\n               //updating crnt\n               crnt[it->first]=vc[it->first];\n               crnt[x]=vc[x];\n\n            }\n            else\n            {\n                ll x=q[i][1];\n                ll siz=q[i][2];\n                auto ito=crnt.lower_bound(x);\n                bool changed=0;ll prev=vc[x];\n                if(ito->first!=x)\n                {\n                    changed=1;\n                    ito--;\n                    prev=vc[ito->first];\n                    updateTree(sg,0,vc.size()-1,1,x-ito->first,ito->first);\n\n                }\n\n                ll temp=queryAns(sg,0,vc.size()-1,0,x-1,1);\n                // cout<<\"temp \"<<temp<<endl;\n                if(temp>=siz)fans.push_back(1);\n                else fans.push_back(0);\n\n                if(changed)\n                {\n                    //reverr changes\n                    updateTree(sg,0,vc.size()-1,1,prev,ito->first);\n\n                }\n            }\n        }\n        return fans;\n    }\n};",
    "submit_ts": 1716652140.0
}