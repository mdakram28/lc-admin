{
    "username": "ak_ashu9",
    "submission": "class Solution {\npublic:\n\n    void dfs(vector<int> adj[], int node, int height, vector<bool> &visited, int &farthestNode, int &maxHeight) {\n        visited[node] = true;\n        if (height>maxHeight) {\n            maxHeight = height;\n            farthestNode = node;\n        }\n\n        for (int i=0; i<adj[node].size(); i++) {\n            int neighbor = adj[node][i];\n            if (!visited[neighbor]) {\n                dfs(adj,neighbor,height+1,visited,farthestNode,maxHeight);\n            }\n        }\n    }\n\n    int treeDiameter(vector<int> adj[], int n) {\n        vector<bool> visited(n,false);\n        int farthestNode = 0;\n        int maxHeight = 0;\n        \n        dfs(adj,0,0,visited,farthestNode,maxHeight);\n        \n        for (int i=0; i<n; i++) {\n            visited[i] = false;\n        }\n        maxHeight = 0;\n        dfs(adj,farthestNode,0,visited,farthestNode,maxHeight);\n\n        return maxHeight;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n1 = edges1.size()+1;\n        int n2 = edges2.size()+1;\n\n        vector<int> adj1[n1];\n        for (int i=0; i<edges1.size(); i++) {\n            adj1[edges1[i][0]].push_back(edges1[i][1]);\n            adj1[edges1[i][1]].push_back(edges1[i][0]);\n        }\n\n        vector<int> adj2[n2];\n        for (int i=0; i<edges2.size(); i++) {\n            adj2[edges2[i][0]].push_back(edges2[i][1]);\n            adj2[edges2[i][1]].push_back(edges2[i][0]);\n        }\n\n        int dia1 = treeDiameter(adj1, n1);\n        int dia2 = treeDiameter(adj2, n2);\n\n        return max(dia1, max(dia2, (dia1+1)/2 + (dia2+1)/2 + 1));\n    }\n};",
    "submit_ts": 1719718660.0
}