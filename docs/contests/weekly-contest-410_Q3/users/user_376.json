{
    "username": "shik",
    "submission": "// {{{ ModInt\ntemplate<int _MOD>\nstruct ModInt {\n    static const auto MOD = _MOD;\n    template<class T> using integral_only = typename enable_if<is_integral<T>::value>::type;\n\n    int x;\n    constexpr ModInt() : x() {}\n    template<class T, integral_only<T>* = nullptr>\n    ModInt(T _x) {\n        x = _x % MOD;\n        if (x < 0) x += MOD;\n    }\n    ModInt operator-() const { return {x == 0 ? 0 : MOD-x}; }\n    ModInt& operator+=(ModInt rhs) {\n        x += rhs.x;\n        if (x >= MOD) x -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt rhs) {\n        x -= rhs.x;\n        if (x < 0) x += MOD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt rhs) {\n        x = (long long)x * rhs.x % MOD;\n        return *this;\n    }\n    ModInt& operator/=(ModInt rhs) {\n        return *this *= rhs.inv();\n    }\n    ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n    ModInt inv() const {\n        // should work for non-prime MOD if gcd(x, MOD) = 1\n        int a = x, b = MOD, u = 1, v = 0;\n        while (b != 0) {\n            int t = a / b;\n            a -= t * b;\n            u -= t * v;\n            swap(a, b);\n            swap(u, v);\n        }\n        return u;\n    }\n    template<class T, integral_only<T>* = nullptr>\n    ModInt pow(T e) {\n        ModInt r = 1, p = *this;\n        while (e) {\n            if (e & 1) r *= p;\n            p *= p;\n            e >>= 1;\n        }\n        return r;\n    }\n    bool operator==(ModInt rhs) const { return x == rhs.x; }\n    bool operator!=(ModInt rhs) const { return x != rhs.x; }\n    bool operator<(ModInt rhs) const { return x < rhs.x; }\n    bool operator<=(ModInt rhs) const { return x <= rhs.x; }\n    bool operator>(ModInt rhs) const { return x > rhs.x; }\n    bool operator>=(ModInt rhs) const { return x >= rhs.x; }\n    friend string to_string(ModInt i) { return to_string(i.x); }\n    friend ostream& operator<<(ostream &os, ModInt i) { return os << i.x; }\n};\n// }}}\n\nusing mint = ModInt<1000000007>;\n\nconst int N = 51;\nclass Solution {\n public:\n  mint dp[2][N][N];\n  int countOfPairs(vector<int>& nums) {\n    int n = nums.size();\n    dp[0][0][N - 1] = 1;\n    for (int ii = 0; ii < n; ii++) {\n      int i = ii & 1;\n      int ni = i ^ 1;\n      memset(dp[ni], 0, sizeof(dp[ni]));\n      for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++) {\n          auto me = dp[i][x][y];\n          if (me == 0) continue;\n          // printf(\"%d %d %d: %d\\n\", ii, x, y, me.x);\n          for (int z = 0; z <= nums[ii]; z++) {\n            // printf(\"-> %d %d %d\\n\", ii + 1, z, nums[i] - z);\n            if (z >= x && nums[ii] - z <= y) {\n              // printf(\"-> %d %d %d\\n\", ii + 1, z, nums[i] - z);\n              dp[ni][z][nums[ii] - z] += me;\n            }\n          }\n        }\n      }\n    }\n    mint ans = 0;\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        ans += dp[n & 1][i][j];\n      }\n    }\n    printf(\"%d\\n\", ans.x);\n    return ans.x;\n  }\n};\n",
    "submit_ts": "1723344844",
    "subm_id": "1351543234"
}