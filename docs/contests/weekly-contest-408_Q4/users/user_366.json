{
    "username": "jayant_dhidhi",
    "submission": "class Solution\n{\npublic:\n    std::vector<int> initializeVisited(int nodes)\n    {\n        return std::vector<int>(nodes + 4, 0);\n    }\n    void enqueueNode(std::queue<int> &q, std::vector<int> &visited, int node)\n    {\n        if (!visited[node])\n        {\n            q.push(node);\n            visited[node] = 1;\n        }\n    }\n\n    void processNode(std::queue<int> &q, std::vector<int> &visited, const std::vector<std::vector<int>> &graph, int current)\n    {\n        for (int neighbor : graph[current])\n        {\n            enqueueNode(q, visited, neighbor);\n        }\n    }\n\n    void traverseGraph(std::queue<int> &q, std::vector<int> &visited, const std::vector<std::vector<int>> &graph)\n    {\n        while (!q.empty())\n        {\n            int current = q.front();\n            q.pop();\n            processNode(q, visited, graph, current);\n        }\n    }\n\n    int bfs(const std::vector<std::vector<int>> &graph, int start, int target1, int target2, int nodes)\n    {\n        std::queue<int> q;\n        std::vector<int> visited = initializeVisited(nodes);\n        enqueueNode(q, visited, start);\n        traverseGraph(q, visited, graph);\n\n        return visited[target1] || visited[target2];\n    }\n\n    bool canReachCorner(int X, int Y, std::vector<std::vector<int>> &circles2)\n    {\n        std::vector<std::pair<std::pair<int, int>, int>> circles(circles2.size());\n        std::vector<std::vector<int>> graph(circles2.size() + 4);\n        int num_circles = circles2.size();\n\n        int rick = 0;\n        do\n        {\n            circles[rick].first.first = circles2[rick][0];\n            circles[rick].first.second = circles2[rick][1];\n            circles[rick].second = circles2[rick][2];\n            ++rick;\n        } while (rick < num_circles);\n\n        for (int rick = 0; rick < num_circles; ++rick)\n        {\n            if (circles[rick].first.first <= circles[rick].second)\n            {\n                graph[num_circles].push_back(rick);\n                graph[rick].push_back(num_circles);\n            }\n            if (X - circles[rick].first.first <= circles[rick].second)\n            {\n                graph[num_circles + 2].push_back(rick);\n                graph[rick].push_back(num_circles + 2);\n            }\n            if (circles[rick].first.second <= circles[rick].second)\n            {\n                graph[num_circles + 1].push_back(rick);\n                graph[rick].push_back(num_circles + 1);\n            }\n            if (Y - circles[rick].first.second <= circles[rick].second)\n            {\n                graph[num_circles + 3].push_back(rick);\n                graph[rick].push_back(num_circles + 3);\n            }\n            int morty = rick + 1;\n            do\n            {\n                if (morty < num_circles)\n                {\n                    double distance = std::sqrt(std::pow(circles[rick].first.first - circles[morty].first.first, 2) +\n                                                std::pow(circles[rick].first.second - circles[morty].first.second, 2));\n                    int radius_sum = circles[rick].second + circles[morty].second;\n                    if (radius_sum >= distance)\n                    {\n                        graph[rick].push_back(morty);\n                        graph[morty].push_back(rick);\n                    }\n                }\n                ++morty;\n            } while (morty < num_circles);\n        }\n\n        int is_blocked = 0;\n        is_blocked = std::max(is_blocked, bfs(graph, num_circles, num_circles + 1, num_circles + 2, num_circles + 4));     // Check for bottom-left corner\n        is_blocked = std::max(is_blocked, bfs(graph, num_circles + 3, num_circles + 2, num_circles + 1, num_circles + 4)); // Check for top-right corner\n\n        switch (is_blocked)\n        {\n        case 0:\n            return true;\n        default:\n            return false;\n        }\n    }\n};",
    "submit_ts": "1722137179",
    "subm_id": "1335756430"
}