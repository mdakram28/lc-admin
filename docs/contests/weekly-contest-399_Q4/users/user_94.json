{
    "username": "power1011",
    "submission": "using i64 = std::int64_t;\nstruct ele_t\n{\n    i64 mx[2][2];\n};\nconstexpr i64 ninf = -0x1fff'ffff'ffff'ffff;\nstruct tree_t\n{\n    int nn;\n    std::vector<ele_t> space;\n    tree_t(int n): space(4*n + 1), nn(n) {\n        for(;;)\n        {\n            auto low_bit = nn & -nn;\n            if(low_bit == nn)\n            {\n                break;\n            }\n            nn += low_bit;\n        }\n    }\n    void modify(int index, int sl, int sr, int q, int qv)\n    {\n        auto &v = space.at(index);\n        if(sl+1 == sr)\n        {\n            v.mx[0][0] = 0;\n            v.mx[0][1] = ninf;\n            v.mx[1][0] = ninf;\n            v.mx[1][1] = qv;\n            return;\n        }\n        int m = (sl+sr) / 2;\n        if(q < m)\n        {\n            modify(index * 2, sl, m, q, qv);\n        }\n        else\n        {\n            modify(index * 2 + 1, m, sr, q, qv);\n        }\n        auto &l = space.at(index * 2);\n        auto &r = space.at(index * 2 + 1);\n        for(int lb:{0,1})\n        {\n            for(int rb:{0,1})\n            {\n                auto ans = ninf;\n                ans = std::max(ans, l.mx[lb][1] + r.mx[0][rb]);\n                ans = std::max(ans, l.mx[lb][0] + r.mx[1][rb]);\n                ans = std::max(ans, l.mx[lb][0] + r.mx[0][rb]);\n                v.mx[lb][rb] = ans;\n            }\n        }\n    }\n    auto query() const\n    {\n        auto &v = space.at(1);\n        auto ans = ninf;\n        ans = std::max(ans, v.mx[0][0]);\n        ans = std::max(ans, v.mx[0][1]);\n        ans = std::max(ans, v.mx[1][0]);\n        ans = std::max(ans, v.mx[1][1]);\n        return ans;\n    }\n};\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        /*\n        [] []\n        maximum subseq sum [contains left:0,1][contain right:0,1]\n        \n        mx[0][0] = max l.mx[0][1] + r.mx[0][0]\n                       l.mx[0][0] + r.mx[1][0]\n                       l.mx[0][0] + r.mx[0][0]\n        \n        mx[0][1] = max l.mx[0][1] + r.mx[0][1]\n                       l.mx[0][0] + r.mx[1][1]\n                       l.mx[0][0] + r.mx[0][1]\n        if length == 1:\n          mx[0][0] = 0\n          mx[0][1] = -inf\n          mx[1][0] = -inf\n          mx[1][1] = val\n        */\n        const auto n = nums.size();\n        tree_t tree(n);\n        for(size_t i=0;i<n;++i)\n        {\n            tree.modify(1, 0, tree.nn, i, nums[i]);\n        }\n        for(size_t i=n;i<tree.nn;++i)\n        {\n            tree.modify(1, 0, tree.nn, i, 0);\n        }\n        i64 ans = 0;\n        constexpr i64 mod = 1'000'000'000 + 7;\n        for(auto &q:queries)\n        {\n            auto pos = q.at(0);\n            auto x = q.at(1);\n            tree.modify(1, 0, tree.nn, pos, x);\n            ans += (mod + tree.query() % mod); //[0, 2*mod)\n        }\n        ans %= mod;\n        return ans;\n    }\n};",
    "submit_ts": 1716694549.0
}