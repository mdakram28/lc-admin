{
    "username": "user9218i",
    "submission": "class Solution {\npublic:\n    \n    int treeDiameter(vector<vector<int>>& edges) {\n        if(edges.size() == 0)   return 0;\n        const int n = edges.size();\n        int ans = 0;\n        vector<vector<int>> tree(n + 1);\n\n        for (const vector<int>& edge : edges) {\n          const int u = edge[0];\n          const int v = edge[1];\n          tree[u].push_back(v);\n          tree[v].push_back(u);\n        }\n\n        maxDepth(tree, 0, -1, ans);\n        return ans;\n      }\n\n      int maxDepth(const vector<vector<int>>& tree, int u, int parent, int& ans) {\n        int maxDepth1 = 0;   // the maximum depth\n        int maxDepth2 = -1;  // the second maximum depth\n\n        for (const int v : tree[u]) {\n          if (v == parent)\n            continue;\n          const int depth = maxDepth(tree, v, u, ans);\n          if (depth > maxDepth1) {\n            maxDepth2 = maxDepth1;\n            maxDepth1 = depth;\n          } else if (depth > maxDepth2) {\n            maxDepth2 = depth;\n          }\n        }\n\n        ans = max(ans, maxDepth1 + maxDepth2);\n        return 1 + maxDepth1;\n      }\n    \n    int f(int n, vector<vector<int>>& edges) {\n        if(edges.size() == 0)   return 0;\n        if(edges.size() == 0) {\n            return 1;\n        }\n        vector<int> v[n];\n        vector<int> deg(n, 0);\n        vector<int> ans;\n        \n        //cout << n << endl;\n        for(auto it: edges) {\n            int l = it[0], r = it[1];\n            //cout << l << \" \"<< r << endl;\n            v[l].push_back(r);\n            v[r].push_back(l);\n            deg[l] ++, deg[r] ++;\n        }\n        queue<int> q;\n        for(int i = 0; i < n; i++) {\n            if(deg[i] == 1)     q.push(i);\n        }\n        while(n > 2) {\n            int sz = q.size();\n            n -= q.size();\n            while(sz -- ) {\n                int num = q.front();\n                for(auto it : v[num]) {\n                    if(deg[it] == 1)    continue;\n                    deg[it] --;\n                    if(deg[it] == 1)    q.push(it);\n                }\n                q.pop();\n            }\n        }\n        \n        return q.front();\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        if(edges1.size() == 0 and edges2.size() == 0)   return 1;\n        int r1 = f(1 + edges1.size(), edges1);\n        int r2 = f(1 + edges2.size(), edges2);\n        \n        vector<vector<int>> v;\n        //vector<vector<int>> v(edges1.size() + edges2.size() + 2, vector<int> ());\n        //vector<int> v[edges1.size() + edges2.size() + 2];\n        for(auto it : edges1) {\n            int l = it[0], r = it[1];\n            v.push_back({l, r});\n            // cout << l << \" \"<< r << endl;\n            // v[l].push_back(r);\n            // v[r].push_back(l);\n        }\n        int add = 1 + edges1.size();\n        for(auto it : edges2) {\n            int l = add + it[0], r = add + it[1];\n            v.push_back({l, r});\n            // cout << l << \" \"<< r << endl;\n            // v[l].push_back(r);\n            // v[r].push_back(l);\n        }\n        \n        //cout << r1 << \" \"<< r2 + add << endl;\n        v.push_back({r1, r2 + add});\n        // v[r1].push_back(add + r2);\n        // v[r2 + add].push_back(r1);\n        return treeDiameter(v);\n    }\n};\n/*\n[[0,1],[2,0],[3,2],[3,6],[8,7],[4,8],[5,4],[3,5],[3,9]]\n[[0,1],[0,2],[0,3]]\n7\n*/",
    "submit_ts": 1719719160.0
}