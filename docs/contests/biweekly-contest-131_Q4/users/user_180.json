{
    "username": "ThuPngm",
    "submission": "#define ll long long\n\nclass Solution {\npublic:\n    vector<ll> segtree;\n\n    void update(int l, int r, int index, int pos, ll val) {\n        if (l == r) {\n            segtree[index] = val;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (pos <= mid) update(l, mid, 2 * index + 1, pos, val);\n        else update(mid + 1, r, 2 * index + 2, pos, val);\n        segtree[index] = max(segtree[2 * index + 1], segtree[2 * index + 2]);\n    }\n\n    int queryX(int l, int r, int from, int to, int index) {\n        if (from <= l && r <= to)\n            return segtree[index];\n        if (r < from || to < l)\n            return 0;  //Modify this\n        int mid = (l + r) / 2;\n        return max(queryX(l, mid, from, to, 2 * index + 1), queryX(mid + 1, r, from, to, 2 * index + 2));\n    }\n\n    \n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int MAX = min(50000, 3 * (int)queries.size()) + 5;\n        segtree = vector<ll>(4 * MAX);\n        set<int> obstables;\n        obstables.insert(0);\n        obstables.insert(MAX);\n        vector<bool> res;\n        for (auto query: queries) {\n            int q = query[0], x = query[1];\n            auto it = obstables.lower_bound(x);\n            int r = *it;\n            it--;\n            int l = *it;\n            if (q == 1) {\n                update(0, MAX - 1, 0, x, x - l);\n                update(0, MAX - 1, 0, r, r - x);\n                obstables.insert(x);\n            } else {\n                int maxWidth = max(queryX(0, MAX - 1, 0, l, 0), x - l);\n                // cout << l << \" \" << r << \" \" << queryX(0, MAX - 1, 0, l, 0) << \" \" << x - l << \"\\n\";\n                if (maxWidth >= query[2])\n                    res.push_back(true);\n                else\n                    res.push_back(false);\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1716650796.0
}