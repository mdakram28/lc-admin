{
    "username": "power1011",
    "submission": "const array<size_t, 2> mul{233,519};\nconst array<size_t, 2> mod{1'000'000'000+7,1'000'000'000+9};\nusing hashv_t = array<size_t, 2>;\nvector<hashv_t> ppp;\nvoid build(int n)\n{\n    ppp.clear();\n    ppp.resize(n+1);\n    ppp[0] = {1,1};\n    for(int i=1;i<=n;++i)\n    {\n        for(int j=0;j<2;++j)\n        {\n            ppp[i][j] = ppp[i-1][j] * mul[j] % mod[j];\n        }\n    }\n}\nhashv_t calc2(const string&s)\n{\n    int n = s.size();\n    array<size_t, 2> h{};\n    h[0] = h[1] = s[0];\n    for(int i=1;i<n;++i)\n    {\n        for(int j=0;j<2;++j)\n        {\n            h[j] = (h[j] * mul[j] + s[i]) % mod[j];\n        }\n    }\n    return h;\n}\nstruct myhash\n{\n\n    vector<array<size_t, 2>> h;\n    myhash(const string&s): h(s.size())\n    {\n        int n = s.size();\n        for(int i=1;i<n;++i)\n        {\n            for(int j=0;j<2;++j)\n            {\n                h[i][j] = (h[i-1][j] * mul[j] + s[i]) % mod[j];\n            }\n        }\n    }\n    array<size_t, 2> calc(int l, int r)\n    {\n        array<size_t, 2> ret = h[r];\n        for(int j=0;j<2;++j)\n        {\n            ret[j] += mod[j] - h[l-1][j]  * ppp[r-l+1][j] % mod[j];\n            ret[j] %= mod[j];\n        }\n        return ret;\n    }\n};\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        // collect all the length of words\n        // there are at must O(sqrt(5 * 10^4)) of different length\n        // save in lengths\n        \n        // for every prefix (pf) in target\n        // we iterate lengths (l) and check if pf[-l:] is in words\n        // dp[i] is the min cost to build prefix i of target\n        // dp[i] = dp[i-l] + cost_map[pf[-l:]] if(pf[-l:] is in words) for all l in lengths\n        \n        \n        // O(len(target) * sqrt(5 * 10^4))\n        vector<int> lengths{};\n        for(auto &w:words)\n        {\n            lengths.push_back(w.size());\n        }\n        std::sort(lengths.begin(), lengths.end());\n        lengths.erase(std::unique(lengths.begin(), lengths.end()), lengths.end());\n        // got lengths\n        auto hash_2 = [](const hashv_t &v)\n        {\n            return v[0] + v[1] * 999;  \n        };\n        unordered_map<hashv_t, int, decltype(hash_2)> cost_map(1, hash_2);\n        for(int i=0;i<words.size();++i)\n        {\n            auto hh = calc2(words[i]);\n            auto it = cost_map.insert({hh, costs[i]});\n            if(!it.second)\n            {\n                it.first->second = std::min(it.first->second, costs[i]);\n            }\n            //cout << i << \":\" << hash_2(hh) << \"\\n\";\n        }\n        \n        target.insert(target.begin(), '0');\n        int n = target.size();\n        build(n);\n        myhash mh(target);\n        const int inf = 1'000'000'000;\n        vector<int> dp(n, inf);\n        dp[0] = 0;\n        for(int i=1;i<n;++i)\n        {\n            for(auto &l:lengths)\n            {\n                if(i-l+1 > 0)\n                {\n                    //cout << i << \",\" << l << \":\" << hash_2(mh.calc(i-l+1, i)) << \"\\n\";\n                    auto it = cost_map.find(mh.calc(i-l+1, i));\n                    if(it == cost_map.end())\n                    {\n                        continue;\n                    }\n                    dp[i] = min(dp[i], dp[i-l] + it->second);\n                }\n            }\n        }\n        if(dp[n-1] == inf)\n        {\n            return -1;\n        }\n        return dp[n-1];\n    }\n};",
    "submit_ts": "1720324126",
    "subm_id": "1312392207"
}