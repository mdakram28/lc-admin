{
    "username": "yesh_the_devil",
    "submission": "class Solution {\npublic:\n    int dfs(vector<vector<int>> &net, int begin, int end1, int end2, int vertices) {\n        queue<int> nq;\n        vector<int> seen(vertices + 4, 0);\n        nq.push(begin);\n        seen[begin] = 1;\n    \n        while (!nq.empty()) {\n            int w = nq.front();\n            nq.pop();\n            for (int z : net[w]) {\n                if (!seen[z]) {\n                    nq.push(z);\n                    seen[z] = 1;\n                }\n            }\n        }\n        return seen[end1] || seen[end2];\n    }\n    \n    bool canReachCorner(int boundaryX, int boundaryY, vector<vector<int>>& centersAndRadii) {\n        vector<pair<pair<int, int>, int>> blobs(centersAndRadii.size());\n        vector<vector<int>> linkages(centersAndRadii.size() + 4);\n        int blobsCount = centersAndRadii.size();\n        \n        for (int k = 0; k < blobsCount; ++k) {\n            blobs[k].first.first = centersAndRadii[k][0];\n            blobs[k].first.second = centersAndRadii[k][1];\n            blobs[k].second = centersAndRadii[k][2];\n        }\n        \n        for (int k = 0; k < blobsCount; ++k) {\n            if (blobs[k].first.first <= blobs[k].second) {\n                linkages[blobsCount].push_back(k);\n                linkages[k].push_back(blobsCount);\n            }\n            if (boundaryX - blobs[k].first.first <= blobs[k].second) {\n                linkages[blobsCount + 2].push_back(k);\n                linkages[k].push_back(blobsCount + 2);\n            }\n            if (blobs[k].first.second <= blobs[k].second) {\n                linkages[blobsCount + 1].push_back(k);\n                linkages[k].push_back(blobsCount + 1);\n            }\n            if (boundaryY - blobs[k].first.second <= blobs[k].second) {\n                linkages[blobsCount + 3].push_back(k);\n                linkages[k].push_back(blobsCount + 3);\n            }\n            for (int m = k + 1; m < blobsCount; ++m) {\n                double dist = sqrt(pow(blobs[k].first.first - blobs[m].first.first, 2) +\n                                   pow(blobs[k].first.second - blobs[m].first.second, 2));\n                int totalRadius = blobs[k].second + blobs[m].second;\n                if (totalRadius >= dist) {\n                    linkages[k].push_back(m);\n                    linkages[m].push_back(k);\n                }\n            }\n        }\n        \n        int impeded = 0;\n        impeded = max(impeded, dfs(linkages, blobsCount, blobsCount + 1, blobsCount + 2, blobsCount + 4)); \n        impeded = max(impeded, dfs(linkages, blobsCount + 3, blobsCount + 2, blobsCount + 1, blobsCount + 4)); \n        \n        if (impeded) {\n            return false;\n        }\n        return true;\n    }\n};",
    "submit_ts": "1722136483",
    "subm_id": "1335735864"
}