{
    "username": "minohcity",
    "submission": "class Solution {\npublic:\n    int numberOfSubstrings(string& s) {\n        int n = int(s.size());\n\n        vector<int> pre(n + 1, 0);\n        vector<int> zeroIndexes;\n        for (int i = 0; i < n; ++i) {\n            pre[i + 1] = pre[i] + (s[i] == '1');\n            if (s[i] == '0') {\n                zeroIndexes.emplace_back(i);\n            }\n        }\n\n        // function to get the number of 1s in the range [l, r]\n        auto getOne = [&](int l, int r) {\n            return pre[r + 1] - pre[l];\n        };\n\n        // function to get the number of 0s in the range [l, r]\n        auto getZero = [&](int l, int r) {\n            return r - l + 1 - getOne(l, r);\n        };\n\n        auto square = [&](int x) {\n            return x * x;\n        };\n\n        auto pickTwo = [&](int x) {\n            return x * (x - 1) / 2;\n        };\n\n        int zeroSize = zeroIndexes.size();\n        int oneSize = n - zeroSize;\n\n        if (zeroSize == 0) {\n            return pickTwo(n + 1);\n        }\n\n        // cout << \"zeroIndexes: \"; for (int id : zeroIndexes) cout << id << ' '; cout << endl;\n        // base case when there is no 0 and only 1s exist in the string\n        int answer = pickTwo(zeroIndexes[0] + 1);\n        for (int i = 0; i + 1 < zeroSize; ++i) {\n            answer += pickTwo(zeroIndexes[i + 1] - zeroIndexes[i]);\n        }\n        answer += pickTwo(n - zeroIndexes.back());\n\n        // cout << \"only 1s: \" << answer << endl;\n\n        // find all the substrings such that getOne(l, r) >= getZero(l, r) * getZero(l, r)\n        for (int cntZero = 1; cntZero <= zeroSize && cntZero <= 200; ++cntZero) {\n            int target = square(cntZero);\n            if (target > oneSize) {\n                break;\n            }\n            for (int l = 0, r = l + cntZero - 1; r < zeroSize; ++l, ++r) {\n                // int zero = getZero(zeroIndexes[l], zeroIndexes[r]);\n                int one = getOne(zeroIndexes[l], zeroIndexes[r]);\n\n                int prevZero = l == 0 ? -1 : zeroIndexes[l - 1];\n                int nextZero = r == zeroSize - 1 ? n : zeroIndexes[r + 1];\n                \n                int lone = getOne(prevZero + 1, zeroIndexes[l] - 1);\n                int rone = getOne(zeroIndexes[r] + 1, nextZero - 1);\n\n                if (one + lone + rone < target) {\n                    // impossible to have getOne(l, r) >= getZero(l, r) * getZero(l, r)\n                    continue;\n                }\n\n                // now find the number of substrings that satisfy the condition\n                // leftside: [0, lone] number of ones\n                // right side: [0, rone] number of ones\n                int cur = 0;\n                for (int i = 0; i <= lone; ++i) {\n                    // for (int j = 0; j <= rone; ++j) {\n                    //     if (i + j + one >= target) {\n                    //         ++cur;\n                    //     }\n                    // }\n                    int remaining = target - i - one;\n                    if (remaining <= rone) cur += min(rone + 1, rone - remaining + 1);\n                }\n\n                // cout << \"l: \" << l << \" r: \" << r << \" cntZero: \" << cntZero << \" cur: \" << cur << endl;\n                answer += cur;\n            }\n        }\n\n        return answer;\n    }\n};\n",
    "submit_ts": "1722138479",
    "subm_id": "1335791836"
}