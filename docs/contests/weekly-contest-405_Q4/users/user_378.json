{
    "username": "resotto",
    "submission": "class Solution {\n    private Integer[] memo;\n    private Node root;\n    public int minimumCost(String target, String[] words, int[] costs) {\n        root = new Node();\n        var map = new HashMap<String, Integer>();\n        for (int i = 0; i < words.length; i++) {\n            map.put(words[i], Math.min(map.getOrDefault(words[i], Integer.MAX_VALUE), costs[i]));\n        }\n        for (String key : map.keySet()) {\n            var node = root;\n            String s = key;\n            for (int j = 0; j < s.length(); j++) {\n                if (node.next[s.charAt(j) - 'a'] == null) {\n                    node.next[s.charAt(j) - 'a'] = new Node();\n                }\n                node = node.next[s.charAt(j) - 'a'];\n            }\n            node.cost = map.get(key);\n        }\n        memo = new Integer[target.length()];\n        var ans = dfs(0, target);\n        return (int) 1e9 <= ans ? -1 : ans;\n    }\n    private int dfs(int i, String target) {\n        if (i == target.length()) {\n            return 0;\n        } else if (memo[i] == null) {\n            int ans = (int) 1e9;\n            var node = root;\n            for (int j = i; j < target.length(); j++) {\n                if (node.next[target.charAt(j) - 'a'] == null) {\n                    break;\n                }\n                node = node.next[target.charAt(j) - 'a'];\n                if (0 < node.cost) {\n                    ans = Math.min(ans, node.cost + dfs(j+1, target));\n                }\n            }\n            memo[i] = ans;\n        }\n        return memo[i];\n    }\n    class Node {\n        Node[] next = new Node[26];\n        int cost = 0;\n    }\n}\n\n/*\n    DP for each index (starting a word from the index)\n    \n    \n    private Map<Character, List<Pair<String, Integer>> map;\n    private Integer[] memo;\n    public int minimumCost(String target, String[] words, int[] costs) {\n        map = new HashMap<>();\n        for (int i = 0; i < words.length; i++) {\n            map.computeIfAbsent(words[i].charAt(0), z -> new ArrayList<>()).add(new Pair(words[i], costs[i]));\n        }\n        for (int j = 0; j < 26; j++) {\n            var list = map.computeIfAbsent((char) ('a' + j), z -> new ArrayList<>());\n            Collections.sort(list, (a, b) -> a.getKey().length() - b.getKey().length());\n        }\n        memo = new Integer[target.length()];\n        return dfs(0, target);\n    }\n    private int dfs(int i, String target) {\n        if (i == target.length()) {\n            return 0;\n        } else if (memo[i] == null) {\n            char sc = target.charAt(i);\n            int ans = Integer.MAX_VALUE, maxLen = 0 < map.get(sc).size() ? map.get(sc).get(map.get(sc).size()-1).length() : 0;\n            for (int j = i; j < target.length() && j < maxLen; j++) {\n                \n            }\n            memo[i] = ans;\n        }\n        return memo[i];\n    }\n    \n\"r\"\n[\"r\",\"r\",\"r\",\"r\"]\n[1,6,3,3]\n=> 1\n*/",
    "submit_ts": "1720321684",
    "subm_id": "1312329556"
}