{
    "username": "jtcheng26",
    "submission": "class Solution {\npublic:\n    vector<int> bfs(const vector<vector<int>>& adj, int n) {\n        vector<int> dist(n, -1);\n        queue<int> q;\n        for (int i=0;i<n;i++) {\n            if (adj[i].size() == 1) {\n                dist[i] = 0;\n                q.push(i);\n            }\n        }\n        while (!q.empty()) {\n            int top = q.front();\n            q.pop();\n            for (int j : adj[top]) {\n                if (dist[j] != -1) continue;\n                dist[j] = dist[top] + 1;\n                q.push(j);\n            }\n        }\n        \n        return dist;\n    }\n    pair<vector<int>, vector<int>> bfs(const vector<vector<int>>& adj, int n, int r) {\n        vector<int> dist(n, -1);\n        vector<int> par(n, -1);\n        queue<int> q;\n        dist[r] = 0;\n        par[r] = r;\n        q.push(r);\n        while (!q.empty()) {\n            int top = q.front();\n            q.pop();\n            for (int j : adj[top]) {\n                if (dist[j] != -1) continue;\n                dist[j] = dist[top] + 1;\n                par[j] = top;\n                q.push(j);\n            }\n        }\n        \n        return { dist, par };\n    }\n    \n    pair<int, int> diam(const vector<vector<int>>& adj, int n) {\n        pair<vector<int>, vector<int>> d1 = bfs(adj, n, 0);\n        int k = 0;\n        for (int i=1;i<n;i++) {\n            if (d1.first[i] > d1.first[k]) k = i;\n        }\n        pair<vector<int>, vector<int>> d2 = bfs(adj, n, k);\n        k = 0;\n        for (int j=1;j<n;j++) {\n            if (d2.first[j] > d2.first[k]) k = j;\n        }\n        \n        int ans = d2.first[k];\n//         for (int i=0;i<ans/2;i++) \n//              k = d2.second[k];\n        \n        \n        return { ans , (ans + 1) / 2  };\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        vector<vector<int>> adj1(n);\n        vector<vector<int>> adj2(m);\n        for (const vector<int>& v: edges1) {\n            adj1[v[0]].push_back(v[1]);\n            adj1[v[1]].push_back(v[0]);\n        }\n        for (const vector<int>& v: edges2) {\n            adj2[v[0]].push_back(v[1]);\n            adj2[v[1]].push_back(v[0]);\n        }\n        \n//         vector<int> d1 = bfs(adj1, n);\n//         vector<int> d2 = bfs(adj2, m);\n//         int k = 0;\n//         for (int i=1;i<n;i++) {\n//             if (d1[i] > d1[k]) k = i;\n//         }\n//         int l = 0;\n//         for (int i=1;i<m;i++) {\n//             if (d2[i] > d2[l]) l = i;\n//         }\n        \n        pair<int, int> da = diam(adj1, n);\n        pair<int, int> db = diam(adj2, m);\n        \n        int ans = max({da.first, db.first, da.second + db.second + 1});\n        return ans;\n    }\n};",
    "submit_ts": 1719716221.0
}