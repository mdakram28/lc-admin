{
    "username": "yashss1",
    "submission": "vector<int> a;\nclass node {\npublic:\n\tstatic const long long inf = 1e8;\n\tlong long mn, mx, sum;\n\tnode(long long _mn, long long _mx, long long _sum) {\n\t\tmn = _mn;\n\t\tmx = _mx;\n\t\tsum = _sum;\n\t}\n\tnode() {\n\t\tmn = inf;\n\t\tmx = 0;\n\t\tsum = 0;\n\t}\n};\nstruct segtree {\n\tlong long N;\n\tvector<node> st;\n\tvector<bool> cLazy;\n\tvector<int> lazy;\n\tvoid init(int n) {\n\t\tN = n;\n\t\tst.resize((N << 2) + 2);\n\t\tcLazy.assign((N << 2) + 2, false);\n\t\tlazy.assign((N << 2) + 2, 0);\n\t\tbuild(1, 1, N);\n\t}\n\t//Write reqd merge functions\n\tvoid merge(node &ret, node &left, node &right) {\n\t\tret.mn = min(left.mn, right.mn);\n\t\tret.mx = max(left.mx, right.mx);\n\t\tret.sum = left.sum + right.sum;\n\t}\n\n\t//Handle lazy propagation appriopriately\n\tvoid propagate(int u, int L, int R) {\n\t\t// Propagate down?\n\t\tif (L != R) {\n\t\t\tcLazy[u * 2] = 1;\n\t\t\tcLazy[u * 2 + 1] = 1;\n\t\t\t// Default range update operation is :\n\t\t\t// adding lazy[u] to all elements in range [...]\n\t\t\tlazy[u * 2] += lazy[u];\n\t\t\tlazy[u * 2 + 1] += lazy[u];\n\t\t}\n\t\t// Updating the range [L, R] with lazy[u]\n\t\t{\n\t\t\t// Default range update operation is :\n\t\t\t// adding lazy[u] to all elements in range [...]\n\t\t\tst[u].sum += (R - L + 1) * lazy[u];\n\t\t\tst[u].mx += lazy[u];\n\t\t\tst[u].mn += lazy[u];\n\t\t}\n\t\tcLazy[u] = 0;\n\t\tlazy[u] = 0;\n\t}\n\tvoid build (int u, int L, int R) {\n\t\tif (L == R) {\n\t\t\t// Leaf value\n\t\t\tst[u] = node(a[L], a[L], a[L]);\n\t\t\treturn;\n\t\t}\n\t\tint M = (L + R) / 2;\n\t\tbuild(u * 2, L, M);\n\t\tbuild(u * 2 + 1, M + 1, R);\n\t\tmerge(st[u], st[u * 2], st[u * 2 + 1]);\n\t}\n\tnode Query(int u, int L, int R, int i, int j) {\n\t\tif (cLazy[u])\n\t\t\tpropagate(u, L, R);\n\t\tif (j < L || i > R)\n\t\t\treturn node();\n\t\tif (i <= L && R <= j)\n\t\t\treturn st[u];\n\t\tint M = (L + R) / 2;\n\t\tnode left = Query(u * 2, L, M, i, j);\n\t\tnode right = Query(u * 2 + 1, M + 1, R, i, j);\n\t\tnode ret;\n\t\tmerge(ret, left, right);\n\t\treturn ret;\n\t}\n\tnode pQuery(int u, int L, int R, int pos) {\n\t\tif (cLazy[u])\n\t\t\tpropagate(u, L, R);\n\t\tif (L == R)\n\t\t\treturn st[u];\n\t\tint M = (L + R) / 2;\n\t\tif (pos <= M)\n\t\t\treturn pQuery(u * 2, L, M, pos);\n\t\telse\n\t\t\treturn pQuery(u * 2 + 1, M + 1, R, pos);\n\t}\n\tvoid Update(int u, int L, int R, int i, int j, int val) {\n\t\tif (cLazy[u])\n\t\t\tpropagate(u, L, R);\n\t\tif (j < L || i > R)\n\t\t\treturn;\n\t\tif (i <= L && R <= j) {\n\t\t\t// Default range update operation is :\n\t\t\t// adding val to all elements in range [...]\n\t\t\tcLazy[u] = 1;\n\t\t\tlazy[u] = val;\n\t\t\tpropagate(u, L, R);\n\t\t\treturn;\n\t\t}\n\t\tint M = (L + R) / 2;\n\t\tUpdate(u * 2, L, M, i, j, val);\n\t\tUpdate(u * 2 + 1, M + 1, R, i, j, val);\n\t\tmerge(st[u], st[u * 2], st[u * 2 + 1]);\n\t}\n\tvoid pUpdate(int u, int L, int R, int pos, int val) {\n\t\tif (cLazy[u])\n\t\t\tpropagate(u, L, R);\n\t\tif (L == R) {\n\t\t\tcLazy[u] = 1;\n\t\t\tlazy[u] = val;\n\t\t\tpropagate(u, L, R);\n\t\t\treturn;\n\t\t}\n\t\tint M = (L + R) / 2;\n\t\tif (pos <= M)\n\t\t\tpUpdate(u * 2, L, M, pos, val);\n\t\telse\n\t\t\tpUpdate(u * 2 + 1, M + 1, R, pos, val);\n\t\tmerge(st[u], st[u * 2], st[u * 2 + 1]);\n\t}\n\tnode query(int pos) { return pQuery(1, 1, N, pos); }\n\tnode query(int l, int r) { return Query(1, 1, N, l, r); }\n\tvoid update(int pos, int val) { pUpdate(1, 1, N, pos, val); }\n\tvoid update(int l, int r, int val) { Update(1, 1, N, l, r, val); }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& q) {\n        int mx = 0;\n        for(int i = 0; i < q.size(); i++) {\n            mx = max(mx, q[i][1]);\n        }\n        \n        int mxPut = 0;\n        a.resize(4 * (mx + 10));\n        \n\t    segtree seg;\n\t    seg.init(mx + 3);\n        \n        multiset<int> st;\n        st.insert(0);\n        \n        vector<bool> ans;\n        for(int i = 0; i < q.size(); i++) {\n            int type = q[i][0];\n            \n            if(type == 1) {\n                int x = q[i][1];\n                if(mxPut < x) {\n                    int val = seg.query(x).mx;\n                    seg.update(x, x, -1 * val);\n                    seg.update(x, x, x - mxPut);\n                    mxPut = max(mxPut, x);\n                    st.insert(x);\n                    continue;\n                }\n                \n                \n                auto prev = st.lower_bound(x);\n\n                prev--;\n                int val = seg.query(x).mx;\n                seg.update(x, x, -1 * val);\n                seg.update(x, x, x - (*prev));\n                prev++;\n                if((*prev) == x) {\n                    prev++;\n                }\n                val = seg.query((*prev)).mx;\n                seg.update((*prev), (*prev), -1 * val);\n                seg.update((*prev), (*prev), (*prev) - x);\n                \n                st.insert(x);\n            }\n            else {\n                int x = q[i][1], sz = q[i][2];\n                \n                auto prev = st.lower_bound(x);\n                if(((*prev) != x) || (prev == st.end())) {\n                    prev--;\n                }\n                \n                // cout << (*prev) << '\\n';\n                \n                int mxTill = seg.query(0, (*prev)).mx;\n                int res = max(mxTill, x - (*prev));\n                \n                // cout << mxTill << \" \" << res << '\\n';\n                \n                if(res >= sz) {\n                    ans.push_back(true);\n                } \n                else {\n                    ans.push_back(false);\n                }\n            }\n            \n//             {\n//                 for(int i = 0; i < 10; i++) {\n//                     cout << seg.query(i).mx << \" \";\n//                 }cout << '\\n';\n//             }\n        }  \n        return ans;\n    }\n};",
    "submit_ts": 1716651813.0
}