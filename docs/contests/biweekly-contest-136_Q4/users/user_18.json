{
    "username": "Manan04",
    "submission": "class Solution:\n    def timeTaken(self, edges: List[List[int]]) -> List[int]:\n        # Template from https://codeforces.com/blog/entry/124286\n        def exclusive(A, zero, combine, node):\n            n = len(A)\n            exclusiveA = [zero] * n # Exclusive segment tree\n\n            # Build exclusive segment tree\n            for bit in range(n.bit_length())[::-1]:\n                for i in range(n)[::-1]:\n                    # Propagate values down the segment tree    \n                    exclusiveA[i] = exclusiveA[i // 2]\n                for i in range(n & ~(bit == 0)):\n                    # Fold A[i] into exclusive segment tree\n                    ind = (i >> bit) ^ 1\n                    exclusiveA[ind] = combine(exclusiveA[ind], A[i], node, i)\n            return exclusiveA\n\n        def rerooter(graph, default, combine, finalize = lambda nodeDP,node,eind: nodeDP):\n            n = len(graph)\n            rootDP = [0] * n\n            forwardDP = [None] * n\n            reverseDP = [None] * n\n\n            # Compute DP for root=0\n            DP = [0] * n\n            bfs = [0]\n            P = [0] * n\n            for node in bfs:\n                for nei in graph[node]:\n                    if P[node] != nei:\n                        P[nei] = node\n                        bfs.append(nei)\n\n            for node in reversed(bfs):\n                nodeDP = default[node]\n                for eind, nei in enumerate(graph[node]):\n                    if P[node] != nei:\n                        nodeDP = combine(nodeDP, DP[nei], node, eind)\n                DP[node] = finalize(nodeDP, node, graph[node].index(P[node]) if node else -1)\n            # DP for root=0 done\n\n            # Use the exclusive function to reroot \n            for node in bfs:\n                DP[P[node]] = DP[node]\n                forwardDP[node] = [DP[nei] for nei in graph[node]]\n                rerootDP = exclusive(forwardDP[node], default[node], combine, node)\n                reverseDP[node] = [finalize(nodeDP, node, eind) for eind, nodeDP in enumerate(rerootDP)]\n                rootDP[node] = finalize((combine(rerootDP[0], forwardDP[node][0], node, 0) if n > 1 else default[node]), node, -1)\n                for nei, dp in zip(graph[node], reverseDP[node]):\n                    DP[nei] = dp\n            return rootDP, forwardDP, reverseDP\n\n\n#         n = int(input())\n#         color = [int(x) for x in input().split()]\n\n#         for _ in range(n - 1):\n#             u,v = [int(x) - 1 for x in input().split()]\n#             graph[u].append(v)\n#             graph[v].append(u)\n\n        #def dfs(node, parent=-1):\n        #  nodeDP = 0\n        #  for nei in graph[node]:\n        #    if nei != parent:\n        #      neiDP = dfs(nei, node)\n        #       nodeDP += max(neiDP, 0)\n        #  return nodeDP + 2 * color[node] - 1\n        #print(dfs(u))\n\n\n        def combine(nodeDP, neiDP, node, eind):\n          # return nodeDP + max(neiDP, 0)\n            adder = 1\n            if(graph[node][eind] % 2 == 0):\n                adder += 1\n            return max(nodeDP, neiDP + adder)\n\n        def finalize(nodeDP, node, eind):\n          # return nodeDP + 2 * color[node] - 1\n            return nodeDP\n        \n        n = len(edges) + 1\n        default = [0] * n\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        rootDP, forwardDP, reverseDP = rerooter(graph, default, combine, finalize)\n        return rootDP\n        # print(*rootDP)",
    "submit_ts": "1722697141",
    "subm_id": "1343135661"
}