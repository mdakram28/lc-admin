{
    "username": "AnshChouksey",
    "submission": "class TrieNode {\npublic:\n    unordered_map<char, TrieNode*> branches;\n    vector<pair<int, int>> endings;\n};\n\nclass Trie {\npublic:\n    TrieNode* base;\n    Trie() {\n        base = new TrieNode();\n    }\n    void addWord(string term, int idx, int value) {\n        TrieNode* current = base;\n        for (char letter : term) {\n            if (!current->branches.count(letter)) {\n                current->branches[letter] = new TrieNode();\n            }\n            current = current->branches[letter];\n        }\n        current->endings.push_back({idx, value});\n    }\n};\n\nclass Solution {\npublic:\n    int minimumCost(string goal, vector<string>& replacements, vector<int>& prices) {\n        int length = goal.size();\n        vector<int> minCost(length + 1, INT_MAX);\n        minCost[0] = 0;\n        Trie dictionary;\n        for (int i = 0; i < replacements.size(); ++i) {\n            dictionary.addWord(replacements[i], i, prices[i]);\n        }\n        for (int start = 0; start < length; ++start) {\n            if (minCost[start] == INT_MAX) {\n                continue;\n            }\n            TrieNode* current = dictionary.base;\n            for (int end = start; end < length; ++end) {\n                if (!current->branches.count(goal[end])) {\n                    break;\n                }\n                current = current->branches[goal[end]];\n                for (auto& item : current->endings) {\n                    int wordLength = replacements[item.first].size();\n                    if (start + wordLength <= length) {\n                        minCost[start + wordLength] = min(minCost[start + wordLength], minCost[start] + item.second);\n                    }\n                }\n            }\n        }\n        return minCost[length] == INT_MAX ? -1 : minCost[length];\n    }\n};",
    "submit_ts": "1720322613",
    "subm_id": "1312354566"
}