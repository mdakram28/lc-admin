{
    "username": "The_2nd_Derivative",
    "submission": "\n#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)\n// trace std::pair\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){\n    return os<<\"{\"<<P.first<<\":\"<<P.second<<\"}\";\n}\n// trace std::vector\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){\n    os<<\"[ \";for(auto v:V)os<<v<<\" \";return os<<\"]\";\n}\n// trace std::map;\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {\n    os<<\"[ \";for(auto& P : MP) os<<P<<\" \";return os<<\"]\";\n}\n// trace unordred_std::map\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {\n    os<<\"[ \";for(auto& P : MP) os<<P<<\" \";return os<<\"]\";\n}\n// trace std::set\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){\n    os<<\"[ \";for(auto s:S)os<<s<<\" \";return os<<\"]\";\n}\n// trace std::unordered_set\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){\n    os<<\"[ \";for(auto s:S)os<<s<<\" \";return os<<\"]\";\n}\n// std::stack FUN\ntemplate<class T> void F_Stack(std::stack<T> st, std::string& cont) { \n    if(st.empty()) return;\n    T mem=st.top();st.pop();F_Stack(st,cont);cont+=\" \"+to_string(mem);  \n}\n// trace std::stack                                                  \ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {\n    os<<\"[\";std::string cont=\"\";F_Stack(st,cont);return os<<cont<<\" ]\";\n}\n// track std::queue\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {\n    os<<\"[ \";while(!q.empty()) os<<q.front()<<\" \",q.pop();return os<<\"]\";\n}\n\n// for last arg.\ntemplate<typename Arg1>\nvoid __f(const char* name,Arg1&& arg1){\n    std::cout<<name<<\" : \"<<arg1<<std::endl;\n}\n// for variable arg\ntemplate <typename Arg1,typename... Args>\nvoid __f(const char* names,Arg1&& arg1,Args&&... args){\n    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<\" : \"<<arg1<<\" | \";__f(comma+1,args...);\n}\n\n// dbg std::array\ntemplate<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){\n    os<<\"[ \";for(auto v:V)os<<v<<\" \";return os<<\"]\";\n}\n\n// X.find_by_order(k) return iterator to kth element. 0 indexed.\n// X.order_of_key(k) returns count of elements strictly less than k.\n\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// template <class T>\n// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\n\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define sz(x) ((ll)(x).size())\n#define nl '\\n'\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n \nusing ll = long long int;\nusing pii = pair<ll,ll>;\nusing mii = map<ll,ll>;\nusing umii = unordered_map<ll,ll>;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvii = vector<vpii>;\n\ntemplate<class T> bool chmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool chmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nconst ll INF = 1e18;\nconst ll N = 1e5+5;\n\n// DSU with path compression & small to large merge\nstruct DSU {\n    std::vector<int> parent, siz;\n    int comps;\n    \n    DSU() {}\n    DSU(int n) {\n        init(n);\n    }\n    \n    void init(int n) {\n        parent.resize(n);\n        std::iota(parent.begin(), parent.end(), 0);\n        siz.assign(n, 1);\n        comps = n;\n    }\n    \n    int find(int x) {\n        while (x != parent[x]) {\n            x = parent[x] = parent[parent[x]];\n        }\n        return x;\n    }\n    \n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            return false;\n        }\n        // small to large merging\n        if (siz[x] < siz[y])\n            swap(x, y);\n        siz[x] += siz[y];\n        parent[y] = x;\n        comps--;\n        return true;\n    }\n    \n    int getComps() {\n        return comps;\n    }\n\n    int size(int x) {\n        return siz[find(x)];\n    }\n};\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& c) {\n        ll n=sz(c);\n        DSU dsu(n+4);\n        auto intersect_circle=[&](vi& c1, vi& c2){\n            ll x1=c1[0],y1=c1[1],r1=c1[2];\n            ll x2=c2[0],y2=c2[1],r2=c2[2];\n            ll dis=(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);\n            return dis<=(r1+r2)*(r1+r2);\n        };\n        for(int i=0;i<n-1;i++){\n            for(int j=i+1;j<n;j++){\n                if(intersect_circle(c[i],c[j])){\n                    dsu.merge(i,j);\n                }\n            }\n        }\n        // 0-n-1 -> circles\n        // n=left, y=0\n        // n+1=>up\n        // n+2=>right\n        // n+3=>down\n        for(int i=0;i<n;i++){\n            ll xi=c[i][0],yi=c[i][1],ri=c[i][2];\n            // left\n            if(xi<=ri){\n                dsu.merge(i,n);\n            }\n            // up\n            if(abs(Y-yi)<=ri){\n                dsu.merge(i,n+1);\n            }\n            // right\n            if(abs(X-xi)<=ri){\n                dsu.merge(i,n+2);\n            }\n            if(yi<=ri){\n                dsu.merge(i,n+3);\n            }\n        }\n        return !(dsu.same(n+1,n+3) || dsu.same(n,n+2) || dsu.same(n,n+3) || dsu.same(n+1,n+2)); \n    }\n};",
    "submit_ts": "1722139004",
    "subm_id": "1335805314"
}