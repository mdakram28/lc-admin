{
    "username": "mkawa222",
    "submission": "import typing\n\nclass SegTree:\n    def __init__(self,\n                 op: typing.Callable[[typing.Any, typing.Any], typing.Any],\n                 e: typing.Any,\n                 v: typing.Union[int, typing.List[typing.Any]]) -> None:\n        self._op = op\n        self._e = e\n\n        if isinstance(v, int):\n            v = [e]*v\n\n        self._n = len(v)\n        self._log = (self._n-1).bit_length()\n        self._size = 1 << self._log\n        self._d = [e]*(2*self._size)\n\n        for i in range(self._n):\n            self._d[self._size+i] = v[i]\n        for i in range(self._size-1, 0, -1):\n            self._update(i)\n\n    def set(self, p: int, x: typing.Any) -> None:\n        assert 0 <= p < self._n\n\n        p += self._size\n        self._d[p] = x\n        for i in range(1, self._log+1):\n            self._update(p >> i)\n\n    def get(self, p: int) -> typing.Any:\n        assert 0 <= p < self._n\n\n        return self._d[p+self._size]\n\n    def prod(self, left: int, right: int) -> typing.Any:\n        assert 0 <= left <= right <= self._n\n        sml = self._e\n        smr = self._e\n        left += self._size\n        right += self._size\n\n        while left < right:\n            if left & 1:\n                sml = self._op(sml, self._d[left])\n                left += 1\n            if right & 1:\n                right -= 1\n                smr = self._op(self._d[right], smr)\n            left >>= 1\n            right >>= 1\n\n        return self._op(sml, smr)\n\n    def all_prod(self) -> typing.Any:\n        return self._d[1]\n\n    def max_right(self, left: int,\n                  f: typing.Callable[[typing.Any], bool]) -> int:\n        assert 0 <= left <= self._n\n        assert f(self._e)\n\n        if left == self._n:\n            return self._n\n\n        left += self._size\n        sm = self._e\n\n        first = True\n        while first or (left & -left) != left:\n            first = False\n            while left%2 == 0:\n                left >>= 1\n            if not f(self._op(sm, self._d[left])):\n                while left < self._size:\n                    left *= 2\n                    if f(self._op(sm, self._d[left])):\n                        sm = self._op(sm, self._d[left])\n                        left += 1\n                return left-self._size\n            sm = self._op(sm, self._d[left])\n            left += 1\n\n        return self._n\n\n    def min_left(self, right: int,\n                 f: typing.Callable[[typing.Any], bool]) -> int:\n        assert 0 <= right <= self._n\n        assert f(self._e)\n\n        if right == 0:\n            return 0\n\n        right += self._size\n        sm = self._e\n\n        first = True\n        while first or (right & -right) != right:\n            first = False\n            right -= 1\n            while right > 1 and right%2:\n                right >>= 1\n            if not f(self._op(self._d[right], sm)):\n                while right < self._size:\n                    right = 2*right+1\n                    if f(self._op(self._d[right], sm)):\n                        sm = self._op(self._d[right], sm)\n                        right -= 1\n                return right+1-self._size\n            sm = self._op(self._d[right], sm)\n\n        return 0\n\n    def _update(self, k: int) -> None:\n        self._d[k] = self._op(self._d[2*k], self._d[2*k+1])\n\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        def unpack(x):\n            c = x & mask\n            x >>= 18\n            b = x & mask\n            x >>= 18\n            return x, b, c\n\n        def pack(a, b, c):\n            return a << 36 | b << 18 | c\n\n        def op(a, b):\n            l1, m1, r1 = unpack(a)\n            l2, m2, r2 = unpack(b)\n            if l1 == l2 == lim:\n                return pack(lim, m1+m2, lim)\n            if l1 == lim:\n                return pack(m1+l2, m2, r2)\n            if l2 == lim:\n                return pack(l1, m1, r1+m2)\n            return pack(l1, max(m1, m2, r1+l2), r2)\n\n        mask = (1 << 18)-1\n        lim = 50004\n        x = pack(lim, 1, lim)\n        e = pack(lim, 0, lim)\n        n=min(lim,len(queries)*3+5)\n        st = SegTree(op, e, [x]*n)\n        ans = []\n        for data in queries:\n            if data[0] == 1:\n                x = data[1]\n                st.set(x, pack(0, 0, 1))\n            else:\n                _, x, s = data\n                l, m, r = unpack(st.prod(0, x))\n                if l == lim: l = -1\n                if r == lim: r = -1\n                ans.append(max(l, m, r) >= s)\n        return ans\n",
    "submit_ts": 1716650885.0
}