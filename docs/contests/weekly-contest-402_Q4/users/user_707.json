{
    "username": "T_DOG",
    "submission": "class Solution {\npublic:\n    \n    int update(int l,int r,int x,vector<int> &tree,vector<int> &peaks,int index){\n        if(l>x || r<x){\n            return tree[index];\n        }\n        else if(l==r){\n            return tree[index] = peaks[x];\n        }\n        else{\n            int mid = (l+r)/2;\n            int left = update(l,mid,x,tree,peaks,2*index+1),right = update(mid+1,r,x,tree,peaks,2*index+2);\n            return tree[index] = left+right;\n        }\n    }\n    \n    int queryTree(int p,int q,int l,int r,vector<int> &tree,int index){\n        if(p > q){\n            return 0;\n        }\n        if(p > r || q < l){\n            return 0;\n        }\n        else if(p<=l && q>=r){\n            return tree[index];\n        }\n        else{\n            int mid = (l+r)/2;\n            int left = queryTree(p,q,l,mid,tree,2*index+1),right = queryTree(p,q,mid+1,r,tree,2*index+2);\n            return left+right;\n        }\n    }\n    \n    int build(int l, int r, vector<int> &tree, vector<int> &peaks,int index){\n        if(l == r){\n            return tree[index] = peaks[l];\n        }\n        else{\n            int mid = (l+r)/2;\n            int left = build(l,mid,tree,peaks,2*index+1),right = build(mid+1,r,tree,peaks,2*index+2);\n            return tree[index] = left+right;\n        }\n    }\n    \n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        int n = nums.size(),m = n-2;\n        \n        vector<int> peaks;\n        \n        vector<int> tree(4*m);\n        \n        vector<int> res;\n        \n        for(int i=1; i<n-1; i++){\n            if(nums[i] > nums[i-1] && nums[i] > nums[i+1]){\n                peaks.push_back(1);\n            }\n            else{\n                peaks.push_back(0);\n            }\n        }\n        \n        build(0,m-1,tree,peaks,0);\n        \n        for(auto it: queries){\n            int a=it[0],b=it[1],c=it[2];\n            if(a==1){\n                if(b==c){\n                    res.push_back(0);\n                }\n                else{\n                    b++; c--;\n                    b--; c--;\n                    int val = queryTree(b,c,0,m-1,tree,0);\n                    res.push_back(val);\n                }\n                \n            }\n            else{\n                int index = b, val = c;\n                nums[index] = val;\n                if(index == 0){\n                    if(nums[1] > nums[0] && nums[1] > nums[2]){\n                        peaks[0] = 1;\n                        update(0,m-1,0,tree,peaks,0);\n                    }\n                    else{\n                        peaks[0] = 0;\n                        update(0,m-1,0,tree,peaks,0);\n                    }\n                }\n                else if(index == n-1){\n                    if(nums[n-2] > nums[n-1] && nums[n-2] > nums[n-3]){\n                        peaks[n-3] = 1;\n                        update(0,m-1,m-1,tree,peaks,0);\n                    }\n                    else{\n                        peaks[n-3] = 0;\n                        update(0,m-1,m-1,tree,peaks,0);\n                    }\n                }\n                else if(index == 1){\n                    if(nums[1] > nums[0] && nums[1] > nums[2]){\n                        peaks[0] = 1;\n                    }\n                    else{\n                        peaks[0] = 0;\n                    }\n                    \n                    if(nums[2] > nums[1] && n > 3 && nums[2] > nums[3]){\n                        peaks[1] = 1;\n                    }\n                    else if(n > 3){\n                        peaks[1] = 0;\n                    }\n                    \n                    update(0,m-1,0,tree,peaks,0);\n                    \n                    if(n > 3){\n                        update(0,m-1,1,tree,peaks,0);\n                    }\n                }\n                else if(index == n-2){\n                    if(nums[n-2] > nums[n-1] && nums[n-2] > nums[n-3]){\n                        peaks[m-1] = 1;\n                    }\n                    else{\n                        peaks[m-1] = 0;\n                    }\n                    \n                    if(n > 3 && nums[n-3] > nums[n-2] && nums[n-3] > nums[n-4]){\n                        peaks[m-2] = 1;\n                    }\n                    else if(n > 3){\n                        peaks[m-2] = 0;\n                    }\n                    \n                    update(0,m-1,m-1,tree,peaks,0);\n                    \n                    if(n > 3){\n                        update(0,m-1,m-2,tree,peaks,0);\n                    }\n                }\n                else{\n                    \n                    if(nums[index] > nums[index+1] && nums[index] > nums[index-1]){\n                        peaks[index-1] = 1;\n                    }\n                    else{\n                        peaks[index-1] = 0;\n                    }\n                    \n                    update(0,m-1,index-1,tree,peaks,0);\n                    \n                    if(nums[index-1] > nums[index] && nums[index-1] > nums[index-2]){\n                        peaks[index-2] = 1;\n                    }\n                    else{\n                        peaks[index-2] = 0;\n                    }\n                    \n                    update(0,m-1,index-2,tree,peaks,0);\n                    \n                    if(nums[index+1] > nums[index] && nums[index+1] > nums[index+2]){\n                        peaks[index] = 1;\n                    }\n                    else{\n                        peaks[index] = 0;\n                    }\n                    \n                    update(0,m-1,index,tree,peaks,0);\n                }\n            }\n            \n        }\n        \n        return res;\n    }\n};",
    "submit_ts": 1718508594.0
}