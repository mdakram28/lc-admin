{
    "username": "hhuuuu",
    "submission": "template <typename T> struct zwkSegmentTree {\n    vector<T> A;\n    virtual T op(const T& a, const T& b) = 0; \n    virtual void updateT(T& a,const T& b) = 0;\n    int n = 0, N = 0 ; \n    void init(auto && v){ \n        A.clear();\n        for(auto x : v) A.push_back(x);\n        n = A.size();\n        A.resize((N = 1 << __lg(2*n-1)) + n); \n        memcpy(A.data()+N,A.data(),n*sizeof(T));\n        for(int L = N , R = N + n - 1; L > 1; L/=2, R/=2){ \n            for(int i = L ; i <= R ; i += 2) \n                A[i/2] = i == R ? A[i] : op(A[i] , A[i+1]);\n        }\n    } \n    void update(int i,const T& b){\n        updateT(A[i+N],b); \n        for(int I = i + N, R = N+n-1 ; I > 1; I/=2, R/=2){\n            A[I/2] = I%2==0 and I==R ? A[I] : op(A[I&~1] , A[I|1]); \n        }   \n    }\n    T query(){ return A[1]; }\n    T& query(int i){ return A[i+N]; }\n    T query(int l,int r){ return query(l,r,0,N-1,1);}\n    T query(int L,int R,int l,int r,int i){  \n        if( L <= l and r <= R) return A[i];\n        int mid = l + r >> 1;\n        if(mid < L)  return query(L, R, mid+1, r, i*2+1);\n        if(mid >= R) return query(L, R, l, mid, i*2);\n        return op(query(L, R, l, mid, i*2) , query(L, R, mid+1, r, i*2+1)); \n    }\n};\ntemplate<typename T>struct treemax:zwkSegmentTree<T>{  \n    T op(const T& a, const T& b){return max(a,b);}; \n    void updateT(T& a,const T& b){ a = b;}\n}; treemax<int> tree;  \nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int mx = 0;\n        for(auto &v : queries) mx = max(mx, v[1]);\n        tree.init(  vector<int>(mx+1,0) );\n        set<int> st; st.emplace(0);\n        tree.update(0,mx);\n        vector<bool> res;\n        for(auto &v : queries){\n            auto it = prev(st.upper_bound(v[1]));\n            int x = *it , L = tree.query(x);\n            // cout << x << ' ' << L << endl;\n            if(v[0] == 1){\n                // cout << x << ' ' <<  v[1] - x << ' ' << v[1] << ' ' << x + L - v[1] << endl;\n                tree.update(x, v[1] - x);\n                tree.update(v[1], x + L - v[1]);\n                st.emplace(v[1]);\n            }else{\n                // cout << v[1] - x << ' ' << ' ' << tree.query(0,x-1) << endl;\n                if(v[1] - x >= v[2] or x and tree.query(0,x-1) >= v[2]) \n                    res.push_back(1);\n                else res.push_back(0);\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1716649013.0
}