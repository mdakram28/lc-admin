{
    "username": "ToTea",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        vector<unordered_set<int>> graph(edges1.size()+1);\n        for (auto& edge1 : edges1) {\n            graph[edge1[0]].insert(edge1[1]);\n            graph[edge1[1]].insert(edge1[0]);\n        }\n        int diameter1 = maxDiameter(graph);\n        graph = vector<unordered_set<int>>(edges2.size()+1);\n        for (auto& edge2 : edges2) {\n            graph[edge2[0]].insert(edge2[1]);\n            graph[edge2[1]].insert(edge2[0]);\n        }\n        int diameter2 = maxDiameter(graph);\n        return max({diameter1, diameter2, ((diameter1+1) / 2) + 1 + ((diameter2+1) / 2)});\n    }\nprivate:\n    int maxDiameter(const vector<unordered_set<int>>& graph) {\n        int last = 0;\n        queue<pair<int,int>> q; // cur, in\n        q.push({0,-1});\n        while (!q.empty()) {\n            for (int qSize = q.size(); qSize > 0; --qSize) {\n                auto [cur, in] = q.front(); q.pop();\n                last = cur;\n                for (int out : graph[cur]) {\n                    if (out == in) continue;\n                    q.push({out, cur});\n                }\n            }\n        }\n        int height = -1;\n        q.push({last, -1});\n        while (!q.empty()) {\n            height += 1;\n            for (int qSize = q.size(); qSize > 0; --qSize) {\n                auto [cur, in] = q.front(); q.pop();\n                for (int out : graph[cur]) {\n                    if (out == in) continue;\n                    q.push({out, cur});\n                }\n            }\n        }\n        return height;\n    }\n};",
    "submit_ts": "1719717816",
    "subm_id": "1304401490"
}