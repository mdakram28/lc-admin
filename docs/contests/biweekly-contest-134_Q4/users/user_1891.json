{
    "username": "bera_474",
    "submission": "#define ll long long\nconst ll inf = (1ll << 30) - 1;\n\nstruct Node {\n  ll val;\n  Node() : val(inf) {}\n  Node(ll v) : val(v) {}\n  friend Node merge(Node l, Node r) { return Node(l.val & r.val); }\n  void update(ll v) { val = v; }\n};\n\nstruct SegTree {\n  int n;\n  vector<Node> seg;\n  SegTree(int _n) : n(_n), seg(2 * _n) {}\n  template <typename Type> SegTree(vector<Type> a) {\n    n = int(a.size());\n    seg.resize(2 * n);\n    for (int i = 0; i < n; i++)\n      seg[i + n] = Node(a[i]);\n    for (int i = n - 1; i > 0; i--)\n      seg[i] = merge(seg[i << 1], seg[i << 1 | 1]);\n  }\n\n  // 0 based-idx -> sgt[i].val = v\n  void update(int i, ll v) {\n    assert(i >= 0 && i < n);\n    for (seg[i += n].update(v); i >>= 1;)\n      seg[i] = merge(seg[i << 1], seg[i << 1 | 1]);\n  }\n\n  // 0 based-idx -> l and r both inclusive -> sgt[l..r]\n  Node query(int l, int r) {\n    assert(l >= 0 && r < n);\n    Node res_l, res_r;\n    for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {\n      if (l & 1)\n        res_l = merge(res_l, seg[l++]);\n      if (r & 1)\n        res_r = merge(seg[--r], res_r);\n    }\n    return merge(res_l, res_r);\n  }\n};\n\n\nclass Solution {\npublic:\n  long long countSubarrays(vector<int> &nums, int k) {\n    SegTree sgt(nums);\n    int n = nums.size();\n    ll ans = 0;\n    for (int i = 0; i < n; i++) {\n      if (nums[i] >= k) {\n        int L = i, R = n;\n        while (R > L + 1) {\n          int M = (L + R) / 2;\n\n          (sgt.query(i, M).val >= k ? L = M : R = M);\n        }\n        if (sgt.query(i, L).val != k)\n          continue;\n        int lst = L;\n        L = i - 1, R = n;\n        while (R > L + 1) {\n          int M = (L + R) / 2;\n          (sgt.query(i, M).val > k ? L = M : R = M);\n        }\n        L++;\n        ans += lst - L + 1;\n      }\n    }\n    return ans;\n  }\n};",
    "submit_ts": "1720277324",
    "subm_id": "1311658357"
}