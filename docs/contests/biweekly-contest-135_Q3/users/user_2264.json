{
    "username": "KarryJodd",
    "submission": "class MinSumSegTree {\n\n    public static class Pair{\n        int sum;\n        int max;\n        Pair(){}\n        Pair(int sum, int max){\n            this.sum = sum;\n            this.max = max;\n        }\n    }\n\n    public static class SegmentTree {\n        static Pair[] tree;\n        static int[] arr;\n\n        SegmentTree(int[] arr) {\n            this.arr = arr;\n            this.tree = new Pair[arr.length*4];\n            build(1, 0, arr.length-1);\n        }\n\n        public static void build(int node, int start, int end) {\n            if (start == end) {\n                tree[node] = new Pair(arr[start], arr[start]);\n            } else {\n                int mid = (start + end) >> 1;\n                build(node << 1, start, mid);\n                build(node <<1 + 1, mid + 1, end);\n                tree[node] = calc(tree[node<<1], tree[node<<1 + 1]);\n            }\n        }\n\n        public static Pair calc(Pair left, Pair right){\n            Pair ans = new Pair();\n            ans.sum =Math.max(left.max + right.max, Math.max(left.sum, right.sum));\n            ans.max = Math.max(left.max, right.max);\n            return ans;\n        }\n\n        public static void update(int node, int start, int end, int idx, int val) {\n            if (start == end) {\n                arr[start] = val;\n                tree[node].max = tree[node].sum = val;\n            } else {\n                int mid = (start + end) >> 1;\n                if (start <= idx && idx <= mid) {\n                    update(node*2, start, mid, idx, val);\n                } else {\n                    update(node<<2 +1, mid+1, end, idx, val);\n                }\n                tree[node] = calc(tree[node<<2], tree[node<<2 + 1]);\n            }\n        }\n\n        public static Pair query(int node, int start, int end, int l, int r) {\n            if (end < l || r < start) {\n                return new Pair(0, 0);\n            }\n\n            if (start == end) return tree[node];\n            else if (l <= start && end <= r) {\n                return tree[node];\n            } else {\n                int mid = (start + end)>>1;\n                Pair left = query(node<<2, start, mid, l,  r);\n                Pair right = query(node<<2 + 1, mid+1, end, l, r);\n                return calc(left, right);\n            }\n        }\n    }\n}\n\nclass Solution {\n    public int minChanges(int[] nums, int k) {\n        Map<Integer, List<Integer>> hm = new HashMap<>();\n        List<Integer> differences = new ArrayList<>();\n        int n = nums.length, ans = n;\n        \n        for (int i = 0; i < n / 2; i++) {\n            int a = nums[i], b = nums[n - i - 1];\n            int d = Math.abs(a - b);\n            int max = Math.max(Math.max(a, b), Math.max(k - a, k - b));\n            \n            if (!hm.containsKey(d)) hm.put(d, new ArrayList<>());\n            hm.get(d).add(max);\n            \n            differences.add(max);\n        }\n        \n        Collections.sort(differences);\n        \n        for (Map.Entry<Integer, List<Integer>> entry : hm.entrySet()) {\n            int diff = entry.getKey();\n            List<Integer> arr = entry.getValue();\n            \n            int cnt = binarySearch(differences, diff);\n            \n            if (cnt < 0) cnt = - (cnt + 1);\n            cnt = cnt * 2 + (n / 2 - cnt);\n            \n            for (int x : arr) {\n                cnt -= (x < diff) ? 2 : 1;\n            }\n            \n            ans = Math.min(ans, cnt);\n        }\n        \n        return ans;\n    }\n    \n    private int binarySearch(List<Integer> arr, int src) {\n        int low = 0, high = arr.size() - 1;\n        \n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (arr.get(mid) < src) low = mid + 1;\n            else high = mid;\n        }\n        \n        return low;\n    }\n}\n\nclass MaxSumSegTree {\n\n    public static class Pair{\n        int sum;\n        int max;\n        Pair(){}\n        Pair(int sum, int max){\n            this.sum = sum;\n            this.max = max;\n        }\n    }\n\n    public static class SegmentTree {\n        static Pair[] tree;\n        static int[] arr;\n\n        SegmentTree(int[] arr) {\n            this.arr = arr;\n            this.tree = new Pair[arr.length*4];\n            build(1, 0, arr.length-1);\n        }\n\n        public static void build(int node, int start, int end) {\n            if (start == end) {\n                tree[node] = new Pair(arr[start], arr[start]);\n            } else {\n                int mid = (start + end) >> 1;\n                build(node << 1, start, mid);\n                build(node <<1 + 1, mid + 1, end);\n                tree[node] = calc(tree[node<<1], tree[node<<1 + 1]);\n            }\n        }\n\n        public static Pair calc(Pair left, Pair right){\n            Pair ans = new Pair();\n            ans.sum =Math.max(left.max + right.max, Math.max(left.sum, right.sum));\n            ans.max = Math.max(left.max, right.max);\n            return ans;\n        }\n\n        public static void update(int node, int start, int end, int idx, int val) {\n            if (start == end) {\n                arr[start] = val;\n                tree[node].max = tree[node].sum = val;\n            } else {\n                int mid = (start + end) >> 1;\n                if (start <= idx && idx <= mid) {\n                    update(node*2, start, mid, idx, val);\n                } else {\n                    update(node<<2 +1, mid+1, end, idx, val);\n                }\n                tree[node] = calc(tree[node<<2], tree[node<<2 + 1]);\n            }\n        }\n\n        public static Pair query(int node, int start, int end, int l, int r) {\n            if (end < l || r < start) {\n                return new Pair(0, 0);\n            }\n\n            if (start == end) return tree[node];\n            else if (l <= start && end <= r) {\n                return tree[node];\n            } else {\n                int mid = (start + end)>>1;\n                Pair left = query(node<<2, start, mid, l,  r);\n                Pair right = query(node<<2 + 1, mid+1, end, l, r);\n                return calc(left, right);\n            }\n        }\n    }\n}\n",
    "submit_ts": "1721489682",
    "subm_id": "1327460621"
}