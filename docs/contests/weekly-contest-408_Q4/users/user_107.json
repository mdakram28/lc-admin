{
    "username": "BZH110",
    "submission": "\nclass DSU{\npublic:\n    vector<int> pa, size;\n    DSU(int n){\n        pa.resize(n);\n        size.resize(n, 1);\n        iota(pa.begin(), pa.end(), 0);\n    }\n\n    int find(int x){\n        return pa[x] == x ? x : (pa[x] = find(pa[x]));\n    }\n\n    void merge(int x, int y){ // x -> y\n        x = find(x);\n        y = find(y);\n        if(x == y)\n            return;\n        pa[x] = y;\n        size[y] += size[x];\n    }\n};\n\nclass Solution {\npublic:\n    using ll = long long;\n    ll mypow(ll a, ll b, ll mod = LLONG_MAX) {\n        if (b == 0)\n            return 1;\n        if (b % 2 == 0)\n            return mypow((a * a) % mod, b / 2, mod);\n        return (a * mypow((a * a) % mod, b / 2, mod)) % mod;\n    }\n    bool touch(vector<int>& a, vector<int>& b){\n        if(pow(a[0] - b[0], 2) + pow(a[1] - b[1], 2) <= pow(a[2] + b[2], 2))\n            return true;\n        return false;\n    }\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n        DSU d(n + 5);\n        for(int i=0;i<n;i++){\n            auto& c = circles[i];\n            int lx = c[0] - c[2], rx = c[0] + c[2];\n            int ly = c[1] - c[2], ry = c[1] + c[2];\n            if(lx <= 0 && rx >= 0)\n                d.merge(i, n);\n            if(lx <= X && rx >= X)\n                d.merge(i, n + 1);\n            if(ly <= 0 && ry >= 0)\n                d.merge(i, n + 2);\n            if(ly <= Y && ry >= Y)\n                d.merge(i, n + 3);\n            for(int j=i+1;j<n;j++){\n                if(touch(c, circles[j]))\n                    d.merge(i, j);\n            }\n        }\n        if(d.find(n) == d.find(n + 1) || \n        d.find(n) == d.find(n + 2) || \n        d.find(n + 1) == d.find(n + 3) || \n        d.find(n + 2) == d.find(n + 3))\n            return false;\n        return true;\n    }\n};",
    "submit_ts": "1722135621",
    "subm_id": "1335707951"
}