{
    "username": "trisha_tomy",
    "submission": "class Solution {\n    int mod = 1000000007;\n    int dp[][];\n    public int numberOfPermutations(int n, int[][] requirements) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int k = 0;\n        for(int requirement[]: requirements){\n            map.put(requirement[0]+1, requirement[1]);\n            k = Math.max(k, requirement[1]);  //finding max k possible\n        }\n        dp = new int[n+1][k+1];\n        dp[0][0] = 1;\n        \n        for(int i = 1; i<n+1; i++){\n            //same as k inverse pairs\n            for(int j = 0; j<k+1; j++){\n                for(int pairs = 0; pairs<i; pairs++){\n                    if(j-pairs>=0){\n                        dp[i][j] = (dp[i][j] + dp[i-1][j-pairs])%mod;\n                    } \n                    \n                }\n            }\n\n            if(map.containsKey(i)){  //we have a requirement\n                int invCount = map.get(i);\n                for(int inv = 0; inv<k+1; inv++){\n                    if(inv!=invCount) dp[i][inv] = 0;  //reset so not considered for future\n                }\n            }\n        }\n\n        int ans = 0;\n        for(int i = 0; i<k+1; i++){\n            ans = (ans + dp[n][i])%mod;  //counting all final possibilities\n        }\n        return ans;\n    }\n}",
    "submit_ts": 1719071076.0
}