{
    "username": "Sajal2212",
    "submission": "#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <string>\n#include <tuple>\nusing namespace std;\n\nclass Solution {\npublic:\n    int waysToReachStair(int k) {\n        if (k == 0) return 2; // Special case: two ways to stay at stair 0\n\n        using State = tuple<int, int, bool>;\n        unordered_map<State, long long, hashState> memo;\n        queue<State> q;\n        unordered_set<State, hashState> visited;\n        \n        // Initial state: stair 1, jump 0, not went down last time\n        State initialState = {1, 0, false};\n        q.push(initialState);\n        memo[initialState] = 1;\n        visited.insert(initialState);\n\n        long long total_ways = 0;\n\n        while (!q.empty()) {\n            auto [stair, jump, went_down_last_time] = q.front();\n            q.pop();\n            \n            State currentState = {stair, jump, went_down_last_time};\n\n            // Move up to stair + 2^jump if it doesn't overflow\n            if (stair <= k) {\n                int up_stair = stair + (1 << jump);\n                if (up_stair <= k + 1) {\n                    State upState = {up_stair, jump + 1, false};\n                    if (!visited.count(upState)) {\n                        q.push(upState);\n                        visited.insert(upState);\n                    }\n                    memo[upState] += memo[currentState];\n                }\n            }\n\n            // Move down to stair - 1 (if not consecutive down move and not at stair 0)\n            if (stair > 0 && !went_down_last_time) {\n                int down_stair = stair - 1;\n                State downState = {down_stair, jump, true};\n                if (!visited.count(downState)) {\n                    q.push(downState);\n                    visited.insert(downState);\n                }\n                memo[downState] += memo[currentState];\n            }\n        }\n\n        // Summing up the results for reaching stair k\n        for (int jump = 0; jump <= 30; ++jump) {\n            State state1 = {k, jump, false};\n            State state2 = {k, jump, true};\n            if (memo.count(state1)) {\n                total_ways += memo[state1];\n            }\n            if (memo.count(state2)) {\n                total_ways += memo[state2];\n            }\n        }\n\n        return total_ways;\n    }\n\nprivate:\n    struct hashState {\n        size_t operator()(const tuple<int, int, bool>& state) const {\n            auto [stair, jump, went_down_last_time] = state;\n            return hash<int>()(stair) ^ hash<int>()(jump) ^ hash<bool>()(went_down_last_time);\n        }\n    };\n};\n",
    "submit_ts": 1716088409.0
}