{
    "username": "anusarati",
    "submission": "struct And\n{\n    int operator()(int a, int b)\n    {\n        return a & b;\n    }\n};\n\ntemplate <class DataType, class BinaryOp>\nclass SegmentTree\n{\npublic:\n    struct Node\n    {\n        int pos, left, right;\n        inline Node left_node() const { return {pos + 1, left, mid()}; }\n        inline int mid() const { return left + (right - left) / 2; }\n        inline Node right_node() const\n        {\n            return {pos + 2 * (mid() - left + 1), mid() + 1, right};\n        }\n    };\n    inline Node root() const { return {0, 0, (int)size() - 1}; };\n\n    SegmentTree(int count) : data(2 * count - 1)\n    {\n    }\n    void assign(int index, DataType x, Node node)\n    {\n        if (node.left <= node.right)\n        {\n            if (node.left < node.right)\n            {\n                if (index <= node.mid())\n                    assign(index, x, node.left_node());\n                else\n                    assign(index, x, node.right_node());\n                data[node.pos] =\n                    op(data[node.left_node().pos], data[node.right_node().pos]);\n            }\n            else\n            {\n                data[node.pos] = x;\n            }\n        }\n    }\n    size_t size() const { return (data.size() + 1) / 2; }\n    void assign(int index, DataType x) { return assign(index, x, root()); }\n    DataType find(int left, int right, Node node)\n    {\n        if (left > right)\n            return {};\n\n        // interval completely covered, don't need children\n        if (left == node.left && node.right == right)\n            return data[node.pos];\n\n        int mid = left + (right - left) / 2;\n\n        auto left_res = find(left, min(node.mid(), right), node.left_node());\n        auto right_res =\n            find(max(left, node.mid() + 1), right, node.right_node());\n        auto res = op(move(left_res), move(right_res));\n        return res;\n    }\n    DataType find(int left, int right) { return find(left, right, root()); }\n    template <class T>\n    SegmentTree(const vector<T> &source) : SegmentTree(source.size())\n    {\n        for (int i = 0; i < source.size(); ++i)\n        {\n            assign(i, source[i]);\n        }\n    }\n    void print(Node node)\n    {\n        printf(\"d %i p %i l %i r %i\\n\", data[node.pos], node.pos, node.left,\n               node.right);\n        if (node.left < node.right)\n        {\n            print(node.left_node());\n            print(node.right_node());\n        }\n    }\n    void print() { print(root()); }\n    void dbg()\n    {\n        for (int n : data)\n            cout << n << ' ';\n        cout << '\\n';\n    }\n\nprivate:\n    vector<DataType> data;\n    BinaryOp op;\n};\n\nstruct AndI\n{\n    int x = ~0;\n    AndI() : x(~0) {}\n    AndI(int y) : x(y) {}\n    operator int &() { return x; }\n    operator const int &() const { return x; }\n};\n\nclass Solution\n{\npublic:\n    int minimumDifference(vector<int> &nums, int k)\n    {\n        SegmentTree<AndI, And> seg(nums);\n        // expanding subarray can only decrease and\n        const int N = nums.size();\n        int best = 1e9;\n        int resume = 0;\n        for (int i = 0; i < N && resume < N; ++i)\n        {\n            resume = max(i, resume);\n            int cur = seg.find(i, resume);\n            best = min(best, abs(k - cur));\n            // cout << i << ' ' << resume << ' ' << cur << endl;\n            if (cur < k)\n                continue;\n            for (; resume < N; ++resume)\n            {\n                cur &= nums[resume];\n                best = min(best, abs(k - cur));\n                if (cur < k)\n                {\n                    break;\n                }\n            }\n        }\n        return best;\n    }\n};",
    "submit_ts": 1717299792.0
}