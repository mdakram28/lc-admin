{
    "username": "KarryJodd",
    "submission": "class SegmentTree {\n    int[] tree;\n    int n;\n\n    public SegmentTree(int[] arr) {\n        n = arr.length;\n        tree = new int[4 * n];\n        build(arr, 0, 0, n - 1);\n    }\n\n    public void build(int[] arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(arr, 2 * node + 1, start, mid);\n            build(arr, 2 * node + 2, mid + 1, end);\n            tree[node] = tree[2 * node + 1] & tree[2 * node + 2];\n        }\n    }\n\n    public int query(int l, int r) {\n        return query(0, 0, n - 1, l, r);\n    }\n\n    public int query(int node, int start, int end, int l, int r) {\n        if (r < start || end < l) {\n            return Integer.MAX_VALUE;\n        }\n        if (l <= start && end <= r) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int p1 = query(2 * node + 1, start, mid, l, r);\n        int p2 = query(2 * node + 2, mid + 1, end, l, r);\n        return p1 & p2;\n    }\n}\n\nclass Solution {\n    public int numberOfAlternatingGroups(int[] colors, int k) {\n        int N = colors.length, cnt = 0, len = 1;\n\n        for (int i = 1; i < N + k - 1; i++) {\n            int current = i%N, previous = (i-1)%N;\n            len = (colors[current] != colors[previous]) ? len+1 : 1;\n            if (len >= k) cnt++;\n        }\n\n        return cnt;\n    }\n}\n\nclass Trie {\n    // About trie Data Structure -\n    // This data structure is used to implement the following operations -\n    // 1. insert(word) - to insert a string in trie.\n    // 2. search(word) - to check if word is present in Trie or not.\n    // 3. startsWith(word) - to check if there is any string in the trie that starts with the given prefix string word.\n\n    // Initialise the data structure.\n    // Very similar to generic tree. Just like, we had an array in generic tree in every node, in trie also, we have\n    // an array of 26 length. (Reason - too obvious)\n\n    static class Node{\n        Node[] children;\n        boolean eow;\n\n        public Node() {\n            children = new Node[26];\n            for (int i = 0; i < 26; i++) children[i] = null;\n            eow = false;\n        }\n    }\n\n    static Node root = new Node();\n\n    public static void insert(String word) {\n        Node treeRoot = root;\n        for (int i = 0; i < word.length(); i++) {\n            int idx = word.charAt(i) - 'a';\n\n            if (treeRoot.children[idx] == null) {\n                treeRoot.children[idx] = new Node();\n            }\n\n            if (i == word.length() - 1) {\n                treeRoot.children[idx].eow = true;\n            }\n            treeRoot = treeRoot.children[idx];\n        }\n    }\n\n    public static boolean search(String word) {\n        Node treeRoot = root;\n        for (int i = 0; i < word.length(); i++) {\n            int idx = word.charAt(i) - 'a';\n            if (treeRoot.children[idx] == null) return false;\n            if (i == word.length() - 1) {\n                return treeRoot.children[idx].eow;\n            }\n            treeRoot = treeRoot.children[idx];\n        }\n        return false;\n    }\n\n    public static boolean prefixSearch(String word) {\n        Node treeRoot = root;\n\n        for (int i = 0; i < word.length(); i++) {\n            int idx = word.charAt(i) - 'a';\n            if (treeRoot.children[idx] == null) return false;\n            treeRoot = treeRoot.children[idx];\n        }\n\n        return true;\n    }\n\n    public static int countUniqueSubStrings(String word) {\n        // So, basically in this question, we need to find all the unique substrings of a\n        // given string. This can be done easily because all the unique substrings are just -\n        // \"All Prefix of all Suffix.\"\n\n        // STEPS -\n        // 1. Find all the suffixes of the word.\n        // 2. Make a trie out of these suffixes list.\n        // 3. Find all unique prefixes which is equal to the total number of nodes in trie.\n\n        // Step 1 & 2:\n        String[] suffixes = new String[word.length()];\n        for (int i = 0; i < word.length(); i++) {\n            suffixes[i] = word.substring(i);\n            insert(suffixes[i]);\n        }\n\n        Node treeRoot = root;\n\n        return countNodes(treeRoot);\n    }\n\n    public static int countNodes(Node treeRoot) {\n        if (treeRoot == null) return 0;\n\n        int cnt = 0;\n        for (int i = 0; i < 26; i++) {\n            if (treeRoot.children[i] != null) {\n                cnt += countNodes(treeRoot.children[i]);\n            }\n        }\n        return cnt + 1;\n    }\n}",
    "submit_ts": "1720280477",
    "subm_id": "1311790847"
}