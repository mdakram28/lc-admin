{
    "username": "LessThanExpert",
    "submission": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define ll long long\n#define ull unsigned ll\n#define float double\n#define ff first\n#define ss second\n#define all(up) up.begin(), up.end()\n#define sz(x) ((ll)x.ch())\n#define debug(x) cerr << #x << \" \" << x << \"\\n\";\n#define printans(okk) cout << (okk ? \"Yes\\n\" : \"No\\n\");\n#define uniq(up) up.erase(unique(all(up)), up.end());\n#define iofast ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\ntemplate <class T>\nusing oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nll getRandomNumber(ll l, ll r) { return uniform_int_distribution<ll>(l, r)(rng); }\nconst ll N = 5e4 + 2, MOD = 1e9 + 7, LOG = 18, INF = 1e18, inf = 1e9;\n\nclass Solution\n{\n    ll SubAND(ll L, ll R, vector<vector<ll>> &pf)\n    {\n        ll AND = 0;\n        for (ll i = 0; i < 32; i++)\n        {\n            if (pf[R][i] - pf[L - 1][i]==R-L+1)\n                AND |= (1LL << i);\n        }\n        return AND;\n    }\n    ll findANDLessEqualK(ll ind, ll n, vector<vector<ll>> &pf, ll k)\n    {\n        ll lo = ind, hi = n, val = SubAND(ind, ind, pf);\n        while (lo <= hi)\n        {\n            ll mid = (lo + hi) / 2;\n            if (SubAND(ind, mid, pf) <= k)\n            {\n                val = SubAND(ind, mid, pf);\n                hi = mid - 1;\n            }\n            else\n                lo = mid + 1;\n        }\n        return abs(k - val);\n    }\n    ll findANDGreaterEqualK(ll ind, ll n, vector<vector<ll>> &pf, ll k)\n    {\n        ll lo = ind, hi = n, val = SubAND(ind, ind, pf);\n        while (lo <= hi)\n        {\n            ll mid = (lo + hi) / 2;\n            if (SubAND(ind, mid, pf) >= k)\n            {\n                val = SubAND(ind, mid, pf);\n                lo = mid + 1;\n            }\n            else\n                hi = mid - 1;\n        }\n        return abs(k - val);\n    }\n\npublic:\n    ll minimumDifference(vector<int> &ar, ll k)\n    {\n        ll n = ar.size();\n        vector<vector<ll>> pf(n + 1, vector<ll>(32));\n        for (ll i = 1; i <= n; i++)\n        {\n            for (ll j = 0; j < 32; j++)\n            {\n                pf[i][j] = pf[i - 1][j];\n                if (ar[i - 1] & (1LL << j))\n                    pf[i][j]++;\n            }\n        }\n        ll ans = LLONG_MAX;\n        for (ll i = 1; i <= n; i++)\n        {\n            ans = min({ans, findANDLessEqualK(i, n, pf, k), findANDGreaterEqualK(i, n, pf, k)});\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1717300054.0
}