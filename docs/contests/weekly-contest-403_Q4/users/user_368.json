{
    "username": "Sariabell",
    "submission": "class Solution {\npublic:\n    int minimumSum(vector<vector<int>>& grid) {\n        int a1 = eval(grid);\n\n        int ny = grid.size();\n        int nx = grid.front().size();\n        vector<vector<int>> g(nx, vector<int>(ny));\n        for (int x = 0; x < nx; ++x) {\n            for (int y = 0; y < ny; ++y) {\n                g[x][y] = grid[y][x];\n            }\n        }\n        int a2 = eval(g);\n        return min(a1, a2);\n    }\n\n    int eval(vector<vector<int>>& grid) {\n        int ny = grid.size();\n        int nx = grid.front().size();\n\n        int s = 0;\n        vector<int> v(nx);\n        for (int x = 0; x < nx; ++x) {\n            int p = 0;\n            for (int y = 0; y < ny; ++y) {\n                if (grid[y][x]) {\n                    p |= 1 << y;\n                    ++s;\n                }\n            }\n            v[x] = p;\n        }\n\n        auto count = [&](int xl, int xr, int yl, int yr) {\n            int ymask = 0;\n            for (int y = yl; y <= yr; ++y) {\n                ymask |= 1 << y;\n            }\n            while (xl < xr && !(v[xl] & ymask))\n                ++xl;\n            while (xl < xr && !(v[xr] & ymask))\n                --xr;\n            int cnt = 0;\n            int yreal = 0;\n            for (int x = xl; x <= xr; ++x) {\n                int b = v[x] & ymask;\n                cnt += __builtin_popcount(b);\n                yreal |= b;\n            }\n\n            int h = 0;\n            while (yreal && !(yreal & 1))\n                yreal >>= 1;\n            while (yreal) {\n                yreal >>= 1;\n                ++h;\n            }\n            int sz = h * (xr - xl + 1);\n            return pair<int, int>(sz, cnt);\n        };\n\n        int ans = ny * nx;\n        for (int g1x = 0; g1x <= nx - 1; ++g1x) {\n            for (int g1y = 0;g1y <= ny - 1; ++g1y) {\n                auto [g1sz, g1cnt] = count(0, g1x, 0, g1y);\n                if (g1cnt == 0) continue;\n\n                for (int x_mid = 0; x_mid <= g1x; ++x_mid) {\n                    auto [g2sz, g2cnt] = count(0, x_mid, g1y + 1, ny - 1);\n                    if (g2cnt == 0) continue;\n\n                    auto [g3sz_h, g3cnt_h] = count(x_mid + 1, nx - 1, g1y + 1, ny - 1);\n                    auto [g3sz_v, g3cnt_v] = count(g1x + 1, nx - 1, 0, ny - 1);\n\n                    if (0 < g3cnt_h && g1cnt + g2cnt + g3cnt_h == s)\n                        ans = min(ans, g1sz + g2sz + g3sz_h);\n                    if (0 < g3cnt_v && g1cnt + g2cnt + g3cnt_v == s)\n                        ans = min(ans, g1sz + g2sz + g3sz_v);\n                }\n\n                for (int x_mid = g1x + 1; x_mid < nx - 1; ++x_mid) {\n                    auto [g3sz, g3cnt] = count(x_mid + 1, nx - 1, 0, ny - 1);\n                    if (g3cnt == 0) continue;\n\n                    auto [g2sz_h, g2cnt_h] = count(0, x_mid, g1y + 1, ny - 1);\n                    auto [g2sz_v, g2cnt_v] = count(g1x + 1, x_mid, 0, ny - 1);\n                    if (0 < g2cnt_h && g1cnt + g2cnt_h + g3cnt == s)\n                        ans = min(ans, g1sz + g2sz_h + g3sz);\n                    if (0 < g2cnt_v && g1cnt + g2cnt_v + g3cnt == s)\n                        ans = min(ans, g1sz + g2sz_v + g3sz);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1719114367.0
}