{
    "username": "drizzlo",
    "submission": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#define INF 0x3f3f3f3f3f3f3f3f\nusing namespace std;\n\nstruct edge {\n  int v, f, c, next;\n} e[1000005];\n\nstruct node {\n  int v, e;\n} p[10005];\n\nstruct mypair {\n  int dis, id;\n\n  bool operator<(const mypair& a) const { return dis > a.dis; }\n\n  mypair(int d, int x) { dis = d, id = x; }\n};\n\n#define int long long\nint head[5005], dis[5005], vis[5005], h[5005];\nint n, m, s, t, cnt = 1, maxf, minc;\n#undef int\n\nvoid addedge1(int u, int v, int f, int c) {\n  e[++cnt].v = v;\n  e[cnt].f = f;\n  e[cnt].c = c;\n  e[cnt].next = head[u];\n  head[u] = cnt;\n}\n\nvoid addedge(int u, int v, int f, int c) {\n  addedge1(u,v,f,c);\n  addedge1(v,u,0,-c);\n}\n\nbool dijkstra() {\n  priority_queue<mypair> q;\n  for (int i = 1; i <= n; i++) dis[i] = INF;\n  memset(vis, 0, sizeof(vis));\n  dis[s] = 0;\n  q.push(mypair(0, s));\n  while (!q.empty()) {\n    int u = q.top().id;\n    q.pop();\n    if (vis[u]) continue;\n    vis[u] = 1;\n    for (int i = head[u]; i; i = e[i].next) {\n      int v = e[i].v, nc = e[i].c + h[u] - h[v];\n      if (e[i].f && dis[v] > dis[u] + nc) {\n        dis[v] = dis[u] + nc;\n        p[v].v = u;\n        p[v].e = i;\n        if (!vis[v]) q.push(mypair(dis[v], v));\n      }\n    }\n  }\n  return dis[t] != INF;\n}\n\nvoid spfa() {\n  queue<int> q;\n  memset(h, 0x3f, sizeof(h));\n  h[s] = 0, vis[s] = 1;\n  q.push(s);\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    vis[u] = 0;\n    for (int i = head[u]; i; i = e[i].next) {\n      int v = e[i].v;\n      if (e[i].f && h[v] > h[u] + e[i].c) {\n        h[v] = h[u] + e[i].c;\n        if (!vis[v]) {\n          vis[v] = 1;\n          q.push(v);\n        }\n      }\n    }\n  }\n}\n\nvoid MCMF() {\n  spfa();  // \u5148\u6c42\u51fa\u521d\u59cb\u52bf\u80fd\n  while (dijkstra()) {\n    long long minf = INF;\n    for (int i = 1; i <= n; i++) h[i] += dis[i];\n    for (int i = t; i != s; i = p[i].v) minf = min(minf, (long long) e[p[i].e].f);\n    for (int i = t; i != s; i = p[i].v) {\n      e[p[i].e].f -= minf;\n      e[p[i].e ^ 1].f += minf;\n    }\n    maxf += minf;\n    minc += minf * h[t];\n  }\n}\nclass Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& a) {\n        memset(head,0,sizeof head);\n        memset(dis,0,sizeof dis);\n        memset(vis,0,sizeof vis);\n        memset(h,0,sizeof h);\n        n=0, m=0, s=0, t=0, cnt = 1, maxf=0, minc=0;\n        int n=a.size(),m=a[0].size();\n        s=n+m+1;\n        int _t=n+m+2;\n        t=n+m+3;\n        for(int i=1;i<=n;++i)addedge(s,i,1,0);\n        for(int i=1;i<=m;++i)addedge(n+i,_t,1,0);\n        for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)addedge(i,n+j,1,-a[i-1][j-1]);\n        addedge(_t,t,3,0);\n        ::n=n+m+3;\n        MCMF();\n        assert(maxf==3);\n        return -minc;\n    }\n};",
    "submit_ts": "1723907063",
    "subm_id": "556323334"
}