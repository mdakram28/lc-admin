{
    "username": "wayjiang",
    "submission": "class Solution {\npublic:\n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n        long long ans = 0;\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            target[i] -= nums[i];\n        }\n        vector<int> v{abs(target[0])};\n        for (int i = 1; i < n; ++i) {\n            if (target[i] == 0) {\n                ans += minNumberOperations(v);\n                v.clear();\n            }\n            else if (target[i] > 0 == target[i - 1] > 0) {\n                v.push_back(abs(target[i]));\n            } else {\n                ans += minNumberOperations(v);\n                v.clear();\n                v.push_back(abs(target[i]));\n            }\n        }\n        if (v.size()) ans += minNumberOperations(v);;\n        return ans;\n    }\n    vector<pair<int, int>> mn; // node-> {mn, pos}\n    vector<int> target;\n    int n;\n    long long minNumberOperations(vector<int>& target) {\n        if (target.empty()) return 0;\n        this->target = target;\n        n = target.size();\n        mn.resize(n * 4);\n        for (int i = 0; i < n; ++i)\n            update(1, 1, n, i + 1, target[i]);\n        return DFS(0, 0, n - 1);\n    }\n    long long DFS(int base, int L, int R) {\n        if (L > R) return 0;\n        if (L == R) return target[L] - base;\n                \n        auto [minVal, pos] = queryMin(1, 1, n, L + 1, R + 1);\n        pos--; // 1-index in segment tree\n        long long sum = minVal - base + DFS(minVal, L, pos - 1) + DFS(minVal, pos + 1, R);\n        return sum;\n    }\n    void update(int o, int l, int r, int idx, int val) {\n        if (l == r) {\n            mn[o] = {val, idx};\n            return;\n        }\n        int m = (l + r) / 2;\n        if (idx <= m) \n            update(o * 2, l, m, idx, val);\n        else \n            update(o * 2 + 1, m + 1, r, idx, val);\n        // maintain\n        if (mn[o * 2].first < mn[o * 2 + 1].first)\n            mn[o] = mn[o * 2];\n        else\n            mn[o] = mn[o * 2 + 1];\n    }\n    \n    pair<int, int> queryMin(int o, int l, int r, int L, int R) { \n\t\tif (r < L || l > R) return {INT_MAX, 0};\n        if (L <= l && r <= R) return mn[o];\n        int m = (l + r) / 2;\n        auto A = queryMin(o * 2, l, m, L, R);\n        auto B = queryMin(o * 2 + 1, m + 1, r, L, R);\n        return A.first < B.first ? A : B;\n    }\n      \n};",
    "submit_ts": "1721532215",
    "subm_id": "1327980512"
}