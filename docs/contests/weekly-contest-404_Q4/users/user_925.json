{
    "username": "WRWRW",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int: \n        def get_g(edges):\n            g = defaultdict(list)\n            for a, b in edges:\n                g[a].append(b)\n                g[b].append(a)\n            return g\n        g1, g2 = get_g(edges1), get_g(edges2)\n        def find_d(g, node, p=None):\n            if len(g) == 0:\n                return [1], 0\n            d = 1\n            lls = []\n            for child in g[node]:\n                if child != p:\n                    ll, dd = find_d(g, child, node)\n                    d = max(d, dd)\n                    l = max(ll)\n                    heapq.heappush(lls, l + 1)\n                    if len(lls) > 2:\n                        heapq.heappop(lls)\n            if not lls:\n                lls = [1]\n            if len(lls) > 1:\n                a, b = lls[0], lls[1]\n                d = max(d, a + b - 2)\n            else:\n                d = max(lls[0] - 1, d)\n            # print(node, lls, d)\n            return lls, d\n        ll1, dd1 = find_d(g1, 0)\n        ll2, dd2 = find_d(g2, 0)\n        # print( ll1, dd1)\n        # print( ll2, dd2)\n        # if len(g1) == len(g2) == 0:\n        #     return 1 \n        # if len(g1) == 0:\n        #     return dd2\n        # if len(g2) == 0:\n        #     return dd1\n        return max(dd1, dd2, ceil(dd1 / 2) + ceil(dd2 / 2) + 1)",
    "submit_ts": 1719719779.0
}