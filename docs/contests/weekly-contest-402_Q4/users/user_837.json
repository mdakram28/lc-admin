{
    "username": "abhik2003",
    "submission": "\nclass SegmentTree\n{\n    vector<int> v, tree;\n    int N;\n\npublic:\n    SegmentTree(vector<int> &v_)\n    {\n        int n = v_.size();\n        N = n;\n        v = v_;\n        tree.resize(n * 4);\n        build(1, 0, n - 1);\n    }\n    void build(int node, int st, int en)\n    {\n        if (st == en)\n        {\n            if (st == 0 || st == (N - 1)){\n                tree[node] = 0;\n                return;\n            }\n            if(v[st-1]<v[st] && v[st]>v[st+1])\n                tree[node] = 1; // peak\n            return;\n        }\n        int mid = (st + en) / 2;\n        build(node * 2, st, mid);\n        build(node * 2 + 1, mid + 1, en);\n\n        tree[node] = tree[node * 2] + tree[node * 2 + 1]; // total peaks\n    }\n\n    void update(int node, int index, int st, int en, int val)\n    {\n        if (st == en)\n        {\n            cout<<st<<index<<endl;\n            v[index] = val;\n            if (st == 0 || st == (N - 1))\n            {\n                tree[node] = 0;\n                return;\n            }\n            if (v[st - 1] < v[st] && v[st] > v[st + 1])\n                tree[node] = 1; // peak\n            else\n                tree[node] = 0;\n            return;\n\n        }\n        int mid = (st + en) / 2;\n        if (index <= mid)\n        {\n            update(node * 2, index, st, mid, val);\n        }\n        else\n        {\n            update(node * 2 + 1, index, mid + 1, en, val);\n        }\n        tree[node] = tree[node * 2] + tree[node * 2 + 1]; // total peaks\n    }\n    \n    int query(int node, int st, int en, int l, int r)\n    {\n        // l...st..en...r   whole subarray\n        if (l <= st && r >= en)\n        {\n            return tree[node];\n        }\n\n        // st..en l..r ||  l..r st..en  out of subarray\n        if (en < l || st > r)\n        {\n            return 0; //****\n        }\n\n        int mid = (st + en) / 2;\n        int q1 = query(node * 2, st, mid, l, r);\n        int q2 = query(node * 2 + 1, mid+1, en, l, r);\n\n        return q1+q2; \n    }\n};\n\nclass Solution\n{\npublic:\n    vector<int> countOfPeaks(vector<int> &nums, vector<vector<int>> &queries)\n    {\n        vector<int> ans;\n        SegmentTree *ST = new SegmentTree(nums);\n        int n = nums.size();\n        for (auto it : queries)\n        {\n            if(it[0]==1){\n                int l = it[1] + 1;\n                int r = it[2] - 1;\n                if(l<=r){\n                    ans.push_back(ST->query(1, 0, n - 1, l, r));\n                }\n                else{\n                    ans.push_back(0);\n                }\n            }\n            else{\n                int l = it[1];\n                int r = it[2];\n                nums[l] = r;\n                ST->update(1, l, 0, n - 1, r);\n                if(l>0)ST->update(1, l-1, 0, n - 1, nums[l-1]);\n                if(l<(n-1))ST->update(1, l+1, 0, n - 1, nums[l+1]);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718508284.0
}