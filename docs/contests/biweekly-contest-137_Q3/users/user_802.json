{
    "username": "Asmit Papney",
    "submission": "class Solution {\npublic:\n\n    long long t[102][104][104];\n    vector<vector<vector<vector<int>>>> sparseTable;\n    \n    long long Solve(vector<vector<int>>&A, int row, int col1, int col2){\n        if(row == A.size()) return -1e15;\n        \n        long long Ans = -1e15;\n        \n        if(t[row][col1][col2]!=-1)\n            return t[row][col1][col2];\n        \n        if(col1 != 102 && col2!= 102){\n            // also swap if col1 > col2\n            if(col1 > col2) swap(col1, col2) ;\n            // row,0  to n-1,col1-1  \n            // row,col1+1  to n-1,col2-1\n            // row,col2+1 to n-1, m-1\n            long long option1 = querySparseTable(row, 0, A.size()-1, col1-1);\n            long long option2 = querySparseTable(row, col1+1, A.size()-1, col2-1);\n            long long option3 = querySparseTable(row, col2+1, A.size()-1, A[0].size()-1);\n                \n            return max(option1, max(option2, option3));\n        }\n        \n        Ans = max(Ans, Solve(A, row+1, col1, col2)) ;\n                 \n        for(int i=0; i<A[0].size(); i++){\n            if(i==col1 || i==col2) continue ;\n            \n            if(col1 == 102)\n                Ans = max(Ans, Solve(A, row+1, i, col2) + A[row][i] );\n            else if(col2 == 102)\n                Ans = max(Ans, Solve(A, row+1, col1, i) + A[row][i]);\n        }\n        \n        \n        return t[row][col1][col2] = Ans;\n    }\n    \n    void buildSparseTable(vector<vector<int>>& matrix) {\n        int rows = matrix.size();\n        int cols = matrix[0].size();\n        int logRows = log2(rows) + 1;\n        int logCols = log2(cols) + 1;\n\n        // Initialize sparse table\n        sparseTable.assign(logRows, vector<vector<vector<int>>>(logCols, vector<vector<int>>(rows,vector<int>(cols))));\n\n        // Base case: 2D sparse table for submatrices of size 1x1\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                sparseTable[0][0][i][j] = matrix[i][j];\n            }\n        }\n\n        // Build sparse table\n        for (int i = 0; (1 << i) <= rows; ++i) {\n            for (int j = 0; (1 << j) <= cols; ++j) {\n                for (int r = 0; r + (1 << i) - 1 < rows; ++r) {\n                    for (int c = 0; c + (1 << j) - 1 < cols; ++c) {\n                        if (i == 0 && j == 0) {\n                            sparseTable[i][j][r][c] = matrix[r][c];\n                        } else if (i == 0) {\n                            sparseTable[i][j][r][c] = max(sparseTable[i][j-1][r][c], sparseTable[i][j-1][r][c + (1 << (j-1))]);\n                        } else if (j == 0) {\n                            sparseTable[i][j][r][c] = max(sparseTable[i-1][j][r][c], sparseTable[i-1][j][r + (1 << (i-1))][c]);\n                        } else {\n                            sparseTable[i][j][r][c] = max({\n                                sparseTable[i-1][j-1][r][c],\n                                sparseTable[i-1][j-1][r + (1 << (i-1))][c],\n                                sparseTable[i-1][j-1][r][c + (1 << (j-1))],\n                                sparseTable[i-1][j-1][r + (1 << (i-1))][c + (1 << (j-1))]\n                            });\n                        }\n                    }\n                }\n            }\n        }\n    }\n        \n    long long querySparseTable(int topLeftRow, int topLeftCol, int bottomRightRow, int bottomRightCol) {\n        \n        if(topLeftCol > bottomRightCol) return -1e15;\n        \n        long long  logRows = log2(sparseTable.size());\n        long long  logCols = log2(sparseTable[0].size());\n\n        long long  rowRange = bottomRightRow - topLeftRow + 1;\n        long long  colRange = bottomRightCol - topLeftCol + 1;\n\n        long long  kRow = log2(rowRange);\n        long long  kCol = log2(colRange);\n\n        long long  maxVal = max({\n            sparseTable[kRow][kCol][topLeftRow][topLeftCol],\n            sparseTable[kRow][kCol][bottomRightRow - (1 << kRow) + 1][topLeftCol],\n            sparseTable[kRow][kCol][topLeftRow][bottomRightCol - (1 << kCol) + 1],\n            sparseTable[kRow][kCol][bottomRightRow - (1 << kRow) + 1][bottomRightCol - (1 << kCol) + 1]\n        });\n\n        return maxVal;\n    }\n    \n    long long maximumValueSum(vector<vector<int>>& board) {\n        memset(t,-1,sizeof(t));\n        buildSparseTable(board);\n        return Solve(board, 0, 102, 102);\n    }\n};",
    "submit_ts": "1723909601",
    "subm_id": "1359198752"
}