{
    "username": "yrclamb",
    "submission": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        Map<Integer, Set<Integer>> tree1 = new HashMap<>();\n        Map<Integer, Set<Integer>> tree2 = new HashMap<>();\n        \n        for(int[] e : edges1){\n            Set<Integer> set = tree1.getOrDefault(e[0], new HashSet<Integer>());\n            set.add(e[1]);\n            tree1.put(e[0], set);\n            \n            set = tree1.getOrDefault(e[1], new HashSet<Integer>());\n            set.add(e[0]);\n            tree1.put(e[1], set);\n        }\n        \n        for(int[] e : edges2){\n            Set<Integer> set = tree2.getOrDefault(e[0], new HashSet<Integer>());\n            set.add(e[1]);\n            tree2.put(e[0], set);\n            \n            set = tree2.getOrDefault(e[1], new HashSet<Integer>());\n            set.add(e[0]);\n            tree2.put(e[1], set);\n        }\n        \n        int[] t1 = mid(tree1);\n        int[] t2 = mid(tree2);\n        \n        int ans = Math.max(t1[1], t2[1]);\n        ans = Math.max(ans, t1[0] + t2[0] + 1);\n        return  ans;\n                \n    }\n    \n    private int[] mid(Map<Integer, Set<Integer>> tree){\n       // System.out.println(tree);\n        Queue<Integer> Q = new LinkedList<>();\n        Q.add(0);\n        Set<Integer> visited = new HashSet<>();\n        visited.add(0);\n        \n        int dist = -1 ;\n        int lastNode = 0;\n        while(!Q.isEmpty()){\n            dist++;\n            \n            int size = Q.size();\n            for(int i = 0; i < size; i++){\n                int cur = Q.poll();\n                for(int next : tree.getOrDefault(cur, new HashSet<Integer>())){\n                    if(!visited.contains(next)){\n                        visited.add(next);\n                        Q.add(next);\n                        lastNode = next;\n                    }\n                }\n            }\n        }\n     //   System.out.println(\"dist 0 = \" + dist);\n        \n        Q = new LinkedList<>();\n        Q.add(lastNode);\n        visited = new HashSet<>();\n        visited.add(lastNode);\n        dist = -1;\n        while(!Q.isEmpty()){\n            dist++;\n           // System.out.println(\"dist = \" + dist + \", Q = \" + Q);\n            int size = Q.size();\n            for(int i = 0; i < size; i++){\n                int cur = Q.poll();\n                for(int next : tree.getOrDefault(cur, new HashSet<Integer>())){\n                    if(!visited.contains(next)){\n                        visited.add(next);\n                        Q.add(next);\n                    }\n                }\n            }\n        }\n        int ret = dist / 2;\n        if(dist % 2 != 0) ret++;\n     //   System.out.println(\"dist \" + lastNode + \" = \" + dist);\n     //   System.out.println(\"return: \" + ret);\n        return new int[]{ret, dist};\n    }\n}",
    "submit_ts": 1719718627.0
}