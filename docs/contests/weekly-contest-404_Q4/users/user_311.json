{
    "username": "Ankitsisodya",
    "submission": "\n\nclass Solution\n{\npublic:\n    int diameter = 0;\n\n    int dfs(int u, int p, vector<int> adj[])\n    {\n\n        deque<int> val;\n        for (auto &v : adj[u])\n            if (v != p)\n            {\n                val.emplace_back(dfs(v, u, adj));\n                sort(val.begin(), val.end());\n                if (val.size() > 2)\n                    val.pop_front();\n            }\n        int l1 = 0, l2 = 0;\n        if (val.size() == 2)\n            l1 = val[0], l2 = val[1];\n        if (val.size() == 1)\n            l2 = val[0];\n\n        diameter = max(diameter, l1 + l2);\n        return val.size() ? val[val.size() - 1] + 1 : 1;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>> &edges1, vector<vector<int>> &edges2)\n    {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        vector<int> adj1[n + 1], adj2[m + 1];\n        for (auto &p : edges1)\n        {\n            int u = ++p[0], v = ++p[1];\n            adj1[u].push_back(v);\n            adj1[v].push_back(u);\n        }\n        for (auto &p : edges2)\n        {\n            int u = ++p[0], v = ++p[1];\n            adj2[u].push_back(v);\n            adj2[v].push_back(u);\n        }\n        dfs(1, 0, adj1);\n        int dia1 = diameter;\n        diameter = 0;\n        dfs(1, 0, adj2);\n        int dia2 = diameter;\n        diameter = 0;\n        int ans = max(dia1, dia2);\n\n        auto bfs = [&](int node, vector<int> &d, vector<int> adj[])\n        {\n            pair<int, int> p;\n            queue<int> q;\n            q.push(node);\n            d[node] = 0;\n            while (q.size())\n            {\n                auto u = q.front();\n                q.pop();\n                for (auto &v : adj[u])\n                {\n                    if (d[u] + 1 < d[v])\n                    {\n                        d[v] = d[u] + 1;\n                        q.push(v);\n                    }\n                }\n            }\n        };\n        // vector<int> d(n + 1, INT_MAX);\n        // bfs(1, d, adj1);\n        // int start1 = -1, maxi = -1;\n        // for (int i = 1; i <= n; ++i)\n        // {\n        //     if (d[i] > maxi)\n        //     {\n        //         maxi = d[i];\n        //         start1 = i;\n        //     }\n        //     d[i] = INT_MAX;\n        // }\n        // bfs(start1, d, adj1);\n        // int end1 = -1;\n        // maxi = -1;\n        // for (int i = 1; i <= n; ++i)\n        // {\n        //     if (d[i] > maxi)\n        //     {\n        //         maxi = d[i];\n        //         start1 = i;\n        //     }\n        //     d[i] = INT_MAX;\n        // }\n        if (dia1 % 2 == dia2 % 2 && dia1 % 2 == 1)\n            return max(ans, (dia1 / 2) + (dia2 / 2) + 3);\n        else if (dia1 % 2 == dia2 % 2 && dia1 % 2 == 0)\n        {\n            return max(ans, (dia1 / 2) + (dia2 / 2) + 1);\n        }\n        return max({dia1, dia2, ((dia1) / 2 )+ ((dia2) / 2) + 2});\n    }\n};",
    "submit_ts": 1719718133.0
}