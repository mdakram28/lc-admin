{
    "username": "areke",
    "submission": "class Solution {\npublic:\n    \n    void dfs(int x, vector<vector<int> > & v, vector<int> & d, int last = -1) {\n        if (last != -1) {\n            d[x] = d[last] + 1;\n        }\n        for (int n : v[x]) {\n            if (n == last) continue;\n            dfs(n, v, d, x);\n        }\n    }\n    \n    int diam(vector<vector<int> > & edges) {\n        int n = edges.size() + 1;\n        vector<vector<int> > v(n);\n        for (int i = 0; i < edges.size(); i++) {\n            v[edges[i][0]].push_back(edges[i][1]);\n            v[edges[i][1]].push_back(edges[i][0]);\n        }\n        vector<int> d(n, 0);\n        dfs(0, v, d);\n        int b = 0;\n        for (int i = 0; i < n; i++) {\n            if (d[i] > d[b]) b = i;\n        }\n        vector<int> d2(n, 0);\n        dfs(b, v, d2);\n        int ret = 0;\n        for (int i = 0; i < n; i++) {\n            if (d2[i] > ret) ret = d2[i];\n        }\n        return ret;\n        \n    }\n    \n    vector<int> get_c(vector<vector<int> > & edges) {\n        set<int> s;\n        \n        \n        int n = edges.size() + 1;\n        vector<vector<int> > v(n);\n        for (int i = 0; i < edges.size(); i ++) {\n            v[edges[i][0]].push_back(edges[i][1]);\n            v[edges[i][1]].push_back(edges[i][0]);\n            s.insert(i);\n        }\n        \n        vector<int> c(n, 0);\n        for (int i = 0; i < n; i++) {\n            s.insert(i);\n        }\n        for (int i =0; i < edges.size(); i++) {\n            c[edges[i][0]]++;\n            c[edges[i][1]]++;\n        }\n        queue<int> q;\n        for (int i = 0; i < c.size(); i++) {\n            if (c[i] == 1) {\n                q.push(i);\n            }\n        }\n        int rem = n;\n        while (rem > 2) {\n            rem -= q.size();\n            int o = q.size();\n            for (int i = 0; i < o; i++) {\n                int cur = q.front();\n                s.erase(s.find(cur));\n                q.pop();\n                for (int n : v[cur]) {\n                    c[n]--;\n                    if (c[n] == 1) {\n                        q.push(n);\n                    }\n                }\n            }\n        }\n        \n        vector<int> ret(s.begin(), s.end());\n        return ret;\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        vector<int> c = get_c(edges1);\n        vector<int> d = get_c(edges2);\n        vector<vector<int> > v(edges1.begin(), edges1.end());\n        int n = edges1.size() + 1;\n        for (int i = 0; i < edges2.size(); i++) {\n            v.push_back((vector<int>){n + edges2[i][0], n + edges2[i][1]});\n        }\n        int res = 0;\n        for (int x : c) {\n            for (int y : d) {\n                v.push_back({x, y + n});\n                res = max(res, diam(v));\n                v.pop_back();\n            }\n        }\n        return res;\n        \n    }\n};",
    "submit_ts": 1719718056.0
}