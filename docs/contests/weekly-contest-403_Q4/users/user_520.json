{
    "username": "AshutoshSingh10",
    "submission": "\t#include <bits/stdc++.h>\n\tusing namespace std;\n\tusing std::cout;\n\tusing std::cin;\n\t#define endl '\\n'    \n\t#define ll long long\n\t#define loop(i,a,b) for(long long i=a;i<b;i++)\n\t#define roop(i,a,b) for(long long i=a-1;i>=b;i--)\n\t#define all(p) p.begin(),p.end()\n\t#define pb(p) push_back(p);\n\tlong long pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}\n\ttemplate<class T> using _pq = priority_queue<T>;\n\ttemplate<class T> using _pqr = priority_queue<T, vector<T>, greater<T>>;\n\ttemplate<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}\n\ttemplate<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}\n\t#include <ext/pb_ds/assoc_container.hpp>\n    #include <ext/pb_ds/tree_policy.hpp>\n    using namespace __gnu_pbds;\n    #include<iostream>\n    template <class T> using OrderSet = tree<T, null_type, \n    less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n    ll lcm(ll a, ll b){return (a/__gcd(a,b)*b);}\n    const ll INF= LONG_LONG_MAX;\nll calc(vector<ll> x)\n{\n\tif(x[1]==INT_MAX || x[0]==INT_MAX || x[2]==INT_MAX || x[3]==INT_MAX) return 0;\n    return (x[1]-x[0]+1) * (x[3]-x[2]+1);\n\n}\n\n    void minimumArea(vector<vector<int>>& grid,vector<vector<ll>> &pre) {\n\t\t\tll xl=INT_MAX;\n\t\t\tll xs=0;\n\t\t\tll yl=INT_MAX;\n\t\t\tll ys=0;\n\t\t\tint n=grid.size();\n            int m=grid[0].size();\n\t\t\tloop(i,0,n)\n\t\t\t{\n\t\t\t\tloop(j,0,m)\n\t\t\t\t{\n\t\t\t\t\tif(grid[i][j]==1)\n\t\t\t\t\t{\n\t\t\t\t\t\txl=min(i,xl);\n\t\t\t\t\t\txs=max(i,xs);\n                        \n\t\t\t\t\t\tyl=min(j,yl);\n\t\t\t\t\t\tys=max(j,ys);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpre.push_back({xl,xs,yl,ys});\n\t\t\t}\n    }\n\n\t  ll nope(vector<vector<int>>& grid) {\n          if(grid.size()==0) return 0;\n          ll cnt=0;\n\t\t\tll xl=INT_MAX;\n\t\t\tll xs=0;\n\t\t\tll yl=INT_MAX;\n\t\t\tll ys=0;\n\t\t\tint n=grid.size();\n            int m=grid[0].size();\n\t\t\tloop(i,0,n)\n\t\t\t{\n\t\t\t\tloop(j,0,m)\n\t\t\t\t{\n\t\t\t\t\tif(grid[i][j]==1)\n\t\t\t\t\t{\n                        cnt++;\n\t\t\t\t\t\txl=min(i,xl);\n\t\t\t\t\t\txs=max(i,xs);\n                        \n\t\t\t\t\t\tyl=min(j,yl);\n\t\t\t\t\t\tys=max(j,ys);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n          if(cnt==0)return 0;\n\t\t\treturn calc({xl,xs,yl,ys});\n    }\n\n    ll fun(vector<vector<int>>& grid) \n\t{\n\t\tll ans=INT_MAX;\n\t\tvector<vector<ll>> pre;\n\t\tminimumArea(grid,pre);\n\t\tint n=grid.size();\n\t\tint m=grid[0].size();\n\t\tfor(int i=n-1;i>=0;i--)\n\t\t{\n\t\t\tvector<vector<ll>> fix;\n\t\t\tll xl=INT_MAX;\n\t\t\tll xs=0;\n\t\t\tll yl=INT_MAX;\n\t\t\tll ys=0;\n\t\t\tfor(ll j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tfor(ll k=n-1;k>=i;k--)\n\t\t\t\t{\n\t\t\t\t\tif(grid[k][j]==1)\n\t\t\t\t\t{\n\t\t\t\t\t\txl=min(k,xl);\n\t\t\t\t\t\txs=max(k,xs);\n                        \n\t\t\t\t\t\tyl=min(j,yl);\n\t\t\t\t\t\tys=max(j,ys);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n                fix.push_back({xl,xs,yl,ys});\n\t\t\t}\n\t\t\txl=INT_MAX;\n\t\t\txs=0;\n\t\t\tyl=INT_MAX;\n\t\t\tys=0;\n\n\t\t\tfor(ll j=m-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tfor(ll k=n-1;k>=i;k--)\n\t\t\t\t{\n\t\t\t\t\tif(grid[k][j]==1)\n\t\t\t\t\t{\n\t\t\t\t\t\txl=min(k,xl);\n\t\t\t\t\t\txs=max(k,xs);\n                        \n\t\t\t\t\t\tyl=min(j,yl);\n\t\t\t\t\t\tys=max(j,ys);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n                \n                ll a=0;\n                if(j) a=calc(fix[j-1]);\n                ll b=0;\n                if(i) b=calc(pre[i-1]);\n\t\t\t\tans=min(ans,a+b+calc({xl,xs,yl,ys})\n\t\t\t\t);\n                // cout<<ans<<\"->\";\n                \n\t\t\t}\n            \n        // cout<<endl;\n\n\n\t\t}\n        cout<<ans<<endl;\n    if(ans==INT_MAX) return 0;\n\t\treturn ans;\n\t}\n\n\tll extra(vector<vector<int>>  grid)\n\t{\n\t\tint n=grid.size();\n\t\tll ans=INT_MAX;\n\t\tloop(i,0,n)\n\t\t{\n\t\t\tloop(j,i,n)\n\t\t\t{\n\t\t\t\tvector<vector<int>> x,y,z;\n\t\t\t\tfor(int k=0;k<i;k++)\n\t\t\t\t{\n\t\t\t\t\tx.push_back(grid[k]);\n\t\t\t\t}\n\t\t\t\tfor(int k=i;k<j;k++)\n\t\t\t\t{\n\t\t\t\t\ty.push_back(grid[k]);\n\t\t\t\t}\n\t\t\t\tfor(int k=j;k<n;k++)\n\t\t\t\t{\n\t\t\t\t\tz.push_back(grid[k]);\n\t\t\t\t}\n\n\t\t\t\tans=min(ans,nope(x)+nope(y)+nope(z));\n\n\n\t\t\t}\n\t\t\t\t\n\t\t}\n        cout<<\"annnnn\"<<ans;\n\t\t\n\nreturn ans;\n\t}\nclass Solution {\npublic:\n    int minimumSum(vector<vector<int>>& grid) {\n\n\t\tll ans=fun(grid);\n\t\tans=min(ans,extra(grid));\n\t\treverse(all(grid));\n        \n\t\tans=min(ans,fun(grid));\n\t\tint n=grid.size();\n\t\tint m=grid[0].size();\n\t\tvector<vector<int>> vec(m,vector<int>(n,0));\n\t\tloop(i,0,m)\n\t\t{\n\t\t\tloop(j,0,n)\n\t\t\t{\n\t\t\t\tvec[i][j]=grid[j][i];\n\t\t\t}\n\t\t}\n\t\tans=min(ans,fun(vec));\n\t\treverse(all(vec));\n\t\tans=min(ans,fun(vec));\n\t\tans=min(ans,extra(vec));\n\n        \n\t\treturn ans;\n\t\t\n        \n    }\n};",
    "submit_ts": 1719114869.0
}