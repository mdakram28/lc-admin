{
    "username": "bruteForce18",
    "submission": "class Solution {\n     int[] nums;\n     int[] segmentTree;\n\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        this.nums = nums;\n        int n = nums.length;\n        segmentTree = new int[4 * n];\n        \n        // Build initial Segment Tree with peak counts\n        build(0, 0, n - 1);\n        \n        List<Integer> result = new ArrayList<>();\n        for (int[] q : queries) {\n            int type = q[0];\n            if (type == 1) {\n                int li = q[1];\n                int ri = q[2];\n                if (li == ri) {\n                    result.add(0);\n                } else {\n                    result.add(query(0, 0, n - 1, li + 1, ri - 1));\n                }\n            } else if (type == 2) {\n                int index = q[1];\n                int value = q[2];\n                updateRange(index, value);\n            }\n        }\n        \n        return result;\n    }\n    \n    boolean isPeak(int i) {\n        if (i == 0 || i == nums.length - 1) \n            return false;\n        return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    }\n\n    private void build(int node, int start, int end) {\n        if (start == end) {\n            segmentTree[node] = isPeak(start) ? 1 : 0;\n        } else {\n            int mid = (start + end) / 2;\n            int leftChild = 2 * node + 1;\n            build(leftChild, start, mid);\n            int rightChild = 2 * node + 2;\n            build(rightChild, mid + 1, end);\n            segmentTree[node] = segmentTree[leftChild] + segmentTree[rightChild];\n        }\n    }\n\n    private void update(int node, int start, int end, int idx) {\n        if (start == end) {\n            segmentTree[node] = isPeak(idx) ? 1 : 0;\n        } else {\n            int mid = (start + end) / 2;\n            int leftChild = 2 * node + 1;\n            int rightChild = 2 * node + 2;\n            if (start <= idx && idx <= mid) {\n                update(leftChild, start, mid, idx);\n            } else {\n                update(rightChild, mid + 1, end, idx);\n            }\n            segmentTree[node] = segmentTree[leftChild] + segmentTree[rightChild];\n        }\n    }\n\n    private int query(int node, int start, int end, int left, int right) {\n        if (right < start || end < left) {\n            return 0;\n        }\n        if (left <= start && end <= right) {\n            return segmentTree[node];\n        }\n        int mid = (start + end) / 2;\n        int leftChild = 2 * node + 1;\n        int rightChild = 2 * node + 2;\n        int leftResult = query(leftChild, start, mid, left, right);\n        int rightResult = query(rightChild, mid + 1, end, left, right);\n        return leftResult + rightResult;\n    } \n    \n    private void updateRange(int index, int value) {\n        // Collect all indices to update\n        Set<Integer> indicesToUpdate = new HashSet<>();\n        indicesToUpdate.add(index);\n        if (index > 0) indicesToUpdate.add(index - 1);\n        if (index < nums.length - 1) indicesToUpdate.add(index + 1);\n\n        // Update the value\n        nums[index] = value;\n\n        // Iteratively update the peaks in the segment tree\n        for (int idx : indicesToUpdate) {\n            update(0, 0, nums.length - 1, idx);\n        }\n    }\n}\n",
    "submit_ts": 1718507891.0
}