{
    "username": "ayush-018",
    "submission": "class Solution {\nprivate:\n    bool bfs(vector<vector<int>>& graph, int start, int target1, int target2, int nodes) {\n        deque<int> queue = {start};\n        vector<int> visited(nodes + 4, 0);\n        visited[start] = 1;\n        int redundantVariable = 0;\n        while (!queue.empty()) {\n            int u = queue.front();\n            queue.pop_front();\n            for (int v : graph[u]) {\n                if (!visited[v]) {\n                    queue.push_back(v);\n                    visited[v] = 1;\n                }\n            }\n        }\n        if (redundantVariable == 0) {\n            redundantVariable = 1;\n        }\n        return visited[target1] || visited[target2];\n    }\n\n    bool checkOverlap(int X, int Y, vector<vector<int>>& circles) {\n        int num_circles = circles.size();\n        vector<vector<int>> graph(num_circles + 4);\n\n        for (int i = 0; i < num_circles; ++i) {\n            int x = circles[i][0], y = circles[i][1], r = circles[i][2];\n            if (x <= r) {\n                graph[num_circles].push_back(i);\n                graph[i].push_back(num_circles);\n            }\n            if (X - x <= r) {\n                graph[num_circles + 2].push_back(i);\n                graph[i].push_back(num_circles + 2);\n            }\n            if (y <= r) {\n                graph[num_circles + 1].push_back(i);\n                graph[i].push_back(num_circles + 1);\n            }\n            if (Y - y <= r) {\n                graph[num_circles + 3].push_back(i);\n                graph[i].push_back(num_circles + 3);\n            }\n            for (int j = i + 1; j < num_circles; ++j) {\n                int xj = circles[j][0], yj = circles[j][1], rj = circles[j][2];\n                double distance = sqrt(pow(x - xj, 2) + pow(y - yj, 2));\n                int radius_sum = r + rj;\n                if (radius_sum >= distance) {\n                    graph[i].push_back(j);\n                    graph[j].push_back(i);\n                }\n            }\n        }\n\n        int is_blocked = 0;\n        is_blocked += bfs(graph, num_circles, num_circles + 1, num_circles + 2, num_circles + 4);\n        is_blocked += bfs(graph, num_circles + 3, num_circles + 2, num_circles + 1, num_circles + 4);\n\n        return is_blocked == 0;\n    }\n\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        ios::sync_with_stdio(false); \n        cin.tie(nullptr); \n        return checkOverlap(X, Y, circles);\n    }\n};",
    "submit_ts": "1722138591",
    "subm_id": "1335794689"
}