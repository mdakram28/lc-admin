{
    "username": "PyIsTheBestLang",
    "submission": "import heapq\nfrom collections import deque\nfrom math import inf\nfrom typing import List\n\n\n# from sortedcontainers import SortedList\n# sys.set_int_max_str_digits(0)  # for big number in leet code\n\n\ndef max(a, b):\n    return a if a > b else b\n\n\ndef min(a, b):\n    return a if a < b else b\n\n\nclass DinicMaxflowMinCost:\n    def __init__(self, n):\n        self.n = n\n        self.vis = [0] * (self.n + 1)\n        self.point_head = [0] * (self.n + 1)\n        self.edge_capacity = [0] * 2\n        self.edge_cost = [0] * 2\n        self.edge_to = [0] * 2\n        self.edge_next = [0] * 2\n        self.h = [inf] * (self.n + 1)\n        self.dis = [inf] * (self.n + 1)\n        self.max_flow = 0\n        self.min_cost = 0\n        self.edge_id = 2\n        self.pre_edge = [0] * (self.n + 1)\n        self.pre_point = [0] * (self.n + 1)\n\n    def _add_single_edge(self, u, v, cap, c):\n        self.edge_capacity.append(cap)\n        self.edge_cost.append(c)\n        self.edge_to.append(v)\n        self.edge_next.append(self.point_head[u])\n        self.point_head[u] = self.edge_id\n        self.edge_id += 1\n        return\n\n    def add_edge(self, u, v, cap, c):\n        # assert 1 <= u <= self.n\n        # assert 1 <= v <= self.n\n        self._add_single_edge(u, v, cap, c)\n        self._add_single_edge(v, u, 0, -c)\n        return\n\n    def _spfa(self, s):\n        self.h[s] = 0\n        q = deque([s])\n        self.vis[s] = 1\n        while q:\n            u = q.popleft()\n            self.vis[u] = 0\n            i = self.point_head[u]\n            while i:\n                v = self.edge_to[i]\n                if self.edge_capacity[i] > 0 and self.h[v] > self.h[u] + self.edge_cost[i]:\n                    self.h[v] = self.h[u] + self.edge_cost[i]\n                    if not self.vis[v]:\n                        q.append(v)\n                        self.vis[v] = 1\n                i = self.edge_next[i]\n        return\n\n    def _dijkstra(self, s, t):\n        for i in range(1, self.n + 1):\n            self.dis[i] = inf\n            self.vis[i] = 0\n        self.dis[s] = 0\n        q = [(0, s)]\n        while q:\n            d, u = heapq.heappop(q)\n            if self.vis[u]:\n                continue\n            self.vis[u] = 1\n            i = self.point_head[u]\n            while i:\n                v = self.edge_to[i]\n                nc = self.h[u] - self.h[v] + self.edge_cost[i]\n                if self.edge_capacity[i] > 0 and self.dis[v] > self.dis[u] + nc:\n                    self.dis[v] = self.dis[u] + nc\n                    self.pre_edge[v] = i\n                    self.pre_point[v] = u\n                    if not self.vis[v]:\n                        heapq.heappush(q, (self.dis[v], v))\n                i = self.edge_next[i]\n        return self.dis[t] < inf\n\n    def max_flow_min_cost(self, s, t):\n        self._spfa(s)\n        while self._dijkstra(s, t):\n            for i in range(1, self.n + 1):\n                self.h[i] += self.dis[i]\n\n            cur_flow = inf\n            v = t\n            while v != s:\n                i = self.pre_edge[v]\n                c = self.edge_capacity[i]\n                cur_flow = cur_flow if cur_flow < c else c\n                v = self.pre_point[v]\n\n            v = t\n            while v != s:\n                i = self.pre_edge[v]\n                self.edge_capacity[i] -= cur_flow\n                self.edge_capacity[i ^ 1] += cur_flow\n                v = self.pre_point[v]\n\n            self.max_flow += cur_flow\n            self.min_cost += cur_flow * self.h[t]\n\n        return self.max_flow, self.min_cost\n\n\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        flow = DinicMaxflowMinCost(m+n+4)\n        for i in range(m):\n            for j in range(n):\n                flow.add_edge(i+1+1, m+j+1+1, 1, -board[i][j])\n        for i in range(m):\n            flow.add_edge(1, i+1+1, 1, 0)\n        for j in range(n):\n            flow.add_edge(m+j+1+1, m+n+1+1, 1, 0)\n\n        flow.add_edge(m+n+1+2, 1, 3, 0)\n        flow.add_edge(m+n+1+1, m + 1+ n + 3, 3, 0)\n        ans = flow.max_flow_min_cost(m+n+1+2, m+1+n+3)\n        return -ans[1]",
    "submit_ts": "1723906802",
    "subm_id": "556321818"
}