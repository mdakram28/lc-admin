{
    "username": "liketheflower",
    "submission": "class Tree:\n    def treeDiameter(self, edges: List[List[int]]) -> int:\n        if not edges:\n            return 0\n        def dfs(u, t):\n            nonlocal ans, vis, d, next\n            if vis[u]:\n                return\n            vis[u] = True\n            for v in d[u]:\n                dfs(v, t + 1)\n            if ans < t:\n                ans = t\n                next = u\n\n        d = defaultdict(set)\n        vis = [False] * (len(edges) + 1)\n        for u, v in edges:\n            d[u].add(v)\n            d[v].add(u)\n        ans = 0\n        next = 0\n        dfs(edges[0][0], 0)\n        vis = [False] * (len(edges) + 1)\n        dfs(next, 0)\n        return ans\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n       \n        t1 = Tree()\n        t2 = Tree()\n        \n        ret1 =  t1.treeDiameter(edges1) \n        ret2 = t2.treeDiameter(edges2)\n        \"\"\"\n        if not edges1 or not edges2:\n            return max(ret1, ret2)\n        \"\"\"\n        \n        \n        ht1 = ret1 // 2\n        ht1_remain = ret1 - ht1\n        ht2 = ret2 // 2\n        ht2_remain = ret2 - ht2\n        #print(ret1, ret2)\n        ret = max(ht1, ht1_remain) + max(ht2, ht2_remain) + 1\n        return max([ret1, ret2, ret])\n\n\"\"\"\n[[0,1],[2,0],[3,2],[3,6],[8,7],[4,8],[5,4],[3,5],[3,9]]\n[[0,1],[0,2],[0,3]]\n\nshould be 7 instead of 6\n\"\"\"\n",
    "submit_ts": "1719718512",
    "subm_id": "1304419053"
}