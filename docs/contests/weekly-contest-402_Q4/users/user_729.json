{
    "username": "em_priyank",
    "submission": "class Solution {\npublic:\n\n    void build(vector<int>& tree,const vector<int>& data,int start,int end,int node) {\n        if (start==end) {\n            tree[node]=data[start];\n        } \n        else{\n            int mid=start+(end-start)/2;\n            build(tree,data,start,mid,2*node+1);\n            build(tree,data,mid+1,end,2*node+2);\n            tree[node]=tree[2*node+1]+tree[2*node+2];\n        }\n    }\n\n    void update(vector<int>& tree,int start,int end,int idx,int value,int node){\n        if (start==end){\n            tree[node]=value;\n        }\n        else{\n            int mid=start+(end-start)/2;\n            if (idx<=mid){\n                update(tree,start,mid,idx,value,2*node+1);\n            } \n            else{\n                update(tree,mid+1,end,idx,value,2*node+2);\n            }\n            tree[node]=tree[2*node+1]+tree[2*node+2];\n        }\n    }\n\n    int query(const vector<int>& tree,int start,int end,int L,int R,int node){\n        if (L>end || R<start){\n            return 0;\n        }\n        if (L<=start && end<=R){\n            return tree[node];\n        }\n        int mid=start+(end-start)/2;\n        return query(tree,start,mid,L,R,2*node+1)+query(tree,mid+1,end,L,R,2*node+2);\n    }\n\n\n    vector<int> countOfPeaks(vector<int>& A,vector<vector<int>>& queries){\n\n        \n        int n=A.size();\n        vector<int> peaks(n,0);\n\n        auto che=[&](int i){\n            return i>0 && i<n-1 && A[i]>A[i-1] && A[i]>A[i+1];\n        };\n\n        for (int i=1;i<n-1;++i){\n            if (che(i)){\n                peaks[i]=1;\n            }\n        }\n\n        vector<int> tree(4*n,0);\n        build(tree,peaks,0,n-1,0);\n\n        vector<int> ans;\n        for (auto& q:queries) {\n            \n            \n            if (q[0]==1){\n                int li=q[1];\n                int ri=q[2];\n                ans.push_back(query(tree,0,n-1,li+1,ri-1,0));\n                \n            } \n            else{\n                \n                \n                int index=q[1];\n                int val=q[2];\n\n                if (index>0 && che(index-1)) {\n                    update(tree,0,n-1,index-1,0,0);\n                }\n                if (che(index)) {\n                    update(tree,0,n-1,index,0,0);\n                }\n                if (index<n-1 && che(index+1)) {\n                    update(tree,0,n-1,index+1,0,0);\n                }\n\n                A[index]=val;\n\n                if (index>0 && che(index-1)) {\n                    update(tree,0,n-1,index-1,1,0);\n                }\n                if (che(index)) {\n                    update(tree,0,n-1,index,1,0);\n                }\n                if (index<n-1 && che(index+1)) {\n                    update(tree,0,n-1,index+1,1,0);\n                }\n                \n            }\n        }\n\n        return ans;\n    }\n    \n};\n",
    "submit_ts": 1718508037.0
}