{
    "username": "Jyotheeswar",
    "submission": "class Tree {\npublic:\n   map <int ,int > l;\n   int best;\n   int node;\n   int dfs(int v, bool* visited, vector <int> graph[], int c = 0){\n      visited[v] = true;\n      int ans = 0;\n      for(int i = 0; i < graph[v].size(); i++){\n         if(!visited[graph[v][i]])ans = max(ans,dfs(graph[v][i], visited, graph, c+1));\n      }\n      if(c > best){\n         best = c;\n         node = v ;\n      }\n      visited[v] = false;\n      return max(c,ans);\n   }\n   int treeDiameter(vector<vector<int>>& e) {\n      int n = e.size();\n      vector <int> graph[n+1];\n      for(int i = 0; i < n; i++){\n         graph[e[i][0]].push_back(e[i][1]);\n         graph[e[i][1]].push_back(e[i][0]);\n      }\n      bool* visited = new bool[n+1]();\n      best = 0;\n      node = 0;\n      dfs(0, visited, graph);\n      bool* visited2 = new bool[n+1]();\n      return dfs(node, visited2, graph);\n   }\n};\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        Tree ob1, ob2;\n        // cout<<ob1.treeDiameter(edges1)<<\" \"<<ob2.treeDiameter(edges2)<<\"\\n\";\n        int d1 = ob1.treeDiameter(edges1), d2 = ob2.treeDiameter(edges2);\n        int ans = max(d1, d2);\n        return max(ans, ((d1 + 1) / 2) + ((d2 + 1) / 2) + 1);\n        // return ((ob1.treeDiameter(edges1) + 1) / 2) + (( + 1) / 2) + 1;\n    }\n};",
    "submit_ts": "1719719435",
    "subm_id": "1304441886"
}