{
    "username": "sourashisHmm",
    "submission": "class Solution {\npublic:\n    int findCenter(int n, vector<vector<int>>& edges) {\n        if (n == 1) return 0;\n        vector<unordered_set<int>> adj(n);\n        for (const auto &e: edges) {\n            int u = e[0], v = e[1];\n            adj[u].insert(v);\n            adj[v].insert(u);\n        }\n\n        queue<int> q;\n        for (int u = 0; u < n; ++u) {\n            //degree == 1\n            if (adj[u].size() <= 1)\n                q.push(u);\n        }\n        int remNodes = n; //remaining nodes\n        while (remNodes > 2) {\n            int layerSize = q.size();\n            remNodes -= layerSize;\n            for (int i = 0; i < layerSize; ++i) {    \n                int u = q.front();\n                q.pop();\n\n                //remove u\n                //v is the only connected node to u now\n                int v = *adj[u].begin();\n                adj[v].erase(u);\n                adj[u].erase(v);\n\n                if (adj[v].size() == 1) \n                    q.push(v);\n            }\n        }\n\n        return q.front();\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    vector<int> hMemo1, hMemo2;\n    \n    \n    int h(int root, int parent, vector<unordered_set<int>> &adj, vector<int> &memo) {\n        if (memo[root] != -1) return memo[root];\n        int res = 0;\n        for (int v: adj[root]) {\n            if (v == parent) continue;\n            res = max(res, h(v, root, adj, memo));\n        }\n        return memo[root] = (1 + res);\n    }\n    \n    int height(int root, int n, vector<vector<int>> &edges, vector<int> &memo) {\n        vector<unordered_set<int>> adj(n);\n        for (const auto &e: edges) {\n            int u = e[0], v = e[1];\n            adj[u].insert(v);\n            adj[v].insert(u);\n        }\n        \n        return h(root, -1, adj, memo);\n    }\n    \n    \n    \n    \n    \n    int diam(int c, int n, vector<vector<int>> &edges, vector<int> &memo) {\n        vector<unordered_set<int>> adj(n);\n        for (const auto &e: edges) {\n            int u = e[0], v = e[1];\n            adj[u].insert(v);\n            adj[v].insert(u);\n        }\n        \n        \n        \n        vector<int> childHeights;\n        for (int v: adj[c]) {\n            childHeights.push_back(h(v, c, adj, memo));\n        }\n        \n        if (childHeights.size() == 0)\n            return 1;\n        \n        sort(childHeights.begin(), childHeights.end());\n        \n        int res = childHeights.back();\n        if (childHeights.size() > 1)\n            res += childHeights[childHeights.size() - 2];\n        \n        ++res;\n        \n        // printf(\"\\ndiam: root=%d, childHeights: \", c);\n        // for (int x: childHeights)\n        //     cout << x << \", \";\n        return res;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        // int res = INT_MAX;\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        \n        if (n == 1 && m == 1) return 1;\n        // if (n == 1) return \n        \n        int c1 = findCenter(n, edges1);\n        int c2 = findCenter(m, edges2);\n        \n        // printf(\"\\nc1=%d, c2=%d,\", c1,c2);\n        // printf(\"\\nh1 = %d, h2=%d\", height(c1, n, edges1), height(c2, m, edges2));\n        \n        \n        \n        hMemo1 = vector<int>(n + 1, -1);\n        hMemo2 = vector<int>(m + 1, -1);\n        \n        int res = height(c1, n, edges1, hMemo1) + height(c2, m, edges2, hMemo2) - 1;\n        \n        // printf(\"\\nh1 = %d, h2=%d\", height(c1, n, edges1, hMemo1), height(c2, m, edges2, hMemo2));\n        // printf(\"\\nd1 = %d, d2=%d\", diam(c1, n, edges1, hMemo1), diam(c2, m, edges2, hMemo2));\n        \n        res = max({res, diam(c1, n, edges1, hMemo1) - 1, diam(c2, m, edges2, hMemo2) - 1});\n        return res;\n    }\n};",
    "submit_ts": 1719719488.0
}