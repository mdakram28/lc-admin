{
    "username": "adityaraj_19",
    "submission": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b)   for (int i = (a);i < (b); ++i)\n#define RFOR(i, a, b)  for (int i = (a);i > (b); --i)\n#define Traverse(i, a) for(auto& i : a)\n#define all(x)         std::begin(x), std::end(x)\n#define rall(x)        std::end(x), std::begin(x)\n#define nl             \"\\n\"\n#define ff             first\n#define ss             second\n#define eb             emplace_back\n#define sz(x)          ((ll)(x).size())\n#define yes            cout << \"Yes\\n\"\n#define no             cout << \"No\\n\"\n#define set_bits       __builtin_popcountll\nusing ll = long long int;\nusing vi = vector<int>;\nusing vs = vector<string>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\n\nconst auto boostIO = []() {\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    cout << fixed; cout.precision(12);\n    return 0;\n}();\n\nconst ll N = 1e6 + 7;\nconst ll MOD = 1e9 + 7; // 998244353;\n\n/* Direction Array */\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n// int dx[] = {0, 0, 1, -1, -1, 1, -1, 1};\n// int dy[] = { -1, 1, 0, 0, 1, 1, -1, -1};\n\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate <class T> \nusing pbds =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T> void print(T && x) {cout << x << \"\\n\";}\ntemplate<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' '; print(y...);}\ntemplate<typename T> T isqrt(const T &x){T y = sqrtl(x + 2); while(y * y > x) y--; return y;}\ntemplate<class T> bool chmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool chmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ninline int ceil(int a, int b) { return (a + b - 1ll) / b; }\ninline int gcd(int x, int y) { return x ? gcd(y % x, x) : y; }\nstatic bool cmp(pii &a, pii &b) { return a.ss > b.ss; }\n\n// int power(int base, int exp, const int M = MOD) {\n//     int result = 1;\n//     base %= M;\n//     while (exp) {\n//         if (exp & 1)\n//             result = (result * base) % M;\n//         base = (base * base) % M;\n//         exp >>= 1;\n//     }\n//     return result;\n// }\n// int modInverse(int a, int m) { return power(a, m - 2);}\n\n// int fact[N], invf[N];\n// void Precompute() {\n//     fact[0] = 1;\n//     for (int i = 1; i < N; ++i) {\n//         fact[i] = (fact[i - 1] * i);\n//     }\n\n//     invf[N - 1] = modInverse(fact[N - 1], MOD);\n//     for (int i = N - 2; i >= 0; --i) {\n//         invf[i] = (invf[i + 1] * (i + 1));\n//     }\n// }\n\n// int ncr(int n, int r) {\n//     if (r < 0 or n < r) return 0;\n//     return (fact[n] * ((invf[r] * invf[n - r])));\n// }\n\n\nll ncr(ll n, ll k) {\n    if (k > n) return 0;\n    if (k == 0 || k == n) return 1;\n    ll result = 1;\n    for (ll i = 1; i <= k; ++i) {\n        result *= (n - i + 1);\n        result /= i;\n    }\n    return result;\n}\n\nclass Solution {\npublic:\n    int waysToReachStair(int k) {\n        // Precompute();\n        ll ans = 0;\n        FOR(i, 0, 32) {\n            int r = (1ll << i) - k;\n            if(r >= 0)\n                ans += ncr(i + 1, r);\n        }\n        return ans;\n    }\n};\n\n// #define LOCAL\n#ifdef LOCAL\nint main()\n{\n    Solution s;\n    // cout<<\"Ans:\"<<s.runSoln(20)<<\":Fn\"<<endl;\n    // cout<<\"Ans:\"<<s.runSoln(100)<<\":Fn\"<<endl;\n    // cout<<\"Ans:\"<<s.runSoln(1000)<<\":Fn\"<<endl;\n    return 0;\n}\n#endif\n\n\n\n\n\n",
    "submit_ts": 1716089436.0
}