{
    "username": "goku_2022",
    "submission": "class Solution {\npublic:\n    class helper {\n    public:\n        vector<pair<int, int>> we;\n        map<char, helper*> mpp;\n        int index;\n    };\n\n    class Trie {\n    public:\n        helper* root = NULL;\n        Trie() { root = new helper(); }\n        void add(string& word, int cost, int i) {\n            helper* node = root;\n            for (int j = 0; j < word.size(); j++) {\n                if (node->mpp.find(word[j]) == node->mpp.end()) {\n                    node->mpp[word[j]] = new helper();\n                    node = node->mpp[word[j]];\n                } else {\n                    node = node->mpp[word[j]];\n                }\n            }\n            node->we.push_back({i, cost});\n        }\n        void countWordsEqualTo(string& word) {}\n\n        void countWordsStartingWith(string& word) {}\n    };\n\n    int minimumCost(string tt, vector<string>& words, vector<int>& costs) {\n        Trie trie;\n        int n = tt.size();\n        int m = words.size();\n        vector<int> v(tt.size() + 1, INT_MAX);\n        v[0] = 0;\n\n        for (int i = 0; i < m; ++i) {\n            trie.add(words[i], costs[i], i);\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (v[i] != INT_MAX) {\n                helper* node = trie.root;\n                for (int j = i; j < n; j++) {\n                    // map<char, helper*> mp = node->mpp;\n                    if (node->mpp.find(tt[j]) != node->mpp.end()) {\n                        node = node->mpp[tt[j]];\n                        // vector<pair<int, int>> vp = node->we;\n                        int si = node->we.size();\n                        for (int k = 0; k < node->we.size(); k++){\n                                pair<int,int>vp=node->we[k];\n                            if (i + words[vp.first].size() <= n)\n                                if (v[i + words[vp.first].size()] <\n                                    v[i] + vp.second)\n                                    v[i + words[vp.first].size()] =\n                                        v[i + words[vp.first].size()];\n                                else\n                                    v[i + words[vp.first].size()] =\n                                        v[i] + vp.second;\n                        }\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n        if (v[tt.size()] == INT_MAX) {\n            return -1;\n        }\n        return v[n];\n    }\n};\n// class TrieVertex {\n// public:\n//     vector<TrieVertex*> children;\n//     int value;\n//     bool isEndOfWord;\n\n//     TrieVertex() : children(26, nullptr), value(INT_MAX), isEndOfWord(false) {}\n// };\n\n// class TrieTree {\n// public:\n//     TrieVertex* root;\n\n//     TrieTree() {\n//         root = new TrieVertex();\n//     }\n\n//     void addWord(const string& word, int cost) {\n//         TrieVertex* node = root;\n//         for (char c : word) {\n//             if (!node->children[c - 'a']) {\n//                 node->children[c - 'a'] = new TrieVertex();\n//             }\n//             node = node->children[c - 'a'];\n//         }\n//         node->value = min(cost, node->value);\n//         node->isEndOfWord = true;\n//     }\n\n//     TrieVertex* getRoot() {\n//         return root;\n//     }\n// };\n\n// class Solution {\n// public:\n//     int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n//         TrieTree trie;\n//         int length = target.size();\n//         vector<int> minimumCost(length + 1, INT_MAX);\n\n//         for (int i = 0; i < words.size(); ++i) {\n//             trie.addWord(words[i], costs[i]);\n//         }\n\n//         minimumCost[0] = 0;\n\n//         for (int i = 0; i < length; ++i) {\n//             if (minimumCost[i] == INT_MAX) continue;\n\n//             TrieVertex* node = trie.getRoot();\n//             for (int j = i; j < length; ++j) {\n//                 char c = target[j];\n//                 if (!node->children[c - 'a']) break;\n//                 node = node->children[c - 'a'];\n//                 if (node->isEndOfWord) {\n//                     minimumCost[j + 1] = min(minimumCost[j + 1], minimumCost[i] + node->value);\n//                 }\n//             }\n//         }\n\n//         return minimumCost[length] == INT_MAX ? -1 : minimumCost[length];\n//     }\n// };",
    "submit_ts": "1720324317",
    "subm_id": "1312396605"
}