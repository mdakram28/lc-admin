{
    "username": "purnawirman",
    "submission": "class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        path = [[0, n - 1]]\n        res = []\n        prev = n - 1\n\n        def overlap(path, q): # return count of removed path, new path\n            res = 0\n            npath = []\n\n            lo, hi = 0, len(path) - 1\n            while lo < hi:\n                mid = (lo + hi) // 2\n                if path[mid][1] >= q[0]:\n                    hi = mid\n                else:\n                    lo = mid + 1\n            start = lo\n\n            npath = path[:start]\n\n            for i, cand in enumerate(path[start:]):\n                if q[1] <= cand[0] or q[0] >= cand[1]: # no overlap\n                    npath.append(cand)\n                elif q[0] < cand[0] and q[1] > cand[1]: # 0 cand\n                    res += cand[1] - cand[0] + 1\n                else:\n                    if q[0] < cand[1] and q[1] > cand[1]: # 1 cand\n                        npath.append([cand[0], q[0]])\n                        res += cand[1] - q[0] \n                    elif q[1] > cand[0] and q[0] < cand[0]: # 1 cand\n                        npath.append([q[1], cand[1]])\n                        res += q[1] - cand[0] \n                    else:\n                        npath.append([cand[0], q[0]])\n                        npath.append([q[1], cand[1]])\n                        res += q[1] - q[0] - 1\n            return res, npath\n\n\n        for s, e in queries:\n            red, path = overlap(path, (s, e))\n            prev -= red\n            res.append(prev)\n        return res",
    "submit_ts": "1722743953",
    "subm_id": "1343803481"
}