{
    "username": "suizhiyuan",
    "submission": "use std::collections::BTreeMap;\n\nimpl Solution {\n    pub fn shortest_distance_after_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        let queries = queries\n            .iter()\n            .map(|v| Query {\n                start: v[0] as usize,\n                end: v[1] as usize,\n            })\n            .collect::<Vec<_>>();\n    \n        let mut collection = BTreeMap::<usize, &Query>::new();\n        let mut result = Vec::with_capacity(queries.len());\n        let mut change = 0;\n    \n        for q in queries.iter() {\n            let mut need_remove = vec![];\n            let last = collection.range(..=q.start).next_back();\n            if last.is_some() && last.unwrap().1.end >= q.end {\n                result.push(n - 1 - change);\n                continue;\n            }\n            for (k, v) in collection.range(q.start..q.end) {\n                if v.change() >= q.change() {\n                    break;\n                }\n    \n                change -= v.change();\n                need_remove.push(*k);\n            }\n    \n            for k in need_remove {\n                collection.remove(&k);\n            }\n            collection.insert(q.start, q);\n            change += q.change();\n            result.push(n - 1 - change);\n        }\n    \n        result\n    }\n}\n\nstruct Query {\n    start: usize,\n    end: usize,\n}\n\nimpl Query {\n    fn change(&self) -> i32 {\n        self.end as i32 - self.start as i32 - 1\n    }\n}",
    "submit_ts": "1722742173",
    "subm_id": "552342960"
}