{
    "username": "wolfenbitzyt",
    "submission": "#include <vector>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <set>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        \n        // Function to find the diameter of a tree\n        auto findDiameter = [](const vector<vector<int>>& edges, int nodes) {\n            vector<vector<int>> adj(nodes);\n            for (const auto& edge : edges) {\n                adj[edge[0]].push_back(edge[1]);\n                adj[edge[1]].push_back(edge[0]);\n            }\n            \n            auto bfs = [&](int start) {\n                vector<int> dist(nodes, -1);\n                queue<int> q;\n                q.push(start);\n                dist[start] = 0;\n                int farthest = start;\n                \n                while (!q.empty()) {\n                    int u = q.front();\n                    q.pop();\n                    for (int v : adj[u]) {\n                        if (dist[v] == -1) {\n                            dist[v] = dist[u] + 1;\n                            q.push(v);\n                            if (dist[v] > dist[farthest]) {\n                                farthest = v;\n                            }\n                        }\n                    }\n                }\n                return make_pair(farthest, dist[farthest]);\n            };\n            \n            auto [node1, _] = bfs(0);\n            auto [node2, diameter] = bfs(node1);\n            return diameter;\n        };\n        \n        int diameter1 = findDiameter(edges1, n);\n        int diameter2 = findDiameter(edges2, m);\n        \n        // Function to find the minimum maximum distance using rerooting\n        auto minMaxDistRerooting = [](const vector<vector<int>>& edges, int nodes) {\n            vector<vector<int>> adj(nodes);\n            for (const auto& edge : edges) {\n                adj[edge[0]].push_back(edge[1]);\n                adj[edge[1]].push_back(edge[0]);\n            }\n            \n            vector<int> dp(nodes, 0), d(nodes, 0);\n            \n            function<void(int, int)> dfs1 = [&](int u, int parent) {\n                for (int v : adj[u]) {\n                    if (v != parent) {\n                        dfs1(v, u);\n                        dp[u] = max(dp[u], dp[v] + 1);\n                    }\n                }\n            };\n            \n            function<void(int, int)> dfs2 = [&](int u, int parent) {\n                d[u] = dp[u];\n                multiset<int> dep;\n                for (int v : adj[u]) {\n                    dep.insert(dp[v] + 1);\n                }\n                for (int v : adj[u]) {\n                    if (v != parent) {\n                        int val = dp[v] + 1;\n                        int cur_val = dp[u];\n                        dep.erase(dep.find(val));\n                        int mx = dep.empty() ? 0 : *dep.rbegin();\n                        dep.insert(val);\n                        dp[u] = mx;\n                        dp[v] = max(dp[v], mx + 1);\n                        dfs2(v, u);\n                        dp[u] = cur_val;\n                        dp[v] = val - 1;\n                    }\n                }\n            };\n            \n            dfs1(0, -1);\n            dfs2(0, -1);\n            \n            return *min_element(d.begin(), d.end());\n        };\n        \n        int dis1 = minMaxDistRerooting(edges1, n);\n        int dis2 = minMaxDistRerooting(edges2, m);\n        \n        if (n == 0 && m > 0) return diameter2;\n        if (m == 0 && n > 0) return diameter1;\n        if (n == 0 && m == 0) return 0;\n        cout<<dis1<<\" \"<<dis2<<endl;\n        return max({diameter1, diameter2, dis1 + dis2 + 1});\n    }\n};\n",
    "submit_ts": 1719716472.0
}