{
    "username": "psshrivathsa784",
    "submission": "#define forz(i,a,b) for(int i = a;i<b;i++)\n\nvector<int> tree[100001];\nunordered_map<int,int> mp[100001];\nint dist[100001];\n\nint dfs1(int ver, int par){ // returns the max dist element in the subtree of ver\n    \n    int mxDist = 0;\n    for(int child: tree[ver]){\n        if (child != par){\n            dist[child] = dist[ver]+1+((child%2) == 0);\n            mp[ver][child] = dist[child]-dist[ver] + dfs1(child,ver);\n            mxDist = max(mxDist, mp[ver][child]);\n        }\n    }\n    return mxDist;\n}\n\nvoid dfs2(int ver, int par, int parDist, vector<int> &sol){\n    \n    int mxDist = parDist + 1 + (par%2 == 0);\n\n    vector<pair<int,int>> mul;\n    mul.push_back({mxDist,-1}); \n\n    for(int child: tree[ver]){\n        if (child != par){\n            mxDist = max(mxDist, mp[ver][child]);\n            mul.push_back({mp[ver][child],child});\n        }\n    }\n    sort(mul.rbegin(),mul.rend());\n\n    sol[ver] = mxDist;\n\n    for (int child: tree[ver]){\n        if (child != par){\n            if (mul[0].second == child){\n                dfs2(child, ver, mul[1].first,sol);\n            }\n            else{\n                dfs2(child, ver, mul[0].first,sol);\n            }\n        }\n    }\n}\n\nclass Solution {\npublic:\n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        int n = edges.size()+1;\n\n        forz(i,0,n){\n            tree[i].clear();\n            mp[i].clear();\n        }\n        dist[0] = 0;\n\n        forz(i,0,n-1){\n            tree[edges[i][0]].push_back(edges[i][1]);\n            tree[edges[i][1]].push_back(edges[i][0]);\n        }\n\n        vector<int> sol(n);\n        sol[0] = dfs1(0,-1);\n\n        dfs2(0,100001,-1,sol);\n\n        return sol;\n\n    }\n};",
    "submit_ts": "1722699393",
    "subm_id": "1343210266"
}