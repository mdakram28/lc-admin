{
    "username": "Andriy",
    "submission": "'''\nif we have a max num would we always grab it???\n\nno since its col and row could have better numbers?\n\n10^4 cells so n^2 could work or sorting or whatever\n\nlets do a backtracking solution idk\n\nget 3 highest values in every row and save their columns\nthen just move down rows and place the 3 rooks making sure the cols dont intercept\n\n3 choices every row but at most 3 choices made total + skipping\n\nmaybe could do some max state with dp but questionable since we need to avoid cols idk if we can do that greedily\n\nstill n^3 but atleast not n*n ^3 since we minimize cols to 3 columns\n\nig we can use a heap of size 3 to grab top 3 elements - what if a value has multiple cols? would we want to try all or nah\n'''\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n\n        newBoard = []\n        for i in range(len(board)):\n            heap = []\n            for j in range(len(board[0])):\n                heapq.heappush(heap, (board[i][j], i, j))\n\n                if len(heap) > 3: # remove min elements till only 3 left\n                    heapq.heappop(heap)\n\n            newBoard.append(heap)\n\n        # newboard confirmed working\n        # print(newBoard)\n        n = len(newBoard)\n        m = len(newBoard[0])\n        colSet = set()\n        res = float(\"-inf\")\n        currSum = 0\n        for i1 in range(n - 2):\n            for j1 in range(m):\n                currSum += newBoard[i1][j1][0]\n                colSet.add(newBoard[i1][j1][2])\n\n                for i2 in range(i1 + 1, n - 1):\n                    for j2 in range(m):\n                        if newBoard[i2][j2][2] in colSet:\n                            continue\n\n                        currSum += newBoard[i2][j2][0]\n                        colSet.add(newBoard[i2][j2][2])\n                        for i3 in range(i2 + 1, n):\n                            for j3 in range(m):\n                                if newBoard[i3][j3][2] in colSet:\n                                    continue\n                                res = max(res, currSum + newBoard[i3][j3][0])\n\n                        currSum -= newBoard[i2][j2][0]\n                        colSet.remove(newBoard[i2][j2][2])\n\n                currSum -= newBoard[i1][j1][0]\n                colSet.remove(newBoard[i1][j1][2])\n\n\n        return res\n\n                                \n        \n        ",
    "submit_ts": "1723908120",
    "subm_id": "1359139017"
}