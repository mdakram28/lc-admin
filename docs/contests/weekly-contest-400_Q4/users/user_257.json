{
    "username": "nubskr",
    "submission": "/*\nDONT GET A FUCKIN PENALTY!!!\n\nLOOK OUT FOR:\n\toverflow!!!\n\tcheck constraints!!!\n\tll vs int!!!!\n\nmay the divine intellect be with you!\n*/\n\n/*\nwe only need to find two things\n\nwhat is the greatest and we can get that is just smaller than k\n\nand what is the smallest and we can get that is just bigger than k\n\nand gets smaller the more we go forward\n\nif K is bigger than all the elems, then we just take the biggest element and diff it with that\n\n\n*/\n\n\nclass SegmentTree {\npublic:\n    SegmentTree(const std::vector<int>& data) {\n        n = data.size();\n        tree.resize(4 * n);\n        build(data, 0, 0, n - 1);\n    }\n\n    // Function to find the bitwise AND in the range [l, r]\n    int rangeAnd(int l, int r) {\n        return query(0, 0, n - 1, l, r);\n    }\n\nprivate:\n    int n;\n    std::vector<int> tree;\n\n    // Function to build the segment tree\n    void build(const std::vector<int>& data, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = data[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(data, 2 * node + 1, start, mid);\n            build(data, 2 * node + 2, mid + 1, end);\n            tree[node] = tree[2 * node + 1] & tree[2 * node + 2];\n        }\n    }\n\n    // Function to query the segment tree for the range [l, r]\n    int query(int node, int start, int end, int l, int r) {\n        if (r < start || end < l) {\n            return INT_MAX;  // Return a value that doesn't affect the AND operation\n        }\n        if (l <= start && end <= r) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int left_query = query(2 * node + 1, start, mid, l, r);\n        int right_query = query(2 * node + 2, mid + 1, end, l, r);\n        return left_query & right_query;\n    }\n};\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& v, int k) {\n    \tint n = v.size();\n    \tSegmentTree st(v);\n    \tint ans = INT_MAX;\n    \tfor (int i = 0; i < n; ++i)\n    \t{\n    \t\t// what is the just smallest element we can get if we start from this and go back\n    \t\t// max val just smaller than k\n    \t\tint l = 0,r = i;\n    \t\twhile(l < r){\n    \t\t\tint mid = (l + r + 1)/2;\n    \t\t\tif(st.rangeAnd(mid,i) <= k){\n    \t\t\t\tl = mid;\n    \t\t\t}\n    \t\t\telse{\n    \t\t\t\tr = mid - 1;\n    \t\t\t}\n    \t\t}\n    \t\tif(st.rangeAnd(l,i) <= k){\n    \t\t\tans = min(ans,abs(st.rangeAnd(l,i) - k));\n    \t\t}\n\n    \t\t// now find the min value just greater than k\n\n    \t\tl = 0,r = i;\n    \t\twhile(l < r){\n    \t\t\tint mid = (l + r)/2;\n    \t\t\tif(st.rangeAnd(mid,i) >= k){\n    \t\t\t\tr = mid;\n    \t\t\t}\n    \t\t\telse{\n    \t\t\t\tl = mid + 1;\n    \t\t\t}\n    \t\t}\n    \t\tif(st.rangeAnd(l,i) >= k){\n    \t\t\tans = min(ans,abs(st.rangeAnd(l,i) - k));\n    \t\t}\n    \t}\n    \treturn ans;\n    }\n};",
    "submit_ts": 1717297365.0
}