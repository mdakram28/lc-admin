{
    "username": "traveler1",
    "submission": "class Solution {\npublic:\n    pair<int, int> bfs(int start, const vector<vector<int>>& adj) {\n    int n = adj.size();\n    vector<int> dist(n, -1);\n    queue<int> q;\n\n    dist[start] = 0;\n    q.push(start);\n\n    int farthestNode = start;\n    int maxDist = 0;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n\n        for (int neighbor : adj[node]) {\n            if (dist[neighbor] == -1) {\n                dist[neighbor] = dist[node] + 1;\n                q.push(neighbor);\n\n                if (dist[neighbor] > maxDist) {\n                    maxDist = dist[neighbor];\n                    farthestNode = neighbor;\n                }\n            }\n        }\n    }\n\n    return {farthestNode, maxDist};\n}\n\n    int findDiameter(const vector<vector<int>>& adj) {\n        if (adj.empty()) return 0; \n        pair<int, int> firstBFS = bfs(0, adj);\n        pair<int, int> secondBFS = bfs(firstBFS.first, adj);\n        return secondBFS.second;\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1, m = edges2.size() + 1;\n       \n        vector<vector<int>> adj1(n), adj2(m);\n        for (const auto& edge : edges1) {\n            adj1[edge[0]].push_back(edge[1]);\n            adj1[edge[1]].push_back(edge[0]);\n        }\n\n        for (const auto& edge : edges2) {\n            adj2[edge[0]].push_back(edge[1]);\n            adj2[edge[1]].push_back(edge[0]);\n        }\n        if (n == 0 && m == 0) return 1; \n        int d1 = findDiameter(adj1);\n        int d2 = findDiameter(adj2);\n        int mn = max(d1,d2);\n        mn = max(mn, (d1 + 1) / 2 + 1 + (d2 + 1) / 2);\n        return mn;}\n        \n};",
    "submit_ts": 1719719273.0
}