{
    "username": "k7aditya",
    "submission": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pi 3.141592653589\n#define mod 1e9+7\n#define ll long long\n#define float double\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define all(c) cc.begin(), c.end()\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fast ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n\nclass Solution {\npublic:\n\n    int bfs(vector<vector<int>>& adj, int startNode, int t1, int t2, int totalNodes) {\n        queue<int> q;\n        vector<int> vis(totalNodes, 0);\n        q.push(startNode);\n        vis[startNode] = 1;\n        \n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            for (auto neigh : adj[node]) {\n                if (!vis[neigh]) {\n                    q.push(neigh);\n                    vis[neigh] = 1;\n                }\n            }\n        }\n        if(vis[t1] || vis[t2]) return true;\n        return false;\n    }\n\n    bool solve(int w, int h, vector<vector<int>>& c){\n        int numc = c.size();\n        vector<vector<int>> circleData = c;\n        vector<vector<int>> adj(numc + 4);\n        \n        for (int i = 0; i < numc; ++i) {\n            if (circleData[i][0] <= circleData[i][2]) {\n                adj[numc].push_back(i);\n                adj[i].push_back(numc);\n            }\n            if (w - circleData[i][0] <= circleData[i][2]) {\n                adj[numc + 2].push_back(i);\n                adj[i].push_back(numc + 2);\n            }\n            if (circleData[i][1] <= circleData[i][2]) {\n                adj[numc + 1].push_back(i);\n                adj[i].push_back(numc + 1);\n            }\n            if (h - circleData[i][1] <= circleData[i][2]) {\n                adj[numc + 3].push_back(i);\n                adj[i].push_back(numc + 3);\n            }\n            for (int j = i + 1; j < numc; ++j) {\n                double distance = sqrt(pow(circleData[i][0] - circleData[j][0], 2) +\n                                       pow(circleData[i][1] - circleData[j][1], 2));\n                int radiusSum = circleData[i][2] + circleData[j][2];\n                if (radiusSum >= distance) {\n                    adj[i].push_back(j);\n                    adj[j].push_back(i);\n                }\n            }\n        }\n        \n        int blocked = 0;\n        int b1= bfs(adj, numc, numc + 1, numc + 2, numc + 4);\n        int b2= bfs(adj, numc + 3, numc + 2, numc + 1, numc + 4);\n        blocked = max({blocked, b1, b2});\n        \n        return !blocked;\n    }\n\n    bool canReachCorner(int w, int h, vector<vector<int>>& c) {\n        bool ans=solve(w, h, c);\n        return ans;\n    }\n    \n};\n",
    "submit_ts": "1722137570",
    "subm_id": "1335767569"
}