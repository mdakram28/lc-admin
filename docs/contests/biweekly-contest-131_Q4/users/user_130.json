{
    "username": "ajingo",
    "submission": "template <typename R, typename T>\nconcept Foldable = requires(R op, const T& l, const T& r) { { op.fold(l, r) } -> same_as<T>; };\ntemplate <typename R>\nconcept T = requires(R op) {\n  typename R::T;\n  requires Foldable<R, typename R::T>;\n  { op.e() } -> same_as<typename R::T>;\n};\n\ntemplate<T R>\nstruct SegmentTree {\n  R op = R{};\n  using T = typename R::T;\n  vector<T> data;\n  int n = 1;\n  int bit = 0;\n  int size = 0;\n\n  void init(int sz) {\n    size = sz;\n    while (n < sz) {\n      n <<= 1;\n      bit++;\n    }\n    data.assign(n << 1, op.e());\n  }\n\n  SegmentTree(int n) { init(n); }\n\n  SegmentTree(const vector<T>& a) {\n    int sz = a.size();\n    init(sz);\n    for (int i = 0; i < sz; i++) data[i + n] = a[i];\n    for (int i = n - 1; i > 0; i--) data[i] = op.fold(data[i << 1 | 0], data[i << 1 | 1]);\n  }\n\n  void update(int x, const T& v) {\n    data[x += n] = v;\n    for (x >>= 1; x > 0; x >>= 1) {\n      data[x] = op.fold(data[x << 1 | 0], data[x << 1 | 1]);\n    }\n  }\n\n  T find(int l, int r) {\n    if (l == r) return op.e();\n    T x = op.e(), y = op.e();\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) x = op.fold(x, data[l++]);\n      if (r & 1) y = op.fold(data[--r], y);\n    }\n    return op.fold(x, y);\n  }\n\n  int minLeft(int r, const function<bool(const T&)>& f) {\n    assert(r <= size);\n    assert(f(op.e()));\n    if (r == 0) {\n      return 0;\n    }\n    r += n;\n    auto s = op.e();\n    while(true) {\n      r -= 1;\n      while (r > 1 && r % 2 == 1) {\n        r >>= 1;\n      }\n      auto v = op.fold(data[r], s);\n      if (!f(v)) {\n        while (r < n) {\n          r = r << 1 | 1;\n          v = op.fold(data[r], s);\n          if (f(v)) {\n            s = v;\n            r -= 1;\n          }\n        }\n        return r + 1 - n;\n      }\n      s = v;\n      if ((r & -r) == r) {\n        break;\n      }\n    }\n    return 0;\n  }\n  \n  int maxRight(int l, const function<bool(const T&)>& f) {\n    assert(l <= size);\n    assert(f(op.e()));\n    if (l == size) {\n      return size;\n    }\n    l += n;\n    auto s = op.e();\n    while(true) {\n      while (l % 2 == 0) {\n        l >>= 1;\n      }\n      auto v = op.fold(s, data[l]);\n      if (!f(v)) {\n        while (l < n) {\n          l <<= 1;\n          v = op.fold(s, data[l]);\n          if (f(v)) {\n            s = v;\n            l += 1;\n          }\n        }\n        return l - n;\n      }\n      s = v;\n      l += 1;\n      if ((l & -l) == l) {\n        break;\n      }\n    }\n    return size;\n  }\n};\n\nstruct R {\n  using T = int;\n  T fold(const T& l, const T& r) {\n    return max(l, r);\n  }\n  T e() { return 0; }\n};\n\nclass Solution {\npublic:\n  vector<bool> getResults(vector<vector<int>>& queries) {\n    int m = 4 * queries.size();\n    set<int> st = {0, m};\n    SegmentTree<R> seg(m + 1);\n    vector<bool> ans;\n    for (auto& q : queries) {\n      int op = q[0];\n      if (op == 1) {\n        int x = q[1];\n        auto it = st.insert(x).first;\n        int l = *prev(it);\n        int r = *next(it);\n        seg.update(x, x - l);\n        seg.update(r, r - x);\n      } else {\n        int x = q[1];\n        int sz = q[2];\n        auto it = st.upper_bound(x);\n        int l = *prev(it);\n        if (x - l >= sz) {\n          ans.push_back(true);\n        } else {\n          int best = seg.find(0, l + 1);\n          ans.push_back(best >= sz);\n        }\n      }\n    }\n    return ans;\n  }\n};",
    "submit_ts": 1716650314.0
}