{
    "username": "devvrat_07",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n \n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<class T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define ff first\n#define ss second\n#define ld long double\n#define ll long long\n#define pb push_back\n#define INF 1e18\n#define ppb pop_back\n#define fl(i,n,m) for(int i=n;i<m;i++)\n#define pii pair<int,int>\n#define vi vector<int>\n#define vll vector<ll>\n#define print(a) for(auto &it:a) cout<<it<<\" \"; cout<<endl\n#define mii map<int,int>\n#define setbits(x) __builtin_popcountll(x)\n#define sz(x) ((int)(x).size())\n#define all(a) a.begin(),a.end()\n#define yes cout<<\"YES\"<<endl\n#define no cout<<\"NO\"<<endl\n \nll gcd(ll a, ll b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}\nll expo(ll a, ll b, ll mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}\nvoid extendgcd(ll a, ll b, ll*v) {if (b == 0) {v[0] = 1; v[1] = 0; v[2] = a; return ;} extendgcd(b, a % b, v); ll x = v[1]; v[1] = v[0] - v[1] * (a / b); v[0] = x; return;} //pass an arry of size1 3\nll mminv(ll a, ll b) {ll arr[3]; extendgcd(a, b, arr); return arr[0];} //for non prime b\nll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}\nbool revsort(ll a, ll b) {return a > b;}\n \nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\nll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;} //only for prime m\n \nint pw(ll int a, ll int b, ll int m) {\n    if(b==0) {\n        return 1;\n    }\n \n    if(b%2 == 0) {\n        ll int t = pw(a, (b/2), m);\n        return (1ll*t*t)%m;\n    }\n    else {\n        ll int t = pw(a, (b-1)/2, m);\n        t = (1ll*t*t)%m;\n        return (1ll*a*t)%m;\n    }\n}\n \nconst int N=500000;\nconst ll int mod = 1e9 + 7;\n \nll int fact[N], invfact[N];\nvoid init() {\n    ll int p = mod;\n    fact[0]=1;\n    int i;\n    for(i=1; i<N; i++) {\n        fact[i] = (i*fact[i-1])%p;\n    }\n    i--;\n    invfact[i] = pw(fact[i], p-2, p);\n    for(i--; i>=0; i--) {\n        invfact[i] = (invfact[i+1]*(i+1))%p;\n    }\n}\n \nint ncr(int n, int r) {\n    return (((fact[n]*invfact[r])%mod)*invfact[n-r])%mod;\n}\n \nvector<int> sieve_of_eratosthenes(int n) {\n    vector<int> prm;\n    bool is_prime[n + 1];\n    memset(is_prime, true, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = false;\n    for(int p = 2; p * p <= n; p++) {\n        if(is_prime[p]) {\n            for(int i = p * p; i <= n; i += p) {\n                is_prime[i] = false;\n            }\n        }\n    }\n    for(int i = 2; i <= n; i++) {\n        if(is_prime[i]) {\n            prm.pb(i);\n        }\n    }\n    return prm;\n}\n\nclass Solution {\npublic:\n    long long minimumOperations(vector<int>& v, vector<int>& u) {\n        vector<ll> pre_cal_kiya;\n        ll n = v.size();\n        for(int i=0;i<n;i++){\n            pre_cal_kiya.push_back(u[i]-v[i]);\n        }\n        ll prvious1 = 0;\n        long long result= 0;\n        for(int i=0;i<n;){\n            if(pre_cal_kiya[i]==0){\n                i++;\n                continue;\n            }\n            if(pre_cal_kiya[i]>0){\n                ll mx = 0,mn = 1e9,ch=0;\n                while(i<n && ch<=pre_cal_kiya[i] && pre_cal_kiya[i]>0){\n                    mx = max(pre_cal_kiya[i],mx);\n                    ch = pre_cal_kiya[i];\n                    i++;\n                }\n                result += mx-prvious1;\n                if(i<n && pre_cal_kiya[i]<=0){\n                    prvious1 = 0;\n                    continue;\n                }\n                ch = 1e9;\n                while(i<n && pre_cal_kiya[i]<=ch && pre_cal_kiya[i]>0){\n                    mn = min(mn,pre_cal_kiya[i]);\n                    ch = pre_cal_kiya[i];\n                    i++;\n                }\n                if(i<n && pre_cal_kiya[i]<=0){\n                    prvious1 = 0;\n                    continue;\n                }\n                prvious1 = mn;\n            }\n            else{\n                ll mx = 0,mn = 1e9,ch=0;\n                while(i<n && abs(pre_cal_kiya[i])>=ch && pre_cal_kiya[i]<0){\n                    mx = max(abs(pre_cal_kiya[i]),mx);\n                    ch = abs(pre_cal_kiya[i]);\n                    i++;\n                }\n                result += mx-prvious1;\n                if(i<n && pre_cal_kiya[i]>=0){\n                    prvious1 = 0;\n                    continue;\n                }\n                ch = 1e9;\n                while(i<n && ch>=abs(pre_cal_kiya[i]) && pre_cal_kiya[i]<0){\n                    mn = min(mn,abs(pre_cal_kiya[i]));\n                    ch = abs(pre_cal_kiya[i]);\n                    i++;\n                }\n                if(i<n && pre_cal_kiya[i]>=0){\n                    prvious1 = 0;\n                    continue;\n                }\n                prvious1 = mn;\n            }\n        }\n        return result;\n    }\n};",
    "submit_ts": "1721532801",
    "subm_id": "1327994416"
}