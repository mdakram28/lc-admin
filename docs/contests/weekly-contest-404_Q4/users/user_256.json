{
    "username": "meaviral17",
    "submission": "\n#include <vector>\n#include <functional>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(std::vector<std::vector<int>>& tree1Edges, std::vector<std::vector<int>>& tree2Edges) {\n        int nodesInTree1 = tree1Edges.size() + 1;\n        int nodesInTree2 = tree2Edges.size() + 1;\n\n        std::vector<std::vector<int>> adjacencyList1(nodesInTree1);\n        std::vector<std::vector<int>> adjacencyList2(nodesInTree2);\n\n        for (const auto& edge : tree1Edges) {\n            adjacencyList1[edge[0]].push_back(edge[1]);\n            adjacencyList1[edge[1]].push_back(edge[0]);\n        }\n\n        for (const auto& edge : tree2Edges) {\n            adjacencyList2[edge[0]].push_back(edge[1]);\n            adjacencyList2[edge[1]].push_back(edge[0]);\n        }\n\n        auto depthFirstSearch = [](const std::vector<std::vector<int>>& graph, int startNode, int& farthestNode) {\n            int totalNodes = graph.size();\n            std::vector<int> distances(totalNodes, -1);\n            std::function<void(int, int)> explore = [&](int currentNode, int currentDistance) {\n                distances[currentNode] = currentDistance;\n                if (currentDistance > distances[farthestNode]) {\n                    farthestNode = currentNode;\n                }\n                for (int neighbor : graph[currentNode]) {\n                    if (distances[neighbor] == -1) {\n                        explore(neighbor, currentDistance + 1);\n                    }\n                }\n            };\n            farthestNode = startNode;\n            explore(startNode, 0);\n            return distances[farthestNode];\n        };\n\n        int initialNode1 = 0;\n        depthFirstSearch(adjacencyList1, 0, initialNode1);\n        int diameter1 = depthFirstSearch(adjacencyList1, initialNode1, initialNode1);\n\n        int initialNode2 = 0;\n        depthFirstSearch(adjacencyList2, 0, initialNode2);\n        int diameter2 = depthFirstSearch(adjacencyList2, initialNode2, initialNode2);\n\n        int minimumDiameter = std::max(diameter1, diameter2);\n        int halfDiameter1 = (diameter1 + 1) / 2;\n        int halfDiameter2 = (diameter2 + 1) / 2;\n        minimumDiameter = std::max(minimumDiameter, halfDiameter1 + halfDiameter2 + 1);\n\n        return minimumDiameter;\n    }\n};\n",
    "submit_ts": "1719718232",
    "subm_id": "1304412055"
}