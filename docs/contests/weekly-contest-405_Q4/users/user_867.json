{
    "username": "Hetgandhi",
    "submission": "/*struct Node {\n    // Array to store links to child nodes,\n    // each index represents a letter\n    Node* links[26];\n    // Flag indicating if the node\n    // marks the end of a word\n    bool flag = false;\n\n    // Check if the node contains\n    // a specific key (letter)\n    bool containsKey(char ch) {\n        return links[ch - 'a'] != NULL;\n    }\n\n    // Insert a new node with a specific\n    // key (letter) into the Trie\n    void put(char ch, Node* node) {\n        links[ch - 'a'] = node;\n    }\n\n    // Get the node with a specific\n    // key (letter) from the Trie\n    Node* get(char ch) {\n        return links[ch - 'a'];\n    }\n\n    // Set the current node\n    // as the end of a word\n    void setEnd() {\n        flag = true;\n    }\n\n    // Check if the current node\n    // marks the end of a word\n    bool isEnd() {\n        return flag;\n    }\n};\n\n// Trie class\nclass Trie {\nprivate:\n    Node* root;\n\npublic:\n    // Constructor to initialize the\n    // Trie with an empty root node\n    Trie() {\n        root = new Node();\n    }\n\n    // Inserts a word into the Trie\n    // Time Complexity O(len), where len\n    // is the length of the word\n    void insert(string word) {\n        Node* node = root;\n        for (int i = 0; i < word.length(); i++) {\n            if (!node->containsKey(word[i])) {\n                // Create a new node for\n                // the letter if not present\n                node->put(word[i], new Node());\n            }\n            // Move to the next node\n            node = node->get(word[i]);\n        }\n        // Mark the end of the word\n        node->setEnd();\n    }\n\n    // Returns if the word\n    // is in the trie\n    bool search(string word) {\n        Node* node = root;\n        for (int i = 0; i < word.length(); i++) {\n            if (!node->containsKey(word[i])) {\n                // If a letter is not found,\n                // the word is not in the Trie\n                return false;\n            }\n            // Move to the next node\n            node = node->get(word[i]);\n        }\n        // Check if the last node\n        // marks the end of a word\n        return node->isEnd();\n    }\n\n    // Returns if there is any word in the\n    // trie that starts with the given prefix\n    bool startsWith(string prefix) {\n        Node* node = root;\n        for (int i = 0; i < prefix.length(); i++) {\n            if (!node->containsKey(prefix[i])) {\n                // If a letter is not found, there is\n                // no word with the given prefix\n                return false;\n            }\n            // Move to the next node\n            node = node->get(prefix[i]);\n        }\n        // The prefix is found in the Trie\n        return true;\n    }\n};\n\n*/\n\n\n\nclass Node {\npublic:\n    unordered_map<char, Node*> children;\n    vector<pair<int, int>> word_ends;\n};\n\nclass Trie {\npublic:\n    Node* root;\n\n    Trie() {\n        root = new Node();\n    }\n    /*bool search(string word) {\n        Node* node = root;\n        for (int i = 0; i < word.length(); i++) {\n            if (!node->containsKey(word[i])) {\n                // If a letter is not found,\n                // the word is not in the Trie\n                return false;\n            }\n            // Move to the next node\n            node = node->get(word[i]);\n        }\n        // Check if the last node\n        // marks the end of a word\n        return node->isEnd();\n    }\n\n    // Returns if there is any word in the\n    // trie that starts with the given prefix\n    bool startsWith(string prefix) {\n        Node* node = root;\n        for (int i = 0; i < prefix.length(); i++) {\n            if (!node->containsKey(prefix[i])) {\n                // If a letter is not found, there is\n                // no word with the given prefix\n                return false;\n            }\n            // Move to the next node\n            node = node->get(prefix[i]);\n        }\n        // The prefix is found in the Trie\n        return true;\n    }*/\n    void insert(string word, int index, int cost) {\n        Node* node = root;\n        for (char c : word) {\n            if (!node->children.count(c)) {\n                node->children[c] = new Node();\n            }\n            node = node->children[c];\n        }\n        node->word_ends.push_back({index, cost});\n    }\n    \n};\n\nclass Solution {\npublic:\n    int  minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        \n        Trie res;\n        int n = target.size();\n        \n        for (int i = 0; i < words.size(); ++i) \n        {\n            res.insert(words[i], i, costs[i]);\n        }\n        vector<int> dp(n + 1, INT_MAX);\n        dp[0] = 0;\n        \n        for (int i = 0; i < n; ++i) \n        {\n            if (dp[i] == INT_MAX) \n            {\n                int z=2200;\n                continue;\n            }\n            Node* kl;\n            Node* temp = res.root;\n            for (int j = i; j < n; ++j) \n            {\n                if (!temp->children.count(target[j])) \n                {\n                    break;\n                }\n                temp= temp->children[target[j]];\n                for (auto qw : temp->word_ends) \n                {\n                    int ans = words[qw.first].size();\n                    int m= i + ans+20-20;;\n                    \n                    if (m <= n) \n                    {\n                        int a1=dp[i] + qw.second;\n                        int a2=dp[m];\n                        dp[m] = min(a1,a2)+200-200;\n                    }\n                }\n            }\n        }\n        if(dp[n]==INT_MAX)\n        {\n            return -1;\n        }\n        else\n        {\n            return dp[n]+1000-1000;\n        }\n        \n    }\n};",
    "submit_ts": "1720322997",
    "subm_id": "1312364689"
}