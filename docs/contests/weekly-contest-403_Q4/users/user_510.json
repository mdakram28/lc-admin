{
    "username": "A_Le_K",
    "submission": "static const int __ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0; }();\n\ntypedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair<int ,int> pii; typedef pair<ll, ll> pll; typedef double rl;\ntypedef pii int2; typedef tuple<int, int, int> int3; typedef tuple<int, int, int, int> int4; typedef tuple<int, int, int, int, int> int5;\ntypedef pll ll2; typedef tuple<ll, ll, ll> ll3; typedef tuple<ll, ll, ll, ll> ll4; typedef tuple<ll, ll, ll, ll, ll> ll5;\ntypedef vector<int> vi; typedef vector<pii> vii; typedef vector<ll> vll; typedef vector<pll> vll_ll; typedef vector<vi> vvi; typedef vector<vii> vvii; typedef vector<vll> vvll; typedef vector<vll_ll> vvll_ll;\n\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define xx first\n#define yy second\n#define FOR(i,N) for(int i=0; i<N; i++)\n#define g0(x) get<0>(x)\n#define g1(x) get<1>(x)\n#define g2(x) get<2>(x)\n#define g3(x) get<3>(x)\n#define g4(x) get<4>(x)\n\ntemplate<typename A> string to_string(A* ptr) { stringstream ss; ss << \"0x\" << std::setw(16) << std::setfill ('0') << std::hex << (uint64_t)(uintptr_t)ptr; return ss.str(); }\nstring to_string(char c) { return ((string)\"'\"+c)+ \"'\"; }\ntemplate <typename A, typename B> string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C> string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '\"' + s + '\"'; }\nstring to_string(const char* s) { return to_string((string) s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(vector<bool> v) {\n    bool first = true; string res = \"{\";\n\tfor (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += \", \"; } first = false; res += to_string(v[i]); }\n\tres += \"}\"; return res;\n}\ntemplate <size_t N> string to_string(bitset<N> v) { string res = \"\"; for (size_t i = 0; i < N; i++) { res += static_cast<char>('0' + v[i]); } return res; }\ntemplate <typename A> string to_string(A v) {\n\tbool first = true; string res = \"{\";\n\tfor (const auto &x : v) {\n\t\tif (!first) { res += \", \"; }\n\t\tfirst = false; res += to_string(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate <typename A, typename B> string to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\ntemplate <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) { return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\"; }\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) { return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\"; }\nvoid debug_out() { cout << endl; }\ntemplate <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << \" \" << to_string(H); debug_out(T...); }\n\n#define popc __builtin_popcountll\n//#define popc __builtin_popcount\n//#define clz __builtin_clzll\n//#define clz __builtin_clz\ninline int bitLength(uint32_t val) { return 32 - __builtin_clz  (val); }\ninline int bitLength(uint64_t val) { return 64 - __builtin_clzll(val); }\n\ntemplate<typename T> inline void domax(T& A, const T& B) { A=max(A, B); }\ntemplate<typename T> inline void domin(T& A, const T& B) { A=min(A, B); }\n\ntemplate<typename T>\ninline T true_mod(T A, T B)\n{\n    assert(B>=1);\n    A%=B;\n    if(A<0) A+=B;\n    return A;\n}\n\ntemplate<typename T>\ninline T div_down(T A, T B)\n{\n    return (A-true_mod(A,B))/B;\n}\n\ntemplate<typename T>\ninline T div_up(T A, T B)\n{\n    return div_down(A+B-1, B);\n}\n\n#define all(x) (x).begin(), (x).end()\n\n#if 1\n#define dbg(...) cout << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) 42\n#endif\n\ntypedef tuple<int, int, int, int> rect;\n\nrect intersect(rect one, rect two) {\n    auto [U1, D1, L1, R1]=one;\n    auto [U2, D2, L2, R2]=two;\n    return {max(U1, U2), min(D1, D2), max(L1, L2), min(R1, R2)};\n}\n\nbool nonempty(rect r) {\n    auto [U, D, L, R]=r;\n    return U<=D && L<=R;\n}\n\nint n, m;\nvector<vector<int>> g;\n\ntypedef pair<rect, int> info;\n\nconst int MX=30;\ninfo lazy[MX][MX][MX][MX];\nbool done[MX][MX][MX][MX];\n\ninfo calc(const int U, const int D, const int L, const int R) {\n    if(done[U][D][L][R]) return lazy[U][D][L][R];\n    \n    int u=n, d=0, l=m, r=0;\n    int ones=0;\n    \n    for(int i=U; i<=D; i++) for(int j=L; j<=R; j++) {\n        ones+=g[i][j];\n        \n        if(g[i][j]==1) {\n            domin(u, i);\n            domax(d, i);\n            domin(l, j);\n            domax(r, j);\n\n        }\n    }\n    \n    done[U][D][L][R]=true;\n    rect res={u, d, l, r};\n    lazy[U][D][L][R]={res, ones};\n    \n    \n    return {res,ones};\n}\n\nconst int INF=1e9+100;\n\n\n\nint f1(const int U, const int D, const int L, const int R) {\n    auto rr=calc(U, D, L, R);\n    auto [u,d,l,r]=rr.xx;\n    \n    if(nonempty(rr.xx)) return (d-u+1)*(r-l+1);\n    else return 0;\n}\n\nconst int LAZY_VAL=-1000;\nint F2[MX][MX][MX][MX];\n\n\nint f2(const int U, const int D, const int L, const int R) {\n    if(F2[U][D][L][R]!=LAZY_VAL) return F2[U][D][L][R];\n    \n    int result=f1(U,D,L,R);\n    for(int i=U; i<D; i++) {\n        int tmp=f1(U,i,L,R)+f1(i+1,D,L,R);\n        domin(result, tmp);\n    }\n    \n    for(int j=L; j<R; j++) {\n        int tmp=f1(U,D,L,j)+f1(U,D,j+1,R);\n        domin(result, tmp);\n    }\n    \n    F2[U][D][L][R]=result;\n    return result;\n}\n\nint F3[MX][MX][MX][MX];\n\n/*\nint f3(const int U, const int D, const int L, const int R) {\n    if(F3[U][D][L][R]!=LAZY_VAL) return F3[U][D][L][R];\n    \n    int result=INF;\n    \n    for(int i=U; i<D; i++) {\n            int tmp=f1(U,i,L,R)+f2(i,n-1,0,m-1);\n            domin(result, tmp);\n            \n            domin(result, f3(0,i))\n            \n            int tmp2=f2(0,i,0,m-1)+f1(i,n-1,0,m-1);\n            domin(result, tmp2);\n    }\n    \n    for(int j=0; j+1<m; j++) {\n            int tmp=f1(0, n-1, 0, j)+f2(0,n-1,j+1,m-1);\n            domin(result, tmp);\n            \n            int tmp2=f2(0, n-1, 0, j)+f1(0,n-1,j+1,m-1);\n            domin(result, tmp2);\n    }\n\n    F3[U][D][L][R]=result;\n    return result;\n}\n*/\n\n/*\ninfo up[MX], down[MX], lleft[MX], rright[MX];\nint res_up[MX], res_down[MX], res_left[MX], res_right[MX];\nint res_up2[MX], res_down2[MX], res_left2[MX], res_right2[MX];\n\nvoid init_infos() {\n    FOR(i, n) {\n        //up[i]=calc(0, i, 0, m-1);\n        //down[i]=calc(i, n-1, 0, m-1);\n        \n        res_up[i]=f1(0, i, 0, m-1);\n        res_down[i]=f1(i, n-1, 0, m-1);\n    }\n    \n    FOR(j, m) {\n        //lleft[j]=calc;\n        //rright[j]=calc;\n        \n        res_left[j]=f1(0, n-1, 0, j);\n        res_right[j]=f1(0,n-1, j,m-1);\n    }\n      \n}\n*/\n\nclass Solution {\npublic:\n    int minimumSum(vector<vector<int>>& grid) {\n        g=grid;\n        n=g.size();\n        m=g[0].size();\n        \n        //init_infos();\n        FOR(i, n) FOR(j, n) FOR(a,m) FOR(b,m) {\n            done[i][j][a][b]=false;\n            F2[i][j][a][b]=LAZY_VAL;\n        }\n            \n        int result=n*m;\n        \n        for(int i=0; i+1<n; i++) {\n            int tmp=f1(0,i,0,m-1)+f2(i+1,n-1,0,m-1);\n            domin(result, tmp);\n            \n            //domin(result, )\n            \n            int tmp2=f2(0,i,0,m-1)+f1(i+1,n-1,0,m-1);\n            domin(result, tmp2);\n        }\n        for(int j=0; j+1<m; j++) {\n            int tmp=f1(0, n-1, 0, j)+f2(0,n-1,j+1,m-1);\n            domin(result, tmp);\n            \n            int tmp2=f2(0, n-1, 0, j)+f1(0,n-1,j+1,m-1);\n            domin(result, tmp2);\n        }\n        \n        return result;\n        \n        /*\n        int u=n, d=0, l=m, r=0;\n        int ones=0;\n        \n        FOR(i, n) FOR(j, m) {\n            if(g[i][j]==1) {\n                domin(u, i);\n                domax(d, i);\n                domin(l, j);\n                domax(r, j);\n                \n            }\n            ones+=g[i][j];\n        }\n        */\n\n    }\n};",
    "submit_ts": 1719114493.0
}