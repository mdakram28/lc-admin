{
    "username": "lkm_leetcode",
    "submission": "class Solution:\n    def minimumSum(self, grid: List[List[int]]) -> int:\n        \n        \n        num_rows = len(grid)\n        num_cols = len(grid[0])\n       \n        segments = {} # (w,h,i,j) = i_min, j_min, i_max, j_max\n        for i in range(num_rows):\n            for j in range(num_cols):\n                x = grid[i][j]\n                if x:\n                    segments[1,1,i,j] = i,j,i,j\n                else:\n                    segments[1,1,i,j] = inf, inf, -inf, -inf\n        \n        \n        def Combine(seg_1, seg_2):\n            return [min(seg_1[0], seg_2[0]), min(seg_1[1], seg_2[1]), max(seg_1[2], seg_2[2]), max(seg_1[3], seg_2[3])]\n            \n            \n        width = 1 \n        while width <= num_cols:\n            height = 1\n            while  height<= num_rows:\n                # print(width, height)\n                if width == height == 1:\n                    height *=2\n                    continue \n                \n                for j in range(num_cols):\n                    if j + width > num_cols:\n                        continue \n                    \n                    for i in range(num_rows):\n                        if i + height > num_rows:\n                            continue\n                        \n                        # print()\n                        \n                        if width > height:\n                            segments[width, height, i,j] = Combine(segments[width//2, height,i,j], segments[width//2, height, i, j + width//2])\n                        else:\n                            segments[width, height, i,j] =Combine(segments[width, height//2,i,j], segments[width, height//2, i + height//2, j])\n                height*=2\n            width  *= 2\n            \n        \n        \n\n        \n        @cache\n        def Split(i_1, j_1, i_2, j_2, recurse):\n            min_cost = inf  \n            for i in range(i_1, i_2):\n                split_1 = (i_1, j_1, i, j_2)\n                split_2 = (i+1, j_1, i_2, j_2)\n                \n                if recurse:\n                    min_cost = min(min_cost, Evaluate(*split_1) + Split(*split_2, False))\n                    min_cost = min(min_cost, Evaluate(*split_2) + Split(*split_1, False))\n                else:\n                    min_cost = min(min_cost, Evaluate(*split_1)  + Evaluate(*split_2))\n\n            for j in range(j_1, j_2):\n                split_1 = (i_1, j_1,i_2, j)\n                split_2 = (i_1,j + 1, i_2, j_2)\n                if recurse:\n                    min_cost = min(min_cost, Evaluate(*split_1) + Split(*split_2, False))\n                    min_cost = min(min_cost, Evaluate(*split_2) + Split(*split_1, False))\n                else:\n                    min_cost = min(min_cost, Evaluate(*split_1)  + Evaluate(*split_2))\n            return min_cost \n\n        \n        @cache\n        def Evaluate(i_1, j_1, i_2, j_2):\n            i_1, i_2 = sorted([i_1, i_2])\n            j_1, j_2 = sorted([j_1,j_2])\n            if i_2 >= num_rows or j_2 >= num_cols:\n                \n                return 0\n            width = j_2 - j_1 + 1 \n            height = i_2 - i_1 + 1\n            \n            # print(i_1, j_1, i_2, j_2)\n            # print(f\"{width = }\")\n            # print(f\"{height = }\")\n            # tile it with 4 tiles \n            tile_width = 1<<(width.bit_length() - 1) if width > 1  else 1 \n            tile_height = 1<<(height.bit_length() - 1) if height > 1 else 1\n            segment = [inf, inf, -inf, -inf]    \n            top_left_points = [(i_1, j_1), (i_1, j_2 - tile_width + 1 ), (i_2 - tile_height + 1, j_1),(i_2 - tile_height + 1, j_2 - tile_width + 1)]\n            \n            for i,j in top_left_points:\n                segment = Combine(segment, segments[tile_width, tile_height, i,j])\n            min_i,min_j,max_i, max_j  = segment\n            return 0 if inf in [max_i, max_j] else  (max_j - min_j + 1 ) * (max_i - min_i + 1)\n        \n                \n        # print(*grid, sep=\"\\n\", end=\"\\n\\n\")\n        # print(*list(segments), sep=\"\\n\")\n        # print(*segments.items(), sep=\"\\n\")\n        # print(Evaluate(0,0,num_rows-1,num_cols -1))\n        # return -1\n        \n        return Split(0,0, num_rows -1, num_cols -1, True)\n            \n            ",
    "submit_ts": 1719115184.0
}