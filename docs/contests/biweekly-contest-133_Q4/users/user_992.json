{
    "username": "aditya_kunwar",
    "submission": "#include<bits/stdc++.h>\nusing namespace std;\nclass sol{\npublic:\n      \n    vector<long long> tree;\n    sol(int n)\n    {\n        tree.resize(4 * n +1);\n    }\n\n    void build(vector<int>& arr, int node, int start,int end)\n    {\n        if (start == end) {\n            tree[node] = arr[start];\n            return;\n        }\n            int mid = (start + end) / 2;\n            build(arr, 2 * node + 1, start, mid);\n            build(arr, 2 * node + 2, mid + 1, end);\n            tree[node]= (tree[2 * node + 1] + tree[2 * node + 2]);\n        \n    }\n \n    int query(int node, int start, int end, int l, int r)\n    {\n        if (r < start || end < l) {\n            return 0;            // this return must be updated\n        }\n        if (l <= start && end <= r) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int p1 = query(2 * node + 1, start, mid, l, r);\n        int p2 = query(2 * node + 2, mid + 1, end, l, r);\n\n        return (p1+p2);\n    }\n    void update_tree(int node, int start, int end, int i, int val) {\n\tif(start > i || end < i) return;\n\tif(start == i && i == end) {\n\t\ttree[node] = val;\n\t\treturn;\n\t}\n\tint c1 = 2 * node + 1, c2 = c1 + 1, m = (start+end)/2;\n\n   \n\tupdate_tree(c1, start, m, i, val);\n\n\tupdate_tree(c2, m+1, end, i, val);\n \n\ttree[node] = tree[c1] + tree[c2] ;\n}\n};\nclass Solution {\npublic:\n    long long m=1e9+7;\n    \n    long long f(int n, vector<vector<int>>& requirements) {\n        vector<vector<long long>> dp(n + 1, vector<long long>(405, 0));\n        dp[0][0] = 1;\n        unordered_map<int, int> r;\n        for (auto &i: requirements) {\n            int temp=i[0] + 1;\n            r[temp] = i[1];\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <=401; j++) {\n            for (int pos = 0; pos < i; pos++) {\n                    int prevj = j-pos;\n                    if(prevj<0)continue;\n                    if(prevj >= 0) {\n                        if(i==0)\n                            dp[i][j] = (dp[i][j] + dp[0][prevj])%m;\n                        else\n                        dp[i][j] = (dp[i][j] + dp[i - 1][prevj])%m;\n                    }\n                }\n            }\n            if (r.count(i)!=0) {\n                int t = r[i];\n                for (int j = 0; j <=401; j++) {\n                    if (j!= t) \n                        dp[i][j] = 0;\n                }\n            }\n        }\n        long long res = 0;\n        for (auto i: dp[n]) \n            res+=i%m;\n        \n        return res;\n    }\n\n    int numberOfPermutations(int n, vector<vector<int>>& requirements) {\n        long long ans= f(n,requirements);\n        return ans;\n        \n    }\n};",
    "submit_ts": "1719071752",
    "subm_id": "1296853335"
}