{
    "username": "sparkwenc",
    "submission": "template <int64_t mod> class int_mod {\n  private:\n\tint64_t value;\n\n  public:\n\tconstexpr static int64_t mval() { return mod; }\n\t// int_mod/* -> */int_mod\n\tint_mod() : value{} {}\n\tint_mod(const std::integral auto &x) {\n\t\tvalue = static_cast<int64_t>(x % mod);\n\t\tif (value < 0)\n\t\t\tvalue += mod;\n\t}\n\tconst int64_t &operator()() const { return value; }\n\ttemplate <class I>\n\t    requires std::is_arithmetic_v<I>\n\texplicit operator I() const {\n\t\treturn static_cast<I>(value);\n\t}\n\t// ++---\n\tint_mod &operator+=(const int_mod &other) {\n\t\tif ((value += other.value) >= mod)\n\t\t\tvalue -= mod;\n\t\treturn *this;\n\t}\n\tint_mod &operator+=(const std::integral auto &other) {\n\t\treturn *this += int_mod{other};\n\t}\n\tint_mod operator-() const { return int_mod{-value}; }\n\tint_mod &operator-=(const int_mod &other) {\n\t\tif ((value -= other.value) < 0)\n\t\t\tvalue += mod;\n\t\treturn *this;\n\t}\n\tint_mod &operator-=(const std::integral auto &other) {\n\t\treturn *this -= int_mod{other};\n\t}\n\t// ***///\n\tint_mod &operator*=(const int_mod &other) {\n\t\tvalue = (value * other.value) % mod;\n\t\treturn *this;\n\t}\n\tint_mod &operator*=(const std::integral auto &other) {\n\t\treturn *this *= int_mod{other};\n\t}\n\tint_mod power(const std::integral auto &other) {\n\t\tassert(other >= 0);\n\t\tint_mod<mod> x = *this, res = 1;\n\t\tauto p = other;\n\t\twhile (p > 0) {\n\t\t\tif (p & 1)\n\t\t\t\tres *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tint_mod inverse() const {\n\t\tint64_t a = value, m = mod;\n\t\tint64_t u = 0, v = 1, t;\n\t\twhile (a != 0) {\n\t\t\tt = m / a;\n\t\t\tm -= t * a;\n\t\t\tstd::swap(a, m);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\tassert(m == 1);\n\t\treturn int_mod{u};\n\t}\n\tint_mod &operator/=(const int_mod &other) {\n\t\treturn *this *= other.inverse();\n\t}\n\tint_mod &operator/=(const std::integral auto &other) {\n\t\treturn *this /= int_mod{other};\n\t}\n};\n/// +++\ntemplate <int64_t mod>\nint_mod<mod> operator+(const int_mod<mod> &l, const int_mod<mod> &r) {\n\treturn int_mod<mod>{l} += r;\n}\ntemplate <int64_t mod>\nint_mod<mod> operator+(const int_mod<mod> &l, const std::integral auto &r) {\n\treturn int_mod<mod>{l} += r;\n}\ntemplate <int64_t mod>\nint_mod<mod> operator+(const std::integral auto &l, const int_mod<mod> &r) {\n\treturn int_mod<mod>{l} += r;\n}\n/// ---\ntemplate <int64_t mod>\nint_mod<mod> operator-(const int_mod<mod> &l, const int_mod<mod> &r) {\n\treturn int_mod<mod>{l} -= r;\n}\ntemplate <int64_t mod>\nint_mod<mod> operator-(const int_mod<mod> &l, const std::integral auto &r) {\n\treturn int_mod<mod>{l} -= r;\n}\ntemplate <int64_t mod>\nint_mod<mod> operator-(const std::integral auto &l, const int_mod<mod> &r) {\n\treturn int_mod<mod>{l} -= r;\n}\n/// ***\ntemplate <int64_t mod>\nint_mod<mod> operator*(const int_mod<mod> &l, const int_mod<mod> &r) {\n\treturn int_mod<mod>{l} *= r;\n}\ntemplate <int64_t mod>\nint_mod<mod> operator*(const int_mod<mod> &l, const std::integral auto &r) {\n\treturn int_mod<mod>{l} *= r;\n}\ntemplate <int64_t mod>\nint_mod<mod> operator*(const std::integral auto &l, const int_mod<mod> &r) {\n\treturn int_mod<mod>{l} *= r;\n}\n/// ///\ntemplate <int64_t mod>\nint_mod<mod> operator/(const int_mod<mod> &l, const int_mod<mod> &r) {\n\treturn int_mod<mod>{l} /= r;\n}\ntemplate <int64_t mod>\nint_mod<mod> operator/(const int_mod<mod> &l, const std::integral auto &r) {\n\treturn int_mod<mod>{l} /= r;\n}\ntemplate <int64_t mod>\nint_mod<mod> operator/(const std::integral auto &l, const int_mod<mod> &r) {\n\treturn int_mod<mod>{l} /= r;\n}\n\nclass Solution {\npublic:\n    int countOfPairs(vector<int>& nums) {\n        constexpr static int MOD = 1e9 + 7;\n        \n        vector<int_mod<MOD>> fac(3001);\n        fac[0] = 1;\n        for (int i = 1; i <= 3000; i++)\n            fac[i] = fac[i - 1] * i;\n\n        \n        int sz;\n        for (int i = 0; i < nums.size(); i++) {\n            if (i == 0) {\n                sz = nums[i];\n                continue;\n            }\n            if (nums[i] < nums[i - 1]) {\n                sz -= nums[i - 1] - nums[i];\n            }\n        }\n        if (sz < 0)\n            return 0;\n\n        int mn = nums.size();\n        return (fac[mn + sz] * fac[mn].inverse() * fac[sz].inverse())();\n    }\n};",
    "submit_ts": "1723346720",
    "subm_id": "1351583714"
}