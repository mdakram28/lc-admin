{
    "username": "CAEL0",
    "submission": "#include <bits/stdc++.h>\n#define sz size()\n#define bk back()\n#define fi first\n#define se second\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int MOD = 1e9 + 7;\n\nstruct Node {\n    ll mx, mx_without_left, mx_without_right, mx_without_side;\n};\n\nstruct SegmentTree {\n    vector<Node> tree;\n\n    SegmentTree(int n) { tree.resize(4 * n); }\n\n    Node merge(Node a, Node b) {\n        return Node{\n            max(a.mx + b.mx_without_left, a.mx_without_right + b.mx),\n            max(a.mx_without_left + b.mx_without_left, a.mx_without_side + b.mx),\n            max(a.mx_without_right + b.mx_without_right, a.mx + b.mx_without_side),\n            max(a.mx_without_left + b.mx_without_side, a.mx_without_side + b.mx_without_right),\n        };\n    }\n\n    Node init(int idx, int s, int e, vector<int> &v) {\n        if (s == e) {\n            if (v[s - 1] < 0)\n                tree[idx] = Node{0, 0, 0, 0};\n            return tree[idx] = Node{v[s - 1], 0, 0, 0};\n        }\n\n        int m = (s + e) >> 1;\n        return tree[idx] = merge(init(2 * idx, s, m, v), init(2 * idx + 1, m + 1, e, v));\n    }\n\n    Node maximum(int idx, int s, int e, int l, int r) {\n        if (r < s || e < l)\n            return Node{0, 0, 0, 0};\n\n        if (l <= s && e <= r)\n            return tree[idx];\n\n        int m = (s + e) >> 1;\n        return merge(maximum(2 * idx, s, m, l, r), maximum(2 * idx + 1, m + 1, e, l, r));\n    }\n\n    void update(int idx, int s, int e, int l, int k) {\n        if (l < s || e < l)\n            return;\n\n        if (s == e) {\n            if (k < 0)\n                k = 0;\n\n            tree[idx] = Node{k, 0, 0, 0};\n            return;\n        }\n\n        int m = (s + e) >> 1;\n        update(2 * idx, s, m, l, k);\n        update(2 * idx + 1, m + 1, e, l, k);\n        tree[idx] = merge(tree[2 * idx], tree[2 * idx + 1]);\n    }\n};\n\nclass Solution {\n  public:\n    int maximumSumSubsequence(vector<int> &nums, vector<vector<int>> &queries) {\n        int n = nums.sz;\n\n        SegmentTree st(n);\n        st.init(1, 1, n, nums);\n\n        ll ret = 0;\n\n        for (int i = 0; i < queries.sz; i++) {\n            int pos = queries[i][0] + 1;\n            int x = queries[i][1];\n\n            st.update(1, 1, n, pos, x);\n            ret = (ret + st.maximum(1, 1, n, 1, n).mx) % MOD;\n        }\n\n        return ret;\n    }\n};",
    "submit_ts": "1716692251",
    "subm_id": "1268047919"
}