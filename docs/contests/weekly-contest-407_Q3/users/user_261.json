{
    "username": "shubhamvarshney2000",
    "submission": "#include <bits/stdc++.h>\n\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// using namespace __gnu_pbds;\n// typedef tree<int, null_type, greater_equal<int>, rb_tree_tag,\n//              tree_order_statistics_node_update>\n//     oset;\n\nusing namespace std;\n\n#define ar array\n#define ll long long int\n#define ld long double\n#define sza(x) ((int)x.size())\n#define all(a) (a).begin(), (a).end()\n#define printy cout<<\"Yes\"<<endl;\n#define printn cout<<\"No\"<<endl;\nconst int MAX_N = 1e5 + 5;\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MIN;\nconst ld EPS = 1e-9;\n\n\nlong long pow_m(long long base, long long exp, long long mod) {\n    long long result = 1LL;\n    base = (base % mod);\n        \n    while (exp > 0) {\n        if ((exp & 1LL) == 1LL) result = (result * base) % mod;\n        exp >>= 1LL;\n        base = (base * base) % mod;\n    }\n    return result;\n\n}\nclass DSU {\nprivate:\n    int sz;\n    vector<int> root, rank;\npublic:\n    DSU(int sz){\n        this->sz = sz;\n        root.resize(sz);\n        rank.resize(sz);\n        for(int i = 0; i < sz; i++){\n            root[i] = i;\n            rank[i] = 1;\n        }\n    }\n    \n    int find(int x){\n        if(root[x] == x) return x;\n        return root[x] = find(root[x]);\n    }\n    \n    bool unionSet(int x, int y){\n        int rootX = find(x);\n        int rootY = find(y);\n        if(rootX == rootY)\n            return false;\n        if(rank[rootX] > rank[rootY])\n            root[rootY] = rootX;\n        else if(rank[rootX] < rank[rootY])\n            root[rootX] = rootY;\n        else{\n            root[rootY] = rootX;\n            rank[rootX]++;\n        }\n        return true;\n    }\n\n    void reset() {\n        for(int i = 0; i < sz; i++){\n            root[i] = i;\n            rank[i] = 1;\n        }\n    }\n};\n\n\nclass TreeAncestor {\n    public:\n    vector<vector<int>> vec;\n    vector<int> depth;\n    int h = 18;\n    int n;\n    TreeAncestor(int _n, vector<int>& parent) {\n        n = _n;\n        depth.resize(n,0);\n        vec.resize(h,vector<int>(n+1,-1));\n        for(int i=0;i<n;i++){\n            vec[0][i] = parent[i];\n        }\n        for(int i=1;i<h;i++){\n            for(int j=0;j<n;j++){\n                if(vec[i-1][j] != -1)\n                    vec[i][j] = vec[i-1][vec[i-1][j]];\n            }\n        }\n    }\n    \n    int getKthAncestor(int node, int k) {\n        for(int i=0;i<h;i++){\n            if(k&(1<<i)){\n                node = vec[i][node];\n                if(node == -1){\n                    return -1;\n                }\n            }\n        }\n        return node;\n    }\n    int lca(int a, int b)\n    {\n        if(depth[a] < depth[b])\n            swap(a, b);\n        \n        int diff = depth[a] - depth[b];\n        for(int i = 0; i < 16; i++)\n            if(diff & (1 << i))\n                a = vec[a][i];\n\n        if(a == b)\n            return a;\n        \n        for(int i = 15; i >= 0; i--)\n        {\n            if(vec[a][i] != vec[b][i])\n            {\n                a = vec[a][i];\n                b = vec[b][i];\n            }\n        }\n\n        return vec[a][0];\n    }\n    void dfs(int src, int paren,vector<vector<int>> &g)\n    {\n        for(auto x : g[src])\n        {\n            if(x == paren)\n                continue;\n            depth[x] = depth[src] + 1;\n            dfs(x, src,g);\n        }\n    }\n};\n\nbool help(ll x,ll y,ll sum){\n    ll s = 0;\n    while(x>0 && y>0){\n        if(s>=sum){\n            s= s-2;\n            y--;\n        }\n        else{\n            s += 1;\n            x--;\n        }\n    }\n    if(x<=sum){\n        return 1;\n    }\n    else{\n        return 0;\n    }\n}\n bool subArrayExists(ll arr[], int N)\n{\n    unordered_set<int> sumSet;\n \n    // Traverse through array\n    // and store prefix sums\n    ll sum = 0;\n    for (int i = 0; i < N; i++) {\n        sum += arr[i];\n \n        // If prefix sum is 0 or\n        // it is already present\n        if (sum == 0 || sumSet.find(sum) != sumSet.end())\n            return true;\n \n        sumSet.insert(sum);\n    }\n    return false;\n}\nbool isSubsetSum(ll set[], ll n, ll sum)\n{\n    // The value of subset[i][j] will be true if\n    // there is a subset of set[0..j-1] with sum\n    // equal to i\n    bool subset[n + 1][sum + 1];\n \n    // If sum is 0, then answer is true\n    for (int i = 0; i <= n; i++)\n        subset[i][0] = true;\n \n    // If sum is not 0 and set is empty,\n    // then answer is false\n    for (int i = 1; i <= sum; i++)\n        subset[0][i] = false;\n \n    // Fill the subset table in bottom up manner\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= sum; j++) {\n            if (j < set[i - 1])\n                subset[i][j] = subset[i - 1][j];\n            if (j >= set[i - 1])\n                subset[i][j]\n                    = subset[i - 1][j]\n                      || subset[i - 1][j - set[i - 1]];\n        }\n    }\n \n    return subset[n][sum];\n}\nlong long solve(vector<int> nums,int k){\n        int n = nums.size();\n        long long ans = 0;\n        unordered_map<long long, long long> prev;\n        for (int i = 0; i < n; ++i) {\n            unordered_map<long long, long long> c;\n\n            if (nums[i] == k) {\n                ++ans;\n            }\n            c[nums[i]] += 1;\n\n            for (auto& [val, freq] : prev) {  \n                long long x = val & nums[i];\n                if (x == k) {\n                    ans += freq;\n                }\n                c[x] += freq;\n            }\n            prev = move(c);\n        }\n\n        return ans;\n}\nclass SegmentTree {\nprivate:\n    int n;\n    vector<int> tree;\n    \npublic:\n    SegmentTree(vector<int>& nums) {\n        n = nums.size();\n        tree.resize(2 * n);\n        build(nums);\n    }\n    \n    void build(vector<int>& nums) {\n        for (int i = 0; i < n; ++i) {\n            tree[n + i] = nums[i];\n        }\n        for (int i = n - 1; i > 0; --i) {\n            tree[i] = tree[2 * i] & tree[2 * i + 1];\n        }\n    }\n    \n    int query(int l, int r) {\n        l += n;\n        r += n;\n        int res = INT_MAX;\n        while (l < r) {\n            if (l % 2 == 1) {\n                res &= tree[l++];\n            }\n            if (r % 2 == 1) {\n                res &= tree[--r];\n            }\n            l /= 2;\n            r /= 2;\n        }\n        return res;\n    }\n};\n\n\nvoid findprimefactor(ll x, map<ll, ll>&divs){\n    ll i = 2;\n    while(i * i <= x){\n        while (x %\n         i == 0){\n            divs[i]++;\n            x /= i;\n        }\n        i++;\n    }\n    if(x > 1) divs[x]++;\n}\n\nvoid dfs1(int node,int par,vector<vector<int>> &g,vector<int> &dp, map<ll,ll> &m){\n    int cnt = 0;\n    for(auto x:g[node]){\n        if(x!= par){\n            dfs1(x,node,g,dp,m);\n            cnt++;\n        }\n    }\n    if(cnt == 0){\n        if(m.find(node) != m.end()){\n            dp[node] = 0;\n        }\n        else{\n            dp[node] = INT_MIN;\n        }\n        return;\n    }\n    dp[node] = INT_MIN;\n    for(auto x:g[node]){\n        if(x!= par){\n            dp[node] = max(dp[node],dp[x]);\n        }\n    }\n    // cout<<node<<\" \"<<dp[node]<<endl;\n    if(dp[node] != INT_MIN){\n        dp[node]++;\n    }\n    else{\n        if(m.find(node) != m.end()){\n            dp[node] = 0;\n        }\n        else{\n            dp[node] = INT_MIN;\n        }\n        return;\n    }  \n}\n\nvoid dfs2(int node,int par,vector<vector<int>> &g,vector<int> &aux,vector<int> &dp,map<ll,ll> &m){\n    if(par == -1){\n        if(m.find(node) == m.end()){\n            dp[node] = INT_MIN;\n        }\n        else{\n            dp[node] = 0;\n        }\n    }\n   \n    vector<pair<int,int>> v;\n    for(auto x:g[node]){\n        if(x!=par){\n            v.push_back({aux[x],x});\n        }\n    }\n    if(m[node] == 1 && dp[node] == INT_MIN){\n        dp[node] = 0;\n    }\n    v.push_back({dp[node],-1});\n    sort(v.rbegin(),v.rend());\n    for(auto x:g[node]){\n        if(x != par){\n            if(v.size() == 1){\n                if(v[0].first == INT_MIN){\n                    if(m.find(x) != m.end()){\n                        dp[x] = 0;\n                    }\n                    else{\n                        dp[x] = INT_MIN;\n                    }\n                    \n                }\n                else{\n                    dp[x] = v[0].first+1;\n                }\n            }\n            else{\n                // cout<<v[0].second<<endl;\n                if(v[0].second != x){\n                    if(v[0].second == -1){\n                        if(v[0].first == INT_MIN){\n                           if(m.find(x) != m.end()){\n                                dp[x] = 0;\n                            }\n                            else{\n                                dp[x] = INT_MIN;\n                            }\n                        }\n                        else{\n                            dp[x] = v[0].first+1;\n                        }\n                    }\n                    else{\n                        dp[x] = 2+v[0].first;\n                    }\n                }\n                else{\n                    if(v[1].second == -1){\n                        if(v[1].first == INT_MIN){\n                            if(m.find(x) != m.end()){\n                                dp[x] = 0;\n                            }\n                            else{\n                                dp[x] = INT_MIN;\n                            }\n                        }\n                        else{\n                            dp[x] = v[1].first+1;\n                        }\n                    }\n                    else{\n                        if(v[1].first == INT_MIN){\n                            if(m.find(x) != m.end()){\n                                dp[x] = 0;\n                            }\n                            else{\n                                dp[x] = INT_MIN;\n                            }\n                        }\n                        else{\n                            dp[x] = v[1].first+2;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for(auto x:g[node]){\n        if(x!=par){\n            dfs2(x,node,g,aux,dp,m);\n        }\n    }\n}\n\n\nstring decitob(ll n){\n    string ans = \"\";\n    for(int i=62;i>=0;i--){\n        if(n&(1ll<<i)){\n            ans += '1';\n        }\n        else{\n            ans += '0';\n        }\n    }\n    return ans;\n}\nll botd(string s){\n    ll ans = 0;\n    for(int i=0;i<=62;i++){\n        // cout<<s[i];\n        if(s[i] == '1')\n            ans = ans + (1ll<<(62-i));\n    }\n    // cout<<endl;\n    return ans;\n}\n\nll dfs(int i,int j,vector<vector<int>> &a,vector<vector<int>> &dp){\n    // cout<<i<<\" \"<<j<<endl;\n    if(i>=a.size() || j>=a[0].size()){\n        return INT_MAX;\n    }\n    // cout<<i<<\" \"<<j<<endl;\n    if(i == a.size()-1 && j == a[0].size()-1){\n        return a[i][j];\n    }\n    if(dp[i][j]!= -1){\n        return dp[i][j];\n    }\n    int sum = a[i][j];\n    int down = dfs(i+1,j,a,dp);\n    int up = dfs(i,j+1,a,dp);\n    int mini = min(down,up);\n    if(mini!=INT_MAX){\n        sum += mini;\n    }\n    return dp[i][j] = sum;\n}\nll dfs2(int i,int j,vector<vector<int>> &a,vector<vector<int>> &dp){\n    // cout<<i<<\" \"<<j<<endl;\n    if(i>=a.size() || j>=a[0].size()){\n        return INT_MIN;\n    }\n    // cout<<i<<\" \"<<j<<endl;\n    if(i == a.size()-1 && j == a[0].size()-1){\n        return a[i][j];\n    }\n    if(dp[i][j]!= -1){\n        return dp[i][j];\n    }\n    int sum = a[i][j];\n    int down = dfs2(i+1,j,a,dp);\n    int up = dfs2(i,j+1,a,dp);\n    int mini = max(down,up);\n    if(mini!=INT_MIN){\n        sum += mini;\n    }\n    return dp[i][j] = sum;\n}\nvoid help(){\n        int n,x;\n        cin>>n>>x;\n        ll a[n];\n        vector<ll> pre(n+1,0),dp(n+3,0);\n        for(int i=0;i<n;++i){\n            cin>>a[i];\n            pre[i+1]=pre[i]+a[i];\n        }\n        ll ans=0;\n        for(int i=n-1;i>=0;--i){\n            ll val=pre[i]+x;\n        \n            int ind=lower_bound(pre.begin(),pre.end(),val)-pre.begin();\n            if(ind==n+1){\n                dp[i]+=(n-i);\n            }\n            else if(val==pre[ind]){\n                dp[i]+=(ind-i)+dp[ind+1];\n            }\n            else {\n                dp[i]+=(ind-i-1)+dp[ind];\n            }\n            ans += dp[i];\n        }\n        cout<<ans<<endl;        \n}\nvoid solve(){\n        ll n;\n        cin>>n;\n        ll a[n];\n        ll sum = 0;\n        for(int i=0;i<n;i++){\n            cin>>a[i];\n            sum += a[i];\n        }\n        vector<ll> mad(n);\n        map<int,int> m;\n        ll maxi = 0;\n        for(int i=0;i<n;i++){\n            m[a[i]]++;\n            if(m[a[i]]>=2){\n                maxi = max(maxi,a[i]);\n            }\n            mad[i] = maxi;            \n        }\n        // for(auto x:mad){\n        //     cout<<x<<\" \";\n        // }\n        // cout<<endl;\n        map<ll,ll> mm;\n        for(auto x:mad){\n            if(x>0){\n                mm[x]++;\n            }\n        }\n        vector<pair<ll,ll>> vec;\n        for(auto x:mm){\n            vec.push_back({x.first,x.second});\n        }\n        ll cnt = 0;\n        ll ans = 0;\n        int cnt2 = 0;\n        for(int i=vec.size()-1;i>=0;i--){\n            // cout<<vec[i].first<<\" \"<<vec[i].second<<endl;\n            if(vec[i].second == 1){\n                ans += vec[i].first;\n                cnt2++;\n                cnt += vec[i].second;\n            }\n            else{\n                ans += vec[i].first*(cnt*vec[i].second +vec[i].second*(vec[i].second+1)/2);\n                cnt += vec[i].second;\n                cnt2 = 0;\n            }\n\n\n        }\n        cout<<ans+sum<<endl;\n\n    }\n\nclass Solution {\npublic:\n    int solve(string s){\n         int cnt = 0;\n        int one = 0;\n\n        int i=0;\n        while(i<s.size()){\n            if(s[i] == '1'){\n                one++;\n                i++;\n            }\n            else{\n                cnt+=one;\n                while(i<s.size() && s[i] == '0'){\n                    i++;\n                }\n            }\n        }\n\n        return cnt;\n    }\n    int maxOperations(string s) {\n        return solve(s);\n    }\n};",
    "submit_ts": "1721529850",
    "subm_id": "1327914867"
}