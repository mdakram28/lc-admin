{
    "username": "Amrharb",
    "submission": "\nconst int N = 1e6 + 5, MOD1 = 1e9 + 7, MOD2 = 1e9 + 9;\nint pw1[N], inv1[N], pw2[N], inv2[N], BASE;\n\nbool isPrime(int x) {\n    for (int i = 2; i * i <= x; i++) {\n        if (x % i == 0) return false;\n    }\n    return x > 1;\n}\n\nint fix(long long x, int M) {\n    return (x % M + M) % M;\n}\n\nint fpow(int a, int b, int mod) {\n    if (!b) return 1;\n    int ret = fpow(a, b >> 1, mod);\n    ret = fix(1ll * ret * ret, mod);\n    if (b & 1) ret = fix(1ll * ret * a, mod);\n    return ret;\n}\n\nvoid init() {\n    static bool done = false;\n    if (done) return;\n    done = true;\n\n    mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n    uniform_int_distribution<int> dist(257, 10007);\n    do {\n        BASE = dist(rng);\n    } while (!isPrime(BASE));\n\n    pw1[0] = inv1[0] = pw2[0] = inv2[0] = 1;\n    int iv1 = fpow(BASE, MOD1 - 2, MOD1);\n    int iv2 = fpow(BASE, MOD2 - 2, MOD2);\n    for (int i = 1; i < N; ++i) {\n        pw1[i] = fix(1ll * pw1[i - 1] * BASE, MOD1);\n        pw2[i] = fix(1ll * pw2[i - 1] * BASE, MOD2);\n        inv1[i] = fix(1ll * inv1[i - 1] * iv1, MOD1);\n        inv2[i] = fix(1ll * inv2[i - 1] * iv2, MOD2);\n    }\n}\n\nstruct Hash {\n    vector<pair<int, int>> pre;\n\n    void build(const string &s) {\n        init();\n        int n = s.size();\n        pre.assign(n + 1, {0, 0});\n        for (int i = 0; i < n; i++) {\n            pre[i + 1] = make_pair(fix(1ll * pw1[i] * s[i] + pre[i].first, MOD1),\n                                   fix(1ll * pw2[i] * s[i] + pre[i].second, MOD2));\n        }\n    }\n\n    pair<int, int> getRange(int l, int r) const { // 0-based\n        return make_pair(fix(1LL*inv1[l] * (pre[r + 1].first - pre[l].first), MOD1),\n                         fix(1LL*inv2[l] * (pre[r + 1].second - pre[l].second), MOD2));\n    }\n};\n\npair<int, int> computeHash(const string &s) {\n    init();\n    int hash1 = 0, hash2 = 0;\n    for (char c : s) {\n        hash1 = fix(1ll * hash1 * BASE + c, MOD1);\n        hash2 = fix(1ll * hash2 * BASE + c, MOD2);\n    }\n    return {hash1, hash2};\n}\n\n#undef int\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int n = target.size(), m = words.size();\n        vector<int> dp(n + 1, INT_MAX),sz(m);\n        dp[0] = 0;\n\n        Hash targetHash;\n        targetHash.build(target);\n\n        unordered_map<char, vector<int>> groupedWords;\n        for (int i = 0; i < m; ++i) {\n            groupedWords[words[i][0]].emplace_back(i);\n        }\n\n        vector<pair<int, int>> wordHashes(m);\n        for (int i = 0; i < m; ++i) {\n            Hash hash;\n            hash.build(words[i]);\n            sz[i]=words[i].size();\n            wordHashes[i] = hash.getRange(0,sz[i]-1);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            if (dp[i] == INT_MAX) continue;\n            char startChar = target[i];\n            if (groupedWords.find(startChar) == groupedWords.end()) continue;\n            for (const auto& idx : groupedWords[startChar]) {\n                int len = sz[idx];\n                if (i + len <= n && targetHash.getRange(i, i + len - 1) == wordHashes[idx]) {\n                    dp[i + len] = min(dp[i + len], dp[i] + costs[idx]);\n                }\n            }\n        }\n\n        return dp[n] == INT_MAX ? -1 : dp[n];\n    }\n};",
    "submit_ts": "1720322107",
    "subm_id": "1312340844"
}