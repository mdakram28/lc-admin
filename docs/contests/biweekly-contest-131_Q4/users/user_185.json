{
    "username": "GoGuru",
    "submission": "/* Crimson Mage */\n \n/*\n     \u0950 \u0924\u094d\u0930\u094d\u092f\u092e\u094d\u092c\u0915\u0902 \u092f\u091c\u093e\u092e\u0939\u0947 \u0938\u0941\u0917\u0928\u094d\u0927\u093f\u0902 \u092a\u0941\u0937\u094d\u091f\u093f\u0935\u0930\u094d\u0927\u0928\u092e\u094d |\n     \u0909\u0930\u094d\u0935\u093e\u0930\u0941\u0915\u092e\u093f\u0935 \u092c\u0928\u094d\u0927\u0928\u093e\u0928\u094d\u092e\u0943\u0924\u094d\u092f\u094b\u0930\u094d\u092e\u0941\u0915\u094d\u0937\u0940\u092f \u092e\u093e\u093d\u092e\u0943\u0924\u093e\u0924\u094d ||\n*/\n \n/* \n     I can't wait to live in glory and eternal lastin' life\n     Won't you take the wheel? I'll recline and I'll sit still.\n*/\n \n \n//******************************************************TEMPLATE START******************************************************************\n#include <bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// using namespace __gnu_pbds;\n// template <typename num_t>\n// using ordered_set = tree<num_t, null_type, less_equal<num_t>, rb_tree_tag, tree_order_statistics_node_update>;\nusing namespace chrono;\n#define gc getchar_unlocked\n// #define inf INT_MAX\n#define minf INT_MIN\n#define ff first\n#define ss second\n#define mp make_pair\n#define nline \"\\n\"\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define len(x) ((int)(x).length())\n#define all(x) x.begin(), x.end()\n#define sortall(x) sort(all(x))\n#define PI 3.1415926535897932384626\n#define msb(x) (31 - __builtin_clz(x))      \n#define msbll(x) (63 - __builtin_clzll(x))  \n#define NoSetbitsll(x) __builtin_popcountll(x)\n#define setminus(x) memset(x, -1, sizeof(x))\n#define setzero(x) memset(x, 0, sizeof(x))\n#define f(i, n) for (i = 0; i < n; i++)\n#define fe(i,n) for (i = 1; i <=n; i++)\n#define fos(i, s, n, k) for (i = s; i < n; i = i + k)\n#define fom(i, s, n, k) for (i = s; i < n; i = i * k)\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define getunique(v) {sort(all(v)); v.erase(unique(all(v)), v.end());} // for Vector v\n#define printPrecision(p, Value) cout << fixed << setprecision(p) << Value\n#define tr(it, a) for (auto it = a.begin(); it != a.end(); it++)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lld;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vpi> vvpi;\ntypedef vector<vpl> vvpl;\ntypedef vector<bool> vb;\n \ntemplate <class T, class V> void _print(pair <T, V> p);\ntemplate <class T> void _print(vector <T> v);\ntemplate <class T> void _print(set <T> v);\ntemplate <class T, class V> void _print(map <T, V> v);\ntemplate <class T> void _print(multiset <T> v);\n \ntemplate <class T, class V> void _print(pair <T, V> p) { cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\"; }\ntemplate <class T> void _print(vector <T> v) { cerr << \"[ \"; for (T i : v) { _print(i); cerr << \" \"; } cerr << \"]\"; }\ntemplate <class T> void _print(set <T> v) { cerr << \"[ \"; for (T i : v) { _print(i); cerr << \" \"; } cerr << \"]\"; }\ntemplate <class T> void _print(deque <T> v) { cerr << \"[ \"; for (T i : v) { _print(i); cerr << \" \"; } cerr << \"]\"; }\ntemplate <class T> void _print(multiset <T> v) { cerr << \"[ \"; for (T i : v) { _print(i); cerr << \" \"; } cerr << \"]\"; }\ntemplate <class T, class V> void _print(map <T, V> v) { cerr << \"[ \"; for (auto i : v) { _print(i); cerr << \" \"; } cerr << \"]\"; }\n// template <class T> void _print(ordered_set<T> v) { cerr << \"[ \"; for (auto i : v) { _print(i); cerr << \" \"; } cerr << \"]\"; }\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n// ll getRandomNumber(ll l, ll r) { return uniform_int_distribution<ll>(l, r)(rng); }\n \nll gcd(ll a, ll b) { if (b > a) { return gcd(b, a); } if (b == 0) { return a; } return gcd(b, a % b); }\nll powm(ll a, ll b, ll mod) { ll res = 1; while (b > 0) { if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1; } return res; }  //power modulo m\nvoid extendgcd(ll a, ll b, ll* v) { if (b == 0) { v[0] = 1; v[1] = 0; v[2] = a; return; } extendgcd(b, a % b, v); ll x = v[1]; v[1] = v[0] - v[1] * (a / b); v[0] = x; return; } //pass an array of size 3\nll mminv(ll a, ll b) { ll arr[3]; extendgcd(a, b, arr); return arr[0]; } //for non prime b\nll mminvprime(ll a, ll b) { if (a % b == 0) return -1; return powm(a, b - 2, b); } //for prime only\nvector<ll> sieve(int n) { int* arr = new int[n + 1](); vector<ll> vect; for (int i = 2; i <= n; i++)if (arr[i] == 0) { vect.push_back(i); for (int j = 2 * i; j <= n; j += i)arr[j] = 1; } return vect; }\nvector<string> split(string s, char delimeter) { vector <string> tokens; stringstream check1(s); string intermediate; while (getline(check1, intermediate, delimeter)) { tokens.push_back(intermediate); } return tokens; }\n//Idiot consider all zeroes\nstring stringRemZeroes(string s) { string res; bool flag = true; for (int i = 0;i < s.length();i++) { if (s[i] == '0' && flag) continue; else { flag = false; res.push_back(s[i]); } } if (res.size() == 0) res = \"0\"; return res; }\nvoid toLower(string& s) { transform(s.begin(), s.end(), s.begin(), ::tolower); }\nvoid toUpper(string& s) { transform(s.begin(), s.end(), s.begin(), ::toupper); }\nll addm(ll a, ll b, ll m) { a = a % m; b = b % m; return (((a + b) % m) + m) % m; }\nll mulm(ll a, ll b, ll m) { a = a % m; b = b % m; return (((a * b) % m) + m) % m; }\nll subm(ll a, ll b, ll m) { a = a % m; b = b % m; return (((a - b) % m) + m) % m; }\nll divm(ll a, ll b, ll m) { a = a % m; b = b % m; return (mulm(a, mminvprime(b, m), m) + m) % m; }  //only for prime m\nconst ll SIZE = 1e5 + 100; // change size before calling\nll fact[SIZE], ifact[SIZE];\nvoid gen_factorial(ll n, ll mod) { fact[0] = fact[1] = ifact[0] = ifact[1] = 1; for (ll i = 2; i <= n; i++) { fact[i] = (i * fact[i - 1]) % mod; } ifact[n] = mminvprime(fact[n], mod); for (ll i = n - 1; i >= 2; i--) { ifact[i] = ((i + 1) * ifact[i + 1]) % mod; } }\nll choose(ll n, ll r, ll m) { ll val1 = fact[n]; ll val2 = ifact[n - r]; ll val3 = ifact[r]; return (((val1 * val2) % m) * val3) % m; } //First make fact and ifact for this to work both ll\n//Range intersection\npi intersection(pi a, pi b) { if (a.first > b.second || a.second < b.first) { return mp(-1, -1); } else { b.first = max(b.first, a.first); b.second = min(b.second, a.second); } return b; }\npl findRatio(ll a, ll b) { ll g = gcd(a, b); a /= g; b /= g; return mp(a, b); }\nll stringToNo(string s) { stringstream din(s); ll x; din >> x; return x; }\ntemplate <typename T> void amax(T& a, T b) { a = max(a, b); }\ntemplate <typename T> void amin(T& a, T b) { a = min(a, b); }\nconst int MOD1 = 1000000007;\nconst int MOD2 = 998244353;\n#pragma warning restore format\n//**********************************************************TEMPLATE ENDS****************************************************************\nconst int N = 3e5 + 9;\n \nint a[N+9];\n \nstruct ST {\n  int t[4 * N];\n  static const int inf = 1e9;\n  ST() {\n    memset(t, 0, sizeof t);\n  }\n  void build(int n, int b, int e) {\n    if (b == e) {\n      t[n] = a[b];\n      return;\n    }\n    int mid = (b + e) >> 1, l = n << 1, r = l | 1;\n    build(l, b, mid);\n    build(r, mid + 1, e);\n    t[n] = max(t[l] , t[r]);\n  }\n  void upd(int n, int b, int e, int i, int x) {\n    if (b > i || e < i) return;\n    if (b == e && b == i) {\n      t[n] = x;\n      return;\n    }\n    int mid = (b + e) >> 1, l = n << 1, r = l | 1;\n    upd(l, b, mid, i, x);\n    upd(r, mid + 1, e, i, x);\n    t[n] = max(t[l] , t[r]);\n  }\n  int query(int n, int b, int e, int i, int j) {\n    if (b > j || e < i) return 0;\n    if (b >= i && e <= j) return t[n];\n    int mid = (b + e) >> 1, l = n << 1, r = l | 1;\n    int L = query(l, b, mid, i, j);\n    int R = query(r, mid + 1, e, i, j);\n    return max(L,R);\n  }\n}t;\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        for(int i = 0;i<N;i++) a[i] = 0;\n        t.build(1,1,N);\n        set<int> a;\n        int n = N;\n        vector<int> ansz;\n        for(auto &it:queries){\n            if(it[0] == 1){\n                auto y = a.upper_bound(it[1]);\n                int pval = 0;\n                int eval = 1e9;\n                if(y!=a.end()) eval = *y;\n                if(y!=a.begin()) {\n                    auto prv = prev(y);\n                    pval = *prv;\n                }\n                if(eval != 1e9){\n                    t.upd(1,1,n,eval,eval-it[1]);\n                }\n                t.upd(1,1,n,it[1],it[1]-pval);\n                a.insert(it[1]);\n            }\n            else{\n                auto y = a.upper_bound(it[1]);\n                int pval = 0;\n                if(y!=a.begin()) {\n                    auto prv = prev(y);\n                    pval = *prv;\n                }\n                int ans = t.query(1,1,n,0,pval);\n                ans = max(ans,it[1]- pval);\n                // cout<<ans<<\" \";\n                bool is = true;\n                if(ans>=it[2]) ansz.push_back(1);\n                else ansz.push_back(0);\n            }\n        }\n        // cout<<endl;\n        vector<bool> an(ansz.size(),false);\n        for(int i = 0;i<ansz.size();i++){\n            if(ansz[i]) an[i] = true;\n        }\n        return an;\n    }\n};",
    "submit_ts": 1716650863.0
}