{
    "username": "ernestlu",
    "submission": "using ll = long long;\nstruct DSU {\n\tint n;\n\tvector<int> par, sz;\n\n    #define all(x) x.begin(),x.end()\n\tDSU(int n) : n(n), par(n), sz(n, 1) {\n\t\tiota(all(par), 0);\n\t}\n\n\tint fnd(int g) {\n\t\tif (g == par[g]) return g;\n\t\treturn par[g] = fnd(par[g]);\n\t}\n\n\tbool onion(int a, int b) {\n\t\ta = fnd(a), b = fnd(b);\n\t\tif (a == b) {\n\t\t\treturn false;\n\t\t}\n\t\tif (sz[a] > sz[b]) swap(a, b);\n\t\tsz[b] += sz[a];\n\t\tpar[a] = b;\n\t\treturn true;\n\t}\n};\nclass Solution {\npublic:\n\n    bool canReachCorner(int X, int Y, vector<vector<int>> &circles) {\n    int n = (int)circles.size();\n    DSU dsu(n + 4);\n\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if (dsu.fnd(i) == dsu.fnd(j))\n            continue;\n        const auto &x = circles[i], y = circles[j];\n        ll d = ((ll)x[0] - y[0]) * ((ll)x[0] - y[0]) + ((ll)x[1] - y[1]) * ((ll)x[1] - y[1]);\n        ll rd = x[2] + y[2];\n        if (rd * rd >= d)\n          dsu.onion(i, j);\n      }\n    }\n\n    for (int i = 0; i < n; i++) {\n      int x = circles[i][0], y = circles[i][1];\n      int r = circles[i][2];\n      if (x <= r)\n        dsu.onion(n, i);\n\n      if (y + r >= Y)\n        dsu.onion(n + 1, i);\n\n      if (x + r >= X)\n        dsu.onion(n + 2, i);\n\n      if (y <= r)\n        dsu.onion(n + 3, i);\n    }\n    if (dsu.fnd(n) == dsu.fnd(n + 2) || dsu.fnd(n) == dsu.fnd(n + 3) ||\n        dsu.fnd(n + 1) == dsu.fnd(n + 2) || dsu.fnd(n + 1) == dsu.fnd(n + 3)) {\n      return false;\n    }\n\n    return true;\n  }\n};",
    "submit_ts": "1722134589",
    "subm_id": "1335671299"
}