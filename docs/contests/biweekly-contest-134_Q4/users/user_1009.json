{
    "username": "CoderChatur",
    "submission": "//Template for generic segment tree\n// Credits to HealthyUG for the inspiration.\n// Segment Tree with Point Updates and Range Queries\n// Supports multiple Segment Trees with just a change in the Node and Update\n// Very few changes required everytime\n#define ll long long \ntemplate <typename Node, typename Update>\nstruct SegTree\n{\n   vector<Node> tree;\n   vector<int> arr; // type may change\n   int n;\n   int s;\n   SegTree(int a_len, vector<int> &a)\n   { // change if type updated\n      arr = a;\n      n = a_len;\n      s = 1;\n      while (s < 2 * n)\n      {\n         s = s << 1;\n      }\n      tree.resize(s);\n      fill(tree.begin(), tree.end(), Node());\n      build(0, n - 1, 1);\n   }\n   void build(int start, int end, int index) // Never change this\n   {\n      if (start == end)\n      {\n         tree[index] = Node(arr[start]);\n         return;\n      }\n      int mid = (start + end) / 2;\n      build(start, mid, 2 * index);\n      build(mid + 1, end, 2 * index + 1);\n      tree[index].merge(tree[2 * index], tree[2 * index + 1]);\n   }\n   void update(int start, int end, int index, int query_index, Update &u) // Never Change this\n   {\n      if (start == end)\n      {\n         u.apply(tree[index]);\n         return;\n      }\n      int mid = (start + end) / 2;\n      if (mid >= query_index)\n         update(start, mid, 2 * index, query_index, u);\n      else\n         update(mid + 1, end, 2 * index + 1, query_index, u);\n      tree[index].merge(tree[2 * index], tree[2 * index + 1]);\n   }\n   Node query(int start, int end, int index, int left, int right)\n   { // Never change this\n      if (start > right || end < left)\n         return Node();\n      if (start >= left && end <= right)\n         return tree[index];\n      int mid = (start + end) / 2;\n      Node l, r, ans;\n      l = query(start, mid, 2 * index, left, right);\n      r = query(mid + 1, end, 2 * index + 1, left, right);\n      ans.merge(l, r);\n      return ans;\n   }\n   void make_update(int index, int val)\n   {                                   // pass in as many parameters as required\n      Update new_update = Update(val); // may change\n      update(0, n - 1, 1, index, new_update);\n   }\n   Node make_query(int left, int right)\n   {\n      return query(0, n - 1, 1, left, right);\n   }\n};\n\n//NOTE: For every different segtree do make two different struct Node and struct Update \nstruct Node1\n{\n   //jitne bhi parameters rakne hai ek node of segtree me \n   int val; // may change\n   Node1()\n   {           // Identity element \n      // Default value jo bharna hai jo tab return ho in case of no overlap in query function(jisse answer me fark na pade)\n      val = -1; // may change\n   }\n   Node1(int p1)\n   {            // Actual Node\n\t//Ye vo value hai jo leaf nodes me bharenge yani jab single node ke liye value calculate ho to kya answera aana chahiye \n      val = p1; // may change\n   }\n   void merge(Node1 &l, Node1 &r)\n   {                       // Merge two child nodes\n      val = l.val & r.val; // may change\n   }\n};\n\nstruct Update1\n{\n   int val; // may change\n   Update1(int p1)\n   {            // Actual Update\n      val = p1; // may change\n   }\n   void apply(Node1 &a)\n   {               // apply update to given node\n      a.val = val; // may change\n   }\n};\n\n//How to declare a segent tree \n/*\n\tSegTree<Node1, Update1> sg1 = SegTree<Node1, Update1>(n, a);\n*/\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& a, int k) {\n      ll ans=0;int n=a.size();\n      SegTree<Node1,Update1> sg=SegTree<Node1,Update1>(n,a);\n      \n        for(ll s=0;s<n;s++)\n        {\n            //finding the first point of ans\n            ll ans1=-1;\n            ll f1=s,l1=n-1;\n            ll mid1=0;\n            while(f1<=l1)\n            {\n               mid1=f1+(l1-f1)/2;\n               ll x1=sg.make_query(s,mid1).val;\n               if(x1>k)\n               {\n                  f1=mid1+1;\n               }\n               else if(x1<k)\n               {\n                  l1=mid1-1;\n               }\n               else\n               {\n                  ans1=mid1;\n                  l1=mid1-1;\n               }\n            }\n            //finding the last point of ans\n            ll ans2=-1;\n            ll f2=s,l2=n-1;\n            ll mid2=0;\n            while(f2<=l2)\n            {\n               mid2=f2+(l2-f2)/2;\n               ll x2=sg.make_query(s,mid2).val;\n               if(x2>k)\n               {\n                  f2=mid2+1;\n               }\n               else if(x2<k)\n               {\n                  l2=mid2-1;\n               }\n               else\n               {\n                  ans2=mid2;\n                  f2=mid2+1;\n               }\n            }\n            if(ans1==-1||ans2==-1)\n            {\n               continue;\n            }\n            ans+=(ans2-ans1+1);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720280179",
    "subm_id": "1311779755"
}