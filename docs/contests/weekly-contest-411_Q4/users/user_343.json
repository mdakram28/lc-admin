{
    "username": "lixiangfan97",
    "submission": "class Solution {\npublic:\n    bool canProceed(char c, int cnt0, int cnt1, int k) {\n        if (c == '0') {\n            return !(cnt1 > k && cnt0+1 > k);\n        } else {\n            return !(cnt0 > k && cnt1+1 > k);\n        }\n    }\n    // map<int, int> itvs;\n    #define MAXN 100010\n    #define ll long long\n\n    struct Node{\n        ll lazy = 0;\n        ll val = 0;\n    };\n\n    Node tree[MAXN*4];\n    void add(int pos, int l, int r, int s, int e) {\n        if (e < l || s > r) {\n            return;\n        }\n        if (l >= s && r <= e) {\n            if (l == r)\n                tree[pos].val++;\n            else\n                tree[pos].lazy++;\n            return;\n        }\n        if (tree[pos].lazy) {\n            tree[2*pos+1].lazy += tree[pos].lazy;\n            tree[2*pos+2].lazy += tree[pos].lazy;\n            tree[pos].lazy = 0;\n        }\n        int mid = (l + r) >> 1;\n        add(2*pos+1, l, mid, s, e);\n        add(2*pos+2, mid+1, r, s, e);\n        ll lv = tree[2*pos+1].lazy * (mid - l +1) + tree[2*pos+1].val;\n        ll rv = tree[2*pos+2].lazy * (r - mid) + tree[2*pos+2].val;\n        tree[pos].val = lv + rv;\n    }\n    // void add(int pos, int l, int r, int i, int val) {\n    //     if (i < l || i > r) {\n    //         return;\n    //     }\n    //     if (l == r) {\n    //         tree[pos] += val;\n    //         return;\n    //     }\n    //     int mid = (l + r) >> 1;\n    //     add(2*pos+1, l, mid, i, val);\n    //     add(2*pos+2, mid+1, r, i, val);\n    //     tree[pos] = tree[2*pos+1] + tree[2*pos+2];\n    // }\n    long long query(int pos, int l, int r, int s, int e) {\n        if (e < l || s >r) {\n            return 0;\n        }\n        if (l >= s && r <= e) {\n            return tree[pos].val + tree[pos].lazy * (r-l+1);\n        }\n        if (tree[pos].lazy) {\n            tree[pos].val +=  tree[pos].lazy * (r-l+1);\n            tree[2*pos+1].lazy += tree[pos].lazy;\n            tree[2*pos+2].lazy += tree[pos].lazy;\n            tree[pos].lazy = 0;\n        }\n        int mid = (l + r) >> 1;\n        return query(2*pos+1, l, mid, s, e)\n            + query(2*pos+2, mid+1, r, s, e);\n    }\n    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n        memset(tree, 0, sizeof(tree));\n        const int n = (int)s.size();\n        int l = 0, r = 0;\n        int cnt0 = 0, cnt1 = 0;\n        if (s[0] == '1') {\n            ++cnt1;\n        } else {\n            ++cnt0;\n        }\n        vector<int> starts;\n        vector<int> ends;\n        vector<pair<int, int> > itvs;\n        while(l < n) {\n            while (r+1 < n && canProceed(s[r+1], cnt0, cnt1, k)) {\n                ++r;\n                if (s[r] == '0')\n                    ++cnt0;\n                else \n                    ++cnt1;\n            }\n            // itvs[l] = r;\n            starts.push_back(l);\n            ends.push_back(r);\n            itvs.push_back({l, r});\n            // cout << \"l = \" << l << \", r = \" << r << endl;\n            if (s[l] == '0')\n                --cnt0;\n            else\n                --cnt1;\n            ++l;\n        }\n        sort(itvs.begin(), itvs.end(), [](const pair<int, int>& x, const pair<int, int>& y) {\n            return x.first > y.first;\n        });\n        map<vector<int>, int> q_2_idx;\n        for (int i = 0; i < (int)queries.size(); ++i) {\n            q_2_idx[queries[i]] = i;\n        }\n        sort(queries.begin(), queries.end(), [](const vector<int>& x, const vector<int>& y) {\n            return x[0] > y[0];\n        });\n\n        int idx = 0;\n        vector<long long> ans;\n        ans.resize(queries.size());\n        for (auto& q: queries) {\n            while(idx < (int)itvs.size() && itvs[idx].first >= q[0]) {\n                add(0, 0, n-1, itvs[idx].first, itvs[idx].second);\n                ++idx;\n            }\n            ans[q_2_idx[q]] = query(0, 0, n-1, q[0], q[1]);\n        }\n        // sort(starts.begin(), starts.end());\n        // sort(ends.begin(), ends.end());\n        // int si = 0, ei = 0;\n        // int overlap = 0;\n        // for (int i = 0; i < n; ++i) {\n        //     while(si < (int)starts.size() && starts[si] <= i) {\n        //         overlap++;\n        //         ++si;\n        //     }\n        //     while(ei < (int)ends.size() && ends[ei] < i) {\n        //         overlap--;\n        //         ++ei;\n        //     }\n        //     add(0, 0, n-1, i, overlap);\n        // }\n        // vector<long long> ans;\n        // ans.resize(queries.size());\n\n        // for (int i = 0; i < (int)queries.size(); ++i) {\n        //     ans[i] = query(0, 0, n-1, queries[i][0], queries[i][1]);\n        // }\n        return ans;\n    }\n};",
    "submit_ts": "1723953382",
    "subm_id": "1359819797"
}