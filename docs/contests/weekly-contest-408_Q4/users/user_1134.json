{
    "username": "LayzerK",
    "submission": "class Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        n = len(circles)\n        rank = [1 for x in range(n)]\n        par = [x for x in range(n)]\n        \n        \n        def find(node):\n            if par[node] != node:\n                par[node] = find(par[node])\n            return par[node]\n        \n        def union(n1, n2):\n            p1 = find(n1)\n            p2 = find(n2)\n            \n            if rank[p1] > rank[p2]:\n                par[p2] = p1\n            elif rank[p2] > rank[p1]:\n                par[p1] = p2\n            \n            else:\n                par[p2] = p1\n                rank[p1] += 1\n                \n        def pt_in(x1, y1, x2, y2, r):\n            dist = (x1-x2)**2 + (y1 - y2)**2\n            #print(dist, \"JHEEE\", x1, x2, y1,y2)\n            if dist <= r**2:\n                return True\n            return False\n\n        \n        \n        def get_intersections(x0, y0, r0, x1, y1, r1):\n            # circle 1: (x0, y0), radius r0\n            # circle 2: (x1, y1), radius r1\n\n            d=math.sqrt((x1-x0)**2 + (y1-y0)**2)\n\n            # non intersecting\n            if d > r0 + r1 :\n                return None\n            # One circle within other\n            if d < abs(r0-r1):\n                return None\n            # coincident circles\n            if d == 0 and r0 == r1:\n                return None\n            else:\n                a=(r0**2-r1**2+d**2)/(2*d)\n                h=math.sqrt(r0**2-a**2)\n                x2=x0+a*(x1-x0)/d   \n                y2=y0+a*(y1-y0)/d   \n                x3=x2+h*(y1-y0)/d     \n                y3=y2-h*(x1-x0)/d \n\n                x4=x2-h*(y1-y0)/d\n                y4=y2+h*(x1-x0)/d\n                return (x3, y3, x4, y4)\n        \n        lo = defaultdict(lambda: inf)\n        hi = defaultdict(lambda: 0)\n        left = defaultdict(lambda:inf)\n        right = defaultdict(lambda:0)\n        \n        intersections = defaultdict(list)\n        \n        for i, circle1 in enumerate(circles):\n            x1,y1,r1= circle1\n            \n            \n            \n            if y1 + r1 >= Y and x1 + r1 >= X:\n                #blocks off end\n                return False\n            if y1 + r1 >= Y and y1 - r1 <= 0:\n                #takes up whole Y by itself\n                return False\n            if x1 - r1 <= 0 and y1 -r1 <= 0:\n                return False\n                #blocks off start\n            if pt_in(0,0, x1,y1, r1) or pt_in(X, Y, x1, y1, r1):\n                #print(\"here\", circle1)\n                return False\n            for j in range(i+1, len(circles)):\n                circle2 = circles[j]\n                x2, y2, r2 = circle2\n                intersection = get_intersections(circle1[0], circle1[1], circle1[2], circle2[0], circle2[1], circle2[2])\n                if not intersection:\n                    continue\n                else:\n                    \n                    #can they be a combined blocker\n                    \n                    if min(x1 - r1, x2 - r2) <= 0 and min(y1-r1, y2 - r2) <= 0:\n                        #print(\"aaa\")\n                        #combines to block 0\n                        return False\n                    if max(x1 + r1, x2 + r2) >= X and max(y1 + r1, y2 + r2) >= Y:\n                        #print(\"ee\")\n                        #combines to block X,Y\n                        return False\n                    \n                    \n                    \n                    union(i, j)\n        \n        circle_lo = defaultdict(lambda: inf)\n        circle_hi = defaultdict(lambda:0)\n        circle_left = defaultdict(lambda: inf)\n        circle_right = defaultdict(lambda: 0)\n        for i in range(n):\n            p = find(i)\n            \n            x,y,r = circles[i]\n            \n            circle_lo[p] = min(circle_lo[p], y-r)\n            circle_hi[p] = max(circle_hi[p], y+r)\n            \n            circle_left[p] = min(circle_left[p], x-r)\n            circle_right[p] = max(circle_right[p], x + r)\n        \n        for p in circle_lo:\n            if circle_lo[p] <= 0 and circle_hi[p] >= Y:\n                return False\n            if circle_left[p] <= 0 and circle_right[p] >= X:\n                return False\n                                                                                         \n                    \n                    \n                    \n\n    \n        return True",
    "submit_ts": "1722138076",
    "subm_id": "1335781490"
}