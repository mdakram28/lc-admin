{
    "username": "Kareem_Elgoker",
    "submission": "// Don't forget long long\ntypedef long long ll;\nconst static auto _ = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\n\nvector<vector<ll >> sparse_table;\nvector<ll> LOG;\n\n// update this variable to a value that has no effect on the answer of the operation\nll neutral = -1;\n\n// update this function for the desired operation\nlong long merge(long long val1, long long val2)\n{\n    return val1 & val2;\n}\n\nvoid build(vector<ll> arr)\n{\n    int n = arr.size();\n    LOG.resize(n + 1);\n\n    for (int i = 1; i <= n; ++i) {\n        LOG[i] = __lg(i);\n    }\n\n    sparse_table.assign(LOG[n] + 1, vector<ll>(n));\n\n    sparse_table[0] = arr;\n\n    for (int i = 1; i <= LOG[n]; ++i) {\n        int len = 1 << (i - 1);\n        for (int j = 0; j + 2 * len <= n; ++j) {\n            sparse_table[i][j] = merge(sparse_table[i - 1][j], sparse_table[i - 1][j + len]);\n        }\n    }\n}\n\n// use this as a general case but a bit slower\nlong long query(int l, int r) // 0 indexed range, O(log(N))\n{\n    int len = r - l + 1;\n    int cnt = 0;\n\n    int ans = neutral;\n    while (len)\n    {\n        if(len & 1)\n        {\n            ans = merge(ans, sparse_table[cnt][l]);\n            l += 1 << cnt;\n        }\n        len >>= 1;\n        cnt++;\n    }\n\n    return ans;\n}\n\n// use this for [min, max, or ,and, gcd, lcm] in O(1) time\nll query_overlap(int l, int r) // 0 indexed range, fast O(1) -> but must [(x op x) = x].\n{\n    ll len = r - l + 1;\n    ll row = LOG[len];\n\n    return merge(sparse_table[row][l], sparse_table[row][r - (1 << row) + 1]);\n}\n\nclass Solution {\npublic:\n\n    int minimumDifference(vector<int>& num, int k) {\n        vector<ll> nums(num.begin(), num.end());\n        build(nums);\n        ll fin = 1e9;\n        for (int i = 0; i < nums.size(); ++i) {\n            int low = i, high = nums.size() - 1, mid, ans = i;\n            while (low <= high)\n            {\n                mid = (low + high) / 2;\n                if(query_overlap(i, mid) >= k)\n                {\n                    ans = mid;\n                    low = mid + 1;\n                }\n                else high = mid - 1;\n            }\n            fin = min(fin, abs(k - query_overlap(i, ans)));\n            if(ans < nums.size() - 1)\n                fin = min(fin, abs(k - query_overlap(i, ans + 1)));\n        }\n        return fin;\n    }\n\n};",
    "submit_ts": 1717297211.0
}