{
    "username": "qqwrv",
    "submission": "constexpr int mod = 1e9 + 7;\nconstexpr long long kInf = 0x3f3f3f3f3f3f3f3f;\nconst int N = 5e4 + 5;\n\nstruct node {\n    long long a[2][2];\n    long long mx;\n\n    friend node operator+(const node& lhs, const node& rhs) {\n        node res;\n\n        memset(res.a, -0x3f, sizeof(res.a));\n        res.a[0][0] = 0;\n        for (int ll = 0; ll < 2; ++ll) {\n            for (int lr = 0; lr < 2; ++lr) {\n                for (int rl = 0; rl < 2; ++rl) {\n                    for (int rr = 0; rr < 2; ++rr) {\n                        if (lr + rl != 2)\n                            res.a[ll][rr] = std::max(res.a[ll][rr], lhs.a[ll][lr] + rhs.a[rl][rr]);\n                    }\n                }\n            }\n        }\n\n        res.mx = std::max({res.a[0][0], res.a[0][1], res.a[1][0], res.a[1][1]});\n\n        return res;\n    }\n} nd[N << 2];\n\nvoid update(int x, int l, int r, int p, int t) {\n    if (l == r) {\n        nd[x].a[0][0] = 0;\n        nd[x].a[0][1] = nd[x].a[1][0] = -kInf;\n        nd[x].a[1][1] = t;\n        nd[x].mx = std::max({nd[x].a[0][0], nd[x].a[0][1], nd[x].a[1][0], nd[x].a[1][1]});\n        return;\n    }\n\n    int mid = (l + r) >> 1;\n    if (p <= mid) update(x << 1, l, mid, p, t);\n    else update(x << 1 | 1, mid + 1, r, p, t);\n    nd[x] = nd[x << 1] + nd[x << 1 | 1];\n}\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& a, vector<vector<int>>& queries) {\n        const int n = a.size();\n\n        for (int i = 0; i < n; ++i)\n            update(1, 0, n - 1, i, a[i]);\n\n        int ans = 0;\n        for (auto xy : queries) {\n            int x = xy[0];\n            int y = xy[1];\n\n            update(1, 0, n - 1, x, y);\n            long long tmp = nd[1].mx;\n            ans = ((ans + tmp % mod) % mod + mod) % mod;\n        }\n\n        for (int i = 0; i < n; ++i)\n            update(1, 0, n - 1, i, 0);\n\n        return ans;\n    }\n};",
    "submit_ts": 1716693311.0
}