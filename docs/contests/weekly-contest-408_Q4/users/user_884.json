{
    "username": "heerkshah434",
    "submission": "class Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int nc = circles.size();\n        vector<vector<int>> graph(nc + 4);\n        \n        auto addEdge = [&](int u, int v) {\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n        };\n        \n        // Create graph nodes for boundary connections\n        for (int i = 0; i < nc; i++) {\n            if (circles[i][0] <= circles[i][2]) addEdge(nc, i);\n            if (X - circles[i][0] <= circles[i][2]) addEdge(nc + 2, i);\n            if (circles[i][1] <= circles[i][2]) addEdge(nc + 1, i);\n            if (Y - circles[i][1] <= circles[i][2]) addEdge(nc + 3, i);\n            \n            // Check for circle-circle connections\n            for (int j = i + 1; j < nc; ++j) {\n                double dist = hypot(circles[i][0] - circles[j][0], circles[i][1] - circles[j][1]);\n                if (circles[i][2] + circles[j][2] >= dist) addEdge(i, j);\n            }\n        }\n        \n        auto bfs = [&](int start, int target1, int target2) {\n            queue<int> q;\n            vector<bool> visited(nc + 4, false);\n            q.push(start);\n            visited[start] = true;\n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n                for (int v : graph[u]) {\n                    if (!visited[v]) {\n                        if (v == target1 || v == target2) return true;\n                        q.push(v);\n                        visited[v] = true;\n                    }\n                }\n            }\n            return false;\n        };\n        \n        // Check if there's a path from left or bottom boundary to right or top boundary\n        return !(bfs(nc, nc + 1, nc + 2) || bfs(nc + 3, nc + 1, nc + 2));\n    }\n};",
    "submit_ts": "1722138577",
    "subm_id": "1335794333"
}