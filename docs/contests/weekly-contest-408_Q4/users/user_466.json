{
    "username": "abhishek_k11",
    "submission": "#define FAST_IO ios::sync_with_stdio(false); cin.tie(nullptr)\n#define MAXIMUM(a, b) ((a) > (b) ? (a) : (b))\n#define MAKE_PAIR make_pair\n#define PUSH_BACK push_back\n#define FIRST first\n#define SECOND second\n\nusing namespace std;\n\ntypedef vector<int> IntVector;\ntypedef vector<IntVector> IntMatrix;\ntypedef pair<int, int> IntPair;\ntypedef vector<IntPair> IntPairVector;\n\nclass Solution {\npublic:\n    int bfs(const IntMatrix &graph, int start, int t1, int t2, int nodes) {\n        queue<int> q;\n        IntVector visited(nodes + 4, 0);\n        q.push(start);\n        visited[start] = 1;\n\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            for (int v : graph[u]) {\n                if (!visited[v]) {\n                    q.push(v);\n                    visited[v] = 1;\n                }\n            }\n        }\n        return visited[t1] || visited[t2];\n    }\n\n    bool canReachCorner(int X, int Y, IntMatrix &circles2) {\n        vector<tuple<int, int, int>> circles(circles2.size());\n        IntMatrix graph(circles2.size() + 4);\n        int n = circles2.size();\n\n        for (int i = 0; i < n; ++i) {\n            circles[i] = make_tuple(circles2[i][0], circles2[i][1], circles2[i][2]);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            int x, y, r;\n            tie(x, y, r) = circles[i];\n\n            if (x <= r) {\n                graph[n].PUSH_BACK(i);\n                graph[i].PUSH_BACK(n);\n            }\n            if (X - x <= r) {\n                graph[n + 2].PUSH_BACK(i);\n                graph[i].PUSH_BACK(n + 2);\n            }\n            if (y <= r) {\n                graph[n + 1].PUSH_BACK(i);\n                graph[i].PUSH_BACK(n + 1);\n            }\n            if (Y - y <= r) {\n                graph[n + 3].PUSH_BACK(i);\n                graph[i].PUSH_BACK(n + 3);\n            }\n            for (int j = i + 1; j < n; ++j) {\n                int xj, yj, rj;\n                tie(xj, yj, rj) = circles[j];\n\n                double dist = sqrt(pow(x - xj, 2) + pow(y - yj, 2));\n                int radius_sum = r + rj;\n                if (radius_sum >= dist) {\n                    graph[i].PUSH_BACK(j);\n                    graph[j].PUSH_BACK(i);\n                }\n            }\n        }\n\n        int blocked = 0;\n        blocked = MAXIMUM(blocked, bfs(graph, n, n + 1, n + 2, n + 4));\n        blocked = MAXIMUM(blocked, bfs(graph, n + 3, n + 2, n + 1, n + 4));\n\n        return blocked ? false : true;\n    }\n};\n\nauto init = []() { \n    std::ios::sync_with_stdio(false); \n    std::cin.tie(nullptr); \n    std::cout.tie(nullptr); \n    return 'c'; \n}();\n",
    "submit_ts": "1722137497",
    "subm_id": "1335765476"
}