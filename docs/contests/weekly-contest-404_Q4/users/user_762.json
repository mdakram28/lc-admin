{
    "username": "akash967049",
    "submission": "class Tree\n{\npublic:\n    map<int, vector<int>> tree;\n\n    Tree()\n    {\n        // nothing\n    }\n\n    bool getDiameterPath(int vertex,\n                         int targetVertex,\n                         int parent,\n                         vector<int> &path)\n    {\n\n        if (vertex == targetVertex)\n        {\n\n            path.push_back(vertex);\n            return true;\n        }\n\n        for (auto i : tree[vertex])\n        {\n\n            // To prevent visiting a\n            // node already visited\n            if (i == parent)\n                continue;\n\n            // Recursive call to the neighbours\n            // of current node inorder\n            // to get the path\n            if (getDiameterPath(i, targetVertex,\n                                vertex, path))\n            {\n                path.push_back(vertex);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    void farthestNode(int vertex, int parent,\n                      int height, int &maxHeight,\n                      int &maxHeightNode)\n    {\n\n        // If the current height is maximum\n        // so far, then save the current node\n        if (height > maxHeight)\n        {\n            maxHeight = height;\n            maxHeightNode = vertex;\n        }\n\n        // Iterate over all the neighbours\n        // of current node\n        for (auto i : tree[vertex])\n        {\n            // This is to prevent visiting\n            // a already visited node\n            if (i == parent)\n                continue;\n\n            // Next call will be at 1 height\n            // higher than our current height\n            farthestNode(i, vertex,\n                         height + 1,\n                         maxHeight,\n                         maxHeightNode);\n        }\n    }\n\n    // Function to add edges\n    void addedge(int a, int b)\n    {\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n\n    vector<int> FindCenter()\n    {\n        int maxHeight = -1;\n        int maxHeightNode = -1;\n        farthestNode(0, -1, 0, maxHeight,\n                     maxHeightNode);\n        int leaf1 = maxHeightNode;\n        maxHeight = -1;\n        farthestNode(maxHeightNode,\n                     -1, 0, maxHeight,\n                     maxHeightNode);\n\n        int leaf2 = maxHeightNode;\n        // cout<<maxHeight<<\"\\n\";\n//         vector<int> path;\n\n//         getDiameterPath(leaf1, leaf2,\n//                         -1, path);\n        \n        int pathSize = maxHeight;\n        // cout<<pathSize<<\"\\n\";\n        int a = pathSize / 2;\n        if (pathSize % 2 == 1)a++;\n        return {a, pathSize};\n    }\n};\n\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        Tree t1;\n        Tree t2;\n        for(auto edge: edges1)t1.addedge(edge[0], edge[1]);\n        for(auto edge: edges2)t2.addedge(edge[0], edge[1]);\n        vector<int> a = t1.FindCenter();\n        vector<int> b = t2.FindCenter();\n        // cout<<a<<\" : \"<<b;\n        return max(a[0]+b[0]+1, max(a[1], b[1]));\n    }\n};\n\n",
    "submit_ts": 1719719841.0
}