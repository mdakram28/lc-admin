{
    "username": "zeldahuang",
    "submission": "class Solution {\npublic:\n    static const int MAX_LEN =100000 ;\n    int seg_tree[MAX_LEN << 2];\n    int Lazy[MAX_LEN << 2];\n    int arr[MAX_LEN];\n    //\u4ece\u4e0b\u5f80\u4e0a\u66f4\u65b0 \u8282\u70b9\n    void push_up (int root) {\n        seg_tree[root] = max(seg_tree[root << 1], seg_tree[root << 1 | 1]);      //\u6700\u5c0f\u503c\u6539min\n    }\n    //\u4ece\u4e0a\u5411\u4e0b\u66f4\u65b0\uff0c\u5de6\u53f3\u5b69\u5b50\n    void push_down (int root, int L, int R) {\n        if(Lazy[root]){\n            Lazy[root << 1] += Lazy [root];\n            Lazy[root << 1 | 1] += Lazy[root];\n            int mid = (L + R) >> 1;\n            seg_tree[root << 1] +=  Lazy[root] ;\n            seg_tree[root << 1 | 1] += Lazy[root] ;\n            Lazy[root] = 0;\n        }\n    }\n    //\u5efa\u6811\n    //[L,R]\u5c31\u662f\u5bf9\u5e94arr\u6570\u7ec4\u91cc\u9762\u7684\u6570\n    void build (int root, int L, int R) {\n        Lazy[root] = 0;\n        if(L == R) {\n            seg_tree[root] = L;\n            return ;\n        }\n        int mid = (L + R) >> 1;\n        build(root << 1, L, mid);\n        build(root << 1 | 1, mid + 1, R);\n        push_up(root);\n    }\n\n    //\u533a\u95f4\u67e5\u8be2\n    //\u67e5\u627e\u533a\u95f4[LL,RR]\u7684\u6700\u5927/\u5c0f\u503c\n    int query (int root, int L, int R, int LL, int RR) {\n        if (LL <= L && R <= RR) return seg_tree[root];\n        push_down(root, L, R);     //\u6bcf\u6b21\u8bbf\u95ee\u90fd\u53bb\u68c0\u67e5Lazy \u6807\u8bb0\n        int Ans = 0;\n        int mid = (L + R) >> 1;\n        if(LL <= mid) Ans = max(Ans, query(root << 1, L, mid, LL, RR));    //\u6700\u5c0f\u503c\u6539min\n        if(RR > mid) Ans = max(Ans, query(root << 1 | 1, mid + 1, R, LL, RR)); //\u6700\u5c0f\u503c\u6539min\n        return Ans;\n    }\n    //\u533a\u95f4\u4fee\u6539 +-\u67d0\u503c\n    //\u4f7f\u5f97\u533a\u95f4[LL,RR]\u7684\u503c\u90fd\u52a0\u4e0aval\n    void update_Interval(int root, int L, int R, int LL, int RR, int val){\n         if (LL <= L && R <= RR) {\n             Lazy[root] += val;\n             seg_tree[root] += val;\n            return ;\n         }\n         push_down(root, L, R);\n         int mid = (L + R) >> 1;\n         if (LL <= mid) update_Interval(root << 1, L, mid, LL, RR, val);\n         if (RR > mid) update_Interval(root << 1 | 1, mid + 1, R, LL , RR, val);\n         push_up(root);\n    }\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int tot=60000;\n        build(1,1,tot);\n        // cout<<getmax(0,100,0,tot,1)<<\">>>>\\n\";\n        set<int> se;\n        se.insert(0);\n        se.insert(tot);\n        vector<bool> ans;\n        for(auto &q:queries){\n            if(q[0]==1){\n                int x=q[1];\n                auto itl=se.lower_bound(x);\n                auto itr=itl;\n                itl--;\n                int xl=*itl;\n                int xr=*itr;\n                // cout<<x<<\" \"<<xl<<\" \"<<xr<<\"...\\n\";\n                // update(x+1,xr,xl-x,0,tot,1);\n                update_Interval(1, 1, tot, x+1, xr, xl-x);\n                // cout<<query(1, 1, tot , 3, 4)<<\"...\\n\";\n                se.insert(x);\n            }\n            else{\n                int x=q[1],len=q[2];\n                // int maxx=getmax(0, x,0,tot,1);\n                int maxx=query(1, 1, tot , 1, x);\n                // cout<<maxx<<\"...ff\\n\";\n                if(maxx>=len) ans.push_back(true);\n                else ans.push_back(false);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716652613.0
}