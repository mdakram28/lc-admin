{
    "username": "jcoves",
    "submission": "\n#ifdef LOCAL_RUN\n#include \"debug_leet.h\"\n    #else\n    #define trace(...) ;\n    #define dbg(...) ;\n    #define debug(x) ;\n    #define debuga(a, n) ;\n    #define debug2(x, y) ;\n    #define debug3(x, y, z) ;\n    #define debug4(x, y, z, w) ;\n    #define debug5(a,b,c,d,e) ;\n    #define ctime() ;\n    #define lassert(x) ;\n    #define dassert(x, ...) ;\n    int recur_depth = 0; bool rec_indent = true;\n    const bool isLocal = false;\n    template <typename Arg, typename... Args>\n    void display(TreeNode* root) {}\n    #endif\n\n    #define pb push_back\n    #define eb emplace_back\n    #define popb pop_back\n    #define all(v) begin(v), end(v)\n    #define rall(v) (v).rbegin(),(v).rend()\n    #define make_unique(v) (v).erase(unique(all(v)), (v).end())\n    #define sz(c) ((int) c.size())\n    #define forn(i,n) for(int i=0;i<(int)(n);i++)\n    #define fornn(i,s,n) for(int i=s;i<(int)(n);i++)\n    #define forb(i,n) for(int i=n-1;i>=0;i--)\n    #define forbn(i,s,n) for(int i=n-1;i>=(int)(s);i--)\n    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n    #define mem(a,b) memset(a,b,sizeof(a))\n    #define abs(x) (((x) < 0) ? -(x) : (x))\n    #define sqr(x) ((x) * (x))\n    #define sqrt(x) sqrt(abs(x))\n    #define has(c,x) (c.find(x) != c.end())\n    #define pw(x) (1LL << (x))\n    #define ibit(x,i) (((x) >> (i)) & 1)\n    #define data(v) v.data(), sz(v) // vi -> vai\n\n    typedef stringstream sstr;\n    typedef long long ll;\n    typedef long double ld;\n    typedef pair<int, int> pii;\n    typedef pair<ll,ll> pll;\n    typedef pair<ld,ld> pdd;\n    typedef vector<int> vi;\n    typedef vector<ll> vll;\n    typedef vector<pii> vpii;\n    typedef vector<vi> vvi;\n    typedef vector<vll> vvll;\n    typedef valarray<int> vai;\n    template <class T>\n    using min_pq = priority_queue<T, vector<T>, greater<T>>;\n    template <class T>\n    using vc = vector<T>;\n    template <class T>\n    using vvc = vector<vc<T>>;\n    template <class T>\n    using vvvc = vector<vvc<T>>;\n    template <class T>\n    using vvvvc = vector<vvvc<T>>;\n    template <class T>\n    using vvvvvc = vector<vvvvc<T>>;\n\n    template<class F>\n    struct y_comb{\n        F f;\n        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }\n        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }\n    };\n    template<class F>\n    decltype(auto) yf(F &&f){\n        return y_comb<decay_t<F>>(forward<F>(f));\n    }\n\n    inline int ni(){ int x; cin >> x;   return x; }\n    inline ll  nl() { ll  x; cin >> x; return x; }\n\n    template <class T> void mmin(T& a, const T& b) {\n        a = (a) < (b) ? (a) : (b);\n    }\n    template <class T> void mmax(T& a, const T& b) {\n        a = (a) > (b) ? (a) : (b);\n    }\n    template <class T> auto vv(int d1, T x){\n        return vc<T>(d1, x);\n    }\n    template <class T> auto vv(int d1, int d2, T x){\n        return vc<vc<T>>(d1, vc<T>(d2, x));\n    }\n    template <class T> auto vv(int d1, int d2, int d3, T x){\n        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));\n    }\n    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){\n        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));\n    }\n    void outv(auto &v){\n        for(auto &x: v) {cout<< x <<\" \";} cout<<endl;\n    }\n    void rvec(int &n, auto &v){\n        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);\n    }\n    template <typename Arg, typename... Args>\n    void read(Arg&& arg, Args&&... args){\n        cin >> std::forward<Arg>(arg); using expander = int[];\n        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};\n    }\n    template <typename Arg, typename... Args>\n    void out(Arg&& arg, Args&&... args){\n        cout << std::forward<Arg>(arg); using expander = int[];\n        (void)expander{0, (void(cout << \" \" << std::forward<Args>(args)),0)...};\n        cout << endl;\n    }\n    template <class Integer, class F>\n    Integer find_first_false(Integer l, Integer r, F&& f) {\n        --l; // ++r;\n        while (r - l > 1) {\n            Integer m = midpoint(l, r);\n            if (f(m)) l = m;\n            else r = m;\n        }\n        return r;\n    }\n    template <class Integer, class F>\n    Integer find_first_true(Integer l, Integer r, F &&f) {\n        return find_first_false(l, r, [&f](Integer i) { return !f(i); });\n    }\n    auto init = []() {\n        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';\n    }();\n\n    ll pwr(ll base, ll p, ll mod){\n        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;\n            base=(base*base)%mod; p/=2;}\n        return ans;\n    }\n    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }\n    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }\n\n    const long double PI = (long double)(3.1415926535897932384626433832795);\n    const ll  mx_ll   = numeric_limits<ll> :: max();\n    const int mx_int  = numeric_limits<int> :: max();\n\n    const int oo = 0x3f3f3f3f;\n    const ll  OO = 0x3f3f3f3f3f3f3f3fll;\n    const double eps = 1e-9;\n    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};\n    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};\n\nconst int maxn = 1e5 + 3;\nconst int mod = 1e9+7;\nclass Solution {\npublic:\n    int diam(vvi &e){\n        int n = sz(e) + 1;\n        debug(n);\n        vvi g(n); forn(i, n-1){\n            int x = e[i][0], y = e[i][1];\n            g[x].pb(y);\n            g[y].pb(x);\n            // out(x, y);\n        }\n        vi par;\n        auto getFar = [&](int source){\n            par.assign(n, -1);\n            int ans = -1;\n            queue<int> q; q.emplace(source);\n            while(sz(q)){\n                auto x = q.front(); q.pop();\n                int p = par[x];\n                ans = x;\n                for(int to: g[x]) if(p != to) {\n                    par[to] = x;\n                    q.emplace(to);\n                }\n            }\n            return ans;\n        };\n        int root = 0;\n        int a = getFar(root);\n        int b = getFar(a);\n        vi path(n);\n        int res = 0, other = -1;\n        vi ps;\n        for(int x = b; x != -1; x = par[x]){\n            ps.pb(x);\n            if(x != a and x != b) other = x;\n            path[x] = 1;\n            res++;\n        }\n        return res;\n    }\n    int minimumDiameterAfterMerge(vvi& e1, vvi& e2) {\n        int a = diam(e1), b = diam(e2);\n        debug2(a, b);\n        int ans = a/2 + b/2 + 1;\n        mmax(ans, max(a, b) - 1);\n        return ans;\n    }\n};",
    "submit_ts": 1719718012.0
}