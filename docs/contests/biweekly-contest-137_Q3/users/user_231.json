{
    "username": "VimT",
    "submission": "impl Solution {\n    pub fn maximum_value_sum(board: Vec<Vec<i32>>) -> i64 {\n        let m = board.len();\n        let n = board[0].len();\n        let mut nums = vec![];\n        for i in 0..m {\n            for j in 0..n {\n                nums.push((board[i][j], i, j));\n            }\n        }\n        nums.sort_unstable_by_key(|&(num, _, _)| -num);\n        let find_left = |x: usize, y: usize| -> Vec<(i32, usize, usize)> {\n            let mut result = Vec::with_capacity(m + n - 2);\n            for i in 0..m {\n                if i == x { continue; }\n                result.push((board[i][y], i, y));\n            }\n            for j in 0..n {\n                if j == y { continue; }\n                result.push((board[x][j], x, j));\n            }\n            result.sort_unstable_by_key(|x| -x.0);\n            result\n        };\n        fn find_one(nums: &[(i32, usize, usize)], used_i: (usize, usize), used_j: (usize, usize)) -> i64 {\n            for &(num, x, y) in nums.iter() {\n                if x == used_i.0 || x == used_i.1 || y == used_j.0 || y == used_j.1 {\n                    continue;\n                }\n                return num as i64;\n            }\n            unreachable!()\n        }\n        let find_two = |nums: &[(i32, usize, usize)], used_i: usize, used_j: usize| -> i64 {\n            for &(num, x, y) in nums.iter() {\n                if x != used_i && y != used_j {\n                    let mut result = num as i64 + find_one(nums, (used_i, x), (used_j, y));\n                    let left = find_left(x, y);\n                    for &(num, x, y) in left.iter() {\n                        if x != used_i && y != used_j {\n                            result = result.max(num as i64 + find_one(nums, (used_i, x), (used_j, y)));\n                            break;\n                        }\n                    }\n                    return result;\n                }\n            }\n            unreachable!()\n        };\n    \n        let max = nums[0].0 as i64;\n        let max_i = nums[0].1;\n        let max_j = nums[0].2;\n        let mut result = max + find_two(&nums[1..], max_i, max_j);\n        \n        for i in 0..m {\n            if i == max_i { continue; }\n            let a = board[i][max_j] as i64;\n            for j in 0..n {\n                if j == max_j { continue; }\n                let b = board[max_i][j] as i64;\n                result = result.max(a + b + find_one(&nums[..], (i, max_i), (j, max_j)));\n            }\n        }\n        result\n    }\n}",
    "submit_ts": "1723908549",
    "subm_id": "556331498"
}