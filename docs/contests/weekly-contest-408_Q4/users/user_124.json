{
    "username": "qb_2008",
    "submission": "class Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        // if any circile contains (0, 0) or (X, Y), then false.\n        // split circles into connected circle groups.\n        // If a circle group connects two edges of a rectangle (L, B), (L, R), (T, B), (T, R), then can't reach.\n        // otherwise can reach.\n        int n = circles.size();\n        vector<int64_t> circle_r2(n, 0);\n        for (int i = 0; i < n; i++) {\n            vector<int>& c = circles[i];\n            int64_t r2 = (int64_t)c[2] * c[2];\n            circle_r2[i] = r2;\n            if (getDistSquare(c[0], c[1]) <= r2) {\n                return false;\n            }\n            if (getDistSquare(c[0] - X, c[1] - Y) <= r2) {\n                return false;\n            }\n        }\n        \n        vector<int> root(n, 0);\n        for (int i = 0; i < n; i++) {\n            root[i] = i;\n        }\n        for (int i = 0; i < n; i++) {\n            int root1 = findRoot(root, i);\n            for (int j = i + 1; j < n; j++) {\n                int root2 = findRoot(root, j);\n                if (root1 == root2) {\n                    continue;\n                }\n                int64_t r2 = (int64_t)(circles[i][2] + circles[j][2]);\n                r2 *= r2;\n                if (getDistSquare(circles[i][0] - circles[j][0], circles[i][1] - circles[j][1]) <= r2) {\n                    root[root2] = root1;\n                }\n            }\n        }\n        \n        int BIT_LEFT = 1 << 0;\n        int BIT_TOP = 1 << 1;\n        int BIT_RIGHT = 1 << 2;\n        int BIT_BOTTOM = 1 << 3;\n        vector<int> touch_mask(n, 0);\n        for (int i = 0; i < n; i++) {\n            int root1 = findRoot(root, i);\n            //printf(\"root[%d] = %d\\n\", i, root1);\n            int x = circles[i][0];\n            int y = circles[i][1];\n            int r = circles[i][2];\n            \n            // dist to LEFT line\n            if (y <= Y) {\n                if (x <= r) {\n                    touch_mask[root1] |= BIT_LEFT;\n                }\n            } else {\n                if (getDistSquare(x, y - Y) <= circle_r2[i]) {\n                    touch_mask[root1] |= BIT_LEFT;\n                }\n            }\n            \n            // dist to RIGHT line\n            if (y <= Y) {\n                if (x - r <= X && x + r >= X) {\n                    touch_mask[root1] |= BIT_RIGHT;\n                }\n            }\n            \n            // dist to BOTTOM line\n            if (x <= X) {\n                if (y <= r) {\n                    touch_mask[root1] |= BIT_BOTTOM;\n                }\n            } else {\n                if (getDistSquare(x - X, y) <= circle_r2[i]) {\n                    touch_mask[root1] |= BIT_BOTTOM;\n                }\n            }\n            \n            // dist to TOP line\n            if (x <= X) {\n                if (y - r <= Y && y + r >= Y) {\n                    touch_mask[root1] |= BIT_TOP;\n                }\n            }\n            //printf(\"touch_mask[%d] = 0x%x\\n\", root1, touch_mask[root1]);\n        }\n        \n        vector<int> key = {\n         BIT_BOTTOM | BIT_LEFT,\n         BIT_LEFT | BIT_RIGHT,\n         BIT_BOTTOM | BIT_TOP,\n         BIT_TOP | BIT_RIGHT,\n        };\n        for (int i = 0; i < n; i++) {\n            if (touch_mask[i]) {\n                int a = touch_mask[i];\n                for (int j = 0; j < 4; j++) {\n                    if ((a & key[j]) == key[j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n        \n    }\n    \n    int findRoot(vector<int>& root, int i) {\n        if (root[i] == i) {\n            return i;\n        }\n        root[i] = findRoot(root, root[i]);\n        return root[i];\n    }\n    \n    int64_t getDistSquare(int dx, int dy) {\n        return (int64_t)dx * dx + (int64_t)dy * dy;\n    }\n    \n    double getDist(int dx, int dy) {\n        double a = (double)dx * dx + (double)dy * dy;\n        return sqrt(a);\n    }\n    \n};",
    "submit_ts": "1722139161",
    "subm_id": "1335809594"
}