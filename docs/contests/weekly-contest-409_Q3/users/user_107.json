{
    "username": "BarryBondsOfLC",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> struct IntervalContainer {\n    set<pair<T, T>> intervals;\n    T total = 0;\n\n    void add(T l, T r) {\n        while (true) {\n            auto it = intervals.lower_bound(make_pair(l, l));\n            if (it == intervals.end() || it->first > r - 1) break;\n            r = max(r, it->second);\n            l = min(l, it->first);\n            total -= it->second - it->first + 1;\n            intervals.erase(it);\n        }\n        while (true) {\n            auto it = intervals.lower_bound(make_pair(l, l));\n            if (it == intervals.begin()) break;\n            it--;\n            if (it->second < l + 1) break;\n            r = max(r, it->second);\n            l = min(l, it->first);\n            total -= it->second - it->first + 1;\n            intervals.erase(it);\n        }\n        intervals.insert(make_pair(l, r));\n        total += r - l + 1;\n    }\n\n    void remove(T l, T r) {\n        while (true) {\n            auto it = intervals.lower_bound(make_pair(l, l));\n            if (it == intervals.end() || it->first > r) break;\n            auto [l2, r2] = *it;\n            intervals.erase(it);\n            total -= min(r2, r) - l2 + 1;\n            if (r2 > r) {\n                intervals.insert(make_pair(r+1, r2));\n                break;\n            }\n        }\n        while (true) {\n            auto it = intervals.lower_bound(make_pair(l, l));\n            if (it == intervals.begin()) break;\n            it--;\n            if (it->second < l) break;\n            auto [l2, r2] = *it;\n            intervals.erase(it);\n            total -= min(r, r2) - l + 1;\n            if (l2 < l) intervals.insert(make_pair(l2, l-1));\n            if (r2 > r) intervals.insert(make_pair(r+1, r2)); \n            break;\n        }\n    }\n\n    bool intersects(T l, T r) {\n        auto it = intervals.lower_bound(make_pair(l, l));\n        if (it != intervals.end() && it->first <= r) return true;\n        return it != intervals.begin() && (--it)->second >= l;\n    }\n\n    bool contains(T l, T r) {\n        auto it = intervals.lower_bound(make_pair(l+1, l));\n        if (it == intervals.begin()) return false;\n        it--;\n        return it->first <= l && r <= it->second;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        auto ic = IntervalContainer<int>();\n        for (int i = 0; i < n - 1; ++i) ic.add(i, i);\n        \n        vector<int> res;\n        for (const auto& q : queries) {\n            auto u = q[0], v = q[1];\n            ic.add(u, v);\n            res.push_back(ic.intervals.size());\n        }\n        \n        return res;\n    }\n};",
    "submit_ts": "1722740028",
    "subm_id": "1343709399"
}