{
    "username": "sho1004",
    "submission": "#ifdef _SM_LOCAL\n#include \"debug.hpp\" // IWYU pragma: keep\n#else\n#include <bits/stdc++.h>\n#define Debug(...)\n#endif\nusing namespace std;\nusing ll = long long;\n// constexpr ll inf = LLONG_MAX >> 1;\n// constexpr int inf = INT_MAX >> 1;\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = (int)edges1.size() + 1;\n        int m = (int)edges2.size() + 1;\n        vector<vector<int>> g1(n), g2(m);\n        for (int i = 0; i < n - 1; i++) {\n            int u = edges1[i][0], v = edges1[i][1];\n            g1[u].push_back(v);\n            g1[v].push_back(u);\n        }\n        for (int i = 0; i < m - 1; i++) {\n            int u = edges2[i][0], v = edges2[i][1];\n            g2[u].push_back(v);\n            g2[v].push_back(u);\n        }\n        vector<int> path;\n        auto F = [&](int sz, vector<vector<int>>& g, vector<int>&d, int start) -> int {\n            d[start] = 0;\n            queue<int> que;\n            que.push(start);\n            vector<int> prev(sz, -1);\n            while (!que.empty()) {\n                int u = que.front();\n                que.pop();\n                for (int v: g[u]) if (d[v] == -1)  {\n                    d[v] = d[u] + 1;\n                    prev[v] = u;\n                    que.push(v);\n                }\n            }\n            int mx = *max_element(d.begin(), d.end());\n            int u = -1;\n            for (int i = 0; i < sz; i++) {\n                if (d[i] == mx) {\n                    u = i;\n                    break;\n                }\n            }\n            int ans = u;\n            path.clear();\n            while (u != -1) {\n                path.push_back(u);\n                u = prev[u];\n            }\n            return ans;\n        };\n        vector<int> d(n, -1);\n        int u = F(n, g1, d, 0);\n        d.assign(n, -1);\n        u = F(n, g1, d, u);\n        set<int> left;\n        for (int i: path) {\n            if (d[i] == d[u] / 2 || d[i] == (d[u] + 1) / 2) {\n                left.insert(i);\n            }\n        }\n        d.resize(m, -1);\n        d.assign(m, -1);\n        u = F(m, g2, d, 0);\n        d.assign(m, -1);\n        u = F(m, g2, d, u);\n        set<int> right;\n        for (int i: path) {\n            if (d[i] == d[u] / 2 || d[i] == (d[u] + 1) / 2) {\n                right.insert(i + n);\n            }\n        }\n        vector<vector<int>> g(n + m);\n        for (int i = 0; i < n; i++) {\n            g[i] = g1[i];\n        }\n        for (int i = 0; i < m; i++) {\n            for (int v: g2[i]) {\n                g[i + n].push_back(v + n);\n            }\n        }\n        d.resize(n + m);\n        int mn = 1 << 30;\n        for (int l: left) {\n            for (int r: right) {\n                auto G = g;\n                G[l].push_back(r);\n                G[r].push_back(l);\n                d.assign(n + m, -1);\n                u = F(n + m, G, d, 0);\n                d.assign(n + m, -1);\n                u = F(n + m, G, d, u);\n                mn = min(mn, d[u]);\n            }\n        }\n        return mn;\n    }\n};",
    "submit_ts": "1719717836",
    "subm_id": "1304402008"
}