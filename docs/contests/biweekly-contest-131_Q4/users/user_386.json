{
    "username": "anubhav100rao",
    "submission": "//seg tree for binary string operations begin toggle on range, find max cons one on range\nstruct node{\n    int max_cons_one,max_cons_zero;\n    int left_one,left_zero;\n    int right_one,right_zero;\n    node(){\n        max_cons_zero=0; max_cons_one=0;\n        left_zero=0; left_one=0;\n        right_zero=0; right_one=0;\n    }  \n};\nstruct seg_tree{\n    vector<node> st;\n    vector<int> lazy;\n    seg_tree(int n){\n        st.resize(4*n);\n        lazy.resize(4*n);\n    }\n    void build(int node,int l,int r,string &s){\n        if(l==r){\n            st[node].max_cons_one=(s[l]=='1');\n            st[node].max_cons_zero=(s[l]=='0');\n            st[node].left_one=(s[l]=='1');\n            st[node].left_zero=(s[l]=='0');\n            st[node].right_one=(s[l]=='1');\n            st[node].right_zero=(s[l]=='0');\n            return;\n        }\n        int mid=l+(r-l)/2;\n        build(2*node+1,l,mid,s);\n        build(2*node+2,mid+1,r,s);\n        st[node].max_cons_one=max({st[2*node+1].max_cons_one,st[2*node+2].max_cons_one,st[2*node+1].right_one+st[2*node+2].left_one});\n        st[node].max_cons_zero=max({st[2*node+1].max_cons_zero,st[2*node+2].max_cons_zero,st[2*node+1].right_zero+st[2*node+2].left_zero});\n        st[node].left_one=st[2*node+1].left_one;\n        if(st[2*node+1].left_one==(mid-l+1)){\n            st[node].left_one+=st[2*node+2].left_one;\n        }\n        st[node].left_zero=st[2*node+1].left_zero;\n        if(st[2*node+1].left_zero==(mid-l+1)){\n            st[node].left_zero+=st[2*node+2].left_zero;\n        }\n        st[node].right_one=st[2*node+2].right_one;\n        if(st[2*node+2].right_one==(r-(mid+1)+1)){\n            st[node].right_one+=st[2*node+1].right_one;\n        }\n        st[node].right_zero=st[2*node+2].right_zero;\n        if(st[2*node+2].right_zero==(r-(mid+1)+1)){\n            st[node].right_zero+=st[2*node+1].right_zero;\n        }\n        // cout<<l<<\" \"<<r<<\" \"<<st[node].max_cons_one<<\" \"<<st[node].max_cons_zero<<\" \"<<st[node].left_one<<\" \"<<st[node].left_zero<<\" \"<<st[node].right_one<<\" \"<<st[node].right_zero<<endl;\n    }\n    void flip(int node,int l,int r){\n        swap(st[node].max_cons_one,st[node].max_cons_zero);\n        swap(st[node].left_one,st[node].left_zero);\n        swap(st[node].right_one,st[node].right_zero);\n    }\n    void update(int node,int l,int r,int start,int end){\n        if(lazy[node]!=0){\n            flip(node,l,r);\n            lazy[node]=0;\n            if(l!=r){\n                lazy[2*node+1]^=1;\n                lazy[2*node+2]^=1;\n            }\n        }\n        if(l>=start && r<=end){\n            flip(node,l,r);\n            if(l!=r){\n                lazy[2*node+1]^=1;\n                lazy[2*node+2]^=1;\n            }\n            return;\n        }\n        if(l>end || r<start)\n            return;\n        int mid=l+(r-l)/2;\n        update(2*node+1,l,mid,start,end);\n        update(2*node+2,mid+1,r,start,end);\n        st[node].max_cons_one=max({st[2*node+1].max_cons_one,st[2*node+2].max_cons_one,st[2*node+1].right_one+st[2*node+2].left_one});\n        st[node].max_cons_zero=max({st[2*node+1].max_cons_zero,st[2*node+2].max_cons_zero,st[2*node+1].right_zero+st[2*node+2].left_zero});\n        st[node].left_one=st[2*node+1].left_one;\n        if(st[2*node+1].left_one==(mid-l+1)){\n            st[node].left_one+=st[2*node+2].left_one;\n        }\n        st[node].left_zero=st[2*node+1].left_zero;\n        if(st[2*node+1].left_zero==(mid-l+1)){\n            st[node].left_zero+=st[2*node+2].left_zero;\n        }\n        st[node].right_one=st[2*node+2].right_one;\n        if(st[2*node+2].right_one==(r-(mid+1)+1)){\n            st[node].right_one+=st[2*node+1].right_one;\n        }\n        st[node].right_zero=st[2*node+2].right_zero;\n        if(st[2*node+2].right_zero==(r-(mid+1)+1)){\n            st[node].right_zero+=st[2*node+1].right_zero;\n        }\n    }\n    pair<node,int> query(int Node,int l,int r,int start,int end){\n        if(lazy[Node]!=0){\n            flip(Node,l,r);\n            if(l!=r){\n                lazy[2*Node+1]^=1;\n                lazy[2*Node+2]^=1;\n            }\n            lazy[Node]=0;\n        }\n        if(l>=start && r<=end){\n            return {st[Node],r-l+1};\n        }\n        if(l>end || r<start)\n            return {node(),0};\n        int mid=l+(r-l)/2;\n        auto left1=query(2*Node+1,l,mid,start,end);\n        auto right1=query(2*Node+2,mid+1,r,start,end);\n        node left=left1.first,right=right1.first;\n        node ans;\n        ans.max_cons_one=max({left.max_cons_one,right.max_cons_one,left.right_one+right.left_one});\n        ans.max_cons_zero=max({left.max_cons_zero,right.max_cons_zero,left.right_zero+right.left_zero});\n        ans.left_one=left.left_one;\n        if(left.left_one==left1.second){\n            ans.left_one+=right.left_one;\n        }\n        ans.left_zero=left.left_zero;\n        if(left.left_zero==left1.second){\n            ans.left_zero+=right.left_zero;\n        }\n        ans.right_one=right.right_one;\n        if(right.right_one==right1.second){\n            ans.right_one+=left.right_one;\n        }\n        ans.right_zero=right.right_zero;\n        if(right.right_zero==right1.second){\n            ans.right_zero+=left.right_zero;\n        }\n        return {ans,left1.second+right1.second};\n    }\n};\n\n\nclass Solution {\npublic:\n    using ll = long long;\n    const ll inf = 1e11;\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int mx = 0;\n        for(auto &q: queries) {\n            mx = max(mx, q[1] + 100);\n        }\n        mx = max(mx, 3 * (int)queries.size() + 100);\n        mx += 100;\n        seg_tree tree(mx);\n        string s(mx, '0');\n        tree.build(0, 0, mx - 1, s);\n\n        vector<bool> ans;\n        tree.update(0, 0, mx - 1, 0, 0);\n        tree.update(0, 0, mx - 1, mx - 1, mx - 1);\n        set<int>adds;\n        for(auto &q: queries) {\n            int type = q[0];\n            if(type == 1) {\n                int x = q[1];\n                tree.update(0, 0, mx - 1, x, x);\n                adds.insert(x);\n            } else {\n                int x = q[1], sz = q[2];\n                if(!adds.count(x)) {\n                    tree.update(0, 0, mx - 1, x, x);\n                }\n                auto res = tree.query(0, 0, mx - 1, 0, x);\n                // cout << x << \" \" << sz << \" \" << res.first.max_cons_zero << \" \" << res.first.max_cons_one << endl;\n                \n                int curr = res.first.max_cons_zero + 1;\n                curr = min(curr, x);\n                if(curr >= sz) ans.push_back(true);\n                else ans.push_back(false);\n\n                if(!adds.count(x)) {\n                    tree.update(0, 0, mx - 1, x, x);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716651986.0
}