{
    "username": "ArpitKrishna99",
    "submission": "class Solution:\n    def bfs(self, graph, s, t1, t2, n):\n        q = deque([s])\n        vis = [0] * (n + 4)\n        vis[s] = 1\n        \n        while q:\n            u = q.popleft()\n            for v in graph[u]:\n                if not vis[v]:\n                    q.append(v)\n                    vis[v] = 1\n        \n        return vis[t1] or vis[t2]\n\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        n = len(circles)\n        circles = [((circles[i][0], circles[i][1]), circles[i][2]) for i in range(n)]\n        graph = [[] for _ in range(n + 4)]\n        \n        for i in range(n):\n            cx, cy = circles[i][0]\n            r = circles[i][1]\n            \n            if cx <= r:\n                graph[n].append(i)\n                graph[i].append(n)\n            if X - cx <= r:\n                graph[n + 2].append(i)\n                graph[i].append(n + 2)\n            if cy <= r:\n                graph[n + 1].append(i)\n                graph[i].append(n + 1)\n            if Y - cy <= r:\n                graph[n + 3].append(i)\n                graph[i].append(n + 3)\n            \n            for j in range(i + 1, n):\n                cx2, cy2 = circles[j][0]\n                r2 = circles[j][1]\n                distance = math.sqrt((cx - cx2) ** 2 + (cy - cy2) ** 2)\n                if r + r2 >= distance:\n                    graph[i].append(j)\n                    graph[j].append(i)\n        \n        res = max(self.bfs(graph, n, n + 1, n + 2, n + 4), \n                         self.bfs(graph, n + 3, n + 2, n + 1, n + 4))  \n        return not res\n",
    "submit_ts": "1722137259",
    "subm_id": "1335758668"
}