{
    "username": "shivom-parveen",
    "submission": "#include <bits/stdc++.h>\nusing ll = int;\nusing namespace std;\nconst ll INF=1e9;\nint p, q;\n#define pb push_back\n// =================\n\n// Debugging template\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename A>\nvoid __print(const A &x);\ntemplate <typename A, typename B>\nvoid __print(const pair<A, B> &p);\ntemplate <typename... A>\nvoid __print(const tuple<A...> &t);\ntemplate <typename T>\nvoid __print(stack<T> s);\ntemplate <typename T>\nvoid __print(queue<T> q);\ntemplate <typename T, typename... U>\nvoid __print(priority_queue<T, U...> q);\n/*\nvoid __print(Mint x) {\n\tcerr << x;\n}\n*/\ntemplate <typename A>\nvoid __print(const A &x) {\n\tbool first = true;\n\tcerr << '{';\n\tfor (const auto &i : x) {\n\t\tcerr << (first ? \"\" : \",\"), __print(i);\n\t\tfirst = false;\n\t}\n\tcerr << '}';\n}\ntemplate <typename A, typename B>\nvoid __print(const pair<A, B> &p) {\n\tcerr << '(';\n\t__print(p.first);\n\tcerr << ',';\n\t__print(p.second);\n\tcerr << ')';\n}\ntemplate <typename... A>\nvoid __print(const tuple<A...> &t) {\n\tbool first = true;\n\tcerr << '(';\n\tapply([&first](const auto & ...args) { ((cerr << (first ? \"\" : \",\"), __print(args), first = false), ...); }, t);\n\tcerr << ')';\n}\ntemplate <typename T>\nvoid __print(stack<T> s) {\n\tvector<T> debugVector;\n\twhile (!s.empty()) {\n\t\tT t = s.top();\n\t\tdebugVector.push_back(t);\n\t\ts.pop();\n\t}\n\treverse(debugVector.begin(), debugVector.end());\n\t__print(debugVector);\n}\ntemplate <typename T>\nvoid __print(queue<T> q) {\n\tvector<T> debugVector;\n\twhile (!q.empty()) {\n\t\tT t = q.front();\n\t\tdebugVector.push_back(t);\n\t\tq.pop();\n\t}\n\t__print(debugVector);\n}\ntemplate <typename T, typename... U>\nvoid __print(priority_queue<T, U...> q) {\n\tvector<T> debugVector;\n\twhile (!q.empty()) {\n\t\tT t = q.top();\n\t\tdebugVector.push_back(t);\n\t\tq.pop();\n\t}\n\t__print(debugVector);\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid _print(const Head &H, const Tail &...T) {\n\t__print(H);\n\tif (sizeof...(T))\n\t\tcerr << \", \";\n\t_print(T...);\n}\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << \"Line:\" << __LINE__ << \" [\" << #__VA_ARGS__ << \"] = [\"; _print(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n#define hell dbg(\"hell\");\n// =================\nclass Solution {\n  public:\n    int md(ll x, ll y, ll a, ll b) {\n      return abs(x - a) + abs(y - b);\n    }\n    int chan(vector<vector<int>> points) {\n      //dbg(\"chan : \", points);\n      ll fans = 0;\n      ll max1=-INF, min1=+INF, max0=-INF, min0=+INF;\n      vector<int> a_max1, a_min1, a_max0, a_min0;\n      ll itr_max1, itr_min1, itr_max0, itr_min0;\n      for (ll i = 0; i < (ll)points.size(); i++) {\n        auto v = points[i];\n        ll x = v[0], y = v[1];\n        if (x + y > max1) {\n          max1 = x + y;\n          a_max1 = {x,y};\n          itr_max1 = i;\n        }\n        if (x + y < min1) {\n          min1 = x + y;\n          a_min1 = {x,y};\n          itr_min1 = i;\n        }\n        if (x - y > max0) {\n          max0 = x - y;\n          a_max0 = {x,y};\n          itr_max0 = i;\n        }\n        if (x - y < min0) {\n          min0 = x - y;\n          a_min0 = {x,y};\n          itr_min0 = i;\n        }\n      }\n      //dbg(a_max0, a_max1, a_min0, a_min1);\n      vector<vector<ll>> worst;\n      worst.pb(a_min0);\n      worst.pb(a_max0);\n      worst.pb(a_min1);\n      worst.pb(a_max1);\n      //dbg(worst);\n      ll best_itr1, best_itr2;\n      for (ll i = 0; i < (ll)points.size(); i++) {\n        auto v = points[i];\n        ll x = v[0], y = v[1];\n        for (ll j = 0; j < worst.size(); j++) {\n          auto v2 = worst[j];\n          ll a = v2[0], b = v2[1];\n          fans = max(fans, md(x,y,a,b));\n          if (md(x,y,a,b) == fans) {\n            best_itr1 = i;\n            if (j == 0) \n              best_itr2 = itr_min0;\n            if (j == 1) \n              best_itr2 = itr_max0;\n            if (j == 2) \n              best_itr2 = itr_min1;\n            if (j == 3) \n              best_itr2 = itr_max1;\n          }\n        }\n      }\n      p = best_itr1;\n      q = best_itr2;\n      return fans;\n    }\n    int minimumDistance(vector<vector<int>>& points) {\n      ll b1, b2;\n      ll res = chan(points);\n      b1 = p, b2 = q;\n      vector<vector<int>> p1, p2;\n      for (ll i = 0; i < (ll)points.size(); i++) {\n        if (i != b1) {\n          p1.pb(points[i]);\n        }\n      }\n      //dbg(res);\n      //dbg(points);\n      //dbg(p, q);\n      //dbg(p1);\n      //dbg(p2);\n      for (ll i = 0; i < (ll)points.size(); i++) {\n        if (i != b2) {\n          p2.pb(points[i]);\n        }\n      }\n      ll res1 = chan(p1), res2 = chan(p2);\n\n      return min(res1, res2);\n    }\n};\n"
}