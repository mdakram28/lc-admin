{
    "username": "tmimotw",
    "submission": "class Solution {\npublic int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n    var graph1 = new HashMap<Integer, Set<Integer>>();\n    for (var edge : edges1) {\n      graph1.computeIfAbsent(edge[0], a -> new HashSet<Integer>()).add(edge[1]);\n      graph1.computeIfAbsent(edge[1], a -> new HashSet<Integer>()).add(edge[0]);\n    }\n    var graph2 = new HashMap<Integer, Set<Integer>>();\n    for (var edge : edges2) {\n      graph2.computeIfAbsent(edge[0], a -> new HashSet<Integer>()).add(edge[1]);\n      graph2.computeIfAbsent(edge[1], a -> new HashSet<Integer>()).add(edge[0]);\n    }\n    var d1 = calculateDiameter(graph1);\n    var d2 = calculateDiameter(graph2);\n    return Math.max(Math.max(d1, d2), (d1 + 1) / 2 + (d2 + 1) / 2 + 1);\n  }\n\n  private int calculateDiameter(HashMap<Integer, Set<Integer>> graph) {\n    var result = bfs(graph, 0);\n    result = bfs(graph, result[0]);\n    return result[1];\n  }\n\n  private int[] bfs(HashMap<Integer, Set<Integer>> graph, int u) {\n    int[] dist = new int[100000];\n    Arrays.fill(dist, -1);\n    var queue = new ArrayDeque<Integer>();\n    queue.offer(u);\n    dist[u] = 0;\n    while (!queue.isEmpty()) {\n      var size = queue.size();\n      while (size > 0) {\n        size--;\n        var item = queue.poll();\n        for (var nextNode : graph.getOrDefault(item, Collections.emptySet())) {\n          if (dist[nextNode] != -1)\n            continue;\n          dist[nextNode] = dist[item] + 1;\n          queue.offer(nextNode);\n        }\n      }\n    }\n    var maxDist = 0;\n    var maxDistIndex = 0;\n    for (int i = 0; i < dist.length; i++) {\n      if (dist[i] > maxDist) {\n        maxDist = dist[i];\n        maxDistIndex = i;\n      }\n    }\n    return new int[] { maxDistIndex, maxDist };\n  }\n}",
    "submit_ts": 1719719043.0
}