{
    "username": "IAFB358kMw",
    "submission": "class Solution {\n    \n    private List<List<Integer>> initializeAdjacencyList(int size) {\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < size; i++) {\n            adj.add(new ArrayList<>());\n        }\n        return adj;\n    }\n\n    private void populateEdges(List<List<Integer>> adj, int[][] edges) {\n        for (int[] edge : edges) {\n            adj.get(edge[0]).add(edge[1]);\n            adj.get(edge[1]).add(edge[0]);\n        }\n    }\n\n    private int dfs(List<List<Integer>> list, int start, int[] end) {\n        int n = list.size();\n        int[] dist = new int[n];\n        for (int i = 0; i < n; i++) {\n            dist[i] = -1;\n        }\n\n        dfsVisit(list, start, 0, dist, end);\n        return dist[end[0]];\n    }\n\n    private void dfsVisit(List<List<Integer>> list, int node, int d, int[] dist, int[] end) {\n        dist[node] = d;\n        if (d > dist[end[0]]) {\n            end[0] = node;\n        }\n        for (int neighbor : list.get(node)) {\n            if (dist[neighbor] == -1) {\n                dfsVisit(list, neighbor, d + 1, dist, end);\n            }\n        }\n    }\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int n = edges1.length + 1;\n        int m = edges2.length + 1;\n\n        List<List<Integer>> list1 = initializeAdjacencyList(n);\n        List<List<Integer>> list2 = initializeAdjacencyList(m);\n\n        populateEdges(list1, edges1);\n        populateEdges(list2, edges2);\n\n        int[] f1 = new int[1];\n        dfs(list1, 0, f1);\n        int d1 = dfs(list1, f1[0], f1);\n\n        int[] f2 = new int[1];\n        dfs(list2, 0, f2);\n        int d2 = dfs(list2, f2[0], f2);\n\n        int ans = Math.max(d1, d2);\n        int h1 = (d1 + 1) / 2;\n        int h2 = (d2 + 1) / 2;\n        ans = Math.max(ans, h1 + h2 + 1);\n\n        return ans;\n    }\n\n    \n}\n",
    "submit_ts": "1719718193",
    "subm_id": "1304411089"
}