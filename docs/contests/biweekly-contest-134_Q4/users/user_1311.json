{
    "username": "SaHiL7264",
    "submission": "#define ll long long\nclass Node {\n    public:\n    long long val;\n    \n    Node() {\n        val = (1ll<<31)-1;\n    }\n    \n    Node(long long v) {\n        val = v;\n    }\n};\n \nclass Sg {\n    public:\n    ll size;\n    vector<Node> values;\n    Node merge(Node l,Node r) {\n        return Node(l.val & r.val);\n    }\n \n    Node single(ll v) {\n        return Node(v);\n    }\n    void init(ll n) {\n        size = 1;\n        while(size < n) size *= 2; \n        values.resize(2*size -1); \n    }\n    void build(vector<int> &a,ll x,ll lx,ll rx) {\n        if(rx-lx == 1) {\n            if(lx < int(a.size())) {\n                values[x] = single(a[lx]);\n            }\n            return; \n        }\n \n        ll m = (lx+rx)/2;\n        build(a,2*x +1,lx,m);\n        build(a,2*x +2,m,rx);\n        values[x] = merge(values[2*x +1],values[2*x +2]);\n    }\n \n    void build(vector<int> &a) {\n        build(a,0,0,size);\n    }\n \n    void set(ll i,ll v,ll x,ll lx,ll rx) {\n        if(rx-lx == 1) {\n            values[x] = single(v);\n            return;\n        }\n \n        ll m = (lx+rx)/2;\n        if(i < m) {\n            set(i,v,2*x +1,lx,m);\n        }\n        else {\n            set(i,v,2*x +2,m,rx);\n        }\n        values[x] = merge(values[2*x+1],values[2*x+2]);\n    }\n \n    void set(ll i,ll v) {\n        set(i,v,0,0,size);\n    }\n\n    Node calc(ll l,ll r,ll x,ll lx,ll rx) {\n        if(lx >= r || l >= rx) return  Node();\n        if(lx >= l && rx <= r) return values[x];\n        ll m = (lx+rx)/2;\n        Node s1 = calc(l,r,2*x+1,lx,m);\n        Node s2 = calc(l,r,2*x+2,m,rx);\n        return merge(s1,s2);\n    }   \n \n    Node sum(ll l,ll r) {\n        return calc(l,r+1,0,0,size);\n    }\n};\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& arr, int k) {\n        int n = arr.size();\n        \n        Sg st;\n        st.init(n);\n        st.build(arr);\n        \n        long long ans = 0;\n        auto fMin = [&](int i) -> ll {\n                int minIndex = n;\n                int l = i;\n                int r = n-1;\n                while(l <= r){\n                    int mid = l + (r-l)/2;\n                    int res = st.sum(i, mid).val;\n                    if(res == k) {\n                        minIndex = mid;\n                        r = mid-1;\n                    }\n                    else if(res < k) r = mid-1;\n                    else l = mid+1;\n                }\n                return minIndex;\n        };\n        auto fMax = [&](int i) -> ll {\n                int maxIndex = -1;\n                int l = i;\n                int r = n-1;\n                while(l <= r){\n                    int mid = l + (r-l)/2;\n                    int res = st.sum(i, mid).val;\n                    if(res == k) {\n                        maxIndex = mid;\n                        l = mid+1;\n                    }\n                    else if(res < k) r = mid-1;\n                    else l = mid+1;\n                }\n                return maxIndex;\n            };\n        for(int i=0; i<n; ++i) {\n            int mni = fMin(i);\n            int mxi = fMax(i);\n            if(mni != n && mxi != -1) ans += (mxi - mni + 1);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720280351",
    "subm_id": "1311786096"
}