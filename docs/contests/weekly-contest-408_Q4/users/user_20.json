{
    "username": "sheepforever",
    "submission": "const int N = 5000;\n\nvector<int> edges[N];\n\nvoid insert(int x, int y) {\n    edges[x].push_back(y);\n    edges[y].push_back(x);\n}\n\nvector<bool> bfs(int n, int source) {\n    vector<bool> vis(n, false);\n    vis[source] = true;\n    queue<int> q;\n    q.push(source);\n    while (!q.empty()) {\n        int x = q.front();\n        q.pop();\n        for (int to : edges[x]) {\n            if (!vis[to]) {\n                vis[to] = true;\n                q.push(to);\n            }\n        }\n    }\n    return vis;\n}\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n        for (int i = 0; i < n + 4; ++i) {\n            edges[i].clear();\n        }\n        \n        for (int i = 0; i < n; ++i) {\n            long long x = circles[i][0];\n            long long y = circles[i][1];\n            long long r = circles[i][2];\n            \n            if (x - r <= 0) {\n                insert(n, i);\n            }\n            if (y - r <= 0) {\n                insert(n + 1, i);\n            }\n            if (x + r >= X) {\n                insert(n + 2, i);\n            }\n            if (y + r >= Y) {\n                insert(n + 3, i);\n            }\n            \n            for (int j = 0; j < i; ++j) {\n                long long x2 = circles[j][0];\n                long long y2 = circles[j][1];\n                long long r2 = circles[j][2];\n                \n                if ((x - x2) * (x - x2) + (y - y2) * (y - y2) <= (r + r2) * (r + r2)) {\n                    insert(i, j);\n                }\n            }\n        }\n        \n        vector<bool> reach[4];\n        for (int i = 0; i < 4; ++i) {\n            reach[i] = bfs(n + 4, n + i);\n        }\n        bool block = reach[0][2 + n] || reach[1][3 + n] || reach[0][1 + n] || reach[2][3 + n];\n        return !block;\n    }\n};",
    "submit_ts": "1722136180",
    "subm_id": "1335726207"
}