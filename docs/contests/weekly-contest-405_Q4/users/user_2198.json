{
    "username": "justdoit1999",
    "submission": "class Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        // trim down words duplicates to only use min cost word\n        int wl = words.size();\n        unordered_map<string, int> mp; // word, mincost\n        for (int i=0; i<wl; ++i) {\n            auto it = mp.find(words[i]);\n            if (it == mp.end()) {\n                mp[words[i]] = costs[i];\n            } else {\n                it->second = min(it->second, costs[i]);\n            }\n        }\n        words.clear();\n        costs.clear();\n        for (auto it = mp.begin(); it != mp.end(); ++it) {\n            words.push_back(it->first);\n            costs.push_back(it->second);\n        }\n\n        int n = target.length();\n        vector<int> dp(n+1, 1e9);\n        wl = words.size();\n        dp[0] = 0;\n        for (int i=0; i<=n; ++i) {\n            for (int j=0; j<wl; ++j) {\n                int m = words[j].length();\n                if (i+m > n) continue;\n                if (target.compare(i, m, words[j], 0, m) == 0) {\n                    dp[i+m] = min(dp[i+m], dp[i] + costs[j]);\n                }\n            }\n        }\n        if (dp[n] == 1e9) {\n            return -1;\n        } else {\n            return dp[n];\n        }\n    }\n};",
    "submit_ts": "1720324446",
    "subm_id": "1312399675"
}