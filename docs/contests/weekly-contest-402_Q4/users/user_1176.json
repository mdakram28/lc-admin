{
    "username": "pankaj_777",
    "submission": "#define ll int\nstruct SegTree {\n    vector<ll> sums;\n    int size;\n    SegTree(int n) {\n        size = n;\n        sums.assign(4 * size + 10, 0);\n    }\n\n    void build(ll a[], int v, int tl, int tr) {\n        if (tl == tr) {\n            sums[v] = a[tl];\n        } else {\n            int mid = tl + (tr - tl) / 2;\n            build(a, 2 * v + 1, tl, mid);\n            build(a, 2 * v + 2, mid + 1, tr);\n            sums[v] = sums[2 * v + 1] + sums[2 * v + 2];\n        }\n    }\n\n    void build(ll a[]) {\n        build(a, 0, 0, size - 1);\n    }\n\n    void update(int v, int tl, int tr, int idx, int val) {\n        if (tl == tr) {\n            sums[v] = val;\n        } else {\n            int mid = tl + (tr - tl) / 2;\n            if (idx <= mid) update(2 * v + 1, tl, mid, idx, val);\n            else update(2 * v + 2, mid + 1, tr, idx, val);\n            sums[v] = sums[2 * v + 1] + sums[2 * v + 2];\n        }\n    } \n\n    void update(int idx, int val) {\n        update(0, 0, size - 1, idx, val);\n    }\n\n    ll sum(int v, int tl, int tr, int l, int r) {\n        if (r < tl or l > tr or l > r) return 0;\n        if (tl >= l and tr <= r) return sums[v];\n        int mid = tl + (tr - tl) / 2;\n        ll res = sum(2 * v + 1, tl, mid, l, r);\n        res += sum(2 * v + 2, mid + 1, tr, l, r);\n        return res;\n    }\n\n    ll sum(int l, int r) {\n        return sum(0, 0, size - 1, l, r);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int a[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = (i != 0 and i != n - 1 and nums[i] > nums[i + 1] and nums[i] > nums[i - 1]);\n        }\n        \n        SegTree ds(n);\n        ds.build(a);\n        \n        vector<int> res;\n        for (auto &x : queries) {\n            int type = x[0];\n            if (type == 1) {\n                int l = x[1], r = x[2];\n                res.push_back(max(0, ds.sum(l, r) - ds.sum(l, l) - ds.sum(r, r)));\n            } else {\n                int idx = x[1], val = x[2];\n                nums[idx] = val;\n                \n                ds.update(idx, (idx != 0 and idx != n - 1 and nums[idx] > nums[idx - 1] and nums[idx] > nums[idx + 1]));\n                if (idx - 1 >= 1) {\n                    ds.update(idx - 1, nums[idx - 1] > nums[idx - 2] and nums[idx - 1] > nums[idx]);\n                }\n                if (idx + 1 < n - 1) {\n                    ds.update(idx + 1, nums[idx + 1] > nums[idx + 2] and nums[idx + 1] > nums[idx]);\n                }\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1718508516.0
}