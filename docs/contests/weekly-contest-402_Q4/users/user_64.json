{
    "username": "mymelochan",
    "submission": "def segfunc(x, y):\n    return x+y              #\u533a\u9593\u548c\n#################\n\n#####\u5358\u4f4d\u5143(ide_ele)#####\nide_ele = 0                 #\u533a\u9593\u548c\n#########################\n\nclass SegTree:\n    \"\"\"\n    init(init_val, ide_ele): \u914d\u5217init_val\u3067\u521d\u671f\u5316 O(N)\n    update(k, x): k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0 O(N)\n    query(l, r): \u533a\u9593[l, r)\u3092segfunc\u3057\u305f\u3082\u306e\u3092\u8fd4\u3059 O(logN)\n    j\u756a\u76ee\u306e\u8981\u7d20\u3092\u53d6\u308a\u51fa\u3059\u3068\u304d->sgt.tree[sgt.num+j]\n    \"\"\"\n    def __init__(self, init_val, segfunc, ide_ele):\n        \"\"\"\n        init_val: \u914d\u5217\u306e\u521d\u671f\u5024\n        segfunc: \u533a\u9593\u306b\u3057\u305f\u3044\u64cd\u4f5c\n        ide_ele: \u5358\u4f4d\u5143\n        n: \u8981\u7d20\u6570\n        num: n\u4ee5\u4e0a\u306e\u6700\u5c0f\u306e2\u306e\u3079\u304d\u4e57\n        tree: \u30bb\u30b0\u30e1\u30f3\u30c8\u6728(1-index)\n        \"\"\"\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        # \u914d\u5217\u306e\u5024\u3092\u8449\u306b\u30bb\u30c3\u30c8\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        # \u69cb\u7bc9\u3057\u3066\u3044\u304f\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        \"\"\"\n        k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0\n        k: index(0-index)\n        x: update value\n        \"\"\"\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def get(self,k):\n        '''\n        \u4e00\u70b9\u53d6\u5f97\n        k:\u53d6\u5f97\u3057\u305f\u3044index(0-indexed)\n        '''\n        return self.tree[self.num+k]\n\n    def query(self, l, r):\n        \"\"\"\n        [l, r)\u306esegfunc\u3057\u305f\u3082\u306e\u3092\u5f97\u308b\n        l: index(0-index)\n        r: index(0-index)\n        \"\"\"\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        N = len(nums)\n        init = [0]*N\n        for i in range(1,N-1):\n            if nums[i-1] < nums[i] > nums[i+1]:\n                init[i] = 1\n        #print(init)\n        sgt = SegTree(init,segfunc,ide_ele)\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                l,r = q[1:]\n                if l+1 > r:\n                    ans.append(0)\n                else:\n                    ans.append(sgt.query(l+1,r))\n            else:\n                idx,val = q[1:]\n                nums[idx] = val\n                if 0 < idx < N-1:\n                    sgt.update(idx,int(nums[idx-1] < nums[idx] > nums[idx+1]))\n                idx -= 1\n                if 0 < idx < N-1:\n                    sgt.update(idx,int(nums[idx-1] < nums[idx] > nums[idx+1]))\n                idx += 2\n                if 0 < idx < N-1:\n                    sgt.update(idx,int(nums[idx-1] < nums[idx] > nums[idx+1]))\n            \n            #print(list(sgt.get(i) for i in range(N)))\n        \n        return ans",
    "submit_ts": 1718506103.0
}