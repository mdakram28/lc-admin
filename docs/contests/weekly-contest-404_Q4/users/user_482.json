{
    "username": "Mohanito",
    "submission": "class Solution {\npublic:\n//     int dfs(vector<vector<int>>& graph, int curr, vector<bool>& visited, int& diameter) {\n//         vector<int> v; // save length of branches\n//         for (int next : graph[curr]) {\n//             if (visited[next]) {\n//                 continue;\n//             }\n//             visited[next] = true;\n//             v.push_back(dfs(graph, next, visited, diameter));\n//         }\n//         sort(v.rbegin(), v.rend());\n//         // diameter: top 2 + myself\n//         int t1 = (v.size() >= 1) ? v[0] : 0;\n//         int t2 = (v.size() >= 2) ? v[1] : 0;\n//         diameter = max(diameter, 1 + t1 + t2);\n//         // return the longest branch starting from me - top 1 + myself\n//         return t1 + 1;\n//     }\n    \n//     int getDiameter(vector<vector<int>>& edges) {\n//         int n = edges.size() + 1;\n//         vector<vector<int>> graph(n, vector<int>());\n//         for (auto& edge : edges) {\n//             graph[edge[0]].push_back(edge[1]);\n//             graph[edge[1]].push_back(edge[0]);\n//         }\n//         int diameter = 0;\n//         vector<bool> visited(n, false);\n//         visited[0] = true;\n//         dfs(graph, 0, visited, diameter);\n//         return diameter;\n//     }\n    pair<int, int> getDiameter(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vector<vector<int>> graph(n, vector<int>());\n        for (auto& edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n        \n        // bfs from 0 to find the one end of diamater\n        queue<int> q;\n        q.push(0);\n        vector<bool> visited(n, false);\n        visited[0] = true;\n        int end1 = -1;\n        while (q.size()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int curr = q.front();\n                q.pop();\n                end1 = curr;\n                for (int next : graph[curr]) {\n                    if (visited[next]) {\n                        continue;\n                    }\n                    visited[next] = true;\n                    q.push(next);\n                }\n            }\n        }\n        // cout << \"end 1 is \" << end1 << endl;\n        // 2. start from end 1 and find end 2\n        visited = vector<bool>(n, false);\n        vector<int> longest(n, 0);   // farthest node from curr node\n        int distance = 0;\n        q.push(end1);\n        visited[end1] = true;\n        int end2 = -1;\n        while (q.size()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int curr = q.front();\n                q.pop();\n                longest[curr] = max(longest[curr], distance);\n                end2 = curr;\n                for (int next : graph[curr]) {\n                    if (visited[next]) {\n                        continue;\n                    }\n                    visited[next] = true;\n                    q.push(next);\n                }\n            }\n            distance++;\n        }\n        \n        // cout << \"end 2 is \" << end2 << endl;\n        \n        // 3. start from end 2 and update all longest\n        visited = vector<bool>(n, false);\n        distance = 0;\n        q.push(end2);\n        visited[end2] = true;\n        while (q.size()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int curr = q.front();\n                q.pop();\n                longest[curr] = max(longest[curr], distance);\n                for (int next : graph[curr]) {\n                    if (visited[next]) {\n                        continue;\n                    }\n                    visited[next] = true;\n                    q.push(next);\n                }\n            }\n            distance++;\n        }\n        \n        // for (auto i : longest) {\n        //     cout << i << \" \";\n        // }\n        // cout << endl;\n        \n        // first is the shortest farthest node, second is diamater\n        return make_pair(*min_element(longest.begin(), longest.end())\n                        , *max_element(longest.begin(), longest.end()));\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        // minimum diameter: min(longest path in tree 1 that goes to connecting node + longest path in tree 1 that goes to connecting node, longest path in tree 1, longest path in tree 2)\n        // the farthest node from each node is one end of the diameter\n        auto p1 = getDiameter(edges1);\n        auto p2 = getDiameter(edges2);\n        int diameter1 = p1.second;\n        int diameter2 = p2.second;\n        int minfarthest1 = p1.first;\n        int minfarthest2 = p2.first;\n        // cout << minfarthest1 << \"\";\n        // cout << minfarthest2 << \"\";\n        // cout << diameter1 << \"\";\n        // cout << diameter2 << \"\" << endl;\n        \n        return max(max(diameter1, diameter2), 1 + minfarthest1 + minfarthest2);\n    }\n};",
    "submit_ts": "1719719079",
    "subm_id": "1304433249"
}