{
    "username": "auracodehandle",
    "submission": "class Solution {\npublic:\n    pair<int, int> dfs(int node, int parent, vector<vector<int>>& adj) {\n        pair<int, int> res = {0, node};\n        for (int neighbor : adj[node]) {\n            if (neighbor != parent) {\n                pair<int, int> subres = dfs(neighbor, node, adj);\n                subres.first += 1;\n                if (subres.first > res.first) {\n                    res = subres;\n                }\n            }\n        }\n        return res;\n    }\n\n    vector<int> findPath(int start, int end, vector<vector<int>>& adj, vector<int>& parent) {\n        vector<int> path;\n        int current = end;\n        while (current != start) {\n            path.push_back(current);\n            current = parent[current];\n        }\n        path.push_back(start);\n        reverse(path.begin(), path.end());\n        return path;\n    }\n\n    int treeDiameter(vector<vector<int>>& adj, int &midpoint) {\n        pair<int, int> firstDFS = dfs(0, -1, adj);\n        pair<int, int> secondDFS = dfs(firstDFS.second, -1, adj);\n\n        // Use BFS to find the path from firstDFS.second to secondDFS.second\n        int n = adj.size();\n        vector<int> parent(n, -1);\n        queue<int> q;\n        q.push(firstDFS.second);\n        parent[firstDFS.second] = firstDFS.second;\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            for (int neighbor : adj[node]) {\n                if (parent[neighbor] == -1) {\n                    parent[neighbor] = node;\n                    q.push(neighbor);\n                }\n            }\n        }\n\n        vector<int> path = findPath(firstDFS.second, secondDFS.second, adj, parent);\n        midpoint = path[path.size() / 2];\n        return secondDFS.first;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n\n        vector<vector<int>> adj1(2e5 + 1), adj2(m);\n\n        for (auto& a : edges1) {\n            adj1[a[0]].push_back(a[1]);\n            adj1[a[1]].push_back(a[0]);\n        }\n\n        for (auto& a : edges2) {\n            adj2[a[0]].push_back(a[1]);\n            adj2[a[1]].push_back(a[0]);\n        }\n\n        int midpoint1, midpoint2;\n        int diameter1 = treeDiameter(adj1, midpoint1);\n        int diameter2 = treeDiameter(adj2, midpoint2);\n\n        for(auto a: edges2){\n            adj1[a[1] + n].push_back(a[0] + n);\n            adj1[a[0] + n].push_back(a[1] + n);\n        }\n\n        adj1[midpoint1].push_back(midpoint2 + n);\n        adj1[midpoint2 + n].push_back(midpoint1);\n\n        return treeDiameter(adj1, midpoint2);;\n    }\n};\n",
    "submit_ts": 1719719894.0
}