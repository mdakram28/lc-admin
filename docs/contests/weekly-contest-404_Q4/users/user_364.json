{
    "username": "ycyubill",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size()+1, m = edges2.size()+1;\n        \n        vector<int> degree(n + m, 0);\n        vector<vector<int>> neighbor(n+m);\n        \n        for(auto tmp: edges1)\n        {\n            degree[tmp[0]]++;\n            degree[tmp[1]]++;\n            neighbor[tmp[0]].push_back(tmp[1]);\n            neighbor[tmp[1]].push_back(tmp[0]);\n        }\n        \n        queue<int> q;\n        unordered_set<int> visited;\n        for(int i = 0; i < n; i++)\n            if(degree[i] == 1)\n            {\n                q.push(i);\n                visited.insert(i);\n            }\n        \n        int cur1=0;\n        while(q.size())\n        {\n            cur1 = q.front();\n            q.pop();\n            for(auto tmp: neighbor[cur1])\n            {\n                if(!visited.count(tmp))\n                {\n                    degree[tmp]--;\n                    if(degree[tmp]==1)\n                    {\n                        q.push(tmp);\n                        visited.insert(tmp);\n                    }\n                }\n            }\n        }\n        \n        \n        for(auto tmp: edges2)\n        {\n            tmp[0] += n;\n            tmp[1] += n;\n            degree[tmp[0]]++;\n            degree[tmp[1]]++;\n            neighbor[tmp[0]].push_back(tmp[1]);\n            neighbor[tmp[1]].push_back(tmp[0]);\n        }\n        \n\n        for(int i = n; i < n+m; i++)\n            if(degree[i] == 1)\n            {\n                q.push(i);\n                visited.insert(i);\n            }\n        \n        int cur2=n;\n        while(q.size())\n        {\n            cur2 = q.front();\n            q.pop();\n            for(auto tmp: neighbor[cur2])\n            {\n                if(!visited.count(tmp))\n                {\n                    degree[tmp]--;\n                    if(degree[tmp]==1)\n                    {\n                        q.push(tmp);\n                        visited.insert(tmp);\n                    }\n                }\n            }\n        }\n        \n        degree.resize(m+n, 0);\n        for(auto tmp: edges1)\n        {\n            degree[tmp[0]]++;\n            degree[tmp[1]]++;\n        }\n        for(auto tmp: edges2)\n        {\n            degree[tmp[0]]++;\n            degree[tmp[1]]++;\n        }\n        degree[cur1]++;\n        degree[cur2]++;\n        neighbor[cur1].push_back(cur2);\n        neighbor[cur2].push_back(cur1);\n        \n\n        visited.clear();\n        q.push(0);\n        visited.insert(0);\n        int end1;\n        while(q.size())\n        {\n            end1 = q.front();\n            q.pop();\n            for(int tmp: neighbor[end1])\n            {\n                if(!visited.count(tmp))\n                {\n                    q.push(tmp);\n                    visited.insert(tmp);\n                }\n            }\n        }\n        //cout<<end1<<endl;\n        \n        visited.clear();\n        q.push(end1);\n        visited.insert(end1);\n        int ans = 0;\n        while(q.size())\n        {\n            int cnt = q.size();\n            while(cnt--)\n            {\n                int cur = q.front();\n                q.pop();\n                for(auto tmp: neighbor[cur])\n                {\n                    if(!visited.count(tmp))\n                    {\n                        q.push(tmp);\n                        visited.insert(tmp);\n                    }\n                }\n            }\n            ans++;\n        }\n        return ans-1;\n\n    }\n};",
    "submit_ts": "1719718657",
    "subm_id": "1304422818"
}