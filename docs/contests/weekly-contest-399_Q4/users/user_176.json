{
    "username": "wxy9018",
    "submission": "'''Dynamic SegTree will TLE. Have to use static SegTree.\nclass SegTree:\n    def __init__(self, start, stop):\n        self.start, self.stop = start, stop # start inclusive, stop not inclusive\n        self.val = 0\n        self._left, self._right = None, None\n    \n    @property\n    def mid(self):\n        return (self.start + self.stop) // 2\n    \n    @property\n    def left(self):\n        if not self._left:\n            self._left = SegTree(self.start, self.mid)\n        return self._left\n    \n    @property\n    def right(self):\n        if not self._right:\n            self._right = SegTree(self.mid, self.stop)\n        return self._right\n    \n    def update(self, pos, val):\n        #print(self.start, self.stop, pos, val)\n        if not (self.start <= pos < self.stop): # nothing to update\n            return\n        if self.start == pos and self.stop - 1 == pos:\n            self.val = max(val, 0)\n            return\n        else:\n            self.left.update(pos, val)\n            self.right.update(pos, val)\n            self.val = max(self.query_range(self.start, pos) + self.query_range(pos+1, self.stop), \n                          self.query_range(self.start, pos-1) + self.query_range(pos+2, self.stop) + val)#, self.left.val + self.right.val\n            #print(self.val)\n    \n    def query(self, pos):\n        if not (self.start <= pos < self.stop):\n            return 0\n        elif self.start == pos and self.stop - 1 == pos: \n            return self.val\n        else:\n            if pos < self.mid:\n                return self.left.query(pos)\n            else:\n                return self.right.query(pos)\n    \n    \n    def query_range(self, begin, end):\n        #print(self.start, begin, end, self.stop)\n        if not (self.start <= begin < end <= self.stop):\n            return 0\n        if self.start == begin and self.stop == end:\n            return self.val\n        return max(self.left.query_range(begin, min(self.mid-1, end)) + self.right.query_range(max(self.mid, begin), end), \n                   self.left.query_range(begin, min(self.mid, end)) + self.right.query_range(max(self.mid+1, begin), end))\n    \n    def print_tree(self):\n        if self.start == self.stop - 1:\n            print(self.start, self.stop, self.val)\n            return\n        print(self.start, self.stop, self.val)\n        self.left.print_tree()\n        self.right.print_tree()\n'''\n\nclass SegTree:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.tree = [None] * (4 * self.n)\n        self.build(nums, 0, 0, self.n - 1)\n    \n    def build(self, nums, node, start, end):\n        if start == end:\n            self.tree[node] = (max(0, nums[start]), 0, 0, 0)\n        else:\n            mid = (start + end) // 2\n            left_child = 2 * node + 1\n            right_child = 2 * node + 2\n            self.build(nums, left_child, start, mid)\n            self.build(nums, right_child, mid + 1, end)\n            self.tree[node] = self.merge(self.tree[left_child], self.tree[right_child])\n    \n    def merge(self, left, right):\n        include = max(left[2] + right[0], left[0] + right[1])\n        exclude_l = max(left[3] + right[0], left[1] + right[1])\n        exclude_r = max(left[2] + right[2], left[0] + right[3])\n        exclude_both = max(left[3] + right[2], left[1] + right[3])\n        return (include, exclude_l, exclude_r, exclude_both)\n    \n    def update(self, idx, value, node, start, end):\n        if start == end:\n            self.tree[node] = (max(0, value), 0, 0, 0)\n        else:\n            mid = (start + end) // 2\n            left_child = 2 * node + 1\n            right_child = 2 * node + 2\n            if start <= idx <= mid:\n                self.update(idx, value, left_child, start, mid)\n            else:\n                self.update(idx, value, right_child, mid + 1, end)\n            self.tree[node] = self.merge(self.tree[left_child], self.tree[right_child])\n    \n    def query(self):\n        return self.tree[0][0]\n\n\nclass Solution:\n    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n\n        segtree = SegTree(nums)\n        \n        MOD = 10 ** 9 + 7\n        \n        res = 0\n        for pos, val in queries:\n            segtree.update(pos, val, 0, 0, segtree.n - 1)\n            \n            #segtree.print_tree()\n            #print(segtree.query())\n            \n            res = (res + segtree.query()) % MOD\n        \n        return res\n        ",
    "submit_ts": 1716695921.0
}