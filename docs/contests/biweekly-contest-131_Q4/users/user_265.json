{
    "username": "rushinshah_",
    "submission": "\n#define ll long long\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass LazySegmentTree {\nprivate:\n    vector<int> tree;\n    vector<int> lazy;\n    int size;\n\n    void propagate(int node, int start, int end) {\n        if (lazy[node] != 0) {\n            tree[node] += lazy[node];\n            if (start != end) {\n                lazy[2 * node + 1] += lazy[node];\n                lazy[2 * node + 2] += lazy[node];\n            }\n            lazy[node] = 0;\n        }\n    }\n\n    void update(int node, int start, int end, int left, int right, int diff) {\n        propagate(node, start, end);\n\n        if (end < left || start > right) return;\n\n        if (left <= start && end <= right) {\n            tree[node] += diff;\n            if (start != end) {\n                lazy[2 * node + 1] += diff;\n                lazy[2 * node + 2] += diff;\n            }\n            return;\n        }\n\n        int mid = (start + end) / 2;\n        update(2 * node + 1, start, mid, left, right, diff);\n        update(2 * node + 2, mid + 1, end, left, right, diff);\n        tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);\n    }\n\n    int query(int node, int start, int end, int left, int right) {\n        propagate(node, start, end);\n\n        if (end < left || start > right) return INT_MIN;\n\n        if (left <= start && end <= right) return tree[node];\n\n        int mid = (start + end) / 2;\n        return max(query(2 * node + 1, start, mid, left, right),\n                   query(2 * node + 2, mid + 1, end, left, right));\n    }\n\npublic:\n    LazySegmentTree(vector<int>& arr) {\n        size = arr.size();\n        tree.resize(4 * size);\n        lazy.resize(4 * size);\n        build(arr, 0, 0, size - 1);\n    }\n\n    void build(vector<int>& arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(arr, 2 * node + 1, start, mid);\n            build(arr, 2 * node + 2, mid + 1, end);\n            tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    void rangeAdd(int left, int right, int diff) {\n        update(0, 0, size - 1, left, right, diff);\n    }\n\n    int rangeMaxQuery(int left, int right) {\n        return query(0, 0, size - 1, left, right);\n    }\n};\n\n\n\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector<bool> ans;\n\n        int n = queries.size();\n\n        vector<int> b(1e5 + 1);\n        for(int i = 0; i <= 1e5; i++){\n            b[i] = i;\n        }\n        LazySegmentTree st = LazySegmentTree(b);\n\n        set<int> bricks;\n        bricks.insert(0);\n        bricks.insert(1e5 + 1);\n        for(int i = 0; i < n; i++){\n            if(queries[i][0] == 1){\n                auto p = bricks.lower_bound(queries[i][1]);\n                ll g = st.rangeMaxQuery(queries[i][1], queries[i][1]);\n                // cout << g << \"\\n\";\n                  \n                st.rangeAdd(queries[i][1] + 1, *p, -g);\n                // cout << st.lazy_query(9, 9) <<\"\\n\";\n                // cout << st.lazy_query(queries[i][1] + 1, queries[i][1] + 1) << \"\\n\";\n                bricks.insert(queries[i][1]);\n            }else{\n\n                ll h = st.rangeMaxQuery(0, queries[i][1]);\n\n                // for(int i = 0; i <= 13; i++){\n                //     cout << st.lazy_query(0, i) << \"\\n\";\n                // }\n                // cout << h << \"\\n\";\n              \n                if(h >= queries[i][2])ans.push_back(true);\n                else ans.push_back(false);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716651379.0
}