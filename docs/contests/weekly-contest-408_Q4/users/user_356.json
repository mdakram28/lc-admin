{
    "username": "JasonL14",
    "submission": "class Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        def is_connected(circle1, circle2):\n            return (circle1[2] + circle2[2]) >= math.sqrt(\n                (circle1[0] - circle2[0])**2 + (circle1[1] - circle2[1])**2\n            )\n\n        def is_touching_bottom_or_right(circle):\n            return circle[0] + circle[2] >= X or circle[1] - circle[2] <= 0\n\n        def is_touching_top_or_left(circle):\n            return circle[0] - circle[2] <= 0 or circle[1] + circle[2] >= Y\n\n        def contains_origin(circle):\n            return circle[2] >= math.sqrt(\n                circle[0]**2 + circle[1]**2\n            )\n\n        for circle in circles:\n            if contains_origin(circle): return False\n        \n        seen = set()\n        queue = collections.deque()\n\n        graph = collections.defaultdict(list)\n        for i in range(len(circles)):\n            for j in range(i+1, len(circles)):\n                if is_connected(circles[i], circles[j]):\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n\n        for index, circle in enumerate(circles):\n            if is_touching_bottom_or_right(circle):\n                if is_touching_top_or_left(circle): return False\n                queue.append(index)\n                seen.add(index)\n\n\n        while queue:\n            index = queue.popleft()\n\n            for neighbor in graph[index]:\n                if neighbor in seen: continue\n                seen.add(neighbor)\n                if is_touching_top_or_left(circles[neighbor]): return False\n\n                queue.append(neighbor)\n\n\n        return True\n        ",
    "submit_ts": "1722137428",
    "subm_id": "1335763513"
}