{
    "username": "rezero456",
    "submission": "class Solution {\n    public int minChanges(int[] nums, int k) {\n        LazySegmentTree lazySegmentTree=new LazySegmentTree(new int[k+1]) {\n            @Override\n            int doQueryMerge(int leftRes, int rightRes) {\n                return Math.min(leftRes,rightRes);\n            }\n\n            @Override\n            int doQuerySpecific(int start, int end, int node) {\n                return lazyTag[node] ? (segmentTree[node] + lazyValue[node]) : segmentTree[node];\n            }\n\n            @Override\n            void doMergeLazyTag(int start, int end, int node, int value) {\n                lazyValue[node] = lazyTag[node] ? (lazyValue[node] + value) : value;\n                lazyTag[node] = true;\n            }\n        };\n        for(int i=0;i<nums.length/2;i++){\n            int first=nums[i],second=nums[nums.length-1-i];\n            int maxOnce=Math.max(k-Math.min(first,second),Math.max(first,second));\n            lazySegmentTree.update(Math.abs(first-second),Math.abs(first-second),-1);\n            lazySegmentTree.update(0,maxOnce,1);\n            if(maxOnce<k){\n                lazySegmentTree.update(maxOnce+1,k,2);\n            }\n        }\n        return lazySegmentTree.queryRange(0,k);\n    }\n\n    abstract class LazySegmentTree {\n        protected int n;\n        protected int[] segmentTree;\n        protected boolean[] lazyTag;\n        protected int[] lazyValue;\n\n        public LazySegmentTree(int[] origin) {\n            this.n = origin.length;\n            //\u4f7f\u75284\u500d\u7684\u6570\u636e\u957f\u5ea6\u7684\u7a7a\u95f4\u6765\u786e\u4fdd\u6811\u7684\u8282\u70b9\u4fe1\u606f\u53ef\u4ee5\u88ab\u653e\u4e0b\u3002\u5b9e\u9645\u4e0a\u9700\u8981\u7684\u7a7a\u95f4 =\uff08n\u5411\u4e0a\u6269\u5145\u5230\u6700\u8fd1\u76842\u7684\u67d0\u4e2a\u6b21\u65b9\uff09\u7684\u4e24\u500d\n            this.segmentTree = new int[n * 4];\n            this.lazyTag = new boolean[n * 4];\n            this.lazyValue = new int[n * 4];\n            build(origin, 0, n - 1, 0);\n        }\n\n        /**\n         * \u5efa\u6811 \u590d\u6742\u5ea6O(n) n+1/2n+1/4n+...=2n\n         */\n        public void build(int[] origin, int start, int end, int nodeIndex) {\n            if (start == end) {\n                segmentTree[nodeIndex] = origin[start];\n                return;\n            }\n            int mid = (start + end) / 2;\n            build(origin, start, mid, nodeIndex * 2 + 1);\n            build(origin, mid + 1, end, nodeIndex * 2 + 2);\n            segmentTree[nodeIndex] = doQueryMerge(doQuerySpecific(start, mid, nodeIndex * 2 + 1), doQuerySpecific(mid + 1, end, nodeIndex * 2 + 2));\n        }\n\n        /**\n         * origin[targetIndex]+=value:\n         * \u5355\u70b9\u66f4\u65b0 \u590d\u6742\u5ea6log2n\n         */\n        public void update(int startIndex, int endIndex, int value) {\n            update(0, n - 1, startIndex, endIndex, value, 0);\n        }\n\n        /**\n         * \u8303\u56f4\u67e5\u8be2 \u590d\u6742\u5ea6log2n\n         */\n        public int queryRange(int startIndex, int endIndex) {\n            return queryRange(0, n - 1, startIndex, endIndex, 0);\n        }\n\n        private int queryRange(int start, int end, int startIndex, int endIndex, int nodeIndex) {\n            if (start == startIndex && end == endIndex) {\n                return doQuerySpecific(start, end, nodeIndex);\n            }\n            int mid = (start + end) / 2;\n            if (lazyTag[nodeIndex]) {\n                update(start, mid, start, mid, lazyValue[nodeIndex], nodeIndex * 2 + 1);\n                update(mid + 1, end, mid + 1, end, lazyValue[nodeIndex], nodeIndex * 2 + 2);\n                lazyTag[nodeIndex] = false;\n                lazyValue[nodeIndex] = 0;\n                segmentTree[nodeIndex] = doQueryMerge(doQuerySpecific(start, mid, nodeIndex * 2 + 1), doQuerySpecific(mid + 1, end, nodeIndex * 2 + 2));\n            }\n            boolean includeLeft = mid >= startIndex && endIndex >= start;\n            boolean includeRight = end >= startIndex && endIndex >= (mid + 1);\n            if (includeLeft && includeRight) {\n                return doQueryMerge(\n                        queryRange(start, mid, startIndex, mid, nodeIndex * 2 + 1),\n                        queryRange(mid + 1, end, mid + 1, endIndex, nodeIndex * 2 + 2)\n                );\n            }\n            return includeLeft ? queryRange(start, mid, startIndex, endIndex, nodeIndex * 2 + 1) :\n                    queryRange(mid + 1, end, startIndex, endIndex, nodeIndex * 2 + 2);\n        }\n\n        private void update(int start, int end, int startIndex, int endIndex, int value, int nodeIndex) {\n            if (start == startIndex && end == endIndex) {\n                doMergeLazyTag(start, end, nodeIndex, value);\n                return;\n            }\n            int mid = (start + end) / 2;\n            if (lazyTag[nodeIndex]) {\n                update(start, mid, start, mid, lazyValue[nodeIndex], nodeIndex * 2 + 1);\n                update(mid + 1, end, mid + 1, end, lazyValue[nodeIndex], nodeIndex * 2 + 2);\n                lazyTag[nodeIndex] = false;\n                lazyValue[nodeIndex] = 0;\n            }\n            if (endIndex <= mid) {\n                update(start, mid, startIndex, endIndex, value, nodeIndex * 2 + 1);\n            } else if (startIndex >= mid + 1) {\n                update(mid + 1, end, startIndex, endIndex, value, nodeIndex * 2 + 2);\n            } else {\n                update(start, mid, startIndex, mid, value, nodeIndex * 2 + 1);\n                update(mid + 1, end, mid + 1, endIndex, value, nodeIndex * 2 + 2);\n            }\n            segmentTree[nodeIndex] = doQueryMerge(doQuerySpecific(start, mid, nodeIndex * 2 + 1), doQuerySpecific(mid + 1, end, nodeIndex * 2 + 2));\n        }\n\n        abstract int doQueryMerge(int leftRes, int rightRes);\n\n        /**\n         * \u67e5\u8be2\u7279\u5b9a\u503c\n         */\n        abstract int doQuerySpecific(int start, int end, int node);\n\n        abstract void doMergeLazyTag(int start, int end, int node, int value);\n    }\n}",
    "submit_ts": "1721487329",
    "subm_id": "548309459"
}