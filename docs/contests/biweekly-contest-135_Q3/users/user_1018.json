{
    "username": "heartunderblade",
    "submission": "template <typename _Ty = long long>\nclass SegmentTree\n{\npublic:\n    template <typename ForIt>\n    SegmentTree(ForIt first, ForIt last)\n        : _count(std::distance(first, last))\n        , _node_count((1 << count_node(_count)) - 1)\n        , _nodes(new _Ty[_node_count + 1])\n        , _delta(new _Ty[_node_count + 1]())\n    {\n        _build(1, _count, 1, first);\n    }\n\n    SegmentTree(unsigned cnt)\n        : _count(cnt)\n        , _node_count((1 << count_node(_count)) - 1)\n        , _nodes(new _Ty[_node_count + 1]())\n        , _delta(new _Ty[_node_count + 1]())\n    {\n    }\n\n    ~SegmentTree()\n    {\n        delete[] _nodes;\n        delete[] _delta;\n    }\n\n    static unsigned count_node(unsigned len) noexcept\n    {\n        len = len * 2 - 1;\n        unsigned level = 1;\n        for (; len >>= 1; ++level) ;\n        return level;\n    }\n\n    // 0-based [l, r)\n    void update(unsigned l, unsigned r, _Ty delta) noexcept\n    {\n        // if (l > r || r > _count) throw std::logic_error(\"\");\n        if (l == r) return;\n        _update(l + 1, r, 1, _count, 1, delta);\n    }\n\n    // 0-based [l, r)\n    _Ty query(unsigned l, unsigned r) const noexcept\n    {\n        // if (l > r || r > _count) throw std::logic_error(\"\");\n        if (l >= r) return 0;\n        return _query(l + 1, r, 1, _count, 1);\n    }\n\n    // 1-based [l, r]\n    void _update(unsigned l, unsigned r, unsigned nl, unsigned nr, unsigned node, _Ty delta) noexcept\n    {\n        // assert l >= nl && r <= nr\n\n        _nodes[node] += delta * static_cast<int>((r - l + 1));\n\n        // lazy\n        if (l == nl && r == nr) {\n            _delta[node] += delta;\n            return;\n        }\n\n        if (nl == nr) {\n            return;\n        }\n\n        unsigned const m = (nl + nr) / 2;\n        if (l <= m) _update(l, std::min(r, m), nl, m, _left_child_of(node), delta);\n        if (r > m) _update(std::max(l, m + 1), r, m + 1, nr, _right_child_of(node), delta);\n    }\n\n    // 1-based [l, r]\n    _Ty _query(unsigned l, unsigned r, unsigned nl, unsigned nr, unsigned node) const noexcept\n    {\n        // assert l >= nl && r <= nr\n\n        if (l == nl && r == nr) {\n            return _nodes[node];\n        }\n\n        if (_delta[node]) {\n            _push_down(nl, nr, node);\n        }\n\n        _Ty acc = 0;\n        unsigned const m = (nl + nr) / 2;\n        if (l <= m) acc += _query(l, std::min(r, m), nl, m, _left_child_of(node));\n        if (r > m) acc += _query(std::max(l, m + 1), r, m + 1, nr, _right_child_of(node));\n        return acc;\n    }\n\nprivate:\n    // [l, r]\n    template <typename ForIt>\n    void _build(unsigned nl, unsigned nr, unsigned node, ForIt first) noexcept\n    {\n        if (nl == nr) {\n            _nodes[node] = *first;\n            return;\n        }\n\n        unsigned const left_child = _left_child_of(node);\n        unsigned const right_child = _right_child_of(node);\n        unsigned const m = (nl + nr) / 2;\n\n        _build(nl, m, left_child, first);\n        _build(m + 1, nr, right_child, std::next(first, m + 1 - nl));\n\n        _nodes[node] = _nodes[left_child] + _nodes[right_child];\n    }\n\n    void _push_down(unsigned nl, unsigned nr, unsigned node) const noexcept\n    {\n        // assert node is an inner node\n\n        _Ty const delta = _delta[node];\n        _delta[node] = 0;\n\n        unsigned const left_child = _left_child_of(node);\n        unsigned const right_child = _right_child_of(node);\n        unsigned const m = (nl + nr) / 2;\n\n        // does not matter if a child is leaf\n\n        _delta[left_child] += delta;\n        _delta[right_child] += delta;\n\n        _nodes[left_child] += delta * (m - nl + 1);\n        _nodes[right_child] += delta * (nr - m);\n    }\n\n    static unsigned _left_child_of(unsigned node) noexcept\n    {\n        return node << 1;\n    }\n\n    static unsigned _right_child_of(unsigned node) noexcept\n    {\n        return node << 1 | 1;\n    }\n\n    // count of elements in [first, last)\n    unsigned const _count;\n\n    // node count in the tree\n    unsigned const _node_count;\n\n    // nodes with 1-based indexes\n    // for i > 0, if _nodes[i] corresponds to [first, last]\n    // _nodes[i * 2] is the left child of _nodes[i]\n    //     and it corresponds to [first, first + (last - first) / 2]\n    // _nodes[i * 2 + 1] is the right child of _nodes[i]\n    //     and corresponds to [first + (last - first) / 2 + 1, last]\n    _Ty *const _nodes;\n\n    // denoting that children of the node are not yet updated\n    _Ty *const _delta;\n};\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int minChanges(vector<int> const &nums, int const k)\n    {\n        int const num_max = *max_element(nums.cbegin(), nums.cend());\n        SegmentTree<long long> st(num_max + 1);\n        int const n = nums.size(), half_n = n / 2;\n        for (int i = 0; i != half_n; ++i)\n        {\n            int const lhs = nums[i], rhs = nums[n - i - 1];\n            auto const [mn, mx] = minmax(lhs, rhs);\n            int const diff = mx - mn;\n            int const upper_line = max(mx, num_max - mn);\n            st.update(0, diff, 1);\n            st.update(diff + 1, upper_line + 1, 1);\n            st.update(upper_line + 1, num_max + 1, 2);\n        }\n        int winner = numeric_limits<int>::max();\n        for (int candidate_x = 0; candidate_x <= num_max; ++candidate_x)\n        {\n            int const challenger = st.query(candidate_x, candidate_x + 1);\n            if (winner > challenger) winner = challenger;\n        }\n        return winner;\n    }\n};",
    "submit_ts": "1721489062",
    "subm_id": "548317157"
}