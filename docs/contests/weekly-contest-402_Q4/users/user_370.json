{
    "username": "sheldon-29",
    "submission": "class Solution {\n    typedef long long ll;\n    static const ll MN = 1L*INT_MIN*100000;\n    static const ll MX = 1l*INT_MAX*100000;\n    const int inf = 0x3f3f3f3f;\n    struct my_tree{\n    struct node{\n        ll l,r;\n        int left_son = -1,right_son = -1;\n        ll sum = 0;\n        ll mx = MN;\n        ll mn = MX;\n    };\n    int id = 1;\n    vector<node>tree = vector<node>(1,node());\n    void pushup(int k){\n        ll ans = 0;\n        ll mx = MN;\n        ll mn = MX;\n        if(tree[k].left_son != -1){\n            ans += tree[tree[k].left_son].sum;\n            mx = max(mx,tree[tree[k].left_son].mx);\n            mn = min(mn,tree[tree[k].left_son].mn);\n        }\n        if(tree[k].right_son != -1){\n            ans += tree[tree[k].right_son].sum;\n            mx = max(mx,tree[tree[k].right_son].mx);\n            mn = min(mn,tree[tree[k].right_son].mn);\n        }\n        tree[k].sum = ans;\n        tree[k].mx = mx;\n        tree[k].mn = mn;\n    }\n    //\u4fee\u6539\u4e0b\u6807\u4e3aid\u7684\u503c\u4e3aval\n    void insert(int k,ll l,ll r,ll idx,ll val){\n        tree[k].l = l;\n        tree[k].r = r;\n        if(l != r){\n            ll mid = (l+r)>>1;\n            if(mid >= idx){\n                if(tree[k].left_son == -1){\n                    tree.emplace_back(node());\n                    tree[k].left_son = id++;\n                }\n                insert(tree[k].left_son,l,mid,idx,val);\n            }else{\n                if(tree[k].right_son == -1){\n                    tree.emplace_back(node());\n                    tree[k].right_son = id++;\n                }\n                insert(tree[k].right_son,mid+1,r,idx,val);\n            }\n            pushup(k);\n        }else{\n            tree[k].sum = val;\n            tree[k].mx = val;\n            tree[k].mn = val;\n        }\n    }\n    //\u6c42\u533a\u95f4[left,right]\u5185\u7684\u533a\u95f4\u548c\n    ll query(int k,ll l,ll r,int left,int right){\n        if(k == -1)    return 0;\n        if(l>=left && r<=right){\n            return tree[k].sum;\n        }\n        ll ans = 0;\n        ll mid = (l+r)>>1;\n        if(mid >= left){\n            ans += query(tree[k].left_son,l,mid,left,right);\n        }\n        if(mid < right){\n            ans += query(tree[k].right_son,mid+1,r,left,right);\n        }\n        return ans;\n    }\n    //\u6c42\u533a\u95f4[left,right]\u5185\u7684\u6700\u5927\u503c\n    ll query_mx(int k,ll l,ll r,int left,int right){\n        if(k == -1)    return MN;\n        if(l>=left && r<=right){\n            return tree[k].mx;\n        }\n        ll ans = MN;\n        ll mid = (l+r)>>1;\n        if(mid >= left){\n            ans = max(ans,query_mx(tree[k].left_son,l,mid,left,right));\n        }\n        if(mid < right){\n            ans = max(ans,query_mx(tree[k].right_son,mid+1,r,left,right));\n        }\n        return ans;\n    }\n    //\u6c42\u533a\u95f4[left,right]\u5185\u7684\u6700\u5c0f\u503c\n    ll query_mn(int k,ll l,ll r,int left,int right){\n        if(k == -1)    return MX;\n        if(l>=left && r<=right){\n            return tree[k].mn;\n        }\n        ll ans = MX;\n        ll mid = (l+r)>>1;\n        if(mid >= left){\n            ans = min(ans,query_mn(tree[k].left_son,l,mid,left,right));\n        }\n        if(mid < right){\n            ans = min(ans,query_mn(tree[k].right_son,mid+1,r,left,right));\n        }\n        return ans;\n    }\n\n    //\u627e\u51fa[left,right]\u8303\u56f4\u5185\u7b2c\u4e00\u4e2a\u503c\u5927\u4e8emaxVal\u7684\u4e0b\u6807\uff0c\u627e\u4e0d\u5230\u8fd4\u56de-1\n    int find_mx(int k,int left,int right,int maxVal){\n        if(k == -1) return -1;\n        if(tree[k].mx <= maxVal) return -1;\n        if(tree[k].l > right)   return -1;\n        if(tree[k].r < left)    return -1;\n        if(tree[k].l == tree[k].r){\n            return tree[k].l;\n        }\n        int ret = find_mx(tree[k].left_son,left,right,maxVal);\n        if(ret == -1){\n            return find_mx(tree[k].right_son,left,right,maxVal);\n        }\n        return ret;\n    }\n};\nvoid update(my_tree& o1,int index,vector<int>& nums){\n    int n = nums.size();\n    ll l = 0,r = n+5;\n    if(index > 0 && index < n-1){\n        if(nums[index] > nums[index-1] && nums[index] > nums[index+1]){\n            o1.insert(0,l,r,index,1);\n        }else{\n            o1.insert(0,l,r,index,0);\n        }\n    }\n}\n\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        ll l = 0,r = n+5;\n        my_tree o1;\n\n        for(int i = 1;i<n-1;i++){\n            if(nums[i] > nums[i-1] && nums[i] > nums[i+1]){\n                o1.insert(0,l,r,i,1);\n            }\n        }\n        vector<int>ans;\n        for(auto q: queries){\n            if(q[0] == 1){\n                int sum = o1.query(0,l,r,q[1],q[2]);\n                int left = q[1],right = q[2];\n                if(left != 0 && left != n-1 && nums[left] > nums[left-1] && nums[left] > nums[left+1]){\n                    sum--;\n                }\n                if(right != left && right != 0 && right != n-1 && nums[right] > nums[right-1] && nums[right] > nums[right+1]){\n                    sum--;\n                }\n                ans.emplace_back(sum);\n            }else{\n                int idx = q[1],val = q[2];\n                nums[idx] = val;\n                //\u66f4\u65b0\u81ea\u8eab\n                update(o1,idx,nums);\n                update(o1,idx-1,nums);\n                update(o1,idx+1,nums);\n                \n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718507345.0
}