{
    "username": "halllllllis",
    "submission": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate <typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define     ll              long long int\n#define     IOS             ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define     vt              vector<ll>v;\n#define     cYes            cout<<\"YES\"<<'\\n';\n#define     cNo             cout<<\"NO\"<<'\\n';\n#define     INPUT           int t;cin>>t;while(t--)\n#define     vl              vector<ll>\n#define     pii             pair<int,int>\n#define     pll             pair<ll,ll>\n#define     pb              push_back\n#define     F               first\n#define     S               second\n#define     forx3(x, start, stop, step) for (long long x = start; x < (long long)(stop); x += step)\n#define     forx(x, start, stop) forx3(x, start, stop, 1) \n#define     forx2(x, stop) forx(x, 0, stop)\n#define     forr(x,start,stop)  for (long long x = start; x >= (long long)(stop); x -= 1)\n#define     all(a) a.begin(), a.end()\n#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\nvoid err(istream_iterator<string> it) {\n    cout << '\\n';\n}\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n    cout << *it << \" = \" << a << ' ';\n    err(++it, args...);\n}\nstatic constexpr ll MOD  = 1e9+7;\n\nll modPow(ll base, ll exp, ll mod) {\n    ll res = 1;\n    base %= mod;\n    while (exp > 0) {\n        if (exp & 1) res = (res * base) % mod;\n        exp >>= 1;\n        base = (base * base) % mod;\n    }\n    return res;\n}\n\nclass Solution {\n    vector<int> nums;\n    vector<int> t;\n    int sz;\n    \n    bool check(int idx) {\n        if(idx <= 0 || idx >= sz - 1) return false;\n        return (nums[idx] > nums[idx - 1]) && (nums[idx] > nums[idx + 1]);\n    }\n    \n    void build(int l, int r, int v) {\n        if(l == r) {\n            t[v] = check(l);\n            return;\n        }\n        int m = (l + r) / 2;\n        build(l, m, v * 2);\n        build(m + 1, r, v * 2 + 1);\n        t[v] = t[v * 2] + t[v * 2 + 1];\n    }\n    \n    void update(int l, int r, int v, int idx) {\n        if(idx < l || idx > r) return;\n        if(l == r) {\n            t[v] = check(l);\n            return;\n        }\n        int m = (l + r) / 2;\n        update(l, m, v * 2, idx);\n        update(m + 1, r, v * 2 + 1, idx);\n        t[v] = t[v * 2] + t[v * 2 + 1];\n    }\n    \n    int query(int tl, int tr, int l, int r, int v){\n        if(l > r) return 0;\n        if(tl == l && tr == r) return t[v];\n        int m = (tl + tr) / 2;\n        return query(tl, m, l, min(r, m), v * 2) + query(m + 1, tr, max(m + 1, l), r, v * 2 + 1);\n    }\n    \npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        sz = nums.size();\n        this->nums = move(nums);\n        t.resize(sz * 4);\n        vector<int> res;\n        build(0, sz - 1, 1);\n        for(auto& q: queries) {\n            if(q[0] == 1) {\n                if(q[2] - q[1] < 2) res.pb(0);\n                else res.pb(query(0, sz - 1, q[1] + 1, q[2] - 1, 1));\n            } else {\n                this->nums[q[1]] = q[2];\n                update(0, sz - 1, 1, q[1]);\n                if(q[1] + 1 < sz) update(0, sz - 1, 1, q[1] + 1);\n                if(q[1] - 1 >= 0) update(0, sz - 1, 1, q[1] - 1);\n            }\n        }\n        return res;\n    }\n};\n\n",
    "submit_ts": 1718508757.0
}