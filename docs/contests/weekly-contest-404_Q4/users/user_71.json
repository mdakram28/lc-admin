{
    "username": "peterrockwave",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        n = len(edges1) + 1\n        m = len(edges2) + 1\n        \n        neighbors1 = [[] for j in range(n)]\n        parent1 = [None for j in range(n)]\n        children1 = [[] for j in range(n)]\n        height1 = [0 for j in range(n)] # height of descendant subtree\n        localdiam1 = [0 for j in range(n)] # longest path that peaks here\n        farthestup1 = [0 for j in range(n)] # distance to farthest point from here, assuming you go up first\n        farthest1 = [0 for j in range(n)] # distance to farthest point from here\n        for e in edges1:\n            neighbors1[e[0]].append(e[1])\n            neighbors1[e[1]].append(e[0])\n        \n        # setup parent,children,height and localdiam\n        def traverse1(curr):\n            for n in neighbors1[curr]:\n                if n != parent1[curr]:\n                    parent1[n] = curr\n                    children1[curr].append(n)\n                    traverse1(n)\n                    if height1[n] >= height1[curr]:\n                        height1[curr] = height1[n] + 1\n            if len(children1[curr]) >= 2:\n                a = [height1[c] for c in children1[curr]]\n                a.sort()\n                localdiam1[curr] = a[-1] + a[-2] + 2\n            else:\n                localdiam1[curr] = height1[curr]\n        def calcfarthest1(curr):\n            if parent1[curr] == None:\n                farthestup1[curr] = 0\n            else:\n                a = [height1[c] for c in children1[parent1[curr]] if c != curr]\n                if len(a) == 0:\n                    a = [-1]\n                farthestup1[curr] = max(farthestup1[parent1[curr]] + 1, max(a) + 2)\n            farthest1[curr] = max(farthestup1[curr], height1[curr])\n            for c in children1[curr]:\n                calcfarthest1(c)\n        traverse1(0)\n        calcfarthest1(0)\n        \n        \n        neighbors2 = [[] for j in range(m)]\n        parent2 = [None for j in range(m)]\n        children2 = [[] for j in range(m)]\n        height2 = [0 for j in range(m)] # height of descendant subtree\n        localdiam2 = [0 for j in range(m)] # longest path that peaks here\n        farthestup2 = [0 for j in range(m)] # distance to farthest point from here, assuming you go up first\n        farthest2 = [0 for j in range(m)] # distance to farthest point from here\n        for e in edges2:\n            neighbors2[e[0]].append(e[1])\n            neighbors2[e[1]].append(e[0])\n        \n        # setup parent,children,height and localdiam\n        def traverse2(curr):\n            for n in neighbors2[curr]:\n                if n != parent2[curr]:\n                    parent2[n] = curr\n                    children2[curr].append(n)\n                    traverse2(n)\n                    if height2[n] >= height2[curr]:\n                        height2[curr] = height2[n] + 1\n            if len(children2[curr]) >= 2:\n                a = [height2[c] for c in children2[curr]]\n                a.sort()\n                localdiam2[curr] = a[-1] + a[-2] + 2\n            else:\n                localdiam2[curr] = height2[curr]\n        def calcfarthest2(curr):\n            if parent2[curr] == None:\n                farthestup2[curr] = 0\n            else:\n                a = [height2[c] for c in children2[parent2[curr]] if c != curr]\n                if len(a) == 0:\n                    a = [-1]\n                farthestup2[curr] = max(farthestup2[parent2[curr]] + 1, max(a) + 2)\n            farthest2[curr] = max(farthestup2[curr], height2[curr])\n            for c in children2[curr]:\n                calcfarthest2(c)\n        traverse2(0)\n        calcfarthest2(0)\n        \n        ans1 = max(farthest1)\n        ans2 = max(farthest2)\n        ans3 = min(farthest1) + min(farthest2) + 1\n        return max(ans1, ans2, ans3)\n                    \n        ",
    "submit_ts": "1719716644",
    "subm_id": "1304370131"
}