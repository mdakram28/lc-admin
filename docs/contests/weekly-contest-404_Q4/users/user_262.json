{
    "username": "andyliang223",
    "submission": "class Solution {\npublic:\n    \nint dist[2][200000];\nvector<int> adj[200000];\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        \n        memset(dist, 0, sizeof(dist));\n        memset(adj, 0, sizeof(adj));\n        for(int x = 0; x < edges1.size(); x++){\n            adj[edges1[x][0]].push_back(edges1[x][1]);\n            adj[edges1[x][1]].push_back(edges1[x][0]);\n        }\n        \n        int mxNode = dfs(0, 0, 0, 0);\n        // then, find node b (this step also computes distance from a to every other\n        // node)\n        int mxNode2 = dfs(mxNode, mxNode, 0, 0);\n        // finally, compute the distance from b to every other node\n        dfs(mxNode2, mxNode2, 0, 1);\n        int best1 = INT_MAX;\n        int lmao1 = 0;\n        for (int i = 0; i < edges1.size() + 1; i++) {\n            best1 = min(best1, max(dist[0][i], dist[1][i]));\n            lmao1 = max(lmao1, dist[0][i]);\n            lmao1 = max(lmao1, dist[1][i]);\n            \n        }\n        \n        \n        memset(dist, 0, sizeof(dist));\n        memset(adj, 0, sizeof(adj));\n        for(int x = 0; x < edges2.size(); x++){\n            adj[edges2[x][0]].push_back(edges2[x][1]);\n            adj[edges2[x][1]].push_back(edges2[x][0]);\n        }\n        \n        mxNode = dfs(0, 0, 0, 0);\n        // then, find node b (this step also computes distance from a to every other\n        // node)\n        mxNode2 = dfs(mxNode, mxNode, 0, 0);\n        // finally, compute the distance from b to every other node\n        dfs(mxNode2, mxNode2, 0, 1);\n        int best2 = INT_MAX;\n        int lmao2 = 0;\n        for (int i = 0; i < edges2.size() + 1; i++) {\n            best2 = min(best2, max(dist[0][i], dist[1][i]));\n            lmao2 = max(lmao2, dist[0][i]);\n            lmao2 = max(lmao2, dist[1][i]);\n        }\n        //cout << \"best1 \" << best1 << \" best2 \" << best2 << endl;\n        return max(best1 + best2 + 1, max(lmao1, lmao2));\n        \n        \n        \n    }\n    \n\n\nint dfs(int u, int p, int d, int i) {\n\tdist[i][u] = d;\n\tint opt = -1;\n\tfor (int v : adj[u]) {\n\t\tif (v != p) {\n\t\t\tint x = dfs(v, u, d + 1, i);\n\t\t\tif (opt == -1 || dist[i][x] > dist[i][opt]) opt = x;\n\t\t}\n\t}\n\treturn opt == -1 ? u : opt;\n}\n\n};",
    "submit_ts": 1719717858.0
}