{
    "username": "CoderSahib_001",
    "submission": "class Solution {\npublic:\n    const int MOD = 1e9 + 7;\n    const int BASE = 257;\n\n    vector<long long> computePrefixHashes(const string &target) {\n        int n = target.size();\n        vector<long long> prefixHash(n + 1, 0);\n        for (int i = 1; i <= n; ++i) {\n            prefixHash[i] = (prefixHash[i - 1] * BASE + target[i - 1]) % MOD;\n        }\n        return prefixHash;\n    }\n\n    vector<long long> computeBasePowers(int n) {\n        vector<long long> basePowers(n + 1, 1);\n        for (int i = 1; i <= n; ++i) {\n            basePowers[i] = (basePowers[i - 1] * BASE) % MOD;\n        }\n        return basePowers;\n    }\n\n    long long getHash(const vector<long long> &prefixHash, const vector<long long> &basePowers, int i, int j) {\n        return (prefixHash[j + 1] - (prefixHash[i] * basePowers[j - i + 1] % MOD) + MOD) % MOD;\n    }\n\n    long long hashString(const string &str) {\n        long long hashValue = 0;\n        for (char c : str) {\n            hashValue = (hashValue * BASE + c) % MOD;\n        }\n        return hashValue;\n    }\n\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int n = target.size();\n        vector<long long> prefixHash = computePrefixHashes(target);\n        vector<long long> basePowers = computeBasePowers(n);\n        \n        unordered_map<int, unordered_map<long long, int>> wordLengthHashCostMap;\n        for (int i = 0; i < words.size(); ++i) {\n            int length = words[i].size();\n            long long wordHash = hashString(words[i]);\n            if (wordLengthHashCostMap[length].find(wordHash) == wordLengthHashCostMap[length].end() || wordLengthHashCostMap[length][wordHash] > costs[i]) {\n                wordLengthHashCostMap[length][wordHash] = costs[i];\n            }\n        }\n        \n        vector<long long> dp(n + 1, INT_MAX);\n        dp[0] = 0;\n        \n        for (int i = 0; i < n; ++i) {\n            if (dp[i] == INT_MAX) continue;\n            for (const auto& [length, hashCostMap] : wordLengthHashCostMap) {\n                if (i + length <= n) {\n                    long long currentHash = getHash(prefixHash, basePowers, i, i + length - 1);\n                    if (hashCostMap.find(currentHash) != hashCostMap.end()) {\n                        dp[i + length] = min(dp[i + length], dp[i] + hashCostMap.at(currentHash));\n                    }\n                }\n            }\n        }\n        \n        return dp[n] == INT_MAX ? -1 : dp[n];\n    }\n};\n",
    "submit_ts": "1720321130",
    "subm_id": "1312314338"
}