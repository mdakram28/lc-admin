{
    "username": "LayzerK",
    "submission": "class Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        #you want to find the maximal distance and remove one of those 2 points then find the maximal distance again\n        \n        \n        def compute(points):\n            cheby = [(p[0] + p[1], p[0]-p[1]) for p in points]\n\n            x_cheby = [(p[0], i) for i, p in enumerate(cheby)]\n            y_cheby = [(p[1], i) for i, p in enumerate(cheby)]\n\n            x_cheby.sort()\n            y_cheby.sort()\n\n\n            max_dist = -1\n            max_pair = (-1, -1)\n            for i, (x,y) in enumerate(cheby):\n                lo_x, lo_x_j = x_cheby[0]\n                hi_x, hi_x_j = x_cheby[-1]\n                \n                lo_y, lo_y_j = y_cheby[0]\n                hi_y, hi_y_j = y_cheby[-1]\n                \n                best = 0\n                best_j = -1\n                if abs(x-lo_x) > best:\n                    best_j = lo_x_j\n                    best = abs(x-lo_x)\n                if abs(x-hi_x) > best:\n                    best_j = hi_x_j\n                    best = abs(hi_x-x)\n                if abs(y-hi_y) > best:\n                    best_j = hi_y_j\n                    best = abs(hi_y-y)\n                if abs(y-lo_y) > best:\n                    best_j = lo_y_j\n                    best = abs(lo_y-y)\n                \n                \n                if best > max_dist:\n                    max_dist = best\n                    max_pair = (i, best_j)\n            return (max_dist, max_pair)\n        \n        \n        default_dist, (i, j) = compute(points)\n        \n        sans_i = []\n        sans_j = [] \n        for index, p in enumerate(points):\n            if index != i:\n                sans_i.append(p)\n            if index != j:\n                sans_j.append(p)\n                \n        ans = inf\n        new_best, (i2, j2) = compute(sans_i)\n        other_best, (other_i, other_j) = compute(sans_j)\n        print(new_best, other_best)\n        print(i,j)\n        return min(new_best, other_best)\n        \n        \n                    \n                    \n                    \n                \n                    "
}