{
    "username": "mananghetia",
    "submission": "/*Multi purpose Segment Tree Template*/\n/*range are half-open i.e [l,r)*/\n/*By default it will perform range increment update and calculate range sum*/\nstruct segNode\n{\n    int val;\n    int l, r;\n    segNode() // default value of Segment tree main node\n    {\n        val = 0;\n        l = -1, r = -1;\n    }\n};\nstruct lazyNode\n{\n    int val;\n    lazyNode() // default value of Segment tree lazy node\n    {\n        val = 0;\n    }\n};\nstruct segTree\n{\n    int N;\n    vector<segNode> seg;\n    vector<lazyNode> lazy;\n    segTree(int n) // Default Segment Tree\n    {\n        N = n;\n        seg.resize(4 * N + 5);\n        lazy.resize(4 * N + 5);\n        vector<int> a(N, seg[0].val); // check this\n        build(a, 0, N, 0);\n    }\n    segTree(vector<int> &a) // Pre-Computed Segment Tree\n    {\n        N = a.size();\n        seg.resize(4 * N + 5);\n        lazy.resize(4 * N + 5);\n        build(a, 0, N, 0);\n    }\n    void merge(segNode &cur, segNode &left, segNode &right) // change this function\n    {\n        assert(cur.l == left.l && cur.r == right.r);\n        \n        cur.val = max(left.val,right.val);\n    }\n    void propogate(int id) // change this function\n    {\n        int l = seg[id].l, r = seg[id].r;\n        seg[id].val += lazy[id].val;\n        if (l + 1 != r)\n        {\n            int mid = (l + r) >> 1LL, left = 2 * id + 1, right = 2 * id + 2;\n            lazy[left].val += lazy[id].val;\n            lazy[right].val += lazy[id].val;\n        }\n        lazy[id].val = 0;\n    }\n    void build(vector<int> &a, int l, int r, int id)\n    {\n        seg[id].l = l;\n        seg[id].r = r;\n        if (l + 1 == r) // check this block\n        {\n            seg[id].val = a[l];\n            return;\n        }\n        int mid = (l + r) >> 1LL, left = 2 * id + 1, right = 2 * id + 2;\n        build(a, l, mid, left);\n        build(a, mid, r, right);\n        merge(seg[id], seg[left], seg[right]);\n    }\n    void update(int ql, int qr, int val, int id = 0)\n    {\n        propogate(id);\n        int l = seg[id].l;\n        int r = seg[id].r;\n        if (ql >= r || l >= qr)\n            return;\n        if (ql <= l && r <= qr) // check this block\n        {\n            lazy[id].val = val;\n            propogate(id);\n            return;\n        }\n        int mid = (l + r) >> 1LL, left = 2 * id + 1, right = 2 * id + 2;\n        update(ql, qr, val, left);\n        update(ql, qr, val, right);\n        merge(seg[id], seg[left], seg[right]);\n    }\n    segNode query(int ql, int qr, int id = 0)\n    {\n        propogate(id);\n        segNode ans;\n        int l = seg[id].l;\n        int r = seg[id].r;\n        if (ql >= r)\n        {\n            ans.l = ans.r = ql;\n            return ans;\n        }\n        if (l >= qr)\n        {\n            ans.l = ans.r = qr;\n            return ans;\n        }\n        if (ql <= l && r <= qr)\n            return seg[id];\n        int mid = (l + r) >> 1LL, left = 2 * id + 1, right = 2 * id + 2;\n        segNode ansl = query(ql, qr, left);\n        segNode ansr = query(ql, qr, right);\n        ans.l = ansl.l;\n        ans.r = ansr.r;\n        merge(ans, ansl, ansr);\n        return ans;\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector<bool> ans;\n        set<int> s;\n        const int N = 5e4+5;\n        s.insert(0),s.insert(N);\n        vector<int> a(N);\n        for(int i=0;i<N;i++)\n            a[i]=i;\n        segTree st(a);\n        for(auto t:queries)\n        {\n            int x=t[1];\n            if(t[0]==1)\n            {\n                auto it=s.lower_bound(x);\n                int y=*it;\n                int v=st.query(x,x+1).val;\n                st.update(x+1,y+1,-v);\n                s.insert(x);\n                // for(int i=0;i<=11;i++)\n                //     cout<<st.query(i,i+1).val<<\" \";cout<<endl;\n            }\n            else \n            {\n                int mx=st.query(0,x+1).val;\n                if(mx>=t[2])\n                    ans.push_back(true);\n                else \n                    ans.push_back(false);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716650204.0
}