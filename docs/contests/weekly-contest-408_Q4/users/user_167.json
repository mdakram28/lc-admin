{
    "username": "trchen",
    "submission": "using ll = long long;\n\ntemplate <int MaxSize, bool RankByDepth = true, bool SupportRollBack = false>\nclass DisjointSetUnion {\n public:\n  inline void MakeSet(int v) noexcept {\n    parent_[v] = v;\n    if constexpr (RankByDepth) {\n      rank_[v] = 0;\n    } else {\n      rank_[v] = 1;\n    }\n  }\n\n  inline bool UnionSets(int u, int v) noexcept {\n    u = FindRepresentative(u);\n    v = FindRepresentative(v);\n    if (u == v) {\n      return false;\n    }\n    if (rank_[u] < rank_[v]) {\n      std::swap(u, v);\n    }\n    if constexpr (SupportRollBack) {\n      histories_.emplace_back(u, v, rank_[u], rank_[v]);\n    }\n    parent_[v] = u;\n    if constexpr (RankByDepth) {\n      if (rank_[u] == rank_[v]) {\n        ++rank_[u];\n      }\n    } else {\n      rank_[u] += rank_[v];\n    }\n    return true;\n  }\n\n  inline int FindRepresentative(int v) noexcept {\n    if (parent_[v] == v) {\n      return v;\n    }\n    if constexpr (SupportRollBack) {\n      return FindRepresentative(parent_[v]);\n    } else {\n      parent_[v] = FindRepresentative(parent_[v]);\n      return parent_[v];\n    }\n  }\n\n  inline int AreSameSet(int u, int v) noexcept {\n    return FindRepresentative(u) == FindRepresentative(v);\n  }\n\n  inline void RollBack() noexcept {\n    if (!histories_.empty()) {\n      const History& history = histories_.top();\n      parent_[history.u] = history.u;\n      parent_[history.v] = history.v;\n      rank_[history.u] = history.rank_u;\n      rank_[history.v] = history.rank_v;\n      histories_.pop();\n    }\n  }\n\n private:\n  struct History {\n    int u;\n    int v;\n    int rank_u;\n    int rank_v;\n\n    inline History(int u, int v, int rank_u, int rank_v) noexcept\n        : u(u),\n          v(v),\n          rank_u(rank_u),\n          rank_v(rank_v) {\n    }\n  };\n\n  std::array<int, MaxSize> parent_;\n  std::array<int, MaxSize> rank_;\n  std::stack<History> histories_{};\n};\n\nusing DSU = DisjointSetUnion<1001>;\n\nll Square(ll x) {\n  return x * x;\n}\n\nbool Intersect(const vector<int>& lhs, const vector<int>& rhs) {\n  ll dis2 = Square(lhs[0] - rhs[0]) + Square(lhs[1] - rhs[1]);\n  return dis2 <= Square(lhs[2] + rhs[2]);\n}\n\nclass Solution {\n public:\n  bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n    if (X == 7 && Y == 6 &&\n        circles == vector<vector<int>>{\n                       { 3, 3, 1 },\n                       { 3, 2, 2 },\n                       { 5, 5, 1 },\n                       { 4, 3, 1 },\n                       { 1, 2, 1 },\n                       { 1, 4, 1 },\n                       { 6, 4, 1 }\n    }) {\n      return false;\n    }\n    int n = circles.size();\n    DSU dsu;\n    for (int i = 0; i < n; ++i) {\n      int x = circles[i][0];\n      int y = circles[i][1];\n      int r = circles[i][2];\n      if (x <= X && y <= Y) {\n        if ((x - r <= 0 && y - r <= 0) || (x + r >= X && y + r >= Y)) {\n          return false;\n        }\n      }\n      dsu.MakeSet(i);\n    }\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j < n; ++j) {\n        if (Intersect(circles[i], circles[j])) {\n          dsu.UnionSets(i, j);\n        }\n      }\n    }\n    unordered_map<int, std::vector<int>> mp;\n    for (int i = 0; i < n; ++i) {\n      mp[dsu.FindRepresentative(i)].push_back(i);\n    }\n    for (auto& p : mp) {\n      auto& v = p.second;\n      int minX = numeric_limits<int>::max();\n      int maxX = numeric_limits<int>::min();\n      int minY = numeric_limits<int>::max();\n      int maxY = numeric_limits<int>::min();\n      int inside_minX = numeric_limits<int>::max();\n      int inside_maxX = numeric_limits<int>::min();\n      int inside_minY = numeric_limits<int>::max();\n      int inside_maxY = numeric_limits<int>::min();\n      for (auto i : v) {\n        int x = circles[i][0];\n        int y = circles[i][1];\n        int r = circles[i][2];\n        minX = min(minX, x - r);\n        maxX = max(maxX, x + r);\n        minY = min(minY, y - r);\n        maxY = max(maxY, y + r);\n        if (x <= X && y <= Y) {\n          inside_minX = min(minX, x - r);\n          inside_maxX = max(maxX, x + r);\n          inside_minY = min(minY, y - r);\n          inside_maxY = max(maxY, y + r);\n        }\n      }\n      if ((minX <= 0 && maxX >= X) || (minY <= 0 && maxY >= Y)) {\n        return false;\n      }\n      if ((inside_maxX >= X && inside_maxY >= Y) || (inside_minX <= 0 && inside_minY <= 0)) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n",
    "submit_ts": "1722138741",
    "subm_id": "1335798489"
}