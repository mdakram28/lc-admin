{
    "username": "sheepforever",
    "submission": "namespace {\n\nconst int maxn = 100007;\nconst int INF = 0x3F3F3F3F;\n\nstruct node\n{\n    int next[26];\n    int suf,count;\n    int cost, depth;\n    bool dan;\n} tree[maxn];\n    \nint last;\nint queue[maxn];\n    \ninline int tran(char s)\n{\n    return s - 'a';\n}\n\nvoid insert(const char *s,int len, int cost)\n{\n    int now = 1;\n    for (int i = 0;i < len;++i)\n        if (tree[now].next[tran(s[i])])\n            now = tree[now].next[tran(s[i])];\n        else\n        {\n            tree[now].next[tran(s[i])] = last;\n            now = last++;\n            memset(&tree[now],0,sizeof(node));\n            tree[now].cost = INF;\n            tree[now].depth = i + 1;\n        }\n    ++tree[now].count;\n    tree[now].dan = true;\n    tree[now].cost = min(tree[now].cost, cost);\n}\n\nvoid buildTrie()\n{\n    int front = 0,rear = 0;\n    queue[rear++] = 1;\n    while (front < rear)\n    {\n        int now = queue[front++];\n        tree[now].dan = tree[now].dan || tree[tree[now].suf].dan;\n        for (int i = 0;i < 26;++i)\n            if (tree[now].next[i])\n            {\n                queue[rear++] = tree[now].next[i];\n                tree[tree[now].next[i]].suf = tree[tree[now].suf].next[i];\n            }\n            else\n                tree[now].next[i] = tree[tree[now].suf].next[i];\n    }\n}\n    \n}  // namespace\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        memset(&tree[0],0,sizeof(node));\n        memset(&tree[1],0,sizeof(node));\n        for (int i = 0;i < 26;++i)\n            tree[0].next[i] = 1;\n        last = 2;\n        for (int i = 0; i < words.size(); ++i) {\n            insert(words[i].c_str(), words[i].size(), costs[i]);\n        }\n        buildTrie();\n        \n        vector<int> dp(target.size() + 1, INF);\n        dp[0] = 0;\n        int cur = 1;\n        for (int i = 0; i < target.size(); ++i) {\n            cur = tree[cur].next[target[i] - 'a'];\n            \n            int now = cur;\n            while (now != 1) {\n                dp[i + 1] = min(dp[i + 1], dp[i - tree[now].depth + 1] + tree[now].cost);\n                now = tree[now].suf;\n            }\n        }\n        return dp[target.size()] == INF ? -1 : dp[target.size()];\n    }\n};",
    "submit_ts": "1720320417",
    "subm_id": "1312293512"
}