{
    "username": "sunsq",
    "submission": "class Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        peak = [0] * n\n        for i, x in enumerate(nums):\n            if i > 0 and i < n - 1 and nums[i - 1] < x and x > nums[i + 1]:\n                peak[i] = 1\n        \n        tree = SegTree(peak)\n        res = []\n        \n        def update(idx: int) -> None:\n            if idx > 0 and idx < n - 1:\n                is_peak = 1 if nums[idx] > nums[idx - 1] and nums[idx] > nums[idx + 1] else 0\n                if is_peak != peak[idx]:\n                    peak[idx] = is_peak\n                    tree.update(1, 1, n, idx + 1, is_peak)  \n        \n        # print(nums, peak)\n        for q in queries:\n            if q[0] == 1:\n                res.append(tree.query(1, 1, n, q[1] + 2, q[2]))\n            else:\n                idx, val = q[1], q[2]\n                nums[idx] = val\n                update(idx - 1)\n                update(idx)\n                update(idx + 1)\n            # print(nums, peak)\n        return res\n\n    \nclass SegTree:\n    __slots__ = 'tree', 'nums'\n\n    def __init__(self, nums: List[int]):\n        n = len(nums)\n        self.tree = [0] * (n * 4)\n        self.nums = nums\n        self.build(1, 1, n)\n    \n    def build(self, o: int, l: int, r: int) -> None:\n        if l == r:\n            self.tree[o] = self.nums[l - 1]\n            return\n        m = (l + r) // 2\n        self.build(o * 2, l, m)\n        self.build(o * 2 + 1, m + 1, r)\n        self.tree[o] = self.tree[o * 2] + self.tree[o * 2 + 1]\n    \n    def update(self, o: int, l: int, r: int, idx: int, val: int) -> None:\n        if l == r:\n            self.tree[o] = val\n            return\n        m = (l + r) // 2\n        if idx <= m:\n            self.update(o * 2, l, m, idx, val)\n        else:\n            self.update(o * 2 + 1, m + 1, r, idx, val)\n        self.tree[o] = self.tree[o * 2] + self.tree[o * 2 + 1]\n    \n    def query(self, o: int, l: int, r: int, ql: int, qr: int) -> int:\n        if ql <= l and r <= qr:\n            return self.tree[o]\n        res = 0\n        m = (l + r) // 2\n        if ql <= m:\n            res += self.query(o * 2, l, m, ql, qr)\n        if qr > m:\n            res += self.query(o * 2 + 1, m + 1, r, ql, qr)\n        return res",
    "submit_ts": 1718508276.0
}