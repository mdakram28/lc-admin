{
    "username": "Ometek",
    "submission": "class Solution {\n    // my old implementation\n    class PointRangeTree {\n    private:\n      int SIZE;\n      int DEFAULT = 0; \n      vector<int> TREE;\n\n        int getN(int n) {\n        int i = 0;\n        while ((1 << i) < n)\n            i++;\n        return (1 << i);\n        }\n\n      int func(int a, int b) {\n        return max(a, b);\n      }\n\n    public:  \n      PointRangeTree(int n) {\n        this->SIZE = getN(n);\n        this->TREE.resize(2 * this->SIZE, this->DEFAULT);\n      }\n\n      void update(int pos, int val) {\n        pos += this->SIZE;\n        this->TREE[pos] = val;\n        pos /= 2;\n\n        while (pos != 0) {\n          this->TREE[pos] = this->func(this->TREE[2 * pos], this->TREE[2 * pos + 1]);\n            pos /= 2;\n        }\n      }\n\n      int query(int p, int k) {\n        int ans = this->DEFAULT;\n        p += this->SIZE;\n        k += this->SIZE;\n\n        while (p < k) {\n          //cerr << p << \" \" << k << \"\\n\";\n          if (p&1) {\n            ans = this->func(ans, this->TREE[p]);\n            p = (p>>1) + 1;\n          }\n          else {\n            p >>= 1;\n          }\n\n          if (k&1) { \n            k >>= 1;\n          }\n          else {\n            ans = this->func(ans, this->TREE[k]);\n            k = (k>>1) - 1;\n          }\n        }\n         \n\n        if (p == k)\n            ans = this->func(ans, this->TREE[p]);\n\n        return ans;\n      }\n        \n    int get(int x) {\n            return this->TREE[x + this->SIZE];\n        }\n\n        void print() {\n            cout << \"===== ===== =====\\n\";\n            for (int i = 0; i < SIZE; i++) \n                cout << this->TREE[i] << \" \";\n            cout << \"\\n\";\n            for (int i = 0; i < SIZE; i++) \n                cout << this->TREE[i + SIZE] << \" \";\n            cout << \"\\n===== ===== =====\\n\";\n        }\n\n    };\n    \n    \n    \npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        PointRangeTree tree = PointRangeTree(50005);\n        vector<bool> ans;\n        set<int> obstacles;\n        obstacles.insert(0);\n        obstacles.insert(-1);\n        tree.update(0, 50005);\n        \n        for (auto q : queries) {\n            if (q[0] == 1) {\n                auto prev = obstacles.lower_bound(q[1]);\n                --prev;\n                \n                int dist = tree.get(*prev);\n                tree.update(*prev, q[1] - *prev);\n                tree.update(q[1], dist + *prev - q[1]);        \n                obstacles.insert(q[1]);\n            }\n            else {\n                //tree.print();\n                \n                auto prev = obstacles.lower_bound(q[1]);\n                prev--;\n                //cout << q[1] << \" \" << *prev << \"\\n\";\n                \n                int quer = tree.query(0, *prev - 1);\n                int rest = (q[1] - *prev);\n                    \n                ans.push_back((quer >= q[2]) || (rest >= q[2]));\n            }\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": 1716652441.0
}