{
    "username": "LayCurse",
    "submission": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"inline\")\n#include<bits/stdc++.h>\nusing namespace std;\nvoid*wmem;\nchar memarr[96000000];\ntemplate<class S, class T> inline S chmax(S &a, T b){\n  if(a<b){\n    a=b;\n  }\n  return a;\n}\ntemplate<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){\n  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\n  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );\n  (*arr)=(T*)(*mem);\n  (*mem)=((*arr)+x);\n}\ntemplate<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){\n  walloc1d(arr, x2-x1, mem);\n  (*arr) -= x1;\n}\nstruct graph{\n  int N;\n  int*es;\n  int**edge;\n  void setEdge(int N__, int M, int A[], int B[], void **mem = &wmem){\n    int i;\n    N = N__;\n    walloc1d(&es, N, mem);\n    walloc1d(&edge, N, mem);\n    for(i=(0);i<(N);i++){\n      es[i] = 0;\n    }\n    for(i=(0);i<(M);i++){\n      es[A[i]]++;\n      es[B[i]]++;\n    }\n    for(i=(0);i<(N);i++){\n      walloc1d(&edge[i], es[i], mem);\n    }\n    for(i=(0);i<(N);i++){\n      es[i] = 0;\n    }\n    for(i=(0);i<(M);i++){\n      edge[A[i]][es[A[i]]++] = B[i];\n      edge[B[i]][es[B[i]]++] = A[i];\n    }\n  }\n  void getDist(int root, int res[], void *mem = wmem){\n    int i;\n    int j;\n    int k;\n    int*q;\n    int s;\n    int z;\n    walloc1d(&q, N, &mem);\n    for(i=(0);i<(N);i++){\n      res[i]=-1;\n    }\n    res[root]=0;\n    s=0;\n    z=1;\n    q[0]=root;\n    while(z){\n      i=q[s++];\n      z--;\n      for(j=(0);j<(es[i]);j++){\n        k=edge[i][j];\n        if(res[k]>=0){\n          continue;\n        }\n        res[k]=res[i]+1;\n        q[s+z++]=k;\n      }\n    }\n  }\n  int getDist(int a, int b, void *mem = wmem){\n    int i;\n    int j;\n    int k;\n    int*q;\n    int s;\n    int z;\n    int*d;\n    if(a==b){\n      return 0;\n    }\n    walloc1d(&d, N, &mem);\n    walloc1d(&q, N, &mem);\n    for(i=(0);i<(N);i++){\n      d[i] = -1;\n    }\n    d[a] = 0;\n    s = 0;\n    z = 1;\n    q[0] = a;\n    while(z){\n      i = q[s++];\n      z--;\n      for(j=(0);j<(es[i]);j++){\n        k = edge[i][j];\n        if(d[k] >= 0){\n          continue;\n        }\n        d[k] = d[i] + 1;\n        if(k==b){\n          return d[k];\n        }\n        q[s+z++] = k;\n      }\n    }\n    return -1;\n  }\n  int TreeDiameter(int &a, int &b, void *mem = wmem){\n    int i;\n    int mx;\n    int*d;\n    walloc1d(&d, N, &mem);\n    getDist(0, d, mem);\n    mx = -1;\n    for(i=(0);i<(N);i++){\n      if(mx < d[i]){\n        mx = d[i];\n        a = i;\n      }\n    }\n    getDist(a, d, mem);\n    mx = -1;\n    for(i=(0);i<(N);i++){\n      if(mx < d[i]){\n        mx = d[i];\n        b = i;\n      }\n    }\n    return mx;\n  }\n  int TreeDiameter(void *mem = wmem){\n    int a;\n    int b;\n    return TreeDiameter(a, b, mem);\n  }\n}\n;\ntemplate<class T, class S> inline int vec2arr(vector<T> &v, S arr[]){\n  int i;\n  int N = v.size();\n  for(i=(0);i<(N);i++){\n    arr[i] = v[i];\n  }\n  return N;\n}\ntemplate<class T, class S1, class S2> inline int vec2arr(vector<vector<T>> &v, S1 arr1[], S2 arr2[]){\n  int i;\n  int N = v.size();\n  for(i=(0);i<(N);i++){\n    arr1[i] = v[i][0];\n    arr2[i] = v[i][1];\n  }\n  return N;\n}\ntemplate<class T, class S1, class S2, class S3> inline int vec2arr(vector<vector<T>> &v, S1 arr1[], S2 arr2[], S3 arr3[]){\n  int i;\n  int N = v.size();\n  for(i=(0);i<(N);i++){\n    arr1[i] = v[i][0];\n    arr2[i] = v[i][1];\n    arr3[i] = v[i][2];\n  }\n  return N;\n}\n#define main dummy_main\nint main(){\n  wmem = memarr;\n  return 0;\n}\n#undef main\nclass Solution{\n  public:\n  int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2){\n    dummy_main();\n    graph g1;\n    graph g2;\n    int res;\n    int d1;\n    int d2;\n    static int n;\n    static int m;\n    static int a[1000000];\n    static int b[1000000];\n    m = vec2arr(edges1, a, b);\n    n = m+1;\n    g1.setEdge(n,m,a,b);\n    m = vec2arr(edges2, a, b);\n    n = m+1;\n    g2.setEdge(n,m,a,b);\n    d1 = g1.TreeDiameter();\n    d2 = g2.TreeDiameter();\n    res = (d1+1)/2 + (d2+1)/2 + 1;\n    chmax(res, d1);\n    chmax(res, d2);\n    return res;\n  }\n}\n;\n// cLay version 20240420-1\n\n// --- original code ---\n// #define main dummy_main\n// {}\n// #undef main\n// \n// class Solution {\n// public:\n//   int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n//     dummy_main();\n//     graph g1, g2;\n//     int res, d1, d2;\n//     static int n, m, a[1d6], b[1d6];\n// \n//     m = vec2arr(edges1, a, b);\n//     n = m+1;\n//     g1.setEdge(n,m,a,b);\n// \n//     m = vec2arr(edges2, a, b);\n//     n = m+1;\n//     g2.setEdge(n,m,a,b);\n// \n//     d1 = g1.TreeDiameter();\n//     d2 = g2.TreeDiameter();\n//     res = (d1+1)/2 + (d2+1)/2 + 1;\n//     res >?= d1;\n//     res >?= d2;\n//     return res;\n//   }\n// };\n",
    "submit_ts": "1719715976",
    "subm_id": "1304351563"
}