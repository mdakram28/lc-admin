{
    "username": "Grind_Like_GM",
    "submission": "from typing import List\nfrom collections import deque\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def find_diameter(edges: List[List[int]], n: int) -> int:\n            def bfs(start: int) -> (int, int):\n                dist = [-1] * n\n                dist[start] = 0\n                queue = deque([start])\n                farthest_node = start\n                max_dist = 0\n                while queue:\n                    node = queue.popleft()\n                    for neighbor in graph[node]:\n                        if dist[neighbor] == -1:\n                            dist[neighbor] = dist[node] + 1\n                            queue.append(neighbor)\n                            if dist[neighbor] > max_dist:\n                                max_dist = dist[neighbor]\n                                farthest_node = neighbor\n                return farthest_node, max_dist\n            \n            graph = [[] for _ in range(n)]\n            for u, v in edges:\n                graph[u].append(v)\n                graph[v].append(u)\n            \n            farthest_node, _ = bfs(0)\n            _, diameter = bfs(farthest_node)\n            return diameter\n        \n        n = len(edges1) + 1\n        m = len(edges2) + 1\n        \n        diameter1 = find_diameter(edges1, n)\n        diameter2 = find_diameter(edges2, m)\n\n        def radius(diameter: int) -> int:\n            return (diameter + 1) // 2\n        \n        radius1 = radius(diameter1)\n        radius2 = radius(diameter2)\n        \n        new_diameter = max(diameter1, diameter2, radius1 + radius2 + 1)\n        \n        return new_diameter\n\n",
    "submit_ts": "1719718208",
    "subm_id": "1304411443"
}