{
    "username": "dhruvsharma190801",
    "submission": "class Solution {\npublic:\n    int bfs(vector<vector<int>> &adjacency_list, int start_node, int first_target, int second_target, int total_nodes) {\n    queue<int> nodes_queue;\n    vector<int> visited(total_nodes + 4, 0);\n    nodes_queue.push(start_node);\n    visited[start_node] = 1;\n\n    while (!nodes_queue.empty()) {\n        int current_node = nodes_queue.front();\n        nodes_queue.pop();\n        for (int neighbor : adjacency_list[current_node]) {\n            if (!visited[neighbor]) {\n                nodes_queue.push(neighbor);\n                visited[neighbor] = 1;\n            }\n        }\n    }\n    return visited[first_target] || visited[second_target];\n}\n\n\n    bool canReachCorner(int X, int Y, vector<vector<int>>& obstacle_positions) {\n        vector<pair<pair<int, int>, int>> circles(obstacle_positions.size());\nvector<vector<int>> adjacency_list(obstacle_positions.size() + 4);\nint num_obstacles = obstacle_positions.size();\n\nfor (int i = 0; i < num_obstacles; ++i) {\n    circles[i].first.first = obstacle_positions[i][0]; // x-coordinate\n    circles[i].first.second = obstacle_positions[i][1]; // y-coordinate\n    circles[i].second = obstacle_positions[i][2]; // radius\n}\n\nfor (int i = 0; i < num_obstacles; ++i) {\n    if (circles[i].first.first <= circles[i].second) {\n        adjacency_list[num_obstacles].push_back(i);\n        adjacency_list[i].push_back(num_obstacles);\n    }\n    if (X - circles[i].first.first <= circles[i].second) {\n        adjacency_list[num_obstacles + 2].push_back(i);\n        adjacency_list[i].push_back(num_obstacles + 2);\n    }\n    if (circles[i].first.second <= circles[i].second) {\n        adjacency_list[num_obstacles + 1].push_back(i);\n        adjacency_list[i].push_back(num_obstacles + 1);\n    }\n    if (Y - circles[i].first.second <= circles[i].second) {\n        adjacency_list[num_obstacles + 3].push_back(i);\n        adjacency_list[i].push_back(num_obstacles + 3);\n    }\n    for (int j = i + 1; j < num_obstacles; ++j) {\n        double distance = sqrt(pow(circles[i].first.first - circles[j].first.first, 2) +\n                               pow(circles[i].first.second - circles[j].first.second, 2));\n        int combined_radius = circles[i].second + circles[j].second;\n        if (combined_radius >= distance) {\n            adjacency_list[i].push_back(j);\n            adjacency_list[j].push_back(i);\n        }\n    }\n}\n\nint path_blocked = 0;\npath_blocked = max(path_blocked, bfs(adjacency_list, num_obstacles, num_obstacles + 1, num_obstacles + 2, num_obstacles + 4)); // Check for bottom-left corner\npath_blocked = max(path_blocked, bfs(adjacency_list, num_obstacles + 3, num_obstacles + 2, num_obstacles + 1, num_obstacles + 4)); // Check for top-right corner\nif (path_blocked) {\n    return false;\n}\nreturn true;\n\n    }\n};\n",
    "submit_ts": "1722137010",
    "subm_id": "1335751518"
}