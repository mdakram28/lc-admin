{
    "username": "dingmingcheng1",
    "submission": "class Solution {\n     static class Graph {\n\n        private int MAXN = 0x3f3f3f3f;\n        public Edge[] edges;\n        public int cnt;\n        public int[] fir;\n        public long[] dis;\n        public boolean[] vis;\n        public int ans;\n\n        static class Edge {\n\n            int u, v, w, next;\n            boolean cut;\n            int used;\n            int num;\n        }\n\n        public void graphInit(int nodeSize, int edgeSize) {\n            //\u5206\u914d\u5185\u5b58\uff0cedges\uff0cfir\uff0cdis\n            cnt = 0;\n            edges = new Edge[edgeSize + 10];\n            fir = new int[nodeSize + 10];\n            dis = new long[nodeSize + 10];\n            vis = new boolean[nodeSize + 10];\n            Arrays.fill(fir, -1);\n        }\n\n        //\u6784\u5efa\u90bb\u63a5\u8868\uff0cu\u4ee3\u8868\u8d77\u70b9\uff0cv\u4ee3\u8868\u7ec8\u70b9\uff0cw\u4ee3\u8868\u4e4b\u95f4\u8def\u5f84\n        void addEdge(int u, int v, int w) {\n            edges[cnt] = new Edge();\n            edges[cnt].u = u;\n            edges[cnt].v = v;\n            edges[cnt].w = w;\n            edges[cnt].next = fir[u];\n            edges[cnt].used = 0;\n            fir[u] = cnt++;\n        }\n\n        public void prim(int n, int start, int dest) {\n            for (int i = 2; i <= n; ++i)\n                dis[i] = MAXN;\n\n            for (int i = fir[start]; i != -1; i = edges[i].next) {\n                int v = edges[i].v;\n                dis[v] = Math.min(dis[edges[i].v], edges[i].w);\n            }\n\n            int now = start;\n            while (true) {\n                long minn = MAXN;\n                vis[now] = true;\n                for (int i = 1; i <= n; ++i) {\n                    if (vis[i]) continue;\n                    if (minn > dis[i]) {\n                        minn = dis[i];\n                        now = i;\n                    }\n                }\n                ans += minn;\n                if (minn == MAXN) break;\n\n                for (int i = fir[now]; i != -1; i = edges[i].next) {\n                    int v = edges[i].v;\n                    if (vis[v]) continue;\n                    if (dis[v] > edges[i].w) {\n                        dis[v] = edges[i].w;\n                    }\n                    dis[v] = Math.min(dis[edges[i].v], edges[i].w);\n                }\n                if (vis[dest]) break;\n            }\n        }\n\n        // \u6700\u77ed\u8def\u5f84\n        //\u8ddd\u79bb\u67d0\u70b9\u7684\u8ddd\u79bb\uff0cv\u4e3a\u70b9\uff0cw\u4e3a\u8ddd\u79bb\n        static class Node implements Comparable<Node> {\n\n            int v;\n            long w;\n            int x, y, z;\n\n            public Node(int v, long w, int x) {\n                this.v = v;\n                this.w = w;\n                this.x = x;\n            }\n\n\n            @Override\n            public int compareTo(Node o) {\n                if (this.w > o.w) return 1;\n                return -1;\n            }\n        }\n\n        public void dijkstra(int s, int[] dis) {\n            PriorityQueue<Node> pque = new PriorityQueue<>();\n            dis[s] = 0;\n            pque.add(new Node(s, 0, 0));\n            while (!pque.isEmpty()) {\n                Node cur = pque.poll();\n                for (int i = fir[cur.v]; i != -1; i = edges[i].next) {\n                    int v = edges[i].v;\n                    if (dis[cur.v] + edges[i].w < dis[v]) {\n\n                        dis[v] = dis[cur.v] + edges[i].w;\n\n                        pque.add(new Node(v, dis[v], cur.x + 1));\n                        edges[i].used++;\n                    }\n                }\n            }\n        }\n\n\n        //    \u4e8c\u5206\u56fe\u67d3\u8272\n        //\u6539\u70b9\u662f\u5426\u88ab\u8bbf\u95ee\u8fc7\n        int[] vise;\n        //\u88ab\u67d3\u8272\u4e3a0\u7684\u6570\u91cf\n        int cnt0;\n        //\u88ab\u67d3\u4e3a1\u7684\u6570\u91cf\n        int cnt1;\n\n        public void initEft(int nodeSize, int edgeSize) {\n            vise = new int[nodeSize + 10];\n            graphInit(nodeSize, edgeSize);\n        }\n\n        public boolean dfs(int fa, int now, int cnt) {\n            vise[now] = cnt % 2;\n            if (cnt % 2 == 1) cnt0++;\n            else cnt1++;\n            for (int i = fir[now]; i != -1; i = edges[i].next) {\n                int v = edges[i].v;\n                if (v != fa) {\n                    if (vise[v] == -1) {\n                        boolean r = dfs(now, v, cnt + 1);\n                        if (!r) return false;\n                    } else if (vise[v] != (cnt + 1) % 2) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        long inf = Long.MAX_VALUE / 2;\n        int maxn = 100;\n        long[][] map;\n        int nx, ny;\n        int[] link;\n        boolean[] visx, visy;\n        long[] lx, ly;\n        long[] slack;\n\n        public void kmInit(int nx1, int ny1) {\n            maxn = nx1 + ny1;\n            map = new long[nx1][ny1];\n            link = new int[maxn];\n            visx = new boolean[maxn];\n            visy = new boolean[maxn];\n            lx = new long[maxn];\n            ly = new long[maxn];\n            slack = new long[maxn];\n            nx = nx1;\n            ny = ny1;\n        }\n\n        public long KM() {\n            Arrays.fill(link, -1);\n            // lx \u548c ly\u7684\u521d\u59cb\u5316\n            Arrays.fill(ly, 0);\n            for (int i = 0; i < nx; i++) {\n                lx[i] = -inf;\n                for (int j = 0; j < ny; j++) {\n                    lx[i] = Math.max(lx[i], map[i][j]);\n                }\n            }\n\n            // \u4ecex\u96c6\u5408\u7684\u6bcf\u4e2a\u70b9\u5bfb\u627e\u589e\u5e7f\u8def\n            for (int x = 0; x < nx; x++) {\n                for (int i = 0; i < ny; i++) //slack \u7684\u521d\u59cb\u5316\u5bf9\u5f53\u524d\u70b9\u5bfb\u627e\u589e\u5e7f\u8def\u7684\u5de6\u53f3\u8fc7\u7a0b\u4e2d\u6709\u6548\n                {\n                    slack[i] = inf;\n                }\n                while (true) {\n                    Arrays.fill(visx, false);\n                    Arrays.fill(visy, false);\n                    if (dfs(x)) break; //\u8be5\u70b9\u589e\u5e7f\u5b8c\u6210\n                    // \u5426\u5219\u4fee\u6539\u53ef\u884c\u9876\u6807\n                    long d = inf;\n                    for (int i = 0; i < ny; i++) {\n                        if (!visy[i])\n                            d = Math.min(d, slack[i]);\n                    }\n\n                    for (int i = 0; i < nx; i++) {\n                        if (visx[i])\n                            lx[i] -= d;\n                    }\n                    for (int i = 0; i < ny; i++) {\n                        if (visy[i])\n                            ly[i] += d;\n                        else\n                            slack[i] -= d;\n                    }\n                }\n            }\n\n            long res = 0;\n            for (int i = 0; i < ny; i++) { //\u5fc5\u5b9a\u5df2\u7ecf\u627e\u5230\u4e00\u4e2a\u6240\u6709\u76f8\u7b49\u5b50\u56fe\u7684\u70b9\u5bfc\u51fa\u7684\u5b8c\u7f8e\u5339\u914d\n                if (link[i] != -1)\n                    res += map[link[i]][i]; // \u53f3\u96c6\u5408i\u7684\u5339\u914d\u70b9link[i] \u8fd9\u91cc\u4e0d\u50cf\u65e0\u5411\u56fe\u90a3\u6837\uff0c\u9700\u8981\u6ce8\u610f\u987a\u5e8f---------\n            }\n            return res;\n        }\n\n        public boolean dfs(int x) {\n            visx[x] = true;\n            for (int i = 0; i < ny; i++) {\n                if (visy[i]) continue;\n                long w = lx[x] + ly[i] - map[x][i];\n                if (w == 0) {\n                    visy[i] = true;\n                    if (link[i] == -1 || dfs(link[i])) {\n                        link[i] = x;\n                        return true;\n                    }\n                } else slack[i] = Math.min(slack[i], w);\n            }\n            return false;\n        }\n    }\n\n    int max;\n    int value;\n    public void dfs(int u, int sum, int last, Graph g) {\n        if (sum > max) {\n            max = sum;\n            value = u;\n        }\n        for (int i = g.fir[u]; i != -1; i = g.edges[i].next) {\n            int v = g.edges[i].v;\n            if (v == last) continue;\n            dfs(v, sum + 1, u, g);\n        }\n    }\n    public int process(int[][] es) {\n        Graph g = new Graph();\n        int n = es.length + 1;\n        g.graphInit(n, (n + 1)*2);\n        for (int[] e : es) {\n            g.addEdge(e[0], e[1], 1);\n            g.addEdge(e[1], e[0], 1);\n        }\n        max = 0;\n        dfs(0, 0, -1, g);\n        max = 0;\n        dfs(value, 0, -1, g);\n        return max;\n    }\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        Graph g = new Graph();\n        int x1 = process(edges1);\n        int x2 = process(edges2);\n        int prox1 = (int) Math.ceil(x1 * 1.0 / 2);\n        int prox2 = (int) Math.ceil(x2 * 1.0 / 2);\n        return Math.max(Math.max(x1, x2), prox1 + prox2 + 1);\n    }\n}",
    "submit_ts": "1719718375",
    "subm_id": "1304415656"
}