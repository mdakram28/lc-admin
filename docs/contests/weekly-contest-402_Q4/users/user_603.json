{
    "username": "yuwen-yan",
    "submission": "class SegmentTree:\n    def __init__(self, nums):\n        self.nums = nums\n        self.size = len(nums)\n        self.array = [None] * 4 * self.size\n        \n        self.build(1, 0, self.size)\n        \n    def build(self, node, left, right):\n        #print(node, left, right)\n        if left + 1 == right:\n            if left > 0 and self.nums[left] > self.nums[left - 1] and left < (self.size - 1) and self.nums[left] > self.nums[left + 1]:\n                self.array[node] = 1\n            else:\n                self.array[node] = 0\n            return\n        \n        mid = (left + right) // 2\n        self.build(node * 2, left, mid)\n        self.build(node * 2 + 1, mid, right)\n        self.array[node] = self.array[node * 2] + self.array[node * 2 + 1]\n    \n    def query(self, left, right):\n        return self.query_node(1, 0, self.size, left, right)\n    \n    def query_node(self, node, node_left, node_right, query_left, query_right):\n        #print(node, node_left, node_right, query_left, query_right)\n        if query_left <= node_left and query_right >= node_right:\n            #print(node, node_left, node_right, query_left, query_right, self.array[node])\n            return self.array[node]\n        elif query_left >= node_right or query_right <= node_left:\n            return 0\n        else:\n            mid = (node_left + node_right) // 2\n            ans = self.query_node(node * 2, node_left, mid, query_left, query_right) + self.query_node(node * 2 + 1, mid, node_right, query_left, query_right)\n            #print(node, node_left, node_right, query_left, query_right, ans)\n            return ans\n    \n    def update(self, index, value):\n        if self.nums[index] == value:\n            return\n        self.nums[index] = value\n        self.update_node(1, 0, self.size, index, value)\n        \n    def update_node(self, node, node_left, node_right, index, value):\n        \n        #print(self.nums, node, node_left, node_right, index, value)\n        if (node_left > index + 1) or (node_right < index):\n            return\n        \n        if node_left + 1 == node_right:\n            if node_left > 0 and self.nums[node_left] > self.nums[node_left - 1] and node_left < (self.size - 1) and self.nums[node_left] > self.nums[node_left + 1]:\n                self.array[node] = 1\n            else:\n                self.array[node] = 0\n            return\n        mid = (node_left + node_right) // 2\n        self.update_node(node * 2, node_left, mid, index, value)\n        self.update_node(node * 2 + 1, mid, node_right, index, value)\n        self.array[node] = self.array[node * 2] + self.array[node * 2 + 1]\n        #print(self.nums, node, node_left, node_right, index, value, self.array)\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        segment_tree = SegmentTree(nums)\n        \n        #print(segment_tree.array)\n        \n        def is_peak(index):\n            return index >0 and segment_tree.nums[index] > segment_tree.nums[index - 1] and index < (segment_tree.size - 1) and segment_tree.nums[index] > segment_tree.nums[index + 1]\n        \n        ans = []\n        for query in queries:\n            if query[0] == 1:\n                curr_ans = segment_tree.query(query[1], query[2] + 1)\n                if is_peak(query[1]):\n                    curr_ans -= 1\n                if query[2] != query[1] and is_peak(query[2]):\n                    curr_ans -= 1\n                ans.append(curr_ans)\n            else:\n                segment_tree.update(query[1], query[2])\n        return ans\n        \n        ",
    "submit_ts": 1718508032.0
}