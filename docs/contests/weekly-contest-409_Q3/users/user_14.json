{
    "username": "gongshuisanye2",
    "submission": "class BIT:\n    def __init__(self, v):\n        self.n = len(v)\n        self.tree = [0] * (self.n + 1)\n\n    def lowbit(self, x):\n        return (-x) & x\n\n    def add(self, l, r, num):\n        l += 1\n        r += 1\n        i = l\n        while i <= self.n:\n            self.tree[i] += num\n            i += self.lowbit(i)\n        i = r + 1\n        while i <= self.n:\n            self.tree[i] -= num\n            i += self.lowbit(i)\n\n    def query(self, s):\n        s += 1\n        ans = 0\n        i = s\n        while i >= 1:\n            ans += self.tree[i]\n            i -= self.lowbit(i)\n        return ans\n\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        q = len(queries)\n        ans = [0] * q\n        bit1 = BIT([0] * n)\n        bit2 = BIT([0] * n)\n        for i in range(n):\n            bit1.add(i, i, n - 1 - i)\n        f = [i + 1 for i in range(n)]\n        for i in range(q):\n            l, r = queries[i]\n            if bit2.query(l) == 0 and f[l] < r:\n                d = bit1.query(l) - (1 + bit1.query(r))\n                bit1.add(0, l, -d)\n                f[l] = r\n            if l + 1 <= r - 1:\n                bit2.add(l + 1, r - 1, 1)\n            ans[i] = bit1.query(0)\n        return ans",
    "submit_ts": "1722741102",
    "subm_id": "552336038"
}