{
    "username": "jayjariwala10125",
    "submission": "class Solution {\npublic:\nstruct seg{\n    vector<int>tree;\n\n    vector<int>lazy;\n    seg(int n){\n        vector<int>t(n*4);\n        vector<int>l(n*4);\n        tree=t;\n        lazy=l;\n    }\n    void propogate(int node,int start,int end){\n        if(lazy[node]==0){\n            return;\n        }\n        if(start==end){\n            tree[node] = !tree[node];\n        }\n        else{\n                int x = tree[node];\n                tree[node] =((end-start+1) - x);\n                lazy[node*2] = !lazy[node*2];\n                lazy[node*2+1] = !lazy[node*2+1];\n        }\n        lazy[node] = 0;\n    }\n    void update(int node,int start,int end,int l,int r){\n        propogate(node,start,end);\n        if(start>r || end<l){\n            return;\n        }\n        if(start==end){\n            lazy[node] = !lazy[node];\n            propogate(node,start,end);\n        }\n        else if(start>=l && end<=r){\n            lazy[node] = !lazy[node];\n            propogate(node,start,end);\n        }\n        else{\n            int mid = (end+start)/2;\n            update(2*node,start,mid,l,r);\n            update(2*node+1,mid+1,end,l,r);\n            tree[node] = tree[node*2] + tree[node*2+1]; \n        }\n    }\n\n    int query(int node,int start,int end,int l,int r){\n        propogate(node,start,end);\n        if(start>r || end<l){\n            return 0;\n        }\n        if(start==end){\n            return tree[node];\n        }\n        else if(start>=l && end<=r){\n            return tree[node];\n        }\n        else{\n            int mid = (end+start)/2;\n            int x = query(node*2,start,mid,l,r);\n            int y = query(node*2+1,mid+1,end,l,r);\n            return x+y;\n        }\n\n    }\n//\n};\n    vector<int> countOfPeaks(vector<int>& v, vector<vector<int>>& q) {\n        int n=v.size();\n        vector<int>vi(n);\n        seg se = seg(n);\n        for(int i=1;i<n-1;i++){\n            if((v[i]>v[i-1]) && (v[i]>v[i+1])){\n                se.update(1,0,n-1,i,i);\n                // cout<<i<<\" \"<<\" \";\n                vi[i]=1;\n            }\n        }\n        vector<int>ans;\n\n        for(auto &i:q){\n            if(i[0]==1){\n                if((i[2]-i[1])>=2)\n                ans.push_back(se.query(1,0,n-1,i[1]+1,i[2]-1));\n                else{\n                    ans.push_back(0);\n                }\n            }\n            else{\n                v[i[1]]=i[2];\n                int idx=i[1];\n                int leftidx = i[1]-1;\n                int rightidx = i[1]+1;\n                int left=0;\n                int curr=0;\n                int right=0;\n                if((leftidx-1)>=0 && ((leftidx+1)<n) &&(v[leftidx]>v[leftidx-1])&&(v[leftidx]>v[leftidx+1])){\n                    left=1;\n                }\n                if((idx-1)>=0 && ((idx+1)<n) &&(v[idx]>v[idx-1])&&(v[idx]>v[idx+1])){\n                    curr=1;\n                }\n                if((rightidx-1)>=0 && ((rightidx+1)<n) &&(v[rightidx]>v[rightidx-1])&&(v[rightidx]>v[rightidx+1])){\n                    right=1;\n                }\n                if((leftidx!=-1) && (vi[leftidx]^left)){\n                    se.update(1,0,n-1,leftidx,leftidx);\n                    vi[leftidx]=!vi[leftidx];\n                }\n                if((rightidx!=n) && (vi[rightidx]^right)){\n                    se.update(1,0,n-1,rightidx,rightidx);\n                    vi[rightidx]=!vi[rightidx];\n                }\n                if(vi[idx]^curr){\n                    se.update(1,0,n-1,idx,idx);\n                    vi[idx]=!vi[idx];\n                }\n                // for(auto &i:vi){\n                //     cout<<i<<\" \";\n                // }\n                // cout<<endl;\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718508062.0
}