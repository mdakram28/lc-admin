{
    "username": "vijaykatari23",
    "submission": "class Solution {\npublic:\n    // Function to perform BFS and return the farthest node and its distance\n    pair<int, int> bfs(const vector<vector<int>>& adj, int start) {\n        int n = adj.size();\n        vector<int> distance(n, -1);\n        queue<int> q;\n\n        q.push(start);\n        distance[start] = 0;\n\n        int farthest_node = start;\n        int max_distance = 0;\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n\n            for (int neighbor : adj[node]) {\n                if (distance[neighbor] == -1) {\n                    distance[neighbor] = distance[node] + 1;\n                    q.push(neighbor);\n\n                    if (distance[neighbor] > max_distance) {\n                        max_distance = distance[neighbor];\n                        farthest_node = neighbor;\n                    }\n                }\n            }\n        }\n\n        return {farthest_node, max_distance};\n    }\n\n    // Function to calculate the diameter of a tree given its adjacency list\n    int treeDiameter(const vector<vector<int>>& adj) {\n        // Step 1: Perform BFS from an arbitrary node (say node 0) to find the farthest node\n        auto [farthest_node, _] = bfs(adj, 0);\n\n        // Step 2: Perform BFS from the farthest node found in step 1 to find the farthest node from it\n        auto [other_farthest_node, diameter] = bfs(adj, farthest_node);\n\n        // The distance to the farthest node from the farthest node found is the diameter of the tree\n        return diameter;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& a, vector<vector<int>>& b) {\n        int N = a.size() + 1;\n        int M = b.size() + 1;\n        vector<vector<int>> adj(N);\n        for(auto &x : a) {\n            int u = x[0], v = x[1];\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        vector<vector<int>> adj1(M);\n        for(auto &x : b) {\n            int u = x[0], v = x[1];\n            adj1[u].push_back(v);\n            adj1[v].push_back(u);\n        }\n        int x = 0, y = 0;\n        if(N > 1)\n            x = treeDiameter(adj);\n        if(M > 1)\n            y = treeDiameter(adj1);\n        int ans = max(x, y);\n        // cout << x << ' ' << y << '\\n';\n        x = (x + 1) / 2; y = (y + 1) / 2;\n        // cout << x << ' ' << y << '\\n';\n        return max(ans, x + y + 1);\n    }\n};",
    "submit_ts": "1719717252",
    "subm_id": "1304386586"
}