{
    "username": "CreedBratton",
    "submission": "class Solution {\nprivate:\n    static constexpr int LOG = 31;\n    vector<vector<int>> pre;\n    int query(int l, int r) {\n        int andResult = 0;\n        for (int bitpos = 0; bitpos < LOG; ++bitpos) {\n            if (pre[r + 1][bitpos] - pre[l][bitpos] == r + 1 - l) {\n                andResult |= (1 << bitpos);\n            }\n        }\n        return andResult;\n    }\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        int n = int(nums.size());\n        int answer = abs(nums[0] - k);\n\n        // AND[l,r] = i-th bit will be 1 iff all i-th bit of nums[l..r] are 1\n        pre = vector<vector<int>> (n + 1, vector<int> (LOG, 0));\n        for (int r = 0; r < n; ++r) {\n            pre[r + 1] = pre[r];\n            for (int bitpos = 0; bitpos < LOG; ++bitpos) {\n                if (nums[r] & (1 << bitpos)) {\n                    ++pre[r + 1][bitpos];\n                }\n            }\n        }\n\n        for (int l = 0; l < n; ++l) {\n            // from l, the bitwise AND can only go down in value\n            // if nums[l] > k: binary search r\n            // if nums[l] == k -> answer = 0\n            // if nums[l] < k: answer = min(answer, k - nums[l]);\n            if (nums[l] == k) {\n                return 0;\n            }\n\n            if (nums[l] < k) {\n                answer = min(answer, k - nums[l]);\n                continue;\n            }\n\n            // via binary search, find first r such that\n            // AND[l,r] < k (meaning AND[l, r - 1] > k)\n            int low = l, high = n - 1, bestRight = n - 1;\n            int bestAndResult = query(l, n - 1);\n            while (low <= high) {\n                int mid = low + (high - low) / 2;\n\n                // check AND[l,mid]\n                int andResult = query(l, mid);\n\n                if (andResult > k) {\n                    // nope\n                    low = mid + 1;\n                } else if (andResult < k) {\n                    // good, but can we do better?\n                    bestRight = mid;\n                    bestAndResult = andResult;\n                    high = mid - 1;\n                } else {\n                    return 0; // found optimal. why bother checking other stuff?\n                }\n            }\n            // note that it is possible that AND[l,n-1] still > k\n            // which is why we have bestRight init as n-1\n            answer = min(answer, abs(k - bestAndResult));\n            if (bestRight > l) {\n                // try bestRight-1\n                int secondBestRight = bestRight - 1;\n                int secondBestAndResult = query(l, secondBestRight);\n                answer = min(answer, abs(k - secondBestAndResult));\n            }\n        }\n        return answer;\n    }\n};",
    "submit_ts": "1717298691",
    "subm_id": "1274787965"
}