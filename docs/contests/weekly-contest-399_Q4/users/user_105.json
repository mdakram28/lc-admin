{
    "username": "ujjwalsharma9671",
    "submission": "class Solution {\n    class Info{\n        long fl;\n        long fXl;\n        long Xfl;\n        long XfXl;\n\n        Info(long fl, long fXl, long Xfl, long XfXl){\n            this.fl = fl;\n            this.fXl = fXl;\n            this.Xfl = Xfl;\n            this.XfXl = XfXl;\n        }\n    }\n\n    Info[] segmentTree;\n    int MIN = -100001;\n    int M = 1000000007;\n    public int maximumSumSubsequence(int[] nums, int[][] queries) {\n        int n = nums.length;\n        segmentTree = new Info[4 * n];\n\n        initTree(0, 0, n - 1, nums);\n\n        long sum = 0;\n\n        for(int[] q: queries){\n            update(0, 0, n - 1, q[0], q[1], nums);\n\n            Info i = segmentTree[0];\n\n            sum = (sum + Math.max(i.fl, Math.max(i.fXl, Math.max(i.Xfl, i.XfXl)))) % M;\n        }\n\n        return (int) sum;\n    }\n\n    private void initTree(int idx, int l, int r, int[] nums){\n        if(l == r){\n            segmentTree[idx] = new Info(nums[l], MIN, MIN, 0);\n            return;\n        }\n\n        int mid = l + (r - l) / 2;\n\n        initTree(2 * idx + 1, l, mid, nums);\n        initTree(2 * idx + 2, mid + 1, r, nums);\n\n        segmentTree[idx] = merge(segmentTree[2 * idx + 1], segmentTree[2 * idx + 2]);\n    }\n\n    private void update(int idx, int l, int r, int updateIdx, int val, int[] nums){\n        if(l == r){\n            nums[l] = val;\n            segmentTree[idx] = new Info(val, MIN, MIN, 0);\n            return;\n        }\n\n        int mid = l + (r - l) / 2;\n\n        if(updateIdx <= mid){\n            update(2 * idx + 1 , l, mid, updateIdx, val, nums);\n        }\n        else update(2 * idx + 2 , mid + 1, r, updateIdx, val, nums);\n\n        segmentTree[idx] = merge(segmentTree[2 * idx + 1], segmentTree[2 * idx + 2]);\n    }\n\n    private Info merge(Info left, Info right){\n        long val1 = (left.fl != MIN && right.Xfl != MIN) ? (left.fl + right.Xfl) : MIN;\n        long val2 = (left.fXl != MIN && right.fl != MIN) ? (left.fXl + right.fl) : MIN;\n        long val3 = (left.fXl != MIN && right.Xfl != MIN) ? (left.fXl + right.Xfl) : MIN;\n\n        long fl = Math.max(val1, Math.max(val2, val3));\n\n        val1 = (left.fl != MIN && right.XfXl != MIN) ? (left.fl + right.XfXl) : MIN;\n        val2 = (left.fXl != MIN && right.fXl != MIN) ? (left.fXl + right.fXl) : MIN;\n        val3 = (left.fXl != MIN && right.XfXl != MIN) ? (left.fXl + right.XfXl) : MIN;\n\n        long fXl = Math.max(val1, Math.max(val2, val3));\n\n        val1 = (left.Xfl != MIN && right.Xfl != MIN) ? (left.Xfl + right.Xfl) : MIN;\n        val2 = (left.XfXl != MIN && right.fl != MIN) ? (left.XfXl + right.fl) : MIN;\n        val3 = (left.XfXl != MIN && right.Xfl != MIN) ? (left.XfXl + right.Xfl) : MIN;\n\n        long Xfl = Math.max(val1, Math.max(val2, val3));\n\n        val1 = (left.Xfl != MIN && right.XfXl != MIN) ? (left.Xfl + right.XfXl) : MIN;\n        val2 = (left.XfXl != MIN && right.fXl != MIN) ? (left.XfXl + right.fXl) : MIN;\n        val3 = (left.XfXl != MIN && right.XfXl != MIN) ? (left.XfXl + right.XfXl) : MIN;\n\n        long XfXl = Math.max(val1, Math.max(val2, val3));\n\n        return new Info(fl, fXl, Xfl, XfXl);\n    }\n}",
    "submit_ts": 1716694763.0
}