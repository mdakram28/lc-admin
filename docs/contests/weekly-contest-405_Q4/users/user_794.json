{
    "username": "iamekagra",
    "submission": "class Solution {\nprivate:\n    struct Node {\n        map<char, Node*> next;\n        vector<pair<int, int>> endings;\n    };\n\n    class Trie {\n    private:\n        Node* origin;\n    \n    public:\n        Trie() : origin(new Node()) {}\n        \n        void addWord(const string& s, int idx, int val) {\n            Node* curr = origin;\n            for (char c : s) {\n                if (!curr->next.count(c)) {\n                    curr->next[c] = new Node();\n                }\n                curr = curr->next[c];\n            }\n            curr->endings.emplace_back(idx, val);\n        }\n        \n        Node* getRoot() { return origin; }\n    };\n\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int len = target.size();\n        vector<long> minCosts(len + 1, LONG_MAX);\n        minCosts[0] = 0;\n        \n        Trie trie;\n        for (int i = 0; i < words.size(); ++i) {\n            trie.addWord(words[i], i, costs[i]);\n        }\n        \n        for (int start = 0; start < len; ++start) {\n            if (minCosts[start] == LONG_MAX) continue;\n            \n            Node* current = trie.getRoot();\n            for (int end = start; end < len; ++end) {\n                if (!current->next.count(target[end])) break;\n                \n                current = current->next[target[end]];\n                for (const auto& [wordIdx, wordPrice] : current->endings) {\n                    int wordLen = words[wordIdx].size();\n                    if (start + wordLen <= len) {\n                        minCosts[start + wordLen] = min(minCosts[start + wordLen], minCosts[start] + wordPrice);\n                    }\n                }\n            }\n        }\n        \n        return minCosts[len] == LONG_MAX ? -1 : minCosts[len];\n    }\n};",
    "submit_ts": "1720322887",
    "subm_id": "1312361730"
}