{
    "username": "felixhuang07",
    "submission": "static const auto init = []() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    return nullptr;\n}();\n\nstruct modint61 {\nprivate:\n\tusing M = modint61;\n\n\tstatic constexpr long long md = (1LL << 61) - 1;\n\npublic:\n\tstatic constexpr long long mod() { return md; }\n\n\tconstexpr modint61() : v(0) {}\n\t// 0 <= x < md * 2\n\n\tconstexpr explicit modint61(long long x) : v(x >= md ? x - md : x) {}\n\n\tconstexpr long long val() const { return v; }\n\tconstexpr M inv() const { return pow(md - 2); }\n\n\tconstexpr M& operator+=(const M& rhs) & {\n\t\tv += rhs.v;\n\t\tif(v >= md) {\n\t\t\tv -= md;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tconstexpr M& operator-=(const M& rhs) & {\n\t\tv -= rhs.v;\n\t\tif(v < 0) {\n\t\t\tv += md;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tconstexpr M& operator*=(const M& rhs) & {\n\t\tusing ull = unsigned long long;\n\n\t\tull uu = (ull) hi() * rhs.hi() * 2;\n\t\tull ll = (ull) lo() * rhs.lo();\n\t\tull lu = (ull) hi() * rhs.lo() + (ull) lo() * rhs.hi();\n\t\tull sum = uu + ll + ((lu & ((1ULL << 30) - 1)) << 31) + (lu >> 30);\n\t\tv = (sum >> 61) + (sum & ull(md));\n\t\tif(v >= md) {\n\t\t\tv -= md;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tconstexpr M& operator/=(const M& rhs) & {\n\t\treturn *this *= rhs.inv();\n\t}\n\n\tconstexpr M& operator+=(const unsigned int& rhs) & { return *this += M(rhs); }\n\tconstexpr M& operator-=(const unsigned int& rhs) & { return *this -= M(rhs); }\n\n\tconstexpr M pow(long long n) const {\n\t\tassert(n >= 0);\n\t\tM ans(1), a = *this;\n\t\twhile(n) {\n\t\t\tif(n & 1) {\n\t\t\t\tans *= a;\n\t\t\t}\n\t\t\ta *= a;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tfriend constexpr M operator+(M lhs, M rhs) { return lhs += rhs; }\n\tfriend constexpr M operator-(M lhs, M rhs) { return lhs -= rhs; }\n\tfriend constexpr M operator*(M lhs, M rhs) { return lhs *= rhs; }\n\tfriend constexpr M operator/(M lhs, M rhs) { return lhs /= rhs; }\n\n\tfriend constexpr M operator+(M lhs, unsigned int rhs) { return lhs += rhs; }\n\tfriend constexpr M operator-(M lhs, unsigned int rhs) { return lhs -= rhs; }\n\n\tconstexpr M operator+() const { return *this; }\n\tconstexpr M operator-() const { return M(md - v); }\n\tconstexpr bool operator==(const M &rhs) const { return v == rhs.v; }\n\tconstexpr bool operator!=(const M &rhs) const { return v != rhs.v; }\n\t\n\tfriend std::ostream& operator<<(std::ostream& out, const M& num) {\n\t\treturn out << num.v;\n\t}\n\nprivate:\n\tlong long v;\n\n\tinline constexpr unsigned int hi() const { return v >> 31; }\n\tinline constexpr unsigned int lo() const { return v & ((1ULL << 31) - 1); }\n};\n\ntemplate<class M = modint61>\nstruct rolling_hash {\n\tstatic std::vector<M> power;\n\tstatic M base;\n\n\tstatic void prepare(int _n) {\n\t\tif(power.size() > 1 && power[0] != base) {\n\t\t\tpower = {M(1)};\n\t\t}\n\t\twhile((int) power.size() <= _n) {\n\t\t\tpower.emplace_back(power.back() * base);\n\t\t}\n\t}\n\n\trolling_hash() : n(0) {}\n\trolling_hash(const std::string& s, M B = generate_base()) : n(s.size()), pref(s.size() + 1) {\n\t\tbase = B;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpref[i + 1] = pref[i] * base + s[i];\n\t\t}\n\t\tprepare(n);\n\t}\n\n\tconstexpr int size() const { return n; }\n\tconstexpr int length() const { return n; }\n\n\tvoid add_char(char c) {\n\t\tpref.emplace_back(pref[n] * base + c);\n\t\tn++;\n\t\tprepare(n);\n\t}\n\n\tstruct Hash {\n\t\tM val;\n\t\tint len;\n\n\t\tconstexpr Hash() : len(0) {}\n\t\tconstexpr Hash(const M& x, int L) : val(x), len(L) {}\n\n\t\tconstexpr int size() const { return len; }\n\t\tconstexpr int length() const { return len; }\n\n\t\t// S + T\n\n\t\tconstexpr Hash& operator+=(const Hash& rhs) & {\n\t\t\tval = val * power[rhs.len] + rhs.val;\n\t\t\tlen += rhs.len;\n\t\t\treturn *this;\n\t\t}\n\n\t\t// S + ... + S\n\n\t\tconstexpr Hash& operator*=(int n) & {\n\t\t\tif(len > 0) {\n\t\t\t\tM a1 = val;\n\t\t\t\tM r = (len < (int) power.size() ? power[len] : base.pow(len));\n\t\t\t\tval = a1 * (r.pow(n) - 1U) / (r - 1U);\n\t\t\t\tlen *= n;\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\n\t\tfriend constexpr Hash operator+(Hash lhs, Hash rhs) { return lhs += rhs; }\n\t\tfriend constexpr Hash operator*(Hash s, int n) { return s *= n; }\n\n\t\tconstexpr bool operator==(const Hash& rhs) const { return val == rhs.val && len == rhs.len; }\n\t\tconstexpr bool operator<(const Hash& rhs) const { return val.val() < rhs.val.val() || (val.val() == rhs.val.val() && len < rhs.len); }\n\t};\n\n\t// [l, r)\n\n\tconstexpr Hash get(int l, int r) const {\n\t\tassert(0 <= l && l <= r && r <= n);\n\t\treturn Hash(pref[r] - pref[l] * power[r - l], r - l);\n\t}\n\n\tconstexpr Hash get() const {\n\t\treturn Hash(pref[n], n);\n\t}\n\n\tstatic inline M generate_base(bool new_base = false) {\n\t\tstatic M B(0);\n\t\tif(B.val() == 0 || new_base) {\n\t\t\tstd::mt19937_64 mt(std::chrono::steady_clock::now().time_since_epoch().count());\n\t\t\tstd::uniform_int_distribution<unsigned long long> rd(1, M::mod() - 1);\n\t\t\tB = M(rd(mt));\n\t\t}\n\t\treturn B;\n\t}\n\nprivate:\n\tint n;\n\tstd::vector<M> pref;\n};\n\ntemplate<class M> std::vector<M> rolling_hash<M>::power{M(1)};\ntemplate<class M> M rolling_hash<M>::base;\n\nusing H = rolling_hash<modint61>;\n\nint dp[50005];\n\nvector<pair<H, int>> s[50005];\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        target = \" \" + target;\n        H all(target);\n        vector<int> lens;\n        map<string, int> mp;\n        for(int i = 0; i < words.size(); i++) {\n            if(mp.find(words[i]) == mp.end()) {\n                mp[words[i]] = costs[i];\n            } else {\n                mp[words[i]] = min(mp[words[i]], costs[i]);\n            }\n            lens.push_back(words[i].size());\n        }\n        for(auto p : mp) {\n            s[p.first.size()].emplace_back(p.first, p.second);\n        }\n        sort(lens.begin(), lens.end());\n        lens.erase(unique(lens.begin(), lens.end()), lens.end());\n        \n        memset(dp, 0x3f, sizeof(dp));\n        dp[0] = 0;\n        int n = target.size() - 1;\n        for(int i = 1; i <= n; i++) {\n            for(auto L : lens) {\n                if(i + L - 1 > n) {\n                    break;\n                }\n                for(int j = 0; j < s[L].size(); j++) {\n                    if(all.get(i, i + L) == s[L][j].first.get()) {\n                        dp[i + L - 1] = min(dp[i + L - 1], dp[i - 1] + s[L][j].second);\n                    }\n                }\n            }\n        }\n        for(auto L : lens) {\n            s[L].clear();\n        }\n        if(dp[n] > 1E9) {\n            return -1;\n        }\n        return dp[n];\n    }\n};",
    "submit_ts": "1720321103",
    "subm_id": "1312313585"
}