{
    "username": "WanderOvO",
    "submission": "/*\n\u8bb0\u5f55\u6240\u6709\u653e\u7740\u7684\u4f4d\u7f6e\n\u662f\u5426\u5b58\u5728\u4e24\u4e2a\u969c\u788d\u4e4b\u95f4\u7684\u8ddd\u79bb >= sz\n\nx \u5904\u653e\u4e00\u4e2a\u969c\u788d\u7269\uff0c\u627e < x \u7684\u6700\u5927\u7684\u653e\u969c\u788d\u7269\u7684\u4f4d\u7f6e pos\uff0c\u8d4b\u503c a[x] = x - pos\n\u67e5\u8be2 [0, x] \u80fd\u5426\u653e sz\uff0c\u6c42 <= x \u7684\u6700\u5927\u7684\u653e\u969c\u788d\u7269\u7684\u4f4d\u7f6e pos\n\u6c42\u524d\u7f00\u5230 pos \u7684\u6700\u5927\u503c\uff0c\u7136\u540e x - pos\n*/\n#define N 50010\n#define ls (k << 1)\n#define rs (k << 1 | 1)\n\ntypedef long long LL;\n\nstruct SegmentTree {\n    int tr[4 * N], n;\n    \n    void pushup(int k) {\n        tr[k] = max(tr[ls], tr[rs]);\n    }\n    \n    void build(int l, int r, int k) {\n        if (l == r) {\n            tr[k] = 0;\n            return;\n        }\n        \n        int mid = (l + r) / 2;\n        build(l, mid, ls);\n        build(mid + 1, r, rs);\n        \n        pushup(k);\n    }\n    \n    void add(int l, int r, int pos, int k, int val) {\n        if (l == r && l == pos) {\n            tr[k] = val;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (pos <= mid) {\n            add(l, mid, pos, ls, val);\n        } else {\n            add(mid + 1, r, pos, rs, val);\n        }\n        pushup(k);\n    }\n    \n    int query(int l, int r, int ql, int qr, int k) {\n        if (ql <= l && r <= qr) {\n            return tr[k];\n        }\n        int mid = (l + r) / 2;\n        int res = 0;\n        if (ql <= mid) {\n            res = query(l, mid, ql, qr, ls);\n        }\n        if (qr > mid) {\n            res = max(res, query(mid + 1, r, ql, qr, rs));\n        }\n        pushup(k);\n        return res;\n    }\n    \n    void init(int sz) {\n        n = sz;\n        build(1, n, 1);\n    }\n};\n\nSegmentTree tr;\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector<bool> res;\n        int n = min((int)N, (int)(3 * queries.size() + 10));\n        tr.init(n);\n        set<int> barriers;\n        barriers.insert(0);\n        for (int i = 0; i < queries.size(); i++) {\n            if (queries[i].size() == 2) {\n                int x = queries[i][1];\n                int old_len = tr.query(1, n, x, x, 1);\n                tr.add(1, n, x, 1, -old_len);\n                auto it = barriers.upper_bound(x);\n                int pos = *prev(it);\n                // cout << pos << endl;\n                barriers.insert(x);\n                tr.add(1, n, x, 1, x - pos);\n                if (it != barriers.end()) {\n                    pos = *it;\n                    tr.add(1, n, pos, 1, pos - x);\n                }\n            } else {\n                int x = queries[i][1], sz = queries[i][2];\n                auto it = barriers.upper_bound(x);\n                int pos = *prev(it);\n                // cout << pos << endl;\n                int max_sz;\n                if (pos > 0) {\n                    max_sz = tr.query(1, n, 1, pos, 1);\n                } else {\n                    max_sz = 0;\n                }\n                // cout << \"max_sz: \" << max_sz << endl;\n                max_sz = max(max_sz, x - pos);\n                // cout << \"max_sz: \" << max_sz << endl;\n                res.push_back(max_sz >= sz);\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1716650874.0
}