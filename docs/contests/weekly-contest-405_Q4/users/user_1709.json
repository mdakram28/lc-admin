{
    "username": "vineet_sharma",
    "submission": "void computeLPSArray(string &pat, int M, int lps[]){\n\t// length of the previous longest prefix suffix\n\tint len = 0;\n\n\tlps[0] = 0; // lps[0] is always 0\n\n\t// the loop calculates lps[i] for i = 1 to M-1\n\tint i = 1;\n\twhile (i < M) {\n\t\tif (pat[i] == pat[len]) {\n\t\t\tlen++;\n\t\t\tlps[i] = len;\n\t\t\ti++;\n\t\t}\n\t\telse // (pat[i] != pat[len])\n\t\t{\n\t\t\t// This is tricky. Consider the example.\n\t\t\t// AAACAAAA and i = 7. The idea is similar\n\t\t\t// to search step.\n\t\t\tif (len != 0) {\n\t\t\t\tlen = lps[len - 1];\n\n\t\t\t\t// Also, note that we do not increment\n\t\t\t\t// i here\n\t\t\t}\n\t\t\telse // if (len == 0)\n\t\t\t{\n\t\t\t\tlps[i] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid KMPSearch(vector<int> vec[],int ind,string &pat, string &txt){\n\tint M = pat.length();\n\tint N = txt.length();\n\n\t// create lps[] that will hold the longest prefix suffix\n\t// values for pattern\n\tint lps[M];\n\n\t// Preprocess the pattern (calculate lps[] array)\n\tcomputeLPSArray(pat, M, lps);\n    // vector<int> vec;\n\n\tint i = 0; // index for txt[]\n\tint j = 0; // index for pat[]\n\twhile ((N - i) >= (M - j)) {\n\t\tif (pat[j] == txt[i]) {\n\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\n\t\tif (j == M) {\n\t\t\tvec[i - j].push_back(ind);\n\t\t\tj = lps[j - 1];\n\t\t}\n\n\t\t// mismatch after j matches\n\t\telse if (i < N && pat[j] != txt[i]) {\n\t\t\t// Do not match lps[0..lps[j-1]] characters,\n\t\t\t// they will match anyway\n\t\t\tif (j != 0)\n\t\t\t\tj = lps[j - 1];\n\t\t\telse\n\t\t\t\ti = i + 1;\n\t\t}\n\t}\n\n}\n\n\nclass Solution {\npublic:\n    int dp[50001];\n    int solve(vector<int> vec[],vector<string> &words,vector<int> &cost,string &s,int i){\n        if(i==s.length()){\n\n            return 0;\n        }\n        if(i>s.length()){\n            return INT_MAX/2;\n        }\n        \n        if(dp[i]!=-1){\n            return dp[i];\n        }\n        int ans=INT_MAX/2;\n        for(int j=0;j<vec[i].size();j++){\n            int len=words[vec[i][j]].size();\n\n            ans=min(ans,solve(vec, words, cost, s, i+len)+cost[vec[i][j]]);\n            // temp.pop_back();\n        }\n        \n        return dp[i]=ans;\n    }\n\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        memset(dp,-1,sizeof(dp));\n        int n=target.size();\n        vector<int> vec[n];\n        map<string, int> mp;\n        for(int i=0;i<words.size();i++){\n            if(mp[words[i]]==0){\n                mp[words[i]]=costs[i];\n            }\n            else{\n                mp[words[i]]=min(mp[words[i]], costs[i]);\n            }\n        }\n        vector<string> word;\n        vector<int> cost;\n        for(auto it: mp){\n            word.push_back(it.first);\n            cost.push_back(it.second);\n        }\n        \n        \n        for(int i=0;i<word.size();i++){\n            KMPSearch(vec, i, word[i], target);\n            \n        }\n\n        int ans=solve(vec, word,cost, target, 0);\n        if(ans==INT_MAX/2){\n            return -1;\n        }\n        return ans;\n\n    }\n};",
    "submit_ts": "1720324542",
    "subm_id": "1312402045"
}