{
    "username": "gonglinyuan",
    "submission": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.failure_link = None\n        self.word = None\n        self.cost = None\n\nclass AhoCorasickAutomaton:\n    def __init__(self, words):\n        self.root = TrieNode()\n        self.build_trie(words)\n        self.build_failure_links()\n\n    def build_trie(self, inpts):\n        for (word, cost) in inpts:\n            node = self.root\n            for char in word:\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.word = word\n            if node.cost is not None:\n                node.cost = min(node.cost, cost)\n            else:\n                node.cost = cost\n    \n    def build_failure_links(self):\n        from collections import deque\n        queue = deque()\n        # Initialize the first level children with failure links to root\n        for child in self.root.children.values():\n            child.failure_link = self.root\n            queue.append(child)\n        \n        # BFS to establish failure links for deeper nodes\n        while queue:\n            current_node = queue.popleft()\n            \n            for char, child_node in current_node.children.items():\n                queue.append(child_node)\n                # Find failure link for the child node\n                fail_node = current_node.failure_link\n                while fail_node is not None and char not in fail_node.children:\n                    fail_node = fail_node.failure_link\n                child_node.failure_link = fail_node.children[char] if fail_node else self.root\n                # if child_node.failure_link:\n                #     child_node.output.extend(child_node.failure_link.output)\n\n    def search(self, text):\n        node = self.root\n        \n        dp = [None for _ in range(len(text) + 1)]\n        dp[0] = 0\n        \n        for ii, char in enumerate(text):\n            i = ii + 1\n            while node is not None and char not in node.children:\n                node = node.failure_link\n            if node is None:\n                node = self.root\n                continue\n            node = node.children[char]\n            \n            # if node.output:\n            #     for pattern in node.output:\n            #         results.append((pattern, i - len(pattern) + 1))\n            \n            cur_node = node\n            while cur_node is not None:\n                if cur_node.word is not None:\n                    # print(cur_node.word, cur_node.cost)\n                    j = i - len(cur_node.word)\n                    # print(j)\n                    if j >= 0 and dp[j] is not None and (dp[i] is None or dp[j] + cur_node.cost < dp[i]):\n                        dp[i] = dp[j] + cur_node.cost\n                cur_node = cur_node.failure_link\n        # print(dp)\n        return dp[-1] if dp[-1] is not None else -1\n\n\nclass Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        ac_automaton = AhoCorasickAutomaton(list(zip(words, costs)))\n        return ac_automaton.search(target)\n",
    "submit_ts": "1720322633",
    "subm_id": "1312355084"
}