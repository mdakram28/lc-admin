{
    "username": "ofgs1",
    "submission": "use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\nimpl Solution {\n    \n    pub fn minimum_sum(grid: Vec<Vec<i32>>) -> i32 {\n        let (m, n) = (grid.len(), grid[0].len());\n        let mut cols = vec![0; n];\n        let mut rols = vec![0; m];\n        for i in 0..m {\n            for j in 0..n {\n                if grid[i][j] == 1 {\n                    cols[j] += 1;\n                    rols[i] += 1;\n                }\n            }\n        }\n        fn f(g: &Vec<Vec<i32>>, cols: &Vec<i32>, rols: &Vec<i32>, mut lt: usize, mut rt: usize, mut tp: usize, mut bo: usize, c: i32, mm: &mut HashMap<usize, i32>) -> i32 {\n\n            let mut ans = ((rt-lt+1)*(bo-tp+1)) as _;\n            let mut key = (((lt * 30 + rt) * 30 + tp) * 30 + bo) * 30 + c as usize;\n            if let Some(&x) = mm.get(&key) {\n                return x;\n            }\n            if c == 0 {\n                while lt < rt && g[tp..=bo].iter().all(|a| a[lt] == 0) {\n                    lt += 1;\n                }\n                while lt < rt && g[tp..=bo].iter().all(|a| a[rt] == 0) {\n                    rt -= 1;\n                }\n                while tp < bo && g[tp][lt..=rt].iter().all(|&a| a == 0) {\n                    tp += 1;\n                }\n                while tp < bo && g[bo][lt..=rt].iter().all(|&a| a == 0) {\n                    bo -= 1;\n                }\n                ans = ((rt-lt+1)*(bo-tp+1)) as _;\n            } else if c == 1 {\n                for i in lt..rt {\n                    let na = f(g, cols, rols, lt, i, tp, bo, 0, mm) + f(g, cols, rols, i+1, rt, tp, bo, 0, mm);\n                    ans = na.min(ans);\n                }\n                for i in tp..bo {\n                    let na = f(g, cols, rols, lt, rt, tp, i, 0, mm) + f(g, cols, rols, lt, rt, i+1, bo, 0, mm);\n                    ans = na.min(ans);\n                }\n            } else {\n                for i in lt..rt {\n                    let na = f(g, cols, rols, lt, i, tp, bo, 1, mm) + f(g, cols, rols, i+1, rt, tp, bo, 0, mm);\n                    let nb = f(g, cols, rols, lt, i, tp, bo, 0, mm) + f(g, cols, rols, i+1, rt, tp, bo, 1, mm);\n                    ans = na.min(ans).min(nb);\n                }\n                for i in tp..bo {\n                    let na = f(g, cols, rols, lt, rt, tp, i, 1, mm) + f(g, cols, rols, lt, rt, i+1, bo, 0, mm);\n                    let nb = f(g, cols, rols, lt, rt, tp, i, 0, mm) + f(g, cols, rols, lt, rt, i+1, bo, 1, mm);\n                    ans = na.min(ans).min(nb);\n                }\n            }\n            // println!(\"{:?}\", (c, lt, rt, tp, bo, ans));\n            mm.insert(key, ans);\n            ans            \n        }\n        f(&grid, &cols, &rols, 0, n-1, 0, m-1, 2, &mut HashMap::new())\n    }\n\n}",
    "submit_ts": 1719112902.0
}