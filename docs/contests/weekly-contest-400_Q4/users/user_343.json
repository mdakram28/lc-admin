{
    "username": "Mayank_Pushpjeet",
    "submission": "#include<bits/stdc++.h>\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;k<n?i<n:i>n;k<n?i+=1:i-=1)\n#define ll long long\n#define si(x)    scanf(\"%d\",&x)\n#define sl(x)    scanf(\"%lld\",&x)\n#define ss(s)    scanf(\"%s\",s)\n#define pi(x)    printf(\"%d\\n\",x)\n#define pl(x)    printf(\"%lld\\n\",x)\n#define ps(s)    printf(\"%s\\n\",s)\n#define deb(x) cout << #x << \"=\" << x << endl\n#define deb2(x, y) cout << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define al(a)           a.begin(),a.end()\n#define alg(a)          a.rbegin(),a.rend()\n#define getunique(v)    {sort(al(v)); v.erase(unique(al(v)),v.end());}\n#define input(a,n)      for(int i=0;i<n;i++)cin>>a[i]\n#define print(a)        for(auto it:a){cout<<it<<\" \";}cout<<endl\n#define sll             set<long long>\n#define msll            multiset<long long>\n#define inmap(x,mymap)  mymap.find(x)!=mymap.end()\n#define mll             map<ll,ll>\n#define mmll            multimap<ll,ll>\n#define uset            unordered_set<ll>\n#define lb              lower_bound\n#define ub              upper_bound\n#define Inf             1e18\n#define YES             cout << \"YES\" << endl;\n#define NO              cout << \"NO\" << endl;\n#define yes             cout << \"YES\" << endl;\n#define no              cout << \"NO\" << endl;\n/*--- bit-stuff ----*/\n#define setbits(a)      (__builtin_popcountll(a))  // to count 1 bits\n#define right(a)        (__builtin_ctzll(a))       // to count trailing 0s\n#define left(a)         (__builtin_clzll(a))       // to count leading 0s\n#define parity(a)       (__builtin_parityll(a))    // to check even odd\n#define all(x) x.begin(), x.end()\n#define clr(x) memset(x, 0, sizeof(x))\n#define sortall(x) sort(all(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>    pii;\ntypedef pair<ll, ll>    pl;\ntypedef vector<int>        vi;\ntypedef vector<ll>        vl;\ntypedef vector<pii>        vpii;\ntypedef vector<pl>        vpl;\ntypedef vector<vi>        vvi;\ntypedef vector<vl>        vvl;\nmt19937_64 rang(chrono::high_resolution_clock::now().time_since_epoch().count());\nint rng(int lim) {\n    uniform_int_distribution<int> uid(0,lim-1);\n    return uid(rang);\n}\nll mpow(ll base, ll exp); \nvoid ipgraph(ll n, ll m);\nvoid dfs(ll u, ll par);\nll NCR(ll n,ll r, ll M);\nll gcdExtended(ll a, ll b, ll* x, ll* y);\nll modinverse(ll A, ll M);\nvoid linear_sieve();\nbool is_ancestor(ll u, ll v);\nll lca(ll u, ll v);\n\nconst int mod = 1'000'000'007;\nconst int mod2 = 998244353;\nconst int N = 3e5, M = N;\nconst int N1 = 10000000;\n//=======================\n\ntemplate <int MOD=mod>\nstruct Modular {\n  int value;\n  static const int MOD_value = MOD;\n\n  Modular(long long v = 0) { value = v % MOD; if (value < 0) value += MOD;}\n  Modular(long long a, long long b) : value(0){ *this += a; *this /= b;}\n\n  Modular& operator+=(Modular const& b) {value += b.value; if (value >= MOD) value -= MOD; return *this;}\n  Modular& operator-=(Modular const& b) {value -= b.value; if (value < 0) value += MOD;return *this;}\n  Modular& operator*=(Modular const& b) {value = (long long)value * b.value % MOD;return *this;}\n\n  friend Modular mexp(Modular a, long long e) {\n    Modular res = 1; while (e) { if (e&1) res *= a; a *= a; e >>= 1; }\n    return res;\n  }\n  friend Modular inverse(Modular a) { return mexp(a, MOD - 2); }\n\n  Modular& operator/=(Modular const& b) { return *this *= inverse(b); }\n  friend Modular operator+(Modular a, Modular const b) { return a += b; }\n  friend Modular operator-(Modular a, Modular const b) { return a -= b; }\n  friend Modular operator-(Modular const a) { return 0 - a; }\n  friend Modular operator*(Modular a, Modular const b) { return a *= b; }\n  friend Modular operator/(Modular a, Modular const b) { return a /= b; }\n  friend std::ostream& operator<<(std::ostream& os, Modular const& a) {return os << a.value;}\n  friend bool operator==(Modular const& a, Modular const& b) {return a.value == b.value;}\n  friend bool operator!=(Modular const& a, Modular const& b) {return a.value != b.value;}\n};\n\nstruct segtree{\n        ll size;\n        vector<long long> operation; \n        void init(ll n){\n                size=1;\n                while(size<n) size*=2;\n                vl v;\n                operation.assign(2*size,(1ll<<40)-1);\n\n        }\n        void build(vl &a,ll x,ll lx,ll rx){\n                if(rx-lx==1){\n                        if(lx<a.size()) operation[x] = a[lx];\n                        return;\n                }\n                else{\n                    ll m = (lx+rx)/2;\n                    build (a,2*x+1,lx,m);\n                    build (a,2*x+2,m,rx);\n                    ll a1 = operation[2*x+1], a2 = operation[2*x+2];\n                    operation[x] = (a1&a2);\n                }\n        }\n        void build(vl &a){\n                build(a,0,0,size);\n        }\n        ll todo(ll l, ll r, ll x,ll lx,ll rx){\n                if(l>=rx || r<=lx) return (1ll<<40) - 1;\n                if(lx>=l && rx<=r){\n                      return operation[x];  \n                }\n                else{\n                        ll m=(lx+rx)/2;\n                        return (todo(l,r,2*x+1,lx,m) & todo(l,r,2*x+2,m,rx));\n                }\n        }\n        ll todo(ll l, ll r){\n                ll p = todo(l,r,0,0,size);\n                return p;\n        }\n        \n};\n\n// =================================================================\n\nvl g[N]; \nvector<ll> lp(N1+1),pr,tin(N+7), tout(N+7),depth(N+7,0);\nvector<vl> up(N+7,vl(20));\nll timer,binary_up;\n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n            ll ans = Inf,i,j;\n            segtree st;\n            st.init(nums.size());\n            vl v;\n            fo(i,nums.size()) v.pb(nums[i]);\n            st.build(v);\n            for(int i = 0; i<nums.size();i++){\n                    int l = -1, h = i;\n                    if(v[i]<=k){\n                            ans = min(ans,k-v[i]);\n                            continue;\n                    }\n                    while(h-l>1){\n                            ll  m = (h+l)/2;\n                            ll now = st.todo(m,i+1);\n                            if(now>=k) h = m;\n                            else l = m;\n                    }\n                    ans = min(ans,abs(st.todo(h,i+1)-k));\n                    if(l>=0) ans = min(ans,abs(k-st.todo(l,i+1)));\n            }\n            return (int)ans;\n    }\n};\n\nvoid linear_sieve()\n{\n    for (int i=2; i <= N1; ++i) {\n    if (lp[i] == 0) {\n        lp[i] = i;\n        pr.push_back(i);\n    }\n    for (int j=0; j < (int)pr.size() && pr[j] <= lp[i] && i*pr[j] <= N1; ++j) {\n        lp[i * pr[j]] = pr[j];\n    }\n  }\n}\n\nll modinverse(ll A, ll M)\n{\n    ll x, y;\n    ll g = gcdExtended(A, M, &x, &y);\n    if (g != 1)\n        return -1;\n    else {\n \n        // m is added to handle negative x\n        ll res = (x % M + M) % M;\n        return res;\n    }\n}\n\nll gcdExtended(ll a, ll b, ll* x, ll* y)\n{\n \n    // Base Case\n    if (a == 0) {\n        *x = 0, *y = 1;\n        return b;\n    }\n \n    // To store results of recursive call\n    ll x1, y1;\n    ll gcd = gcdExtended(b % a, a, &x1, &y1);\n \n    // Update x and y using results of recursive\n    // call\n    *x = y1 - (b / a) * x1;\n    *y = x1;\n \n    return gcd;\n}\n\nll NCR(ll n,ll r, ll M){\n        if(r>n) return 0ll;\n        if(r== n || r==0 ) return 1ll;\n        ll a1=1,a2=1,a3=1,i;\n        for(i=1;i<=n;i++) a1=(a1*i)%M;\n        for(i=1;i<=r;i++) a2=(a2*i)%M;\n        for(i=1;i<=n-r;i++) a3=(a3*i)%M;\n        a2=(a2*(a3))%M;\n        a2=modinverse(a2,M);\n        a1=(a1*a2)%M;\n        return a1;\n}\n\nll mpow(ll base, ll exp) {\n  base %= mod;\n  ll result = 1;\n  while (exp > 0) {\n    if (exp & 1) result = ((ll)result * base) % mod;\n    base = ((ll)base * base) % mod;\n    exp >>= 1;\n  }\n  return result;\n}\n\nvoid ipgraph(ll n, ll m){\n    ll i, u, v;\n    while(m--){\n        cin>>u>>v;\n    u--, v--;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n}\n\nvoid dfs(ll u, ll par){\n    for(ll v:g[u]){\n        if (v == par) continue;\n        dfs(v, u);\n    }\n}\n\nbool is_ancestor(ll u, ll v)\n{\n    return tin[u] <= tin[v] && tout[u] >= tout[v];\n}\n\nll lca(ll u, ll v){\n    if (is_ancestor(u, v)) return u;\n        \n    if (is_ancestor(v, u)) return v;\n        \n    for (ll i = binary_up; i >= 0; --i) {\n        if (!is_ancestor(up[u][i], v)) u = up[u][i];   \n    }\n    return up[u][0];\n}\n",
    "submit_ts": 1717298133.0
}