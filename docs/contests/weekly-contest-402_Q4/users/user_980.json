{
    "username": "Rajat_Choudhary123",
    "submission": "#define ll long long\n#define ull unsigned ll\n#define vi vector<int>\n#define vvi vector<vi>\n#define vvvi vector<vvi>\n#define pii pair<int,int>\n#define umap unordered_map\n#define uset unordered_set\n//Vector\n#define pt1(x) { for(auto it:x) cout<<it<<' '; cout<<endl;}\n//2-D Vector\n#define pt2(x) { for(auto it:x){cout<<\"[ \"; for(auto it2:it) cout<<it2<<' '; cout<<\"]\\n\";}cout<<endl; }\n//Pair\n#define pt3(x) { for(auto it:x) cout<<\"[\"<<it.first<<','<<it.second<<\"]\"; cout<<endl; }\n#define bend(i) i.begin(),i.end()\n#define rbend(i) i.rbegin(),i.rend()\n#define eb emplace_back\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define fr(i,x,s) for(int i=0;i<x.size();i+=s)\n#define rfr(i,x,s) for(int i=x.size()-1;i>=0;i-=s)\n#define F first\n#define S second\n#define mod (int)(1e9+7)\n#define pi 2.0*asin(1)\nstruct seg{\n\tint value=0,lr=0,rr=0;\n\tseg* left=nullptr,*right=nullptr;\n\tseg(int value) \n\t{\n\t\tthis->value=value;\n\t}\n\tseg(int value,int lr,int rr): seg(value)\n\t{\n\t\tthis->lr=lr;\n\t\tthis->rr=rr;\n\t}\n\tseg(int value,int lr,int rr,seg* left,seg* right): seg(value,lr,rr)\n\t{\n\t\tthis->left=left;\n\t\tthis->right=right;\n\t}\n\tvoid pt()\n\t{\n\t\tint leftval=-1,rightval=-1;\n\t\tif(left) leftval=left->value;\n\t\tif(right) rightval=right->value;\n\t\tcout<<\"Value: \"<<value<<\" Range: [\"<<lr<<\",\"<<rr<<\"]\"<<\" Left: \"<<leftval<<\" Right: \"<<rightval<<endl;\n\t\tif(left) left->pt();\n\t\tif(right) right->pt();\n\t}\n\tvoid update(int idx,int val)\n\t{\n\t\t//No-Overlap\n\t\tif(idx<lr or idx>rr) return;\n\t\t//Complete-Overlap\n\t\tif(lr==rr and rr==idx)\n\t\t{\n\t\t\tvalue=val;\n\t\t\treturn;\t\n\t\t} \n\t\tint curval=0;\n\t\tif(left)\n\t\t{\n\t\t\tleft->update(idx,val);\n\t\t\tcurval+=left->value;\n\t\t}\n\t\tif(right)\n\t\t{\n\t\t\tright->update(idx,val);\n\t\t\tcurval+=right->value;\n\t\t}\n\t\tvalue=curval;\n\t}\n\tint query(int l,int r)\n\t{\n\t\t//No-Overlap\n\t\tif(r<lr or l>rr) return 0;\n\t\t//Complete-Overlap\n\t\tif(l<=lr and rr<=r) return value;\n\t\tint ans=0;\n\t\tif(left) ans+=left->query(l,r);\n\t\tif(right) ans+=right->query(l,r);\n\t\treturn ans;\n\t}\n};\nclass Solution {\npublic:\n    seg* makeseg(vi&vt,int l=-1,int r=-1)\n    {\n        if(l==-1 and r==-1) l=0,r=vt.size()-1;\n        if(l==r)\n        {\n            return new seg(vt[l],l,r);\n        }\n        int mid=(l+r)/2;\n        seg* left=makeseg(vt,l,mid);\n        seg* right=makeseg(vt,mid+1,r);\n        int curval=0;\n        if(left)\n        {\n            curval+=left->value;\n        }\n        if(right)\n        {\n            curval+=right->value;\n        }\n        return new seg(curval,l,r,left,right);\n    }\n    void func(int idx,seg* sg,vi&peak,vi&nums)\n    {\n        if(idx<=0 or idx>=nums.size()-1) return;\n        int prev=-1,next=-1;\n        if(idx) prev=nums[idx-1];\n        if(idx+1<nums.size()) next=nums[idx+1];\n        if(nums[idx]>max(prev,next))\n        {\n            sg->update(idx,true);\n            peak[idx]=true;\n        }\n        else\n        {\n            sg->update(idx,false);\n            peak[idx]=false;\n        }\n    }\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> peak(1,false);\n        for(auto i=1;i<nums.size()-1;i++)\n        {\n            if(nums[i]>max(nums[i-1],nums[i+1])) peak.emplace_back(true);\n            else peak.emplace_back(false);\n        }\n        peak.emplace_back(false);\n        seg* sg=makeseg(peak);\n        vector<int> ans;\n        if(nums.size()==1)\n        {\n            for(auto it:queries)\n            {\n                if(it[0]==1) ans.emplace_back(0);\n            }\n            return ans;\n        }\n        for(auto it:queries)\n        {\n            if(it[0]==1)\n            {\n                int first=it[1]+1;\n                int second=it[2]-1;\n                if(first<=second)\n                ans.emplace_back(sg->query(first,second));\n                else\n                ans.emplace_back(0);\n                // pt1(peak);\n            }\n            else\n            {\n                int idx=it[1];\n                int val=it[2];\n                nums[idx]=val;\n                if(idx==0)\n                {\n                    func(idx+1,sg,peak,nums);\n                }\n                else if(idx==nums.size()-1)\n                {\n                    func(idx-1,sg,peak,nums);\n                }\n                else\n                {\n                    func(idx,sg,peak,nums);\n                    func(idx+1,sg,peak,nums);\n                    func(idx-1,sg,peak,nums);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718508923.0
}