{
    "username": "pein531",
    "submission": "const int N = 5010, INF = 0x3f3f3f3f;\n\nclass SegmentTree {\npublic:\n    struct Info {\n        int l, r, v;\n        Info() {}\n        Info(int left, int right, int val): l(left), r(right), v(val) {}\n    } seg[N<<2];\n\n    explicit SegmentTree() {}\n\n    void build(int u, int l, int r) {\n        if(l == r) {\n            seg[u] = Info(l, r, 0);\n        }else {\n            int mid = l + r >> 1;\n            build(u<<1, l, mid);\n            build(u<<1|1, mid + 1, r);\n            pushup(u);\n        }\n    }\n\n    void modify(int pos, int val) {\n        modify(1, pos, val);\n    }\n\n    Info query(int l, int r) {\n        if(l > r) return Info(0, 0, 0);\n        return query(1, l, r);\n    }\n\nprivate:\n    void modify(int u, int pos, int val) {\n        if(seg[u].l == pos && seg[u].r == pos) {\n            seg[u] = Info(pos, pos, val);\n        }else {\n            int mid = seg[u].l + seg[u].r >> 1;\n            if(pos <= mid) modify(u<<1, pos, val);\n            else modify(u<<1|1, pos, val);\n            pushup(u);\n        }\n    }\n\n    Info query(int u, int l, int r) {\n        if(l <= seg[u].l && seg[u].r <= r) return seg[u];\n        int mid = seg[u].l + seg[u].r >> 1;\n        if(r <= mid) {\n            return query(u<<1, l, r);\n        }else if(mid < l) {\n            return query(u<<1|1, l, r);\n        }else {\n            return merge(query(u<<1, l, r), query(u<<1|1, l, r));\n        }\n    }\n\n    void pushup(int u) {\n        seg[u] = merge(seg[u<<1], seg[u<<1|1]);\n    }\n\n    Info merge(const Info& lchild, const Info& rchild) {\n        Info info;\n        info.l = lchild.l;\n        info.r = rchild.r;\n        info.v = max(lchild.v, rchild.v);\n        return info;\n    }\n};\n\nclass Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> vals;\n        for(int i = 0; i < n; i++) {\n            vals.push_back(nums[i]);\n        }\n        sort(vals.begin(), vals.end());\n        vals.erase(unique(vals.begin(), vals.end()), vals.end());\n        unordered_map<int, int> val2pos;\n        int sz = vals.size();\n        for(int i = 0; i < sz; i++) {\n            val2pos[vals[i]] = i + 1;\n        }\n        vector<SegmentTree> seg;\n        for(int i = 0; i <= k; i++) {\n            SegmentTree tree;\n            tree.build(1, 1, sz);\n            seg.push_back(tree);\n        }\n        int ans = 1;\n        for(int i = 0; i < n; i++) {\n            int index = val2pos[nums[i]];\n            for(int rest = 0; rest <= min(k, i); rest++) {\n                if(i == 0) {\n                    seg[rest].modify(index, 1);\n                    ans = max(ans, seg[rest].query(index, index).v);\n                }else {\n                    int dp = 0;\n                    if(rest > 0) {\n                        int left = index > 1? seg[rest - 1].query(1, index - 1).v: 0;\n                        int right = index + 1 <= sz? seg[rest - 1].query(index + 1, sz).v: 0;\n                        dp = max(dp, max(left, right) + 1);\n                    }\n                    dp = max(dp, seg[rest].query(index, index).v + 1);\n                    seg[rest].modify(index, dp);\n                    ans = max(ans, dp);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1717860584",
    "subm_id": "1281762557"
}