{
    "username": "profchi",
    "submission": "class Solution {\n\n    Set<Integer> [] graph;\n\n    int diam;\n    int [] diameter;\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        diam = 0;\n        int res = getCount(edges1) + getCount(edges2) - 1; \n\n        return Math.max(res, diam - 1);\n    }\n\n\n    private int getCount(int [][] edges) {\n        if (edges.length == 0)\n            return 1;\n\n        int n = edges.length + 1;\n\n        graph = new Set[n];\n\n        for (int i = 0; i < n; ++i) {\n            graph[i] = new HashSet<>();\n        }\n\n        int u, v;\n\n        for (int [] edge : edges) {\n            u = edge[0];\n            v = edge[1];\n\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n\n        diameter = new int [3];\n        getDiameter(0, -1);\n        diam = Math.max(diam, diameter[2]);\n\n        Queue<Integer> queue = new LinkedList<>();\n\n        for (int i = 0; i < n; ++i) {\n            if (graph[i].size() == 1)\n                queue.add(i);\n        }\n\n        int size;\n        int count = 0;\n        int current;\n\n        int last = 0;\n\n        while (!queue.isEmpty()) {\n            size = queue.size();\n            ++count;\n            last = size;\n\n            while (size-- > 0) {\n                current = queue.remove();\n\n               // System.out.println(current + \" \" + count);\n\n                for (int next : graph[current]) {\n                    graph[next].remove(current);\n\n                    if (graph[next].size() == 1)\n                        queue.add(next);\n                }\n            }\n        }\n\n        int res = count + (last > 1 ? 1 : 0);\n       \n        //System.out.println(res); \n        return res;\n    }\n\n    private int [] getDiameter(int node, int parent) {\n\t\t\n\t\tint [] result = new int [] {node, node, 1};\n\t\t\n\t\tint [] first = new int [3];\n\t\tint [] second = new int [3];\n\t\t\n\t\tfirst[0] = result[0];\n\t\tfirst[1] = result[1];\n\t\tfirst[2] = result[2];\n\t\t\n\t\tint [] test;\n\t\t\n\t\tfor (int child : graph[node]) {\n\t\t\tif (child == parent)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\ttest = getDiameter(child, node);\n\t\t\t\n\t\t\tif (test[2] + 1 > result[2]) {\n\t\t\t\tresult[1] = test[1];\n\t\t\t\tresult[2] = test[2] + 1;\n\t\t\t}\n\t\t\t\n\t\t\tif (test[2] + 1 > first[2]) {\n\t\t\t\tsecond = first;\n\t\t\t\tfirst = test;\n\t\t\t\tfirst[2]++;\n\t\t\t\tfirst[0] = node;\n\t\t\t} else if (test[2] + 1> second[2]) {\n\t\t\t\tsecond[0] = node;\n\t\t\t\tsecond = test;\n\t\t\t\tsecond[2]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (first[2] + second[2] - 1 > result[2]) {\n\t\t\tresult[0] = first[1];\n\t\t\tresult[1] = second[1];\n\t\t\tresult[2] = first[2] + second[2] - 1;\n\t\t}\n\t\t\n\t\tif (result[2] > diameter[2]) {\n\t\t\tdiameter = result;\n\t\t}\n\t\t\n        // System.out.println(node + \" \" + Arrays.toString(first));\n\t\treturn first;\n\t}\n}",
    "submit_ts": 1719717881.0
}