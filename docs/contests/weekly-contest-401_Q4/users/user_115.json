{
    "username": "z123k3",
    "submission": "class Solution {\n    public int maxTotalReward(int[] rv) {\n        TreeSet<Integer> set = new TreeSet<>();\n        for (int num : rv) {\n            set.add(num);\n        }\n        Map<Integer, Boolean> seen = new HashMap<>();\n        seen.put(0, true);\n        \n        int n = set.size();\n        \n        rv = new int[n];\n        int i = 0;\n        for (int num : set) {\n            seen.put(num, true);\n            rv[i++] = num;\n        }\n                \n        for(i = rv[n-1] + rv[n-1] - 1; i >=0; i--) {\n            if(can(seen, set, i)) {\n                return i;\n            }\n        }\n        \n        return rv[0];\n    }\n    \n    private boolean can(Map<Integer, Boolean> seen, TreeSet<Integer> set, int val) {\n        //System.out.println(seen + \" \" + set + \" \" + val);\n        \n        if(seen.containsKey(val)) {\n            return seen.get(val);\n        }\n        \n        List<Integer> candidates = new ArrayList<>(set.headSet(val));\n            \n        for(int i = candidates.size() - 1; i >=0; i--) {\n            int num = candidates.get(i);\n            \n            if((val - num) >= num){\n                seen.put(val, false);\n                return false;\n            }\n            \n            if(can(seen, set, val - num)) {\n                seen.put(val, true);\n                return true;\n            }\n        }\n        \n        seen.put(val, false);\n        return false;\n    }\n}",
    "submit_ts": 1717904138.0
}