{
    "username": "krishnash1355",
    "submission": "class Solution {\npublic:\n    vector<int> segTree;\n\n    void build(vector<int> &a, int start, int end, int index) {\n        // Time Complexity -> O(n)\n        if (start == end) {\n            segTree[index] = a[start];\n            return;\n        }\n        int left = 2 * index; int right = 2 * index + 1;\n        int mid = (start + end) / 2;\n        build(a, start, mid, left);\n        build(a, mid + 1, end, right);\n        segTree[index] = segTree[left] + segTree[right];\n        return;\n    }\n\n    void update(vector<int> &a, int start, int end, int index, int pos, int val) {\n        // Time Complexity -> O(logn)\n        if (start == end) {\n            a[pos] = val;\n            segTree[index] = val;\n            return;\n        }\n        int mid = (start + end) / 2;\n        if (pos <= mid) update(a, start, mid, 2 * index, pos, val);\n        else update(a, mid + 1, end, 2 * index + 1, pos, val);\n        segTree[index] = segTree[2 * index] + segTree[2 * index + 1];\n    }\n\n    int query(int start, int end, int index, int l, int r) {\n        // Time Complexity -> O(logn)\n        // start & end will be zero based indexing from (0 to n-1);\n        // l & r will be zero based\n        if (l <= start && end <= r) return segTree[index];\n        if (r < start || l > end) return 0;\n        int mid = (start + end) / 2;\n        return query(start, mid, 2 * index, l, r) + query(mid + 1, end, 2 * index + 1, l, r);\n    }\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        segTree.resize(4 * n);\n        vector<int> v(n);\n        for (int i = 1; i < n - 1; i++) if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) v[i] = 1;\n        build(v, 0, n - 1, 1);\n        vector<int> ans;\n        for (auto i : queries) {\n            if (i[0] == 2) {\n                int val = i[2];\n                int index = i[1];\n                int change = 0;\n                nums[index] = val;\n                if (index == 0 || index == n - 1) change = 0;\n                else if (nums[index - 1] < nums[index] && nums[index] > nums[index + 1]) change = 1;\n                    \n                int lefty = 0;\n                if (index - 1 <= 0 || index - 1 >= n - 1) lefty = 0;\n                else if (nums[index] < nums[index - 1] && nums[index - 1] > nums[index - 2]) lefty = 1;\n\n                int righty = 0;\n                if (index + 1 <= 0 || index + 1 >= n - 1) righty = 0;\n                else if (nums[index] < nums[index + 1] && nums[index + 1] > nums[index + 2]) righty = 1;\n\n                update(v, 0, n - 1, 1, index, change);\n                if (index > 1)\n                    update(v, 0, n - 1, 1, index - 1, lefty);\n                if (index < n - 1)\n                    update(v, 0, n - 1, 1, index + 1, righty);\n            }\n            else\n                ans.push_back(query(0, n - 1, 1, i[1] + 1, i[2] - 1));\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718507389.0
}