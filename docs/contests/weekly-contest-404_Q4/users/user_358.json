{
    "username": "thunder_strike",
    "submission": "class Solution {\npublic:\n    \n    int x;\n    \n    void dfsUtil(int node, int count, vector<int> &visited,\n                       int& maxCount, vector<vector<int>> &g)\n    {\n        visited[node] = true;\n        count++;\n        for (auto i:g[node]) {\n            if (!visited[i]) {\n                if (count >= maxCount) {\n                    maxCount = count;\n                    x = i;\n                }\n                dfsUtil(i, count, visited, maxCount, g);\n            }\n        }\n    }\n    \n    void dfs(int node, int n, vector<vector<int>> &g, int& maxCount)\n{\n        vector<int> visited(n+5,0);\n        int count = 0;\n\n        for (int i = 0; i < n; ++i)\n            visited[i] = false;\n\n        dfsUtil(node, count + 1, visited, maxCount, g);\n    }\n    \n    int find_rad(vector<vector<int>>& edges){\n        int n=0;\n        for(auto &i:edges){\n            n=max({n,i[0],i[1]});\n        }\n        vector<vector<int>> g(n+3);\n        for(auto &i:edges){\n            g[i[0]].push_back(i[1]);\n            g[i[1]].push_back(i[0]);\n        }\n        int maxCount = -1e8;\n \n        dfs(1, n, g, maxCount);\n        \n        dfs(x, n, g, maxCount);\n\n        return maxCount;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int d1=0,d2=0;\n        if(!edges1.empty()){\n            d1=find_rad(edges1)-1;\n        }\n        if(!edges2.empty()){\n            d2=find_rad(edges2)-1;\n        }\n        int r1=(d1+1)/2;\n        int r2=(d2+1)/2;\n        int ans=max({d1,d2,r1+r2+1});\n        // cout<<d1<<\" \"<<d2<<'\\n';\n        return ans;\n    }\n};",
    "submit_ts": 1719716892.0
}