{
    "username": "believer_79",
    "submission": "\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& b) {\n        int d = a.size();\n        vector<int> ans;\n        vector<int> peaks(d, 0);\n        vector<int> segTree(4 * d, 0);\n\n        auto isPeak = [&](int i) {\n            return i > 0 && i < d - 1 && a[i] > a[i - 1] && a[i] > a[i + 1];\n        };\n\n        function<void(int, int, int)> buildSegTree = [&](int node, int start, int end) {\n            if (start == end) {\n                segTree[node] = peaks[start];\n            } else {\n                int mid = (start + end) / 2;\n                buildSegTree(2 * node + 1, start, mid);\n                buildSegTree(2 * node + 2, mid + 1, end);\n                segTree[node] = segTree[2 * node + 1] + segTree[2 * node + 2];\n            }\n        };\n\n        function<void(int, int, int, int, int)> updateSegTree = [&](int node, int start, int end, int idx, int val) {\n            if (start == end) {\n                segTree[node] = val;\n            } else {\n                int mid = (start + end) / 2;\n                if (start <= idx && idx <= mid) {\n                    updateSegTree(2 * node + 1, start, mid, idx, val);\n                } else {\n                    updateSegTree(2 * node + 2, mid + 1, end, idx, val);\n                }\n                segTree[node] = segTree[2 * node + 1] + segTree[2 * node + 2];\n            }\n        };\n\n        function<int(int, int, int, int, int)> querySegTree = [&](int node, int start, int end, int L, int R) -> int {\n            if (R < start || end < L) return 0;\n            if (L <= start && end <= R) return segTree[node];\n            int mid = (start + end) / 2;\n            int leftQuery = querySegTree(2 * node + 1, start, mid, L, R);\n            int rightQuery = querySegTree(2 * node + 2, mid + 1, end, L, R);\n            return leftQuery + rightQuery;\n        };\n\n        for (int i = 1; i < d - 1; ++i) {\n            if (isPeak(i)) peaks[i] = 1;\n        }\n\n        buildSegTree(0, 0, d - 1);\n\n        for (const auto& q : b) {\n            if (q[0] == 1) {\n                int li = q[1], ri = q[2];\n                ans.push_back(querySegTree(0, 0, d - 1, li + 1, ri - 1));\n            } else if (q[0] == 2) {\n                int idx = q[1], val = q[2];\n                a[idx] = val;\n                if (idx > 0 && idx < d - 1) {\n                    peaks[idx] = isPeak(idx) ? 1 : 0;\n                    updateSegTree(0, 0, d - 1, idx, peaks[idx]);\n                }\n                if (idx - 1 > 0) {\n                    peaks[idx - 1] = isPeak(idx - 1) ? 1 : 0;\n                    updateSegTree(0, 0, d - 1, idx - 1, peaks[idx - 1]);\n                }\n                if (idx + 1 < d - 1) {\n                    peaks[idx + 1] = isPeak(idx + 1) ? 1 : 0;\n                    updateSegTree(0, 0, d - 1, idx + 1, peaks[idx + 1]);\n                }\n            }\n        }\n\n        return ans;\n    }\n};\n",
    "submit_ts": 1718507580.0
}