{
    "username": "balakrishnan_v",
    "submission": "#define MAXN 100000\nclass Solution {\npublic:\n    \n    // interval [u, v]\n    // w is inside\n    // break into [u,w-1], [w], [w+1, v]\n    \n    // w -> interval containing w-1, w and w+1\n    \n    bool InInterval(pair<int,int> I, int w) {\n        return (I.first <= w && I.second >= w);\n    }\n    \n    pair<int,int> GetIntervalContaining(const set<pair<int,int>>& intervals, int w) {\n        auto it = intervals.lower_bound({w+1,-1});\n        if (it == intervals.begin()) return {-1,-1};\n        it--;\n        if (InInterval(*it,w)) return *it;\n        else return {-1,-1};\n    }\n    \n    int Asum[MAXN+2];\n    int Bsum[MAXN+2];\n    \n    void update(vector<int>& tree, int idx, int delta) {\n        while(idx < tree.size()) {\n            tree[idx]+=delta;\n            idx += (idx&-idx);\n        }\n    }\n    \n    int read(vector<int>& tree, int idx) {\n        int ret=0;\n        while(idx) {\n            ret += tree[idx];\n            idx -= (idx&-idx);\n        }\n        return ret;\n    }\n    \n    \n    vector<int> Atree,Btree;\n    \n    \n    void UpdateInterval(int u, int v, int n, int delta) {\n        if (u > n) return;\n        int max_ct = n-u;\n        \n        // v-u+1 -> 1\n        // \n        // x -> 2+v-u-x <= max_ct -> x >= 2+v-u-max_ct\n        \n        int x = max(1, 2+v-u-max_ct);\n        \n        update(Btree, x, (2+v-u)*delta);\n        update(Btree, v-u+2, -(2+v-u)*delta);\n        \n        update(Atree, x, -delta);\n        update(Atree, v-u+2, delta);\n        \n//         for(int t=x;t<=v-u+1;t++) {\n//             Bsum[t] += (2+v-u)*delta;\n//             Asum[t] += -1*delta;\n//         }\n        \n        update(Btree, 1, (2+v-u-x)*delta);\n        update(Btree, x, -(2+v-u-x)*delta);\n        // for(int t=1;t<=x-1;t++) {\n        //     Bsum[t]+=(2+v-u-x)*delta;\n        // }\n        \n    }\n    \n    void Update(set<pair<int,int>>& intervals, vector<int>& colors, int w, int c) {\n        int n=colors.size()/2;\n        set<pair<int,int>> updating_intervals;\n        for(int x : {w-1,w,w+1}) {\n            pair<int,int> curr = GetIntervalContaining(intervals, x);\n            if (curr.first != -1) {\n                updating_intervals.insert(curr);\n            }\n        }\n        \n        vector<pair<int,int>> broken_intervals;\n        for(auto tmp : updating_intervals) {\n            intervals.erase(tmp);\n            UpdateInterval(tmp.first,tmp.second,n,-1);\n            if (InInterval(tmp, w)) {\n                if (tmp.first <= w-1) broken_intervals.push_back({tmp.first,w-1});\n                broken_intervals.push_back({w,w});\n                if (w+1<=tmp.second) broken_intervals.push_back({w+1,tmp.second});\n            } else {\n                broken_intervals.push_back(tmp);\n            }\n        }\n        colors[w]=c;     \n        vector<pair<int,int>> new_intervals;\n        for(int i=0;i<broken_intervals.size();i++) {\n            if (i == 0 || colors[broken_intervals[i].first]==colors[broken_intervals[i-1].second]) {\n                new_intervals.push_back(broken_intervals[i]);\n            } else {\n                new_intervals.back().second = broken_intervals[i].second;\n            }\n        }\n        \n        for(auto tmp : new_intervals) {\n            UpdateInterval(tmp.first,tmp.second,n,1);\n            intervals.insert(tmp);\n        }\n    }\n    \n    \n    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {\n        int n=colors.size();\n        for(int i=0;i<n;i++) {\n            colors.push_back(colors[i]);\n        }\n        \n        Atree=vector<int>(n+2,0);\n        Btree=vector<int>(n+2,0);\n\n        // for(int j=1;j<=n;j++) {\n        //     Asum[j]=Bsum[j]=0;\n        // }\n        \n        set<pair<int,int>> intervals;\n        for(int i=0;i<2*n;) {\n            int j=i;\n            while(j+1<2*n && colors[j+1]!=colors[j]) {\n                j++;\n            }\n            intervals.insert({i,j});\n            UpdateInterval(i,j,n,1);\n            i=j+1;\n        }\n        \n        \n        // a given interval [u,v] -> contributes to \n        // v-u+1 -> 1\n        // v-u -> 2\n        //\n        // x -> 2+v-u-x\n        // x-1 -> 2+v-u-x\n        // 1 -> 2+v-u-x\n        \n        \n        // for t in  x to v-u+1 -> 2+v-u-t -> B = 2+v-u and A = -1\n        // for t in 1 to x-1 -> 2+v-u-x -> B = 2+v-u-x and A = 0\n        \n        vector<int> ret;\n        for(auto tmp : queries) {\n            int type = tmp[0];\n            if (type == 1) {\n                int sz = tmp[1];\n                int curr_ans = read(Atree, sz)*sz + read(Btree, sz);\n//                 for(auto curr_interval : intervals) {\n//                     if (curr_interval.first > n) break;\n//                     int interval_sz = curr_interval.second-curr_interval.first+1;\n                    \n//                     // can start at u,u+1,,n-1\n                    \n                    \n                    \n                    \n//                     if (interval_sz >= sz) curr_ans += min(interval_sz-sz+1,n-curr_interval.first);\n//                 }\n                ret.push_back(curr_ans);\n                \n                \n            } else {\n                int idx = tmp[1];\n                int c = tmp[2];\n                Update(intervals, colors, idx, c);\n                Update(intervals, colors, idx+n, c);\n            }\n        }\n        \n        return ret;\n        \n    }\n};",
    "submit_ts": "1722743684",
    "subm_id": "1343797361"
}