{
    "username": "jiangzhouxy",
    "submission": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int l1 = length(edges1);\n        int l2 = length(edges2);\n        // System.out.println(length(edges1));\n        // System.out.println(length(edges2));\n        return Math.max(Math.max(l1 - 1, l2 - 1), l1 / 2 + l2 / 2 + 1);\n    }\n    \n    private int length(int[][] edge) {\n        if (edge.length == 0) {\n            return 0;\n        }\n        int n = edge.length + 1;\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int[] e : edge) {\n            graph.putIfAbsent(e[0], new ArrayList<>());\n            graph.putIfAbsent(e[1], new ArrayList<>());\n            \n            graph.get(e[1]).add(e[0]);\n            graph.get(e[0]).add(e[1]);\n        }\n        \n        int[] res = cal(graph, n, 0);\n        return cal(graph, n, res[0])[1];\n        \n    }\n    \n    private int[] cal(Map<Integer, List<Integer>> graph, int n, int start) { // node, length\n        Queue<Integer> q = new LinkedList<>();\n    \n        // start with 0\n        boolean[] visited = new boolean[n];\n        q.add(start);\n        visited[start] = true;\n        \n        int res = 0;\n        int node = -1;\n        while (!q.isEmpty()) {\n            int qsize = q.size();\n            for (int i = 0; i < qsize; i++) {\n                int cur = q.poll();\n                node = cur;\n                for (int next: graph.get(cur)) {\n                    if (!visited[next]) {\n                        visited[next] = true;   \n                        q.add(next);\n                    }\n                }\n            }\n            res++;\n        }\n        return new int[]{node, res};\n    }\n}",
    "submit_ts": "1719717845",
    "subm_id": "1304402201"
}