{
    "username": "m-iller",
    "submission": "class Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        int n = nums.length;\n        SegmentTree segmentTree = new SegmentTree(nums);\n        List<Integer> result = new ArrayList<>();\n        for (int[] query : queries) {\n            if (query[0] == 1) {\n                int li = query[1];\n                int ri = query[2];\n                result.add(segmentTree.countPeaks(li, ri));\n            } else if (query[0] == 2) {\n                int index = query[1];\n                int val = query[2];\n                segmentTree.update(index, val);\n            }\n        }\n        return result;\n    }\n    \n    class SegmentTree {\n        private int[] nums;\n        private int[] peaks;\n        \n        public SegmentTree(int[] nums) {\n            this.nums = nums;\n            this.peaks = new int[nums.length * 4];\n            build(0, 0, nums.length - 1);\n        }\n        \n        private void build(int node, int start, int end) {\n            if (start == end) {\n                peaks[node] = isPeak(start) ? 1 : 0;\n            } else {\n                int mid = (start + end) / 2;\n                int leftChild = 2 * node + 1;\n                int rightChild = 2 * node + 2;\n                build(leftChild, start, mid);\n                build(rightChild, mid + 1, end);\n                peaks[node] = peaks[leftChild] + peaks[rightChild];\n            }\n        }\n        \n        public void update(int index, int val) {\n            nums[index] = val;\n            update(0, 0, nums.length - 1, index);\n            // \u66f4\u65b0\u76f8\u90bb\u8282\u70b9\uff0c\u786e\u4fdd\u5cf0\u503c\u72b6\u6001\u7684\u6b63\u786e\u6027\n            if (index > 0) {\n                update(0, 0, nums.length - 1, index - 1);\n            }\n            if (index < nums.length - 1) {\n                update(0, 0, nums.length - 1, index + 1);\n            }\n        }\n        \n        private void update(int node, int start, int end, int index) {\n            if (start == end) {\n                peaks[node] = isPeak(start) ? 1 : 0;\n            } else {\n                int mid = (start + end) / 2;\n                int leftChild = 2 * node + 1;\n                int rightChild = 2 * node + 2;\n                if (index <= mid) {\n                    update(leftChild, start, mid, index);\n                } else {\n                    update(rightChild, mid + 1, end, index);\n                }\n                peaks[node] = peaks[leftChild] + peaks[rightChild];\n            }\n        }\n        \n        public int countPeaks(int li, int ri) {\n            // \u786e\u4fdd\u4e0d\u5305\u62ec\u5b50\u6570\u7ec4\u7684\u7b2c\u4e00\u4e2a\u548c\u6700\u540e\u4e00\u4e2a\u5143\u7d20\n            if (li + 1 >= ri) {\n                return 0;\n            }\n            return query(0, 0, nums.length - 1, li + 1, ri - 1);\n        }\n        \n        private int query(int node, int start, int end, int L, int R) {\n            if (L > end || R < start) {\n                return 0;\n            }\n            if (L <= start && end <= R) {\n                return peaks[node];\n            }\n            int mid = (start + end) / 2;\n            int leftChild = 2 * node + 1;\n            int rightChild = 2 * node + 2;\n            int leftResult = query(leftChild, start, mid, L, R);\n            int rightResult = query(rightChild, mid + 1, end, L, R);\n            return leftResult + rightResult;\n        }\n        \n        private boolean isPeak(int index) {\n            if (index <= 0 || index >= nums.length - 1) {\n                return false;\n            }\n            return nums[index] > nums[index - 1] && nums[index] > nums[index + 1];\n        }\n    }\n}",
    "submit_ts": 1718506341.0
}