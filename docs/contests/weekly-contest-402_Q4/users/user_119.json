{
    "username": "Romy67",
    "submission": "#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define per(i, a, b) for(int i = a; i > (b); --i)\n#define ar array\n#define sz(x) (int) (x).size()\n#define pii pair<int,int>\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\n\ntemplate<typename T>\nvoid min_self(T& A, T B) {\n    A = min(A,B);\n}\ntemplate<typename T>\nvoid max_self(T& A, T B) {\n    A = max(A,B);\n}\n\nstruct FT {\n    vector<ll> s;\n    FT(int n) : s(n) {}\n    void update(int pos, ll dif) { // a[pos] += dif\n        for (; pos < sz(s); pos |= pos + 1) s[pos] += dif;\n    }\n    ll query(int pos) { // sum of values in [0, pos)\n        ll res = 0;\n        for (; pos > 0; pos &= pos - 1) res += s[pos-1];\n        return res;\n    }\n    int lower_bound(ll sum) {// min pos st sum of [0, pos] >= sum\n        // Returns n if no sum is >= sum, or -1 if empty sum is.\n        if (sum <= 0) return -1;\n        int pos = 0;\n        for (int pw = 1 << 25; pw; pw >>= 1) {\n            if (pos + pw <= sz(s) && s[pos + pw-1] < sum)\n                pos += pw, sum -= s[pos-1];\n        }\n        return pos;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        FT ft(sz(nums));\n        vector<int> a(nums.begin(),nums.end());\n        rep(i,0,sz(nums)) {\n            if(i>0 && i+1<sz(nums) && nums[i]>nums[i-1] && nums[i]>nums[i+1]) {\n                ft.update(i, 1ll);\n            } \n        }\n        vector<int> v;\n        auto upd = [&](int idx) -> void {\n            if(!(idx>0 && idx+1<sz(a))) return;\n            int prv = ft.query(idx+1)-ft.query(idx);\n            int now = 0;\n            if(a[idx]>a[idx-1] && a[idx]>a[idx+1]) {\n                now = 1;\n            } else {\n                now = 0;\n            }\n            if(now-prv!=0) {\n                ft.update(idx, now-prv);\n            }\n        };\n        rep(i,0,sz(queries)) {\n            int qt = queries[i][0];\n            if(qt==1) {\n                int l=queries[i][1], r = queries[i][2];\n                int ans = ft.query(r);\n                if(l==r) {\n                    ans = 0;\n                } else {\n                    ans -= ft.query(l+1);\n                }\n                v.push_back(ans);\n            } else {\n                int idx = queries[i][1], x = queries[i][2];\n                a[idx] = x;\n                upd(idx);\n                upd(idx-1);\n                upd(idx+1);\n            }\n        }\n        return v;\n    }\n};",
    "submit_ts": 1718506685.0
}