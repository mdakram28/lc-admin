{
    "username": "fatalerror-i",
    "submission": "class LazySegmentTree:\n    __slots__ = 'n', 'height', 'size', 'initval', 'initlazy', 'op', 'apply', 'compose', 'tree', 'lazy'\n    def __init__(self, nums, initval, initlazy, op, apply, compose):\n        self.n = len(nums)\n        self.height = (self.n-1).bit_length()\n        self.size = 1 << self.height\n        self.initval = initval\n        self.initlazy = initlazy\n        self.op = op\n        self.apply = apply\n        self.compose = compose\n\n        self.tree = [initval for _ in range(2 * self.size)]\n        self.tree[self.size:self.size+self.n] = nums\n        for i in range(self.size-1, 0, -1):\n            self.pushup(i)\n        self.lazy = [initlazy for _ in range(self.size)]\n\n    def pushup(self, rt):\n        self.tree[rt] = self.op(self.tree[rt*2], self.tree[rt*2+1])\n\n    def pushdown(self, rt):\n        if self.lazy[rt] == self.initlazy: return\n        self.modify(rt*2, self.lazy[rt])\n        self.modify(rt*2+1, self.lazy[rt])\n        self.lazy[rt] = self.initlazy\n\n    def set(self, idx, val):\n        idx += self.size\n        for i in range(self.height, 0, -1):\n            self.pushdown(idx >> i)\n        self.tree[idx] = val\n        for i in range(1, self.height + 1):\n            self.pushup(idx >> i)\n\n    def update(self, left, right, val):\n        if left > right: return\n        left += self.size\n        right += self.size\n\n        for i in range(self.height, 0, -1):\n            if left >> i << i != left:\n                self.pushdown(left >> i)\n            if (right+1) >> i << i != right+1:\n                self.pushdown(right >> i)\n\n        l, r = left, right\n        while left <= right:\n            if left & 1:\n                self.modify(left, val)\n                left += 1\n            if not right & 1:\n                self.modify(right, val)\n                right -= 1\n            left >>= 1\n            right >>= 1\n\n        left, right = l, r\n        for i in range(1, self.height + 1):\n            if left >> i << i != left:\n                self.pushup(left >> i)\n            if (right+1) >> i << i != right+1:\n                self.pushup(right >> i)\n\n    def modify(self, rt, val):\n        self.tree[rt] = self.apply(val, self.tree[rt])\n        if rt < self.size:\n            self.lazy[rt] = self.compose(val, self.lazy[rt])\n\n    def get(self, idx):\n        idx += self.size\n        for i in range(self.height, 0, -1):\n            self.pushdown(idx >> i)\n        return self.tree[idx]\n\n    def query(self, left, right):\n        if left > right: return self.initval\n        left += self.size\n        right += self.size\n\n        for i in range(self.height, 0, -1):\n            if left >> i << i != left:\n                self.pushdown(left >> i)\n            if (right+1) >> i << i != right+1:\n                self.pushdown(right >> i)\n\n        lres, rres = self.initval, self.initval\n        while left <= right:\n            if left & 1:\n                lres = self.op(lres, self.tree[left])\n                left += 1\n            if not right & 1:\n                rres = self.op(self.tree[right], rres)\n                right -= 1\n            left >>= 1\n            right >>= 1\n\n        return self.op(lres, rres)\n\n    def all(self):\n        return self.tree[1]\n\nop = int.__add__\napply = lambda lz, node: lz\ncompose = lambda lz1, lz2: lz1\n    \nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        nums = [1] * (n-1)\n        seg = LazySegmentTree(nums, 0, 1, op, apply, compose)\n        ans = []\n        for a, b in queries:\n            seg.update(a+1, b-1, 0)\n            ans.append(seg.all())\n        return ans",
    "submit_ts": "1722740693",
    "subm_id": "552333092"
}