{
    "username": "kavascgjmd39",
    "submission": "const double eps = 1e-6;\n#define ll long long\ntypedef long double ld;\n// #define pb push_back // for vector\n#define pi pair \n// #define mp make_pair\n#define all(a) a.begin(), a.end()\n#define rep(i, a, b) for (ll i = a; i < b; i++)\n#define ff first\n#define ss second\n#define vt vector\n#define vi vt<ll>\n#define ub upper_bound\n#define lb lower_bound\n#define repr(i, n, a) for (ll i = n; i >= a; i--)\n#define dq deque\n#define inset(a, st) st.find(a) != st.end()\n#define issub(a, b) b.find(a) != string::npos // check if a is substr of b\n#define len(a) (ll)a.size()\nconst ld PI = 2 * acos(0.0);\nconst ll mod2 = 1e9 + 7;\nconst ll nax = 2e5 + 5;\nconst ll mod = 1e9+7;\nclass Pair {\npublic:\n    ll lr, lnr, lrp, lprp;\n    Pair(ll lr, ll lnr, ll lrp, ll lprp) {\n        this->lr = lr;\n        this->lnr = lnr;\n        this->lrp = lrp;\n        this->lprp = lprp;\n    }\n    Pair() : lr(0), lnr(0), lrp(0), lprp(0) {}\n};\n\nvector<Pair> seg;\nvector<ll> a;\n\nPair merge(Pair val1, Pair val2) {\n   \n    Pair res;\n    res.lr = max(val1.lr + val2.lnr, val1.lrp + val2.lr);\n    res.lnr = max(val1.lnr + val2.lnr, val1.lprp + val2.lr);\n    res.lrp = max(val1.lrp + val2.lrp, val1.lr + val2.lprp);\n    res.lprp =  max(val1.lnr + val2.lprp, val1.lprp + val2.lrp);\n    return res;\n    \n}\n\nPair build(ll l, ll r, ll i) {\n    if (l == r) {\n        return seg[i] = Pair(a[l], 0, 0, 0);\n    }\n    ll mid = l + (r - l) / 2;\n    Pair val1 = build(l, mid, 2 * i);\n    Pair val2 = build(mid + 1, r, 2 * i + 1);\n    return seg[i] = merge(val1, val2);\n}\n\nvoid update(ll l, ll r, ll i, ll k, ll val) {\n    if (l == r && l == k) {\n        seg[i] = Pair(val, 0, 0, 0);\n        return;\n    }\n    if (l > k || r < k) {\n        return;\n    }\n    ll mid = l + (r - l) / 2;\n    update(l, mid, 2 * i, k, val);\n    update(mid + 1, r, 2 * i + 1, k, val);\n    seg[i] = merge(seg[2 * i], seg[2 * i + 1]);\n}\n\nPair query(ll l, ll r, ll i, ll a, ll b) {\n    if (l >= a && r <= b) {\n        return seg[i];\n    }\n    if (l > b || r < a) {\n        return Pair(0, 0, 0, 0); // neutral element for max\n    }\n    ll mid = l + (r - l) / 2;\n    Pair val1 = query(l, mid, 2 * i, a, b);\n    Pair val2 = query(mid + 1, r, 2 * i + 1, a, b);\n    return merge(val1, val2);\n}\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        a.resize(n);\n        rep(i , 0 , nums.size()){\n          a[i] = nums[i];\n        }\n        seg.resize(nums.size() * 4);\n        build(0, n - 1, 1);\n        ll ans = 0;\n        int res = 0;\n        for (auto& q : queries) {\n            \n                int index = q[0];\n                int value = q[1];\n                update(0, n - 1, 1, index, value);\n                int l = 0;\n                int r = n-1;\n                Pair result = query(0, n - 1, 1, l, r);\n                res = max({result.lr, result.lnr, result.lrp, result.lprp});\n               cout << res <<\" \";\n               ans += res % mod;\n            ans %= mod;\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": 1716695045.0
}