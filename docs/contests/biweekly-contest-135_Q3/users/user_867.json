{
    "username": "51_KING",
    "submission": "\n#define ll long long\n\nclass SegmentTree {\npublic:\n    SegmentTree(const vector<int>& nums) : nums(nums) {\n        n = nums.size();\n        tree.resize(4 * n, 0);\n        build(0, 0, n - 1);\n     }\n\n    void update(int index, int value) {\n        update(0, 0, n - 1, index,value);\n    }\n\n    int query(int l, int r) {\n        return query(0, 0, n - 1, l, r);\n    }\n\nprivate:\n    vector<int> nums;\n    vector<int> tree;\n    int n;\n\n    void build(int node, int start, int end) {\n        if (start == end) {\n            tree[node] = 0;\n        } else {\n            int mid = (start + end) / 2;\n            build(2 * node + 1, start, mid);\n            build(2 * node + 2, mid + 1, end);\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n            if(mid+2<=end && nums[mid] < nums[mid+1] && nums[mid+1] > nums[mid+2]) tree[node]+=1;\n            if(mid-1>=start && mid+1 <= end && nums[mid-1]<nums[mid] && nums[mid] > nums[mid+1]) tree[node]+=1;\n        }\n    }\n\n    void update(int node, int start, int end, int idx,int value) {\n        if (start == end) {\n            if(start==idx){\n                nums[idx] = value;\n            }\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid) {\n                update(2 * node + 1, start, mid, idx,value);\n            } else {\n                update(2 * node + 2, mid + 1, end, idx,value);\n            }\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n            if(mid+2<=end && nums[mid] < nums[mid+1] && nums[mid+1] > nums[mid+2]) tree[node]+=1;\n            if(mid-1>=start && mid+1<=end && nums[mid-1]<nums[mid] && nums[mid] > nums[mid+1]) tree[node]+=1;\n        }\n    }\n\n    int query(int node, int start, int end, int l, int r) {\n        if (r < start || end < l) {\n            return 0;\n        }\n        if (l <= start && end <= r) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int left = query(2 * node + 1, start, mid, l, r);\n        int right = query(2 * node + 2, mid + 1, end, l, r);\n        int ans = 0;\n        if(mid+2<=end && mid+2<=r && mid>=l && nums[mid] < nums[mid+1] && nums[mid+1] > nums[mid+2]) ans+=1;\n        \n        if(mid-1>=start && mid+1<=end && mid-1>=l && mid+1<=r && nums[mid-1]<nums[mid] && nums[mid] > nums[mid+1]) ans+=1;\n\n        return left + right + ans;\n    }\n};\n\nclass Solution {\npublic:\n    int evaluateDifference(int targetDifference, int threshold, vector<int> &values) {\n        int modifications = 0;\n        int length = values.size();\n        \n        for(int i = 0; i < length / 2; ++i) {\n            if (abs(values[i] - values[length - i - 1]) == targetDifference) continue;\n            \n            int larger = max(values[i], values[length - i - 1]);\n            int smaller = min(values[i], values[length - i - 1]);\n            \n            int adjustedUp = smaller + targetDifference;\n            int adjustedDown = larger - targetDifference;\n            \n            if (adjustedUp <= threshold || adjustedDown >= 0) \n                modifications += 1;\n            else \n                modifications += 2;\n        }\n        return modifications;\n    }\n    int solve(vector<int>& values, int threshold){\n          map<int, int> differenceCount;\n        int length = values.size();\n        \n        for (int i = 0; i < length / 2; ++i) {\n            differenceCount[abs(values[i] - values[length - i - 1])] += 1;\n        }\n\n        vector<pair<int, int>> sortedDifferences;\n        for (auto &entry : differenceCount) {\n            sortedDifferences.push_back({entry.second, entry.first});\n        }\n        \n        sort(sortedDifferences.begin(), sortedDifferences.end(), [&](auto &a, auto &b) {\n            if (a.first > b.first) return true;\n            else if (a.first == b.first) return a.second < b.second;\n            return false;\n        });\n\n        int minModifications = length;\n        for (int i = 0; i < min(100, (int)sortedDifferences.size()); ++i) {\n            minModifications = min(minModifications, evaluateDifference(sortedDifferences[i].second, threshold, values));\n        }\n\n        return minModifications;\n    }\n    int minChanges(vector<int>& nums, int k) {\n       return solve(nums,k);\n    }\n};",
    "submit_ts": "1721488685",
    "subm_id": "1327430020"
}