{
    "username": "sepehry",
    "submission": "\nimport math\n\n\nclass SegmentTree:\n    def __init__(self, combine_op, default_val, arr=None, n: int = None):\n        \"\"\"\n        :param combine_op: associative operation op(a, op(b, c)) = op(op(a, b), c) (e.g., operator.add, operator.xor, min, max)\n        :param default_val: value for heap indices with no corresponding index in arr due to heap length being 2^k\n        :param arr: array of data, it will trigger _initialize_heap()\n        :param n: length of the original arr if it is not provided\n        \"\"\"\n        if n is None:\n            assert (arr is not None)\n            n = len(arr)\n        else:\n            assert (arr is None)\n        self.heap = [default_val] * self._calculate_heap_size(n)\n        self._combine = combine_op\n        if arr is not None:\n            self._initialize_heap(arr)\n\n    def __getitem__(self, i):\n        return self.heap[self._heap_index(i)]\n\n    def __setitem__(self, i: int, x):\n        self.update(i, x)\n\n    def _initialize_heap(self, arr):\n        node0 = self._heap_index(0)\n        self.heap[node0:node0 + len(arr)] = arr\n        while node0:\n            node0 = self._parent(node0)\n            for node in range(node0, self._left(node0)):\n                self.heap[node] = self._combine_children(node)\n\n    def update(self, i: int, x):\n        \"\"\"arr[i] = x\"\"\"\n        node = self._heap_index(i)\n        self.heap[node] = x\n        while node:\n            node = self._parent(node)\n            self.heap[node] = self._combine_children(node)\n\n    def query(self, i: int, j: int):\n        \"\"\"Returns combine_op(arr[i:j+1]) (arr[j] INCLUDED!)\"\"\"\n        node1, node2 = self._heap_index(i), self._heap_index(j)\n        if node1 == node2:\n            return self.heap[node1]\n        result1 = self.heap[node1]\n        result2 = self.heap[node2]\n        # We must ensure first arg of self._combine are nodes on the left of the second arg\n        # as our only assumption is associativity (i.e., op(a, op(b, c)) = op(op(a, b), c))\n        # if we don't respect it, then we also need commutativity (i.e., op(a, b) = op(b, a)).\n        while (parent1 := self._parent(node1)) != (parent2 := self._parent(node2)):\n            if self._is_left(node1):\n                result1 = self._combine(result1, self.heap[self._sibling(node1)])\n            if self._is_right(node2):\n                result2 = self._combine(self.heap[self._sibling(node2)], result2)\n            node1 = parent1\n            node2 = parent2\n        return self._combine(result1, result2)\n\n    def query_all(self):\n        return self.heap[0]\n\n    def _combine_children(self, parent):\n        return self._combine(self.heap[self._left(parent)], self.heap[self._right(parent)])\n\n    def _parent(self, node: int) -> int:\n        return (node - 1) >> 1\n\n    def _left(self, node: int) -> int:\n        return 1 + (node << 1)\n\n    def _right(self, node: int) -> int:\n        return 2 + (node << 1)\n\n    def _sibling(self, node: int) -> int:\n        return node + ((node & 1) << 1) - 1\n\n    def _is_left(self, node: int) -> bool:\n        return (node & 1) == 1\n\n    def _is_right(self, node: int) -> bool:\n        return (node & 1) == 0\n\n    def _heap_index(self, node: int) -> int:\n        return self._parent(len(self.heap)) + node\n\n    def _calculate_heap_size(self, arr_size: int):\n        return (1 << (1 + int(math.ceil(math.log2(arr_size))))) - 1\n\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n\n        def combine(lll, rrr):\n            li, lj, lc = lll\n            ri, rj, rc = rrr\n            if ri == -1 or rj == -1:\n                return lll\n            # assert (lj + 1 == ri)\n            c = lc + rc\n            if (ri + 1) < n and (ri + 1) <= rj and nums[ri] > nums[ri + 1] and nums[ri] > nums[ri - 1]:\n                c += 1\n            elif (lj - 1) >= 0 and (lj - 1) >= li and nums[lj] > nums[lj - 1] and nums[lj] > nums[lj + 1]:\n                c += 1\n\n            return li, rj, c\n\n        aaa = [(i, i, 0) for i in range(n)]\n        st = SegmentTree(combine, (-1, -1, -1), aaa)\n        sol = []\n        for qqq in queries:\n            if qqq[0] == 1:\n                _, l, r = qqq\n                _, _, c = st.query(l, r)\n                sol.append(c)\n            else:\n                _, i, v = qqq\n                nums[i] = v\n                st.update(i, (i, i, 0))\n        return sol\n",
    "submit_ts": 1718507268.0
}