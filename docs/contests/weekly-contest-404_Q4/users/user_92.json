{
    "username": "DoubleLei",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def bfs_farthest_node(start, tree):\n            n = len(tree)\n            visited = [False] * n\n            queue = deque([(start, 0)])\n            visited[start] = True\n            farthest_node = start\n            max_distance = 0\n\n            while queue:\n                node, distance = queue.popleft()\n                if distance > max_distance:\n                    max_distance = distance\n                    farthest_node = node\n                for neighbor in tree[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append((neighbor, distance + 1))\n\n            return farthest_node, max_distance\n\n        def tree_diameter(tree):\n            start = 0\n            farthest_node, _ = bfs_farthest_node(start, tree)\n            farthest_node, diameter = bfs_farthest_node(farthest_node, tree)\n            return diameter\n\n        def build_tree(edges, n):\n            tree = [[] for _ in range(n)]\n            for u, v in edges:\n                tree[u].append(v)\n                tree[v].append(u)\n            return tree\n\n        def minimum_diameter(edges1, edges2):\n            n, m = len(edges1) + 1, len(edges2) + 1\n            tree1 = build_tree(edges1, n)\n            tree2 = build_tree(edges2, m)\n\n            diameter1 = tree_diameter(tree1)\n            diameter2 = tree_diameter(tree2)\n            # print(diameter1, diameter2)\n            min_possible_diameter = max(diameter1, diameter2, (diameter1 + 1) // 2 + (diameter2 + 1) // 2 + 1)\n\n            return min_possible_diameter\n        return minimum_diameter(edges1, edges2)",
    "submit_ts": "1719717276",
    "subm_id": "1304387276"
}