{
    "username": "Wibo",
    "submission": "class Solution {\npublic:\n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        if (n == 2) return {1, 2};\n\n        vector<vector<int>> adjl(n);\n        for (int i=0; i+1<n; i++) {\n            int u = edges[i][0], v = edges[i][1];\n            adjl[u].push_back(v);\n            adjl[v].push_back(u);\n        }\n\n        int root;\n        for (int i=0; i<n; i++) {\n            if (adjl[i].size() > 1) root = i;\n        }\n\n        auto f = [](int u) -> int {\n            return (u&1) ? 1 : 2;\n        };\n        \n        const int magic = 5;\n        vector<vector<multiset<int>>> dp(n, vector<multiset<int>>(2));\n        auto update = [&](int u, int v, int d) -> void {\n            for (int i=0; i<2; i++) {\n                if (!dp[v][i].empty()) {\n                    auto it = dp[v][i].rbegin();\n                    int cost = *it + f(u);\n                    if (d > 0) {\n                        dp[u][i].insert(cost);\n                        if (dp[u][i].size() > magic) dp[u][i].erase(dp[u][i].begin());\n                    } else {\n                        auto it = dp[u][i].find(cost);\n                        if (it != dp[u][i].end()) dp[u][i].erase(it);\n                    }\n                }\n            }\n        };\n        auto dfs1 = [&](auto &self, int u, int p) -> void {\n            if (adjl[u].size() == 1 && p != -1) dp[u][u&1].insert(0);\n            // dp[u][u&1][0]++;\n            for (int v : adjl[u]) {\n                if (v == p) continue;\n                self(self, v, u);\n                update(u, v, 1);\n            }\n        };\n        dfs1(dfs1, root, -1);\n\n        vector<int> ans(n);\n        auto dfs2 = [&](auto &self, int u, int p) -> void {\n            // cout << \"root: \" << u << '\\n';\n            // for (int i=0; i<n; i++) {\n            //     cout << i << \": \";\n            //     for (int j=0; j<2; j++) {\n            //         for (auto &[x, c] : dp[i][j]) {\n            //             cout << '(' << j << ',' << x << ',' << c << ')';\n            //         }\n            //     }\n            //     cout << '\\n';\n            // }\n\n            ans[u] = max(\n                (dp[u][0].empty() ? 0 : *dp[u][0].rbegin() + 2),\n                (dp[u][1].empty() ? 0 : *dp[u][1].rbegin() + 1)\n            ) - f(u);\n            for (int v : adjl[u]) {\n                if (v == p) continue;\n                update(u, v, -1);\n                update(v, u, 1);\n                self(self, v, u);\n                update(v, u, -1);\n                update(u, v, 1);\n            }\n        };\n        dfs2(dfs2, root, -1);\n\n        return ans;\n    }\n};",
    "submit_ts": "1722699072",
    "subm_id": "1343200652"
}