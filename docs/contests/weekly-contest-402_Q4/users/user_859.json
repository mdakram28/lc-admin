{
    "username": "stormsunshine",
    "submission": "class Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        List<Integer> counts = new ArrayList<Integer>();\n        int length = nums.length;\n        int[] peaks = new int[length];\n        for (int i = 1; i < length - 1; i++) {\n            peaks[i] = isPeak(nums, i) ? 1 : 0;\n        }\n        SegmentTree st = new SegmentTree(peaks);\n        for (int[] query : queries) {\n            if (query[0] == 1) {\n                int start = query[1], end = query[2];\n                int currCount = st.getSum(start, end) - peaks[start];\n                if (start < end) {\n                    currCount -= peaks[end];\n                }\n                counts.add(currCount);\n            } else {\n                int index = query[1], val = query[2];\n                nums[index] = val;\n                int minIndex = Math.max(index - 1, 0), maxIndex = Math.min(index + 1, length - 1);\n                for (int i = minIndex; i <= maxIndex; i++) {\n                    peaks[i] = isPeak(nums, i) ? 1 : 0;\n                    st.update(i, peaks[i]);\n                }\n            }\n        }\n        return counts;\n    }\n\n    public boolean isPeak(int[] nums, int index) {\n        if (index <= 0 || index >= nums.length - 1) {\n            return false;\n        }\n        return nums[index] > nums[index - 1] && nums[index] > nums[index + 1];\n    }\n}\n\nclass SegmentTree {\n    private int n;\n    private int[] tree;\n\n    public SegmentTree(int[] nums) {\n        n = nums.length;\n        tree = new int[n * 4];\n        build(0, n - 1, 0, nums);\n    }\n\n    public int getSum(int start, int end) {\n        return getSum(start, end, 0, 0, n - 1);\n    }\n\n    public void update(int index, int value) {\n        update(index, value, 0, 0, n - 1);\n    }\n\n    private void build(int start, int end, int treeIndex, int[] nums) {\n        if (start == end) {\n            tree[treeIndex] = nums[start];\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        build(start, mid, treeIndex * 2 + 1, nums);\n        build(mid + 1, end, treeIndex * 2 + 2, nums);\n        tree[treeIndex] = tree[treeIndex * 2 + 1] + tree[treeIndex * 2 + 2];\n    }\n\n    private int getSum(int rangeStart, int rangeEnd, int treeIndex, int treeStart, int treeEnd) {\n        if (rangeStart == treeStart && rangeEnd == treeEnd) {\n            return tree[treeIndex];\n        }\n        int mid = treeStart + (treeEnd - treeStart) / 2;\n        if (rangeEnd <= mid) {\n            return getSum(rangeStart, rangeEnd, treeIndex * 2 + 1, treeStart, mid);\n        } else if (rangeStart > mid) {\n            return getSum(rangeStart, rangeEnd, treeIndex * 2 + 2, mid + 1, treeEnd);\n        } else {\n            return getSum(rangeStart, mid, treeIndex * 2 + 1, treeStart, mid) + getSum(mid + 1, rangeEnd, treeIndex * 2 + 2, mid + 1, treeEnd);\n        }\n    }\n\n    private void update(int rangeIndex, int value, int treeIndex, int start, int end) {\n        if (start == end) {\n            tree[treeIndex] = value;\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        if (rangeIndex <= mid) {\n            update(rangeIndex, value, treeIndex * 2 + 1, start, mid);\n        } else {\n            update(rangeIndex, value, treeIndex * 2 + 2, mid + 1, end);\n        }\n        tree[treeIndex] = tree[treeIndex * 2 + 1] + tree[treeIndex * 2 + 2];\n    }\n}",
    "submit_ts": "1718507454",
    "subm_id": "539781454"
}