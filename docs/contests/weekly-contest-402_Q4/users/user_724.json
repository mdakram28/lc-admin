{
    "username": "DestyFog",
    "submission": "class Solution {\n    SegTreeNode root;\n    int[] array;\n    \n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        this.array = new int[nums.length];\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0 && i != array.length - 1 && nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {\n                array[i] = 1;\n            }\n        }\n        this.root = buildSegmentTree(array, 0, nums.length - 1);\n        \n        List<Integer> ans = new ArrayList<>();\n        for (int[] query : queries) {\n            if (query[0] == 1) {\n                if (query[1] >= query[2] - 1) {\n                    ans.add(0);\n                } else {\n                    ans.add(sumRange(query[1] + 1, query[2] - 1));\n                }\n            } else {\n                nums[query[1]] = query[2];\n                for (int i = Math.max(0, query[1] - 1); i <= Math.min(nums.length - 1, query[1] + 1); i++) {\n                    if (i != 0 && i != array.length - 1 && nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {\n                        array[i] = 1;\n                        update(root, i, 1);\n                    } else {\n                        array[i] = 0;\n                        update(root, i, 0);\n                    }\n                }\n            }\n        }\n        \n        return ans;\n    }\n    \n    class SegTreeNode{\n\t\tint start;\n\t\tint end;\n\t\tint sum;\n\t\tSegTreeNode left;\n\t\tSegTreeNode right;\n\t\tSegTreeNode(int start, int end) {\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\t}\n\n\tprivate SegTreeNode buildSegmentTree(int[] nums, int left, int right) {\n\t\tif (left > right) {\n\t\t\treturn null;\n\t\t}\n\t\tSegTreeNode root = new SegTreeNode(left, right);\n\t\t\n\t\tif (left == right) {\n\t\t\troot.sum = nums[left];\n\t\t\treturn root;\n\t\t}\n\t\tint mid = left + (right - left) / 2;\n\t\troot.left = buildSegmentTree(nums, left, mid);\n\t\troot.right = buildSegmentTree(nums, mid + 1, right);\n\t\troot.sum = root.left.sum + root.right.sum;\n\t\treturn root;\n\t}\n\n\tvoid update(int i, int val) {\n\t\tupdate(root, i, val);\n\t}\n\tprivate void update(SegTreeNode root, int idx, int val) {\n\t\tif (root == null || root.start > idx || root.end < idx) {\n\t\t\treturn;\n\t\t}\n\t\tif (root.start == root.end && root.end == idx) {\n\t\t\troot.sum = val;\n\t\t\treturn;\n\t\t}\n\t\tint mid = root.start + (root.end - root.start) / 2;\n\t\tif (idx <= mid) {\n\t\t\troot.sum -= root.left.sum;\n\t\t\tupdate(root.left, idx, val);\n\t\t\troot.sum += root.left.sum;\n\t\t} else {\n\t\t\troot.sum -= root.right.sum;\n\t\t\tupdate(root.right, idx, val);\n\t\t\troot.sum += root.right.sum;\n\t\t}\n\t}\n\n\tpublic int sumRange(int i, int j) {\n\t\treturn sumRange(root, i, j);\n\t}\n\n\tprivate int sumRange(SegTreeNode root, int left, int right) {\n\t\tif (root == null || root.end < left || root.start > right || left > right) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (left <= root.start  && right >= root.end) {\n\t\t\treturn root.sum;\n\t\t}\n\t\tint mid = root.start + (root.end - root.start) / 2;\n\t\treturn sumRange(root.left, left, Math.min(mid, right)) + sumRange(root.right, Math.max(left, mid + 1), right);\n\t}\n}\n\n// class Solution {\n//     public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n//         List<Integer> ans = new ArrayList<>();\n//         for (int[] query : queries) {\n//             if (query[0] == 1) {\n//                 ans.add(count(nums, query[1], query[2]));\n//             } else {\n//                 nums[query[1]] = query[2];\n//             }\n//         }\n        \n//         return ans;\n//     }\n    \n//     int count(int[] nums, int left, int right) {\n//         int count = 0;\n//         for (int i = left; i <= right; i++) {\n//             if (i != left && i != right && nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {\n//                 count++;\n//             }\n//         }\n        \n//         return count;\n//     }\n// }",
    "submit_ts": 1718508023.0
}