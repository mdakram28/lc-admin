{
    "username": "romitdas76",
    "submission": "class ST {\n\tvector<int> seg, lazy; \npublic: \n\tST(int n) {\n\t\tseg.resize(4 * n+1); \n\t\tlazy.resize(4 * n+1); \n\t}\npublic: \n\tvoid build(int ind, int low, int high, vector<int> &arr) {\n\t\tif(low == high) {\n\t\t\tseg[ind] = arr[low];\n\t\t\treturn; \n\t\t}\n\t\tint mid = (low + high) >> 1; \n\t\tbuild(2*ind+1, low, mid, arr); \n\t\tbuild(2*ind+2, mid+1, high, arr); \n\t\tseg[ind] = seg[2*ind+1] + seg[2*ind+2];\n\t}\npublic:\n\tvoid update(int ind, int low, int high, int l, int r, \n\t\tint val) {\n\t\t// update the previous remaining updates \n\t\t// and propogate downwards \n\t\tif(lazy[ind] != 0) {\n\t\t\tseg[ind] += (high - low + 1) * lazy[ind]; \n            seg[ind] =max(seg[ind],0);\n\t\t\t// propogate the lazy update downwards\n\t\t\t// for the remaining nodes to get updated \n\t\t\tif(low != high) {\n\t\t\t\tlazy[2*ind+1] += lazy[ind]; \n\t\t\t\tlazy[2*ind+2] += lazy[ind]; \n\t\t\t}\n \n\t\t\tlazy[ind] = 0; \n\t\t}\n \n\t\t// no overlap \n\t\t// we don't do anything and return \n\t\t// low high l r or l r low high \n\t\tif(high < l or r < low) {\n\t\t\treturn; \n\t\t}\n \n\t\t// complete overlap \n\t\t// l low high r \n\t\tif(low>=l && high <= r) {\n\t\t\tseg[ind] += (high - low + 1) * val; \n            seg[ind] =max(seg[ind],0);\n\t\t\t// if a leaf node, it will have childrens\n\t\t\tif(low != high) {\n\t\t\t\tlazy[2*ind+1] += val; \n\t\t\t\tlazy[2*ind+2] += val; \n\t\t\t}\n\t\t\treturn; \n\t\t}\n\t\t// last case has to be no overlap case\n\t\tint mid = (low + high) >> 1; \n\t\tupdate(2*ind+1, low, mid, l, r, val);\n\t\tupdate(2*ind+2, mid+1, high, l, r, val); \n\t\tseg[ind] = seg[2*ind+1] + seg[2*ind+2]; \n\t}\npublic: \n\tint query(int ind, int low, int high, int l, int r) {\n \n\t\t// update if any updates are remaining \n\t\t// as the node will stay fresh and updated \n\t\tif(lazy[ind] != 0) {\n\t\t\tseg[ind] += (high - low + 1) * lazy[ind]; \n            seg[ind] =max(seg[ind],0);\n\t\t\t// propogate the lazy update downwards\n\t\t\t// for the remaining nodes to get updated \n\t\t\tif(low != high) {\n\t\t\t\tlazy[2*ind+1] += lazy[ind]; \n\t\t\t\tlazy[2*ind+2] += lazy[ind]; \n\t\t\t}\n \n\t\t\tlazy[ind] = 0; \n\t\t}\n \n\t\t// no overlap return 0; \n\t\tif(high < l or r < low) {\n\t\t\treturn 0; \n\t\t}\n \n\t\t// complete overlap \n\t\tif(low>=l && high <= r) return seg[ind]; \n \n\t\tint mid = (low + high) >> 1; \n\t\tint left = query(2*ind+1, low, mid, l, r);\n\t\tint right = query(2*ind+2, mid+1, high, l, r);\n\t\treturn left + right; \n\t}\n};\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& q) {\n        // int arr[n];\n         vector<int> ans;\n        vector<int>arr(n-1,1);\n        // arr[n-2]=0;\n        ST st(n+1);\n        st.build(0,0,n-2,arr);\n        // cout<<st.query(0,0,n-2,0,n-2);\n        for(auto i:q){\n            int l=i[0];\n            int r=i[1];\n            \n            st.update(0,0,n-2,l+1,r-1,-1);\n            \n            ans.push_back(st.query(0,0,n-2,0,n-2));\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": "1722742334",
    "subm_id": "1343766527"
}