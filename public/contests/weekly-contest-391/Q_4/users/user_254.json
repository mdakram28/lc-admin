{
    "username": "louisfghbvc",
    "submission": "class Solution {\npublic:\n    int minimumDistance(vector<vector<int>>& points) {\n        // goal: find the minimum distance move exactly one point\n        // idea:\n        // enumerate the point\n        // sort the point by x\n        \n        // [[3,10],[5,15],[10,2],[4,4]], ans=12\n        // [3,10],[4,4],[5,15],[10,2]\n        // D = |xi-xj| + |yi-yj|\n        // => (xi-xj) + (yi-yj) => (xi+yi) - (xj+yj)\n        // => -(xi-xj) + (yi-yj) => -(xi-yi) + (xj-yj)\n        // => (xi-xj) + -(yi-yj) => (xi-yi) - (xj-yj)\n        // => -(xi-xj) + -(yi-yj) => -(xi+yi) + (xj+yj)\n        \n        // only need to consider (xi-yi), (xi+yi)\n        // idea: maintain a multiset\n        \n        multiset<int> dif1, dif2;\n        for (auto &p : points) {\n            dif1.insert(p[0]-p[1]);\n            dif2.insert(p[0]+p[1]);\n        }\n        \n        int ans = INT_MAX;\n        for (auto &p: points) {\n            dif1.erase(dif1.find(p[0]-p[1]));\n            dif2.erase(dif2.find(p[0]+p[1]));\n            ans = min(ans, max(*dif1.rbegin()-*dif1.begin(), *dif2.rbegin()-*dif2.begin()));\n            dif1.insert(p[0]-p[1]);\n            dif2.insert(p[0]+p[1]);\n        }\n        \n        return ans;\n    }\n};"
}