{
    "username": "MvKaio",
    "submission": "using ll = long long;\nvector<vector<int>> C;\n\nbool touch(int i, int j) {\n    auto &v = C[i];\n    auto &w = C[j];\n    return (ll(v[0] - w[0]) * (v[0] - w[0]) +\n        ll(v[1] - w[1]) * (v[1] - w[1]) <= ll(v[2] + w[2]) * (v[2] + w[2]));\n}\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        C = circles;\n        int n = circles.size();\n        //vector<int> id(n);\n        //vector<int> sz(n, 1);\n        //iota(id.begin(), id.end(), 0);\n        vector<int> borders(n);\n        \n        for (int i = 0; i < n; i++) {\n            auto v = circles[i];\n            ll x = v[0];\n            ll y = v[1];\n            ll r = v[2];\n            if (x + r >= X) borders[i] |= 1;\n            if (x - r <= 0) borders[i] |= 2;\n            if (y + r >= Y) borders[i] |= 4;\n            if (y - r <= 0) borders[i] |= 8;\n        }\n        \n        //function<int(int)> find = [&] (int x) {\n        //    return id[x] == x ? x : id[x] = find(id[x]);\n        //};\n        //\n        //auto unite = [&] (int i, int j) {\n        //    i = find(i);\n        //    j = find(j);\n        //    if (i == j) return;\n        //    if (sz[i] > sz[j]) swap(i, j);\n        //    id[i] = j;\n        //    sz[j] += sz[i];\n        //    borders[j] |= borders[i];\n        //};\n        \n        queue<int> q;\n        vector<int> vis(n, false);\n        for (int i = 0; i < n; i++) if (!vis[i]) {\n            vis[i] = true;\n            q.push(i);\n            while (q.size()) {\n                int v = q.front();\n                q.pop();\n                for (int u = 0; u < n; u++) if (touch(u, v)) {\n                    if (!vis[u]) {\n                        vis[u] = true;\n                        borders[i] |= borders[u];\n                        q.push(u);\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if ((borders[i] >> 1 & 1) && (borders[i] >> 3 & 1)) return false;\n            if ((borders[i] >> 0 & 1) && (borders[i] >> 2 & 1)) return false;\n            if ((borders[i] >> 0 & 1) && (borders[i] >> 1 & 1)) return false;\n            if ((borders[i] >> 2 & 1) && (borders[i] >> 3 & 1)) return false;\n        }\n\n        return true;\n    }\n};",
    "submit_ts": "1722136067",
    "subm_id": "1335722715"
}