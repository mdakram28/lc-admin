{
    "username": "user0290vr",
    "submission": "import java.util.*;\n\nclass Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int n = edges1.length + 1;\n        int m = edges2.length + 1;\n\n        List<List<Integer>> tree1 = buildTree(n, edges1);\n        List<List<Integer>> tree2 = buildTree(m, edges2);\n\n        int diameter1 = getDiameter(tree1, n);\n        int diameter2 = getDiameter(tree2, m);\n\n        int newDiameter = Math.max(diameter1, Math.max(diameter2, (diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1));\n\n        return newDiameter;\n    }\n\n    private List<List<Integer>> buildTree(int size, int[][] edges) {\n        List<List<Integer>> tree = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            tree.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            tree.get(edge[0]).add(edge[1]);\n            tree.get(edge[1]).add(edge[0]);\n        }\n        return tree;\n    }\n\n    private int getDiameter(List<List<Integer>> tree, int n) {\n        int[] firstDFS = dfs(tree, 0, -1);\n        int[] secondDFS = dfs(tree, firstDFS[0], -1);\n        return secondDFS[1];\n    }\n\n    private int[] dfs(List<List<Integer>> tree, int node, int parent) {\n        int farthestNode = node;\n        int maxDistance = 0;\n\n        for (int neighbor : tree.get(node)) {\n            if (neighbor == parent) continue;\n            int[] result = dfs(tree, neighbor, node);\n            if (result[1] + 1 > maxDistance) {\n                maxDistance = result[1] + 1;\n                farthestNode = result[0];\n            }\n        }\n\n        return new int[]{farthestNode, maxDistance};\n    }\n}\n",
    "submit_ts": "1719716577",
    "subm_id": "1304368328"
}