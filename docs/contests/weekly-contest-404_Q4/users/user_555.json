{
    "username": "andy-lc",
    "submission": "import kotlin.math.max\nclass Solution {\n    private fun makeGraph(edges: Array<IntArray>): Array<ArrayList<Int>> {\n        val graph = Array<ArrayList<Int>>(edges.size + 1) { ArrayList() }\n        for (arr in edges) {\n            graph[arr[0]].add(arr[1])\n            graph[arr[1]].add(arr[0])\n        }\n        return graph\n    }\n\n    private fun maxDepthDfs(graph: Array<ArrayList<Int>>, p: Int, i: Int, depth: IntArray): Int {\n        graph[i].remove(p)\n        depth[i] = 1\n        for (j in graph[i]) {\n            if (j != p) {\n                depth[i] = max(depth[i], maxDepthDfs(graph, i, j, depth) + 1)\n            }\n        }\n        return depth[i]\n    }\n\n    private fun maxRootDepthDfs(\n        graph: Array<ArrayList<Int>>, p: Int, i: Int, depth: IntArray, parentDepth: Int, rootDepth: IntArray\n    ) {\n        rootDepth[i] = max(parentDepth + 1, depth[i])\n        if (graph[i].size == 0) {\n            return\n        }\n        val childDepthLeft = IntArray(graph[i].size)\n        val childDepthRigh = IntArray(graph[i].size)\n        childDepthLeft[0] = depth[graph[i][0]]\n        childDepthRigh[graph[i].size - 1] = depth[graph[i][graph[i].size - 1]]\n        for (j in 1..<graph[i].size) {\n            childDepthLeft[j] = max(childDepthLeft[j - 1], depth[graph[i][j]])\n        }\n        for (j in (0..<graph[i].size - 1).reversed()) {\n            childDepthRigh[j] = max(childDepthRigh[j + 1], depth[graph[i][j]])\n        }\n        for (j in graph[i].indices) {\n            val pd = max(\n                max(\n                    if (j - 1 >= 0) childDepthLeft[j - 1] else 0,\n                    if (j + 1 < graph[i].size) childDepthRigh[j + 1] else 0\n                ), parentDepth\n            ) + 1\n            maxRootDepthDfs(graph, i, graph[i][j], depth, pd, rootDepth)\n        }\n    }\n\n    fun rootDepth(graph: Array<ArrayList<Int>>): IntArray {\n        val depth = IntArray(graph.size)\n        maxDepthDfs(graph, -1, 0, depth)\n        val rootDepth = IntArray(graph.size)\n        maxRootDepthDfs(graph, -1, 0, depth, 0, rootDepth)\n        return rootDepth\n    }\n\n    fun argmin(arr: IntArray): Int {\n        var k = 0\n        for (i in arr.indices) {\n            if (arr[i] < arr[k]) {\n                k = i\n            }\n        }\n        return k\n    }\n\n    fun diameter(graph: Array<ArrayList<Int>>, p: Int, i: Int, depth: IntArray, parentDepth: Int): Int {\n        if (graph[i].size == 0) {\n            return parentDepth + 1\n        }\n        val childDepthLeft = IntArray(graph[i].size)\n        val childDepthRigh = IntArray(graph[i].size)\n        childDepthLeft[0] = depth[graph[i][0]]\n        childDepthRigh[graph[i].size - 1] = depth[graph[i][graph[i].size - 1]]\n        for (j in 1..<graph[i].size) {\n            childDepthLeft[j] = max(childDepthLeft[j - 1], depth[graph[i][j]])\n        }\n        for (j in (0..<graph[i].size - 1).reversed()) {\n            childDepthRigh[j] = max(childDepthRigh[j + 1], depth[graph[i][j]])\n        }\n        var last = parentDepth\n        var diam = 0\n        for (j in graph[i].indices) {\n            diam = max(diam, last + 1 + depth[graph[i][j]])\n            last = max(last, depth[graph[i][j]])\n            val pd = max(\n                max(\n                    if (j - 1 >= 0) childDepthLeft[j - 1] else 0,\n                    if (j + 1 < graph[i].size) childDepthRigh[j + 1] else 0\n                ), parentDepth\n            ) + 1\n            diam = max(diam, diameter(graph, i, graph[i][j], depth, pd))\n        }\n        return diam\n    }\n\n    fun minimumDiameterAfterMerge(edges1: Array<IntArray>, edges2: Array<IntArray>): Int {\n        val graph1 = makeGraph(edges1)\n        val graph2 = makeGraph(edges2)\n        val rootDepth1 = rootDepth(graph1)\n        val rootDepth2 = rootDepth(graph2)\n        val point1 = argmin(rootDepth1)\n        val point2 = argmin(rootDepth2)\n        val edges3 = Array<IntArray>(edges1.size + edges2.size + 1) {\n            if (it < edges1.size) {\n                edges1[it].copyOf()\n            } else if (it < edges1.size + edges2.size) {\n                edges2[it - edges1.size].map { x -> x + edges1.size + 1 }.toIntArray()\n            } else {\n                IntArray(2) { i -> if (i == 0) point1 else point2 + edges1.size + 1 }\n            }\n        }\n        val graph3 = makeGraph(edges3)\n        val depth = IntArray(graph3.size)\n        maxDepthDfs(graph3, -1, 0, depth)\n        return diameter(graph3, -1, 0, depth, 0) -1\n    }\n}",
    "submit_ts": 1719719103.0
}