{
    "username": "Ethan-ZYF",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...)\n#endif\ntemplate <class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\n\ntemplate <i64 P>\nstruct MLong {\n    i64 x;\n\n    constexpr MLong() : x{} {}\n\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n\n    static i64 Mod;\n\n    constexpr static i64 getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n\n    constexpr static void setMod(i64 Mod_) {\n        Mod = Mod_;\n    }\n\n    constexpr i64 norm(i64 x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n\n    constexpr i64 val() const {\n        return x;\n    }\n\n    explicit constexpr operator i64() const {\n        return x;\n    }\n\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n\n    constexpr MLong& operator*=(MLong rhs) & {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n\n    constexpr MLong& operator+=(MLong rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n\n    constexpr MLong& operator-=(MLong rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n\n    constexpr MLong& operator/=(MLong rhs) & {\n        return *this *= rhs.inv();\n    }\n\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n\n    friend constexpr std::istream& operator>>(std::istream& is, MLong& a) {\n        i64 v;\n        is >> v;\n        a = MLong(v);\n        return is;\n    }\n\n    friend constexpr std::ostream& operator<<(std::ostream& os, const MLong& a) {\n        return os << a.val();\n    }\n\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate <>\ni64 MLong<0LL>::Mod = 1;\n\ntemplate <int P>\nstruct MInt {\n    int x;\n\n    constexpr MInt() : x{} {}\n\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n\n    static int Mod;\n\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n\n    constexpr int val() const {\n        return x;\n    }\n\n    explicit constexpr operator int() const {\n        return x;\n    }\n\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n\n    constexpr MInt& operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n\n    constexpr MInt& operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n\n    constexpr MInt& operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n\n    constexpr MInt& operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n\n    friend constexpr std::istream& operator>>(std::istream& is, MInt& a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n\n    friend constexpr std::ostream& operator<<(std::ostream& os, const MInt& a) {\n        return os << a.val();\n    }\n\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate <>\nint MInt<0>::Mod = 1;\n\ntemplate <int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 1e9 + 7;\nusing Z = MInt<P>;\n\nstring to_string(Z x) {\n    return to_string(x.val());\n}\n\nconstexpr int MX = 1005;\nclass Solution {\n   public:\n    int countOfPairs(vector<int>& nums) {\n        int n = nums.size();\n        vector<Z> dp(MX + 1);\n        dp[0] = 1;\n        for (int i = 0; i < n; i++) {\n            vector<Z> new_dp(MX + 1), ps(MX + 2);\n            for (int j = 0; j <= MX; j++) {\n                ps[j + 1] = ps[j] + dp[j];\n            }\n            for (int y = 0; y <= nums[i]; y++) {\n                int up = min(y, (i == 0 ? 5000 : nums[i - 1]) - nums[i] + y);\n                debug(y, up);\n                new_dp[y] = ps[max(0, up + 1)];\n            }\n\n            dp = new_dp;\n            debug(dp);\n        }\n        Z res = 0;\n        for (int i = 0; i <= MX; i++) {\n            res += dp[i];\n        }\n        return res.val();\n    }\n};",
    "submit_ts": "1723345372",
    "subm_id": "1351554342"
}