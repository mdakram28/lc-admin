{
    "username": "franky50616",
    "submission": "class SegmentTree \n{\nprivate:\n\tvector<int> nodes;\n\tint size = 0;\n\n\tbool overlap(int a, int b, int c, int d)\n\t{\n\t\tif (a <= c && c <= b) return true;\n\t\tif (c <= a && a <= d) return true;\n\t\treturn false;\n\t}\n\n\tvoid maintain(int left, int right, int i)\n\t{\n\t\tnodes[i] = nodes[2*i+1] + nodes[2*i+2];\n\t}\n\n\tvoid build(vector<int>& nums, int left, int right, int i)\n\t{\n\t\tif (left == right)\n\t\t{\n\t\t\tnodes[i] = nums[left];\n\t\t\treturn;\n\t\t}\n\n\t\tint mid = left + (right - left) / 2;\n\t\tbuild(nums, left, mid, 2 * i + 1);\n\t\tbuild(nums, mid+1, right, 2 * i + 2);\n\t\tmaintain(left, right, i);\n\t}\n\npublic:\n\tSegmentTree(vector<int>& nums)\n\t{\n\t\tint n = nums.size();\n\t\tnodes.resize(4 * n, 0);        \n\t\tbuild(nums, 0, n - 1, 0);\n\t}\n\n\tvoid update(int cL, int cR, int pos, int val, int i)\n\t{\n\t\tif (!overlap(cL, cR, pos, pos)) return;\n\t\tif (cL == cR)\n\t\t{\n\t\t\tnodes[i] = val;\n\t\t\treturn;\n\t\t}\n\n\t\tint mid = cL + (cR - cL) / 2;\n\t\tupdate(cL, mid, pos, val, 2 * i + 1);\n\t\tupdate(mid + 1, cR, pos, val, 2 * i + 2);\n\t\tmaintain(cL, cR, i);\n\t}\n\n\tint query(int cL, int cR, int tL, int tR, int i)\n\t{\n        if(tL > tR) return 0;\n\t\tif (!overlap(cL, cR, tL, tR)) return 0;\n\t\tif (tL <= cL && cR <= tR) return nodes[i];\n\n\t\tint mid = cL + (cR - cL) / 2;\n\t\tint resL = query(cL, mid, tL, tR, 2 * i + 1);\n\t\tint resR = query(mid+1, cR, tL, tR, 2 * i + 2);\n\t\treturn resL + resR;\n\t}\n};\n\nclass Solution \n{\nprivate:\n    vector<int> idx;\n    \npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) \n    {\n        int n=nums.size();\n        getPeek(nums);\n        \n        //for(int i : idx) cout<<i<<\" \"; cout<<endl;\n        \n        SegmentTree st(idx);\n        \n        //cout<<\"build done!\"<<endl;\n        \n        vector<int> res;\n        for(auto& q : queries)\n        {\n            if(q[0] == 1)\n            {\n                int l=q[1]+1;\n                int r=q[2]-1;\n                int cnt = st.query(0, n-1, l, r, 0);                \n                res.push_back(cnt);\n            }\n            else\n            {\n                int i=q[1];\n                int v=q[2];\n                change(st, nums, i, v);\n            }\n        }\n        \n        return res;\n    }\n    \n    void change(SegmentTree& st, vector<int>& nums, int i, int val)\n    {\n        if(nums[i] == val) return;\n        \n        nums[i] = val;                \n        \n        updateIdx(st, nums, i);\n        updateIdx(st, nums, i-1);\n        updateIdx(st, nums, i+1);\n    }\n    \n    void updateIdx(SegmentTree& st, vector<int>& nums, int i)\n    {\n        int n=nums.size();\n        if(i < 0 || i >= n) return;        \n        \n        if(isPeek(nums, i) && idx[i] == 0)\n        {\n            idx[i]=1;\n            st.update(0, n-1, i, 1, 0);\n        }\n        else if(!isPeek(nums, i) && idx[i] == 1)\n        {\n            idx[i]=0;\n            st.update(0, n-1, i, 0, 0);\n        }\n    }\n    \n    bool isPeek(vector<int>& nums, int i)\n    {\n        if(i == 0 || i == nums.size()-1) return false;\n        \n        return nums[i-1] < nums[i] && nums[i] > nums[i+1];\n    }\n    \n    void getPeek(vector<int>& nums)\n    {\n        int n=nums.size();\n        idx.resize(n, 0);\n        for(int i=1; i<n-1; ++i)\n        {\n            if(nums[i-1] < nums[i] && nums[i] > nums[i+1]) idx[i] = 1;\n        }\n    }\n};",
    "submit_ts": 1718508445.0
}