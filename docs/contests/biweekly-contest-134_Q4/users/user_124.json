{
    "username": "Kude",
    "submission": "#pragma GCC optimize(\"O2\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define rrep(i,n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\ntemplate<class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } else return false; }\ntemplate<class T> bool chmin(T& a, const T& b) { if (b < a) { a = b; return true; } else return false; }\nusing ll = long long;\nusing P = pair<int,int>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\n\ntemplate <class S, S (*op)(S, S), S (*e)()>\nstruct SWAG {\n    std::vector<S> ar, sl, sr;\n    SWAG() : sl{e()}, sr{e()} {}\n    explicit SWAG(const std::vector<S>& v) : sr{e()} {\n        const int n = v.size();\n        S x = e();\n        sl.reserve(n + 1);\n        sl.push_back(x);\n        for (int i = n - 1; i >= 0; i--) {\n            x = op(v[i], x);\n            sl.push_back(x);\n        }\n    }\n\n    void push(S x) {\n        ar.push_back(x);\n        sr.push_back(op(sr.back(), x));\n    }\n\n    void pop() {\n        assert(sl.size() != 1 || ar.size() != 0);\n        if (sl.size() != 1) {\n            sl.pop_back();\n        } else {\n            const int n = ar.size();\n            S x = e();\n            for (int i = n - 1; i >= 1; i--) {\n                x = op(ar[i], x);\n                sl.push_back(x);\n            }\n            ar.resize(0);\n            sr.resize(1);\n        }\n    }\n\n    S all_prod() { return op(sl.back(), sr.back()); }\n\n    int size() { return (int)sl.size() - 1 + ar.size(); }\n};\n\nint op(int x, int y) { return x & y; }\nint e() { return (1 << 30) - 1; }\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& a, int k) {\n        int n = a.size();\n        int r1 = 0, r2 = 0;\n        SWAG<int, op, e> swg;\n        ll ans = 0;\n        rep(l, n) {\n          while (r1 < n && (swg.all_prod() | k) != k) {\n            swg.push(a[r1++]);\n          }\n          while (r2 < n && (a[r2] & k) == k) r2++;\n          if (swg.all_prod() == k && r1 <= r2) ans += r2 - r1 + 1;\n          if (l == r1) r1++;\n          else swg.pop();\n          if (l == r2) r2++;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720277738",
    "subm_id": "1311677769"
}