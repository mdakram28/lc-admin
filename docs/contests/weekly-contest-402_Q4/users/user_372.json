{
    "username": "mafulong",
    "submission": "\n'''\n\u7ebf\u6bb5\u6811\n'''\n\n\n# \u7ebf\u6bb5\u6811\u7684\u8282\u70b9\u7c7b\nclass STNode:\n    def __init__(self, left, right, val):\n        self.left = left  # \u533a\u95f4\u5de6\u8fb9\u754c\n        self.right = right  # \u533a\u95f4\u53f3\u8fb9\u754c\n        self.mid = (left + right) >> 1\n        self.leftNode = None  # \u533a\u95f4\u5de6\u8282\u70b9\n        self.rightNode = None  # \u533a\u95f4\u53f3\u8282\u70b9\n        self.val = val  # \u8282\u70b9\u503c\uff08\u533a\u95f4\u503c\uff09\n        self.lazy_tag = None  # \u533a\u95f4\u95ee\u9898\u7684\u5ef6\u8fdf\u66f4\u65b0\u6807\u8bb0\n\n    def __repr__(self):\n        return f\"{self.left}:{self.right} = {self.val}\"\n\n\nfrom enum import Enum\n\n\nclass SegOpCollect(Enum):\n    Collect_Sum = 1\n    Collect_Max = 2\n    Collect_Min = 3\n\n\nclass SegOpUpdate(Enum):\n    Update_SetVal = 1\n    Update_AddVal = 2\n    Update_MultiplyVal = 3\n    Update_Reverse = 4  # \u533a\u95f4\u53cd\u8f6c\u3002refer to: https://leetcode.cn/problems/handling-sum-queries-after-update/solution/xian-duan-shu-by-tsreaper-2qot/\n\n\n# \u7ebf\u6bb5\u6811\u7c7b\nclass SegmentTree:\n    def __init__(self, collect=SegOpCollect.Collect_Max, update=SegOpUpdate.Update_SetVal, default_val=0):\n        self.op_collect = collect\n        self.op_update = update\n        self.default_val = default_val\n\n    def build(self, left=0, right=int(1e9)):\n        # \u6ce8\u610fright\u4e0d\u80fd\u5c0f\u4e8e\u67e5\u8be2\u8fb9\u754c\uff0c\u8fd9\u91cc\u66f4\u65b0\u67e5\u8be2\u6700\u5927\u53ea\u80fd[left,right]\n        if self.op_collect == SegOpCollect.Collect_Sum:\n            self.root = STNode(left, right, self.default_val * (right - left + 1))\n        else:\n            self.root = STNode(left, right, self.default_val)\n\n    def build_with_data(self, data=[]):\n        # \u6ce8\u610fright\u4e0d\u80fd\u5c0f\u4e8e\u67e5\u8be2\u8fb9\u754c\uff0c\u8fd9\u91cc\u66f4\u65b0\u67e5\u8be2\u6700\u5927\u53ea\u80fd[left,right]\n        def create_tree(left, right) -> STNode:  # \u6784\u5efa[left, right]\u7684\u6811\n            node = STNode(left, right, self.default_val)\n            if left == right:\n                node.val = data[left]  # \u5230\u8fbe\u53f6\u8282\u70b9\n            else:\n                mid = (left + right) >> 1\n                # \u6784\u5efa\u5de6\u53f3\u5b50\u6811\n                node.leftNode, node.rightNode = create_tree(left, mid), create_tree(mid + 1, right)\n                self.__merge(node)\n            return node\n\n        self.root = create_tree(0, len(data) - 1)\n\n    # collect \u5de6\u533a\u95f4\u548c\u53f3\u533a\u95f4\u7684\u805a\u5408\u65b9\u6cd5\uff1b\u4f20\u5165\u5de6\u533a\u95f4\u548c\u53f3\u533a\u95f4\uff0c\u8fd4\u56de\u4e00\u4e2a\u4e24\u533a\u95f4\u7684\u805a\u5408\u7ed3\u679c\n    def collect(self, a, b):\n        if self.op_collect == SegOpCollect.Collect_Sum:\n            # \u53d6sum\n            return a + b\n        elif self.op_collect == SegOpCollect.Collect_Max:\n            # \u53d6max\n            return max(a, b)\n        elif self.op_collect == SegOpCollect.Collect_Min:\n            # \u53d6min\n            return min(a, b)\n\n    # \u7528\u4e8e\u52a0lazy\u6807\u8bb0\u7684\uff0c\u5b9e\u9645\u4e0a\u662f\u5f53\u524dval\u53d8\u4e0b\uff0c\u7136\u540e\u52a0\u7684\u6807\u8bb0\u5f71\u54cd\u5b50\u8282\u70b9\n    def lazy_update(self, node: STNode, lazy: int):\n        # \u6e90\u5934\u662fupdate_interval\u65f6\u8c03\u7528\uff0c\u7136\u540epushdown\u65f6\u6709lazy_tag\u5c31\u4e0b\u63a8\uff0c\u5982\u679c\u6ca1\u6709update_interval\u5c31\u6ca1\u6709lazy_tag\u4e86\n        meta_size = (node.right - node.left + 1)  # (r - l + 1)\u4e3a\u6b64\u533a\u95f4\u7684\u5143\u7ebf\u6bb5\u6570\n        diff_val = None\n        if self.op_collect == SegOpCollect.Collect_Sum:\n            # - when sum\n            diff_val = meta_size * lazy\n        # elif self.op_collect == SegOpCollect.Collect_Max or self.op_collect == SegOpCollect.Collect_Min:\n        else:\n            # - when max/min\n            diff_val = lazy\n\n        if self.op_update == SegOpUpdate.Update_SetVal:\n            # - when set val\n            # \u4e0d\u7d2f\u52a0\u6807\u8bb0\n            node.lazy_tag = lazy\n            node.val = diff_val\n        elif self.op_update == SegOpUpdate.Update_AddVal:\n            # - when add\n            # \u7d2f\u52a0\u6807\u8bb0\n            node.lazy_tag = node.lazy_tag + lazy if node.lazy_tag is not None else lazy\n            node.val += diff_val\n        elif self.op_update == SegOpUpdate.Update_MultiplyVal:\n            # - when multiply\n            # \u7d2f\u4e58\u6807\u8bb0\n            node.lazy_tag = node.lazy_tag * lazy if node.lazy_tag is not None else lazy\n            node.val *= diff_val\n        elif self.op_update == SegOpUpdate.Update_Reverse:\n            # - when reverse, \u5fc5\u987b\u662f\u4e2asum\u6811\n            node.lazy_tag = (node.lazy_tag + lazy) % 2 if node.lazy_tag is not None else lazy\n            # if node.lazy_tag == 0:\n            #     node.lazy_tag = None\n            if lazy == 1:\n                node.val = meta_size - node.val\n\n    def __merge(self, node):\n        node.val = self.collect(node.leftNode.val, node.rightNode.val)\n\n    # \u5411\u4e0b\u66f4\u65b0 node \u8282\u70b9\u6240\u5728\u533a\u95f4\u7684\u5de6\u53f3\u5b50\u8282\u70b9\u7684\u503c\u548c\u61d2\u60f0\u6807\u8bb0, \u5b9e\u9645\u662f\u628a\u5f53\u524d\u8282\u70b9\u7684lazy flag\u53bb\u6389\uff0c\u8f6c\u5316\u5e76\u52a0\u5230\u4e0b\u9762\u8282\u70b9\u4e0a\u53bb\n    def __pushdown(self, node):\n        # create child nodes\n        if not node.leftNode:\n            node.leftNode = STNode(node.left, node.mid, self.default_val)\n        if not node.rightNode:\n            node.rightNode = STNode(node.mid + 1, node.right, self.default_val)\n        # push down lazy tag\n        if node.lazy_tag is not None:\n            # \u5982\u679c\u662f\u53f6\u5b50\u8282\u70b9\u5df2\u7ecf\u7531\u7236\u8282\u70b9\u66f4\u65b0\u8fd9\u4e2a\u53f6\u5b50\u8282\u70b9\u503c\u4e86\n            if node.left != node.right:\n                self.lazy_update(node.leftNode, node.lazy_tag)\n                self.lazy_update(node.rightNode, node.lazy_tag)\n            node.lazy_tag = None  # \u66f4\u65b0\u5f53\u524d\u8282\u70b9\u7684\u61d2\u60f0\u6807\u8bb0\n\n    # \u5355\u70b9\u66f4\u65b0\uff0c\u5c06 nums[i] \u66f4\u6539\u4e3a val\n    def set_point(self, i, val):\n        # \u5355\u70b9\u66f4\u65b0\uff0c\u5c06 nums[i] \u66f4\u6539\u4e3a val\u3002node \u8282\u70b9\u7684\u533a\u95f4\u4e3a [node.left, node.right]\n        def dfs(i, val, node):\n            # \u5355\u70b9\u66f4\u65b0\u53ea\u6539\u4e86\u4e2a\u70b9\u7684val\uff0c\u4e0d\u9700\u8981\u8003\u8651lazy flag\n            if node.left == node.right:\n                # self.lazy_update(node, val)\n                node.val = val\n                return\n            self.__pushdown(node)\n            if i <= node.mid:  # \u5728\u5de6\u5b50\u6811\u4e2d\u66f4\u65b0\u8282\u70b9\u503c\n                dfs(i, val, node.leftNode)\n            else:  # \u5728\u53f3\u5b50\u6811\u4e2d\u66f4\u65b0\u8282\u70b9\u503c\n                dfs(i, val, node.rightNode)\n            self.__merge(node)\n\n        dfs(i, val, self.root)\n\n    # \u533a\u95f4\u67e5\u8be2\uff0c\u67e5\u8be2\u533a\u95f4\u4e3a [q_left, q_right] \u7684\u533a\u95f4\u503c\n    def query_interval(self, left, right):\n        def dfs(node):\n            # corner case\n            if left > right:\n                return self.default_val\n            if left <= node.left and node.right <= right:  # \u533a\u95f4\u5c31\u662f\u60f3\u8981\u7684\u533a\u95f4\n                return node.val  # \u76f4\u63a5\u8fd4\u56de\u8282\u70b9\u503c\n            self.__pushdown(node)\n            if right <= node.mid:\n                return dfs(node.leftNode)\n            elif left > node.mid:\n                return dfs(node.rightNode)\n            res_left = dfs(node.leftNode)\n            res_right = dfs(node.rightNode)\n            return self.collect(res_left, res_right)  # \u8fd4\u56de\u5de6\u53f3\u5b50\u6811\u5143\u7d20\u503c\u7684\u805a\u5408\u8ba1\u7b97\u7ed3\u679c\n\n        return dfs(self.root)\n\n    # \u6c42[left,right]\u533a\u95f4\u7684\u5927\u4e8e\u7b49\u4e8eval\u7684\u7b2c\u4e00\u4e2a\u4f4d\u7f6e, \u4e8c\u5206, \u9700\u8981\u662fmax\u6811, \u5982\u679c\u6ca1\u627e\u5230\u8fd4\u56de-1\n    def query_first_not_less_val(self, left, right, val):\n        assert self.op_collect == SegOpCollect.Collect_Max\n\n        # \u533a\u95f4\u67e5\u8be2\uff0c\u5728\u7ebf\u6bb5\u6811\u7684 [left, right] \u533a\u95f4\u8303\u56f4\u4e2d\u641c\u7d22\u533a\u95f4\u4e3a [left, right] \u7684\u533a\u95f4\u503c\n        def dfs(node):\n            if right < node.left or left > node.right:\n                return -1\n            if left <= node.left and node.right <= right:  # \u533a\u95f4\u5c31\u662f\u60f3\u8981\u7684\u533a\u95f4\n                if node.val < val:\n                    return -1\n            if node.left == node.right:\n                if node.val < val:\n                    return -1\n                return node.left\n            self.__pushdown(node)\n            res_left = -1\n            if left <= node.mid:  # \u5728\u5de6\u5b50\u6811\u4e2d\u67e5\u8be2\n                res_left = dfs(node.leftNode)\n                if res_left != -1:\n                    return res_left\n            res_right = -1\n            if right > node.mid:  # \u5728\u53f3\u5b50\u6811\u4e2d\u67e5\u8be2\n                res_right = dfs(node.rightNode)\n            return self.collect(res_left, res_right)  # \u8fd4\u56de\u5de6\u53f3\u5b50\u6811\u5143\u7d20\u503c\u7684\u805a\u5408\u8ba1\u7b97\u7ed3\u679c\n\n        return dfs(self.root)\n\n    # \u6c42[left,right]\u533a\u95f4\u7684\u5927\u4e8e\u7b49\u4e8eval\u7684\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e, \u4e8c\u5206, \u9700\u8981\u662fmax\u6811, \u5982\u679c\u6ca1\u627e\u5230\u8fd4\u56de-1\n    def query_last_not_less_val(self, left, right, val):\n        assert self.op_collect == SegOpCollect.Collect_Max\n\n        # \u533a\u95f4\u67e5\u8be2\uff0c\u5728\u7ebf\u6bb5\u6811\u7684 [left, right] \u533a\u95f4\u8303\u56f4\u4e2d\u641c\u7d22\u533a\u95f4\u4e3a [left, right] \u7684\u533a\u95f4\u503c\n        def dfs(node):\n            if right < node.left or left > node.right:\n                return -1\n            if left <= node.left and node.right <= right:  # \u533a\u95f4\u5c31\u662f\u60f3\u8981\u7684\u533a\u95f4\n                if node.val < val:\n                    return -1\n            if node.left == node.right:\n                if node.val < val:\n                    return -1\n                return node.left\n            self.__pushdown(node)\n            res_right = -1\n            if right > node.mid:  # \u5728\u53f3\u5b50\u6811\u4e2d\u67e5\u8be2\n                res_right = dfs(node.rightNode)\n                if res_right != -1:\n                    return res_right\n            res_left = -1\n            if left <= node.mid:  # \u5728\u5de6\u5b50\u6811\u4e2d\u67e5\u8be2\n                res_left = dfs(node.leftNode)\n            return self.collect(res_left, res_right)  # \u8fd4\u56de\u5de6\u53f3\u5b50\u6811\u5143\u7d20\u503c\u7684\u805a\u5408\u8ba1\u7b97\u7ed3\u679c\n\n        return dfs(self.root)\n\n    # \u533a\u95f4\u66f4\u65b0\uff0c\u5c06\u533a\u95f4[left, right]\u503c\u8fdb\u884c\u53d8\u5316val\u7684\u5904\u7406\n    def update_interval(self, left, right, val):\n        if left > right:\n            return\n        # \u533a\u95f4\u66f4\u65b0\n        def dfs(node):\n            if left <= node.left and node.right <= right:\n                self.lazy_update(node, val)\n                return\n            self.__pushdown(node)  # \u5411\u4e0b\u66f4\u65b0\u8282\u70b9\u6240\u5728\u533a\u95f4\u7684\u5de6\u53f3\u5b50\u8282\u70b9\u7684\u503c\u548c\u61d2\u60f0\u6807\u8bb0\n            if left <= node.mid:  # \u5728\u5de6\u5b50\u6811\u4e2d\u66f4\u65b0\u533a\u95f4\u503c\n                dfs(node.leftNode)\n            if right > node.mid:  # \u5728\u53f3\u5b50\u6811\u4e2d\u66f4\u65b0\u533a\u95f4\u503c\n                dfs(node.rightNode)\n            self.__merge(node)\n\n        dfs(self.root)\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        seg = SegmentTree(SegOpCollect.Collect_Sum, SegOpUpdate.Update_SetVal)\n        n = len(nums)\n        d = [0] * n\n        for i, v in enumerate(nums):\n            j = i - 1\n            if j >= 0 and nums[j] < v and i + 1 < n and nums[i + 1] < v:\n                d[i] = 1\n        # print(nums)\n        # print(d)\n        seg.build_with_data(d)\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                l, r = q[1], q[2]\n                res = 0\n                if l + 1 <= r - 1:\n                    res = seg.query_interval(l + 1, r - 1)\n                # print(q, res)\n                ans.append(res)\n            else:\n                index, v = q[1], q[2]\n                nums[index] = v\n                i = index\n                if i - 1 >= 0 and i + 1 < n and nums[i - 1] < nums[i] and nums[i + 1] < nums[i]:\n                    if d[i] != 1:\n                        d[i] = 1\n                        seg.set_point(i, 1)\n                else:\n                    if 0 <= i < n and d[i] != 0:\n                        d[i] = 0\n                        seg.set_point(i, 0)\n\n                i = index - 1\n                if i - 1 >= 0 and i + 1 < n and nums[i - 1] < nums[i] and nums[i + 1] < nums[i]:\n                    if d[i] != 1:\n                        d[i] = 1\n                        seg.set_point(i, 1)\n                else:\n                    if 0 <= i < n and d[i] != 0:\n                        d[i] = 0\n                        seg.set_point(i, 0)\n                i = index + 1\n                if i - 1 >= 0 and i + 1 < n and nums[i - 1] < nums[i] and nums[i + 1] < nums[i]:\n                    if d[i] != 1:\n                        d[i] = 1\n                        seg.set_point(i, 1)\n                else:\n                    if 0 <= i < n and d[i] != 0:\n                        d[i] = 0\n                        seg.set_point(i, 0)\n        return ans",
    "submit_ts": 1718507047.0
}