{
    "username": "shubhamvarshney2000",
    "submission": "    #include <bits/stdc++.h>\n\n    // #include <ext/pb_ds/assoc_container.hpp>\n    // #include <ext/pb_ds/tree_policy.hpp>\n    // using namespace __gnu_pbds;\n    // typedef tree<int, null_type, greater_equal<int>, rb_tree_tag,\n    //              tree_order_statistics_node_update>\n    //     oset;\n\n    using namespace std;\n\n    #define ar array\n    #define ll long long\n    #define ld long double\n    #define sza(x) ((int)x.size())\n    #define all(a) (a).begin(), (a).end()\n    #define printy cout<<\"Yes\"<<endl;\n    #define printn cout<<\"No\"<<endl;\n    const int MAX_N = 1e5 + 5;\n    const ll MOD = 1e9 + 7;\n    const ll INF = 1e9;\n    const ld EPS = 1e-9;\n\n    long long pow_m(long long base, long long exp, long long mod) {\n        long long result = 1LL;\n        base = (base % mod);\n            \n        while (exp > 0) {\n            if ((exp & 1LL) == 1LL) result = (result * base) % mod;\n            exp >>= 1LL;\n            base = (base * base) % mod;\n        }\n        return result;\n\n    }\n    // Trie implementation \n    class Node{\n        public:\n        \n        Node* links[26];\n        bool flag = false;\n\n        bool containskey(char ch){\n            return links[ch-'a'] != nullptr;\n        }\n\n        Node* get(char ch){\n            return links[ch-'a'];\n        }\n\n        void put(char ch,Node* node){\n            links[ch-'a'] = node;\n        }\n\n        void setEnd(){\n            flag = true;\n        }\n\n        bool isEnd(){\n            return flag == true;\n        }\n    };\n    class Trie {\n    public:\n        Node* root;\n        Trie() {\n            root = new Node();\n        }\n        \n        void insert(string word) {\n            Node* node = root;\n            for(int i=0;i<word.size();i++){\n                if(!node->containskey(word[i])){\n                    node->put(word[i],new Node());\n                }\n                node = node->get(word[i]);\n            }\n            node->setEnd();\n        }\n        \n        bool search(string word) {\n            Node* node = root;\n            for(int i=0;i<word.size();i++){\n                if(!node->containskey(word[i])){\n                    return false;\n                }\n                node = node->get(word[i]);\n            }\n            return node->isEnd();\n        }\n        \n        bool startsWith(string prefix) {\n            Node* node = root;\n            for(int i=0;i<prefix.size();i++){\n                if(!node->containskey(prefix[i])){\n                    return false;\n                }\n                node = node->get(prefix[i]);\n            }\n            return true;\n        }\n    };\n\n    class DSU {\n        private:\n        int sz;\n        vector<int> root, rank;\n        public:\n        DSU(int sz){\n            this->sz = sz;\n            root.resize(sz);\n            rank.resize(sz);\n            for(int i = 0; i < sz; i++){\n                root[i] = i;\n                rank[i] = 1;\n            }\n        }\n        \n        int find(int x){\n            if(root[x] == x) return x;\n            return root[x] = find(root[x]);\n        }\n        \n        bool unionSet(int x, int y){\n            cout<<x<<\" \"<<y<<endl;\n            int rootX = find(x);\n            int rootY = find(y);\n            cout<<rootX<<\" \"<<rootY<<endl;\n            if(rootX == rootY)\n                return false;\n            \n            if(rank[rootX] > rank[rootY])\n                root[rootY] = rootX;\n            else if(rank[rootX] < rank[rootY])\n                root[rootX] = rootY;\n            else{\n                root[rootY] = rootX;\n                rank[rootX]++;\n            }\n            return true;\n        }\n\n        int solve() {\n            map<ll,ll> m;\n            for(int i = 0; i < sz; i++){\n                if(m.find(root[i]) == m.end()){\n                    cout<<root[i];\n                    m[root[i]]++;\n                }\n            }\n            return (int)m.size();\n        }\n    };\n\n\n    class TreeAncestor {\n        public:\n        vector<vector<int>> vec;\n        vector<int> depth;\n        int h = 18;\n        int n;\n        TreeAncestor(int _n, vector<int>& parent) {\n            n = _n;\n            depth.resize(n,0);\n            vec.resize(h,vector<int>(n+1,-1));\n            for(int i=0;i<n;i++){\n                vec[0][i] = parent[i];\n            }\n            for(int i=1;i<h;i++){\n                for(int j=0;j<n;j++){\n                    if(vec[i-1][j] != -1)\n                        vec[i][j] = vec[i-1][vec[i-1][j]];\n                }\n            }\n        }\n        \n        int getKthAncestor(int node, int k) {\n            for(int i=0;i<h;i++){\n                if(k&(1<<i)){\n                    node = vec[i][node];\n                    if(node == -1){\n                        return -1;\n                    }\n                }\n            }\n            return node;\n        }\n        int lca(int a, int b)\n        {\n            if(depth[a] < depth[b])\n                swap(a, b);\n            \n            int diff = depth[a] - depth[b];\n            for(int i = 0; i < 16; i++)\n                if(diff & (1 << i))\n                    a = vec[a][i];\n\n            if(a == b)\n                return a;\n            \n            for(int i = 15; i >= 0; i--)\n            {\n                if(vec[a][i] != vec[b][i])\n                {\n                    a = vec[a][i];\n                    b = vec[b][i];\n                }\n            }\n\n            return vec[a][0];\n        }\n        void dfs(int src, int paren,vector<vector<int>> &g)\n        {\n            for(auto x : g[src])\n            {\n                if(x == paren)\n                    continue;\n                depth[x] = depth[src] + 1;\n                dfs(x, src,g);\n            }\n        }\n    };\n\n    bool help(ll x,ll y,ll sum){\n        ll s = 0;\n        while(x>0 && y>0){\n            if(s>=sum){\n                s= s-2;\n                y--;\n            }\n            else{\n                s += 1;\n                x--;\n            }\n        }\n        if(x<=sum){\n            return 1;\n        }\n        else{\n            return 0;\n        }\n    }\n    \n    bool subArrayExists(ll arr[], int N)\n    {\n        unordered_set<int> sumSet;\n    \n        // Traverse through array\n        // and store prefix sums\n        ll sum = 0;\n        for (int i = 0; i < N; i++) {\n            sum += arr[i];\n    \n            // If prefix sum is 0 or\n            // it is already present\n            if (sum == 0 || sumSet.find(sum) != sumSet.end())\n                return true;\n    \n            sumSet.insert(sum);\n        }\n        return false;\n    }\n\n    ll myCountX(ll N, ll X)\n    {\n        ll x, a, r;\n        ll e;\n    \n        // The loop is executed for every digit of N\n        e = (ll)(log10(N));\n        r = 0;\n        while (e >= 0) {\n            // Calculation of next digit in decrescent order of\n            // power of 10\n            x = N / (ll)pow(10, e);\n            x %= 10;\n            // Modularity based on power of 10\n            a = x * e * (ll)pow(10, e - 1);\n            r += a;\n            // If the digit is the searched one then the\n            // remainder of division by the current power of 10\n            // is added to result because a number of occurances\n            // equal to this remainder is when the digit is\n            // present with this position\n            if (x == X) {\n                a = (N % (ll)pow(10, e)) + 1;\n                // But if the searched digit is equal to 0 then\n                // there aren't number with the most significant\n                // digit equal to 0\n                if (X == 0)\n                    a -= (ll)pow(10, e);\n                r += a;\n            }\n            // If the digit is greater than the searched one and\n            // the searched digit isn't 0 then the number of all\n            // number with the most significat digit equal to\n            // the searched one must be added to result\n            if (x > X && X != 0) {\n                a = (ll)pow(10, e);\n                r += a;\n            }\n            e--;\n        }\n        return r;\n    }\n    ll count(vector<int> &cnt,int l,int r){\n        if(l == 0){\n            return cnt[r];\n        }\n        else{\n            return cnt[r]-cnt[l-1];\n        }\n    }\n    ll a[1000001][20];\n\n    void build(int arr[],int n){\n        for(int i=0;i<n;i++){\n            a[i][0] = arr[i];\n        }\n        for(int j=1;j<=20;j++){\n            for(int i=0;i+(1<<j)<=n;i++){\n                a[i][j] = a[i][j-1] + a[i+(1<<(j-1))][j-1];\n            }\n        }\n    }\n\n    bool can(vector<vector<int>> &vec,int k,int n){\n        vector<int> a = vec[k-1];\n        // cout<<n<<endl;\n        for(int i=k;i<n;i++){\n            vector<int> aa(21);\n            // cout<<i<<endl;\n            for(int j=0;j<21;j++){\n                // cout<<vec[i][j]<<\" \"<<vec[i-k][j]<<endl;\n                aa[j] = vec[i][j] - vec[i-k][j];\n            }\n            for(int j=0;j<21;j++){\n                if(a[j]>0 && aa[j] == 0){\n                    return false;\n                }\n                if(a[j] == 0 && aa[j]> 0){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    void solve(){\n       int a,b,c;\n       cin>>a>>b>>c;\n    }\nclass SegmentTree {\n    private:\n        vector<int> st;\n        vector<int> nums;\n        int n;\n\n        bool isPeak(int idx) {\n            if (idx <= 0 || idx >= n - 1) return false;\n            return nums[idx] > nums[idx - 1] && nums[idx] > nums[idx + 1];\n        }\n\n        void build(int si, int ss, int se) {\n            if (ss == se) {\n                st[si] = isPeak(ss) ? 1 : 0;\n                return;\n            }\n            int mid = (ss + se) / 2;\n            build(2 * si + 1, ss, mid);\n            build(2 * si + 2, mid + 1, se);\n            st[si] = st[2 * si + 1] + st[2 * si + 2];\n        }\n\n        int query(int si, int ss, int se, int qs, int qe) {\n            if (ss > qe || se < qs) return 0;\n            if (ss >= qs && se <= qe) return st[si];\n\n            int mid = (ss + se) / 2;\n            return query(2 * si + 1, ss, mid, qs, qe) + query(2 * si + 2, mid + 1, se, qs, qe);\n        }\n\n        void update(int si, int ss, int se, int idx) {\n            if (ss == se) {\n                st[si] = isPeak(ss) ? 1 : 0;\n                return;\n            }\n            int mid = (ss + se) / 2;\n            if (idx <= mid) {\n                update(2 * si + 1, ss, mid, idx);\n            } else {\n                update(2 * si + 2, mid + 1, se, idx);\n            }\n            st[si] = st[2 * si + 1] + st[2 * si + 2];\n        }\n\n    public:\n        SegmentTree(vector<int>& nums) : nums(nums) {\n            n = nums.size();\n            st.resize(4 * n);\n            build(0, 0, n - 1);\n        }\n\n        int countPeaks(int l, int r) {\n            if (l >= r) return 0;\n            return query(0, 0, n - 1, l + 1, r - 1);\n        }\n\n        void update(int idx, int newVal) {\n            nums[idx] = newVal;\n            if (idx > 0) update(0, 0, n - 1, idx - 1);\n            update(0, 0, n - 1, idx);\n            if (idx < n - 1) update(0, 0, n - 1, idx + 1);\n        }\n    };\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        SegmentTree segmentTree(nums);\n        vector<int> result;\n        for (const auto& query : queries) {\n            if (query[0] == 1) {\n                int l = query[1], r = query[2];\n                result.push_back(segmentTree.countPeaks(l, r));\n            } else if (query[0] == 2) {\n                int idx = query[1], newVal = query[2];\n                segmentTree.update(idx, newVal);\n            }\n        }\n        return result;\n    }\n};",
    "submit_ts": "1718506620",
    "subm_id": "1289625338"
}