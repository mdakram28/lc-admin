{
    "username": "keylovett",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        \n        \n        \n        def build_graph(tree, n):\n            \n            if n == 1:\n                return 0  \n            \n            adj_list = [[] for _ in range(n)]\n            \n            for u, v in tree:\n                \n                adj_list[u].append(v)\n                adj_list[v].append(u)\n\n            leaves = deque()\n            degree = [0] * n\n            for i in range(n):\n                degree[i] = len(adj_list[i])\n                if degree[i] == 1:\n                    leaves.append(i)\n\n            remaining_nodes = n\n            while remaining_nodes > 2:\n                leaves_size = len(leaves)\n                remaining_nodes -= leaves_size\n                for _ in range(leaves_size):\n                    leaf = leaves.popleft()\n                    for neighbor in adj_list[leaf]:\n                        degree[neighbor] -= 1\n                        if degree[neighbor] == 1:\n                            leaves.append(neighbor)\n\n            return list(leaves)\n        \n        def calculate_depth(tree, root, n):\n\n            adj_list = [[] for _ in range(n)]\n            for u, v in tree:\n                adj_list[u].append(v)\n                adj_list[v].append(u)\n\n\n            visited = [False] * n\n            queue = deque([(root, 0)]) \n            max_depth = 0\n\n            while queue:\n                node, depth = queue.popleft()\n                visited[node] = True\n                max_depth = max(max_depth, depth)\n\n                for neighbor in adj_list[node]:\n                    if not visited[neighbor]:\n                        queue.append((neighbor, depth + 1))\n\n            return max_depth\n\n        def find_min_depth_root_and_depth(tree):\n            n = len(tree)+1\n            if n==1:\n                return 0, 0\n            centers = build_graph(tree, n)\n            min_depth = float('inf')\n            best_root = None\n\n            for center in centers:\n                depth = calculate_depth(tree, center, n)\n                if depth < min_depth:\n                    min_depth = depth\n                    best_root = center\n\n            return best_root, min_depth\n        def bfs_farthest_node(tree, start, n):\n            adj_list = [[] for _ in range(n)]\n            for u, v in tree:\n                adj_list[u].append(v)\n                adj_list[v].append(u)\n\n            visited = [False] * n\n            queue = deque([(start, 0)]) \n            farthest_node = start\n            max_distance = 0\n\n            while queue:\n                node, distance = queue.popleft()\n                visited[node] = True\n                if distance > max_distance:\n                    max_distance = distance\n                    farthest_node = node\n\n                for neighbor in adj_list[node]:\n                    if not visited[neighbor]:\n                        queue.append((neighbor, distance + 1))\n\n            return farthest_node, max_distance\n\n        def find_diameter(tree):\n            n = len(tree)+1\n            if n==1:\n                return 1\n            farthest_node_A, _ = bfs_farthest_node(tree, 0, n)\n            farthest_node_B, diameter = bfs_farthest_node(tree, farthest_node_A, n)\n            return diameter\n        \n        min_depth1 = find_min_depth_root_and_depth(edges1)\n        depth1 = find_diameter(edges1)\n        min_depth2 = find_min_depth_root_and_depth(edges2)\n        depth2 =  find_diameter(edges2)\n\n        \n        if not edges1 and not edges2:\n            return 1\n        if not edges1:\n            return max(depth2, min_depth2[1]+1)\n        if not edges2:\n            return max(depth1, min_depth1[1]+1)\n        return max(depth1, depth2, min_depth1[1]+min_depth2[1]+1)\n        ",
    "submit_ts": "1719719666",
    "subm_id": "1304447575"
}