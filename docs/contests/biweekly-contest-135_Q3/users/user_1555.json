{
    "username": "Arpit971",
    "submission": "\nint compare(const void* a, const void* b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint lower_bound(int* arr, int n, int key) {\n    int low = 0;\n    int high = n;\n    while (low < high) {\n        int mid = (low + high) / 2;\n        if (arr[mid] < key) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint abs_diff(int a, int b) {\n    return abs(a - b);\n}\n\nint minChanges(int* nums, int n, int k) {\n    // This will mimic the behavior of map<int, vector<int>> in C++\n    typedef struct {\n        int key;\n        int* values;\n        int size;\n        int capacity;\n    } Map;\n\n    Map* m = (Map*)malloc(n / 2 * sizeof(Map));\n    int* v = (int*)malloc(n / 2 * sizeof(int));\n    int m_size = 0, v_size = 0;\n\n    for (int i = 0; i < n / 2; i++) {\n        int a = nums[i], b = nums[n - i - 1];\n        int diff = abs_diff(a, b);\n        int X = max(max(a, b), max(k - a, k - b));\n\n        int found = 0;\n        for (int j = 0; j < m_size; j++) {\n            if (m[j].key == diff) {\n                if (m[j].size == m[j].capacity) {\n                    m[j].capacity *= 2;\n                    m[j].values = (int*)realloc(m[j].values, m[j].capacity * sizeof(int));\n                }\n                m[j].values[m[j].size++] = X;\n                found = 1;\n                break;\n            }\n        }\n\n        if (!found) {\n            m[m_size].key = diff;\n            m[m_size].size = 1;\n            m[m_size].capacity = 2;\n            m[m_size].values = (int*)malloc(2 * sizeof(int));\n            m[m_size].values[0] = X;\n            m_size++;\n        }\n\n        v[v_size++] = X;\n    }\n\n    int ans = n;\n    qsort(v, v_size, sizeof(int), compare);\n\n    for (int i = 0; i < m_size; i++) {\n        int diff = m[i].key;\n        int T = lower_bound(v, v_size, diff);\n        T = T * 2 + (n / 2 - T);\n\n        for (int j = 0; j < m[i].size; j++) {\n            if (m[i].values[j] < diff) {\n                T -= 2;\n            } else {\n                T -= 1;\n            }\n        }\n\n        if (T < ans) {\n            ans = T;\n        }\n    }\n\n    for (int i = 0; i < m_size; i++) {\n        free(m[i].values);\n    }\n    free(m);\n    free(v);\n\n    return ans;\n}",
    "submit_ts": "1721489620",
    "subm_id": "1327458789"
}