{
    "username": "technoid_22",
    "submission": "class Solution {\n    public long countSubarrays(int[] nums, int k) {\n         int n = nums.length;\n        long totalSubarrays = 0;\n        Map<Long, Long> bitwiseAndFrequency = new HashMap<>();  // Map to track frequency of AND results\n\n        for (int i = 0; i < n; ++i) {\n            Map<Long, Long> newFrequencyMap = new HashMap<>();  // Map for storing updated frequencies for this iteration\n\n            // If the current number equals the target, count it as a valid subarray\n            if (nums[i] == k) {\n                ++totalSubarrays;\n            }\n\n            // Update the new frequency map with the current number\n            newFrequencyMap.put((long) nums[i], 1L);\n\n            // Process previous results to update the total subarrays count\n            for (Map.Entry<Long, Long> entry : bitwiseAndFrequency.entrySet()) {\n                long andResult = entry.getKey();\n                long count = entry.getValue();\n                long newAndResult = andResult & nums[i];  // Perform bitwise AND operation\n                if (newAndResult == k) {\n                    totalSubarrays += count;  // Add the count of subarrays where AND result equals the target\n                }\n                newFrequencyMap.put(newAndResult, newFrequencyMap.getOrDefault(newAndResult, 0L) + count);  // Update the frequency map\n            }\n\n            // Update the bitwise AND frequency map with new results\n            bitwiseAndFrequency = newFrequencyMap;\n        }\n\n        return totalSubarrays; \n    }\n}",
    "submit_ts": "1720279582",
    "subm_id": "1311757037"
}