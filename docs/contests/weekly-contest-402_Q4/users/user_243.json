{
    "username": "XYShaoKang",
    "submission": "function countOfPeaks(nums: number[], queries: number[][]): number[] {\n  const n = nums.length\n  const st = new SegTree(n)\n  for (let i = 0; i < n; i++) {\n    if (nums[i] > (nums[i - 1] ?? 0) && nums[i] > (nums[i + 1] ?? 0)) {\n      st.update(i, i, 1)\n    }\n  }\n  const res: number[] = []\n  for (const [t, a, b] of queries) {\n    if (t === 1) {\n      let ans = st.query(a, b)\n      if (nums[a] > (nums[a - 1] ?? 0) && nums[a] > (nums[a + 1] ?? 0)) ans--\n      if (a !== b && nums[b] > (nums[b - 1] ?? 0) && nums[b] > (nums[b + 1] ?? 0)) ans--\n      res.push(ans)\n    } else if (t === 2) {\n      if (a && nums[a - 1] > nums[a] && nums[a - 1] > (nums[a - 2] ?? 0)) {\n        st.update(a - 1, a - 1, -1)\n      }\n      if (a < n - 1 && nums[a + 1] > nums[a] && nums[a + 1] > (nums[a + 2] ?? 0)) {\n        st.update(a + 1, a + 1, -1)\n      }\n      if (nums[a] > (nums[a - 1] ?? 0) && nums[a] > (nums[a + 1] ?? 0)) {\n        st.update(a, a, -1)\n      }\n      nums[a] = b\n      if (nums[a] > (nums[a - 1] ?? 0) && nums[a] > (nums[a + 1] ?? 0)) {\n        st.update(a, a, 1)\n      }\n      if (a && nums[a - 1] > nums[a] && nums[a - 1] > (nums[a - 2] ?? 0)) {\n        st.update(a - 1, a - 1, 1)\n      }\n      if (a < n - 1 && nums[a + 1] > nums[a] && nums[a + 1] > (nums[a + 2] ?? 0)) {\n        st.update(a + 1, a + 1, 1)\n      }\n    }\n  }\n  return res\n}\n\ntype Node = {\n  left: Node | null\n  right: Node | null\n  val: number\n  add: number\n}\nclass SegTree {\n  private root: Node\n  update: (x: number, y: number, z: number) => void\n  query: (x: number, y: number) => number\n  constructor(private n: number) {\n    this.root = this._newNode()\n\n    this.update = (x: number, y: number, z: number) => {\n      x = Math.max(x, 0)\n      y = Math.min(y, n)\n      this._update(this.root, 0, n, x, y, z)\n    }\n    this.query = (x: number, y: number) => {\n      x = Math.max(x, 0)\n      y = Math.min(y, n)\n      return this._query(this.root, 0, n, x, y)\n    }\n  }\n  private _newNode(val = 0, left = null, right = null) {\n    return { val, left, right, add: 0 }\n  }\n  private _down(node: Node, l: number, r: number) {\n    const { left, right } = node\n    if (!left || !right) return\n    const mid = Math.floor((l + r) / 2)\n    left.add += node.add\n    left.val += node.add * (mid - l + 1)\n    right.add += node.add\n    right.val += node.add * (r - mid)\n\n    node.add = 0\n  }\n  private _up(node: Node) {\n    const { left, right } = node\n    if (!left || !right) return\n\n    node.val = left.val + right.val\n  }\n  private _update(node: Node | null, l: number, r: number, x: number, y: number, z: number): void {\n    if (!node) return\n\n    if (l === x && r === y) {\n      node.add += z\n      node.val += z * (r - l + 1)\n      return\n    }\n\n    const mid = Math.floor((l + r) / 2)\n    if (!node.left) {\n      node.left = this._newNode()\n      node.right = this._newNode()\n    }\n    this._down(node, l, r)\n    if (y <= mid) this._update(node.left, l, mid, x, y, z)\n    else if (x > mid) this._update(node.right, mid + 1, r, x, y, z)\n    else this._update(node.left, l, mid, x, mid, z), this._update(node.right, mid + 1, r, mid + 1, y, z)\n\n    this._up(node)\n  }\n  private _query(node: Node | null, l: number, r: number, x: number, y: number): number {\n    if (y < x) return 0\n    if (!node) return 0\n\n    if (l === x && r === y) return node.val\n\n    let res = 0,\n      mid = Math.floor((l + r) / 2)\n    if (!node.left) {\n      node.left = this._newNode()\n      node.right = this._newNode()\n    }\n    this._down(node, l, r)\n    if (y <= mid) res = this._query(node.left, l, mid, x, y)\n    else if (x > mid) res = this._query(node.right, mid + 1, r, x, y)\n    else res = this._query(node.left, l, mid, x, mid) + this._query(node.right, mid + 1, r, mid + 1, y)\n\n    this._up(node)\n    return res\n  }\n}",
    "submit_ts": 1718506904.0
}