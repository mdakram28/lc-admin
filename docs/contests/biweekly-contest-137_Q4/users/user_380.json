{
    "username": "ansh",
    "submission": "\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.sql.Array;\nimport java.util.*;\n\nimport javax.management.Query;\n\npublic class Solution {\n\n class Pair<K, V>{\n        K first;\n        V second;\n        Pair(K f,V s){\n            first = f;\n            second = s;     \n        }     \n    }\n\n   \n\n\n    //implementing segment trees\n    int N ;\n    int[] seg ;\n    \n    // first will built the buil\n    public int build(int idx , int l , int h,int[] a){      \n        if(l==h)return seg[idx]=a[l];\n        int mid =(h+l)/2;\n        int left=  build(idx*2+1,l,mid,a);\n        int right =build(idx*2+2,mid+1,h,a);\n        // update this part as per the Question\n        return seg[idx] =left|right;\n        \n    }\n\n    public int find(int idx, int low, int high, int l , int r){\n\n        if(low>=l && high<=r){\n            return seg[idx];\n        }\n        if(high<l || low>r)return 0;\n\n      int   mid = (low +high)/2;\n        int left=    find(idx*2+1,low, mid,l,r);\n           int right=  find(idx*2+2,mid+1,high,l,r);\n\n           return left|right;\n\n    }\n\n    void update(int idx, int index,int value, int low , int high, int[] a){\n        //write base case as per Question needs\n        int mid  = (low +high)/2;\n        \n        if(mid>=index){\n          update(2*idx+1,index,value,low,mid,a);\n        }\n        else{\n           update(2*idx+2,index,value,mid,high,a);\n        }\n\n        if(mid==index){\n            if(a[mid]>a[mid-1] && a[mid]>a[mid+1]){\n                if(value>a[mid-1] && value>a[mid+1]){}\n                else seg[idx]--;\n            }\n            else{\n                if(value>a[mid-1] && value>a[mid+1]){seg[idx]++;}\n            }\n        }\n    }\n\n    int mod =(int)1e9+7;\n\n\n\n    //trie implementation\n    class Trie{\n      \n        HashMap<Character,Trie> edge = new HashMap<>();\n        boolean iswordEnd;\n        int cost=(int)1e9;\n\n        public void insert(String word , Trie root){\n            Trie currNode = root;      \n            for(char c : word.toCharArray()){\n                if(!currNode.edge.containsKey(c)){\n                    currNode.edge.put(c,new Trie());\n                }\n                currNode = currNode.edge.get(c);\n            }\n            currNode.iswordEnd =true;\n        }\n\n        public boolean search(String word,Trie root){\n            \n            Trie currNode = root;\n            \n            for(char c : word.toCharArray()){\n                if(!currNode.edge.containsKey(c)){\n                    return false;\n                }\n                currNode = currNode.edge.get(c);\n            }\n           if(currNode.iswordEnd ==true)return true;\n           else return false;\n        }\n    }\n\n\n\n    //counting with prefix using trie\n    public int countWithPrefix(Trie node){\n        if(node==null||node.edge.isEmpty())return 1;\n        int a=0;\n        for(char c : node.edge.keySet()){\n            a += countWithPrefix(node.edge.get(c));\n        }\n        if(node.iswordEnd)a++;\n        return a;\n    }\n\n\n    public void debug(){\n        System.out.println(\"**\");\n    }\n  \n    public void printArray(int[] a){\n        for (int i : a) {\n            System.out.print(i+ \" \");\n        }\n        System.out.println();\n    }\n\n    public void printArray(char[] a){\n        for (char i : a) {\n            System.out.print(i+ \" \");\n        }\n        System.out.println();\n    }\n    public void printArray(String[] a){\n        for (String i : a) {\n            System.out.print(i+ \" \");\n        }\n        System.out.println();\n    }\n\n\n      public void printArray(long[] a){\n        for (long i : a) {\n            System.out.print(i+ \" \");\n        }\n        System.out.println();\n    }\n\n\n    public void soutn(int a){\n        System.out.println(a);\n    }\n    public void soutn(boolean a){\n        System.out.println(a);\n    }\n    public void soutn(char a){\n        System.out.println(a);\n    }\n    public void soutn(String a){\n        System.out.println(a);\n    }\n    public void soutn(HashMap a){\n        System.out.println(a);\n    }\n    public void soutn(HashSet a){\n        System.out.println(a);\n    }\n    public void soutn(long a){\n        System.out.println(a);\n    }\n\n    public void sout(int a){\n        System.out.print(a);\n    }\n    public void sout(char a){\n        System.out.print(a);\n    }\n    public void sout(boolean a){\n        System.out.print(a);\n    }\n    public void sout(String a){\n        System.out.print(a);\n    }\n    public void sout(HashMap a){\n        System.out.print(a);\n    }\n    public void sout(HashSet a){\n        System.out.print(a);\n    }\n    public void sout(long a){\n        System.out.print(a);\n    }\n\n    \n    public int greaterCount(ArrayList<Integer> a , int val){\n        int idx = upper_bound(a,val);\n        if(idx ==-1){\n            idx=  a.size();\n        }\n        \n        return idx;\n    }\n\n\n \n    class node{\n        int i;\n        int j;\n        int time; \n        node(int i , int j, int t){\n            this.i =i;\n            this.j =j;\n            this.time=t;\n        }\n    }\n\n    int dir[][] = new int[][]{{1,0},{0,1},{-1,0},{0,-1}}; \n\n    boolean isValid(int i, int j , int m , int n){\n        if(i>-1&&j>-1&&i<m&&j<n)return true;\n        else return false;\n    }\n\n\n       \n    class DisjointSet{\n        int[] rank ;\n        int[] par; \n        int[] cost;\n\n        DisjointSet(int n){\n            rank = new int[n];\n            par = new int[n];\n         \n\n            for(int i=0;i<n;i++){\n                par[i]=i;\n                rank[i]=1;\n             \n            }\n        }\n\n      int  find(int n){\n            if(par[n]==n){\n                return n;\n            }\n            return par[n] =  find(par[n]);\n        }\n\n        void unionBy(int a,int b){\n            int ua = find(a);\n            int ub = find(b);\n            if(ua==ub){return;}\n            if(rank[ua]==rank[ub]){\n                par[ua] = ub;\n                rank[ub]++;\n            }else if(rank[ua]>rank[ub]){\n                par[ub]=ua;\n            }else if(rank[ub]>rank[ua]){\n                par[ua]=ub;\n            }\n        }\n\n    }\n\n    int f(int curr, int a[], int prev, int prevsum){\n        if(curr==a.length){return 1;}\n        int sum=a[curr];\n        int ans=0;\n        for(int i=prev;i<=sum;i++){\n            if(prevsum-prev>=a[curr]-i)\n           ans+= f(curr+1,a,i,a[curr]);\n        }\n        return ans;\n\n    }\n\n\n   \n\n    public long maximumValueSum(int[][] board) {\n        int n= board.length;\n        int m= board[0].length;\n        int [][]a= new int[n*m][3];\n        int t=n*m;\n\n        int k=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                a[k][0]=board[i][j];\n                a[k][1]=i;\n                a[k][2]=j;\n                k++;\n            }\n        }\n        int cnt=0;\n        Arrays.sort(a,(x,y)->y[0]-x[0]);\n        long sum=(long)-1e17;\n\n        \n        for(int i=0;i<t;i++){\n            int ia=a[i][1];\n            int ja=a[i][2];\n            boolean flag=false;\n             int cnt2=0;\n            for(int j=i+1;j<t;j++){\n                int ib=a[j][1];\n                int jb=a[j][2];\n                int cnt3=0;\n            \n                if(ia!=ib&&ja!=jb){\n\n                  for( k=j+1;k<t;k++){\n                    int ic=a[k][1];\n                    int jc=a[k][2];\n                    if(ic!=ia&&ic!=ib&&jc!=ja&&jc!=jb){\n                        cnt3++;\n                       \n                        //    System.out.println(ia+\"|\"+ja+\" \" + ib+\"|\"+jb+\" \"+ic+\"|\"+jc+\" \");\n                        // System.out.println(board[ia][ja]+\" \" + board[ib][jb]+ \" \" + board[ic][jc]);\n                        sum = Math.max((long)board[ia][ja]+(long)board[ib][jb]+(long)board[ic][jc],sum);\n                      \n                        flag=true;\n                        if(cnt3>3)\n                        break;\n\n                    }\n\n                  }\n                     cnt2++;\n                  if(flag&& cnt2>3)break;\n\n                }\n                    \n            }\n            cnt++;\n            if(cnt>3)return sum;\n        }\n        \n\n        return sum;\n        \n    }\n\n\n\n\n\n    /*------------------------------    Solve   ------------------- */\n\n\n\n    // void solve() {\n    //      int n= sc.nextInt();\n    //     // int p = sc.nextInt();\n    //         int a[]=sc.nextArray(n);\n\n    //     N=n;\n\n    //     int l=0;\n    //     int h=n-1;\n    //     seg= new int[4*n];\n    //     build(0, l, h, a);\n    //     printArray(seg);\n    //     // System.out.println(cnt);\n    //         // System.out.println((int)Math.pow(2,cnt));\n    // //    long n=sc.nextLong();\n    // //    long k=sc.nextLong();\n    // }\n\n   \n\n    /*---------------------------------------------------------------------------------- */\n    public int upper_bound(int[] a  , int k ){\n        int n= a.length;\n        int e=n-1,s=0;\n        while(s<=e){\n            int mid =(s+e)/2;\n            \n            if(a[mid]>k){\n                e=mid-1;\n            }\n            else{\n                s=mid+1;\n            }\n        }\n        if(s>n-1)return -1;        \n        return s;\n    }\n   \n    public int upper_bound(ArrayList<Integer> a  , int k ){\n        int n= a.size();\n        int e=n-1,s=0;\n        while(s<=e){\n            int mid =(s+e)/2;\n            \n            if(a.get(mid)>k){\n                e=mid-1;\n            }\n            else{\n                s=mid+1;\n            }\n        }\n        if(s>n-1)return -1;        \n        return s;\n    }\n\n    public int lower_bound(ArrayList<Integer> a,int k){\n        int n= a.size();  \n        int e=n-1,s=0;\n        while(s<=e){\n            int mid =(s+e)/2;\n            \n            if(a.get(mid)>=k){\n                e=mid-1;\n            }\n            else{\n                s=mid+1; \n            }\n        }\n        if(e<0)return -1;         \n        return e;\n}\n\n    public int lower_bound(int a[],int k){\n            int n= a.length;  \n            int e=n-1,s=0;\n            while(s<=e){\n                int mid =(s+e)/2;\n                \n                if(a[mid]>=k){\n                    e=mid-1;\n                }\n                else{\n                    s=mid+1;\n                }\n            }\n            if(e<0)return -1;         \n            return e;\n    }\n   \n     public long[] prefixSum(int[] a) \n    {\n    \n        long[] sum = new long[a.length +1];\n        for(int i=1;i<a.length+1;i++) sum[i] =  sum[i-1]+(long)a[i-1];\n\n        return sum;\n    }\n\n    public long[] suffixSum(int[] a) \n    {\n\n        long[] sum = new long[a.length +1];\n        for(int i=a.length-1;i>=0;i--) sum[i] =  sum[i+1]+(long)a[i];\n        return sum;\n    \n    }   \n   \n   \n    public int __gcd(int a, int b) {\n    if (b == 0) {\n    \treturn a;\n    } else {\n    return __gcd(b, a % b);\n    }\n    }\n\n   \n    public long __gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        } else {\n        return __gcd(b, a % b);\n        }\n     }\n\n    \n    \n    \n    // public void run() throws FileNotFoundException {\n    //     if (filename == null) {\n    //         sc = new InputReader(System.in);\n    //     } else {\n    //         sc = new InputReader(new FileInputStream(filename));\n    //     }\n    \n    //     int nTests = sc.nextInt();\n    //     for (int test = 0; test < nTests; test++) {\n    //         // solve();\n    //     }\n    // }\n        \n    \n    //  public static void main(String[] args) {\n    //         template  sol = new template ();\n    //         try {\n    //             sol.run();\n    //         } catch (FileNotFoundException e) {\n    //             e.printStackTrace();\n    //         }\n    //     }\n     \n     \n        static class InputReader {\n            \n            public BufferedReader reader;\n            public StringTokenizer tokenizer;\n     \n            public InputReader(InputStream stream) {\n                reader = new BufferedReader(new InputStreamReader(stream));\n                tokenizer = null;\n            }\n     \n            public String next() {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    try {\n                        tokenizer = new StringTokenizer(reader.readLine());\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n                return tokenizer.nextToken();\n            }\n     \n            public int nextInt() {\n                return Integer.parseInt(next());\n            }\n     \n            public float nextFloat() {\n                return Float.parseFloat(next());\n            }\n     \n            public double nextDouble() {\n                return Float.parseFloat(next());\n            }\n     \n            public long nextLong() {\n                return Long.parseLong(next());\n            }\n            \n            public int[] nextArray(int n){\n                int[] a = new int[(n)];\n                for (int i = 0; i < n; i++) {\n                    a[i] = nextInt();\n                }\n                return a;\n            }\n\n            public char nextChar() {\n                return next().charAt(0);\n            }\n\n            public long[] nextArray(long n) {\n                long[] a = new long[(int)n];\n                for (int i = 0; i < n; i++) {\n                    a[i] = nextInt();\n                }\n                return a;\n            }\n        \n}\n    \n}\n\n",
    "submit_ts": "1723910291",
    "subm_id": "1359224574"
}