{
    "username": "TfVQQDhSj6",
    "submission": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 100000;\n\nstruct Node {\n    int sum;\n    int leftVal;\n    int isLeftReady;\n    int rightVal;\n    int isRightReady;\n    int left;\n    int right;\n\n    Node() {\n        sum = leftVal = rightVal = left = right = isLeftReady = isRightReady = 0;\n    }\n} node[N * 4 + 20];\n\nvoid merge(Node &rt, Node &left, Node &right) {\n    rt.sum = left.sum + right.sum;\n    if (left.isRightReady && left.rightVal > right.leftVal) {\n        rt.sum++;\n    } else if (right.isLeftReady && left.rightVal < right.leftVal) {\n        rt.sum++;\n    }\n    rt.leftVal = left.leftVal;\n    rt.rightVal = right.rightVal;\n    rt.isLeftReady = left.isLeftReady;\n    rt.isRightReady = right.isRightReady;\n    if (left.right - left.left == 0) {\n        if (left.leftVal > right.leftVal) {\n            rt.isLeftReady = 1;\n        }\n    }\n    if (right.right - right.left == 0) {\n        if (left.rightVal < right.leftVal) {\n            rt.isRightReady = 1;\n        }\n    }\n}\n\nvoid build(int rt, int left, int right, vector<int> &nums) {\n    node[rt].left = left;\n    node[rt].right = right;\n    if (left == right) {\n        node[rt].sum = 0;\n        node[rt].leftVal = node[rt].rightVal = nums[left - 1];\n        node[rt].isLeftReady = node[rt].isRightReady = 0;\n        return;\n    }\n    int mid = (left + right) / 2;\n    build(rt * 2, left, mid, nums);\n    build(rt * 2 + 1, mid + 1, right, nums);\n    merge(node[rt], node[rt * 2], node[rt * 2 + 1]);\n}\n\nNode query(int rt, int left, int right, int qLeft, int qRight) {\n    if (qLeft <= left && right <= qRight) {\n        return node[rt];\n    }\n    int mid = (left + right) / 2;\n    if (qRight <= mid) {\n        return query(rt * 2, left, mid, qLeft, qRight);\n    } else if (mid < qLeft) {\n        return query(rt * 2 + 1, mid + 1, right, qLeft, qRight);\n    } else {\n        Node a = query(rt * 2, left, mid, qLeft, mid);\n        Node b = query(rt * 2 + 1, mid + 1, right, mid + 1, qRight);\n        Node c;\n        c.left = qLeft;\n        c.right = qRight;\n        merge(c, a, b);\n        return c;\n    }\n}\n\nvoid update(int rt, int left, int right, int pos, int val) {\n    if (left == right && left == pos) {\n        node[rt].sum = 0;\n        node[rt].leftVal = node[rt].rightVal = val;\n        node[rt].isLeftReady = node[rt].isRightReady = 0;\n        return;\n    }\n    int mid = (left + right) / 2;\n    if (pos <= mid) update(rt * 2, left, mid, pos, val);\n    else update(rt * 2 + 1, mid + 1, right, pos, val);\n    merge(node[rt], node[rt * 2], node[rt * 2 + 1]);\n}\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int> &nums, vector<vector<int>> &queries) {\n        int n = nums.size();\n        build(1, 1, n, nums);\n        vector<int> ret;\n\n//        for (int i = 0; i < n * 3; ++i) {\n//            printf(\"rt[%d].sum=%d,(%d->%d) left = %d, right = %d, isL = %d, isR = %d\\n\",\n//                   i, node[i].sum, node[i].left, node[i].right, node[i].leftVal, node[i].rightVal, node[i].isLeftReady,\n//                   node[i].isRightReady);\n//        }\n        for (const auto &v: queries) {\n            if (v[0] == 1) {\n                auto ans = query(1, 1, n, v[1] + 1, v[2] + 1);\n                ret.emplace_back(ans.sum);\n            } else {\n                update(1, 1, n, v[1] + 1, v[2]);\n            }\n        }\n        return ret;\n    }\n};",
    "submit_ts": 1718507923.0
}