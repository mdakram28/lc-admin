{
    "username": "tommy787576",
    "submission": "// queries[i] = [1, li, ri], determine the count of peak elements in the subarray nums[li..ri].\n// how to determine in O(logN)\n\n// segment tree\n// nums = [4,1,4,2,1,5]\n\n// if front[2] > front[1] && front[2] < back[0]:\n//     peak++\n// if back[0] > front[2] && back[0] < back[1]:\n//     peak++\n// [4,1,4],[2,1,5]\n\n// Node {\n//     int start, end;\n//     int numPeak;\n// }\n\n\n// [4,1,4,2]\n\n    \nclass Solution {\nprivate:\n    struct Node {\n        int start, end, numPeaks;\n        Node *left, *right;\n        Node(int _start, int _end): start(_start), end(_end), numPeaks(0), left(nullptr), right(nullptr) {}\n    };\n    Node *root;\n    int n;\n    Node *construct(vector<int>& nums, int start, int end) {\n        if (start == end)\n            return new Node(start, end);    // leaf node\n        int mid = start + (end - start) / 2;\n        Node *curr = new Node(start, end);\n        curr->left = construct(nums, start, mid);\n        curr->right = construct(nums, mid + 1, end);\n        curr->numPeaks = curr->left->numPeaks + curr->right->numPeaks;\n        // check nums[curr->left->end] is peak\n        if (curr->left->start != curr->left->end && nums[curr->left->end] > nums[curr->left->end - 1] && nums[curr->left->end] > nums[curr->right->start])\n            curr->numPeaks++;\n        // check nums[curr->right->start] is peak\n        if (curr->right->start != curr->right->end && nums[curr->right->start] > nums[curr->left->end] && nums[curr->right->start] > nums[curr->right->start + 1])\n            curr->numPeaks++;\n        return curr;\n    }\n    int queryRange(vector<int>& nums, Node *curr, int start, int end) {\n        if (curr->start == start && curr->end == end)\n            return curr->numPeaks;\n        int mid = curr->start + (curr->end - curr->start) / 2;\n        if (end <= mid)\n            return queryRange(nums, curr->left, start, end);\n        else if (start > mid)\n            return queryRange(nums, curr->right, start, end);\n        else {\n            int cnt = queryRange(nums, curr->left, start, mid);\n            cnt += queryRange(nums, curr->right, mid + 1, end);\n            if (start != curr->left->end && nums[curr->left->end] > nums[curr->left->end - 1] && nums[curr->left->end] > nums[curr->right->start])\n                cnt++;\n            if (curr->right->start != end && nums[curr->right->start] > nums[curr->left->end] && nums[curr->right->start] > nums[curr->right->start + 1])\n                cnt++;\n            return cnt;\n        }   \n    }\n    void update(vector<int>& nums, Node *curr, int idx) {\n        if (curr->start == idx && curr->end == idx) {\n            return;\n        }\n        int mid = curr->start + (curr->end - curr->start) / 2;\n        if (idx <= mid)\n            update(nums, curr->left, idx);\n        else\n            update(nums, curr->right, idx);\n        curr->numPeaks = curr->left->numPeaks + curr->right->numPeaks;\n        // check nums[curr->left->end] is peak\n        if (curr->left->start != curr->left->end && nums[curr->left->end] > nums[curr->left->end - 1] && nums[curr->left->end] > nums[curr->right->start])\n            curr->numPeaks++;\n        // check nums[curr->right->start] is peak\n        if (curr->right->start != curr->right->end && nums[curr->right->start] > nums[curr->left->end] && nums[curr->right->start] > nums[curr->right->start + 1])\n            curr->numPeaks++;\n        return;\n    }\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        n = nums.size();\n        root = construct(nums, 0, n - 1);\n        vector<int> ans;\n        for (auto& query : queries) {\n            if (query[0] == 1) {\n                ans.push_back(queryRange(nums, root, query[1], query[2]));\n            }\n            else {\n                nums[query[1]] = query[2];\n                update(nums, root, query[1]);\n            }\n        }\n        return std::move(ans);\n    }\n};",
    "submit_ts": 1718509431.0
}