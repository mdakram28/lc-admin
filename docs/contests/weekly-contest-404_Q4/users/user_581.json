{
    "username": "hurryhao",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        vector<int> a = find(edges1), b = find(edges2);\n        cout<<a[0]<<\" \"<<a[1]<<\",\"<<b[0]<<\" \"<<b[1]<<endl;\n        return max(max(a[1],b[1]),a[0]+b[0]+1);\n    }\n    vector<int> find(vector<vector<int>>& es) { // {lowest tree height, longest path in es}\n        int n=es.size()+1; // number of nodes\n        if (n==1) return vector<int>{0,0};\n        if (n==2) return vector<int>{1,1};\n        if (n==3) return vector<int>{1,2};\n        vector<int> c(n,0); // count of connections\n        vector<unordered_set<int>> m(n, unordered_set<int>());\n        for (auto &e: es) {\n            ++c[e[0]];\n            ++c[e[1]];\n            m[e[0]].insert(e[1]);\n            m[e[1]].insert(e[0]);\n        }\n        vector<int> q;\n        for (int i=0; i<n;++i) {\n            if (c[i]==1) q.push_back(i); // count 1 connection\n        }\n        vector<int> l(n,-1); // paths to leaf\n        int p=0;\n        while (!q.empty()) {\n            if (q.size()==1) return vector<int>{p,p+p};\n            if (q.size()==2 && m[q[0]].contains(q[1])) return vector<int>{p+1,p+p+1};\n            vector<int> nq;\n            for (int a: q) {\n                if (l[a]<0) {\n                    l[a]=p;\n                    for (int b: m[a]) {\n                        if (l[b]>=0) continue;\n                        if (--c[b]==1) nq.push_back(b);\n                    }\n                }\n            }\n            swap(q,nq);\n            ++p;\n        }\n        return vector<int>{p,p+p};\n    }\n};",
    "submit_ts": 1719719778.0
}