{
    "username": "topo1993",
    "submission": "class SegmentTree:\n    # efficient iterative version, implemented by LeonDong1993 (LeonDong1993@gmail.com)\n    # adapted from https://codeforces.com/blog/entry/18051\n    # support single update and query such as range max, min, sum, gcd, max with count, etc.\n    def __init__(self, n, merge, default = 0):\n        self.n = n\n        self.tree = [default] * (n<<1)\n        self.merge = merge\n        self.default = default\n\n    def query(self, l, r, default = None):\n        # on a close interval [l,r], 0-indexed\n        l += self.n\n        r += self.n\n        ans = default if default is not None else self.default\n\n        while l <= r:\n            if l & 1:\n                ans = self.merge(ans, self.tree[l])\n                l += 1\n            if not r & 1:\n                ans = self.merge(ans, self.tree[r])\n                r -= 1\n            l >>= 1\n            r >>= 1\n        return ans\n\n    def update(self, i, v):\n        # update arr[i] to v, 0-indexed\n        i += self.n\n        self.tree[i] = v # or self.merge(self.tree[i], v)\n        while i > 1:\n            i >>= 1\n            self.tree[i] = self.merge(self.tree[i<<1], self.tree[i<<1 | 1])\n\n    def build(self, arr):\n        assert(len(arr) == self.n), 'Size Mismatch!'\n\n        for i in range(self.n):\n            self.tree[i + self.n] = arr[i]\n\n        for i in range(n-1,0,-1):\n            self.tree[i] = self.merge(self.tree[i<<1], self.tree[i<<1 | 1])\n        return self\n\npush = heapq.heappush\n\npop = heapq.heappop\n\nclass Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        \n        def get_max_dist_pair():\n            low = []\n            high = []\n            pts = sorted(points)\n            # if y2 > y1 then save x1 + y1, want x2+y2 - minimum\n            # if y2 < y1 then save x1- y1, want x2-y2 - minimum\n            \n            dist = -1\n            ans = None\n            for i,(x,y) in enumerate(pts):\n                if len(low):\n                    v, j = low[0]\n                    cur = x+y - v\n                    if cur > dist:\n                        dist = cur\n                        ans = (i,j)\n                \n                if len(high):\n                    v,j = high[0]\n                    cur = x-y-v\n                    if cur > dist:\n                        dist = cur\n                        ans = (i,j)\n                        \n                push(low, (x+y ,i))\n                push(high, (x-y, i))\n                        \n            \n            return ans, dist\n        \n        # get dist info\n        points.sort()\n        (i,j), _ = get_max_dist_pair()\n        pi, pj = points[i], points[j]\n        \n        # try first way\n        points[i] = pj\n        _, ans1 = get_max_dist_pair()\n        \n        # try another way\n        points[i] = pi\n        points[j] = pi\n        _, ans2 = get_max_dist_pair()\n        \n        return min(ans1,ans2)\n        \n                    \n                \n            \n            \n            \n            \n            \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n    "
}