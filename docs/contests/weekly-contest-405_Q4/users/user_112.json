{
    "username": "derkach",
    "submission": "bool cmp(pair<long long,pair<int,int> > &a, pair<long long,pair<int,int> > &b){\n        return(a.second < b.second);\n    }\nclass Solution {\npublic:\n\n    long long hashing[100000];\n    long long prime = 71;\n    long long md = 1e9 + 7;\n    long long p[100000];\n    long long dp[100000];\n    long long inf = 1e18;\n    map<long long,char> was;\n\n    void updMin(long long &a,long long b){\n        if(b < a)a = b;\n    }\n\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        vector<pair<long long,pair<int,int> > > H;\n\n        vector<pair<string,int> > WORDS;\n        for(int i = 0; i < words.size(); ++i){\n            WORDS.push_back({words[i], costs[i]});\n        }\n\n        sort(WORDS.begin(),WORDS.end());\n        pair<string,int> s = WORDS[0];\n\n        vector<string> words_;\n        vector<int> costs_;\n\n        words_.push_back(s.first);\n        costs_.push_back(s.second);\n        for(int i = 1; i < WORDS.size(); ++i){\n            if(WORDS[i].first != s.first){\n                words_.push_back(WORDS[i].first);\n                costs_.push_back(WORDS[i].second);\n                s = WORDS[i];\n            }\n        }\n\n        p[0] = prime;\n        int N = (int)target.size();\n        for(int i = 1; i <= N; ++i){\n            p[i] = p[i - 1] * prime % md;\n        }\n        for(int i = 1; i <= N; ++i){\n            hashing[i] = (hashing[i - 1] + p[i - 1] * (long long)(target[i - 1]) % md) % md;\n        }\n\n        dp[0] = 0;\n        for(int i = 1; i <= N; ++i){\n            dp[i] = inf;\n        }\n\n        for(int i = 0; i < words_.size(); ++i){\n            long long hash = 0;\n            long long len = (int)words_[i].size();\n            if(len <= N){\n                for(int j = 0; j < len; ++j){\n                    hash += p[j] * (long long)(words_[i][j]) % md;\n                    hash %= md;\n                }\n                hash = hash * p[N - len] % md;\n                if(!was[hash]){\n                    was[hash] = 1;\n                    H.push_back(make_pair(hash, make_pair(len, costs_[i])));\n                }\n            }\n        }\n\n        sort(H.begin(),H.end(),&cmp);\n\n        for(int i = 0; i < N; ++i){\n            if(dp[i] != inf){\n                for(int j = 0; j < H.size(); ++j){\n                    int len = H[j].second.first;\n                    if(i + len > N)break;\n                    int hash1 = (hashing[i + len] - hashing[i] + md) * p[N - (i + len)] % md;\n                    int hash2 = H[j].first;\n                    if(hash1 == hash2){\n                        updMin(dp[i + len], dp[i] + H[j].second.second);\n                    }\n                }\n            }\n        }\n\n        if(dp[N] == inf)return -1;\n        return dp[N];\n\n    }\n};",
    "submit_ts": "1720320802",
    "subm_id": "1312304958"
}