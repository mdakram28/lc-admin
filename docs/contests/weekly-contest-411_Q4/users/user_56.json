{
    "username": "ghj123h",
    "submission": "public class Solution {\n    public long[] CountKConstraintSubstrings(string s, int k, int[][] queries) {\n        int l = 0, n = s.Length, m = queries.Length;\n        long[] pre = new long[n+1];\n        for (int i = 0; i < n; ++i) pre[i+1] = s[i] - '0' + pre[i];\n        long[] ans = new long[m];\n        var idx = Enumerable.Range(0, m).OrderBy(i => queries[i][1]).ToArray();\n        int j = 0;\n        LazySegTree seg = new(new long[n]);\n        for (int r = 0; r < s.Length; ++r) {\n            while (pre[r+1] - pre[l] > k && r - l + 1 - (pre[r+1] - pre[l]) > k) ++l;\n            seg.Update(l, r, 1);\n            while (j < m && queries[idx[j]][1] == r) {\n                ans[idx[j]] = seg.Query(queries[idx[j]][0], queries[idx[j]][1]);\n                j++;\n            }\n        }\n        return ans;\n    }\n}\n\npublic class LazySegTree {\n    private long[] tree, lazy;\n    private int n;\n\n    private void Build(long[] arr, int v, int l, int r) {\n        if (l == r) tree[v] = arr[l];\n        else {\n            int m = l + (r - l) / 2;\n            Build(arr, v * 2 + 1, l, m);\n            Build(arr, v * 2 + 2, m + 1, r);\n            tree[v] = tree[v*2+1] + tree[v*2+2];\n        }\n    }\n    private void Push(int v, int l, int r) {\n        int m = l + (r - l) / 2;\n        if (l < r && lazy[v] > 0) {\n            tree[v*2+1] += (m - l + 1) * lazy[v]; lazy[v*2+1] += lazy[v];\n            tree[v*2+2] += (r - m) * lazy[v]; lazy[v*2+2] += lazy[v];\n            lazy[v] = 0;\n        }\n    }\n    private void Update(int v, int L, int R, int l, int r, long add) {\n        if (l == L && r == R) {\n            tree[v] += (R - L + 1) * add;\n            lazy[v] += add;\n        } else if (L <= R) {\n            Push(v, l, r);\n            int m = l + (r - l) / 2;\n            Update(v * 2 + 1, L, Math.Min(R, m), l, m, add);\n            Update(v * 2 + 2, Math.Max(L, m + 1), R, m + 1, r, add);\n            tree[v] = tree[v*2+1] + tree[v*2+2];\n        }\n    }\n    private long Query(int v, int L, int R, int l, int r) {\n        if (L > R) return 0;\n        else if (l >= L && r <= R) return tree[v];\n        Push(v, l, r);\n        int m = l + (r - l) / 2;\n        long left = Query(v * 2 + 1, L, Math.Min(R, m), l, m);\n        long right = Query(v * 2 + 2, Math.Max(L, m + 1), R, m + 1, r);\n        return left + right;\n    }\n\n    public LazySegTree(long[] arr) {\n        n = arr.Length;\n        tree = new long[n * 4]; lazy = new long[n * 4];\n        Build(arr, 0, 0, n - 1);\n    }\n    public void Update(int L, int R, long add) => Update(0, L, R, 0, n - 1, add);\n    public long Query(int L, int R) => Query(0, L, R, 0, n - 1);\n}",
    "submit_ts": "1723951424",
    "subm_id": "556405339"
}