{
    "username": "sudharshan281",
    "submission": "class Solution {\npublic:\n typedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<ld> vld;\ntypedef vector<pair<ll , ll>> vpll;\ntypedef vector<pair<ld , ld>> vplld;\ntypedef pair<int,int> pii;\ntypedef vector<pair<int,int>> vpii;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> pll;\ntypedef priority_queue<ll> pq;\ntypedef priority_queue<pair<ll,ll>> pqp;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define endl \"\\n\"\n#define yes cout<<\"YES\"\n#define no cout<<\"NO\"\n#define graph vector<vector<array<int,2>>>\n#define all(x) x.begin(), x.end()\nconst int mod = (int)1e9 + 7;\n\n int d[100004]{};\n  \n  \n\nvoid get_dist(int id, vi& d, graph &g, int p =-1, int dist = 0){\n        d[id] = dist;\n        for(auto &xa : g[id]){\n            int x = xa[0], w = xa[1];\n            w = (x%2 == 0) + 1;\n            if(x != p){\n                get_dist(x, d, g, id, dist+w);\n            }\n        }\n    }\n\n    int max_dist(int id, int p, graph &g){\n        int res = 0;\n        for(auto &xa :g[id]){\n            int x = xa[0], w = xa[1];\n            w = (x%2 == 0) + 1;\n            if( x != p){\n                res = max(res, w + max_dist(x, id, g));\n            }\n        }\n        return res;\n    }\n\n    \n    int diameter(graph &g){\n        int sz = g.size();\n        vi d(sz+1, 0);\n        get_dist(0,d,g);\n        int mx = *max_element(d.begin(), d.end()), node_u;\n        for(int i=0; i<sz; ++i){\n            if(d[i] == mx){\n                node_u = i;\n                break;\n            }\n        }\n        return max_dist(node_u, -1, g);\n    }\n    \n    \n\n\n \nvoid dfs(int id, int p , graph &g, vi& f, vi &s, vi &c){\n\tf[id] = 0;\n\ts[id] = 0;\n\tfor(auto &xa : g[id]){\n        int x = xa[0], w = xa[1];\n        w = (x%2 == 0)+ 1;\n\t\tif(x == p)continue;\n\t\tdfs(x,id, g,f,s,c);\n\t\tif(f[x] + w > f[id]){\n\t\t\ts[id] = f[id];\n\t\t\tf[id] = w + f[x];\n\t\t\tc[id] = x;\n\t\t}\n\t\telse if(f[x] + w > s[id]){\n\t\t\ts[id] = w + f[x];\n\t\t}\n\t}\n}\n \nvoid dfs2(int id, int p , graph &g, vi& f, vi &s, vi &c){\n\tfor(auto &xa : g[id]){\n        int x = xa[0], w = xa[1];\n        w = (id%2 == 0)+ 1;\n\t\tif(x == p)continue;\n        // cout<<\"ID: \"<<id<<endl;\n        // cout<<w<<\" w\\n\";\n\t\tif(c[id] == x){\n\t\t\tif(f[x] < s[id] + w){\n\t\t\t\ts[x] = f[x];\n\t\t\t\tf[x] = s[id] + w;\n\t\t\t\tc[x] = id;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts[x] = max(s[x], w + s[id]);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\ts[x] = f[x];\n\t\t\tf[x] = f[id] + w;\n\t\t\tc[x] = id;\n\t\t}\n\t\tdfs2(x,id, g,f,s,c);\n\t}\n}\n\n\n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        graph g(n);\n        vi res(n);\n        for(auto &x : edges){\n            int u = x[0], v= x[1];\n            int t1 = u&1, t2 = v&1;\n            if(t1 == 0){\n                g[v].pb({u, 2});\n            }\n            else{\n                g[v].pb({u, 1});\n            }\n            if(t2 == 0){\n                g[u].pb({v, 2});\n            }\n            else{\n                g[u].pb({v, 1});\n            }\n        }\n        vi f1(n),c1(n), c2(n), s1(n), s2(n), f2(n);\n        vi dp1(n),dp2(n);\n        dfs(0,-1,g,f1,s1,c1);\n        // dfs(0,-1,g2,f2,s2,c2);\n        dfs2(0,-1,g,f1,s1,c1);\n        // dfs2(0,-1,g2,f2,s2,c2);\n        for(int i=0; i<n; ++i){\n            res[i] = f1[i] ;\n        }\n        return res;\n    }\n};",
    "submit_ts": "1722699720",
    "subm_id": "1343220229"
}