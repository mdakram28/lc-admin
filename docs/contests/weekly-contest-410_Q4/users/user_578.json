{
    "username": "cslasher",
    "submission": "const MOD = 1e9 + 7;\n\nclass SegmentTree {\n  constructor(size) {\n    this.size = size;\n    this.tree = Array(2 * size).fill(0);\n  }\n\n  update(index, value) {\n    index += this.size;\n    this.tree[index] = (this.tree[index] + value) % MOD;\n    while (index > 1) {\n      index >>= 1;\n      this.tree[index] = (this.tree[2 * index] + this.tree[2 * index + 1]) % MOD;\n    }\n  }\n\n  query(left, right) {\n    left += this.size;\n    right += this.size + 1;\n    let sum = 0;\n    while (left < right) {\n      if (left & 1) sum = (sum + this.tree[left++]) % MOD;\n      if (right & 1) sum = (sum + this.tree[--right]) % MOD;\n      left >>= 1;\n      right >>= 1;\n    }\n    return sum;\n  }\n}\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar countOfPairs = function(nums) {\n  const n = nums.length;\n  const maxVal = Math.max(...nums);\n\n  // dp[i][j] represents the number of ways to reach arr1[i] = j.\n  const dp = Array.from({ length: n }, () => Array(maxVal + 1).fill(0));\n  let segTree = new SegmentTree(maxVal + 1);\n\n  // Initialize the segment tree for the first row\n  for (let j = 0; j <= nums[0]; j++) {\n    dp[0][j] = 1;\n    segTree.update(j, dp[0][j]);\n  }\n\n  for (let i = 1; i < n; i++) {\n    let newSegTree = new SegmentTree(maxVal + 1);\n\n    for (let j = 0; j <= nums[i]; j++) {  // arr1[i] = j\n      const arr2 = nums[i] - j;\n      if (arr2 >= 0) {\n        // Only consider valid transitions where arr2[i-1] >= arr2\n        const maxK = Math.min(j, nums[i-1] - arr2);\n        dp[i][j] = segTree.query(0, maxK); // Sum valid previous states\n        newSegTree.update(j, dp[i][j]); // Update new segment tree state\n      }\n    }\n\n    // Move to the next state\n    segTree = newSegTree;\n  }\n\n  // Sum all valid final states\n  let result = 0;\n  for (let j = 0; j <= nums[n - 1]; j++) {\n    result = (result + dp[n - 1][j]) % MOD;\n  }\n\n  return result;\n};",
    "submit_ts": "1723348080",
    "subm_id": "1351611190"
}