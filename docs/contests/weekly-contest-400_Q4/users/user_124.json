{
    "username": "tushar_1290",
    "submission": "#include <vector>\n#include <unordered_map>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    \n            // Helper function to get set bit indices\n        vector<int> get_set_bits(int x) {\n            vector<int> bits;\n            for (int i = 0; x > 0; i++, x >>= 1) {\n                if (x & 1) {\n                    bits.push_back(i);\n                }\n            }\n            return bits;\n        }\n\n        // Helper function to calculate bitwise AND from bit counts\n        int counts_to_bitwise_and(int window_length, unordered_map<int, int>& bit_counts) {\n            int result = 0;\n            for (const auto& [key, count] : bit_counts) {\n                if (count == window_length) {\n                    result |= (1 << key);\n                }\n            }\n            return result;\n        }\n    \n    int minimumDifference(vector<int>& nums, int target) {\n\n\n        int current_AND_value = nums[0];\n        int best_diff = abs(current_AND_value - target);\n\n        unordered_map<int, int> window_bit_counts;\n        for (int bit : get_set_bits(nums[0])) {\n            window_bit_counts[bit]++;\n        }\n\n        int left_idx = 0, right_idx = 0;\n        while (right_idx < nums.size()) {\n            // Expand the window to decrease & value\n            if (current_AND_value > target || left_idx > right_idx) {\n                right_idx++;\n                if (right_idx >= nums.size()) break;\n                for (int bit : get_set_bits(nums[right_idx])) {\n                    window_bit_counts[bit]++;\n                }\n            }\n            // Shrink the window to increase & value\n            else {\n                for (int bit : get_set_bits(nums[left_idx])) {\n                    if (--window_bit_counts[bit] == 0) {\n                        window_bit_counts.erase(bit);\n                    }\n                }\n                left_idx++;\n            }\n\n            current_AND_value = counts_to_bitwise_and(right_idx - left_idx + 1, window_bit_counts);\n\n            // No nonempty arrays allowed\n            if (left_idx <= right_idx) {\n                best_diff = min(best_diff, abs(current_AND_value - target));\n            }\n        }\n\n        return best_diff;\n    }\n};\n",
    "submit_ts": 1717297391.0
}