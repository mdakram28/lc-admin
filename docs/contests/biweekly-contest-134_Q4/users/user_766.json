{
    "username": "jin-yu-man-tang-7",
    "submission": "class SegTree:\n    __slots__ = {'n', 'op', 'e', 'log', 'size', 'd'}\n\n    def __init__(self, OP, E, V):\n        '''\n        V: \u539f\u59cb\u6570\u7ec4\n        OP: \u7ef4\u62a4\u7684\u8fd0\u7b97(min, max, sum...)\n        E: \u7ebf\u6bb5\u6811\u521d\u503c\n        '''\n        self.n = len(V)\n        self.op = OP\n        self.e = E\n        self.log = (self.n - 1).bit_length()\n        self.size = 1 << self.log\n        self.d = [E for _ in range(2 * self.size)]\n        for i in range(self.n):\n            self.d[self.size + i] = V[i]\n        for i in range(self.size - 1, 0, -1):\n            self.update(i)\n\n    def set(self, p, x):\n        assert 0 <= p and p < self.n\n        p += self.size\n        self.d[p] = x\n        for i in range(1, self.log + 1):\n            self.update(p >> i)\n\n    def get(self, p):\n        assert 0 <= p and p < self.n\n        return self.d[p + self.size]\n\n    def prod(self, l, r):\n        # [l, r)\n        assert 0 <= l and l <= r and r <= self.n\n        sml = self.e\n        smr = self.e\n        l += self.size\n        r += self.size\n\n        while (l < r):\n            if (l & 1):\n                sml = self.op(sml, self.d[l])\n                l += 1\n            if (r & 1):\n                smr = self.op(self.d[r - 1], smr)\n                r -= 1\n            l >>= 1\n            r >>= 1\n        return self.op(sml, smr)\n\n    def all_prod(self):\n        return self.d[1]\n\n    def max_right(self, l, f):\n        assert 0 <= l and l <= self.n\n        assert f(self.e)\n        if l == self.n:\n            return self.n\n        l += self.size\n        sm = self.e\n        while (1):\n            while (l % 2 == 0):\n                l >>= 1\n            if not (f(self.op(sm, self.d[l]))):\n                while (l < self.size):\n                    l = 2 * l\n                    if f(self.op(sm, self.d[l])):\n                        sm = self.op(sm, self.d[l])\n                        l += 1\n                return l - self.size\n            sm = self.op(sm, self.d[l])\n            l += 1\n            if (l & -l) == l:\n                break\n        return self.n\n\n    def min_left(self, r, f):\n        assert 0 <= r and r <= self.n\n        assert f(self.e)\n        if r == 0:\n            return 0\n        r += self.size\n        sm = self.e\n        while (1):\n            r -= 1\n            while (r > 1 & (r % 2)):\n                r >>= 1\n            if not (f(self.op(self.d[r], sm))):\n                while (r < self.size):\n                    r = (2 * r + 1)\n                    if f(self.op(self.d[r], sm)):\n                        sm = self.op(self.d[r], sm)\n                        r -= 1\n                return r + 1 - self.size\n            sm = self.op(self.d[r], sm)\n            if (r & -r) == r:\n                break\n        return 0\n\n    def update(self, k):\n        self.d[k] = self.op(self.d[2 * k], self.d[2 * k + 1])\n\n    def __str__(self):\n        return ([str(self.get(i)) for i in range(self.n)])\n\nfrom operator import and_\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        res = 0\n        seg = SegTree(and_, (1 << 31) - 1, nums)\n        for i, x in enumerate(nums):\n            R = seg.max_right(i, lambda x:  x >= k)\n            #print(R)\n            L = seg.max_right(i, lambda x: x > k)\n            res += R - L\n        return res\n        # res = 0\n        # a = []\n        # for x in nums:\n        #     a = [x & y for y in a]\n        #     a.append(x)\n        #     a.sort(reverse=True)\n        #     while a and a[-1] < k:\n        #         a.pop()\n        #     for x in a:\n        #         if x == k:\n        #             res += 1\n        # return res",
    "submit_ts": "1720278839",
    "subm_id": "544564642"
}