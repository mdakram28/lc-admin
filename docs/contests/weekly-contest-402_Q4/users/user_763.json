{
    "username": "LGM70",
    "submission": "import java.util.*;\n\nclass Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        List<Integer> res = new ArrayList<>();\n        SegmentTree segmentTree = new SegmentTree(0, nums.length, nums);\n        for (int[] query : queries) {\n            if (query[0] == 1) {\n                res.add(segmentTree.query(query[1], query[2] + 1));\n            }\n            else {\n                segmentTree.update(query[1], query[2]);\n            }\n        }\n        return res;\n    }\n\n    class SegmentTree {\n        int[] nums;\n        int lt;\n        int rt;\n        int peakCnt;\n        SegmentTree left;\n        SegmentTree right;\n\n        SegmentTree(int lt, int rt, int[] nums) {\n            this.lt = lt;\n            this.rt = rt;\n            this.nums = nums;\n            int mid = (lt + rt) / 2;\n            if (lt < rt - 1) {\n                left = new SegmentTree(lt, mid, nums);\n                right = new SegmentTree(mid, rt, nums);\n            }\n            peakCnt = calPeak();\n        }\n\n        int calPeak() {\n            if (left == null && right == null) {\n                return 0;\n            }\n            else if (left == null) {\n                return right.peakCnt;\n            }\n            else if (right == null) {\n                return left.peakCnt;\n            }\n            else {\n                int mid = (lt + rt) / 2;\n                if (mid + 1 < rt && nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {\n                    return left.peakCnt + right.peakCnt + 1;\n                } else if (mid - 2 >= lt && nums[mid] < nums[mid - 1] && nums[mid - 1] > nums[mid - 2]) {\n                    return left.peakCnt + right.peakCnt + 1;\n                }\n                else {\n                    return left.peakCnt + right.peakCnt;\n                }\n            }\n        }\n\n        void update(int index, int val) {\n            if (lt == rt - 1 && lt == index) {\n                nums[index] = val;\n            }\n            else {\n                int mid = (lt + rt) / 2;\n                if (index < mid) {\n                    left.update(index, val);\n                }\n                else {\n                    right.update(index, val);\n                }\n                peakCnt = calPeak();\n            }\n        }\n\n        int query(int lt, int rt) {\n            if (lt == this.lt && rt == this.rt) {\n                return peakCnt;\n            }\n            int mid = (this.lt + this.rt) / 2;\n            if (rt <= mid) {\n                return left.query(lt, rt);\n            }\n            else if (lt >= mid) {\n                return right.query(lt, rt);\n            }\n            else {\n                int res = left.query(lt, mid);\n                res += right.query(mid, rt);\n                if (mid + 1 < rt && nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {\n                    res++;\n                } else if (mid - 2 >= lt && nums[mid] < nums[mid - 1] && nums[mid - 1] > nums[mid - 2]) {\n                    res++;\n                }\n                return res;\n            }\n        }\n    }\n}",
    "submit_ts": 1718507819.0
}