{
    "username": "rutvikjakasaniya",
    "submission": "class Solution {\n    public boolean canReachCorner(int width, int height, int[][] circleData) {\n        int numCircles = circleData.length;\n        List<int[]> circles = Arrays.asList(circleData);\n        List<List<Integer>> adjacencyList = createAdjacencyList(numCircles);\n\n        populateAdjacencyList(adjacencyList, circles, width, height);\n\n        boolean isBlocked = isPathBlocked(adjacencyList, numCircles, numCircles + 1, numCircles + 2, numCircles + 4);\n        isBlocked |= isPathBlocked(adjacencyList, numCircles + 3, numCircles + 2, numCircles + 1, numCircles + 4);\n\n        return !isBlocked;\n    }\n\n    private List<List<Integer>> createAdjacencyList(int numCircles) {\n        List<List<Integer>> adjacencyList = new ArrayList<>(numCircles + 4);\n        for (int i = 0; i < numCircles + 4; i++) {\n            adjacencyList.add(new ArrayList<>());\n        }\n        return adjacencyList;\n    }\n\n    private void populateAdjacencyList(List<List<Integer>> adjacencyList, List<int[]> circles, int width, int height) {\n        int numCircles = circles.size();\n        for (int i = 0; i < numCircles; ++i) {\n            int x = circles.get(i)[0];\n            int y = circles.get(i)[1];\n            int radius = circles.get(i)[2];\n\n            connectBorderNodes(adjacencyList, i, x, y, radius, width, height);\n            connectCircleNodes(adjacencyList, circles, i, x, y, radius);\n        }\n    }\n\n    private void connectBorderNodes(List<List<Integer>> adjacencyList, int i, int x, int y, int radius, int width, int height) {\n        int numCircles = adjacencyList.size() - 4;\n        if (x <= radius) {\n            adjacencyList.get(numCircles).add(i);\n            adjacencyList.get(i).add(numCircles);\n        }\n        if (width - x <= radius) {\n            adjacencyList.get(numCircles + 2).add(i);\n            adjacencyList.get(i).add(numCircles + 2);\n        }\n        if (y <= radius) {\n            adjacencyList.get(numCircles + 1).add(i);\n            adjacencyList.get(i).add(numCircles + 1);\n        }\n        if (height - y <= radius) {\n            adjacencyList.get(numCircles + 3).add(i);\n            adjacencyList.get(i).add(numCircles + 3);\n        }\n    }\n\n    private void connectCircleNodes(List<List<Integer>> adjacencyList, List<int[]> circles, int i, int x, int y, int radius) {\n        int numCircles = circles.size();\n        for (int j = i + 1; j < numCircles; ++j) {\n            int x2 = circles.get(j)[0];\n            int y2 = circles.get(j)[1];\n            int radius2 = circles.get(j)[2];\n            double distance = Math.hypot(x - x2, y - y2);\n            int radiusSum = radius + radius2;\n            if (radiusSum >= distance) {\n                adjacencyList.get(i).add(j);\n                adjacencyList.get(j).add(i);\n            }\n        }\n    }\n\n    private boolean isPathBlocked(List<List<Integer>> adjacencyList, int startNode, int targetNode1, int targetNode2, int totalNodes) {\n        return bfs(adjacencyList, startNode, targetNode1, targetNode2, totalNodes);\n    }\n\n    private boolean bfs(List<List<Integer>> adjacencyList, int startNode, int targetNode1, int targetNode2, int totalNodes) {\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] visited = new boolean[totalNodes + 4];\n        queue.add(startNode);\n        visited[startNode] = true;\n\n        while (!queue.isEmpty()) {\n            int currentNode = queue.poll();\n            for (int neighbor : adjacencyList.get(currentNode)) {\n                if (!visited[neighbor]) {\n                    queue.add(neighbor);\n                    visited[neighbor] = true;\n                }\n            }\n        }\n        return visited[targetNode1] || visited[targetNode2];\n    }\n\n}",
    "submit_ts": "1722136515",
    "subm_id": "1335736902"
}