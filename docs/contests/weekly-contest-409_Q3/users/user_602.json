{
    "username": "megaspazz",
    "submission": "class Solution {\n    public int[] shortestDistanceAfterQueries(int n, int[][] queries) {\n        final int Q = queries.length;\n        \n        // PrimitiveArraySegmentTree st = PrimitiveArraySegmentTree.newWithSize(n);\n//         PrimitiveAVLSegmentTree st = new PrimitiveAVLSegmentTree();\n        \n//         int[] ans = new int[Q];\n//         for (int q = 0; q < Q; ++q) {\n//             final int u = queries[q][0];\n//             final int v = queries[q][1];\n            \n//             int prev = v + st.get(0, v);\n//             int next = u + st.get(0, u) + 1;\n//             int delta = Math.min(next - prev, 0);\n//             st.increment(v, delta);\n            \n//             int stop = BinarySearch.firstThat(v + 1, n - 1, new BinarySearch.IntCheck() {\n//                 @Override\n//                 public boolean valid(int i) {\n//                     return i + \n//                 }\n//             });\n            \n//             System.out.format(\"q = %d, u = %d, v = %d, prev = %d, next = %d%n\", q, u, v, prev, next);\n            \n//             ans[q] = n - 1 + st.get(0, n - 1);\n//         }\n//         return ans;\n        \n        \n        TreeSet<Integer> ts = new TreeSet<>();\n        for (int i = 0; i < n; ++i) {\n            ts.add(i);\n        }\n        \n        int[] ans = new int[Q];\n        for (int q = 0; q < Q; ++q) {\n            final int u = queries[q][0];\n            final int v = queries[q][1];\n            \n            Integer x = ts.lower(v);\n            while (x != null & x > u) {\n                ts.remove(x);\n                x = ts.lower(x);\n            }\n            \n            ans[q] = ts.size() - 1;\n        }\n        return ans;\n    }\n    \n\t/**\n\t * Generic binary search to find the first or last value resulting in a matching condition.\n\t */\n\t// EXAMPLE USAGE (find insertion index in sorted array `A`):\n\t/*\n\t\tint insertionIndex = BinarySearch.firstThat(0, A.length, new BinarySearch.IntCheck() {\n\t\t\t@Override\n\t\t\tpublic boolean valid(int index) {\n\t\t\t\treturn A[index] > mid;\n\t\t\t}\n\t\t});\n\t */\n\tpublic static class BinarySearch {\n\t\t// Finds the left-most value that satisfies the IntCheck in the range [L, R).\n\t\t// It will return R if the nothing in the range satisfies the check.\n\t\tpublic static int firstThat(int L, int R, IntCheck check) {\n\t\t\twhile (L < R) {\n\t\t\t\tint M = (L >> 1) + (R >> 1) + (L & R & 1);\n\t\t\t\tif (check.valid(M)) {\n\t\t\t\t\tR = M;\n\t\t\t\t} else {\n\t\t\t\t\tL = M + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn L;\n\t\t}\n\n\t\t// Finds the right-most value that satisfies the IntCheck in the range [L, R).\n\t\t// It will return L - 1 if nothing in the range satisfies the check.\n\t\tpublic static int lastThat(int L, int R, IntCheck check) {\n\t\t\tint firstValue = firstThat(L, R, new IntCheck() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean valid(int value) {\n\t\t\t\t\treturn !check.valid(value);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn firstValue - 1;\n\t\t}\n\n\t\t// Finds the left-most value that satisfies the LongCheck in the range [L, R).\n\t\tpublic static long firstThat(long L, long R, LongCheck check) {\n\t\t\twhile (L < R) {\n\t\t\t\tlong M = (L >> 1) + (R >> 1) + (L & R & 1);\n\t\t\t\tif (check.valid(M)) {\n\t\t\t\t\tR = M;\n\t\t\t\t} else {\n\t\t\t\t\tL = M + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn L;\n\t\t}\n\n\t\t// Finds the right-most value that satisfies the IntCheck in the range [L, R).\n\t\t// It will return L - 1 if nothing in the range satisfies the check.\n\t\tpublic static long lastThat(long L, long R, LongCheck check) {\n\t\t\tlong firstValue = firstThat(L, R, new LongCheck() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean valid(long value) {\n\t\t\t\t\treturn !check.valid(value);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn firstValue - 1;\n\t\t}\n\n\t\tpublic static interface LongCheck {\n\t\t\tpublic boolean valid(long value);\n\t\t}\n\n\t\tpublic static interface IntCheck {\n\t\t\tpublic boolean valid(int value);\n\t\t}\n\t}\n    \n\t/**\n\t * PrimitiveAVLSegmentTree does generic range operations in O(log N) time.\n\t * Use your editor's find-and-replace to rename the types into primitives, since Java doesn't support generics of primitives.\n\t */\n\tpublic static class PrimitiveAVLSegmentTree {\n\t\t// Implement the key comparison function, return type should be same as Comparator.compare.\n\t\tprivate static int compareKey(int a, int b) {\n            return Integer.compare(a, b);\n\t\t}\n\n\t\t// Implement the value merge function.\n\t\tprivate static int mergeValue(int a, int b) {\n            return a + b;\n\t\t}\n\n\t\t// The default value if nothing in range.\n\t\tprivate static final int DEFAULT_VALUE = 0;\n\n\t\tprivate AVLTreeNode root;\n\n\t\tpublic void insert(int key, int value) {\n\t\t\tif (root == null) {\n\t\t\t\troot = new AVLTreeNode(key);\n\t\t\t}\n\t\t\troot.insert(key, value);\n\t\t\troot = rebalance(root);\n\t\t}\n\n\t\tpublic void increment(int key, int value) {\n\t\t\tinsert(key, mergeValue(get(key), value));\n\t\t}\n\n\t\tpublic int get(int k) {\n\t\t\tif (root == null) {\n\t\t\t\treturn DEFAULT_VALUE;\n\t\t\t}\n\t\t\treturn root.get(k);\n\t\t}\n\n\t\tpublic int get(int lo, int hi) {\n\t\t\tif (root == null) {\n\t\t\t\treturn DEFAULT_VALUE;\n\t\t\t}\n\t\t\treturn root.get(lo, hi);\n\t\t}\n\n\t\tprivate static class AVLTreeNode {\n\t\t\tprivate int key;\n\t\t\tprivate int val;\n\t\t\tprivate int sum;  // more of an accumulator than a true \"sum\"\n\t\t\tprivate int ht;\n\n\t\t\tprivate AVLTreeNode left;\n\t\t\tprivate AVLTreeNode right;\n\n\t\t\tpublic AVLTreeNode(int key) {\n\t\t\t\tthis.key = key;\n\t\t\t\tthis.val = DEFAULT_VALUE;\n\t\t\t}\n\n\t\t\tpublic void insert(int k, int v) {\n\t\t\t\tint c = compareKey(k, key);\n\t\t\t\tif (c < 0) {\n\t\t\t\t\tleft = getOrCreate(left, k);\n\t\t\t\t\tleft.insert(k, v);\n\t\t\t\t} else if (c > 0) {\n\t\t\t\t\tright = getOrCreate(right, k);\n\t\t\t\t\tright.insert(k, v);\n\t\t\t\t} else {\n\t\t\t\t\tval = v;\n\t\t\t\t}\n\t\t\t\tleft = rebalance(left);\n\t\t\t\tright = rebalance(right);\n\t\t\t\tupdate();\n\t\t\t}\n\n\t\t\tpublic int get(int k) {\n\t\t\t\treturn get(k, k);\n\t\t\t}\n\n\t\t\tpublic int get(int lo, int hi) {\n\t\t\t\tAVLTreeNode curr = this;\n\t\t\t\twhile (curr != null) {\n\t\t\t\t\tif (compareKey(lo, curr.key) <= 0 && compareKey(curr.key, hi) <= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (compareKey(hi, curr.key) < 0) {\n\t\t\t\t\t\tcurr = curr.left;\n\t\t\t\t\t} else if (compareKey(lo, curr.key) > 0) {\n\t\t\t\t\t\tcurr = curr.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (curr == null) {\n\t\t\t\t\treturn DEFAULT_VALUE;\n\t\t\t\t}\n\n\t\t\t\tint ans = curr.val;\n\t\t\t\tif (curr.left != null) {\n\t\t\t\t\tans = mergeValue(ans, curr.left.getSumGTE(lo));\n\t\t\t\t}\n\t\t\t\tif (curr.right != null) {\n\t\t\t\t\tans = mergeValue(ans, curr.right.getSumLTE(hi));\n\t\t\t\t}\n\t\t\t\treturn ans;\n\t\t\t}\n\n\t\t\tprivate void update() {\n\t\t\t\tcomputeHeight();\n\t\t\t\tcomputeSum();\n\t\t\t}\n\n\t\t\tprivate int computeHeight() {\n\t\t\t\tht = 1 + Math.max(getHeight(left), getHeight(right));\n\t\t\t\treturn ht;\n\t\t\t}\n\n\t\t\tprivate int computeSum() {\n\t\t\t\tsum = mergeValue(val, mergeValue(getSum(left), getSum(right)));\n\t\t\t\treturn sum;\n\t\t\t}\n\n\t\t\tprivate int getSumLTE(int k) {\n\t\t\t\tAVLTreeNode curr = this;\n\t\t\t\tint sum = DEFAULT_VALUE;\n\t\t\t\twhile (curr != null) {\n\t\t\t\t\tif (compareKey(k, curr.key) < 0) {\n\t\t\t\t\t\tcurr = curr.left;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsum = mergeValue(sum, mergeValue(curr.val, getSum(curr.left)));\n\t\t\t\t\t\tcurr = curr.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\n\t\t\tprivate int getSumGTE(int k) {\n\t\t\t\tAVLTreeNode curr = this;\n\t\t\t\tint sum = DEFAULT_VALUE;\n\t\t\t\twhile (curr != null) {\n\t\t\t\t\tif (compareKey(k, curr.key) > 0) {\n\t\t\t\t\t\tcurr = curr.right;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsum = mergeValue(sum, mergeValue(curr.val, getSum(curr.right)));\n\t\t\t\t\t\tcurr = curr.left;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\n\t\t\tprivate AVLTreeNode getOrCreate(AVLTreeNode node, int k) {\n\t\t\t\tif (node != null) {\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t\treturn new AVLTreeNode(k);\n\t\t\t}\n\n\t\t\tprivate int getSum(AVLTreeNode node) {\n\t\t\t\tif (node == null) {\n\t\t\t\t\treturn DEFAULT_VALUE;\n\t\t\t\t}\n\t\t\t\treturn node.sum;\n\t\t\t}\n\t\t}\n\n\t\tprivate static int getHeight(AVLTreeNode node) {\n\t\t\tif (node == null) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn node.ht;\n\t\t}\n\n\t\tprivate static int balanceFactor(AVLTreeNode root) {\n\t\t\treturn getHeight(root.left) - getHeight(root.right);\n\t\t}\n\n\t\tprivate static AVLTreeNode rebalance(AVLTreeNode node) {\n\t\t\tif (node == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tint bf = balanceFactor(node);\n\t\t\tif (bf > 1) {\n\t\t\t\treturn rotateRight(node);\n\t\t\t} else if (bf < -1) {\n\t\t\t\treturn rotateLeft(node);\n\t\t\t} else {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\n\t\tprivate static AVLTreeNode rotateRight(AVLTreeNode root) {\n\t\t\tAVLTreeNode pivot = root.left;\n\t\t\troot.left = pivot.right;\n\t\t\tpivot.right = root;\n\t\t\troot.update();\n\t\t\tpivot.update();\n\t\t\treturn pivot;\n\t\t}\n\n\t\tprivate static AVLTreeNode rotateLeft(AVLTreeNode root) {\n\t\t\tAVLTreeNode pivot = root.right;\n\t\t\troot.right = pivot.left;\n\t\t\tpivot.left = root;\n\t\t\troot.update();\n\t\t\tpivot.update();\n\t\t\treturn pivot;\n\t\t}\n\t}\n    \n\t/**\n\t * PrimitiveArraySegmentTree is the same as ArraySegmentTree, except that it uses a primitive type natively to avoid boxing/unboxing.\n\t * Use your editor's find-and-replace to rename the types into primitives, since Java doesn't support generics of primitives.\n\t */\n\tpublic static class PrimitiveArraySegmentTree {\n\t\t// Implement the value merge function.\n\t\tprivate static int merge(int a, int b) {\n            return a + b;\n\t\t}\n\n\t\t// The default value if nothing in range.\n\t\tprivate static final int DEFAULT_VALUE = 0;\n\n\t\tpublic static PrimitiveArraySegmentTree newWithSize(int size, int initialValue) {\n\t\t\treturn new PrimitiveArraySegmentTree(bitsRequired(size), initialValue);\n\t\t}\n\n\t\tpublic static PrimitiveArraySegmentTree newWithSize(int size) {\n\t\t\treturn new PrimitiveArraySegmentTree(bitsRequired(size));\n\t\t}\n\n\t\tprivate int bits;\n\t\tprivate int[] values;\n\n\t\tpublic PrimitiveArraySegmentTree(int bits, int initialValue) {\n\t\t\tthis(bits);\n\n\t\t\tint nodeCount = values.length;\n\t\t\tint itemCount = nodeCount >> 1;\n\n\t\t\tArrays.fill(values, itemCount, nodeCount, initialValue);\n\t\t\tfor (int i = itemCount - 1; i >= 0; --i) {\n\t\t\t\tint L = i << 1;\n\t\t\t\tint R = L + 1;\n\t\t\t\tvalues[i] = merge(values[L], values[R]);\n\t\t\t}\n\t\t}\n\n\t\tpublic PrimitiveArraySegmentTree(int bits) {\n\t\t\tthis.bits = bits;\n\n\t\t\tint itemCount = 1 << bits;\n\t\t\tint nodeCount = itemCount << 1;\n\t\t\tvalues = new int[nodeCount];\n\t\t}\n\n\t\tpublic void insert(int index, int data) {\n\t\t\tint curr = (values.length >> 1) + index;\n\t\t\tvalues[curr] = data;\n\t\t\tcurr >>= 1;\n\t\t\twhile (curr > 0) {\n\t\t\t\tint left = curr << 1;\n\t\t\t\tint right = left + 1;\n\t\t\t\tvalues[curr] = merge(values[left], values[right]);\n\t\t\t\tcurr >>= 1;\n\t\t\t}\n\t\t}\n\n\t\tpublic void increment(int index, int delta) {\n\t\t\tint data = merge(get(index), delta);\n\t\t\tinsert(index, data);\n\t\t}\n\n\t\tpublic int get(int index) {\n\t\t\tint i = (values.length >> 1) + index;\n\t\t\treturn values[i];\n\t\t}\n\n\t\tpublic int get(int loInclusive, int hiInclusive) {\n\t\t\tif (loInclusive > hiInclusive) {\n\t\t\t\treturn DEFAULT_VALUE;\n\t\t\t}\n\n\t\t\tint curr = 1;\n\t\t\tfor (int d = 0; d < bits; ++d) {\n\t\t\t\tint shift = bits - d;\n\t\t\t\tint LL = (curr << shift) - (values.length >> 1);\n\t\t\t\tint LR = LL + (1 << (shift - 1)) - 1;\n\t\t\t\tint RL = LR + 1;\n\t\t\t\tint lCurr = curr << 1;\n\t\t\t\tint rCurr = lCurr + 1;\n\t\t\t\tif (hiInclusive <= LR) {\n\t\t\t\t\tcurr = lCurr;\n\t\t\t\t} else if (loInclusive >= RL) {\n\t\t\t\t\tcurr = rCurr;\n\t\t\t\t} else {\n\t\t\t\t\tint leftValue = getGTE(loInclusive, lCurr, d + 1);\n\t\t\t\t\tint rightValue = getLTE(hiInclusive, rCurr, d + 1);\n\t\t\t\t\treturn merge(leftValue, rightValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn values[curr];\n\t\t}\n\n\t\tprivate int getGTE(int loInclusive, int curr, int dStart) {\n\t\t\tint ans = DEFAULT_VALUE;\n\t\t\tfor (int d = dStart; d < bits; ++d) {\n\t\t\t\tint shift = bits - d;\n\t\t\t\tint LL = (curr << shift) - (values.length >> 1);\n\t\t\t\tint LR = LL + (1 << (shift - 1)) - 1;\n\t\t\t\tint RL = LR + 1;\n\t\t\t\tint rCurr = (curr << 1) + 1;\n\t\t\t\tif (loInclusive <= LL) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (loInclusive >= RL) {\n\t\t\t\t\tcurr = rCurr;\n\t\t\t\t} else {\n\t\t\t\t\tans = merge(ans, values[rCurr]);\n\t\t\t\t\tcurr <<= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn merge(ans, values[curr]);\n\t\t}\n\n\t\tprivate int getLTE(int hiInclusive, int curr, int dStart) {\n\t\t\tint ans = DEFAULT_VALUE;\n\t\t\tfor (int d = dStart; d < bits; ++d) {\n\t\t\t\tint shift = bits - d;\n\t\t\t\tint LL = (curr << shift) - (values.length >> 1);\n\t\t\t\tint LR = LL + (1 << (shift - 1)) - 1;\n\t\t\t\tint RR = LL + (1 << shift) - 1;\n\t\t\t\tint lCurr = curr << 1;\n\t\t\t\tif (hiInclusive >= RR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (hiInclusive <= LR) {\n\t\t\t\t\tcurr = lCurr;\n\t\t\t\t} else {\n\t\t\t\t\tans = merge(ans, values[lCurr]);\n\t\t\t\t\tcurr = lCurr + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn merge(ans, values[curr]);\n\t\t}\n\n\t\tprivate static int bitsRequired(int size) {\n\t\t\treturn Integer.SIZE - Integer.numberOfLeadingZeros(size - 1);\n\t\t}\n\t}\n}",
    "submit_ts": "1722742414",
    "subm_id": "1343768419"
}