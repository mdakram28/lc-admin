{
    "username": "gojib2002",
    "submission": "class Solution {\npublic:\n    vector<int> v1[100010];\n    vector<int> v2[100010];\n    int mx, idx;\n\n    void dfs(int cur, int d, int prv, vector<int> v[])\n    {\n        int i;\n\n        if(mx < d)\n        {\n            idx = cur;\n            mx = d;\n        }\n\n        for(i = 0; i < v[cur].size(); i++)\n        {\n            if(v[cur][i] == prv) continue;\n\n            dfs(v[cur][i], d + 1, cur, v);\n        }\n    }\n\n    int bfs(int x, int y, vector<int> v[])\n    {\n        int i;\n        queue<int> que;\n        int dist1[100010];\n        int dist2[100010];\n        bool visited[100010] = {false};\n        int cur;\n        int ans;\n\n        que.push(x);\n        dist1[x] = 0;\n        visited[x] = true;\n        while(!que.empty())\n        {\n            cur = que.front();\n            que.pop();\n\n            for(i = 0; i < v[cur].size(); i++)\n            {\n                if(visited[v[cur][i]]) continue;\n\n                que.push(v[cur][i]);\n                visited[v[cur][i]] = true;\n                dist1[v[cur][i]] = dist1[cur] + 1;\n            }\n        }\n\n        memset(visited, false, sizeof(visited));\n        \n        que.push(y);\n        dist2[y] = 0;\n        visited[y] = true;\n        while(!que.empty())\n        {\n            cur = que.front();\n            que.pop();\n\n            for(i = 0; i < v[cur].size(); i++)\n            {\n                if(visited[v[cur][i]]) continue;\n\n                que.push(v[cur][i]);\n                visited[v[cur][i]] = true;\n                dist2[v[cur][i]] = dist2[cur] + 1;\n            }\n        }\n\n        ans = 1 << 20;\n        for(i = 0; i < 100010; i++)\n        {\n            if(visited[i]) ans = min(ans, max(dist1[i], dist2[i]));\n        }\n\n        return ans;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int i;\n        int x1, y1;\n        int x2, y2;\n        int mx1, mx2;\n\n        for(i = 0; i < edges1.size(); i++)\n        {\n            v1[edges1[i][0]].push_back(edges1[i][1]);\n            v1[edges1[i][1]].push_back(edges1[i][0]);\n        }\n\n        for(i = 0; i < edges2.size(); i++)\n        {\n            v2[edges2[i][0]].push_back(edges2[i][1]);\n            v2[edges2[i][1]].push_back(edges2[i][0]);\n        }\n\n        mx = -1;\n        dfs(0, 0, -1, v1);\n        x1 = idx;\n        \n        mx = -1;\n        dfs(x1, 0, -1, v1);\n        y1 = idx;\n\n        mx1 = mx;\n\n        mx = -1;\n        dfs(0, 0, -1, v2);\n        x2 = idx;\n\n        mx = -1;\n        dfs(x2, 0, -1, v2);\n        y2 = idx;\n\n        mx2 = mx;\n\n        return max(bfs(x1, y1, v1) + bfs(x2, y2, v2) + 1, max(mx1, mx2));\n    }\n};",
    "submit_ts": 1719716738.0
}