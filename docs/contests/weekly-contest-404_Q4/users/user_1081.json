{
    "username": "charliesabino",
    "submission": "from typing import List\nfrom collections import defaultdict\nimport sys\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        g1, g2 = defaultdict(list), defaultdict(list)\n        n, m = 0, 0\n\n        for e in edges1:\n            n = max(e[0], n, e[1])\n            g1[e[0]].append(e[1])\n            g1[e[1]].append(e[0])\n        for e in edges2:\n            m = max(e[0], m, e[1])\n            g2[e[0]].append(e[1])\n            g2[e[1]].append(e[0])\n\n        dp1 = [[] for _ in range(n + 1)]\n        dp2 = [[] for _ in range(m + 1)]\n\n        def dfs(node, last, g, dp):\n            if len(g[node]) == 1 and g[node][0] == last:\n                return 0\n\n            for neighbor in g[node]:\n                if neighbor == last:\n                    continue\n\n                dp[node].append((1 + dfs(neighbor, node, g, dp), neighbor))\n                dp[node].sort(reverse=True)\n\n                if len(dp[node]) > 2:\n                    dp[node].pop()\n\n            return dp[node][0][0] if dp[node] else 0\n\n        dfs(0, -1, g1, dp1)\n        dfs(0, -1, g2, dp2)\n\n        def dfs2(node, last, g, dp):\n            if last != -1:\n                dp[node].append((1, -1))\n                parent = last\n                if dp[parent] and dp[parent][0][1] != node:\n                    dp[node].append((dp[parent][0][0] + 1, parent))\n                elif len(dp[parent]) > 1:\n                    dp[node].append((dp[parent][1][0] + 1, parent))\n\n                dp[node].sort(reverse=True)\n\n                if len(dp[node]) > 2:\n                    dp[node].pop()\n\n            for neighbor in g[node]:\n                if neighbor != last:\n                    dfs2(neighbor, node, g, dp)\n\n        dfs2(0, -1, g1, dp1)\n        dfs2(0, -1, g2, dp2)\n\n        mx1 = sys.maxsize\n        mx2 = sys.maxsize\n        for node in range(n + 1):\n            mx1 = min(mx1, dp1[node][0][0] if dp1[node] else 0)\n        for node in range(m + 1):\n            mx2 = min(mx2, dp2[node][0][0] if dp2[node] else 0)\n\n        def diam(node, prev, res, g):\n            mx = []\n            for neighbor in g[node]:\n                if neighbor != prev:\n                    mx.append(diam(neighbor, node, res, g))\n                    mx.sort(reverse=True)\n                    if len(mx) > 2:\n                        mx.pop()\n            if mx:\n                res[0] = max(res[0], mx[0] + (mx[1] if len(mx) > 1 else 0))\n            return 1 + (mx[0] if mx else 0)\n\n        d1, d2 = [0], [0]\n        diam(0, -1, d1, g1)\n        diam(0, -1, d2, g2)\n        res = max(d1[0], d2[0])\n        return mx1 + mx2 + 1 if mx1 + mx2 + 1 > res else res",
    "submit_ts": "1719716366",
    "subm_id": "1304362430"
}