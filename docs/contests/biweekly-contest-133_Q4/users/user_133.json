{
    "username": "tungduong150105",
    "submission": "template <typename T>\nT power(T a, int64_t b) {\n    T res = T(1);\n    for (; b; b /= 2, a *= a) {\n        if (b & 1) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nint64_t mul(int64_t a, int64_t b, int64_t mod) {\n    int64_t res = a * b - (int64_t) (a * b / mod) * mod;\n    res %= mod;\n    if (res < 0) {\n        res += mod;\n    }\n    return res;\n}\n\ntemplate <int64_t P>\nstruct ModNum {\n    int64_t x;\n    ModNum() : x(0) {}\n    ModNum(int64_t _x) : x(norm(_x % getMod())) {}\n    static int64_t Mod;\n    static int64_t getMod() {\n        if (P > 0) {\n            return P;\n        }\n        return Mod;\n    }\n    static void setMod(int64_t _Mod) {\n        Mod = _Mod;\n    }\n    int64_t norm(int64_t x) const {\n        if (x < 0) {\n            return x += getMod();\n        } else if (x >= getMod()) {\n            return x -= getMod();\n        }\n        return x;\n    }\n    int64_t val() const {\n        return x;\n    }\n    ModNum operator-() const {\n        ModNum res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    ModNum inv() const {\n        return power(*this, getMod() - 2);\n    }\n    ModNum &operator*=(const ModNum &lhs) {\n        if (getMod() < ((int64_t) 1 << 31)) {\n            x = x * lhs.x % getMod();\n        } else {\n            x = mul(x, lhs.x, getMod());\n        }\n        return *this;\n    }\n    ModNum &operator+=(const ModNum &lhs) {\n        x = norm(x + lhs.x);\n        return *this;\n    }\n    ModNum &operator-=(const ModNum &lhs) {\n        x = norm(x - lhs.x);\n        return *this;\n    }\n    ModNum &operator/=(const ModNum &lhs) {\n        return *this *= lhs.inv();\n    }\n    friend ModNum operator+(const ModNum &lhs, const ModNum &rhs) {\n        ModNum res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend ModNum operator-(const ModNum &lhs, const ModNum &rhs) {\n        ModNum res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend ModNum operator*(const ModNum &lhs, const ModNum &rhs) {\n        ModNum res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend ModNum operator/(const ModNum &lhs, const ModNum &rhs) {\n        ModNum res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend ModNum operator==(const ModNum &lhs, const ModNum &rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend ModNum operator!=(const ModNum &lhs, const ModNum &rhs) {\n        return lhs.val() != rhs.val();\n    }\n    friend std::istream &operator>>(std::istream &is, ModNum &lhs) {\n        int64_t v;\n        is >> v;\n        lhs = ModNum(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const ModNum &lhs) {\n        os << lhs.val();\n        return os;\n    }\n};\n\ntemplate <>\nint64_t ModNum<0>::Mod = 1E9 + 7;\n\nconstexpr int P = 1E9 + 7;\nusing Z = ModNum<P>;\n\nclass Solution {\npublic:\n    int numberOfPermutations(int n, vector<vector<int>>& a) {\n        std::vector<int> f(n + 1, -1);\n        for (auto v : a) {\n            f[v[0] + 1] = v[1];\n        }\n        std::vector<Z> dp(500, 0);\n        dp[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            std::vector<Z> ndp(500, 0);\n            for (int j = 0; j < 500; ++j) {\n                ndp[j] = dp[j];\n                if (j) {\n                    ndp[j] += ndp[j - 1];\n                }\n                if (j >= i) {\n                    ndp[j] -= dp[j - i];\n                }\n            }\n            if (f[i] != -1) {\n                for (int j = 0; j < 500; ++j) {\n                    if (j != f[i]) {\n                        ndp[j] = 0;\n                    }\n                }\n            }\n            std::swap(dp, ndp);\n        }\n        Z ans = std::accumulate(dp.begin(), dp.end(), Z(0));\n        return ans.val();\n    }\n};",
    "submit_ts": 1719068972.0
}