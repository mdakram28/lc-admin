{
    "username": "qqwrv",
    "submission": "#define ASSERT(x)\n\n// y-comb\ntemplate <class Func> class YCombResult {\npublic:\n    explicit YCombResult(Func&& func) : func_(std::forward<Func>(func)) {}\n\n    template <class... Args> decltype(auto) operator()(Args&&... args) {\n        return func_(std::ref(*this), std::forward<Args>(args)...);\n    }\n\nprivate:\n    Func func_;\n};\ntemplate <class Func> decltype(auto) MakeYComb(Func&& func) {\n    return YCombResult<std::decay_t<Func>>(std::forward<Func>(func));\n}\n\n/**\n * Segment tree with point update and range query abilities.\n */\ntemplate <typename Data, typename Tag> class LazySegmentTree {\npublic:\n    LazySegmentTree(int n) : n_(n), data_(n * 4), tag_(n * 4) {}\n    LazySegmentTree(const std::vector<Data>& a) : LazySegmentTree(a.size()) {\n        auto build = MakeYComb([&](auto&& self, int x, int l, int r) -> void {\n            if (l == r) {\n                data_[x] = a[l];\n                return;\n            }\n            int mid = (l + r) >> 1;\n            self(x << 1, l, mid);\n            self(x << 1 | 1, mid + 1, r);\n            pull(x);\n        });\n\n        build(1, 0, n_ - 1);\n    }\n\n    std::string to_string() {\n        std::stringstream ss;\n        auto dfs = MakeYComb([&](auto&& self, int x, int l, int r) -> void {\n            if (l == r) {\n                ss << \"  [\" << l << \"]: \" << data_[x].to_string() << \",\\n\";\n                return;\n            }\n            push(x);\n            int mid = (l + r) >> 1;\n            self(x << 1, l, mid);\n            self(x << 1 | 1, mid + 1, r);\n        });\n        ss << \"SegmentTree: [\\n\";\n        dfs(1, 0, n_ - 1);\n        ss << \"]\\n\";\n        return ss.str();\n    }\n\n    void RangeUpdate(int l, int r, const Tag& tag) {\n        ASSERT(0 <= l && l < n_);\n        ASSERT(0 <= r && r < n_);\n        RangeUpdate(1, 0, n_ - 1, l, r, tag);\n    }\n\n    Data RangeQuery(int l, int r) {\n        ASSERT(0 <= l && l < n_);\n        ASSERT(0 <= r && r < n_);\n        return RangeQuery(1, 0, n_ - 1, l, r);\n    }\n\n    template <typename Pred> int FindFirst(int l, int r, Pred&& pred) {\n        ASSERT(0 <= l && l < n_);\n        ASSERT(0 <= r && r < n_);\n        return FindFirst(1, 0, n_ - 1, l, r, std::forward<Pred>(pred));\n    }\n\n    template <typename Pred> int FindLast(int l, int r, Pred&& pred) {\n        ASSERT(0 <= l && l < n_);\n        ASSERT(0 <= r && r < n_);\n        return FindLast(1, 0, n_ - 1, l, r, std::forward<Pred>(pred));\n    }\n\nprivate:\n    void pull(int x) { data_[x] = data_[x << 1] + data_[x << 1 | 1]; }\n\n    void push(int x) {\n        data_[x << 1].Apply(tag_[x]);\n        tag_[x << 1].Apply(tag_[x]);\n\n        data_[x << 1 | 1].Apply(tag_[x]);\n        tag_[x << 1 | 1].Apply(tag_[x]);\n\n        tag_[x] = Tag{};\n    }\n\n    void RangeUpdate(int x, int l, int r, int L, int R, const Tag& tag) {\n        if (l > R || r < L)\n            return;\n        if (l >= L && r <= R) {\n            data_[x].Apply(tag);\n            tag_[x].Apply(tag);\n            return;\n        }\n        push(x);\n        int mid = (l + r) >> 1;\n        RangeUpdate(x << 1, l, mid, L, R, tag);\n        RangeUpdate(x << 1 | 1, mid + 1, r, L, R, tag);\n        pull(x);\n    }\n\n    Data RangeQuery(int x, int l, int r, int L, int R) {\n        if (l > R || r < L)\n            return Data();\n        if (l >= L && r <= R)\n            return data_[x];\n        push(x);\n        int mid = (l + r) >> 1;\n        return RangeQuery(x << 1, l, mid, L, R) +\n               RangeQuery(x << 1 | 1, mid + 1, r, L, R);\n    }\n\n    template <typename Pred>\n    int FindFirst(int x, int l, int r, int L, int R, Pred&& pred) {\n        if (l > R || r < L)\n            return -1;\n        if (l >= L && r <= R && !pred(data_[x]))\n            return -1;\n        if (l == r)\n            return l;\n        push(x);\n        int mid = (l + r) >> 1;\n        int res = FindFirst(x << 1, l, mid, L, R, std::forward<Pred>(pred));\n        if (res == -1)\n            res = FindFirst(x << 1 | 1, mid + 1, r, L, R,\n                            std::forward<Pred>(pred));\n        return res;\n    }\n\n    template <typename Pred>\n    int FindLast(int x, int l, int r, int L, int R, Pred&& pred) {\n        if (l > R || r < L)\n            return -1;\n        if (l >= L && r <= R && !pred(data_[x]))\n            return -1;\n        if (l == r)\n            return l;\n        push(x);\n        int mid = (l + r) >> 1;\n        int res =\n            FindLast(x << 1 | 1, mid + 1, r, L, R, std::forward<Pred>(pred));\n        if (res == -1)\n            res = FindLast(x << 1, l, mid, L, R, std::forward<Pred>(pred));\n        return res;\n    }\n\nprivate:\n    int n_;\n    std::vector<Data> data_;\n    std::vector<Tag> tag_;\n};\n\nconstexpr static int kInf = 0x3f3f3f3f;\nstruct Tag {\n    int add = 0;\n    void Apply(const Tag& tag) { add += tag.add; }\n};\n\nstruct Data {\n    int mn = kInf;\n\n    friend Data operator+(const Data& lhs, const Data& rhs) {\n        Data res;\n        res.mn = std::min(lhs.mn, rhs.mn);\n        return res;\n    }\n\n    void Apply(const Tag& tag) { mn += tag.add; }\n};\nusing S = LazySegmentTree<Data, Tag>;\n\nstruct Tag2 {\n    int mx = -kInf;\n    void Apply(const Tag2& tag) { mx = std::max(mx, tag.mx); }\n};\n\nstruct Data2 {\n    int mx = -kInf;\n\n    friend Data2 operator+(const Data2& lhs, const Data2& rhs) {\n        Data2 res;\n        res.mx = std::max(lhs.mx, rhs.mx);\n        return res;\n    }\n\n    void Apply(const Tag2& tag) { mx = std::max(mx, tag.mx); }\n};\nusing S = LazySegmentTree<Data, Tag>;\nusing S2 = LazySegmentTree<Data2, Tag2>;\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& q) {\n        std::vector<Data> data(n);\n        for (int i = 0; i < n; ++i)\n            data[i].mn = i;\n        S s(data);\n\n        std::vector<Data2> data2(n);\n        for (int i = 0; i + 1 < n; ++i)\n            data2[i].mx = i + 1;\n        S2 s2(data2);\n\n        const int m = q.size();\n        std::vector<int> ans;\n        for (int i = 0; i < m; ++i) {\n            int u = q[i][0];\n            int v = q[i][1];\n\n            int mx = s2.RangeQuery(0, u).mx;\n            if (v > mx) {\n                s2.RangeUpdate(u, u, Tag2{v});\n                int dpu = s.RangeQuery(u, u).mn;\n                int dpv = s.RangeQuery(v, v).mn;\n                if (dpu + 1 < dpv) {\n                    int d = dpv - (dpu + 1);\n\n                    s.RangeUpdate(v, n - 1, Tag{-d});\n                }\n            }\n\n            ans.push_back(s.RangeQuery(n - 1, n - 1).mn);\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": "1722741011",
    "subm_id": "1343734345"
}