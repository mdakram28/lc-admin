{
    "username": "OuterRidgeSavage",
    "submission": "class Solution {\npublic:\n    static void fmax(int& x, int y) { if (x < y) x = y; }\n    struct TreeNode {\n        int max, max_d;\n        vector<TreeNode*> children;\n        TreeNode() {}\n\n        void Traverse() {\n            max = 0;\n            max_d = 0;\n            for (TreeNode* c : children) {\n                c->Traverse();\n                fmax(max, c->max);\n                fmax(max_d, c->max_d + 1);\n            }\n            fmax(max, max_d);\n            int nc = children.size();\n            for (int i = 0; i < nc - 1; ++i) {\n                for (int j = i + 1; j < nc; ++j) {\n                    fmax(max, children[i]->max_d + children[j]->max_d + 2);\n                }\n            }\n        }\n    };\n    \n\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& e1, vector<vector<int>>& e2) {\n        int m = e1.size() + 1;\n        int n = e2.size() + 1;\n        vector<vector<int>> g1(m, vector<int>()), g2(n, vector<int>());\n        for (const vector<int>& e : e1) {\n            g1[e[0]].push_back(e[1]);\n            g1[e[1]].push_back(e[0]);\n        }\n        for (const vector<int>& e : e2) {\n            g2[e[0]].push_back(e[1]);\n            g2[e[1]].push_back(e[0]);\n        }\n        // cout << \"g2[0].size() = \" << g2[0].size() << endl;\n        // cout << \"g2[0][0] = \" << g2[0][0] << endl;\n        // Build tree t1.\n        vector<TreeNode> t1(m), t2(n);\n        vector<bool> visited(m, false);\n        queue<int> q;\n        q.push(0);\n        visited[0] = true;\n        while (!q.empty()) {\n            int f = q.front();\n            q.pop();\n            for (int i : g1[f]) {\n                if (visited[i]) continue;\n                visited[i] = true;\n                q.push(i);\n                t1[f].children.push_back(&t1[i]);\n            }\n        }\n        // Build tree t2.\n        visited.clear();\n        visited.resize(n, false);\n        q.push(0);\n        visited[0] = true;\n        while (!q.empty()) {\n            int f = q.front();\n            q.pop();\n            // cout << \"[t2] f = \" << f <<\", g2[f].size() = \" << g2[f].size() << endl;\n            for (int i : g2[f]) {\n                // cout << \"[t2] f = \" << f <<\", i = \" << i << endl;\n                if (visited[i]) continue;\n                visited[i] = true;\n                q.push(i);\n                t2[f].children.push_back(&t2[i]);\n            }\n        }\n        \n        // DP\n        t1[0].Traverse();\n        t2[0].Traverse();\n        \n        int a = t1[0].max;\n        int b = t2[0].max;\n        // cout << \"a = \" << a << endl;\n        // cout << \"b = \" << b << endl;\n        // cout << \"t2[0].max_d = \" << t2[0].max_d << endl;\n        // cout << \"t2[0].children.size() = \" << t2[0].children.size() << endl;\n        int d = 0;\n        if (a % 2 == 0 && b % 2 == 0) {\n            d = a / 2 + b / 2 + 1;\n        } else if (a % 2 == 1 && b % 2 == 1) {\n            d = a / 2 + b / 2 + 3;\n        } else {\n            d = a / 2 + b / 2 + 2;\n        }\n        return std::max(std::max(a, b), d);\n    }\n};",
    "submit_ts": 1719719271.0
}