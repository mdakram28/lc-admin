{
    "username": "mai-c1",
    "submission": "const int Maxn = 150010;\n\nstruct Tree {\n    int l, r, val;\n} T[Maxn << 2];\n\n//\u5411\u4e0a\u4f20\u9012\nvoid pushup(int node) {\n    T[node].val = max(T[node << 1].val, T[node << 1 | 1].val);\n}\n\n//\u5efa\u6811\nvoid build(int node, int l, int r) {\n    T[node] = {l, r, 0};\n    if (l == r)return;\n    int mid = (l + r) >> 1;\n    build(node << 1, l, mid);\n    build(node << 1 | 1, mid + 1, r);\n    pushup(node);\n}\n\n//\u641c\u7d22\u8303\u56f4[l,r]\nint query(int node, int l, int r) {\n    if (l <= T[node].l && T[node].r <= r) {\n        return T[node].val;\n    }\n    int mid = (T[node].r + T[node].l) >> 1, val = 0;\n    if (l <= mid) {\n        val = max(val, query(node << 1, l, r));\n    }\n    if (mid < r) {\n        val = max(val, query(node << 1 | 1, l, r));\n    }\n    return val;\n}\n\n//\u4fee\u6539\u8303\u56f4[l,r]\u5185\u7684\u70b9\u4fee\u6539\u4e3ak\nvoid modify(int node, int l, int r, int k) {\n    if (l <= T[node].l && T[node].r <= r) {\n        T[node].val = k;\n        return;\n    }\n    int mid = (T[node].r + T[node].l) >> 1;\n    if (l <= mid) {\n        modify(node << 1, l, r, k);\n    }\n    if (mid < r) {\n        modify(node << 1 | 1, l, r, k);\n    }\n    pushup(node);\n}\n\nclass Solution {\npublic:\n    const int END = 150001, BEGIN = 1;\n\n    vector<bool> getResults(vector<vector<int>> &queries) {\n        vector<int> nums = {BEGIN, END};\n        build(1, 1, END);\n        modify(1, END, END, END - BEGIN);\n        vector<bool> ans;\n        for (auto q: queries) {\n            if (q[0] == 1) {\n                int x = q[1] + 1;\n                int l = 0, r = nums.size() - 1;\n                while (l < r) {\n                    int mid = (l + r + 1) >> 1;\n                    if (nums[mid] <= x)l = mid;\n                    else r = mid - 1;\n                }\n                // \u627e\u5230\u7b2c\u4e00\u4e2a\u5c0f\u4e8ex\u7684\u503c\n                int len = nums[l + 1] - nums[l];\n                modify(1, nums[l + 1], nums[l + 1], nums[l + 1] - x);\n                modify(1, x, x, x - nums[l]);\n                nums.insert(nums.begin() + l + 1, x);\n            } else {\n                int x = q[1] + 1, sz = q[2];\n\n                int l = 0, r = nums.size() - 1;\n                while (l < r) {\n                    int mid = (l + r + 1) >> 1;\n                    if (nums[mid] <= x)l = mid;\n                    else r = mid - 1;\n                }\n\n                int res = max(query(1, 1, x), x - nums[l]);\n                ans.push_back(res >= sz);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716651309.0
}