{
    "username": "n124345679976",
    "submission": "int ps[] = {1000000007, 2013265921, 998244353};\ntemplate<int MOD>\nstruct mint {\n  unsigned x;\n  mint() : x(0) { }\n  mint(signed sig) : x(((sig)%MOD+MOD)%MOD) {}\n  mint(signed long long sig) : x(((sig)%MOD+MOD)%MOD) { }\n  int get() const { return (int)x; }\n  mint pow(long long p) { mint res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }\n \n  mint &operator+=(mint that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n  mint &operator-=(mint that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n  mint &operator*=(mint that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n  mint &operator/=(mint that) { return (*this) *= that.pow(MOD - 2); }\n \n  mint operator+(mint that) const { return mint(*this) += that; }\n  mint operator-(mint that) const { return mint(*this) -= that; }\n  mint operator*(mint that) const { return mint(*this) *= that; }\n  mint operator/(mint that) const { return mint(*this) /= that; }\n  bool operator<(mint that) const { return x < that.x; }\n  friend ostream& operator<<(ostream &os, mint a) { os << a.x; return os; }\n};\ntypedef mint<1000000007> mint17;\ntypedef mint<998244353> mint99;\ntypedef mint<2013265921> mint22;\nvector<mint17> p1;\nvector<mint99> p9;\nvector<mint22> p2;\nstruct info{\n    mint17 a;\n    mint99 b;\n    mint22 c;\n    int cost;\n    int le;\n    info(int cc, int l){a = 0, b = 0, c = 0, cost = cc, le=l;}\n    void reg(char g){\n        a *= 26; a += g - 97;\n        b *= 26; b += g - 97;\n        c *= 26; c += g - 97;\n    }\n    void rem(char s, int w){\n        a -= p1[w] * (s - 97);\n        b -= p9[w] * (s - 97);\n        c -= p2[w] * (s - 97);\n    }\n    bool operator==(info that){return a.x == that.a.x && b.x == that.b.x && c.x == that.c.x;}\n};\nauto comp = [](info a, info that){\n    return (a.a.x < that.a.x) || (a.a.x == that.a.x && a.b.x < that.b.x) || (a.a.x == that.a.x && a.b.x == that.b.x && a.c.x < that.c.x);\n};\n\n\nclass Solution {\npublic:\n    Solution(){\n        p1.push_back(mint17(1));\n        p9.push_back(mint99(1));\n        p2.push_back(mint22(1));\n        while(p1.size() < 100000){\n            p1.push_back(p1.back() * 26);\n            p2.push_back(p2.back() * 26);\n            p9.push_back(p9.back() * 26);\n        }\n    }\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        vector<int> dp(target.size()+1, 1e9);\n        dp[0] = 0;\n        int ma_len = 0;\n        set<int> lens;\n        for(auto& w:words) ma_len = max(ma_len, int(w.size())), lens.insert(w.size());\n        vector<set<info, decltype(comp)>> g(ma_len+1);\n        map<string, int> w2c;\n        for(int i=0;i<words.size();i++){\n            if(!w2c.count(words[i])) w2c[words[i]] = costs[i];\n            else w2c[words[i]] = min(w2c[words[i]], costs[i]);\n        }\n        for(auto& [w, cc]:w2c) {\n            info in(cc, w.size());\n            for(auto& c:w){\n                in.reg(c);\n            }\n            g[w.size()].insert(in);\n        }\n        vector<vector<info>> edge(target.size()+1);\n        vector<info> zz(ma_len+1, info(0, 0));\n        for(int i=0;i<target.size();i++){\n            for(auto j:lens){\n                zz[j].reg(target[i]);\n                if(i < j-1) continue;\n                auto it = g[j].lower_bound(zz[j]);\n                if(it != g[j].end() && !comp(*it, zz[j]) && !comp(zz[j], *it)) {\n                    dp[i+1] = min(dp[i+1], dp[i-j+1] + it->cost);\n                }\n                zz[j].rem(target[i-j+1], j-1);\n            }\n        }\n        if(dp.back() == 1e9) return -1;\n        return dp.back();\n    }\n};",
    "submit_ts": "1720324793",
    "subm_id": "1312408511"
}