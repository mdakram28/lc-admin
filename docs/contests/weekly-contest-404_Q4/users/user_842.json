{
    "username": "krisWuCHYC",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def tree_diameter(edges):\n            if not edges:\n                return 0\n\n            n = len(edges) + 1\n            graph = [[] for _ in range(n)]\n            for u, v in edges:\n                graph[u].append(v)\n                graph[v].append(u)\n\n            def bfs(start):\n                dist = [-1] * n\n                dist[start] = 0\n                q = deque([start])\n                max_dist = 0\n                max_node = start\n                while q:\n                    node = q.popleft()\n                    for neighbor in graph[node]:\n                        if dist[neighbor] == -1:\n                            dist[neighbor] = dist[node] + 1\n                            q.append(neighbor)\n                            if dist[neighbor] > max_dist:\n                                max_dist = dist[neighbor]\n                                max_node = neighbor\n                return max_node, max_dist\n\n            node1, _ = bfs(0)\n            node2, diameter = bfs(node1)\n\n            return diameter\n\n        diameter1 = tree_diameter(edges1)\n        diameter2 = tree_diameter(edges2)\n        # print(diameter1, diameter2)\n        d1 = math.ceil(diameter1 / 2)\n        d2 = math.ceil(diameter2 / 2)\n        # print(d1, d2)\n        return max(d1 + d2 + 1, max(diameter1, diameter2))\n        \n        # if diameter1 == diameter2 == 0:\n        #     return 1\n        # if diameter1 == 0 or diameter2 == 0:\n        #     return max(diameter1, diameter2) if max(diameter1, diameter2) >= 2 else 2\n        # return max(diameter1, diameter2) + 1 + (diameter1 % 2 == 1 and diameter2 % 2 == 1)",
    "submit_ts": 1719717906.0
}