{
    "username": "wxy9018",
    "submission": "class DSU:\n    def __init__(self):\n        self.parents = {}\n        self.weights = {}\n    \n    def find(self, p): \n        if p not in self.parents:\n            self.parents[p] = p\n            self.weights[p] = 1\n        if self.parents[p] != p:\n            self.parents[p] = self.find(self.parents[p])\n        return self.parents[p]\n    \n    def union(self, p, q):\n        i, j = self.find(p), self.find(q)\n        if i == j: # need to add this when performing path compression, otherwise will be a bug. If not doing weighted, then not needed.\n            return\n        if self.weights[i] >= self.weights[j]:\n            self.parents[j] = i\n            self.weights[i] += self.weights[j] # do not need to reset weights[j] to 0 since we only care about the weights at the root.\n        else:\n            self.parents[i] = j\n            self.weights[j] += self.weights[i]\n        \n    def connected(self, p, q):\n        return self.find(p) == self.find(q)\n    \n    def roots(self):\n        \"\"\"Returns the disjoint roots of the DSU\n        \"\"\"\n        res = set()\n        for node in self.parents:\n            res.add(self.find(node))\n        return res\n\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        dsu = DSU()\n        \n        def touches(circleA, circleB):\n            X1, Y1, R1 = circleA\n            X2, Y2, R2 = circleB\n            return ((X1-X2)*(X1-X2) + (Y1-Y2)*(Y1-Y2)) <= ((R1+R2)*(R1+R2))\n                \n        \n        for i in range(len(circles)):\n            dsu.union(i, i)\n            for j in range(i+1, len(circles)):\n                if touches(circles[i], circles[j]):\n                    dsu.union(i, j)\n        \n        roots = dsu.roots()\n        \n        spans = [[X+1, Y+1, -1, -1] for _ in range(len(circles))] # X1, Y1, X2, Y2\n        \n        for i in range(len(circles)):\n            x, y, r = circles[i]\n            root = dsu.find(i)\n            spans[root][0] = min([X, spans[root][0], x-r])\n            spans[root][1] = min([Y, spans[root][1], y-r])\n            spans[root][2] = max([0, spans[root][2], x+r])\n            spans[root][3] = max([0, spans[root][3], y+r])\n        \n        #print(spans)\n        \n        for i in range(len(spans)):\n            if spans[i][0] <= 0 and spans[i][1] <= 0 or spans[i][2] >= X and spans[i][3] >= Y \\\n            or spans[i][0] <= 0 and spans[i][2] >= X or spans[i][1] <= 0 and spans[i][3] >= Y:\n                return False\n                    \n        \n        return True\n        ",
    "submit_ts": "1722137294",
    "subm_id": "1335759662"
}