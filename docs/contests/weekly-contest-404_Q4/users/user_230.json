{
    "username": "adityavkrm",
    "submission": "class Solution {\n    void dfs(int root, int parent, int depth, const vector<vector<int>>& graph, int& maxDepth) {\n        if (maxDepth < depth) {\n            maxDepth = depth;\n        } \n        ++depth;\n        for (int child: graph[root]) {\n            if (child != parent) {\n                dfs(child, root, depth, graph, maxDepth);\n            }\n        }\n    }\n\n    void dfs2(int root, int parent, int depth, const vector<vector<int>>& graph, int& maxDepth, int& maxDNode) {\n        if (maxDepth < depth) {\n            maxDepth = depth;\n            maxDNode = root;\n        } \n        ++depth;\n        for (int child: graph[root]) {\n            if (child != parent) {\n                dfs2(child, root, depth, graph, maxDepth, maxDNode);\n            }\n        }\n    }\n\n    int diameter(const vector<vector<int>>& graph) {\n        int maxD = INT_MIN, node1 = -1;\n        dfs2(0, -1, 0, graph, maxD, node1);\n        maxD = INT_MIN;\n        dfs(node1, -1, 0, graph, maxD);\n        return maxD;\n    }\n\n    pair<int, int> minHeightRootDepth(const vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        if (n == 1) {\n            return { make_pair(0, 0) };\n        } else if (n == 2) {\n            return { make_pair(1, 1) };\n        }\n        vector<vector<int>> graph(n);\n        vector<int> degree(n);\n        for (auto& e: edges) {\n            graph[e[0]].push_back(e[1]);\n            graph[e[1]].push_back(e[0]);\n            ++degree[e[0]];\n            ++degree[e[1]];\n        }\n\n        queue<int> bfs;\n        for (int i = 0; i < n; ++i) {\n            if (degree[i] == 1) {\n                bfs.push(i);\n            }\n        }\n\n        while (n > 2) {\n            int x = bfs.size();\n            n -= x;\n            \n            while (x--) {\n                int node = bfs.front();\n                bfs.pop();\n                \n                for (auto i: graph[node]) {\n                    if (--degree[i] == 1) {\n                        bfs.push(i);\n                    }\n                }\n            }\n        }\n\n        int ans = INT_MAX;\n\n        while (bfs.size()) {\n            int maxD = INT_MIN;\n            dfs(bfs.front(), -1, 0, graph, maxD);\n            if (maxD < ans) {\n                ans = maxD;\n            }\n            bfs.pop();\n        }\n        return { ans, diameter(graph) };\n    }\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        const auto ans1 = minHeightRootDepth(edges1);\n        const auto ans2 = minHeightRootDepth(edges2);\n        return max(max(ans1.second, ans2.second), ans1.first + ans2.first + 1);\n    }\n};",
    "submit_ts": "1719717926",
    "subm_id": "1304404308"
}