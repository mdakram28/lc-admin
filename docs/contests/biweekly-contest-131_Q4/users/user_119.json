{
    "username": "twoplusthree",
    "submission": "int ceilpow2(int n) {\n  int x = 0;\n  while((1 << x) < n) {\n    x++;\n  }\n  return x;\n}\ntemplate<\n  class S,\n  S (*op)(S, S),\n  S (*e)(),\n  class F,\n  S (*mng)(F, S),\n  F (*com)(F, F),\n  F (*id)()\n>\nstruct lazysegtree{\nprivate:\n  int sz, lg;\n  S *t;\n  F *d;\n  void upd(int k) {\n    t[k] = op(t[k << 1], t[k << 1 | 1]);\n  }\n  void all_apply(int k, F f) {\n    t[k] = mng(f, t[k]);\n    if(k < sz) {\n      d[k] = com(f, d[k]);\n    }\n  }\n  void push(int k) {\n    all_apply(k << 1, d[k]);\n    all_apply(k << 1 | 1, d[k]);\n    d[k] = id();\n  }\npublic:\n  lazysegtree(int n, S *arr = nullptr) {\n    lg = ceilpow2(n);\n    sz = 1 << lg;\n    t = new S[2 * sz];\n    for(int i = 0; i < 2 * sz; i++) {\n      t[i] = e();\n    }\n    if(arr) {\n      for(int i = 0; i < n; i++) {\n        t[sz + i] = arr[i];\n      }\n      for(int i = sz - 1; i >= 1; i--) {\n        upd(i);\n      }\n    }\n    d = new F[sz];\n    for(int i = 0; i < sz; i++) {\n      d[i] = id();\n    }\n  }\n  ~lazysegtree() {\n    delete[] t;\n    delete[] d;\n  }\n  void set(int p, S x) {\n    p += sz;\n    for(int i = lg; i >= 1; i--) {\n      push(p >> i);\n    }\n    t[p] = x;\n    for(int i = 1; i <= lg; i++) {\n      upd(p >> i);\n    }\n  }\n  S get(int p) {\n    p += sz;\n    for(int i = lg; i >= 1; i--) {\n      push(p >> i);\n    }\n    return t[p];\n  }\n  S prod(int l, int r) {\n    if(l >= r) {\n      return e();\n    }\n    l += sz;\n    r += sz;\n    for(int i = lg; i >= 1; i--) {\n      if(((l >> i) << i) != l) {\n        push(l >> i);\n      }\n      if(((r >> i) << i) != r) {\n        push(r >> i);\n      }\n    }\n    S resl, resr;\n    resl = resr = e();\n    while(l < r) {\n      if(l & 1) {\n        resl = op(resl, t[l++]);\n      }\n      if(r & 1) {\n        resr = op(t[--r], resr);\n      }\n      l >>= 1;\n      r >>= 1;\n    }\n    return op(resl, resr);\n  }\n  S all_prod() {\n    return t[1];\n  }\n  void apply(int l, int r, F f) {\n    if(l >= r) {\n      return;\n    }\n    l += sz;\n    r += sz;\n    for(int i = lg; i >= 1; i--) {\n      if(((l >> i) << i) != l) {\n        push(l >> i);\n      }\n      if(((r >> i) << i) != r) {\n        push((r - 1) >> i);\n      }\n    }\n    {\n      int ll = l;\n      int rr = r;\n      while(l < r) {\n        if(l & 1) {\n          all_apply(l++, f);\n        }\n        if(r & 1) {\n          all_apply(--r, f);\n        }\n        l >>= 1;\n        r >>= 1;\n      }\n      l = ll;\n      r = rr;\n    }\n    for(int i = 1; i <= lg; i++) {\n      if(((l >> i) << i) != l) {\n        upd(l >> i);\n      }\n      if(((r >> i) << i) != r) {\n        upd((r - 1) >> i);\n      }\n    }\n  }\n};\nint op(int a,int b){return a>b?a:b;}\nint e(){return 0;}\nint mng(int f,int x){return x-f;}\nint com(int f,int g){return f+g;}\nint id(){return 0;}\nconst int _=50005;\nclass Solution {\npublic:\n  vector<bool> getResults(vector<vector<int>>& queries){\n    int *lv=new int[_];\n    for(int i=0;i<_;i++){\n      lv[i]=i;\n    }\n    lazysegtree<int,op,e,int,mng,com,id> st(_,lv);\n    set<int> obs;\n    obs.insert(_);\n    vector<bool> ans;\n    for(auto qry:queries){\n      if(qry[0]==1){\n        int x=qry[1];\n        int r=*(obs.upper_bound(x));\n        int val=st.get(x+1)-1;\n        st.apply(x+1,r+1,val);\n        obs.insert(x);\n      }else{\n        int x=qry[1];\n        int sz=qry[2];\n        int res=st.prod(0,x+1);\n        ans.push_back(res>=sz);\n      }\n    }\n    return ans;\n  }\n};",
    "submit_ts": "1716650214",
    "subm_id": "1267609524"
}