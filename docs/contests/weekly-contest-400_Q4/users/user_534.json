{
    "username": "sahild2003",
    "submission": "import kotlin.math.min\nimport kotlin.math.abs\n\nconst val INF = Int.MAX_VALUE\n\nclass SegmentTree(arr: IntArray) {\n    val tree: IntArray\n    val n: Int\n\n    init {\n        n = arr.size\n        tree = IntArray(4 * n)\n        build(arr, 0, 0, n - 1)\n    }\n\n    private fun build(arr: IntArray, node: Int, start: Int, end: Int) {\n        if (start == end) {\n            tree[node] = arr[start]\n        } else {\n            val mid = (start + end) / 2\n            build(arr, 2 * node + 1, start, mid)\n            build(arr, 2 * node + 2, mid + 1, end)\n            tree[node] = tree[2 * node + 1] and tree[2 * node + 2]\n        }\n    }\n\n    fun query(l: Int, r: Int): Int {\n        return query(0, 0, n - 1, l, r)\n    }\n\n    private fun query(node: Int, start: Int, end: Int, l: Int, r: Int): Int {\n        if (r < start || end < l) {\n            return INF\n        }\n        if (l <= start && end <= r) {\n            return tree[node]\n        }\n        val mid = (start + end) / 2\n        val p1 = query(2 * node + 1, start, mid, l, r)\n        val p2 = query(2 * node + 2, mid + 1, end, l, r)\n        return p1 and p2\n    }\n}\n\nfun closestAND(arr: IntArray, k: Int): Int {\n    val n = arr.size\n    val st = SegmentTree(arr)\n    var ans = INF\n    for (i in 0 until n) {\n        var l = i - 1\n        var r = n - 1\n        while (r - l > 1) {\n            val mid = (l + r) / 2\n            if (st.query(i, mid) >= k) {\n                l = mid\n            } else {\n                r = mid\n            }\n        }\n        if (l != i - 1) {\n            ans = min(ans, abs(st.query(i, l) - k))\n        }\n        ans = min(ans, abs(k - st.query(i, r)))\n    }\n    return ans\n}\n\nclass Solution {\n    fun minimumDifference(nums: IntArray, k: Int): Int {\n        return closestAND(nums, k)\n    }\n}\n",
    "submit_ts": "1717299086",
    "subm_id": "1274801335"
}