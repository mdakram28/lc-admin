{
    "username": "jinmingli",
    "submission": "namespace atcoder\n{\n\n    template <class S,\n              S (*op)(S, S),\n              S (*e)(),\n              class F,\n              S (*mapping)(F, S),\n              F (*composition)(F, F),\n              F (*id)()>\n    struct lazy_segtree\n    {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S> &v) : _n(int(v.size()))\n        {\n            log = 0;\n            while ((1U << log) < (unsigned int)(_n))\n                log++;\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++)\n                d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--)\n            {\n                update(i);\n            }\n        }\n\n        void set(int p, S x)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++)\n                update(p >> i);\n        }\n\n        S get(int p)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                push(p >> i);\n            return d[p];\n        }\n\n        S prod(int l, int r)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r)\n                return e();\n\n            l += size;\n            r += size;\n\n            for (int i = log; i >= 1; i--)\n            {\n                if (((l >> i) << i) != l)\n                    push(l >> i);\n                if (((r >> i) << i) != r)\n                    push(r >> i);\n            }\n\n            S sml = e(), smr = e();\n            while (l < r)\n            {\n                if (l & 1)\n                    sml = op(sml, d[l++]);\n                if (r & 1)\n                    smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n\n            return op(sml, smr);\n        }\n\n        S all_prod() { return d[1]; }\n\n        void apply(int p, F f)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++)\n                update(p >> i);\n        }\n        void apply(int l, int r, F f)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r)\n                return;\n\n            l += size;\n            r += size;\n\n            for (int i = log; i >= 1; i--)\n            {\n                if (((l >> i) << i) != l)\n                    push(l >> i);\n                if (((r >> i) << i) != r)\n                    push((r - 1) >> i);\n            }\n\n            {\n                int l2 = l, r2 = r;\n                while (l < r)\n                {\n                    if (l & 1)\n                        all_apply(l++, f);\n                    if (r & 1)\n                        all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n\n            for (int i = 1; i <= log; i++)\n            {\n                if (((l >> i) << i) != l)\n                    update(l >> i);\n                if (((r >> i) << i) != r)\n                    update((r - 1) >> i);\n            }\n        }\n\n        template <bool (*g)(S)>\n        int max_right(int l)\n        {\n            return max_right(l, [](S x)\n                             { return g(x); });\n        }\n        template <class G>\n        int max_right(int l, G g)\n        {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n)\n                return _n;\n            l += size;\n            for (int i = log; i >= 1; i--)\n                push(l >> i);\n            S sm = e();\n            do\n            {\n                while (l % 2 == 0)\n                    l >>= 1;\n                if (!g(op(sm, d[l])))\n                {\n                    while (l < size)\n                    {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l])))\n                        {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n\n        template <bool (*g)(S)>\n        int min_left(int r)\n        {\n            return min_left(r, [](S x)\n                            { return g(x); });\n        }\n        template <class G>\n        int min_left(int r, G g)\n        {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0)\n                return 0;\n            r += size;\n            for (int i = log; i >= 1; i--)\n                push((r - 1) >> i);\n            S sm = e();\n            do\n            {\n                r--;\n                while (r > 1 && (r % 2))\n                    r >>= 1;\n                if (!g(op(d[r], sm)))\n                {\n                    while (r < size)\n                    {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm)))\n                        {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n\n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n\n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f)\n        {\n            d[k] = mapping(f, d[k]);\n            if (k < size)\n                lz[k] = composition(f, lz[k]);\n        }\n        void push(int k)\n        {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n\n}\n\nint op(int a,int b){\n    return a+b;\n}\n\n\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& qq) {\n        set<int> ss;\n        for(int i=0;i<n;i++) ss.insert(i);\n        int qn=qq.size();\n        vector<int> ans(qn);\n        for(int i=0;i<qn;i++){\n            int u=qq[i][0],v=qq[i][1];\n            auto it=ss.upper_bound(u);\n            \n               vector<int> tmp;\n               while(it!=ss.end()&&(*it)<v){\n                    tmp.push_back(*it);\n                   it++;\n               } \n                for(int t:tmp) ss.erase(t);\n            \n            ans[i]=ss.size()-1;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722740752",
    "subm_id": "552333476"
}