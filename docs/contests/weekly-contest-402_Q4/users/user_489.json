{
    "username": "HsuBokai",
    "submission": "\nclass SegTree1 {\npublic:\n    int n2;\n    vector<int> segtree;\n\n    // sum op\n\n    void sum_init(int n) {\n        n2 = 1;\n        while (n2 < n) {\n            n2 *= 2;\n        }\n        segtree = vector<int>(n2*2, 0);\n    }\n\n    void sum_init(vector<int>& nums) {\n        int n = nums.size();\n        n2 = 1;\n        while (n2 < n) {\n            n2 *= 2;\n        }\n        segtree = vector<int>(n2*2, 0);\n        for (int i = 0; i < n; ++i) {\n            segtree[n2+i] = nums[i];\n        }\n        for (int i = n2-1; i >= 1; --i) {\n            int left = 2*i;\n            int right = left + 1;\n            segtree[i] = segtree[left] + segtree[right];\n        }\n    }\n\n    void sum_clear() {\n        for (int i = 0; i < segtree.size(); ++i)\n            segtree[i] = 0;\n    }\n\n    void sum_update_1(int i , int l, int r, int index, int value) {\n        if (l == r) {\n            segtree[i] += (value - segtree[n2+index]);\n            return;\n        }\n        int mid = l + (r-l)/2;\n        segtree[i] += (value - segtree[n2+index]);\n        if (index <= mid) sum_update_1(2*i, l, mid, index, value);\n        else sum_update_1(2*i+1, mid+1, r, index, value);\n    }\n    void sum_update(int index, int value) {\n        return sum_update_1(1, 0, n2-1, index, value);\n    }\n\n    int sum_query_1(int i, int l, int r, int range_l, int range_r) {\n        //cout << l << ':' << r << ':' << range_l << ':' << range_r << endl;\n        if (l == range_l && r == range_r) {\n            return segtree[i];\n        }\n        int mid = l + (r-l)/2;\n        if (range_r <= mid) return sum_query_1(2*i, l, mid, range_l, range_r);\n        if (range_l > mid) return sum_query_1(2*i+1, mid+1, r, range_l, range_r);\n        int a = sum_query_1(2*i, l, mid, range_l, mid);\n        int b = sum_query_1(2*i+1, mid+1, r, mid+1, range_r);\n        return a + b;\n    }\n    int sum_query(int range_l, int range_r) {\n        return sum_query_1(1, 0, n2-1, range_l, range_r);\n    }\n\n    // min op\n\n    void min_init(int n) {\n        n2 = 1;\n        while (n2 < n) {\n            n2 *= 2;\n        }\n        segtree = vector<int>(n2*2, INT_MAX);\n    }\n\n    void min_clear() {\n        for (int i = 0; i < segtree.size(); ++i)\n            segtree[i] = INT_MAX;\n    }\n\n    void min_update_1(int i , int l, int r, int index, int value) {\n        if (l == r) {\n            segtree[i] = min(segtree[i], value);\n            return;\n        }\n        int mid = l + (r-l)/2;\n        segtree[i] = min(segtree[i], value);\n        if (index <= mid) min_update_1(2*i, l, mid, index, value);\n        else min_update_1(2*i+1, mid+1, r, index, value);\n    }\n    void min_update(int index, int value) {\n        return min_update_1(1, 0, n2-1, index, value);\n    }\n\n    int min_query_1(int i, int l, int r, int range_l, int range_r) {\n        //cout << l << ':' << r << ':' << range_l << ':' << range_r << endl;\n        if (l == range_l && r == range_r) {\n            return segtree[i];\n        }\n        int mid = l + (r-l)/2;\n        if (range_r <= mid) return min_query_1(2*i, l, mid, range_l, range_r);\n        if (range_l > mid) return min_query_1(2*i+1, mid+1, r, range_l, range_r);\n        int a = min_query_1(2*i, l, mid, range_l, mid);\n        int b = min_query_1(2*i+1, mid+1, r, mid+1, range_r);\n        return min(a, b);\n    }\n    int min_query(int range_l, int range_r) {\n        return min_query_1(1, 0, n2-1, range_l, range_r);\n    }\n};\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> peak(n, 0);\n        for (int i = 1; i < (n-1); ++i) {\n            if (nums[i] > nums[i-1] && nums[i] > nums[i+1]) peak[i] = 1;\n        }\n        SegTree1 obj;\n        obj.sum_init(peak);\n        vector<int> ret;\n        for (auto& q : queries) {\n            if (q[0] == 1) {\n                int ans;\n                if (q[2]-q[1] >= 2)\n                    ans = obj.sum_query(q[1]+1, q[2]-1);\n                else\n                    ans = 0;\n                ret.push_back(ans);\n            } else {\n                int i = q[1];\n                int v = q[2];\n                nums[i] = v;\n                int x;\n                x = i;\n                if (x > 0 && x < (n-1)) {\n                    if (nums[x] > nums[x-1] && nums[x] > nums[x+1]) obj.sum_update(x, 1);\n                    else obj.sum_update(x, 0);\n                }\n                x = i+1;\n                if (x > 0 && x < (n-1)) {\n                    if (nums[x] > nums[x-1] && nums[x] > nums[x+1]) obj.sum_update(x, 1);\n                    else obj.sum_update(x, 0);\n                }\n                x = i-1;\n                if (x > 0 && x < (n-1)) {\n                    if (nums[x] > nums[x-1] && nums[x] > nums[x+1]) obj.sum_update(x, 1);\n                    else obj.sum_update(x, 0);\n                }\n            }\n        }\n        return ret;\n    }\n};",
    "submit_ts": "1718507659",
    "subm_id": "1289658554"
}