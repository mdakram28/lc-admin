{
    "username": "Sarthak2509Agarwal",
    "submission": "class Solution {\npublic:\n\npair<int, int> bfs(const vector<vector<int>>& adj, int start) {\n    int n = adj.size();\n    vector<int> dist(n, -1);\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n    int farthestNode = start;\n    int maxDist = 0;\n    \n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        \n        for (int neighbor : adj[node]) {\n            if (dist[neighbor] == -1) {\n                dist[neighbor] = dist[node] + 1;\n                q.push(neighbor);\n                if (dist[neighbor] > maxDist) {\n                    maxDist = dist[neighbor];\n                    farthestNode = neighbor;\n                }\n            }\n        }\n    }\n    \n    return {farthestNode, maxDist};\n}\n\n// Function to find the diameter of a tree\nint findDiameter(const vector<vector<int>>& adj) {\n    if (adj.size() == 1) return 0; // Edge case for single node\n    auto farthestNodePair = bfs(adj, 0);\n    auto diameterPair = bfs(adj, farthestNodePair.first);\n    return diameterPair.second;\n}\n\n// Function to find the center(s) of the tree\nvector<int> findTreeCenters(const vector<vector<int>>& adj) {\n    int n = adj.size();\n    if (n == 1) return {0}; // Edge case for single node\n    vector<int> degree(n, 0);\n    queue<int> leaves;\n\n    for (int i = 0; i < n; ++i) {\n        degree[i] = adj[i].size();\n        if (degree[i] == 1) {\n            leaves.push(i);\n        }\n    }\n\n    int remainingNodes = n;\n    while (remainingNodes > 2) {\n        int leavesCount = leaves.size();\n        remainingNodes -= leavesCount;\n\n        for (int i = 0; i < leavesCount; ++i) {\n            int leaf = leaves.front();\n            leaves.pop();\n\n            for (int neighbor : adj[leaf]) {\n                if (--degree[neighbor] == 1) {\n                    leaves.push(neighbor);\n                }\n            }\n        }\n    }\n\n    vector<int> centers;\n    while (!leaves.empty()) {\n        centers.push_back(leaves.front());\n        leaves.pop();\n    }\n\n    return centers;\n}\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        \n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        \n        vector<vector<int>> adj1(n), adj2(m);\n        for (const auto& edge : edges1) {\n            adj1[edge[0]].push_back(edge[1]);\n            adj1[edge[1]].push_back(edge[0]);\n        }\n        for (const auto& edge : edges2) {\n            adj2[edge[0]].push_back(edge[1]);\n            adj2[edge[1]].push_back(edge[0]);\n        }\n        \n        int diameter1 = findDiameter(adj1);\n        int diameter2 = findDiameter(adj2);\n\n        vector<int> centers1 = findTreeCenters(adj1);\n        vector<int> centers2 = findTreeCenters(adj2);\n\n        int minDiameter = INT_MAX;\n        for (int c1 : centers1) {\n            for (int c2 : centers2) {\n                int newDiameter = max({(diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1,\n                                    diameter1, diameter2});\n                minDiameter = min(minDiameter, newDiameter);\n            }\n        }\n        \n        return minDiameter;\n    }\n};",
    "submit_ts": "1719719254",
    "subm_id": "1304437472"
}