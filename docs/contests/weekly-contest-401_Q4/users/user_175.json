{
    "username": "matt_kaminski",
    "submission": "class Solution {\npublic:\n    int maxTotalReward(vector<int>& rV) {\n        sort(rV.begin(), rV.end(), greater<int>());\n        rV.erase(unique(rV.begin(), rV.end()), rV.end());\n        // memo: index and value so far (can't exceed rv.back()*2);\n        unordered_map<int,unordered_map<int,int>> memo;//(rV.size(), vector<int> (rV.front()*2, -1));\n        //cout << rV.size() << \" \" << rV.back()*2 << endl;\n        return dfs( rV, 0, rV.front()-1, memo) + rV.front();\n    }\n    int dfs(vector<int>& rv, int p, int mv, unordered_map<int,unordered_map<int,int>>  & m) {\n        int start = p+1;\n        auto it = m.find(p);\n        if (it != m.end()) {\n            auto it2 = it->second.find(mv);\n            if (it2 != it->second.end())\n                return it2->second;\n        }\n        while (start < rv.size() && rv[start]> mv) {\n            start++;\n        }\n\n        int res = (start != rv.size()) ? rv[start] : 0;\n        for (int i = start; i < rv.size() ; ++i) {\n            int nmv = min(rv[i] - 1, mv - rv[i]);\n            if (nmv<=0)\n                break;\n            res = max(res, rv[i]+dfs(rv, i, nmv,m));\n        }\n            m[p][mv] = res;\n        return res;\n    }\n};\n\n\n//[2,9,18,17]\n//exp: 35\n//[1,4,5,100]\n//exp: 109\n//[6,13,9,19]\n//exp: 34",
    "submit_ts": 1717905277.0
}