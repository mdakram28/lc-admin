{
    "username": "sanjeeb42",
    "submission": "//From Github Segment Tree Class- https://github.com/sanjeeb42/Segment-Tree\n\nclass SegmentTree {\npublic:\n    SegmentTree(int size) {\n        n = size;\n        segTree.assign(4 * n, 0);\n    }\n\n    void build(const vector<int>& peaks) {\n        build(0, n - 1, 0, peaks);\n    }\n\n    void update(int index, int value) {\n        update(0, n - 1, index, value, 0);\n    }\n\n    int query(int left, int right) {\n        return query(0, n - 1, left, right, 0);\n    }\n\nprivate:\n    vector<int> segTree;\n    int n;\n\n    void build(int l, int r, int pos, const vector<int>& peaks) {\n        if (l == r) {\n            segTree[pos] = peaks[l];\n            return;\n        }\n        int mid = (l + r) / 2;\n        build(l, mid, 2 * pos + 1, peaks);\n        build(mid + 1, r, 2 * pos + 2, peaks);\n        segTree[pos] = segTree[2 * pos + 1] + segTree[2 * pos + 2];\n    }\n\n    void update(int l, int r, int index, int value, int pos) {\n        if (l == r) {\n            segTree[pos] = value;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (index <= mid) {\n            update(l, mid, index, value, 2 * pos + 1);\n        } else {\n            update(mid + 1, r, index, value, 2 * pos + 2);\n        }\n        segTree[pos] = segTree[2 * pos + 1] + segTree[2 * pos + 2];\n    }\n\n    int query(int l, int r, int ql, int qr, int pos) {\n        if (ql <= l && qr >= r) {\n            return segTree[pos];\n        }\n        if (qr < l || ql > r) {\n            return 0;\n        }\n        int mid = (l + r) / 2;\n        return query(l, mid, ql, qr, 2 * pos + 1) + query(mid + 1, r, ql, qr, 2 * pos + 2);\n    }\n};\n\nclass Solution {\n    \nprivate:\n    int solve(vector<int>&nums,int i){\n        int n=nums.size();\n        if (i <= 0 || i >= n - 1) return 0;\n        return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    }\n    \n    void handle_op1(SegmentTree &segTree,int l,int r,vector<int>&results){\n        int count = 0;\n        if (l < r) {\n            count = segTree.query(l + 1, r - 1);\n        }\n        results.push_back(count);\n    }\n    \n    void handle_op2(int index,int value,vector<int>&arr,vector<int>&nums,SegmentTree &segTree){\n        int n=nums.size();\n        nums[index] = value;\n        if (index > 0 && index < n - 1) \n        {\n            arr[index] = solve(nums,index);\n            segTree.update(index, arr[index]);\n        }\n        if (index - 1 > 0) {\n            arr[index - 1] = solve(nums,index - 1);\n            segTree.update(index - 1, arr[index - 1]);\n        }\n        if (index + 1 < n - 1) {\n            arr[index + 1] = solve(nums,index + 1);\n            segTree.update(index + 1, arr[index + 1]);\n        }\n    }\npublic:\n    \n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> arr(n, 0);\n\n      \n        for (int i = 1; i < n - 1; i++) {\n            if (solve(nums,i)) {\n                arr[i] = 1;\n            }\n        }\n\n        SegmentTree segTree(n);\n        segTree.build(arr);\n\n        vector<int> results;\n\n        for (auto &q : queries) {\n            if (q[0] == 1) handle_op1(segTree,q[1],q[2],results);\n            else if (q[0] == 2) handle_op2(q[1],q[2],arr,nums,segTree);\n        }\n\n        return results;\n    }\n};\n    \n",
    "submit_ts": 1718508858.0
}