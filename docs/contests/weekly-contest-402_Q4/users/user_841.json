{
    "username": "ProgramCaiCai_CN",
    "submission": "class SegmentTree:\n    def __init__(self, data):\n        self.n = len(data)\n        self.tree = [0] * (4 * self.n)\n        self.build(data, 0, 0, self.n - 1)\n\n    def build(self, data, node, start, end):\n        if start == end:\n            self.tree[node] = data[start]\n        else:\n            mid = (start + end) // 2\n            self.build(data, 2*node+1, start, mid)\n            self.build(data, 2*node+2, mid+1, end)\n            self.tree[node] = self.tree[2*node+1] + self.tree[2*node+2]\n\n    def update(self, idx, value, node, start, end):\n        if start == end:\n            self.tree[node] = value\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                self.update(idx, value, 2*node+1, start, mid)\n            else:\n                self.update(idx, value, 2*node+2, mid+1, end)\n            self.tree[node] = self.tree[2*node+1] + self.tree[2*node+2]\n\n    def query(self, L, R, node, start, end):\n        if R < start or end < L:\n            return 0\n        if L <= start and end <= R:\n            return self.tree[node]\n        mid = (start + end) // 2\n        left_sum = self.query(L, R, 2*node+1, start, mid)\n        right_sum = self.query(L, R, 2*node+2, mid+1, end)\n        return left_sum + right_sum\n\ndef process_queries(nums, queries):\n    def is_peak(nums, i):\n        if 0 < i < len(nums) - 1:\n            return nums[i-1] < nums[i] > nums[i+1]\n        return False\n\n    peaks = [0] * len(nums)\n    for i in range(1, len(nums)-1):\n        peaks[i] = is_peak(nums, i)\n\n    seg_tree = SegmentTree(peaks)\n    result = []\n\n    for query in queries:\n        if query[0] == 1:\n            li, ri = query[1], query[2]\n            if ri - li >= 2:  # only query if there is room for a peak\n                result.append(seg_tree.query(li+1, ri-1, 0, 0, len(nums)-1))\n            else:\n                result.append(0)\n        elif query[0] == 2:\n            index, val = query[1], query[2]\n            nums[index] = val\n            # Update peaks around the changed index\n            for i in range(max(1, index-1), min(len(nums)-1, index+2)):\n                was_peak = peaks[i]\n                is_now_peak = is_peak(nums, i)\n                if was_peak != is_now_peak:\n                    peaks[i] = is_now_peak\n                    seg_tree.update(i, is_now_peak, 0, 0, len(nums)-1)\n\n    return result\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        return process_queries(nums,queries)",
    "submit_ts": 1718508893.0
}