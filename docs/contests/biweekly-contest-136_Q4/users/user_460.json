{
    "username": "irvifa",
    "submission": "class Solution {\npublic:\n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vector<vector<int>> graph(n);\n        \n        // Build the adjacency list\n        for (const auto& edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n        \n        vector<int> result(n);\n        vector<int> dp_down(n), dp_up(n);\n        \n        // First DFS to compute dp_down\n        dfs_down(0, -1, graph, dp_down);\n        \n        // Second DFS to compute dp_up and final result\n        dfs_up(0, -1, graph, dp_down, dp_up, result);\n        \n        return result;\n    }\n    \nprivate:\n    void dfs_down(int node, int parent, const vector<vector<int>>& graph, vector<int>& dp_down) {\n        int max_child = 0;\n        for (int child : graph[node]) {\n            if (child != parent) {\n                dfs_down(child, node, graph, dp_down);\n                max_child = max(max_child, dp_down[child] + (child % 2 == 0 ? 2 : 1));\n            }\n        }\n        dp_down[node] = max_child;\n    }\n    \n    void dfs_up(int node, int parent, const vector<vector<int>>& graph, const vector<int>& dp_down, \n                vector<int>& dp_up, vector<int>& result) {\n        int max_child = 0, second_max_child = 0;\n        \n        // Find the two highest child values\n        for (int child : graph[node]) {\n            if (child != parent) {\n                int child_value = dp_down[child] + (child % 2 == 0 ? 2 : 1);\n                if (child_value > max_child) {\n                    second_max_child = max_child;\n                    max_child = child_value;\n                } else if (child_value > second_max_child) {\n                    second_max_child = child_value;\n                }\n            }\n        }\n        \n        // Compute dp_up and result for each child\n        for (int child : graph[node]) {\n            if (child != parent) {\n                int up_value = max(dp_up[node], (max_child == dp_down[child] + (child % 2 == 0 ? 2 : 1)) ? second_max_child : max_child);\n                dp_up[child] = up_value + (node % 2 == 0 ? 2 : 1);\n                dfs_up(child, node, graph, dp_down, dp_up, result);\n            }\n        }\n        \n        // Compute result for the current node\n        result[node] = max(dp_down[node], dp_up[node]);\n    }\n};",
    "submit_ts": "1722698186",
    "subm_id": "1343172543"
}