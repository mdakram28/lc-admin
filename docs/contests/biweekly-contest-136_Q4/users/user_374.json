{
    "username": "inversionpeter",
    "submission": "int nodes;\nvector <vector <int>> adjacencyList;\nvector <vector <pair <int, int>>> weights;\n\nint DFS1(int nowAt, int parent) {\n    for (int neighbor : adjacencyList[nowAt]) {\n        if (neighbor != parent) {\n            weights[nowAt].push_back({ DFS1(neighbor, nowAt) + ((neighbor & 1) ? 1 : 2), neighbor });\n        }\n    }\n    if (!weights[nowAt].size()) {\n        return 0;\n    }\n    sort(weights[nowAt].begin(), weights[nowAt].end(), greater <pair <int, int>>());\n    return weights[nowAt][0].first;\n}\n\nvoid DFS2(vector <int> &answers, int nowAt, int parent, int newBranch) {\n    if (!weights[nowAt].size()) {\n        answers[nowAt] = newBranch;\n    }\n    else {\n        int cost = ((nowAt & 1) ? 1 : 2);\n        answers[nowAt] = max(newBranch, weights[nowAt][0].first);\n        if (newBranch >= weights[nowAt][0].first) {\n            for (int neighbor : adjacencyList[nowAt]) {\n                if (neighbor != parent) {\n                    DFS2(answers, neighbor, nowAt, newBranch + cost);\n                }\n            }\n        }\n        else {\n            for (int neighbor : adjacencyList[nowAt]) {\n                if (neighbor != parent) {\n                    if (weights[nowAt][0].second == neighbor) {\n                        if (weights[nowAt].size() == 1) {\n                            DFS2(answers, neighbor, nowAt, newBranch + cost);\n                        }\n                        else {\n                            DFS2(answers, neighbor, nowAt, max(weights[nowAt][1].first, newBranch) + cost);\n                        }\n                    }\n                    else {\n                        DFS2(answers, neighbor, nowAt, answers[nowAt] + cost);\n                    }\n                }\n            }\n        }\n    }\n}\n\nclass Solution {\npublic:\n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        nodes = edges.size() + 1;\n        adjacencyList.clear();\n        adjacencyList.resize(nodes);\n        weights.clear();\n        weights.resize(nodes);\n        for (vector <int> &edge : edges) {\n            adjacencyList[edge[0]].push_back(edge[1]);\n            adjacencyList[edge[1]].push_back(edge[0]);\n        }\n        vector <int> answers(nodes);\n        answers[0] = DFS1(0, -1);\n        for (int neighbor : adjacencyList[0]) {\n            if (weights[0][0].second == neighbor) {\n                if (weights[0].size() == 1) {\n                    DFS2(answers, neighbor, 0, 2);\n                }\n                else {\n                    DFS2(answers, neighbor, 0, weights[0][1].first + 2);\n                }\n            }\n            else {\n                DFS2(answers, neighbor, 0, answers[0] + 2);\n            }\n        }\n        return answers;\n    }\n};",
    "submit_ts": "1722700176",
    "subm_id": "1343233931"
}