{
    "username": "sysulby",
    "submission": "template <class S>\nstruct SegTree {\n  static S op(S a, S b) { return a + b; }\n  static S e() { return S(); }\n\n  int n;\n  vector<S> seg;\n\n  SegTree(int n): n(n) {\n    seg.assign(n * 4, e());\n  }\n\n  SegTree(const vector<S> &a): SegTree(a.size() - 1) {\n    auto build = [&](auto build, int u, int l, int r) {\n      if (l == r) {\n        seg[u] = a[l];\n        return;\n      }\n      int mid = (l + r) / 2;\n      build(build, u << 1, l, mid);\n      build(build, u << 1 | 1, mid + 1, r);\n      seg[u] = op(seg[u<<1], seg[u<<1|1]);\n    };\n    build(build, 1, 1, n);\n  }\n\n  void set(int p, S x) {\n    auto update = [&](auto update, int u, int l, int r) {\n      if (l == r) {\n        seg[u] = x;\n        return;\n      }\n      int mid = (l + r) / 2;\n      if (p <= mid) update(update, u << 1, l, mid);\n      else update(update, u << 1 | 1, mid + 1, r);\n      seg[u] = op(seg[u<<1], seg[u<<1|1]);\n    };\n    update(update, 1, 1, n);\n  }\n\n  S get(int p) const {\n    auto query = [&](auto query, int u, int l, int r) {\n      if (l == r) return seg[u];\n      int mid = (l + r) / 2;\n      return p <= mid?\n        query(query, u << 1, l, mid): query(query, u << 1 | 1, mid + 1, r);\n    };\n    return query(query, 1, 1, n);\n  }\n\n  S prod(int s, int t) const {\n    auto query = [&](auto query, int u, int l, int r) {\n      if (s <= l && r <= t) return seg[u];\n      int mid = (l + r) / 2;\n      if (t <= mid) return query(query, u << 1, l, mid);\n      if (s > mid) return query(query, u << 1 | 1, mid + 1, r);\n      return op(query(query, u << 1, l, mid), query(query, u << 1 | 1, mid + 1, r));\n    };\n    return query(query, 1, 1, n);\n  }\n\n  int max_right(int s, function<bool(S)> f) const {\n    S pre = e();\n    auto query = [&](auto query, int u, int l, int r) {\n      if (s <= l && f(op(pre, seg[u]))) {\n        pre = op(pre, seg[u]);\n        return r;\n      }\n      if (l == r) return l - 1;\n      int mid = (l + r) / 2;\n      if (s <= mid) {\n        int t = query(query, u << 1, l, mid);\n        if (t < mid) return t;\n      }\n      return query(query, u << 1 | 1, mid + 1, r);\n    };\n    return query(query, 1, 1, n);\n  }\n\n  int min_left(int t, function<bool(S)> f) const {\n    S suf = e();\n    auto query = [&](auto query, int u, int l, int r) {\n      if (r <= t && f(op(seg[u], suf))) {\n        suf = op(seg[u], suf);\n        return l;\n      }\n      if (l == r) return r + 1;\n      int mid = (l + r) / 2;\n      if (t > mid) {\n        int s = query(query, u << 1 | 1, mid + 1, r);\n        if (s > mid + 1) return s;\n      }\n      return query(query, u << 1, l, mid);\n    };\n    return query(query, 1, 1, n);\n  }\n};\n\nstruct Info {\n    int v, f, b, l;\n    Info(int v = 0, int f = 0, int b = 0, int l = 0): v(v), f(f), b(b), l(l) {}\n    Info operator+(const Info &o) const {\n        return Info{\n            max({v, o.v, b + o.f}),\n            f == l? l + o.f: f,\n            o.b == o.l? b + o.l: o.b,\n            l + o.l\n        };\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int n = queries.size() * 3;\n        vector<Info> a(n + 1, Info(1, 1, 1, 1));\n        SegTree<Info> sgt(a);\n        vector<bool> ret;\n        for (auto &q: queries) {\n            if (q[0] == 1) {\n                int x = q[1];\n                auto s = sgt.get(x);\n                s.b = 0;\n                sgt.set(x, s);\n                if (x + 1 <= n) {\n                    auto s = sgt.get(x + 1);\n                    s.f = 0;\n                    sgt.set(x + 1, s);\n                }\n            } else {\n                int x = q[1], sz = q[2];\n                ret.emplace_back(sgt.prod(1, x).v >= sz);\n            }\n        }\n        return ret;\n    }\n};",
    "submit_ts": "1716648381",
    "subm_id": "534761169"
}