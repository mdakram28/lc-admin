{
    "username": "dcube04",
    "submission": "// class Solution {\n// public:\n// vector<int> memo;\n// int dfs(const string& target, const vector<string>& words, const vector<int>& costs, int pos)  {\n//     int n = target.size();\n//         if (pos == n) return 0; // Reached the end of the target string\n//         if (memo[pos] != -1) return memo[pos]; // Return cached result if available\n\n//         int minCost = INT_MAX;\n//         for (int i = 0; i < words.size(); ++i) {\n//             const string& word = words[i];\n//             int cost = costs[i];\n//             int len = word.size();\n            \n//             // Check if the word matches the substring starting at position pos\n//             if (pos + len <= n && target.substr(pos, len) == word) {\n//                 int nextCost = dfs(target, words, costs, pos + len);\n//                 if (nextCost != INT_MAX) {\n//                     minCost = min(minCost, cost + nextCost);\n//                 }\n//             }\n//         }\n\n//         return memo[pos] = minCost;\n// }\n// int solve(const string& target, const vector<string>& words, const vector<int>& costs) {\n//     // unordered_map<int, int> memo;\n//     int n = target.size();\n//     memo.resize(n,-1);\n//     int result = dfs(target, words, costs, 0);\n//     return result == INT_MAX ? -1 : result;\n// }\n//     int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n//         return solve(target, words,costs);\n//     }\n// };\n\n\nclass Solution {\npublic:\nstruct TrieNode {\n    unordered_map<char, TrieNode*> children;\n    vector<pair<string, int>> wordCostPairs;\n};\n\nvoid insertTrie(TrieNode* root, const string& word, int cost) {\n    TrieNode* node = root;\n    for (char c : word) {\n        if (!node->children.count(c)) {\n            node->children[c] = new TrieNode();\n        }\n        node = node->children[c];\n    }\n    node->wordCostPairs.emplace_back(word, cost);\n}\n\nint dfs(const string& target, int pos, TrieNode* root, vector<int>& memo) {\n    int n = target.size();\n    if (pos == n) return 0;\n    if (memo[pos] != -1) return memo[pos];\n\n    int minCost = INT_MAX;\n    TrieNode* node = root;\n    \n    for (int i = pos; i < n; ++i) {\n        if (!node->children.count(target[i])) break;\n        node = node->children[target[i]];\n        for (const auto& [word, cost] : node->wordCostPairs) {\n            int nextCost = dfs(target, i + 1, root, memo);\n            if (nextCost != INT_MAX) {\n                minCost = min(minCost, cost + nextCost);\n            }\n        }\n    }\n\n    return memo[pos] = minCost;\n}\n\nint minimumCost(const string& target, const vector<string>& words, const vector<int>& costs) {\n    TrieNode* root = new TrieNode();\n    for (int i = 0; i < words.size(); ++i) {\n        insertTrie(root, words[i], costs[i]);\n    }\n\n    vector<int> memo(target.size(), -1);\n    int result = dfs(target, 0, root, memo);\n    return result == INT_MAX ? -1 : result;\n}\n};",
    "submit_ts": "1720322562",
    "subm_id": "1312353209"
}