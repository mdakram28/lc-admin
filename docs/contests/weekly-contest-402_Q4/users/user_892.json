{
    "username": "yh157612",
    "submission": "struct Node {\n    l: usize,\n    r: usize,\n    peaks: i32,\n    left: Option<Box<Node>>,\n    right: Option<Box<Node>>,\n}\n\nfn build_tree(nums: &Vec<i32>, l: usize, r: usize) -> Node {\n    if r - l <= 1 {\n        return Node {\n            l: l,\n            r: r,\n            peaks: if l > 0 && l + 1 < nums.len() && nums[l] > nums[l - 1].max(nums[l + 1]) { 1 } else { 0 },\n            left: None,\n            right: None,\n        }\n    }\n    let mid = (l + r) / 2;\n    let left = build_tree(nums, l, mid);\n    let right = build_tree(nums, mid, r);\n    Node {\n        l: l,\n        r: r,\n        peaks: left.peaks + right.peaks,\n        left: Some(Box::new(left)),\n        right: Some(Box::new(right)),\n    }\n}\n\nfn update(nums: &Vec<i32>, node: &mut Node, idx: usize) {\n    let l = node.l;\n    let r = node.r;\n    if r - l <= 1 {\n        node.peaks = if l > 0 && l + 1 < nums.len() && nums[l] > nums[l - 1].max(nums[l + 1]) { 1 } else { 0 };\n        return;\n    }\n    let mid = (l + r) / 2;\n    if idx < mid {\n        update(nums, node.left.as_deref_mut().unwrap(), idx);\n    } else {\n        update(nums, node.right.as_deref_mut().unwrap(), idx);\n    }\n    node.peaks = node.left.as_deref().unwrap().peaks + node.right.as_deref().unwrap().peaks;\n}\n\nfn query(node: &Node, l: usize, r: usize) -> i32 {\n    if r <= node.l {\n        return 0;\n    }\n    if l >= node.r {\n        return 0;\n    }\n    if l <= node.l && r >= node.r {\n        return node.peaks;\n    }\n    query(node.left.as_deref().unwrap(), l, r) + query(node.right.as_deref().unwrap(), l, r)\n}\n\nimpl Solution {\n    pub fn count_of_peaks(mut nums: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut root = build_tree(&nums, 0, nums.len());\n        let mut result = vec![];\n        for q in &queries {\n            if q[0] == 1 {\n                let res = query(&root, (q[1] + 1) as usize, q[2] as usize);\n                result.push(res);\n            } else {\n                let idx = q[1] as usize;\n                nums[idx] = q[2];\n                update(&nums, &mut root, idx);\n                if idx >= 1 {\n                    update(&nums, &mut root, idx - 1);\n                }\n                if idx + 1 < nums.len() {\n                    update(&nums, &mut root, idx + 1);\n                }\n            }\n        }\n        result\n    }\n}",
    "submit_ts": "1718509027",
    "subm_id": "1289697443"
}