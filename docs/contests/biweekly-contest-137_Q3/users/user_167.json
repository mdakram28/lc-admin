{
    "username": "lqybzx",
    "submission": "/*long long f[501][501][4];\nclass Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& board) {\n        int n = board.size();\n        int m = board[0].size();\n        int i, j, k;\n        memset(f, 0, sizeof(f));\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < m; j++) {\n                for (k = 0; k < j; k++) {\n                    f[i][j][1] = board[i][j];\n                    if (i != 0) {\n                        f[i][j][2] = max(f[i][j][2], f[i - 1][k][1] + board[i][j]);\n                        f[i][j][3] = max(f[i][j][3], f[i - 1][k][2] + board[i][j]);\n                    }\n                }\n            }\n        }\n        long long ans = 0;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < m; j++) {\n                ans = max(ans, f[i][j][3]);\n            }\n        }\n        return ans;\n    }\n};*/\nstruct map\n{\n     int s,t;\n     int f;\n     long long c;\n     int next;\n}a[1000001];\nint head[10001];\nint edge;\nint pre[10001],v[10001],q[1000001];\nlong long dis[10001];\nlong long max_flow,min_cost;\ninline int min(int x,int y)\n{\n     if(x<y)\n          return x;\n     return y;\n}\ninline void add(int s,int t,long long c,int f)\n{\n     edge++;\n\t a[edge].next=head[s];\n     head[s]=edge;\n     a[edge].s=s;\n     a[edge].t=t;\n     a[edge].c=c;\n     a[edge].f=f;\n}\ninline bool spfa(int as,int at)\n{\n     memset(pre,-1,sizeof(pre));\n     memset(dis,0x3f,sizeof(dis));\n     memset(v,false,sizeof(v));\n     int t=1,r=0,i,d;\n     r++;\n     q[r]=as;\n     dis[as]=0;\n     while(t<=r)\n     {\n          int d=q[t];\n          v[d]=false;\n          for(i=head[d];i!=0;i=a[i].next)\n          {\n               if(a[i].f>0&&dis[d]+a[i].c<dis[a[i].t])\n               {\n                    dis[a[i].t]=dis[d]+a[i].c;\n                    pre[a[i].t]=i;\n                    if(!v[a[i].t])\n                    {\n                         v[a[i].t]=true;\n                         r++;\n\t\t\t\t\t\t q[r]=a[i].t;\n                    }\n               }\n          }\n          t++;\n     }\n  //  for (i = 0; i < 10; i++) {\n  //      cout<<dis[i]<<\" \";\n  //  }\n  //  cout<<endl;\n     if(pre[at]!=-1)\n          return true;\n     return false;\n}\ninline long long mfmc(int as,int at)\n{\n     int d;\n  //   cout<<\"try to mfmc\\n\";\n     while(spfa(as,at))\n     {\n        // cout<<\"try to spfa\\n\";\n          long long minf=210000000ll;\n          d=at;\n          while(d!=as)\n          {\n               minf=min(minf,a[pre[d]].f);\n               d=a[pre[d]].s;\n          }\n        // cout<<\"minf: \"<<minf<<endl;\n          d=at;\n          while(d!=as)\n          {\n               a[pre[d]].f-=minf;\n               if(pre[d]%2==1)\n\t\t\t        a[pre[d]+1].f+=minf;\n               else\n\t\t\t        a[pre[d]-1].f+=minf;\n\t\t       d=a[pre[d]].s;\n          }\n          max_flow+=minf;\n          min_cost+=minf*dis[at];\n        // cout<<\"max_flow, min_cost: \" << max_flow <<\" \"<<min_cost<<endl;\n     }\n     return min_cost;\n}\nclass Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& board) {\n        int n = board.size();\n        int m = board[0].size();\n        int i, j, k;\n        int st = 0 , tt = n + m + 2;\n        edge = 0;\n        memset(head, 0, sizeof(head));\n        for (i = 0; i < n; i++) {\n            add(st, i+1, 0, 1);\n            add(i+1, st, 0, 0);\n            for (j = 0; j < m; j++) {\n                add(i+1, n+j+1, -board[i][j], 1);\n                add(n+j+1, i+1, board[i][j], 0);\n            }\n        }\n        \n        for (j = 0; j < m; j++) {\n            add(n+j+1, n+m+1, 0, 1);\n            add(n+m+1, n+j+1, 0,0);\n        }\n        //cout<<edge<<\", \"<<head[0]<<endl;\n        add(n+m+1,tt,0,3);\n        add(tt,n+m+1,0,0);\n        max_flow = 0;\n        min_cost = 0;\n        long long ans = mfmc(st, tt);\n        return -ans;\n    }\n};",
    "submit_ts": "1723907748",
    "subm_id": "556327255"
}