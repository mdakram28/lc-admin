{
    "username": "kodingcaro",
    "submission": "from collections import defaultdict, deque\nfrom typing import List\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        \n        def build_tree(edges):\n            graph = defaultdict(list)\n            for u, v in edges:\n                graph[u].append(v)\n                graph[v].append(u)\n            return graph\n        \n        def bfs(graph, start):\n            visited = set()\n            queue = deque([(start, 0)])\n            max_dist = 0\n            farthest_node = start\n            \n            while queue:\n                node, dist = queue.popleft()\n                visited.add(node)\n                if dist > max_dist:\n                    max_dist = dist\n                    farthest_node = node\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        queue.append((neighbor, dist + 1))\n            \n            return farthest_node, max_dist\n        \n        # Build trees from given edges\n        tree1 = build_tree(edges1)\n        tree2 = build_tree(edges2)\n        \n        # Function to find farthest node and diameter using BFS\n        def find_diameter(tree):\n            start_node, _ = bfs(tree, 0)\n            farthest_node, diameter = bfs(tree, start_node)\n            return farthest_node, diameter\n        \n        # Find diameters of tree1 and tree2\n        _, diameter1 = find_diameter(tree1)\n        _, diameter2 = find_diameter(tree2)\n        \n        # Calculate possible diameters after merging tree1 and tree2\n        merged_diameter = max(diameter1, diameter2, (diameter1 + 1) // 2 + (diameter2 + 1) // 2 + 1)\n        \n        return merged_diameter\n",
    "submit_ts": "1719715662",
    "subm_id": "1304342862"
}