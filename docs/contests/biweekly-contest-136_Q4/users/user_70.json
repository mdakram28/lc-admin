{
    "username": "boobik",
    "submission": "class Solution {\npublic:\n    vector<int> bfs(const vector<vector<int>>& tree, int start) {\n    int n = tree.size();\n    vector<int> dist(n, -1);\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n\n        for (int neighbor : tree[node]) {\n            if (dist[neighbor] == -1) {\n                dist[neighbor] = dist[node] + (neighbor%2==0 ? 2: 1);\n                q.push(neighbor);\n            }\n        }\n    }\n\n    return dist;\n}\n\nvector<int> find_max_distances(const vector<vector<int>>& edges) {\n    int n = edges.size() + 1;\n    \n    vector<vector<int>> tree(n);\n    for (const auto& edge : edges) {\n        tree[edge[0]].push_back(edge[1]);\n        tree[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> distA = bfs(tree, 0);\n    int farthest_node_A = max_element(distA.begin(), distA.end()) - distA.begin();\n\n    vector<int> distB = bfs(tree, farthest_node_A);\n    int farthest_node_B = max_element(distB.begin(), distB.end()) - distB.begin();\n\n    vector<int> dist_from_A = bfs(tree, farthest_node_A);\n    vector<int> dist_from_B = bfs(tree, farthest_node_B);\n\n    vector<int> max_distances(n);\n    for (int i = 0; i < n; ++i) {\n        max_distances[i] = max(dist_from_A[i] - (i%2==0) + (farthest_node_A%2==0), dist_from_B[i] - (i%2==0) +(farthest_node_B%2==0));\n    }\n\n    return max_distances;\n}\n\n    \n    \n    \n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        return find_max_distances(edges);\n    }\n};",
    "submit_ts": "1722697869",
    "subm_id": "1343161851"
}