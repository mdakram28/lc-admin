{
    "username": "XKTZ",
    "submission": "typedef long long ll;\n\nconstexpr ll MAXN = 1e5 + 5;\n\nll N;\npair<ll,pair<ll,ll>> BIT1[MAXN];\npair<ll,pair<ll,ll>> BIT2[MAXN];\n\nll M;\n\nunordered_map<ll, ll> toid;\n\npair<ll, pair<ll,ll>> query(pair<ll, pair<ll,ll>> *BIT, ll x) {\n    pair<ll, pair<ll,ll>> now = {0x3f3f3f3f3f3f3f3f, {-1, -1}};\n    for (; x; x -= (x & -x)) {\n        now = min(now, BIT[x]);\n    }\n    return now;\n}\n\nvoid upd(pair<ll, pair<ll,ll>> *BIT, ll x, ll v, pair<ll,ll> loc) {\n    for (; x <= M; x += (x & -x)) {\n        BIT[x] = min(BIT[x], {v, loc});\n    }\n}\n\nvoid bitcomp(vector<pair<ll,ll>> &pts) {\n    toid.clear();\n    vector<ll> ys;\n    for (auto [x, y]: pts) {\n        ys.push_back(y);\n    }\n    sort(ys.begin(), ys.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    for (ll i = 0; i < ys.size(); i ++) {\n        // cout << ys[i] << ':' << i << ' ';\n        toid[ys[i]] = i + 1;\n    }\n    // cout << endl;\n    M = ys.size();\n}\n\npair<pair<pair<ll,ll>,pair<ll,ll>>,ll> calc(vector<pair<ll, ll>> pts) {\n    bitcomp(pts);\n    sort(pts.begin(), pts.end());\n    for (ll i = 1; i <= M; i ++) {\n        BIT1[i] = BIT2[i] = {0x3f3f3f3f3f3f3f3f, {-1, -1}};\n    }\n    pair<pair<ll,ll>, pair<ll,ll>> ansnow = {{-1, -1}, {-1, -1}};\n    ll dis = 0;\n    for (auto [x, y]: pts) {\n        ll yid = toid[y];\n        // cout << x << ' ' << y << ' ' << yid << endl;\n        upd(BIT1, yid, x + y, {x, y});\n        // cout << x << ' ' << y << ' ' << yid << endl;\n        upd(BIT2, M - yid + 1, x - y, {x, y});\n        // cout << x << ' ' << y << ' ' << query(BIT1, yid) << ' ' << query(BIT2, M - yid + 1) << '\\n';\n        // cout << x << ' ' << y << ' ' << yid << endl;\n        auto [c1, loc1] = query(BIT1, yid);\n        auto [c2, loc2] = query(BIT2, M - yid + 1);\n        ll dnow = (x + y) - c1;\n        pair<pair<ll,ll>, pair<ll,ll>> ans = {{x, y}, loc1};\n        if ((x -y ) - c2 > dnow) {\n            dnow = (x -y ) - c2;\n            ans = {{x, y}, loc2};\n        }\n        if (dnow >= dis) {\n            dis = dnow;\n            ansnow = ans;\n        }\n    }\n    return {ansnow, dis};\n}\n\nclass Solution {\npublic:\n    int minimumDistance(vector<vector<int>>& points) {\n        N = points.size();\n        vector<pair<ll,ll>> pts;\n        for (auto &v: points) {\n            pts.push_back({v[0], v[1]});\n        }\n        \n        auto [anss, d] = calc(pts);\n        \n        auto [ans1, ans2] = anss;\n        \n        vector<pair<ll,ll>> ptx = pts;\n        \n        for (auto it = ptx.begin(); it != ptx.end(); ++it) {\n            if ((*it) == ans1) {\n                ptx.erase(it);\n                break;\n            }\n        }\n        \n        auto [a1, d2] = calc(ptx);\n        \n        ptx = pts;\n        for (auto it = ptx.begin(); it != ptx.end(); ++it) {\n            if ((*it) == ans2) {\n                ptx.erase(it);\n                break;\n            }\n        }\n        \n        auto [a2, d3] = calc(ptx);\n        \n        // cout << ans1.first << ' ' << ans1.second << ' ' << ans2.first << ' ' << ans2.second << '\\n';\n        \n        return min({d, d2, d3});\n    }\n};"
}