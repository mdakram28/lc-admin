{
    "username": "akayan",
    "submission": "class Solution {\n  fun getResults(queries: Array<IntArray>): List<Boolean> {\n    class SegmentTree(private val size: Int) {\n      private val tree = let {\n        val pow = Math.ceil(Math.log(size.toDouble()) / Math.log(2.0))\n        IntArray(Math.pow(2.0, pow).toInt() * 2) { 0 }\n      }\n      private val lazy = IntArray(tree.size) { 0 }\n      init {\n        build(1, 0, size - 1)\n      }\n\n      private fun build(node: Int, start: Int, end: Int) {\n        if (start == end) {\n          tree[node] = 0\n        } else {\n          val mid = (start + end) / 2\n          build(2 * node, start, mid)\n          build(2 * node + 1, mid + 1, end)\n          tree[node] = maxOf(tree[2 * node], tree[2 * node + 1])\n        }\n      }\n\n      private fun updateRange(node: Int, start: Int, end: Int, l: Int, r: Int, value: Int) {\n        if (lazy[node] != 0) {\n          tree[node] += lazy[node]\n          if (start != end) {\n            lazy[node * 2] += lazy[node]\n            lazy[node * 2 + 1] += lazy[node]\n          }\n          lazy[node] = 0\n        }\n\n        if (start > end || start > r || end < l) {\n          return\n        }\n\n        if (start >= l && end <= r) {\n          tree[node] += value\n          if (start != end) {\n            lazy[node * 2] += value\n            lazy[node * 2 + 1] += value\n          }\n          return\n        }\n\n        val mid = (start + end) / 2\n        updateRange(node * 2, start, mid, l, r, value)\n        updateRange(node * 2 + 1, mid + 1, end, l, r, value)\n        tree[node] = maxOf(tree[node * 2], tree[node * 2 + 1])\n      }\n\n      private fun queryMax(node: Int, start: Int, end: Int, l: Int, r: Int): Int {\n        if (start > end || start > r || end < l) {\n          return Int.MIN_VALUE\n        }\n\n        if (lazy[node] != 0) {\n          tree[node] += lazy[node]\n          if (start != end) {\n            lazy[node * 2] += lazy[node]\n            lazy[node * 2 + 1] += lazy[node]\n          }\n          lazy[node] = 0\n        }\n\n        if (start >= l && end <= r) {\n          return tree[node]\n        }\n\n        val mid = (start + end) / 2\n        val leftMax = queryMax(node * 2, start, mid, l, r)\n        val rightMax = queryMax(node * 2 + 1, mid + 1, end, l, r)\n        return maxOf(leftMax, rightMax)\n      }\n\n      fun update(l: Int, r: Int, value: Int) {\n        updateRange(1, 0, size - 1, l, r, value)\n      }\n\n      fun getMax(l: Int, r: Int): Int {\n        return queryMax(1, 0, size - 1, l, r)\n      }\n    }\n\n    val size = minOf(50001, 3*queries.size+1)\n    val segment = SegmentTree(size)\n    var count = 0\n    val treeMap = TreeSet<Int>()\n    val ansList = mutableListOf<Boolean>()\n    (0 until size).forEach { segment.update(it, it, count); count++ }\n    queries.forEach {\n      if (it[0] == 1) {\n        val x = it[1] + 1\n        val next = treeMap.ceiling(x)\n        val value = segment.getMax(x, x)\n        if (next != null) {\n          segment.update(x, next, -value+1)\n        } else {\n          segment.update(x, size-1, -value+1)\n        }\n        treeMap.add(x)\n      } else {\n        val (_, x, sz) = it\n        val result = segment.getMax(0, x)\n        if (result >= sz) {\n          ansList.add(true)\n        } else {\n          ansList.add(false)\n        }\n      }\n    }\n    return ansList\n  }\n}",
    "submit_ts": 1716652704.0
}