{
    "username": "jam-hsu",
    "submission": "class Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        int[] counter = new int[nums.length];\n        for (int i = 1; i < nums.length - 1; i++) {\n            if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {\n                counter[i]++;\n            }\n        }\n        /**\n        [8,10,10,9,10]\n[[2,0,1],[2,2,7],[1,0,2]]\n        **/\n        SegmentTreeAdd tree = new SegmentTreeAdd(counter);\n        List<Integer> ans = new ArrayList<>();\n        for (int[] q : queries) {\n            if (q[0] == 1) {\n                int l = q[1] + 1;\n                int r = q[2] - 1;\n                if (l <= r) {\n                    ans.add((int)tree.sum(l, r));\n                } else {\n                    ans.add(0);\n                }\n            } else if (nums.length > 2) {\n                if (q[1] == 0) {\n                    if (nums[1] > nums[0] && nums[1] > nums[2]) {\n                        if (nums[1] <= q[2]) {\n                            tree.add(1, -1);\n                        }\n                    }\n                    if (nums[1] > q[2] && nums[1] > nums[2] && tree.query(1) == 0) {\n                        tree.add(1, 1);\n                    }\n                } else if (q[1] == nums.length - 1) {\n                    if (nums[nums.length - 2] > nums[nums.length - 3] && nums[nums.length - 2] > nums[nums.length - 1]) {\n                        if (nums[nums.length - 2] <= q[2]) {\n                            tree.add(nums.length - 2, -1);\n                        }\n                    }\n                    if (nums[nums.length - 2] > nums[nums.length - 3] && nums[nums.length - 2] > q[2] && tree.query(nums.length - 2) == 0) {\n                        tree.add(nums.length - 2, 1);\n                    }\n                } else {\n                    int l = q[1] - 1;\n                    int r = q[1] + 1;\n                    int c = q[1];\n                    if (q[2] >= nums[l] && tree.query(l) > 0) {\n                        tree.add(l, -1);\n                    }\n                    if (q[2] < nums[l] && l > 0 && nums[l] > nums[l - 1] && tree.query(l) == 0) {\n                        tree.add(l, 1);\n                    }\n                    if (q[2] >= nums[r] && tree.query(r) > 0) {\n                        tree.add(r, -1);\n                    }\n                    if (q[2] < nums[r] && r < nums.length - 1 && nums[r] > nums[r + 1] && tree.query(r) == 0) {\n                        tree.add(r, 1);\n                    }\n                    if (q[2] > nums[l] && q[2] > nums[r] && tree.query(c) == 0) {\n                        tree.add(c, 1);\n                    }\n                    if ((q[2] <= nums[l] || q[2] <= nums[r]) && tree.query(c) > 0) {\n                        tree.add(c, -1);\n                    }\n                }\n                System.out.println(tree.sum(0, nums.length - 1));\n                nums[q[1]] = q[2];\n            }\n        }\n        return ans;\n    }\n    \n    class SegmentTreeAdd{\n    int[] nums;\n    long[] tree, lazy;\n    int n;\n    public SegmentTreeAdd(int[] nums){\n        this.nums = nums;\n        this.n = nums.length;\n        this.tree = new long[4 * n];\n        this.lazy = new long[4 * n];\n        build(0, n - 1, 1);\n    }\n    public void add(int i, int x){ // \u5355\u70b9\u4fee\u6539(\u9a71\u52a8): \u589e\u91cf\u5f0f nums[i] += x\n        add(i, x, 0, n - 1, 1);\n    }\n    public void update(int i, int x){ // \u5355\u70b9\u4fee\u6539(\u9a71\u52a8): \u8986\u76d6\u5f0f nums[i] = x\n        update(i, x, 0, n - 1, 1);\n    }\n    public long query(int i){ // \u5355\u70b9\u67e5\u8be2 (\u9a71\u52a8): \u67e5\u8be2 nums[i]\n        return query(i, 0, n - 1, 1);\n    }\n    public void add(int l, int r, int x){ // \u533a\u95f4\u4fee\u6539(\u9a71\u52a8): \u589e\u91cf\u5f0f [l,r] \u533a\u95f4\u6240\u6709\u5143\u7d20\u52a0\u4e0ax\n        add(l, r, x, 0, n - 1, 1);\n    }\n    public long sum(int l, int r){ // \u533a\u95f4\u67e5\u8be2(\u9a71\u52a8): nums[l]~nums[r]\u4e4b\u548c\n        return sum(l, r, 0, n - 1, 1);\n    }\n    public long min(int l, int r){ // \u533a\u95f4\u67e5\u8be2 (\u9a71\u52a8): \u67e5\u8be2[l,r]\u4e2d\u7684\u6700\u5c0f\u503c\n        return min(l, r, 0, n - 1, 1);\n    }\n    public long max(int l, int r){ // \u533a\u95f4\u67e5\u8be2 (\u9a71\u52a8): \u67e5\u8be2[l,r]\u4e2d\u7684\u6700\u5927\u503c\n        return max(l, r, 0, n - 1, 1);\n    }\n    // \u5355\u70b9\u4fee\u6539: \u589e\u91cf\u5f0f \u4ee4nums[idx] += x\u3002\u4fee\u6539\u53f6\u5b50\u7ed3\u70b9\uff0c\u65e0\u5173\u6807\u8bb0\u3002\n    private void add(int idx, int x, int s, int t, int i){\n        if(s == t) {\n            tree[i] += x; // \u589e\u91cf\u66f4\u65b0\n            return;\n        }\n        int c = s + (t - s) / 2;\n        if(lazy[i] != 0) pushDown(s, c, t, i); // \u662f\u5426\u63a8\u9001\u6807\u8bb0\n        if(idx <= c) add(idx, x, s, c, i * 2);\n        else add(idx, x, c + 1, t, i * 2 + 1);\n        pushUp(i); // \u540e\u5e8f\u52a8\u4f5c\uff0c\u81ea\u5e95\u5411\u4e0a\u66f4\u65b0\u7ed3\u70b9\u533a\u95f4\u548c tree[i]\n    }\n    // \u5355\u70b9\u4fee\u6539: \u8986\u76d6\u5f0f \u4ee4nums[idx] = x\u3002\u4fee\u6539\u53f6\u5b50\u7ed3\u70b9\uff0c\u65e0\u5173\u6807\u8bb0\u3002\n    private void update(int idx, int x, int s, int t, int i){\n        if(s == t) {\n            tree[i] = x; // \u8986\u76d6\u66f4\u65b0\n            return;\n        }\n        int c = s + (t - s) / 2;\n        if(lazy[i] != 0) pushDown(s, c, t, i); // \u662f\u5426\u63a8\u9001\u6807\u8bb0\n        if(idx <= c) update(idx, x, s, c, i * 2);\n        else update(idx, x, c + 1, t, i * 2 + 1);\n        pushUp(i);  // \u540e\u5e8f\u52a8\u4f5c\uff0c\u81ea\u5e95\u5411\u4e0a\u66f4\u65b0\u7ed3\u70b9\u533a\u95f4\u548c tree[i]\n    }\n    // \u5355\u70b9\u67e5\u8be2 (\u5177\u4f53): \u67e5\u8be2 nums[i]\uff0c\u5c3e\u9012\u5f52\n    private long query(int idx, int s, int t, int i){\n        if(s == t) return tree[i];\n        int c = s + (t - s) / 2;\n        if(lazy[i] != 0) pushDown(s, c, t, i); // \u662f\u5426\u63a8\u9001\u6807\u8bb0\n        if(idx <= c) return query(idx, s, c, i * 2);\n        else return query(idx, c + 1, t, i * 2 + 1);\n    }\n    // \u533a\u95f4\u4fee\u6539: \u589e\u91cf\u5f0f [l,r] \u533a\u95f4\u6240\u6709\u5143\u7d20\u52a0\u4e0ax\n    private void add(int l, int r, int x, int s, int t, int i){\n        if(l <= s && t <= r){ // \u5f53\u524d\u7ed3\u70b9\u4ee3\u8868\u7684\u533a\u95f4\u5728\u6240\u6c42\u533a\u95f4\u4e4b\u5185\n            tree[i] += (t - s + 1) * x; // \u7ed3\u70b9i\u7684\u533a\u95f4\u548c\u52a0\u4e0at-s+1\u4e2ax\n            if(s != t) lazy[i] += x; // \u7ed3\u70b9i\u4e0d\u662f\u53f6\u5b50\u7ed3\u70b9\uff0c\u61d2\u6807\u8bb0\u503c\u52a0\u4e0ax\n            return;\n        }\n        int c = s + (t - s) / 2;\n        if(lazy[i] != 0) pushDown(s, c, t, i); // \u662f\u5426\u63a8\u9001\u6807\u8bb0\n        if(l <= c) add(l, r, x, s, c, i * 2);\n        if(r > c) add(l, r, x, c + 1, t, i * 2 + 1);\n        pushUp(i); // \u540e\u5e8f\u52a8\u4f5c\uff0c\u81ea\u5e95\u5411\u4e0a\u66f4\u65b0\u7ed3\u70b9\u533a\u95f4\u548c tree[i]\n    }\n    // \u533a\u95f4\u67e5\u8be2: \u6c42 nums[l]~nums[r]\u4e4b\u548c\n    private long sum(int l, int r, int s, int t, int i){\n        if(l <= s && t <= r) return tree[i]; // \u5f53\u524d\u7ed3\u70b9\u4ee3\u8868\u7684\u533a\u95f4\u5728\u6240\u6c42\u533a\u95f4\u4e4b\u5185\n        int c = s + (t - s) / 2;\n        long sum = 0;\n        if(lazy[i] != 0) pushDown(s, c, t, i); // \u662f\u5426\u63a8\u9001\u6807\u8bb0\n        if(l <= c) sum += sum(l, r, s, c, i * 2);\n        if(r > c) sum += sum(l, r, c + 1, t, i * 2 + 1);\n        return sum;\n    }\n    // \u533a\u95f4\u67e5\u8be2: \u67e5\u8be2[l,r]\u4e2d\u7684\u6700\u5c0f\u503c\n    private long min(int l, int r, int s, int t, int i){\n        if(s == t) return tree[i]; // \u53f6\u5b50\u7ed3\u70b9\n        int c = s + (t - s) / 2;\n        long lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;\n        if(lazy[i] != 0) pushDown(s, c, t, i); // \u662f\u5426\u63a8\u9001\u6807\u8bb0\n        if(l <= c) lmin = min(l, r, s, c, i * 2);\n        if(r > c) rmin = min(l, r, c + 1, t, i * 2 + 1);\n        return Math.min(lmin, rmin);\n    }\n    // \u533a\u95f4\u67e5\u8be2: \u67e5\u8be2[l,r]\u4e2d\u7684\u6700\u5927\u503c\n    private long max(int l, int r, int s, int t, int i){\n        if(s == t) return tree[i];\n        int c = s + (t - s) / 2;\n        long lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;\n        if(lazy[i] != 0) pushDown(s, c, t, i);\n        if(l <= c) lmax = max(l, r, s, c, i * 2);\n        if(r > c) rmax = max(l, r, c + 1, t, i * 2 + 1);\n        return Math.max(lmax, rmax);\n    }\n    // \u6784\u5efa\u7ebf\u6bb5\u6811(tree\u6570\u7ec4)\n    private void build(int s, int t, int i){\n        if(s == t) { // s: start,nums\u5f53\u524d\u7ed3\u70b9\u533a\u95f4\u8d77\u70b9\u4e0b\u6807\uff0ct: terminal,nums\u5f53\u524d\u7ed3\u70b9\u533a\u95f4\u672b\u5c3e\u4e0b\u6807\n            tree[i] = nums[s];\n            return;\n        }\n        int c = s + (t - s) / 2;\n        build(s, c, i * 2);\n        build(c + 1, t, i * 2 + 1);\n        pushUp(i);  // \u540e\u5e8f\u52a8\u4f5c\uff0c\u81ea\u5e95\u5411\u4e0a\u66f4\u65b0\u7ed3\u70b9\u533a\u95f4\u548c tree[i]\n    }\n    // pushup: \u66f4\u65b0 tree[i]\n    private void pushUp(int i){\n        tree[i] = tree[i * 2] + tree[i * 2 + 1];\n    }\n    // pushdown: \u66f4\u65b0\u5f53\u524d\u7ed3\u70b9\u53ca\u5176\u5de6\u53f3\u5b50\u7ed3\u70b9\u7684\u61d2\u6807\u8bb0\n    private void pushDown(int s, int c, int t, int i){\n        tree[i * 2] += (c - s + 1) * lazy[i]; // \u66f4\u65b0\u5176\u5de6\u5b50\u7ed3\u70b9\u7684\u533a\u95f4\u548c\n        lazy[i * 2] += lazy[i]; // \u4f20\u9012\u61d2\u6807\u8bb0(\u589e\u91cf\u6807\u8bb0)\n        tree[i * 2 + 1] += (t - c) * lazy[i];\n        lazy[i * 2 + 1] += lazy[i];\n        lazy[i] = 0; // \u91cd\u7f6e\u5f53\u524d\u7ed3\u70b9\u61d2\u60f0\u6807\u8bb0\u503c\uff08\u589e\u91cf\u6807\u8bb0\u7f6e0\uff09\n    }\n}\n}",
    "submit_ts": "1718508472",
    "subm_id": "539787512"
}