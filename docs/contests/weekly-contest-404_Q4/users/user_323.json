{
    "username": "EricYXing",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1, m = edges2.size() + 1, r1 = -1, r2 = -1, h1 = 0, h2 = 0, ans = 0;\n        unordered_map<int, vector<int>> es1, es2;\n        for (auto& e : edges1)\n        {\n            es1[e[0]].push_back(e[1]);\n            es1[e[1]].push_back(e[0]);\n        }\n        for (auto& e : edges2)\n        {\n            es2[e[0]].push_back(e[1]);\n            es2[e[1]].push_back(e[0]);\n        }\n        pair<int, int> t1 = longest(es1, 0, n);\n        r1 = t1.first;\n        t1 = longest(es1, r1, n);\n        h1 = t1.second;\n        pair<int, int> t2 = longest(es2, 0, m);\n        r2 = t2.first;\n        t2 = longest(es2, r2, m);\n        h2 = t2.second;\n        int ht = (h1 / 2) + (h1 % 2) + (h2 / 2) + (h2 % 2) + 1;\n        ans = max(ht, max(h1, h2));\n        return ans;\n    }\n\nprivate: \n    pair<int, int> longest(unordered_map<int, vector<int>>& es, int s, int n)\n    {\n        vector<int> visited(n, INT_MAX);\n        visited[s] = 0;\n        queue<int> q;\n        q.push(s);\n        int h = 0, t = -1;\n        while (!q.empty())\n        {\n            int k = q.size();\n            for (int j = 0; j < k; j++)\n            {\n                int cur = q.front();\n                t = cur;\n                q.pop();\n                int new_h = visited[cur] + 1;\n                for (auto& nxt : es[cur])\n                {\n                    if (new_h < visited[nxt])\n                    {\n                        visited[nxt] = new_h;\n                        h = max(h, new_h);\n                        q.push(nxt);\n                    }\n                }\n            }\n        }\n        return {t, h};\n    }\n};",
    "submit_ts": "1719718172",
    "subm_id": "1304410556"
}