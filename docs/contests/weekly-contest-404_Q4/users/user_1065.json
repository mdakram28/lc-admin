{
    "username": "Shubham__77",
    "submission": "#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& e1, vector<vector<int>>& e2) {\n        int n = e1.size() + 1; \n        int m = e2.size() + 1;\n        vector<vector<int>> g1(n);\n        vector<vector<int>> g2(m);\n        for (const auto& edge : e1) {\n            g1[edge[0]].push_back(edge[1]);\n            g1[edge[1]].push_back(edge[0]);\n        }\n\n        for (const auto& edge : e2) {\n            g2[edge[0]].push_back(edge[1]);\n            g2[edge[1]].push_back(edge[0]);\n        }\n        auto [d1, ext1] = fd(g1);\n        auto [d2, ext2] = fd(g2);\n        cout<<d1<<\" \"<<d2;\n        int md = max({d1, d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1});\n\n        return md;\n    }\n\nprivate:\n    pair<int, vector<int>> fd(const vector<vector<int>>& g) {\n        int n = g.size();\n\n        if (n == 1) return {0, {0}};\n        auto [d1, farthest1] = bfs(0, g);\n        auto [d2, farthest2] = bfs(farthest1, g);\n        return {d2, {farthest1, farthest2}};\n    }\n\n    pair<int, int> bfs(int start, const vector<vector<int>>& g) {\n        int n = g.size();\n        vector<int> d(n, -1);\n        queue<int> q;\n\n        d[start] = 0;\n        q.push(start);\n\n        int maxd = 0;\n        int farthestNode = start;\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n\n            for (int nbh : g[node]) {\n                if (d[nbh] == -1) {\n                    d[nbh] = d[node] + 1;\n                    q.push(nbh);\n                    if (d[nbh] > maxd) {\n                        maxd = d[nbh];\n                        farthestNode = nbh;\n                    }\n                }\n            }\n        }\n\n        return {maxd, farthestNode};\n    }\n};\n",
    "submit_ts": "1719719538",
    "subm_id": "1304444421"
}