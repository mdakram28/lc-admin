{
    "username": "resotto",
    "submission": "class Solution {\n    public int[] shortestDistanceAfterQueries(int n, int[][] queries) {\n        // 3 <= N <= 10^5\n        // 1 <= M <= 10^5\n        // u < v (more than 1 node distance)\n        \n        // There are no two queries such that queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1].\n\n        var graph = new HashMap<Integer, Integer>();\n        for (int i = 0; i < n-1; i++) {\n            graph.put(i, i+1);\n        }\n        int m = queries.length, total = n-1;\n        var ans = new int[m];\n        for (int i = 0; i < m; i++) {\n            int u = queries[i][0], v = queries[i][1];\n            if (graph.get(u) != null && graph.get(u) < v) {\n                int cur = graph.get(u), cost = 0;\n                while (cur < v) {\n                    cost++;\n                    int next = graph.get(cur);\n                    graph.remove(cur);\n                    cur = next;\n                }\n                total -= cost;\n                graph.put(u, v);\n            }\n            ans[i] = total;\n        }\n        return ans;\n    }\n}\n\n/*\n        var graph = new HashMap<Integer, Integer>();\n        for (int i = 0; i < n-1; i++) {\n            graph.put(i, i+1);\n        }\n        int m = queries.length, total = n-1;\n        var ans = new int[m];\n        for (int i = 0; i < m; i++) {\n            int u = queries[i][0], v = queries[i][1];\n            if (graph.get(u) != null && graph.get(u) < v) {\n                for (int j = u+1; j < v; j++) {\n                    graph.remove(j);\n                }\n                total = Math.max(1, total - (v - graph.get(u)));\n                graph.put(u, v);\n            }\n            ans[i] = total;\n        }\n        return ans;\n\n        var memo = new int[n];\n        for (int i = 0; i < n; i++) {\n            memo[i] = n - 1 - i;\n        }\n        int m = queries.length;\n        var ans = new int[m];\n        for (int i = 0; i < m; i++) {\n            int u = queries[i][0], v = queries[i][1];\n            if (memo[u] < v - u) {\n                total -= (v - u) - pre;\n                graph.put(u, v - u);\n            }\n            ans[i] = total;\n        }\n        return ans;\n\n\n    public int[] shortestDistanceAfterQueries(int n, int[][] queries) {\n        // 3 <= N <= 10^5\n        // 1 <= M <= 10^5\n        // u < v (more than 1 node distance)\n        \n        // There are no two queries such that queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1].\n        // => all additional paths are independent => always contribute to the shortest path\n\n        var graph = new HashMap<Integer, Integer>();\n        for (int i = 0; i < n-1; i++) {\n            graph.put(i, 1);\n        }\n        int m = queries.length, total = n-1;\n        var ans = new int[m];\n        for (int i = 0; i < m; i++) {\n            int u = queries[i][0], v = queries[i][1], pre = graph.get(u);\n            if (pre < v - u) {\n                total -= (v - u) - pre;\n                graph.put(u, v - u);\n            }\n            ans[i] = total;\n        }\n        return ans;\n    }\n    \n5\n[[1,4],[2,4]]\n=> [2,2]\n*/",
    "submit_ts": "1722741327",
    "subm_id": "1343742231"
}