{
    "username": "saurabh600",
    "submission": "class seg_tree {\n  typedef long long ll;\n  struct node {\n    ll cnt, first, last, len;\n    bool fok, lok;\n\n    // void print_res() const {\n    //   cout << \"(len, f, ok, l, ok, cnt): \" << len << ' ' << first << \" \"<<fok << ' ' << last << ' '\n    //        << lok << \" \" << cnt << endl;\n    // }\n\n    node() {\n      cnt = 0, first = -1, last = -1, len = 0;\n      fok = 0, lok = 0;\n    }\n\n    void apply(ll v) {\n      cnt = 0, first = v, last = v;\n      fok = false, lok = false, len = 1;\n    }\n\n    node operator+(const node &other) const {\n      if (len == 0) return other;\n      if (other.len == 0) return *this;\n\n      node res;\n\n      res.len = len + other.len;\n      res.last = other.last, res.lok = other.lok;\n      res.first = first, res.fok = fok;\n\n      res.cnt = cnt + other.cnt;\n      if (lok && last > other.first) res.cnt++;\n      if (other.fok && other.first > last) res.cnt++;\n\n      if (other.len == 1) {\n        if (res.last > last) res.lok = 1;\n      }\n      if (len == 1) {\n        if (res.first > other.first) res.fok = 1;\n      }\n\n\n      // print_res();\n      // other.print_res();\n      // res.print_res();\n\n      return res;\n    }\n  };\n\n public:\n  template <class T>\n  seg_tree(int _n, const T &A) : n(_n) {\n    tree.resize(n << 2);\n    build(0, 0, n - 1, A);\n  }\n\n  ll query(int l, int r) { return query(0, 0, n - 1, l, r).cnt; }\n  void update(int pos, long long val) { update(0, 0, n - 1, pos, val); }\n\n private:\n  int n;\n  vector<node> tree;\n\n  template <class T>\n  void build(int i, int x, int y, const T &arr) {\n    if (x == y) {\n      tree[i].apply(arr[x]);\n    } else {\n      int m = (x + y) >> 1;\n      build(2 * i + 1, x, m, arr);\n      build(2 * i + 2, m + 1, y, arr);\n      tree[i] = tree[2 * i + 1] + tree[2 * i + 2];\n    }\n  }\n\n  node query(int i, int x, int y, int l, int r) {\n    if (r < x || l > y || l > r) return node{};\n    if (x >= l && y <= r) return tree[i];\n    int m = (x + y) >> 1;\n    return query(2 * i + 1, x, m, l, r) + query(2 * i + 2, m + 1, y, l, r);\n  }\n\n  void update(int i, int x, int y, int pos, long long val) {\n    if (x == y) {\n      tree[i].apply(val);\n    } else {\n      int mid = (x + y) >> 1;\n      if (pos >= x && pos <= mid) update(2 * i + 1, x, mid, pos, val);\n      else update(2 * i + 2, mid + 1, y, pos, val);\n      tree[i] = tree[2 * i + 1] + tree[2 * i + 2];\n    }\n  }\n};\n\nclass Solution {\n public:\n  vector<int> countOfPeaks(vector<int> &nums, vector<vector<int>> &queries) {\n    seg_tree tree(nums.size(), nums);\n    vector<int> res;\n    \n      // cout << \"here--\\n\";\n    for (auto it : queries) {\n      if (it[0] == 1) {\n        auto ans = tree.query(it[1], it[2]);\n        res.push_back(ans);\n      } else {\n        tree.update(it[1], it[2]);\n      }\n    }\n\n    return res;\n  }\n};\n",
    "submit_ts": 1718508675.0
}