{
    "username": "Abhi_Srivastava",
    "submission": "class Solution {\n\n    struct item {\n        long long alar, al1ar, alar1, al1ar1;\n    };\n\n    struct segtree {\n\n        int size;\n        vector<item> values;\n\n        item NEUTRAL_ELEMENT = {0, 0, 0, 0};\n\n        item merge(item a, item b) {\n            long long alar = max({0ll, a.alar1 + b.al1ar, a.alar + b.al1ar, a.alar1 + b.alar}), \n            al1ar = max({0ll, a.al1ar1 + b.al1ar, a.al1ar + b.al1ar, a.al1ar1 + b.alar}), \n            alar1 = max({0ll, a.alar1 + b.al1ar1, a.alar + b.al1ar1, a.alar1 + b.alar1}), \n            al1ar1 = max({0ll, a.al1ar1 + b.al1ar1, a.al1ar + b.al1ar1, a.al1ar1 + b.alar1});\n            return {alar, al1ar, alar1, al1ar1};\n        }\n\n        item single(int v) {\n            return {v, 0, 0, 0};\n        }\n\n        void init(int n) {\n            size = 1;\n            while (size < n)\n                size *= 2;\n            values.assign(2 * size, NEUTRAL_ELEMENT);\n        }\n\n        void build(vector<int>& a, int n, int x, int lx, int rx) {\n            if (rx - lx == 1) {\n                if (lx < n)\n                    values[x] = single(a[lx]);\n                return;\n            }\n            int m = (lx + rx) / 2;\n            build(a, n, 2 * x + 1, lx, m);\n            build(a, n, 2 * x + 2, m, rx);\n            values[x] = merge(values[2 * x + 1], values[2 * x + 2]);\n        }\n\n        void build(vector<int>& a, int n) {\n            build(a, n, 0, 0, size);\n        }\n\n        void set(int i, int v, int x, int lx, int rx) {\n            if (rx - lx == 1) {\n                values[x] = single(v);\n                return;\n            }\n            int m = (lx + rx) / 2;\n            if (i < m)\n                set(i, v, 2 * x + 1, lx, m);    \n            else\n                set(i, v, 2 * x + 2, m, rx);\n            values[x] = merge(values[2 * x + 1], values[2 * x + 2]);\n        }\n\n        void set(int i, int v) {\n            set(i, v, 0, 0, size);\n        }   \n\n        item calc(int l, int r, int x, int lx, int rx) {\n            if (lx >= r || rx <= l)\n                return NEUTRAL_ELEMENT;\n            if (lx >= l && rx <= r)\n                return values[x];\n            int m = (lx + rx) / 2;\n            item s1 = calc(l, r, 2 * x + 1, lx, m),\n            s2 = calc(l, r, 2 * x + 2, m, rx);\n            return merge(s1, s2);\n        }\n\n        item calc(int l, int r) {\n            return calc(l, r, 0, 0, size);\n        }\n\n    };\n\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), mod = 1e9 + 7;\n        segtree st;\n        st.init(n);\n        st.build(nums, n);\n        long long ans = 0;\n        for (auto x : queries) {\n            st.set(x[0], x[1]);\n            item res = st.calc(0, n);\n            (ans += max({res.alar, res.al1ar, res.alar1, res.al1ar1})) %= mod;\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716692642.0
}