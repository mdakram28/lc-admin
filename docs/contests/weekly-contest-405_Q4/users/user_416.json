{
    "username": "HarshDagar8181",
    "submission": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define V vector\n#define pb push_back\n#define pf push_front\n#define qb pop_back\n#define qf pop_front\n#define eb emplace_back\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\n#define fi first\n#define se second\n#define FR(i, a, b) for (int i = a; i <= b; i++)\n#define FRR(i, a, b) for (int i = a; i >= b; i--)\n#define _sort(x) sort((x).begin(),(x).end());\nconst int inf = 0x3f3f3f3f, mod = 1e9 + 7;\nconst ll infl = 0x3f3f3f3f3f3f3f3fll;\n\nclass Node{\n    public:\n    V<Node*>child;\n    char ch;\n    int cost;\n    bool is_term;\n    Node(char ch){\n        this->ch=ch;\n        cost=1e9;\n        is_term=0;\n        child.resize(26);\n        for(int i=0;i<26;i++){\n            child[i]=NULL;\n        }\n    }\n\n};\n\nclass Solution {\npublic:\n    Node*root;\n    void add_string(string str,int cost){\n        int n=str.size();\n        Node *iter=root;\n        for(int i=0;i<n;i++){\n            int ind=str[i]-'a';\n            if(iter->child[ind]==NULL){\n                Node*new_node=new Node(str[i]);\n                iter->child[ind]=new_node;\n                iter=new_node;\n                if(i==n-1){\n                    iter->is_term=1;\n                    iter->cost=cost;\n                }\n            }\n            else{\n                iter=iter->child[ind];\n                if(i==n-1){\n                    iter->cost=min(iter->cost,cost);\n                    iter->is_term=1;\n                }\n            }\n        }\n    }\n\n    int solve(string &s,int si,V<int>&dp){\n        int n=s.size();\n        if(si>=n){\n            return 0;\n        }\n        if(dp[si]!=-1)return dp[si];\n        Node*iter=root;\n        int res=1e9;\n        for(int i=si;i<n;i++){\n            int ind=s[i]-'a';\n            if(iter->child[ind]==NULL){\n                break;\n            }\n            iter=iter->child[ind];\n            if(iter->is_term){\n                int temp_res=iter->cost;\n                int x=solve(s,i+1,dp);\n                if(x==1e9)temp_res=x;\n                else temp_res+=x;\n                res=min(res,temp_res);\n            }\n        }\n        return dp[si]=res;\n        // return res;\n\n    }\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        root=new Node('@');\n        int n=words.size();\n        for(int i=0;i<n;i++){\n            add_string(words[i],costs[i]);\n        }\n        V<int>dp(target.size()+1,-1);\n        int res=solve(target,0,dp);\n        if(res==1e9)res=-1;\n\n        return res;\n\n\n        \n    }\n};",
    "submit_ts": "1720322091",
    "subm_id": "1312340426"
}