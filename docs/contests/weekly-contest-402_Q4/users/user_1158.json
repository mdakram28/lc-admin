{
    "username": "Anoop6598Rai",
    "submission": "class SEG {\npublic:\n       \n    SEG(const vector<int>& nums) {\n        n=nums.size();\n        seg.resize(4*n+5);\n        Build(nums, 0, 0, n - 1);\n    }\n\n    int query(int l, int r) {\n        return query(0, 0, n - 1, l, r);\n    }\n\n    void update(int ind, int val,  vector<int>& ARR) {\n        update(0, 0, n - 1, ind, val, ARR);\n    }\n    private:\n      int n;\n      vector<int>seg;\n    \n   \n bool ishigh(const vector<int>& nums, int i) {\n        if (i <= 0 || i >= nums.size() - 1) return false;\n        return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    }\n    \n    void Build(const vector<int>& nums, int ind, int low, int high) {\n       if(low==high)\n\t  {\n            seg[ind] = ishigh(nums,low) ? 1 : 0;\n            return;\n\t  }\n\t  int mid=(low+(high-low)/2);\n\t  Build(nums,2*ind+1,low,mid);\n\t  Build(nums,2*ind+2,mid+1,high);\n\t    seg[ind] = seg[2 * ind + 1] + seg[2 * ind + 2];\n    }\n\n    int query(int ind, int low, int high, int l, int r) {\n       \t // no overlap\n\t //l r low high or low high l r\n\t if(r<low||high<l) return 0;\n\t // complete overlap\n\t // [l low high r]\n\t if(low>=l&&high<=r) return seg[ind];\n\t //partial overlap\n\t int mid=(low+(high-low)/2);\n\t int left=query(2*ind+1,low,mid,l,r);\n\t int right=query(2*ind+2,mid+1,high,l,r);\n\t return left+right;\n    }\n    \n     bool isHigh(const vector<int>& nums, int i) {\n        if (i <= 0 || i >= nums.size() - 1) return false;\n        return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    }\n\n    void update(int node, int start, int end, int idx, int val,  vector<int>& nums) {\n        if (start == end) {\n            seg[node] = isHigh(nums, idx) ? 1 : 0;\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid) {\n                update(2 * node + 1, start, mid, idx, val, nums);\n            } else {\n                update(2 * node + 2, mid + 1, end, idx, val, nums);\n            }\n            seg[node] = seg[2 * node + 1] + seg[2 * node + 2];\n        }\n    }\n};\n// class SEG{\n//   public:\n//  vector<int>seg;\n//  SEG(int n)\n//  {\n// \t seg.resize(4*n+1);\n//  }\n// void build(int ind,int low,int high,int arr[])\n// {\n// \t  if(low==high)\n// \t  {\n// \t\t seg[ind]=arr[low];\n// \t\t return;\n// \t  }\n// \t  int mid=(low+(high-low)/2);\n// \t  build(2*ind+1,low,mid,arr);\n// \t  build(2*ind+2,mid+1,high,arr);\n// \t    seg[node] = seg[2 * node + 1] + seg[2 * node + 2];\n// }\n// int query(int ind,int low,int high,int l,int r)\n// {\n// \t // no overlap\n// \t //l r low high or low high l r\n// \t if(r<low||high<l) return INT_MAX;\n// \t // complete overlap\n// \t // [l low high r]\n// \t if(low>=l&&high<=r) return seg[ind];\n// \t //partial overlap\n// \t int mid=(low+(high-low)/2);\n// \t int left=query(2*ind+1,low,mid,l,r);\n// \t int right=query(2*ind+2,mid+1,high,l,r);\n// \t return left+right;\n// }\n// void update(int ind,int low,int high,int i,int val)\n// {\n//    if(low==high)\n//    {\n// \t seg[ind]=val;\n// \t return;\n//    }\n//    int mid=(low+(high-low)/2);\n//    if(i<=mid)\n//    update(2*ind+1,low,mid,i,val);\n//    else update(2*ind+2,mid+1,high,i,val);\n//    seg[ind]=min(seg[2*ind+1],seg[2*ind+2]);\n// }\n// };\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& QUERY) {\n        SEG segT(nums);\n        vector<int>answ;\n\n        for ( auto &q : QUERY) {\n            if (q[0] == 1) {\n                int l = q[1], r = q[2];\n                if (l == r) {\n                    answ.push_back(0);\n                } else {\n                    answ.push_back(segT.query(l + 1, r - 1));\n                }\n            } else if (q[0] == 2) {\n                int indx = q[1], val = q[2];\n                nums[indx] = val;\n                if (indx > 0) segT.update(indx - 1, nums[indx- 1], nums);\n                segT.update(indx, nums[indx], nums);\n                if (indx < (int)nums.size() - 1) segT.update(indx + 1, nums[indx + 1], nums);\n            }\n        }\n\n        return answ;\n    }\n};",
    "submit_ts": 1718509094.0
}