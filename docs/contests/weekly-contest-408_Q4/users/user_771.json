{
    "username": "ExpensiveAC",
    "submission": "class Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        \n        n = len(circles)\n        \n        def bin_sqrt(x):\n            l, r = 0, 10**9\n            while l < r:\n                mid = l + r >> 1\n                if mid * mid >= x:\n                    r = mid\n                else:\n                    l = mid+1\n                    \n            return l-1 if l * l > x else l\n        \n        #(X-a)^2 + (Y-b)^2 <= R^2\n        #if (X,Y) lies on any circle then it is impossible\n        for x, y, r in circles:\n            for a, b in [(0, 0), (X, Y)]:\n                if (a - x) * (a - x) + (b - y) * (b - y) <= (r * r):\n                    return False\n                \n        graph = defaultdict(lambda: [])\n        \n        def check(i,j):\n            \n            d = (circles[i][0] - circles[j][0])*(circles[i][0] - circles[j][0]) + (circles[i][1] - circles[j][1])*(circles[i][1] - circles[j][1])\n            radius_sum_sq = (circles[i][2] + circles[j][2]) ** 2\n            radius_diff_sq = (circles[i][2] - circles[j][2]) ** 2\n\n            if radius_diff_sq <= d <= radius_sum_sq:\n                return True\n            else:\n                return False\n        \n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    if check(i,j):\n                        graph[i].append(j)\n                        \n        def X_ins(C, X):\n            \n            x, y, r = C\n            ub = (r * r) - ((X - x) * (X - x))\n            if ub >= 0:\n                lb, ub = -bin_sqrt((r * r) - ((X - x) * (X - x))) + y, bin_sqrt((r * r) - ((X - x) * (X - x))) + y\n            if ub < 0 or lb > Y:\n                return False\n            else:\n                return True\n            \n        def Y_ins(C, Y):\n            x, y, r = C\n            ub = (r * r) - ((Y - y) * (Y - y))\n            if ub >= 0:\n                lb, ub = -bin_sqrt((r * r) - ((Y - y) * (Y - y))) + x, bin_sqrt((r * r) - ((Y - y) * (Y - y))) + x\n            if ub < 0 or lb > X:\n                return False\n            else:\n                return True\n                        \n        #top (X, 0) to (X, Y)\n        q = deque()\n        seen = set()\n        for i in range(len(circles)):\n            \n            #node touches top\n            if not Y_ins(circles[i], Y):\n                continue\n            else:\n                q.append(i)\n                seen.add(i)\n                \n        #print(q)\n                \n        \n        while q:\n            node = q.popleft()\n            #if node touches bottom or right\n            if X_ins(circles[node], X):\n                return False\n            if Y_ins(circles[node], 0):\n                return False\n            \n            for new_node in graph[node]:\n                if new_node not in seen:\n                    q.append(new_node)\n                    seen.add(new_node)\n                    \n                    \n        #horizontal\n        q = deque()\n        seen = set()\n        for i in range(len(circles)):\n            \n            #node touches top\n            if not X_ins(circles[i], 0):\n                continue\n            else:\n                q.append(i)\n                seen.add(i)\n                \n        #print(q)\n                \n        \n        while q:\n            node = q.popleft()\n            #if node touches bottom or right\n            if X_ins(circles[node], X):\n                return False\n            if Y_ins(circles[node], 0):\n                return False\n            \n            for new_node in graph[node]:\n                if new_node not in seen:\n                    q.append(new_node)\n                    seen.add(new_node)\n                    \n        \n            \n        return True\n",
    "submit_ts": "1722137974",
    "subm_id": "1335778738"
}