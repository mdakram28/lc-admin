{
    "username": "Pushkar_Varshney",
    "submission": "from typing import List\nimport heapq\n\nclass Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        # Create a dictionary to store words and their costs\n        word_cost_map = {}\n        for word, cost in zip(words, costs):\n            if word not in word_cost_map:\n                word_cost_map[word] = cost\n            else:\n                word_cost_map[word] = min(word_cost_map[word], cost)  # Store the minimum cost for the word\n\n        n = len(target)\n        # Priority queue (min-heap) for BFS\n        heap = [(0, 0)]  # (cost, index in target)\n        visited = [float('inf')] * (n + 1)\n        visited[0] = 0\n\n        while heap:\n            current_cost, i = heapq.heappop(heap)\n            \n            if i == n:\n                return current_cost\n            \n            if current_cost > visited[i]:\n                continue\n            \n            # Try to append each word\n            for word, word_cost in word_cost_map.items():\n                w_len = len(word)\n                if i + w_len <= n and target[i:i + w_len] == word:\n                    new_cost = current_cost + word_cost\n                    if new_cost < visited[i + w_len]:\n                        visited[i + w_len] = new_cost\n                        heapq.heappush(heap, (new_cost, i + w_len))\n\n        return -1 if visited[n] == float('inf') else visited[n]\n",
    "submit_ts": "1720324581",
    "subm_id": "1312403014"
}