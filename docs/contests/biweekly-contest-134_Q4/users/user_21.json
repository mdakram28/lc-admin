{
    "username": "STARs_56789",
    "submission": "#ifndef LOCAL\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\n\nnamespace mitsuha{\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &A) {\n    os << A.first << \" \" << A.second;\n    return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &A) {\n    for (size_t i = 0; i < A.size(); i++) {\n        if (i) os << \" \";\n        os << A[i];\n    }\n    return os;\n}\n\nvoid print() {\n    std::cout << \"\\n\";\n    std::cout.flush();\n}\n\ntemplate <class Head, class... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n    std::cout << head;\n    if (sizeof...(Tail)) std::cout << \" \";\n    print(std::forward<Tail>(tail)...);\n}\n}\n\nnamespace mitsuha {\ntemplate <class T> bool chmin(T& x, const T& y) { \n    return y >= x ? false : (x = y, true); \n}\ntemplate <class T> bool chmax(T& x, const T& y) { \n    return y <= x ? false : (x = y, true); \n}\ntemplate <class T> constexpr T fld(const T x, const T y) { \n    T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); \n}\ntemplate <class T> constexpr T cld(const T x, const T y) { \n    T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); \n}\ntemplate <class T> constexpr T rem(const T x, const T y) { \n    return x - y * fld(x, y); \n}\ntemplate <class Iterable> void settify(Iterable& a) { \n    std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); \n}\ntemplate <size_t D> struct Dim : std::array<int, D> {\n    template <typename ...Ints> Dim(const Ints& ...ns) : \n        std::array<int, D>::array{ static_cast<int>(ns)... } {}\n};\ntemplate <typename ...Ints> Dim(const Ints& ...) -> Dim<sizeof...(Ints)>;\ntemplate <class T, size_t D, size_t I = 0>\nauto ndvec(const Dim<D> &ns, const T& value = {}) {\n    if constexpr (I + 1 < D) {\n        return std::vector(ns[I], ndvec<T, D, I + 1>(ns, value));\n    } else {\n        return std::vector<T>(ns[I], value);\n    }\n}\n}\n\nnamespace mitsuha {\nusing str = std::string;\nusing int128 = __int128;\nusing uint128 = unsigned __int128;\ntemplate <class T> using min_priority_queue \n                            = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T> using max_priority_queue \n                            = std::priority_queue<T, std::vector<T>, std::less<T>>;\n}\nnamespace mitsuha { \n    const std::vector<std::string> Yes = {\"No\", \"Yes\"};\n    const std::vector<std::string> YES = {\"NO\", \"YES\"};\n}\n \n#ifndef __COUNTER__\n#define __COUNTER__ __LINE__\n#endif\n\n#define TL (long long)\n \n#define OVERLOAD5(a, b, c, d, e, ...) e\n#define REP1_0(b, c) REP1_1(b, c)\n#define REP1_1(b, c) for (long long REP_COUNTER_##c = 0; REP_COUNTER_##c < TL(b); ++REP_COUNTER_##c)\n#define REP1(b) REP1_0(b, __COUNTER__)\n#define REP2(i, b) for (long long i = 0; i < TL(b); ++i)\n#define REP3(i, a, b) for (long long i = TL(a); i < TL(b); ++i)\n#define REP4(i, a, b, c) for (long long i = TL(a); i < TL(b); i += TL(c))\n#define For(...) OVERLOAD5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)\n#define Frr(i, a) for (long long i = TL(a)-1; i >= 0; --i)\n\n#define All(iterable) std::begin(iterable), std::end(iterable)\n#define len(iterable) TL iterable.size()\n#define elif else if\n\n#define KBIT(a, k) (a & (1ULL << k))\n\n#define Assert(x) void(0);\n\nusing namespace mitsuha;\nusing namespace std;\n \nconstexpr int iinf = std::numeric_limits<int>::max() / 2;\nconstexpr long long linf = std::numeric_limits<long long>::max() / 2;\n\nnamespace mitsuha{\n// Monoid must be idempotent, faster than disjoint sparse table\ntemplate <class Monoid>\nstruct Sparse_Table {\n    using MX = Monoid;\n    using X = typename MX::value_type;\n    int n, log;\n    vector<vector<X>> dat;\n\n    Sparse_Table() {}\n    Sparse_Table(int n) { build(n); }\n    template <typename F>\n    Sparse_Table(int n, F f) {\n        build(n, f);\n    }\n    Sparse_Table(const vector<X>& v) { build(v); }\n\n    void build(int m) {\n        build(m, [](int i) -> X { return MX::unit(); });\n    }\n    void build(const vector<X>& v) {\n        build(len(v), [&](int i) -> X { return v[i]; });\n    }\n    template <typename F>\n    void build(int m, F f) {\n        n = m, log = 1;\n        while ((1 << log) < n) ++log;\n        dat.resize(log);\n        dat[0].resize(n);\n        for(int i = 0; i < n; i++) dat[0][i] = f(i);\n\n        for(int i = 0; i < log - 1; i++) {\n            dat[i + 1].resize(len(dat[i]) - (1 << i));\n            for(int j = 0; j < len(dat[i]) - (1 << i); j++) {\n                dat[i + 1][j] = MX::op(dat[i][j], dat[i][j + (1 << i)]);\n            }\n        }\n    }\n\n    X operator()(int L, int R){\n        if (L == R) return MX::unit();\n        if (R == L + 1) return dat[0][L];\n        int k = (R - L - 1 == 0 ? -1 : 31 - __builtin_clz(R - L - 1));\n        return MX::op(dat[k][L], dat[k][R - (1 << k)]);\n    }\n    X prod(int L, int R) {\n        return (*this)(L, R);\n    }\n\n    template <class F>\n    int max_right(int L, const F &check) {\n        assert(0 <= L && L <= n && check(MX::unit()));\n        if (L == n) return n;\n        int ok = L, ng = n + 1;\n        while (ok + 1 < ng) {\n            int k = (ok + ng) / 2;\n            bool bl = check(prod(L, k));\n            if (bl) ok = k;\n            if (!bl) ng = k;\n        }\n        return ok;\n    }\n\n    template <class F>\n    int min_left(int R, const F &check) {\n        assert(0 <= R && R <= n && check(MX::unit()));\n        if (R == 0) return 0;\n        int ok = R, ng = -1;\n        while (ng + 1 < ok) {\n            int k = (ok + ng) / 2;\n            bool bl = check(prod(k, R));\n            if (bl) ok = k;\n            if (!bl) ng = k;\n        }\n        return ok;\n    }\n};\n} // namespace mitsuha\n\nnamespace mitsuha{\ntemplate <typename X>\nstruct Monoid_And {\n    using value_type = X;\n    static X op(X x, X y) { return x & y; }\n    static constexpr X unit() { return (1 << 30) - 1; };\n    static constexpr bool commute = true;\n};\n} // namespace mitsuha\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        \n        int n = len(nums);\n\n        Sparse_Table<Monoid_And<int>> St(nums);\n        long long ret = 0;\n        For(x, n){\n            int lid = St.max_right(x, [&](int y){ return y > k; });\n            int rid = St.max_right(x, [&](int y){ return y >= k; });\n            ret += abs(rid - lid);\n        }\n        return ret;\n    }\n};\n\n\n",
    "submit_ts": "1720277539",
    "subm_id": "1311668483"
}