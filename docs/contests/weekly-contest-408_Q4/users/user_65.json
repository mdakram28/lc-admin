{
    "username": "wddd",
    "submission": "class Solution {\n    class UF {\n        int[] ids;\n        boolean[][] edges;\n\n        public UF(int n) {\n            ids = new int[n];\n            for (int i = 0; i < ids.length; i++) {\n                ids[i] = i;\n            }\n            edges = new boolean[n][4];\n        }\n\n        public void union(int p, int q) {\n            int pr = find(p);\n            int qr = find(q);\n            if (pr != qr) {\n                ids[pr] = qr;\n                edges[qr][0] = edges[qr][0] || edges[pr][0];\n                edges[qr][1] = edges[qr][1] || edges[pr][1];\n                edges[qr][2] = edges[qr][2] || edges[pr][2];\n                edges[qr][3] = edges[qr][3] || edges[pr][3];\n            }\n            edges[qr][0] = edges[qr][0] || edges[p][0] || edges[q][0];\n            edges[qr][1] = edges[qr][1] || edges[p][1] || edges[q][1];\n            edges[qr][2] = edges[qr][2] || edges[p][2] || edges[q][2];\n            edges[qr][3] = edges[qr][3] || edges[p][3] || edges[q][3];\n        }\n\n        public int find(int p) {\n            if (ids[p] != p) {\n                ids[p] = find(ids[p]);\n            }\n            return ids[p];\n        }\n    }\n\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        UF uf = new UF(circles.length);\n        for (int i = 0; i < circles.length; i++) {\n            if (in(circles[i], 0, 0) || in(circles[i], X, Y)) {\n                return false;\n            }\n            uf.edges[i][0] = circles[i][1] <= circles[i][2];\n            uf.edges[i][1] = circles[i][0] + circles[i][2] >= X;\n            uf.edges[i][2] = circles[i][1] + circles[i][2] >= Y;\n            uf.edges[i][3] = circles[i][0] <= circles[i][2];\n        }\n\n        for (int i = 0; i < circles.length; i++) {\n            int[] ci = circles[i];\n            for (int j = 1; j < circles.length; j++) {\n                int[] cj = circles[j];\n                if (connected(ci, cj)) {\n                    uf.union(i, j);\n                }\n            }\n        }\n\n        for (int i = 0; i < uf.ids.length; i++) {\n            if (uf.ids[i] == i) {\n                if (uf.edges[i][0] && (uf.edges[i][2] || uf.edges[i][3])) {\n                    return false;\n                }\n                if (uf.edges[i][1] && (uf.edges[i][2] || uf.edges[i][3])) {\n                    return false;\n                }\n                if (uf.edges[i][2] && (uf.edges[i][0] || uf.edges[i][1])) {\n                    return false;\n                }\n                if (uf.edges[i][3] && (uf.edges[i][0] || uf.edges[i][1])) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n\n    private boolean in(int[] circle, int x, int y) {\n        long r = (long) circle[2] * circle[2];\n        long d = (long) (circle[0] - x) * (circle[0] - x) + (long) (circle[1] - y) * (circle[1] - y);\n        return r >= d;\n    }\n\n    private boolean connected(int[] ci, int[] cj) {\n        long r = (long) (ci[2] + cj[2]) * (ci[2] + cj[2]);\n        long d = (long) (ci[0] - cj[0]) * (ci[0] - cj[0]) + (long) (ci[1] - cj[1]) * (ci[1] - cj[1]);\n        return r >= d;\n    }\n}",
    "submit_ts": "1722137976",
    "subm_id": "1335778781"
}