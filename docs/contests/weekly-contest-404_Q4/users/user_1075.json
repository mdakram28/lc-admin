{
    "username": "ak3177590",
    "submission": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <cmath> // for ceil\n\nusing namespace std;\n\nclass Solution {\npublic:\n    // Helper function to perform BFS and return the farthest node and its distance\n    pair<int, int> bfs(int src, unordered_map<int, vector<int>>& adj) {\n        queue<int> q;\n        q.push(src);\n        unordered_map<int, int> dist;\n        dist[src] = 0;\n        int farthestNode = src;\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            for (int neighbor : adj[node]) {\n                if (dist.find(neighbor) == dist.end()) {\n                    dist[neighbor] = dist[node] + 1;\n                    q.push(neighbor);\n                    if (dist[neighbor] > dist[farthestNode]) {\n                        farthestNode = neighbor;\n                    }\n                }\n            }\n        }\n\n        return {farthestNode, dist[farthestNode]};\n    }\n\n    // Helper function to find the diameter and radius of a tree\n    pair<int, int> findDiameterAndRadius(unordered_map<int, vector<int>>& adj) {\n        auto [farthestNode, _] = bfs(0, adj);\n        auto [otherEnd, diameter] = bfs(farthestNode, adj);\n        return {diameter, (diameter + 1) / 2};\n    }\n\n    // Helper function to build adjacency list from edges\n    unordered_map<int, vector<int>> buildAdjList(int n, vector<vector<int>>& edges) {\n        unordered_map<int, vector<int>> adj;\n        for (auto& edge : edges) {\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n        return adj;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n1 = edges1.size() + 1; // Number of nodes in tree 1\n        int n2 = edges2.size() + 1; // Number of nodes in tree 2\n\n        // Build adjacency lists for both trees\n        unordered_map<int, vector<int>> adj1 = buildAdjList(n1, edges1);\n        unordered_map<int, vector<int>> adj2 = buildAdjList(n2, edges2);\n\n        // Find the diameters and radii of both trees\n        auto [diameter1, radius1] = findDiameterAndRadius(adj1);\n        auto [diameter2, radius2] = findDiameterAndRadius(adj2);\n\n        // Calculate the new diameter by connecting the centers of both trees\n        int newDiameter = radius1 + radius2 + 1;\n\n        return max({diameter1, diameter2, newDiameter});\n    }\n};\n\n",
    "submit_ts": 1719718517.0
}