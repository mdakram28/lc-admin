{
    "username": "_priyanshu_101_",
    "submission": "class Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        \n        auto fixy = [&](long long x2, long long y2, long long y1, long long r) -> bool {\n            long long right = (r * r) - (y2 - y1) * (y2 - y1);\n            long long mxPoint = min(x2, 1ll * X);\n            return ((x2 - mxPoint) * (x2 - mxPoint) <= right);\n        };\n        \n         auto fixx = [&](long long x2, long long y2, long long x1, long long r) -> bool {\n            long long right = (r * r) - (x2 - x1) * (x2 - x1);\n            long long mxPoint = min(y2, 1ll * Y);\n            return ((y2 - mxPoint) * (y2 - mxPoint) <= right);\n        };\n        \n        \n        auto fixed = [&](long long x2, long long y2, long long x1, long long y1, long long r) -> bool {\n            long long right = (r * r);\n            long long left = ((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1));\n            // cout << left << ' ' << right << '\\n';\n            return left <= right;\n        };\n        \n        \n        int n = circles.size();\n        \n        // cout << \"YES1\\n\";\n        \n        vector <int> start(n), end(n);\n        vector <vector<int>> g(n);\n        for (int i = 0; i < n; i ++) {\n            long long x2 = circles[i][0], y2 = circles[i][1], r = circles[i][2];\n            if (fixed(x2, y2, 0LL, 0LL, r) || fixed(x2, y2, X, Y, r)) {\n                return false;\n            }\n            if (fixy(x2, y2, 0LL, r) || fixx(x2, y2, X, r)) {\n                start[i] = 1;\n            }\n            if (fixx(x2, y2, 0LL, r) || fixy(x2, y2, Y, r)) {\n                end[i] = 1;\n            }\n            // cout << start[i] << ' ' << end[i] << '\\n';\n            if (end[i] && start[i]) return false;\n            for (int j = i + 1; j < n; j ++) {\n                long long x1 = circles[j][0], y1 = circles[j][1], r1 = circles[j][2];\n                long long tot = (r1 + r) * (r1 + r);\n                long long have = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n                if (have <= tot) {\n                    g[i].push_back(j);\n                    g[j].push_back(i);\n                }\n            }\n        }\n        \n        vector <int> vis(n);\n        \n        auto bfs = [&](int s) -> bool {\n            queue <int> q;\n            q.push(s);\n            vis[s] = 1;\n            while (!q.empty()) {\n                int now = q.front();\n                q.pop();\n                vis[now] = 1;\n                if (end[now]) return true;\n                for (auto &next : g[now]) {\n                    if (!vis[next]) {\n                        vis[next] = 1;\n                        q.push(next);\n                        if (end[next]) return true;\n                    }\n                }\n            }\n            return false;\n        };\n        \n        // cout << \"Yes\\n\";\n        \n        for (int i = 0; i < n; i ++) {\n            if (start[i] && !vis[i]) {\n                if (bfs(i)) return false;\n            }\n        }\n        \n        return true;\n        \n        \n    }\n};",
    "submit_ts": "1722137153",
    "subm_id": "1335755694"
}