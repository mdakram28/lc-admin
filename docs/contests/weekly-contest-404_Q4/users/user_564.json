{
    "username": "nithish_654",
    "submission": "class Solution {\npublic:\n    void dfs(int node, int parent, vector<vector<int>>& graph, vector<int>& depth){\n        for(int child : graph[node]){\n            if(child == parent) continue;\n            depth[child] = depth[node] + 1;\n            dfs(child, node, graph, depth);\n        }\n    }\n    int diameter(vector<vector<int>>& graph, int n){\n        vector<int> depth(n, 1);\n        \n        dfs(0, -1, graph, depth);\n        int mx_v = 0;\n        \n        for(int i = 0; i < n; i++){\n            if(depth[mx_v] < depth[i])\n                mx_v = i;\n        }\n        for(int i = 0; i < n; i++){\n            depth[i] = 1;\n        }\n        dfs(mx_v, -1, graph, depth);\n        int ans = 0;\n        for(int i = 0; i < n; i++){\n            ans = max(ans, depth[i]);\n        }\n        return ans;\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1, m = edges2.size() + 1;\n        vector<vector<int>> graph1(n), graph2(m);\n        for(auto &v : edges1){\n            graph1[v[0]].push_back(v[1]);\n            graph1[v[1]].push_back(v[0]);\n        }\n        for(auto &v : edges2){\n            graph2[v[0]].push_back(v[1]);\n            graph2[v[1]].push_back(v[0]);\n        }\n        int d1 = diameter(graph1, n), d2 = diameter(graph2, m);\n        return max({d1 - 1, d2 - 1, d1/2 + d2/2 + 1});\n    }\n};\n",
    "submit_ts": "1719718835",
    "subm_id": "1304427245"
}