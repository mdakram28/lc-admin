{
    "username": "practical-vvingf4j",
    "submission": "#define f first\n#define s second\n#define lc (rt<<1)\n#define rc (rt<<1|1)\n#define pb push_back\n#define cl(a, b) memset(a, b, sizeof(a))\n#define mp(a, b) make_pair((a), (b))\n#define all(x) x.begin(),x.end()\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<pi, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pi> vii;\ntypedef vector<pl> vll;\ntypedef vector<pii> viii;\nconst int NO_DEB = 0;\n#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename... Args>\nvoid logger(string vals, Args &&...values){\n    if (NO_DEB) return;\n    cout << vals << \" = \";\n    string delim = \"\";\n    (..., (cout << delim << values, delim = \", \"));\n    cout << endl;\n}\ntemplate<int MOD> struct mint {\n    static const int mod = MOD;\n    int v;\n    explicit operator int() const { return v; }\n    mint():v(0) {}\n    mint(ll _v):v(int(_v%MOD)) { v += (v<0)*MOD; }\n    mint& operator+=(mint o) {\n        if ((v += o.v) >= MOD) v -= MOD;\n        return *this; }\n    mint& operator-=(mint o) {\n        if ((v -= o.v) < 0) v += MOD;\n        return *this; }\n    mint& operator*=(mint o) {\n        v = int((ll)v*o.v%MOD); return *this; }\n    mint& operator/=(const mint& o) { return (*this) *= inv(o); }\n    friend mint pow(mint a, ll p) { assert(p >= 0);\n        return p==0?1:pow(a*a,p/2)*(p&1?a:1); }\n    friend mint inv(mint a) { assert(a.v != 0); return pow(a,MOD-2); }\n    friend mint operator+(mint a, mint b) { return a += b; }\n    friend mint operator-(mint a, mint b) { return a -= b; }\n    friend mint operator*(mint a, mint b) { return a *= b; }\n    friend mint operator/(mint a, const mint& b) { return a /= b; }\n};\nconst int inf = 0x3F3F3F3F;\nconst ll infl = 0x3F3F3F3F3F3F3F3FLL;\nconst int mod = 1e9 + 7;\nusing mi = mint<mod>;\nvoid print(vector<ll> & a){\n    for(int i=0; i<a.size(); i++) cout << a[i] << \" \\n\"[i+1==a.size()];\n}\n\nconst int MM = 32;\nclass Solution {\npublic:\n    int minimumSum(vector<vector<int>>& grid) {\n        fun1(grid); fun2(grid);\n        for(int l=0, r=(int)grid.size()-1; l < r; l++, r--)  swap(grid[l], grid[r]);\n        fun2(grid);\n        for(int l=0, r=(int)grid.size()-1; l < r; l++, r--)  swap(grid[l], grid[r]);\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> grid2(n, vector<int>(m));\n        for(int i=0; i<n; i++)\n            for(int j=0; j<m; j++)\n                grid2[i][j] = grid[j][i];\n        fun1(grid2); fun2(grid2);\n        for(int l=0, r=(int)grid2.size()-1; l < r; l++, r--)  swap(grid2[l], grid2[r]);\n        fun2(grid2);\n        return ans;\n    }\n    void buildPsa(vector<vector<int>>& grid) {\n        m = grid.size(); n = grid[0].size();\n        cl(psa, 0);\n        for(int i=1; i<=m; i++)\n            for(int j=1; j<=n; j++)\n                psa[i][j] = psa[i-1][j] + psa[i][j-1] - psa[i-1][j-1] + grid[i-1][j-1];\n    }\n    int sum(int r1, int c1, int r2, int c2) {\n        return psa[r2][c2] - psa[r1-1][c2] - psa[r2][c1-1] + psa[r1-1][c1-1];\n    }\n    int getArea(vector<vi>& grid, int r1, int c1, int r2, int c2) {\n        r1--; c1--; r2--; c2--;\n        int mxR = -1, miR = 1e9, mxC=-1, miC = 1e9;\n        for(int i=r1; i<=r2; i++) {\n            for(int j=c1; j<=c2; j++) {\n                if(grid[i][j] != 0) {\n                    mxR = max(mxR, i); miR = min(miR, i);\n                    mxC = max(mxC, j); miC = min(miC, j);\n                }\n            }\n        }\n        return (mxR - miR + 1) * (mxC - miC + 1);\n    }\n    void fun1(vector<vector<int>>& grid) {\n        m = grid.size(); n = grid[0].size();\n        buildPsa(grid);\n        for(int r1=1; r1+2<=m; r1++) {\n            if(sum(1, 1, r1, n) == 0) continue;\n            for(int r2=r1+1; r2+1<=m; r2++) {\n                if(sum(r1+1, 1, r2, n) == 0) continue;\n                if(sum(r2+1, 1, m, n) == 0) continue;\n                ans = min(ans, getArea(grid, 1, 1, r1, n) + getArea(grid, r1+1, 1, r2, n) + getArea(grid, r2+1, 1, m, n));\n            }\n        }\n    }\n    void fun2(vector<vector<int>>& grid) {\n        m = grid.size(); n = grid[0].size();\n        buildPsa(grid);\n        for(int r1=1; r1+1<=m; r1++) {\n            if(sum(1, 1, r1, n) == 0) continue;\n            for(int c=1; c+1<=n; c++) {\n                if(sum(r1+1, 1, m, c)==0 || sum(r1+1, c+1, m, n) == 0) continue;\n                ans = min(ans, getArea(grid, 1, 1, r1, n) + getArea(grid, r1+1, 1, m, c) + getArea(grid, r1+1, c+1, m, n));\n            }\n        }\n    }\n    int m, n, ans = 1e9, psa[MM][MM];\n};",
    "submit_ts": 1719112549.0
}