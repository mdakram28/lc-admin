{
    "username": "xuela",
    "submission": "class Solution {\npublic:\n    // Function to calculate the maximum\n    // Manhattan distance\n    vector<int> MaxDist(vector<vector<int>>& A, int N)\n    {\n        // Vectors to store maximum and\n        // minimum of all the four forms\n        vector<pair<int, int>> V(N), V1(N);\n        \n        for (int i = 0; i < N; i++) {\n            V[i] = make_pair(A[i][0] + A[i][1], A[i][2]);\n            V1[i] = make_pair(A[i][0] - A[i][1], A[i][2]);\n        }\n\n        // Sorting both the vectors\n        sort(V.begin(), V.end());\n        sort(V1.begin(), V1.end());\n        \n        vector<int> ret(3, 0);\n        if(V.back().first - V.front().first > V1.back().first - V1.front().first) {\n            ret[0] = V.back().first - V.front().first;\n            ret[1] = V.back().second;\n            ret[2] = V.front().second;\n        }\n        else {\n            ret[0] = V1.back().first - V1.front().first;\n            ret[1] = V1.back().second;\n            ret[2] = V1.front().second;\n        }\n        return ret;\n\n    }\n    int minimumDistance(vector<vector<int>>& points) {\n        sort(points.begin(), points.end());\n        int n = points.size();\n        for(int i = 0; i < n; i++) {\n            points[i].push_back(i);\n        }\n        vector<int> vec = MaxDist(points, n);\n        vector<vector<int>> new_points1;\n        vector<vector<int>> new_points2;\n        for(int i = 0; i < n; i++) {\n            if(vec[1] != i) {\n                new_points1.push_back(points[i]);\n            }\n            if(vec[2] != i) {\n                new_points2.push_back(points[i]);\n            }\n        }\n        vector<int> vec1 = MaxDist(new_points1, n-1);\n        vector<int> vec2 = MaxDist(new_points2, n-1);\n        return min(vec1[0], vec2[0]);\n    }\n};"
}