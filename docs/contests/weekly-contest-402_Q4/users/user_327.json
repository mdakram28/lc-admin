{
    "username": "shdut-7",
    "submission": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <math.h>\n#include <random>\n#include <chrono> \n#include <assert.h>\n#include <ctime>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define pii pair<int, int>\n#define all(x) x.begin(),x.end()\n#define SZ(x) int(x.size())\n#define rep(i, a, b) for(int i = a; i < b; i++)\n#define per(i, a, b) for(int i = b-1; i >= a; i--)\n#define DBG(x) cerr << (#x) << \"=\" << x << \"\\n\";\n#define ll long long\n#define inf 1000000007\n#define mod 1000000007\n#define N 200005\n\ntemplate<typename U, typename V> void Min(U &a, const V & b){if(a > b)a = b;}\ntemplate<typename U, typename V> void Max(U &a, const V & b){if(a < b)a = b;}\ntemplate<typename U, typename V> void add(U &a, const V & b){a = (a + b) % mod;}\ntemplate<typename U> U gcd(U a, U b){\n    if(a == 0)return b;\n    if(b == 0)return a;\n    if(a >= b)return gcd(a % b, b);\n    else return gcd(a, b % a);\n}\nint pow(int a, int b){\n    int ans = 1;\n    while(b){\n        if(b & 1)ans = 1LL * ans * a % mod;\n        a = 1LL * a * a % mod;\n        b >>= 1;\n    }\n    return ans;\n}\nint pow(int a, ll b, int c){\n    int ans = 1;\n    while(b){\n        if(b & 1)ans = 1LL * ans * a % c;\n        a = 1LL * a * a % c;\n        b >>= 1;\n    }\n    return ans;\n}\n\nstruct DSU{\n    int n;\n    vi f, sz;\n    DSU(int _n) {\n        n = _n;\n        f.resize(n);\n        sz.resize(n);\n        rep(i, 0, n) f[i] = i, sz[i] = 1;\n    }\n    int find(int a) {\n        return f[a] == a ? a : f[a] = find(f[a]);\n    }\n    int merge(int a, int b) {\n        int x = find(a), y = find(b);\n        if (x == y) return 0;\n        if (sz[x] < sz[y]) swap(x, y);\n        sz[x] += sz[y];\n        f[y] = x;\n        return 1;\n    }\n};\n\nstruct Fen{\n    vi f;\n    void init(int n) {\n        f.resize(n+1);\n        for (auto &x : f) x = 0;\n    }\n    void upd(int x, int v) {\n        while(x < SZ(f)) f[x] += v, x += x & -x;\n    }\n    int query(int x) {\n        int ans = 0;\n        while(x > 0) ans += f[x], x -= x & -x;\n        return ans;\n    }\n};\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& queries) {\n        int n = SZ(a);\n        Fen fen;\n        fen.init(n);\n        auto check = [&](int x) {\n            return x > 0 && x < n-1 && a[x] > a[x-1] && a[x] > a[x+1];\n        };\n        rep(i, 1, n-1) {\n            if (check(i)) fen.upd(i, 1);\n        }\n        vi ans;\n        for (auto &q : queries) {\n            if (q[0] == 1) {\n                int res = max(0, fen.query(q[2]-1) - fen.query(q[1]));\n                ans.pb(res);\n            }\n            else {\n                rep(i, q[1]-1, q[1]+2) {\n                    if (check(i)) {\n                        fen.upd(i, -1);\n                    }\n                }\n                a[q[1]] = q[2];\n                rep(i, q[1]-1, q[1]+2) {\n                    if (check(i)) {\n                        fen.upd(i, 1);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n",
    "submit_ts": 1718505905.0
}