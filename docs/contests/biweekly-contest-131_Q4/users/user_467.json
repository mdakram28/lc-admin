{
    "username": "jie-crb",
    "submission": "using i64 = long long;\n\ntemplate<class Info, class Tag>\nstruct LazySegmengtree {\n\tint n;\n\tstd::vector<Info>info;\n\tstd::vector<Tag>tag;\n\n\tLazySegmengtree () {}\n\tLazySegmengtree (int n) {\n\t\tthis->n = n;\n\t\tinfo.assign(4 << std::__lg(n), Info()), tag.assign(4 << std::__lg(n), Tag());\n\t}\n\n\ttemplate<typename T>\n\tvoid build(std::vector<T> a) {\n\t\tauto work = [&](auto && self, int p, int l, int r) {\n\t\t\tif (l == r) {\n\t\t\t\tinfo[p] = Info(a[l]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint mid = std::midpoint(l, r);\n\t\t\tself(self, p << 1, l, mid), self(self, p << 1 | 1, mid + 1, r);\n\t\t\tinfo[p] = info[p << 1] + info[p << 1 | 1];\n\t\t};\n\t\twork(work, 1, 1, n);\n\t}\n\n\tvoid apply(int p, const Tag& v) {\n\t\tinfo[p].apply(v), tag[p].apply(v);\n\t}\n\tvoid pull(int p) {\n\t\tapply(p << 1, tag[p]), apply(p << 1 | 1, tag[p]);\n\t\ttag[p] = Tag();\n\t}\n\n\tvoid modify(int p, int l, int r, int L, int R, const Info& v) {\n\t\tif (l > R or r < L) {\n\t\t\treturn;\n\t\t}\n\t\tif (L <= l and r <= R) {\n\t\t\tinfo[p] = v;\n\t\t\treturn;\n\t\t}\n\t\tpull(p);\n\t\tint mid = std::midpoint(l, r);\n\t\tmodify(p << 1, l, mid, L, R, v), modify(p << 1 | 1, mid + 1, r, L, R, v);\n\t\tinfo[p] = info[p << 1] + info[p << 1 | 1];\n\t}\n\tvoid modify(int p, const Info& v) {\n\t\tmodify(1, 1, n, p, p, v);\n\t}\n\n\tInfo rangeQuery(int p, int l, int r, int L, int R) {\n\t\tif (l > R or r < L) {\n\t\t\treturn Info();\n\t\t}\n\t\tif (L <= l and r <= R) {\n\t\t\treturn info[p];\n\t\t}\n\t\tpull(p);\n\t\tint mid = std::midpoint(l, r);\n\t\treturn rangeQuery(p << 1, l, mid, L, R) + rangeQuery(p << 1 | 1, mid + 1, r, L, R);\n\t}\n\tInfo rangeQuery(int l, int r) {\n\t\treturn rangeQuery(1, 1, n, l, r);\n\t}\n\n\tvoid rangeApply(int p, int l, int r, int L, int R, const Tag& v) {\n\t\tif (l > R or r < L) {\n\t\t\treturn;\n\t\t}\n\t\tif (L <= l and r <= R) {\n\t\t\tapply(p, v);\n\t\t\treturn;\n\t\t}\n\t\tpull(p);\n\t\tint mid = std::midpoint(l, r);\n\t\trangeApply(p << 1, l, mid, L, R, v), rangeApply(p << 1 | 1, mid + 1, r, L, R, v);\n\t\tinfo[p] = info[p << 1] + info[p << 1 | 1];\n\t}\n\tvoid rangeApply(int l, int r, const Tag& v) {\n\t\trangeApply(1, 1, n, l, r, v);\n\t}\n\n\ttemplate<class F>\n\tint findFirst(int p, int l, int r, int L, int R, F pred) {\n\t\tif (l > R or r < L or !pred(info[p])) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (l == r) {\n\t\t\treturn l;\n\t\t}\n\t\tpull(p);\n\t\tint mid = std::midpoint(l, r);\n\t\tint res = findFirst(p << 1, l, mid, L, R, pred);\n\t\treturn res == -1 ? findFirst(p << 1 | 1, mid + 1, r, L, R, pred) : res;\n\t}\n\ttemplate<class F>\n\tint findFirst(int l, int r, F pred) {\n\t\treturn findFirst(1, 1, n, l, r, pred);\n\t}\n\n\ttemplate<class F>\n\tint findLast(int p, int l, int r, int L, int R, F pred) {\n\t\tif (l > R or r < L or !pred(info[p])) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (l == r) {\n\t\t\treturn l;\n\t\t}\n\t\tpull(p);\n\t\tint mid = std::midpoint(l, r);\n\t\tint res = findLast(p << 1 | 1, mid + 1, r, L, R, pred);\n\t\treturn res == -1 ? findLast(p << 1, l, mid, L, R, pred) : res;\n\t}\n\ttemplate<class F>\n\tint findLast(int l, int r, F pred) {\n\t\treturn findLast(1, 1, n, l, r, pred);\n\t}\n};\n\nconst i64 inf = 1E18;\n\nstruct Tag {\n\ti64 add = 0;\n\tvoid apply(const Tag& t) {\n\t\tadd += t.add;\n\t}\n};\nstruct Info {\n\ti64 max = -inf;\n\tvoid apply(const Tag& t) {\n\t\tmax += t.add;\n\t}\n};\nInfo operator+(const Info& a, const Info& b) {\n\treturn {std::max(a.max, b.max)};\n}\n\ntemplate<typename T>\nstruct Fenwick {\n\tint n;\n\tstd::vector<T>a;\n\tFenwick(const int n = 0): n(n), a(n + 1, T()) {}\n\tvoid add(int p, const T& x) {\n\t\twhile (p <= n) {\n\t\t\ta[p] += x;\n\t\t\tp += p & -p;\n\t\t}\n\t}\n\tT sum(int p) {\n\t\tT res = T();\n\t\twhile (p) {\n\t\t\tres += a[p];\n\t\t\tp -= p & -p;\n\t\t}\n\t\treturn res;\n\t}\n\tT rangeSum(int l, int r) {\n\t\treturn sum(r) - sum(l - 1);\n\t}\n};\n\nclass Solution {\npublic:\n\tvector<bool> getResults(vector<vector<int>>& queries) {\n\t\tint n = queries.size();\n\t\tint x = std::min((int)6e4, 4 * n);\n\t\t// int x = 1e5;\n\t\t// std::cout << x << \"\\n\\n\";\n\n\t\tLazySegmengtree<Info, Tag>s(x);\n\n\t\tfor (int i = 1; i <= x; i += 1) {\n\t\t\ts.modify(i, {i});\n\t\t}\n\n\t\tstd::set<int>f;\n\t\tstd::vector<bool>ans;\n\n\t\tfor (const auto & e : queries) {\n\t\t\tif (e[0] == 1) {\n\t\t\t\tint y = -1;\n                if(f.empty()){\n                    y=x;\n                }\n\t\t\t\telse if (e[1] < *f.begin()) {\n\t\t\t\t\ty = *f.begin();\n\t\t\t\t} else {\n\t\t\t\t\tif (e[1] > *f.rbegin()) {\n\t\t\t\t\t\ty = x;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty = *f.upper_bound(e[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts.rangeApply(e[1] + 1, y, {-1 * s.rangeQuery(e[1], e[1]).max});\n\t\t\t\tf.insert(e[1]);\n\t\t\t} else {\n\t\t\t\tint r = e[1];\n\t\t\t\tint sz = e[2];\n\t\t\t\tauto p = s.rangeQuery(1, e[1]);\n\t\t\t\t// std::cout << p.max << \"\\n\";\n\t\t\t\tif (p.max >= e[2]) {\n\t\t\t\t\tans.push_back(true);\n\t\t\t\t} else {\n\t\t\t\t\tans.push_back(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};",
    "submit_ts": 1716651594.0
}