{
    "username": "RakshitAryan",
    "submission": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    pair<int, int> performBFS(int startNode, const vector<vector<int>>& adjacencyList) {\n        int totalNodes = adjacencyList.size();\n        vector<int> distances(totalNodes, -1);\n        queue<int> nodesQueue;\n        nodesQueue.push(startNode);\n        distances[startNode] = 0;\n\n        int furthestNode = startNode;\n        int maximumDistance = 0;\n\n        while (!nodesQueue.empty()) {\n            int currentNode = nodesQueue.front();\n            nodesQueue.pop();\n            for (int neighbor : adjacencyList[currentNode]) {\n                if (distances[neighbor] == -1) {\n                    distances[neighbor] = distances[currentNode] + 1;\n                    nodesQueue.push(neighbor);\n                    if (distances[neighbor] > maximumDistance) {\n                        maximumDistance = distances[neighbor];\n                        furthestNode = neighbor;\n                    }\n                }\n            }\n        }\n\n        return {furthestNode, maximumDistance};\n    }\n\n    int calculateDiameter(const vector<vector<int>>& adjacencyList) {\n        auto firstBFSResult = performBFS(0, adjacencyList);\n        auto secondBFSResult = performBFS(firstBFSResult.first, adjacencyList);\n        return secondBFSResult.second;\n    }\n\n    int minimumDiameterAfterMerge(const vector<vector<int>>& edgesTree1, const vector<vector<int>>& edgesTree2) {\n        int sizeTree1 = edgesTree1.size() + 1;\n        int sizeTree2 = edgesTree2.size() + 1;\n\n        vector<vector<int>> adjacencyList1(sizeTree1);\n        vector<vector<int>> adjacencyList2(sizeTree2);\n\n        for (const auto& edge : edgesTree1) {\n            adjacencyList1[edge[0]].push_back(edge[1]);\n            adjacencyList1[edge[1]].push_back(edge[0]);\n        }\n\n        for (const auto& edge : edgesTree2) {\n            adjacencyList2[edge[0]].push_back(edge[1]);\n            adjacencyList2[edge[1]].push_back(edge[0]);\n        }\n\n        int diameter1 = calculateDiameter(adjacencyList1);\n        int diameter2 = calculateDiameter(adjacencyList2);\n\n        int heightTree1 = (diameter1 + 1) / 2;\n        int heightTree2 = (diameter2 + 1) / 2;\n\n        int mergedDiameter = max({diameter1, diameter2, heightTree1 + heightTree2 + 1});\n        return mergedDiameter;\n    }\n};\n",
    "submit_ts": "1719718691",
    "subm_id": "1304423692"
}