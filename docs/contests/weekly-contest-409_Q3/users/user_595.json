{
    "username": "mnm373",
    "submission": "///////////////////////////////////////////////////\n\nusing grid_t = vector<vector<int>>;\nusing edge_t = vector<vector<int>>;\n\nusing ull = unsigned long long int;\nusing lint = long long int;\n\nnamespace my {\ntemplate <class T>\nclass SegTree {\n   public:\n    using get_value_t = function<T(T, T)>;\n    using update_value_t =\n        function<T(T, int, int, T)>;         // orig, left, right, update\n    using lazy_value_t = function<T(T, T)>;  // orig, parent\n\n    SegTree(vector<T> &init, get_value_t get_value, update_value_t update_value,\n            lazy_value_t lazy_value)\n        : gf(get_value), uf(update_value), lf(lazy_value) {\n        int size = 1 << (int)(ceil(log2(init.size())) + 1);\n        tree.resize(size);\n        lazy.resize(size);\n        ranges.resize(size);\n\n        fill(lazy.begin(), lazy.end(), this->base);\n\n        this->rec_set(0, init, 0, init.size() - 1);\n    }\n\n    /**\n     * @brief Updates a range of the array to value\n     *\n     * @param v updates to\n     * @param l index starting at\n     * @param r index ending at (included)\n     *\n     * When updates could be 0, please set private `base` value other than 0\n     */\n    void update_range(T v, int l, int r) { this->rec_update(0, v, l, r); }\n\n    T get_range(int l, int r) { return this->rec_get_value(0, l, r); }\n\n   private:\n    vector<T> tree, lazy;\n    vector<pair<int, int>> ranges;\n\n    get_value_t gf;\n    update_value_t uf;\n    lazy_value_t lf;\n\n    T base = 0;  // TODO: another vector storing if any index has an update\n\n    void rec_update(int i, T v, int l, int r) {\n        auto [left, right] = ranges[i];\n        auto [j0, j1] = this->children_indx(i);\n\n        auto update_children = [&](T lz) {\n            if (left != right) {\n                lazy[j0] = this->lf(lazy[j0], lz);\n                lazy[j1] = this->lf(lazy[j1], lz);\n            }\n        };\n\n        if (lazy[i] != base) {\n            tree[i] = this->uf(tree[i], left, right, lazy[i]);\n\n            update_children(lazy[i]);\n\n            lazy[i] = base;\n        }\n\n        if (right < l || r < left || l > r) {\n            return;\n        }\n\n        if (left == l && right == r) {\n            tree[i] = this->uf(tree[i], left, right, v);\n\n            update_children(v);\n        } else {\n            int m = ranges[j0].second;\n\n            if (r <= m) {\n                this->rec_update(j0, v, l, r);\n                this->rec_update(j1, v, r, l);\n            } else if (m + 1 <= l) {\n                this->rec_update(j0, v, r, l);\n                this->rec_update(j1, v, l, r);\n            } else {\n                this->rec_update(j0, v, l, m);\n                this->rec_update(j1, v, m + 1, r);\n            }\n\n            tree[i] = this->gf(tree[j0], tree[j1]);\n        }\n    }\n\n    T rec_get_value(int i, int l, int r) {\n        auto [left, right] = ranges[i];\n        auto [j0, j1] = this->children_indx(i);\n\n        if (lazy[i] != base) {\n            tree[i] = this->uf(tree[i], left, right, lazy[i]);\n\n            if (left != right) {\n                lazy[j0] = this->lf(lazy[j0], lazy[i]);\n                lazy[j1] = this->lf(lazy[j1], lazy[i]);\n            }\n\n            lazy[i] = base;\n        }\n\n        if (right < l || r < left || l > r) {\n            return base;\n        }\n\n        if (left == l && right == r) {\n            return tree[i];\n        } else {\n            int m = ranges[j0].second;\n\n            if (r <= m) {\n                return this->gf(this->rec_get_value(j0, l, r),\n                                this->rec_get_value(j1, r, l));\n            } else if (m + 1 <= l) {\n                return this->gf(this->rec_get_value(j0, r, l),\n                                this->rec_get_value(j1, l, r));\n            } else {\n                return this->gf(this->rec_get_value(j0, l, m),\n                                this->rec_get_value(j1, m + 1, r));\n            }\n        }\n    }\n\n    void rec_set(int i, vector<T> &init, int l, int r) {\n        ranges[i] = make_pair(l, r);\n\n        if (l == r) {\n            tree[i] = init[l];\n            return;\n        }\n\n        int m = this->mid(l, r);\n        auto [j0, j1] = this->children_indx(i);\n\n        this->rec_set(j0, init, l, m);\n        this->rec_set(j1, init, m + 1, r);\n\n        tree[i] = this->gf(tree[j0], tree[j1]);\n    }\n\n    pair<int, int> children_indx(int i) {\n        return make_pair(2 * i + 1, 2 * i + 2);\n    }\n\n    int mid(int l, int r) { return (int)((lint)(l + r) >> 1); }\n};\n\n// range sum\n// update: add diff in range elements\nSegTree<int> newDiffSumSegTree(vector<int> &init) {\n    SegTree<int> s(\n        init, [](int a, int b) { return a + b; },\n        [](int o, int l, int r, int n) { return o + (r - l + 1) * n; },\n        [](int o, int n) { return o + n; });\n    return s;\n}\n\n// range max\n// update: set new value\nSegTree<int> newMaxSegTree(vector<int> &init) {\n    SegTree<int> s(\n        init, [](int a, int b) { return max(a, b); },\n        [](int o, int l, int r, int n) { return n; },\n        [](int o, int n) { return n; });\n    return s;\n}\n}  // namespace my\n\nclass Solution {\n   public:\n    vector<int> shortestDistanceAfterQueries(int n,\n                                             vector<vector<int>> &queries) {\n        vector<int> init(n - 1, 1);\n        my::SegTree<int> t(\n            init,\n            [](int a, int b) {\n                if (a == -1 && b == -1) {\n                    return -1;\n                }\n                if (a == -1) {\n                    return b;\n                }\n                if (b == -1) {\n                    return a;\n                }\n                return a + b;\n            },\n            [](int o, int l, int r, int n) { return n; },\n            [](int o, int n) { return n; });\n\n        vector<int> r;\n        r.reserve(queries.size());\n\n        for (auto item : queries) {\n            if (item[0] <= item[1] - 2) {\n                t.update_range(-1, item[0], item[1] - 2);\n            }\n            int v = t.get_range(0, n - 2);\n            if (v == -1) {\n                r.push_back(0);\n            } else {\n                r.push_back(v);\n            }\n        }\n\n        return r;\n    }\n};\n",
    "submit_ts": "1722742399",
    "subm_id": "1343768072"
}