{
    "username": "hab_ee_b",
    "submission": "class SegmentTree {\npublic:\n    SegmentTree(const vector<int>& nums) {\n        n = nums.size();\n        tree.resize(4 * n);\n        build(nums, 0, n - 1, 0);\n    }\n\n    void update(vector<int>& nums, int idx, int val) {\n        nums[idx] = val;\n        for (int i = max(0, idx - 1); i <= min(n - 1, idx + 1); ++i) {\n            updateTree(nums, i, 0, n - 1, 0);\n        }\n    }\n\n    int rangeQuery(const vector<int>& nums, int ql, int qr) {\n        int count = query(ql, qr, 0, n - 1, 0);\n        if (ql == qr) {\n            return 0;\n        }\n        if (ql < n && isPeak(nums, ql)) {\n            count--;\n        }\n        if (qr > 0 && isPeak(nums, qr)) {\n            count--;\n        }\n        return count;\n    }\n\nprivate:\n    int n;\n    vector<int> tree;\n\n    void build(const vector<int>& nums, int l, int r, int pos) {\n        if (l == r) {\n            tree[pos] = isPeak(nums, l) ? 1 : 0;\n            return;\n        }\n        int mid = (l + r) / 2;\n        build(nums, l, mid, 2 * pos + 1);\n        build(nums, mid + 1, r, 2 * pos + 2);\n        tree[pos] = tree[2 * pos + 1] + tree[2 * pos + 2];\n    }\n\n    bool isPeak(const vector<int>& nums, int i) {\n        if (i == 0 || i == nums.size() - 1) {\n            return false;\n        }\n        return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    }\n\n    void updateTree(const vector<int>& nums, int idx, int l, int r, int pos) {\n        if (l == r) {\n            tree[pos] = isPeak(nums, l) ? 1 : 0;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (idx <= mid) {\n            updateTree(nums, idx, l, mid, 2 * pos + 1);\n        } else {\n            updateTree(nums, idx, mid + 1, r, 2 * pos + 2);\n        }\n        tree[pos] = tree[2 * pos + 1] + tree[2 * pos + 2];\n    }\n\n    int query(int ql, int qr, int l, int r, int pos) {\n        if (ql > r || qr < l) {\n            return 0;\n        }\n        if (ql <= l && qr >= r) {\n            return tree[pos];\n        }\n        int mid = (l + r) / 2;\n        return query(ql, qr, l, mid, 2 * pos + 1) + query(ql, qr, mid + 1, r, 2 * pos + 2);\n    }\n};\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        SegmentTree segTree(nums);\n        vector<int> result;\n\n        for (const auto& query : queries) {\n            if (query[0] == 1) {\n                int li = query[1], ri = query[2];\n                result.push_back(segTree.rangeQuery(nums, li, ri));\n            } else if (query[0] == 2) {\n                int index = query[1], value = query[2];\n                segTree.update(nums, index, value);\n            }\n        }\n\n        return result;\n    }    \n\n};",
    "submit_ts": 1718507034.0
}