{
    "username": "mickeyandkaka1",
    "submission": "// {{{\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing vi = vector<int>;\nusing pii = pair<int, int>;\n#define sz(x) (int)((x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(a, b) memset(a, b, sizeof(a))\n#define debug(x...)\n#define debug_arr(x...)\n#ifdef LOCAL\n#include \"prettyprint.hpp\"\n#endif\n// }}}\n\nnamespace internal\n{\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n)\n{\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nconstexpr int bsf_constexpr(unsigned int n)\n{\n    int x = 0;\n    while (!(n & (1 << x))) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n)\n{\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n}  // namespace internal\n\ntemplate <class S, S (*op)(S, S), S (*e)()>\nstruct segtree\n{\npublic:\n    segtree() : segtree(0) {}\n    explicit segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    explicit segtree(const std::vector<S>& v) : _n((int)v.size())\n    {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--)\n        {\n            update(i);\n        }\n    }\n\n    void set(int p, S x)\n    {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) const\n    {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) const\n    {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r)\n        {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() const { return d[1]; }\n\n    template <bool (*f)(S)>\n    int max_right(int l) const\n    {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F>\n    int max_right(int l, F f) const\n    {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do\n        {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l])))\n            {\n                while (l < size)\n                {\n                    l = (2 * l);\n                    if (f(op(sm, d[l])))\n                    {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)>\n    int min_left(int r) const\n    {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F>\n    int min_left(int r, F f) const\n    {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do\n        {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm)))\n            {\n                while (r < size)\n                {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm)))\n                    {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\nprivate:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\ntemplate <class S, S (*op)(S, S), S (*e)(), class Coordinate>\nclass RangeTree\n{\n    int n;\n    using Pt = std::pair<Coordinate, Coordinate>;\n    std::vector<Pt> _pts;\n    std::vector<std::vector<Pt>> _range2yxs;\n    std::vector<segtree<S, op, e>> segtrees;\n    void _set(int v, Pt p, S val)\n    {\n        auto i = std::distance(\n            _range2yxs[v].begin(),\n            std::lower_bound(_range2yxs[v].begin(), _range2yxs[v].end(), Pt{p.second, p.first}));\n        segtrees[v].set(i, val);\n    }\n    void _add(int v, Pt p, S val)\n    {\n        auto i = std::distance(\n            _range2yxs[v].begin(),\n            std::lower_bound(_range2yxs[v].begin(), _range2yxs[v].end(), Pt{p.second, p.first}));\n        segtrees[v].set(i, op(segtrees[v].get(i), val));\n    }\n    S _prod(int v, Coordinate yl, Coordinate yr) const\n    {\n        auto comp = [&](const Pt& l, const Pt& r) { return l.first < r.first; };\n        auto il = std::distance(\n            _range2yxs[v].begin(),\n            std::lower_bound(_range2yxs[v].begin(), _range2yxs[v].end(), Pt{yl, yl}, comp));\n        auto ir = std::distance(\n            _range2yxs[v].begin(),\n            std::lower_bound(_range2yxs[v].begin(), _range2yxs[v].end(), Pt{yr, yr}, comp));\n        return segtrees[v].prod(il, ir);\n    }\n\npublic:\n    RangeTree() = default;\n    void add_point(Coordinate x, Coordinate y) noexcept { _pts.emplace_back(x, y); }\n    void build()\n    {\n        std::sort(_pts.begin(), _pts.end());\n        _pts.erase(std::unique(_pts.begin(), _pts.end()), _pts.end());\n        n = _pts.size();\n\n        _range2yxs.resize(n * 2);\n        for (int i = 0; i < n; i++) _range2yxs[n + i] = {{_pts[i].second, _pts[i].first}};\n        for (int i = n - 1; i > 0; i--)\n        {\n            auto& lch = _range2yxs[i * 2];\n            auto& rch = _range2yxs[i * 2 + 1];\n            std::merge(lch.begin(), lch.end(), rch.begin(), rch.end(),\n                       std::back_inserter(_range2yxs[i]));\n            _range2yxs[i].erase(std::unique(_range2yxs[i].begin(), _range2yxs[i].end()),\n                                _range2yxs[i].end());\n        }\n        for (const auto& v : _range2yxs) segtrees.emplace_back(v.size());\n    }\n    void set(Coordinate x, Coordinate y, S val)\n    {\n        int i = std::distance(_pts.begin(), std::lower_bound(_pts.begin(), _pts.end(), Pt{x, y}));\n        assert(i < n and _pts[i] == std::make_pair(x, y));\n        for (i += n; i; i >>= 1) _set(i, {x, y}, val);\n    }\n    void add(Coordinate x, Coordinate y, S val)\n    {\n        int i = std::distance(_pts.begin(), std::lower_bound(_pts.begin(), _pts.end(), Pt{x, y}));\n        assert(i < n and _pts[i] == std::make_pair(x, y));\n        for (i += n; i; i >>= 1) _add(i, {x, y}, val);\n    }\n    // l, d, r, u [xl, xr) * [yl, yr)\n    S prod(Coordinate xl, Coordinate yl, Coordinate xr, Coordinate yr) const\n    {\n        auto comp = [](const Pt& l, const Pt& r) { return l.first < r.first; };\n        int l = n + std::distance(_pts.begin(),\n                                  std::lower_bound(_pts.begin(), _pts.end(), Pt{xl, yr}, comp));\n        int r = n + std::distance(_pts.begin(),\n                                  std::lower_bound(_pts.begin(), _pts.end(), Pt{xr, yr}, comp));\n        S ret = e();\n        while (l < r)\n        {\n            if (l & 1) ret = op(ret, _prod(l++, yl, yr));\n            if (r & 1) ret = op(ret, _prod(--r, yl, yr));\n            l >>= 1, r >>= 1;\n        }\n        return ret;\n    }\n    S get(Coordinate x, Coordinate y) const { return prod(x, x + 1, y, y + 1); }\n};\n\n// \u66f4\u65b0\u30fb\u52a0\u7b97\u3092\u884c\u3046\u53ef\u80fd\u6027\u306e\u3042\u308b\u70b9\u3092\u5168\u3066add_point\u3059\u308b\n// bulid\u3059\u308b\n// \u4ee5\u4e0a\u306e2\u30b9\u30c6\u30c3\u30d7\u304c\u7d42\u308f\u3063\u305f\u5f8c\u306b\u3001set, add, prod, get\u304c\u884c\u3048\u308b\n\nusing S = long long;\nS op(S x, S y) { return x + y; }\nS e() { return 0; }\nclass Solution\n{\npublic:\n    int minChanges(vector<int>& nums, int k)\n    {\n        int n = sz(nums);\n        if (n <= 2) return 0;\n\n        int tot = n / 2;\n        RangeTree<S, op, e, int> bit;\n\n        vector<pii> point;\n        vector<pair<int, pii>> vec;\n        map<int, int> mp;\n        for (int i = 0; i < n / 2; i++)\n        {\n            int vl = nums[i];\n            int vr = nums[n - 1 - i];\n            if (vl > vr) swap(vl, vr);\n            vec.push_back({vr - vl, {vl, vr}});\n            point.push_back({vl, vr});\n            //cout << vl << \" \" << vr << endl;\n            mp[vr - vl]++;\n            bit.add_point(vl, vr);\n        }\n        sort(all(vec));\n\n        vector<pii> vec_mp;\n        for (auto pr : mp) vec_mp.push_back(pr);\n\n        int q = sz(mp);\n        vector<tuple<int, int, int, int, int>> query(q);\n        for (int i = 0; i < q; i++)\n        {\n            int x = vec_mp[i].first;\n            query[i] = {1, k - x + 1, 0, 100001, x};\n        }\n        bit.build();\n\n        for (int i = 0; i < tot; i++) bit.add(point[i].first, point[i].second, 1);\n\n        map<pii, int> q_res;\n        for (int i = 0; i < q; i++)\n        {\n            if (get<0>(query[i]) == 0)\n            {\n                // pass\n            }\n            else\n            {\n                int t, l, d, r, u;\n                tie(t, l, d, r, u) = query[i];\n                int res = bit.prod(l, d, r, u);\n                q_res[{l, u}] = res;\n                //cout << \"q_res \" << l << \" \" << u << \" \" << res << endl;\n            }\n        }\n\n        int ans = INT_MAX;\n        for (auto [x, cnt] : mp)\n        {\n            int cur = 0;\n            int c0 = cnt, c1 = 0, c2 = 0;\n            pii cur_query{k - x + 1, x};\n\n            c2 = q_res[cur_query];\n            c1 = tot - c0 - c2;\n\n            cur = c1 + 2 * c2;\n\n            //cout << x << \" \" << c2 << \" \" << cur << endl;\n\n            ans = min(ans, cur);\n        }\n        return ans;\n    }\n};\n\n",
    "submit_ts": "1721490083",
    "subm_id": "548321505"
}