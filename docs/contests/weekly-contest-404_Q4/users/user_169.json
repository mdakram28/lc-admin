{
    "username": "NinjaSatish",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& e1, vector<vector<int>>& e2) {\n        ios_base::sync_with_stdio(0);\n        cin.tie(0);\n        int n = e1.size() + 1, m = e2.size() + 1; \n        vector<vector<int>> g1(n), g2(m);\n        \n        for(auto &i : e1) g1[i[0]].push_back(i[1]), g1[i[1]].push_back(i[0]);\n        for(auto &i : e2) g2[i[0]].push_back(i[1]), g2[i[1]].push_back(i[0]);\n        \n        int mx = -1 , mxnode = 0 ;\n        function<void(int, int, int, int)> getFarthest = [&](int node, int dad, int dis, int tree){\n            if(dis > mx){\n                mx = dis ; mxnode = node ;\n            }\n            if(tree){\n                for(auto child : g2[node]){\n                    if(child == dad) continue;\n                    getFarthest(child, node, dis + 1, tree);\n                }   \n            }else{\n                for(auto child : g1[node]){\n                    if(child == dad) continue;\n                    getFarthest(child, node, dis + 1, tree);\n                }\n            }\n        };\n        \n        // get the end pts of diameter of the two trees\n        int pans = 0 ;\n        \n        getFarthest(0, -1, 0, 0);\n        pans = max(pans, mx);\n        int e1g1 = mxnode ; mx = -1; mxnode = 0 ;\n        \n        getFarthest(e1g1, -1, 0, 0);\n        pans = max(pans, mx);\n        int e2g1 = mxnode; mx = -1, mxnode = 0 ;\n        \n        getFarthest(0, -1, 0, 1);\n        pans = max(pans, mx);\n        int e1g2 = mxnode ; mx = -1; mxnode = 0;\n        \n        getFarthest(e1g2, -1, 0, 1);\n        int e2g2 = mxnode ;\n        pans = max(pans, mx);\n        \n        // cout << e1g1 << ' ' << e2g1 << \", \" << e1g2 << ' ' << e2g2 << endl;\n        \n        // get the pts with least max distance \n        vector<int> dg1(n, 0), dg2(m, 0);\n        \n        function<void(int, int, int, int)> getDis = [&](int node, int dad, int dis, int tree){\n            if(tree){\n                dg2[node] = max(dg2[node], dis) ;\n                for(auto child : g2[node]){\n                    if(child == dad) continue;\n                    getDis(child, node, dis + 1, tree);\n                }   \n            }else{\n                dg1[node] = max(dg1[node], dis);\n                for(auto child : g1[node]){\n                    if(child == dad) continue;\n                    getDis(child, node, dis + 1, tree);\n                }\n            }\n        };\n        \n        getDis(e1g1, -1, 0, 0);\n        getDis(e2g1, -1, 0, 0);\n        getDis(e1g2, -1, 0, 1);\n        getDis(e2g2, -1, 0, 1);\n        \n        int ans = pans ;\n        int mx1 = *min_element(dg1.begin(), dg1.end());\n        int mx2 = *min_element(dg2.begin(), dg2.end());\n        \n        // cout << mx1 << ' ' << mx2 << endl;\n        ans = max(ans, 1 + mx1 + mx2);\n        \n        return ans  ;\n    }\n};",
    "submit_ts": "1719716759",
    "subm_id": "1304373287"
}