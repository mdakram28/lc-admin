{
    "username": "itsmeashu",
    "submission": "from collections import deque\nfrom math import sqrt, pow\n\nclass Solution:\n    def heapify(arr, n, i):\n        largest = i\n        l = 2 * i + 1\n        r = 2 * i + 2\n\n        if l < n and arr[l] > arr[largest]:\n            largest = l\n\n        if r < n and arr[r] > arr[largest]:\n            largest = r\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    def heapSort(arr):\n        n = len(arr)\n        for i in range(n // 2 - 1, -1, -1):\n            heapify(arr, n, i)\n\n        for i in range(n - 1, 0, -1):\n            arr[0], arr[i] = arr[i], arr[0]\n            heapify(arr, i, 0)\n\n    def partition(arr, start, end):\n        index = 0\n        pivotElement = arr[end]\n        pivotIndex = 0\n        temp = [0] * (end - start + 1)\n\n        for i in range(start, end + 1):\n            if arr[i] < pivotElement:\n                temp[index] = arr[i]\n                index += 1\n\n        temp[index] = pivotElement\n        index += 1\n\n        for i in range(start, end):\n            if arr[i] > pivotElement:\n                temp[index] = arr[i]\n                index += 1\n\n        index = 0\n        for i in range(start, end + 1):\n            if arr[i] == pivotElement:\n                pivotIndex = i\n            arr[i] = temp[index]\n            index += 1\n        return pivotIndex\n    \n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        n = len(target)\n        m = len(words)\n\n        wc = {}\n        for i, w in enumerate(words):\n            wc[w] = min(wc.get(w, float('inf')), costs[i])\n\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n\n        for i in range(1, n + 1):\n            for w in wc:\n                if i >= len(w) and target[i - len(w):i] == w:\n                    dp[i] = min(dp[i], dp[i - len(w)] + wc[w])\n\n        return dp[n] if dp[n] != float('inf') else -1\n    def quickSort(arr, start, end):\n        if start < end:\n            partitionIndex = partition(arr, start, end)\n            quickSort(arr, start, partitionIndex - 1)\n            quickSort(arr, partitionIndex + 1, end)\n \n    def getMax(arr):\n        mx = arr[0]\n        for i in range(1, len(arr)):\n            if arr[i] > mx:\n                mx = arr[i]\n        return mx\n\n    def countSort(arr, exp):\n        n = len(arr)\n        output = [0] * n\n        count = [0] * 10\n\n        for i in range(n):\n            count[(arr[i] // exp) % 10] += 1\n\n        for i in range(1, 10):\n            count[i] += count[i - 1]\n\n        for i in range(n - 1, -1, -1):\n            output[count[(arr[i] // exp) % 10] - 1] = arr[i]\n            count[(arr[i] // exp) % 10] -= 1\n\n        for i in range(n):\n            arr[i] = output[i]\n    \n    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:\n        horizontalCut.sort()\n        verticalCut.sort()\n        \n        h_segments = len(horizontalCut) + 1\n        v_segments = len(verticalCut) + 1\n        \n        total_cost = 0\n        \n        i, j = 0, 0\n        while i < len(horizontalCut) and j < len(verticalCut):\n            if horizontalCut[i] < verticalCut[j]:\n                total_cost += horizontalCut[i] * v_segments\n                h_segments -= 1\n                i += 1\n            else:\n                total_cost += verticalCut[j] * h_segments\n                v_segments -= 1\n                j += 1\n        \n        while i < len(horizontalCut):\n            total_cost += horizontalCut[i] * v_segments\n            i += 1\n        \n        while j < len(verticalCut):\n            total_cost += verticalCut[j] * h_segments\n            j += 1\n        \n        return total_cost\n\n    def minChanges(self, nums: List[int], k: int) -> int:\n        m = {}\n        v = []\n\n        for i in range(len(nums) // 2):\n            a = nums[i]\n            b = nums[len(nums) - i - 1]\n            diff = abs(a - b)\n\n            X = max(a, b, k - a, k - b)\n\n            if diff in m:\n                m[diff].append(X)\n            else:\n                m[diff] = [X]\n            v.append(X)\n\n        ans = len(nums)\n        v.sort()\n\n        for diff, values in m.items():\n            T = bisect.bisect_left(v, diff)\n            T = T * 2 + (len(nums) // 2 - T)\n\n            for X in values:\n                if X < diff:\n                    T -= 2\n                else:\n                    T -= 1\n\n            ans = min(ans, T)\n\n        return ans\n\n    def minimumOperations(self, nums: List[int], target: List[int]) -> int:\n        n = len(nums)\n        t = [0] * n\n        for i in range(n):\n            t[i] = target[i] - nums[i]\n        \n        pos = 0\n        m = 0\n        ans = abs(t[0])\n        m = ans\n        \n        if t[0] >= 0:\n            pos = 1\n        \n        for i in range(1, n):\n            if t[i] < 0 and pos == 1:\n                ans += abs(t[i])\n                m = abs(t[i])\n                pos = 0\n                continue\n            if t[i] >= 0 and pos == 0:\n                ans += abs(t[i])\n                m = abs(t[i])\n                pos = 1\n                continue\n            if m >= abs(t[i]):\n                m = abs(t[i])\n                continue\n            else:\n                ans += abs(t[i]) - m\n                m = abs(t[i])\n        \n        return ans\n\n    def bfs(self, graph, start, target1, target2, nodes):\n        q = deque([start])\n        visited = [0] * (nodes + 4)\n        visited[start] = 1\n        \n        while q:\n            u = q.popleft()\n            for v in graph[u]:\n                if not visited[v]:\n                    q.append(v)\n                    visited[v] = 1\n        \n        return visited[target1] or visited[target2]\n    \n    def canReachCorner(self, X, Y, circles2):\n        circles = [((x, y), r) for x, y, r in circles2]\n        num_circles = len(circles2)\n        graph = [[] for _ in range(num_circles + 4)]\n        \n        for i in range(num_circles):\n            x, y, r = circles[i][0][0], circles[i][0][1], circles[i][1]\n            if x <= r:\n                graph[num_circles].append(i)\n                graph[i].append(num_circles)\n            if X - x <= r:\n                graph[num_circles + 2].append(i)\n                graph[i].append(num_circles + 2)\n            if y <= r:\n                graph[num_circles + 1].append(i)\n                graph[i].append(num_circles + 1)\n            if Y - y <= r:\n                graph[num_circles + 3].append(i)\n                graph[i].append(num_circles + 3)\n            for j in range(i + 1, num_circles):\n                xj, yj, rj = circles[j][0][0], circles[j][0][1], circles[j][1]\n                distance = sqrt(pow(x - xj, 2) + pow(y - yj, 2))\n                radius_sum = r + rj\n                if radius_sum >= distance:\n                    graph[i].append(j)\n                    graph[j].append(i)\n        \n        is_blocked = 0\n        is_blocked = max(is_blocked, self.bfs(graph, num_circles, num_circles + 1, num_circles + 2, num_circles + 4))  # Check for bottom-left corner\n        is_blocked = max(is_blocked, self.bfs(graph, num_circles + 3, num_circles + 2, num_circles + 1, num_circles + 4))  # Check for top-right corner\n        \n        return not is_blocked\n\n",
    "submit_ts": "1722137265",
    "subm_id": "1335758831"
}