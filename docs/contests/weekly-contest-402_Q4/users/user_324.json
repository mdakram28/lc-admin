{
    "username": "papaya",
    "submission": "#include <bits/stdc++.h>\nusing namespace std ; \n\ntypedef long long int64 ; \n\nstruct Segment_Tree { \n    struct Node {          \n        int64 sum ; // lazy variable \n    } ; \n    vector< Node > t ; \n    int n ; \n\n    inline int ls( int u ) { return u << 1 ; }\n    inline int rs( int u ) { return ( u << 1 ) | 1 ; }  \n    void init( int tn ) { \n        vector<int64> a( tn, 0 ) ;\n        init( tn , a ) ; \n    } \n    void init( int tn , vector<int64> & a ) { \n        n = tn ;         \n        t.resize( n * 4 + 10 ) ;         \n        function<void(int,int,int)> build_tree = [&]( int u , int s , int e  ) {\n\n            if( s == e ) {\n                t[ u ].sum = 0 ;  \n                return ; \n            }\n            int mid = ( s + e ) / 2 ; \n            build_tree( ls(u) , s , mid ) ; \n            build_tree( rs(u) , mid + 1 , e ) ;    \n            _combine( u ) ;  \n        } ; \n        build_tree( 1 ,  0 , tn - 1 ) ; \n    } \n    void _combine( int u ) {\n        t[ u ].sum =  t[ ls(u) ].sum +  t[ rs(u) ].sum   ;\n    }\n    void set( int x , int64 val , int u = 1 , int left = 0 , int right = -1) {\n        if( right == -1 ) right = n - 1 ; \n\n        if( left == right )  { // cotain [left,right], mark it \n            t[ u ].sum = val ;\n            return ; \n        } \n        int mid = ( left + right ) >> 1 ; \n        if( x <= mid ) {\n            set( x , val , ls(u) ,  left , mid ) ; \n        }\n        if( x > mid  ) {\n            set( x ,  val , rs(u) , mid + 1 , right ) ; \n        }\n        _combine( u ) ;\n    }\n\n    int64 range_query_sum( int x , int y  , int u = 1 , int left = 0 , int right = -1 ) {\n        if( right == -1 ) right = n - 1 ; \n\n        int mid = ( left + right ) >> 1 ; \n        if( x <= left && right <= y   )  { // cotain [left,right], mark it \n            return t[ u ].sum ; \n        }\n        int64 ret = 0 ; \n        if( x <= mid ) {\n            ret += range_query_sum( x , y  , ls(u) ,  left , mid ) ; \n        }\n        if( y > mid  ) {\n            ret += range_query_sum( x , y , rs(u) , mid + 1 , right ) ; \n        }\n        return  ret  ; \n    }\n} ; \nclass Solution {\npublic:\n    vector<int> a ; \n    int n ; \n\n    bool is_peak( int i ) { \n        if( i == 0 || i == n - 1 ) {\n            return false ; \n        }\n        return a[i] > a[i-1] && a[i] > a[i+1] ; \n    }\n\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        Segment_Tree t ; \n        a = nums ; \n\n        n = a.size() ; \n        t.init( n ) ; \n\n        for( int i = 1 ; i <= n - 2 ; i++ ) {\n            if( is_peak( i )  ) {\n                t.set( i , 1 ) ; \n            }\n        }\n        vector<int> ans_list ; \n\n        // for( auto &p : queries ) {\n\n        for( int j = 0 ; j < queries.size(); j++ ) { \n\n            auto &p = queries[j] ; \n\n            int op = p[0] ;\n\n            // cout << \" j ; \" << j << \" op: \" <<op << \"\\n\" ; \n\n            if( op == 1 ) {\n                int L  = p[1] , R = p[ 2 ] ; \n\n                int t_ans = 0 ;\n                if( R - L + 1 < 3 ) {\n                    t_ans = 0 ; \n                }\n                else { \n                    int si = L + 1 ; \n                    int sj = R - 1 ; \n                    t_ans = t.range_query_sum( si , sj ) ; \n\n                }\n                ans_list.emplace_back( t_ans ) ; \n            }\n            else {\n                int index = p[1] , val = p[2] ; \n                \n                for( int k = index - 1 ; k <= index + 1 ; k++ ) { \n                    if( k < 0 || k >= n ) {\n                        continue ; \n                    }\n                    if( is_peak( k ) ) {\n                        t.set( k , 0 ) ; \n                    }\n                }\n                \n\n                a[index] = val ; \n\n                for( int k = index - 1 ; k <= index + 1 ; k++ ) { \n                    if( k < 0 || k >= n ) {\n                        continue ; \n                    }\n                    if( is_peak( k ) ) {\n                        t.set( k , 1 ) ; \n                    }\n                }\n\n\n                // for( int index = 0 ; index < n ; index++ ) { \n                //     cout << \" index; \" << \" \" << t.range_query_sum( index , index ) << \"\\n\" ; \n                // }\n            }\n        }\n\n        // for( int i = 0 ; i < n ; i++ ) {\n        //     cout << \" i: \" << i << \" \" << is_peak( i ) << \"\\n\" ;\n        // }\n        return ans_list ; \n    }\n};\n\n\n\nint mai2n( )  { \n    Solution  t; \n\n    vector<int> a ;\n    int n ; \n\n    vector< vector<int>> queries ; \n\n    a = {} ; \n    n = 14 ; \n    \n    a = { 3,1,4,2,5 } ; \n    queries = { { 2 , 3 ,  4 } , { 1 , 0 , 4 } } ; //= [[2,3,4],[1,0,4]] ; \n\n\n    // nums = [4,1,4,2,1,5], queries = [[2,2,4],[1,0,2],[1,0,4]]\n\n    // a = { 4,1,4,2,1,5 } ; \n    // queries = { { 2 ,  2 , 4 } , { 1 , 0 , 2 } , { 1 , 0 , 4 }} ; \n\n    // a = { 3 , 6 , 9 } ; \n    // queries = { { 1 , 1 , 1 } , { 1 , 2 , 2 } , { 2 , 2  , 3 }} ;\n\n    // a = { 3 , 1 , 4 , 2 , 5 }\n    auto ans = t.countOfPeaks (  a , queries ) ; \n    for( auto x : ans ) {\n        cout << x << \"\\n\" ; \n    }\n    // cout << ans << \"\\n\" ;\n\n\n    return 0 ; \n}\n",
    "submit_ts": 1718506880.0
}