{
    "username": "power1011",
    "submission": "class Solution {\npublic:\n    int maxTotalReward(vector<int>& rewardValues) {\n        // 2 3 5\n        // 2 + 3\n        // 3 + 5\n        // 5\n        // 0 -> 1   -> 2\n        // v -> v+1 -> 2(v + 1) -> 4(v + 1) -> 8(v + 1) -> ... -> 2^{i-1} (v+1)\n        // 2^i <= 2^{i-1} (v+1) <= 5 * 10^4\n        // log_2(5*10^4) ~ 13\n        // 49999 + 50000 <= 99999\n        // dp[0] = 1\n        // dp = (dp >> rewardValues[j]) | dp\n        // dp[i] is it possible to reach sum == i\n        // dp[i + rewardValues[j]] can be set for all rewardValues[j] > i\n        // max(i) where dp[i] is set\n        // O(100 * 10^8 / 32 = 3 * 10^8)\n        const int n = rewardValues.size();\n        std::sort(rewardValues.begin(), rewardValues.end());\n        using i64 = std::uint64_t;\n        const int mx = rewardValues.back() * 2 - 1; // 195\n        const int width = 64;\n        const int bitset_size = mx/width + 1; // 4\n        vector<i64> cur(bitset_size + 1);\n        cur[0] = true;\n        for(int i=0;i<n;++i)\n        {\n            auto &v = rewardValues[i]; // 98\n            // index 0       1      2\n            // cur   [0]  [29 34]   [63]\n            vector<i64> nex = cur;\n            auto outer_shift = v/width; // 1\n            auto inner_shift = v%width; // 98 - 64 = 34\n            for(int j=0;j+outer_shift+0 < bitset_size && j*width < v;++j)\n            {\n                // cur[j] => [j*width, j*width + width-1] // [64, 127]\n                auto mask = cur[j];\n                if(j*width + width-1 >= v) // 127 >= 98\n                {\n                    // keep only bits from [j*width, v] // [0, 49]\n                    auto diff = v - j*width; // 34\n                    auto lower_diff_bits = (i64(1) << diff) - 1;\n                    mask &= lower_diff_bits;\n                }\n                // 0\n                nex[j+outer_shift+0] |= mask << inner_shift;\n                if(inner_shift != 0)\n                {\n                    nex[j+outer_shift+1] |= mask >> (width - inner_shift);\n                }\n                // 10110000\n                // 01100000    0000001\n                // j+(v/8)+0   j+(v/8)+1\n            }\n            // for(int j=0;j<nex.size();++j)\n            // {\n            //     std::cout << std::hex << nex[j] << \" \";\n            // }\n            // std::cout << \"\\n\";\n            std::swap(cur, nex);\n        }\n        // std::cout << \"==========\\n\";\n        int ans = 0;\n        for(int i=0;i<cur.size();++i)\n        {\n            for(int j=0;j<width;++j)\n            {\n                if((cur[i] >> j) % 2 == 1)\n                {\n                    ans = i * width + j;\n                    // std::cout << std::dec << ans << \"\\n\";\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1717905045.0
}