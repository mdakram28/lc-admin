{
    "username": "kenCHLEE",
    "submission": "/*\nwhether top-left and bottom-right boundaries are connected\nUnion-Find\nnode 0 ~ n-1: circles\nnode n: top-left boundary\nnode n+1: top-right boundary\n=> TC: O(n^2 * alpha(n)), SC: O(n)\n*/\nclass UnionFind {\n    private int[] parent, size;\n\n    public UnionFind(int n) {\n        parent = new int[n];\n        size = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    public void union(int i, int j) {\n        int r1 = find(i);\n        int r2 = find(j);\n        if (r1 == r2) {\n            return;\n        }\n        if (size[r1] < size[r2]) {\n            parent[r1] = r2;\n            size[r2] += r1;\n        } else {\n            parent[r2] = r1;\n            size[r1] += r2;\n        }\n    }\n\n    public int find(int i) {\n        while (parent[i] != i) {\n            i = parent[i];\n        }\n        return i;\n    }\n}\n\nclass Solution {\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        int n = circles.length;\n        UnionFind uf = new UnionFind(n + 2);\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (areNeighbors(circles[i], circles[j])) {\n                    uf.union(i, j);\n                }\n            }\n            if (isNeighborWithTopLeft(X, Y, circles[i])) {\n                uf.union(i, n);\n            }\n            if (isNeighborWithBottomRight(X, Y, circles[i])) {\n                uf.union(i, n + 1);\n            }\n        }\n        return uf.find(n) != uf.find(n + 1);\n    }\n\n    private boolean areNeighbors(int[] c1, int[] c2) {\n        int x1 = c1[0], y1 = c1[1], r1 = c1[2];\n        int x2 = c2[0], y2 = c2[1], r2 = c2[2];\n        return dist(x1, y1, x2, y2) <= r1 + r2;\n    }\n\n    private boolean isNeighborWithTopLeft(int X, int Y, int[] c) {\n        int x = c[0], y = c[1], r = c[2];\n        return x <= r || Y - y <= r;\n    }\n\n    private boolean isNeighborWithBottomRight(int X, int Y, int[] c) {\n        int x = c[0], y = c[1], r = c[2];\n        return X - x <= r || y <= r;\n    }\n\n    private double dist(int x1, int y1, int x2, int y2) {\n        long dx = x1 - x2;\n        long dy = y1 - y2;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}",
    "submit_ts": "1722138731",
    "subm_id": "1335798218"
}