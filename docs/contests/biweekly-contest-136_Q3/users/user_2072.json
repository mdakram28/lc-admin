{
    "username": "SachinPoonia123",
    "submission": "class Solution {\npublic:\n    int minFlips(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        int ans = 0;\n        \n        int changes = 0;\n        for(int row = 0; row < n/2; row++) {\n            for(int col = 0; col < m/2; col++) {\n                int ones = 0, zeros = 0;\n                int x[4] = {row, row, n-row-1, n-row-1};\n                int y[4] = {col, m-col-1, m-col-1, col};\n                for(int i = 0; i < 4; i++) {\n                   if(grid[x[i]][y[i]] == 0) zeros++;\n                    else ones++;\n                }\n                changes += min(ones, zeros);\n            }\n        }\n                \n        if(n % 2 == 0 && m % 2 == 0) {\n            ans = changes;\n        }\n        else if(n % 2 != 0 && m % 2 != 0) {\n            int ones = 0, zeros = 0;\n            if(grid[n/2][m/2] == 1) changes++;\n            // col\n            int l = 0, r = n-1;\n            int onespair = 0, opppair = 0;\n            while(l < r) {\n                if(grid[l][m/2] != grid[r][m/2]) opppair++;\n                else if(grid[l][m/2] == 1) onespair++;\n                l++; r--;\n            }\n            // column\n            l = 0; r = m-1;\n            // onespair = 0; opppair = 0;\n            while(l < r) {\n                if(grid[n/2][l] != grid[n/2][r]) opppair++;\n                else if(grid[n/2][l] == 1) onespair++;\n                l++; r--;\n            }\n            if((onespair * 2) % 4 == 0) changes += opppair;\n            else {\n                if(opppair != 0) changes += opppair;\n                else if(onespair > 0) changes += 2;\n            }\n            \n            ans = changes;\n        }\n        else {\n            int ones = 0, zeros = 0;\n            if(n % 2 == 0) {\n                int l = 0, r = n-1;\n                int onespair = 0, opppair = 0;\n                while(l < r) {\n                    if(grid[l][m/2] != grid[r][m/2]) opppair++;\n                    else if(grid[l][m/2] == 1) onespair++;\n                    l++; r--;\n                }\n                if((onespair * 2) % 4 == 0) changes += opppair;\n                else {\n                    if(opppair != 0) changes += opppair;\n                    else if(onespair > 0) changes += 2;\n                }\n            }\n            else {\n                int l = 0, r = m-1;\n                int onespair = 0, opppair = 0;\n                while(l < r) {\n                    if(grid[n/2][l] != grid[n/2][r]) opppair++;\n                    else if(grid[n/2][l] == 1) onespair++;\n                    l++; r--;\n                }\n                if((onespair * 2) % 4 == 0) changes += opppair;\n                else {\n                    if(opppair != 0) changes += opppair;\n                    else if(onespair > 0) changes += 2;\n                }\n            }\n            ans = changes;\n        }\n        \n        return ans;\n    }\n};\n// all op -> 0\n// 10 pair made 0   -> 1 change\n// 1's -> 0, 2, 4, 6, 8 -> 2 change\n\n// opp pair -> 10\n// ones pair -> of 4 / not of 4\n    \n// of 4 -> ok\n// not of 4 -> pick one pair for opp pair with 1 change / if opp = 0, then with 2 change\n\n// both even -> all 4\n// both odd -> centre always 0, both centre line - either 0, 1, 2, 3, 4 ... 1's - make factor of 4 optimally(less than total)\n// one odd, one even -> one centre line, exclude centre and take count, can be 0, 1, 2, 3, 4.. make optimal one's",
    "submit_ts": "1722699287",
    "subm_id": "1343207113"
}