{
    "username": "insomniacat",
    "submission": "\nclass SegmentTree {\npublic:\n    SegmentTree(int n) : n(n) {\n        tree.resize(4 * n, 0);      // Initialize the segment tree\n        lazy.resize(4 * n, -1);     // Lazy propagation array initialized to -1\n    }\n\n    // Function to update the range [l, r] to the specific value\n    void rangeUpdate(int l, int r, int value) {\n        update(1, 0, n - 1, l, r, value);\n    }\n\n    // Function to query the sum in the range [l, r]\n    int rangeQuery(int l, int r) {\n        return query(1, 0, n - 1, l, r);\n    }\n\nprivate:\n    vector<int> tree; // Segment tree array\n    vector<int> lazy; // Lazy propagation array\n    int n;\n\n    // Function to propagate updates\n    void propagate(int node, int start, int end) {\n        if (lazy[node] != -1) { // Check if there is a pending update\n            tree[node] = (end - start + 1) * lazy[node]; // Set the current node value\n\n            // Propagate to the children if not a leaf node\n            if (start != end) {\n                lazy[node * 2] = lazy[node]; // Mark left child\n                lazy[node * 2 + 1] = lazy[node]; // Mark right child\n            }\n\n            lazy[node] = -1; // Clear the lazy value\n        }\n    }\n\n    // Update function for range updates to a specific value\n    void update(int node, int start, int end, int l, int r, int value) {\n        propagate(node, start, end); // Ensure any pending updates are applied\n\n        if (start > end || start > r || end < l) {\n            return; // Out of range\n        }\n\n        if (start >= l && end <= r) { // Current segment is fully within range\n            tree[node] = (end - start + 1) * value; // Update the segment tree\n            if (start != end) { // Not a leaf node\n                lazy[node * 2] = value; // Mark left child\n                lazy[node * 2 + 1] = value; // Mark right child\n            }\n            return;\n        }\n\n        int mid = (start + end) / 2;\n        update(node * 2, start, mid, l, r, value); // Update left child\n        update(node * 2 + 1, mid + 1, end, l, r, value); // Update right child\n        tree[node] = tree[node * 2] + tree[node * 2 + 1]; // Recalculate the current node\n    }\n\n    // Query function for range queries\n    int query(int node, int start, int end, int l, int r) {\n        propagate(node, start, end); // Ensure any pending updates are applied\n\n        if (start > end || start > r || end < l) {\n            return 0; // Out of range\n        }\n\n        if (start >= l && end <= r) {\n            return tree[node]; // Current segment is fully within range\n        }\n\n        int mid = (start + end) / 2;\n        int leftSum = query(node * 2, start, mid, l, r); // Query left child\n        int rightSum = query(node * 2 + 1, mid + 1, end, l, r); // Query right child\n        return leftSum + rightSum; // Return total sum\n    }\n};\n\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n       SegmentTree segTree(n);\n        segTree.rangeUpdate(0, n - 1, 1);\n        // cout << n << \" seg sum: \" << segTree.rangeQuery(0, n - 1);\n\n        vector<int> result;\n        for (const auto& query : queries) {\n            int x = query[0];\n            int y = query[1];\n\n            if (y - 1 >= x + 1) {\n                segTree.rangeUpdate(x + 1, y - 1, 0);\n            }\n\n            result.push_back(segTree.rangeQuery(0, n - 1) - 1);\n        }\n\n        return result;\n    }\n};",
    "submit_ts": "1722743609",
    "subm_id": "1343795768"
}