{
    "username": "arujbansal",
    "submission": "class Solution {\npublic:\n    static const int MXN = 5 * (1e4) + 5;\n    static const int MOD = 1e9 + 7;\n\n    struct Node {\n        int left = 0;\n        int right = 0;\n        int both = 0;\n        int neither = 0;\n    };\n\n    Node tree[4 * MXN];\n\n    Node merge(const Node &x, const Node &y) {\n        return Node{\n            max({x.left + y.left, x.both + y.neither, x.left + y.neither, 0}) % MOD,\n            max({y.right + x.neither, y.both + x.neither, x.right + y.right, 0}) % MOD,\n            max({x.left + max(y.right, y.both), x.both + y.right, 0}) % MOD,\n            max(max({x.right + y.neither, x.neither + y.left, x.neither + y.neither}), 0) % MOD\n        };\n    }\n\n    void update(int i, int l, int r, int pos, Node val) {\n        if (l == r) {\n            tree[i] = val;\n            return;\n        }\n\n        int mid = (l + r) / 2;\n\n        if (pos <= mid) update(2 * i, l, mid, pos, val);\n        else update(2 * i + 1, mid + 1, r, pos, val);\n\n        tree[i] = merge(tree[2 * i], tree[2 * i + 1]);\n    }\n\n\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = (int) nums.size();\n        for (int i = 0; i < n; i++) {\n            update(1, 0, n - 1, i, Node{0, 0, max(nums[i], 0), 0});\n        }\n\n        // cout << tree[1].left << \" \" << tree[1].right << \" \" << tree[1].both << \" \" << tree[1].neither << \"\\n\";\n        long long ans = 0;\n\n        for (const auto vec : queries) {\n            int pos = vec[0];\n            int x = vec[1];\n\n            update(1, 0, n - 1, pos, Node{0, 0, max(x, 0), 0});\n\n            // cout << tree[1].left << \" \" << tree[1].right << \" \" << tree[1].both << \" \" << tree[1].neither << \"\\n\";\n\n            ans = (ans + max({tree[1].left, tree[1].right, tree[1].both, tree[1].neither})) % MOD;\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": 1716694355.0
}