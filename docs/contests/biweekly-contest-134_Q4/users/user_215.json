{
    "username": "ypsirK",
    "submission": "/**\n    Author: Kristopher Paul\n    Date Created: 06-07-2024\n**/\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define ll long long\n//#define int ll\n#define pb push_back\n#define MOD 1000000007\n//#define MOD 998244353\n#define mp make_pair\n#define FOR(i,a,b) for (int i = a; i < b; i++)\n#define FORD(i,a,b) for (int i = a; i >= b; i--)\n#define remax(a,b) a = max(a,b)\n#define remin(a,b) a = min(a,b)\n#define pii pair<int,int>\n#define F first\n#define S second\n#define vi vector<int>\n#define all(v) v.begin(),v.end()\n#define WL(t) while(t--)\n#define gcd(a,b) __gcd((a),(b))\n#define lcm(a,b) ((a)*(b))/gcd((a),(b))\n#define out(x) cout << #x << \" is \" << x << endl\n#define FastIO ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate<typename T> using pset = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>; // set\ntemplate<typename T> using pmultiset = tree<T,null_type,less_equal<T>,rb_tree_tag,tree_order_statistics_node_update>; // multiset\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\ntemplate<typename T, typename U> using umap = unordered_map<T,U,custom_hash>;\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        int n = nums.size();\n        int la[n][31];\n        FOR(i,0,n){\n            FOR(j,0,31){\n                if(!(nums[i]&(1<<j))){\n                    la[i][j] = i;\n                }else{\n                    if(i == 0){\n                        la[i][j] = -1;\n                    }else{\n                        la[i][j] = la[i-1][j];\n                    }\n                }\n            }\n        }\n        ll ans = 0;\n        FOR(i,0,n){\n            int pl1 = -1;\n            int pl2 = i+1;\n            FOR(j,0,31){\n                if(k&(1<<j)){\n                    remax(pl1,la[i][j]+1);\n                }else{\n                    remin(pl2,la[i][j]);\n                }\n            }\n            if(pl2 >= pl1 && pl2 >= 0 && pl1 <= i){\n                pl1 = max(0,pl1);\n                pl2 = min(pl2,i);\n                ans += pl2-pl1+1;\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720278388",
    "subm_id": "1311707052"
}