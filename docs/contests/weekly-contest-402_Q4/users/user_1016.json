{
    "username": "seyjs",
    "submission": "class BinaryIndexTree:\n    def __init__(self, array):\n        '''\u521d\u59cb\u5316\uff0c\u603b\u65f6\u95f4 O(n)'''\n        self._array = [0] + array\n        n = len(array)\n        for i in range(1, n + 1):\n            j = i + (i & -i)\n            if j < n + 1:\n                self._array[j] += self._array[i]\n\n    def lowbit(self, x):\n        return x & (-x)\n\n    def update(self, idx, val):\n        '''\u5c06\u539f\u6570\u7ec4idx\u4e0b\u6807\u66f4\u65b0\u4e3aval, \u603b\u65f6\u95f4O(log n)'''\n        prev = self.query(idx, idx + 1)    # \u8ba1\u7b97\u51fa\u539f\u6765\u7684\u503c\n        idx += 1\n        val -= prev    # val \u662f\u8981\u589e\u52a0\u7684\u503c\n        while idx < len(self._array):\n            self._array[idx] += val\n            idx += self.lowbit(idx)\n\n    def query(self, begin, end):\n        if begin >= end:\n            return 0\n        '''\u8fd4\u56de\u6570\u7ec4[begin, end) \u7684\u548c'''\n        return self._query(end) - self._query(begin)\n\n    def _query(self, idx):\n        '''\u8ba1\u7b97\u6570\u7ec4[0, idx)\u7684\u5143\u7d20\u4e4b\u548c'''\n        res = 0\n        while idx > 0:\n            res += self._array[idx]\n            idx -= self.lowbit(idx)\n        return res\nclass Solution(object):\n    def countOfPeaks(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        arr = [0] * n\n        res = []\n        for i in range(1,n-1):\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:\n                arr[i] = 1\n        tree = BinaryIndexTree(arr)\n        for i in range(len(queries)):\n            query = queries[i]\n            if query[0] == 1:\n                l,r = query[1],query[2]\n                v = tree.query(l+1,r)\n                res.append(v)\n            else:\n                p,v = query[1],query[2]\n                nums[p] = v\n                if (p - 1 >= 0 and p + 1 < n and nums[p] > nums[p-1] and nums[p] > nums[p+1]):\n                    tree.update(p,1)\n                else:\n                    tree.update(p,0)\n                # check p - 1\n                if p -2 >= 0 and p - 1 >= 0 and nums[p-1] > nums[p-2] and nums[p-1] > nums[p]:\n                    tree.update(p-1,1)\n                elif p - 1 >= 0:\n                    tree.update(p-1, 0)\n                # check p + 1\n                if p +1 < n and p + 2 < n and nums[p+1] > nums[p+2] and nums[p+1] > nums[p]:\n                    tree.update(p+1,1)\n                elif p + 1 < n:\n                    tree.update(p+1,0)\n\n        return res",
    "submit_ts": "1718508408",
    "subm_id": "539787153"
}