{
    "username": "ryanguorocket",
    "submission": "struct SegTree {\n    int si;\n    vector<int> seg;\n    SegTree() {}\n    SegTree(int nsi) {\n        si = nsi;\n        seg = vector<int>(4 * nsi);\n    }\n    void recalc(int a, int b, int c) {\n        if(a == b) return;\n        int lv = seg[2 * c + 1];\n        int rv = seg[2 * c + 2];\n        seg[c] = max(lv, rv);\n    }\n    void update(int a, int b, int c, int p, int v) {\n        if(a > p || b < p) return;\n        if(a == b) {\n            seg[c] = v;\n            return;\n        }\n        int m = (a + b) / 2;\n        update(a, m, 2 * c + 1, p, v);\n        update(m + 1, b, 2 * c + 2, p, v);\n        recalc(a, b, c);\n    }\n    void update(int p, int v) {update(0, si - 1, 0, p, v);}\n    int query(int a, int b, int c, int be, int en) {\n        if(a > en || b < be) return 0;\n        if(a >= be && b <= en) return seg[c];\n        int m = (a + b) / 2;\n        int lv = query(a, m, 2 * c + 1, be, en);\n        int rv = query(m + 1, b, 2 * c + 2, be, en);\n        return max(lv, rv);\n    }\n    int query(int be, int en) {return query(0, si - 1, 0, be, en);}\n};\n\n\nclass Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {\n        int n = nums.size();\n        map<int, int> cmp;\n        for(int i: nums) cmp[i];\n        int s = 0;\n        for(auto& [i, j]: cmp) j = s++;\n        for(int i = 0; i < n; i++) {\n            nums[i] = cmp[nums[i]];\n        }\n        vector<vector<int>> dp(n, vector<int>(k + 1)); // index, number of neq\n        vector<SegTree> psa(k + 1, SegTree(n));\n        //assuming u use the index lol\n        vector<int> prv(s, -1);\n        dp[0][0] = 1;\n        auto ran = [&](int t, int a, int b) -> int {\n            return psa[t].query(a, b);\n        };\n        prv[nums[0]] = 0;\n        psa[0].update(0, 1);\n        for(int i = 1; i < n; i++) {\n            dp[i][0] = 1;\n            int pp = prv[nums[i]];\n            if(pp != -1) {\n                for(int j = 0; j <= k; j++) {\n                    dp[i][j] = max(dp[i][j], dp[pp][j] + 1);\n                }\n            }\n            for(int j = 0; j < k; j++) {\n                int pv = ran(j, pp + 1, i - 1);\n                dp[i][j + 1] = max(dp[i][j + 1], pv + 1);\n            }\n            for(int j = 0; j <= k; j++) {\n                psa[j].update(i, dp[i][j]);\n            }\n            prv[nums[i]] = i;\n        }\n        int ret = 0;\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j <= k; j++) {\n                ret = max(ret, dp[i][j]);\n            }\n        }\n        return ret;\n    }\n};",
    "submit_ts": 1717859410.0
}