{
    "username": "curdking",
    "submission": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 1; i <= (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst int N = 1E5 + 10;\nint w[N];\nstruct node {\n    int l, r;\n    int fmax[2], lmax[2], rmax[2], sum[2];\n    int lazy, flag; //\u8986\u76d6, \u53d6\u53cd\n}t[N << 2];\nvoid pushdown(node& op, int lazy, int flag) {\n    if (lazy != -1) {\n        op.lmax[lazy] = op.rmax[lazy] = op.fmax[lazy] = op.sum[lazy] = op.r - op.l + 1;\n        op.lmax[!lazy] = op.rmax[!lazy] = op.fmax[!lazy] = op.sum[!lazy] = 0;\n        op.lazy = lazy, op.flag = 0;\n    }\n    else if (flag) {\n        swap(op.fmax[0], op.fmax[1]), swap(op.lmax[0], op.lmax[1]);\n        swap(op.rmax[0], op.rmax[1]), swap(op.sum[0], op.sum[1]);\n        if (op.lazy != -1) op.lazy ^= 1;\n        else op.flag ^= 1;\n    }\n}\nvoid pushdown(int x) {\n    if (t[x].lazy == -1 && !t[x].flag) return;\n    pushdown(t[x << 1], t[x].lazy, t[x].flag);\n    pushdown(t[x << 1 | 1], t[x].lazy, t[x].flag);\n    t[x].lazy = -1, t[x].flag = 0;\n}\n\nvoid pushup(node& p, node& l, node& r) {\n    int lsize = l.r - l.l + 1, rsize = r.r - r.l + 1;\n    for (int i = 0; i < 2; ++i) {\n        p.fmax[i] = max(max(l.fmax[i], r.fmax[i]), l.rmax[i] + r.lmax[i]);\n        p.lmax[i] = l.lmax[i] + (l.lmax[i] == lsize ? r.lmax[i] : 0);\n        p.rmax[i] = r.rmax[i] + (r.rmax[i] == rsize ? l.rmax[i] : 0);\n        p.sum[i] = l.sum[i] + r.sum[i];\n    }\n}\nvoid pushup(int x) { pushdown(x); pushup(t[x], t[x << 1], t[x << 1 | 1]); }\n\nvoid build(int l, int r, int x = 1) {\n    t[x] = { l, r }; t[x].lazy = -1;\n    if (l == r) {\n        int k = w[l];\n        t[x].fmax[k] = t[x].lmax[k] = t[x].rmax[k] = t[x].sum[k] = 1;\n        return;\n    }\n    \n    int mid = l + r >> 1;\n    build(l, mid, x << 1), build(mid + 1, r, x << 1 | 1);\n    pushup(x);\n}\n\nvoid modify(int l, int r, int lazy, int flag, int x = 1) {\n    if (l <= t[x].l && r >= t[x].r) {\n        pushdown(t[x], lazy, flag);\n        return;\n    }\n    pushdown(x);\n    int mid = t[x].l + t[x].r >> 1;\n    if (l <= mid) modify(l, r, lazy, flag, x << 1);\n    if (r > mid) modify(l, r, lazy, flag, x << 1 | 1);\n    pushup(x);\n}\n\nnode ask(int l, int r, int x = 1) {\n    if (l <= t[x].l && r >= t[x].r) return t[x];\n    pushdown(x);\n    int mid = t[x].l + t[x].r >> 1;\n    if (r <= mid) return ask(l, r, x << 1);\n    if (l > mid) return ask(l, r, x << 1 | 1);\n    node res, left = ask(l, r, x << 1), right = ask(l, r, x << 1 | 1);\n    pushup(res, left, right);\n    return res;\n}\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& q) {\n        if (w[0] == 0) {\n            for (int i = 0; i < N; i++) {\n                w[i] = 1;\n            }\n        }\n        int n = 0;\n        for (int i = 0; i < q.size(); i++) {\n            n = max(n, q[i][1]);\n        }\n        n++;\n        build(1, n);\n        modify(1, 1, 0, 0);\n        int qs = q.size();\n        vector<bool> res;\n        for (int i = 0; i < q.size(); i++) {\n            if (q[i][0] == 1) {\n                modify(q[i][1] + 1, q[i][1] + 1, 0, 0);\n            } else {\n                if (q[i][2] == 1) {\n                    res.push_back(true);\n                    continue;\n                }\n                int cnt = ask(1, q[i][1]).fmax[1];\n                if (cnt != 0) {\n                    res.push_back(cnt + 1 >= q[i][2]);\n                } else {\n                    res.push_back(false);\n                }\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1716650111.0
}