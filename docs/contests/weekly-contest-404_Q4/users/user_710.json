{
    "username": "rayvivek779",
    "submission": "class Solution {\n  int n, result, tmp;\n  vector<vector<int>> graph;\n  vector<int> dp;\n  void dfs(int u, int p) {\n    dp[u] = 1;\n    for (int v : graph[u]) {\n      if (v == p) \n        continue;\n\n      dfs(v, u);\n      dp[u] = max(dp[u], dp[v] + 1);\n    }\n  }\n  void dfs2(int u, int p, int up) {\n    multiset<int> s = {up, 0};\n    for (int v : graph[u]) {\n      if (v == p) \n        continue;\n      s.insert(dp[v]);\n    }\n    auto it = s.rbegin();\n    result = min(result, *s.rbegin() + 1);\n    tmp = max(tmp, *s.rbegin() + *next(it) + 1);\n    for (int v : graph[u]) {\n      if (v == p) \n        continue;\n      s.erase(s.find(dp[v]));\n      dfs2(v, u, *s.rbegin() + 1);\n      s.insert(dp[v]);\n    }\n  }\npublic:\n  int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n    int ans = 0, a = 0, b = 0;\n    this->n = edges1.size() + 1;\n    this->graph = vector<vector<int>>(n + 1);\n    this->dp = vector<int>(n + 1, 0);\n    for (auto & edge : edges1) {\n      graph[edge[0]].push_back(edge[1]);\n      graph[edge[1]].push_back(edge[0]);\n    }\n    this->result = n, tmp = 0;\n    dfs(0, -1);\n    dfs2(0, -1, 0);\n    ans += result;\n    a = tmp;\n    this->n = edges2.size() + 1;\n    this->graph = vector<vector<int>>(n + 1);\n    this->dp = vector<int>(n + 1, 0);\n    for (auto & edge : edges2) {\n      graph[edge[0]].push_back(edge[1]);\n      graph[edge[1]].push_back(edge[0]);\n    }\n    this->result = n, tmp = 0;\n    dfs(0, -1);\n    dfs2(0, -1, 0);\n    ans += result;\n    b = tmp;\n    return max({ans, a, b}) - 1;\n  }\n};",
    "submit_ts": 1719717219.0
}