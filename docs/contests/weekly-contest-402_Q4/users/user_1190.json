{
    "username": "manish1972",
    "submission": "class SegmentTree {\n    int[] segmentTree;\n\n    public SegmentTree(int n) {\n        segmentTree = new int[4 * n];\n    }\n\n    public void build(int[] nums, boolean[] peaks, int node, int start, int end) {\n        if (start == end) {\n            segmentTree[node] = peaks[start] ? 1 : 0;\n            return;\n        }\n\n        int mid = start + (end - start) / 2;\n        build(nums, peaks, 2 * node + 1, start, mid);\n        build(nums, peaks, 2 * node + 2, mid + 1, end);\n\n        segmentTree[node] = segmentTree[2 * node + 1] + segmentTree[2 * node + 2];\n    }\n\n    public int query(int node, int start, int end, int left, int right) {\n        if (left > end || right < start) return 0;\n        if (left <= start && right >= end) return segmentTree[node];\n\n        int mid = start + (end - start) / 2;\n        return query(2 * node + 1, start, mid, left, right) +\n               query(2 * node + 2, mid + 1, end, left, right);\n    }\n\n    public void update(int node, int start, int end, int index, boolean[] peaks) {\n        if (start == end) {\n            segmentTree[node] = peaks[index] ? 1 : 0;\n            return;\n        }\n\n        int mid = start + (end - start) / 2;\n        if (index <= mid) {\n            update(2 * node + 1, start, mid, index, peaks);\n        } else {\n            update(2 * node + 2, mid + 1, end, index, peaks);\n        }\n\n        segmentTree[node] = segmentTree[2 * node + 1] + segmentTree[2 * node + 2];\n    }\n}\n\nclass Solution {\n    public boolean isPeak(int[] nums, int i) {\n        if (i <= 0 || i >= nums.length - 1) return false;\n        return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    }\n\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean[] peaks = new boolean[n];\n\n        // Preprocess to find peaks\n        for (int i = 1; i < n - 1; i++) {\n            if (isPeak(nums, i)) {\n                peaks[i] = true;\n            }\n        }\n\n        // Build segment tree for peaks\n        SegmentTree segmentTree = new SegmentTree(n);\n        segmentTree.build(nums, peaks, 0, 0, n - 1);\n\n        List<Integer> result = new ArrayList<>();\n\n        for (int[] query : queries) {\n            if (query[0] == 1) {\n                int li = query[1];\n                int ri = query[2];\n                int count = segmentTree.query(0, 0, n - 1, li + 1, ri - 1);\n                result.add(count);\n            } else if (query[0] == 2) {\n                int index = query[1];\n                int val = query[2];\n                nums[index] = val;\n                if(index - 1 > 0) {\n                    peaks[index - 1] = isPeak(nums, index - 1);\n                    segmentTree.update(0, 0, n - 1, index - 1, peaks);\n                }\n                if(index + 1 < n) {\n                    peaks[index + 1] = isPeak(nums, index + 1);\n                    segmentTree.update(0, 0, n - 1, index + 1, peaks);\n                }\n                peaks[index] = isPeak(nums, index);\n                segmentTree.update(0, 0, n - 1, index, peaks);\n            }\n        }\n\n        return result;\n    }\n}\n",
    "submit_ts": 1718509144.0
}