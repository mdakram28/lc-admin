{
    "username": "plyusnovdmitrii",
    "submission": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <unordered_set>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <fstream>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bitset>\n#include <sstream>\n#include <ext/rope>\n#include <ctime>\n#include <random>\n#include <cstdlib>\n#include <complex>\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\n/* clang-format off */\n\n/* TYPES  */\n#define ll long long\n#define ld long double\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vi vector<int>\n#define vll vector<long long>\n#define vpii vector<pair<int, int>>\n#define vpii vector<pair<int, int>>\n#define vvpii vector<vector<pair<int, int>>>\n#define vpll vector<pair<long long, long long>>\n#define vvpll vector<vector<pair<long long, long long>>>\n#define vvi vector<vector<int>>\n#define vvll vector<vector<long long>>\n#define mii map<int, int>\n#define si set<int>\n#define sc set<char>\n#define vd vector<double>\n#define vvd vector<vector<double>>\n\n\n/* FUNCTIONS */\n#define feach(el, v) for(auto &el: v)\n#define rep(i, n) for(int i=0;i<n;i++)\n#define reprv(i, n) for(int i=n-1;i>=0;i--)\n#define reps(i, s, e) for(int i=s;i<e;i++)\n#define reprve(i, e, s) for(int i=e-1;i>=s;i--)\n#define repe(x, y) for (auto &x: y)\n#define repe2(x, a, y) for (auto &[x,a]: y)\n\n\nconst ll mod = 998244353;\n\ntemplate<ll mod = 998244353>\nstruct ModInt {\n    ll p;\n\n    ModInt() : p(0) {}\n\n    ModInt(ll x) { p = x >= 0 ? x % mod : x + (-x + mod - 1) / mod * mod; }\n\n    ModInt &operator+=(const ModInt &y) {\n        p = p + *y - ((p + *y) >= mod ? mod : 0);\n        return *this;\n    }\n\n    ModInt &operator-=(const ModInt &y) {\n        p = p - *y + (p - *y < 0 ? mod : 0);\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &y) {\n        p = (p * *y) % mod;\n        return *this;\n    }\n\n    ModInt &operator%=(const ModInt &y) {\n        if (y)p %= *y;\n        return *this;\n    }\n\n    ModInt operator+(const ModInt &y) const {\n        ModInt x = *this;\n        return x += y;\n    }\n\n    ModInt operator-(const ModInt &y) const {\n        ModInt x = *this;\n        return x -= y;\n    }\n\n    ModInt operator*(const ModInt &y) const {\n        ModInt x = *this;\n        return x *= y;\n    }\n\n    ModInt operator%(const ModInt &y) const {\n        ModInt x = *this;\n        return x %= y;\n    }\n\n    ModInt binpow(const ModInt &y, ll pow) const {\n        pow %= mod - 1;\n        ModInt res = 1, a = y;\n        while (pow) {\n            if (pow & 1) res *= a;\n            a *= a, pow >>= 1;\n        }\n        return res;\n    }\n\n    ModInt inv() const { return binpow(*this, mod - 2); }\n\n    ModInt &operator/=(const ModInt &y) {\n        p = (p * y.inv().p) % mod;\n        return *this;\n    }\n\n    ModInt operator/(const ModInt &y) const {\n        ModInt x = *this;\n        return x /= y;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int v;\n        is >> v;\n        a = ModInt(v);\n        return is;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &a) { return os << a.p; }\n\n    ModInt &operator++() {\n        p = (p + 1) % mod;\n        return *this;\n    }\n\n    ModInt &operator--() {\n        p = (p - 1 + mod) % mod;\n        return *this;\n    }\n\n    bool operator==(const ModInt &y) const { return p == *y; }\n\n    bool operator!=(const ModInt &y) const { return p != *y; }\n\n    const ll &operator*() const { return p; }\n\n    ll &operator*() { return p; }\n\n};\n\nusing Mint = ModInt<>;\n#define vmint vector<Mint>\n#define vvmint vector<vector<Mint>>\ntypedef tree<ll, null_type, less_equal<>, rb_tree_tag, tree_order_statistics_node_update> oSet;\n#define IO ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#pragma GCC target(\"popcnt\")\n#define vct vector\n\nint cntLeq(vll &v, ll x) { return std::upper_bound(v.begin(), v.end(), x) - v.begin(); }\nint cntLess(vll &v, ll x) { return std::lower_bound(v.begin(), v.end(), x) - v.begin(); }\nint cntGreater(vll &v, ll x) { return v.end() - std::upper_bound(v.begin(), v.end(), x); }\nint cntGeq(vll &v, ll x) { return v.end() - std::lower_bound(v.begin(), v.end(), x); }\n\nvll buildPref(vll &v) {\n    int n = v.size(); vll pref(n);\n    rep(i, n) pref[i] = v[i] + (i ? pref[i - 1] : 0);\n    return pref;\n}\nll getPrefSum(vll &pref, int l, int r) { return pref[r] - (l ? pref[l - 1] : 0); }\n\n\n//////////////////////////////////////////////////////////////////////////\n\nclass Solution {\npublic:\n    vi par, rnk, vis;\n\n\n    void initialise() {\n        par = rnk = vis = vi(1005);\n        rep(i, 1000) par[i] = i, rnk[i] = 1, vis[i] = 0;\n    }\n\n    int findPar(int x) { return x == par[x] ? x : (par[x] = findPar(par[x])); }\n\n\n    void makeUnion(int a,int b) {\n        a = findPar(a), b = findPar(b);\n        if (a == b) return;\n        if (rnk[a] < rnk[b]) swap(a, b);\n        par[b] = a; rnk[a] += rnk[b];\n    }\n\n\n    bool findBlockage(int root, int X, int Y, int n, vector<vector<int>>& circles){\n        int top = 0, bot = INT_MAX, l = INT_MAX, rght = 0;\n        rep(i, n) {\n            if (par[i] == root) {\n                int x = circles[i][0], y = circles[i][1], r = circles[i][2];\n                top = max(top, y + r), bot = min(bot, y - r);\n                l = min(l, x - r), rght = max(rght, x + r);\n            }\n        }\n\n        if (top >= Y && bot <= 0) return 1;\n        if (top >= Y && rght >= X) return 1;\n        if (rght >= X && l <= 0) return 1;\n        if (bot <= 0 && l <= 0) return 1;\n        return 0;\n    }\n\n    struct circle {int id, x, y, r; };\n\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n        initialise();\n\n        rep(i, n) rep(j, n) if (i != j) {\n            ll sqDist = ((ll)circles[i][0] - (ll)circles[j][0]) * ((ll)circles[i][0] - (ll)circles[j][0]) + ((ll)circles[i][1] - (ll)circles[j][1]) * ((ll)circles[i][1] - (ll)circles[j][1]);\n            ll radDist = ((ll)circles[i][2] + (ll)circles[j][2]) * ((ll)circles[i][2] + (ll)circles[j][2]);\n            if (sqDist <= radDist) makeUnion(i, j);\n        }\n\n        rep(i, n) {\n            if (!vis[par[i]]) {\n                vis[par[i]] = 1;\n                bool tst = findBlockage(par[i], X, Y, n, circles);\n                if (tst) return false;\n            }\n        }\n        return true;\n    }\n};\n",
    "submit_ts": "1722137601",
    "subm_id": "1335768449"
}