{
    "username": "shivamkumarsingh1064",
    "submission": "\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <utility>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <functional>\n#include <numeric>\n#include <exception>\n#include <stdexcept>\ntypedef long long ll;\ntypedef vector<vector<int>> vect;\ntypedef vector<int> vec;\ntypedef long double ld;\ntypedef set<int> st;\n\n\nclass Solution {\n    pair<int, int>  bfs(int start, const vect& adj) {\n    int n = adj.size();\n    vector<int> dist(n, -1);\n    queue<int> qu;\n    qu.push(start);\n    dist[start] = 0;\n    int farthest_node = start;\n    int max_dist = 0;\n\n    while (!qu.empty()) {\n        int node = qu.front(); qu.pop();\n        for (int neighbor : adj[node]) {\n            if (dist[neighbor] == -1) {\n                dist[neighbor] = dist[node] + 1;\n                qu.push(neighbor);\n                if (dist[neighbor] > max_dist) {\n                    max_dist = dist[neighbor];\n                    farthest_node = neighbor;\n                }\n            }\n        }\n    }\n    return {farthest_node, max_dist};\n}\n\n// Function to find the diameter of a tree\nint find_diameter(const vector<vector<int>>& adj) {\n    auto [u, _] = bfs(0, adj);\n    auto [v, diameter] = bfs(u, adj);\n    return diameter;\n}\npublic:\n    int minimumDiameterAfterMerge(vect& edges1, vect& edges2) {\n         int n = edges1.size() + 1;\n    int m = edges2.size() + 1;\n\n    // Create adjacency lists for both trees\n    vect adj1(n), adj2(m);\n    for (const auto& edge : edges1) {\n        adj1[edge[0]].push_back(edge[1]);\n        adj1[edge[1]].push_back(edge[0]);\n    }\n    for (const auto& edge : edges2) {\n        adj2[edge[0]].push_back(edge[1]);\n        adj2[edge[1]].push_back(edge[0]);\n    }\n\n    // Find diameters of both trees\n    int dia1 = find_diameter(adj1);\n    int dia2 = find_diameter(adj2);\n\n    // The minimum possible diameter after connecting two trees\n    int min_diameter = max(dia1, dia2);\n    int res = max(min_diameter, (dia1 + 1) / 2 + (dia2 + 1) / 2 + 1);\n\n    return res;\n    }\n};\n\n\n\n\n\n\n\n",
    "submit_ts": 1719719989.0
}