{
    "username": "loodv002",
    "submission": "class Node:\n    def __init__(self, l, r):\n        self.v = 0\n        self.l = l\n        self.r = r\n        if l != r:\n            mid = (l+r)//2\n            self.lc = Node(l, mid)\n            self.rc = Node(mid+1, r)\n    def query(self, l, r):\n        if self.r < l or self.l > r: return 0\n        if l <= self.l and self.r <= r: return self.v\n        return self.lc.query(l, r) + self.rc.query(l, r)\n    def update(self, i, val):\n        if self.r < i or self.l > i: return self.v\n        if self.l == self.r == i:\n            self.v = val\n            return val\n        self.v = self.lc.update(i, val) + self.rc.update(i, val)\n        return self.v\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        root = Node(0, n-1)\n        def peak(i):\n            if i <= 0 or i >= n-1: return 0\n            return int(nums[i-1] < nums[i] and nums[i] > nums[i+1])\n        for i in range(1, n-1):\n            if peak(i): root.update(i, 1)\n        ret = []\n        for c, a1, a2 in queries:\n            if c == 1:\n                if a2 - a1 >= 2:\n                    ret.append(root.query(a1+1, a2-1))\n                else:\n                    ret.append(0)\n            else:\n                nums[a1] = a2\n                root.update(a1-1, peak(a1-1))\n                root.update(a1, peak(a1))\n                root.update(a1+1, peak(a1+1))\n                \n        return ret",
    "submit_ts": 1718506654.0
}