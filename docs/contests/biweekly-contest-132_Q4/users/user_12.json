{
    "username": "mhasan01",
    "submission": "template<typename T>\nstruct Compresser {\n    vector<T> nums;\n    \n    Compresser() { }\n\n    Compresser(vector<T>& v) {\n        nums.assign(v.begin(), v.end());\n        finish();\n    }\n \n    void add(T x) {\n        nums.emplace_back(x);\n    }\n \n    void finish() {\n        sort(nums.begin(), nums.end());\n        nums.resize(unique(nums.begin(), nums.end()) - nums.begin());\n    }\n \n    int getId(T x) {\n        return lower_bound(nums.begin(), nums.end(), x) - nums.begin() + 1;\n    }\n\n    T getValue(int id) {\n        return nums[id - 1];\n    }\n \n    int getLen() {\n        return nums.size();\n    }\n};\n\ntemplate<class Info, class Merge = plus<Info>>\nstruct SegmentTree {\n    const int n;\n    const Merge merge;\n    vector<Info> t;\n    SegmentTree(int len) : n(len), merge(Merge()), t(4 << __lg(len)) {}\n    SegmentTree(vector<Info> init) : SegmentTree(init.size()) {\n        function<void(int, int, int)> build = [&](int v, int s, int e) {\n            if (s == e) {\n                t[v] = init[s];\n                return;\n            }\n            int mid = (s + e) >> 1;\n            build(v << 1, s, mid);\n            build(v << 1 | 1, mid + 1, e);\n            pull(v);\n        };\n        build(1, 0, n - 1);\n    }\n\n    void pull(int v) {\n        t[v] = merge(t[v << 1], t[v << 1 | 1]);\n    }\n\n    void modify(int v, int s, int e, int pos, const Info &val) {\n        if (s == e && s == pos) {\n            t[v] = merge(t[v], val);\n            return;\n        }\n        int mid = (s + e) >> 1;\n        if (pos <= mid) {\n            modify(v << 1, s, mid, pos, val);\n        } else {\n            modify(v << 1 | 1, mid + 1, e, pos, val);\n        }\n        pull(v);\n    }\n\n    void modify(int p, const Info &v) {\n        modify(1, 0, n - 1, p, v);\n    }\n\n    Info rangeQuery(int v, int s, int e, int l, int r) {\n        if (e < l || s > r || l > r) {\n            return Info();\n        }\n        if (l <= s && e <= r) {\n            return t[v];\n        }\n        int mid = (s + e) >> 1;\n        return merge(rangeQuery(v << 1, s, mid, l, r), rangeQuery(v << 1 | 1, mid + 1, e, l, r));\n    }\n\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n - 1, l, r);\n    }\n};\n\nstruct Info {\n    int val;\n    Info() : val(-INT_MAX) {}\n    Info(long long v) : val(v) {}\n};\n\nInfo operator+(const Info& lhs, const Info& rhs) {\n    return Info(max(lhs.val, rhs.val));\n}\n\nclass Solution {\npublic:\n    int maximumLength(vector<int>& a, int k) {\n        Compresser<int> c(a);\n        int sz = c.getLen();\n        vector<SegmentTree<Info>> sgt(k + 1, SegmentTree<Info>(sz + 1));\n        int ans = 0;\n        for (int x : a) {\n            x = c.getId(x);\n            for (int kk = 0; kk <= k; kk++) {\n                int cur = sgt[kk].rangeQuery(x, x).val;\n                if (kk > 0) {\n                    cur = max(cur, sgt[kk - 1].rangeQuery(1, x - 1).val);\n                    cur = max(cur, sgt[kk - 1].rangeQuery(x + 1, sz).val);\n                }\n                if (kk == 0) {\n                    cur = max(cur, 0);\n                }\n                if (cur < 0) {\n                    continue;\n                }\n                ans = max(ans, cur + 1);\n                sgt[kk].modify(x, Info(cur + 1));\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1717858569.0
}