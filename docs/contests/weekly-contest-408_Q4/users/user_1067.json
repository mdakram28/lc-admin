{
    "username": "ansarisuveb",
    "submission": "#define ll unsigned long long\nclass Solution {\npublic:\n    \n    bool isNeighbour(ll x1, ll y1, ll r1, ll x2, ll y2, ll r2){\n        return (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1) <= (r1+r2)*(r1+r2);\n    }\n    \n    bool inside(int x, int y, int r, char c, int X, int Y){\n        if(c=='L') return abs(x)<=r; //y-axis\n        else if(c=='D') return abs(y)<=r; //x-axis\n        else if(c=='R') return abs(x-X)<=r;\n        else return abs(y-Y)<=r;\n    }\n    \n    bool bfs(vector<vector<int>> G, int src, int dest1, int dest2){\n        auto n = G.size();\n        vector<bool> vis(n,false);\n        queue<int> q;\n\n        q.push(src);\n        vis[src] = true;\n        while(!q.empty()){\n            auto node = q.front();\n            q.pop();\n\n            for(auto adj: G[node]){\n                if(!vis[adj]){\n                    q.push(adj);\n                    vis[adj] = true;\n                    if(adj==dest1 || adj==dest2) return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n        int n = circles.size();\n        vector<vector<int>> G(n+4, vector<int>());\n        \n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                if(i!=j){\n                    if(isNeighbour(circles[i][0],circles[i][1],circles[i][2], circles[j][0], circles[j][1], circles[j][2])){\n                        //cout<<i<<\"N\"<<j;\n                        G[i].push_back(j);\n                    }\n                }\n            }\n        }\n        \n        for(int i=0; i<n; i++){\n            if(inside(circles[i][0], circles[i][1], circles[i][2], 'L', X, Y)) G[n].push_back(i), G[i].push_back(n);\n            if(inside(circles[i][0], circles[i][1], circles[i][2], 'R', X, Y)) G[n+3].push_back(i), G[i].push_back(n+3);\n            if(inside(circles[i][0], circles[i][1], circles[i][2], 'U', X, Y)) G[n+1].push_back(i), G[i].push_back(n+1);\n            if(inside(circles[i][0], circles[i][1], circles[i][2], 'D', X, Y)) G[n+2].push_back(i), G[i].push_back(n+2);\n        }\n        \n        \n        \n        if(bfs(G, n, n+2, n+3) || bfs(G, n+1, n+2, n+3)) return false;\n        else return true;\n    }\n};",
    "submit_ts": "1722136642",
    "subm_id": "1335740733"
}