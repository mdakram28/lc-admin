{
    "username": "mintujupally",
    "submission": "class Solution {\npublic:\n    pair<int, int> bfs(int start, vector<vector<int>>& adj) {\n        int n = adj.size();\n        vector<int> distance(n, -1);\n        queue<int> q;\n\n        q.push(start);\n        distance[start] = 0;\n        int farthestNode = start;\n        int maxDistance = 0;\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n\n            for (int neighbor : adj[node]) {\n                if (distance[neighbor] == -1) {\n                    distance[neighbor] = distance[node] + 1;\n                    q.push(neighbor);\n                    if (distance[neighbor] > maxDistance) {\n                        maxDistance = distance[neighbor];\n                        farthestNode = neighbor;\n                    }\n                }\n            }\n        }\n\n        return {farthestNode, maxDistance};\n    }\n\n    int findDiameter(vector<vector<int>>& adj) {\n        pair<int, int> firstBFS = bfs(0, adj);\n        pair<int, int> secondBFS = bfs(firstBFS.first, adj);\n\n        return secondBFS.second;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n=edges1.size();\n        int m=edges2.size();\n        vector<vector<int>> adj1(n+1), adj2(m+1);\n        for(int i=0; i<n; i++)\n        {\n            int a=edges1[i][0], b=edges1[i][1];\n            adj1[a].push_back(b);\n            adj1[b].push_back(a);\n        }\n        for(int i=0; i<m; i++)\n        {\n            int a=edges2[i][0], b=edges2[i][1];\n            adj2[a].push_back(b);\n            adj2[b].push_back(a);\n        }\n\n        int d1=findDiameter(adj1);\n        int d2=findDiameter(adj2);\n\n        return max({d1, d2, 1+(d1+1)/2+(d2+1)/2});\n    }\n};",
    "submit_ts": "1719718954",
    "subm_id": "1304430160"
}