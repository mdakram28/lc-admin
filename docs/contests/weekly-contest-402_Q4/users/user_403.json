{
    "username": "txingml",
    "submission": "const int MAXN = 1e5 + 10;\nint tree[MAXN];\nint n;\nint lowbit(int i) {\n    return i & (-i);\n}\nvoid add(int i, int val) {\n    while (i <= n) {\n        tree[i] += val;\n        i += lowbit(i);\n    }\n}\nint query(int i) {\n    int ret = 0;\n    while (i > 0) {\n        ret += tree[i];\n        i -= lowbit(i);\n    }\n    return ret;\n}\n\nbool peak(const vector<int>& nums, int i) {\n    if (i <= 0 || i+1 >= nums.size()) return false;\n    return nums[i] > nums[i-1] && nums[i] > nums[i+1];\n    \n}\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        n = nums.size();\n        memset(tree, 0, sizeof(tree));\n        for (int i = 1; i + 1 < n; i++) {\n            if (peak(nums, i)) {\n                add(i+1, 1);\n            }\n        }\n        vector<int> ret;\n        for (const auto& q : queries) {\n            if (q[0] == 1) {\n                if (q[2] - q[1] <= 1) {\n                    ret.push_back(0);\n                } else {\n                    ret.push_back(query(q[2] + 1) - query(q[1]));\n                    if (peak(nums, q[1])) ret.back()--;\n                    if (peak(nums, q[2])) ret.back()--;\n                }\n                \n            } else {\n                int i = q[1];\n                vector<int> prev(3);\n                vector<int> now(3);\n                for (int j = 0; j < 3; j++) {\n                    prev[j] = peak(nums, i+j-1);\n                }\n                nums[i] = q[2];\n                for (int j = 0; j < 3; j++) {\n                    now[j] = peak(nums, i+j-1);\n                }\n                for (int j = 0; j < 3; j++) {\n                    if (now[j] != prev[j]) {\n                        add(i+j, now[j]-prev[j]);\n                    }\n                }\n            }\n        }\n        return ret;\n        \n    }\n};",
    "submit_ts": 1718507456.0
}