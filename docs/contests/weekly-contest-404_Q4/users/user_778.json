{
    "username": "rituraj2024",
    "submission": "// class Solution {\n// public:\n//     int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n//         int size1=edges1.size()+1;\n//         int size2=edges2.size()+1;\n\n//         vector< vector<int>> graph1(size1); \n//         vector<vector<int>> graph2(size2);\n//         for (const auto& edge: edges1) {\n//         graph1[edge[0]].push_back(edge[1]);\n//         graph1[edge[1]].push_back(edge[0]);\n//         }\n//         for (const auto& edge: edges2) {\n//             graph2[edge[0]].push_back(edge[1]);\n//             graph2[edge[1]].push_back(edge[0]);\n//         }\n\n//         auto dfs = [](const vector<vector<int>>& graph, int start, int& furthestNode) {\n//             int n = graph.size();\n//             vector<int> distance(n, -1);\n//             function<void(int, int)> dfsVisit = [&](int node, int dist){\n//                  distance [node] = dist;\n//                 if (dist >distance[furthestNode]) {\n//                     furthestNode = node;\n//                 }\n\n//                 for(int neighbor : graph[node]) {\n//                     if (distance[neighbor] == -1) {\n//                         dfsVisit(neighbor, dist + 1);\n//                     }\n//                 } \n//             };\n//             furthestNode=start;\n//             dfsVisit(start,0);\n//             return distance[furthestNode];\n//         };\n//         int node1=0;\n//         dfs(graph1,0,node1);\n//         int diameter1=dfs(graph1,node1,node1);\n//         int node2=0;\n//         dfs(graph2,0,node2);\n//         int diameter2=dfs(graph2,node2,node2);\n\n//         int minD=max(diameter2,diameter1);\n//         int h1=(diameter1+1)/2;\n//          int h2=(diameter2+1)/2;\n\n//         minD=max(minD,h1+h2+1);\n\n//         return minD;\n\n//     }\n// };\n// void dfsVisit(const vector<vector<int>>& graph, int node, int dist, int& furthestNode, vector<int>& distance) {\n//     distance[node] = dist;\n//     if (dist > distance[furthestNode]) {\n//         furthestNode = node;\n//     }\n//     for (int neighbor : graph[node]) {\n//         if (distance[neighbor] == -1) {\n//             dfsVisit(graph, neighbor, dist + 1, furthestNode, distance);\n//         }\n//     }\n// }\n\n// int dfs(const vector<vector<int>>& graph, int start, int& furthestNode) {\n//     int n = graph.size();\n//     vector<int> distance(n, -1);\n//     furthestNode = start;\n//     dfsVisit(graph, start, 0, furthestNode, distance);\n//     return distance[furthestNode];\n// }\n\n// class Solution {\n// public:\n//     int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n//         int size1 = edges1.size() + 1;\n//         int size2 = edges2.size() + 1;\n\n//         vector<vector<int>> graph1(size1); \n//         vector<vector<int>> graph2(size2);\n\n//         for (const auto& edge : edges1) {\n//             graph1[edge[0]].push_back(edge[1]);\n//             graph1[edge[1]].push_back(edge[0]);\n//         }\n//         for (const auto& edge : edges2) {\n//             graph2[edge[0]].push_back(edge[1]);\n//             graph2[edge[1]].push_back(edge[0]);\n//         }\n\n//         int node1 = 0;\n//         dfs(graph1, 0, node1);\n//         int diameter1 = dfs(graph1, node1, node1);\n        \n//         int node2 = 0;\n//         dfs(graph2, 0, node2);\n//         int diameter2 = dfs(graph2, node2, node2);\n\n//         int minDiameter = max(diameter1, diameter2);\n//         int h1 = (diameter1 + 1) / 2;\n//         int h2 = (diameter2 + 1) / 2;\n\n//         minDiameter = max(minDiameter, h1 + h2 + 1);\n\n//         return minDiameter;\n//     }\n// };\n\nvoid dfsHelper(const vector<vector<int>>& graph, int node, int distance, int& farthestNode, vector<int>& distances) {\n    distances[node] = distance;\n    if (distance > distances[farthestNode]) {\n        farthestNode = node;\n    }\n    for (int neighbor : graph[node]) {\n        if (distances[neighbor] == -1) {\n            dfsHelper(graph, neighbor, distance + 1, farthestNode, distances);\n        }\n    }\n}\n\nint findFurthestNode(const vector<vector<int>>& graph, int start, int& farthestNode) {\n    int n = graph.size();\n    vector<int> distances(n, -1);\n    farthestNode = start;\n    dfsHelper(graph, start, 0, farthestNode, distances);\n    return distances[farthestNode];\n}\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int size1 = edges1.size() + 1;\n        int size2 = edges2.size() + 1;\n\n        vector<vector<int>> graph1(size1); \n        vector<vector<int>> graph2(size2);\n\n        for (const auto& edge : edges1) {\n            graph1[edge[0]].emplace_back(edge[1]);\n            graph1[edge[1]].emplace_back(edge[0]);\n        }\n        for (const auto& edge : edges2) {\n            graph2[edge[0]].emplace_back(edge[1]);\n            graph2[edge[1]].emplace_back(edge[0]);\n        }\n\n        int node1 = 0;\n        findFurthestNode(graph1, 0, node1);\n        int diameter1 = findFurthestNode(graph1, node1, node1);\n        \n        int node2 = 0;\n        findFurthestNode(graph2, 0, node2);\n        int diameter2 = findFurthestNode(graph2, node2, node2);\n\n        int minD = max(diameter1, diameter2);\n        int h1 = (diameter1 + 1) / 2;\n        int h2 = (diameter2 + 1) / 2;\n\n        minD = max(minD, h1 + h2 + 1);\n\n        return minD;\n    }\n};",
    "submit_ts": 1719719957.0
}