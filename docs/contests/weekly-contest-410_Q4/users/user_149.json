{
    "username": "Albert_Zhang",
    "submission": "\"\"\" === Method 1. optimized DP\n(1) On top of https://leetcode.com/contest/weekly-contest-410/problems/find-the-count-of-monotonic-pairs-i/,\n    we have: recurrence relation:\n    dp[i][j] = SIGMA[k = 0..1000] dp[i - 1][k], where j <= nums[i] and j >= k and nums[i] - j <= nums[i - 1] - k.\n(2) we can find k's constraint is: \n    k <= min(j, nums[i - 1] - nums[i] + j).\n    So we can use a pre-calculated prefixSums to quickly get \n    dp[i][j] = SIGMA[k = 0..min(j, nums[i - 1] - nums[i] + j)] dp[i - 1][k]\nO(n * 1000) time | O(n * 1000) space - where n is the length of nums\n\"\"\"\nclass Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        n = len(nums)\n        ways = [[0 for _ in range(1001)] for _ in range(n)]\n        # initialization\n        for j in range(nums[0] + 1):\n            ways[0][j] = 1\n        for i in range(1, n):\n            prefixSums = self.getPrefixSums(ways[i - 1])\n            for j in range(1001):\n                if j > nums[i]:\n                    break\n                k = min(j, nums[i - 1] - nums[i] + j)\n                # print(i, j, k)\n                if k < 0:\n                    continue\n                ways[i][j] = prefixSums[k + 1] % MOD\n        # for way in ways:\n        #     print(way)\n        return sum(ways[-1]) % MOD\n\n    def getPrefixSums(self, array):\n        n = len(array)\n        prefixSums = [0] * (n + 1)\n        for i, value in enumerate(array):\n            prefixSums[i + 1] = prefixSums[i] + value\n        return prefixSums\n\n\nMOD = 1000000007\n\n        ",
    "submit_ts": "1723345556",
    "subm_id": "1351558334"
}