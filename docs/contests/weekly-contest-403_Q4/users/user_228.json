{
    "username": "DylanSmith",
    "submission": "typedef long long ll;\n\n#define pb push_back\n#define sz(x) (int)x.size()\n#define all(x) begin(x),end(x)\n#define lb(x,y) lower_bound(all(x),y)-begin(x)\nclass Solution {\npublic:\n    vector<vector<int>> rotate(vector<vector<int>> &grid) {\n        int N = sz(grid), M = sz(grid[0]);\n        vector<vector<int>> res(M, vector<int>(N));\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                res[j][N - 1 - i] = grid[i][j];\n            }\n        }\n        return res;\n    }\n    vector<vector<int>> transpose(vector<vector<int>> &grid) {\n        int N = sz(grid), M = sz(grid[0]);\n        vector<vector<int>> res(M, vector<int>(N));\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                res[j][i] = grid[i][j];\n            }\n        }\n        return res;\n    }\n    int corner(vector<vector<int>> &grid) {\n        int N = sz(grid), M = sz(grid[0]);\n        int mnR = INT_MAX, mnC = INT_MAX;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                if (grid[i][j] == 1) {\n                    mnR = min(mnR, i);\n                    mnC = min(mnC, j);\n                }\n            }\n        }\n        int res = INT_MAX;\n        for (int i = mnR; i < N; i++) {\n            for (int j = mnC; j < M; j++) {\n                int part = (i - mnR + 1) * (j - mnC + 1);\n                vector<int> left(N, INT_MAX), right(N, INT_MIN);\n                for (int x = 0; x < N; x++) {\n                    for (int y = 0; y < M; y++) {\n                        if (x > i || y > j) {\n                            if (grid[x][y] == 1) {\n                                left[x] = min(left[x], y);\n                                right[x] = max(right[x], y);\n                            }\n                        }\n                    }\n                }\n                int t = INT_MAX, b = INT_MIN;\n                for (int x = 0; x < N; x++) {\n                    if (left[x] != INT_MAX) {\n                        t = min(t, x);\n                        b = max(b, x);\n                    }\n                }\n                if (t == INT_MAX) {\n                    res = min(res, part);\n                    continue;\n                }\n                if (t == b) {\n                    res = min(res, part + right[t] - left[t] + 1);\n                } else {\n                    int l1 = INT_MAX, r1 = INT_MIN;\n                    for (int x = t; x < b; x++) {\n                        l1 = min(l1, left[x]);\n                        r1 = max(r1, right[x]);\n                        for (int y = x + 1; y <= b; y++) {\n                            if (left[y] != INT_MAX) {\n                                int l2 = INT_MAX, r2 = INT_MIN;\n                                for (int z = y; z <= b; z++) {\n                                    l2 = min(l2, left[z]);\n                                    r2 = max(r2, right[z]);\n                                }\n                                if ((y > i || l2 > j) && (l1 > j || t > i)) {\n                                    res = min(res, part + (r1 - l1 + 1) * (x - t + 1) + (r2 - l2 + 1) * (b - y + 1));\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    int across(vector<vector<int>> &grid) {\n        int N = sz(grid), M = sz(grid[0]);\n        int mnR = INT_MAX, mxR = INT_MIN;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                if (grid[i][j] == 1) {\n                    mnR = min(mnR, i);\n                    mxR = max(mxR, i);\n                }\n            }\n        }\n        int res = INT_MAX;\n        for (int i = 0; i < M; i++) {\n            for (int j = i; j < M; j++) {\n                int part = (mxR - mnR + 1) * (j - i + 1);\n                int mnR1 = INT_MAX, mxR1 = INT_MIN, mnC1 = INT_MAX, mxC1 = INT_MIN;\n                int mnR2 = INT_MAX, mxR2 = INT_MIN, mnC2 = INT_MAX, mxC2 = INT_MIN;\n                for (int x = mnR; x <= mxR; x++) {\n                    for (int y = 0; y < M; y++) {\n                        if (grid[x][y] == 0) continue;\n                        if (y < i) {\n                            mnR1 = min(mnR1, x);\n                            mxR1 = max(mxR1, x);\n                            mnC1 = min(mnC1, y);\n                            mxC1 = max(mxC1, y);\n                        } else if (y > j) {\n                            mnR2 = min(mnR2, x);\n                            mxR2 = max(mxR2, x);\n                            mnC2 = min(mnC2, y);\n                            mxC2 = max(mxC2, y);\n                        }\n                    }\n                }\n                int a1 = mnR1 == INT_MAX ? 0 : (mxR1 - mnR1 + 1) * (mxC1 - mnC1 + 1);\n                int a2 = mnR2 == INT_MAX ? 0 : (mxR2 - mnR2 + 1) * (mxC2 - mnC2 + 1);\n                res = min(res, part + a1 + a2);\n            }\n        }\n        return res;\n    }\n    int minimumSum(vector<vector<int>>& grid) {\n        int res = INT_MAX;\n        for (int k = 0; k < 4; k++) {\n            grid = rotate(grid);\n            res = min(res, across(grid));\n            for (int k2 = 0; k2 < 2; k2++) {\n                grid = transpose(grid);\n                res = min(res, corner(grid));\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1719112907.0
}