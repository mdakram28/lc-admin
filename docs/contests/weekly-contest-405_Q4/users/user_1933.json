{
    "username": "kzyKT",
    "submission": "#define F first\n#define S second\n#define R cin>>\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}\ntemplate<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?\" \":\"\");pr(b...);}\ntemplate<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nconst ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={-1,0,1,0,-1,-1,1,1},dy[8]={0,1,0,-1,-1,1,1,-1};\ntypedef pair<ll,ll> P;\ntypedef pair<string,ll> PP;\n\nstruct RollingHash {\n  static constexpr uint64_t MASK30=(1ULL<<30)-1;\n  static constexpr uint64_t MASK31=(1ULL<<31)-1;\n  static const uint64_t MOD=(1ULL<<61ULL)-1;\n  const uint64_t base;\n  vector<uint64_t> power;\n  explicit RollingHash(uint64_t base=generate_base()):base(base),power{1} {}\n  vector<uint64_t> build(const string& s) const {\n    int sz=s.size();vector<uint64_t> hashed(sz+1);\n    for(int i=0;i<sz;i++)hashed[i+1]=add(mul(hashed[i],base),s[i]);\n    return hashed;\n  }\n  template<typename T>\n  vector<uint64_t> build(const vector<T>& s) const {\n    int sz=s.size();vector<uint64_t> hashed(sz+1);\n    for(int i=0;i<sz;i++)hashed[i+1]=add(mul(hashed[i],base),s[i]);\n    return hashed;\n  }\n  uint64_t query(const vector<uint64_t>& s,int l,int r) {\n    expand(r-l);return add(s[r],MOD-mul(s[l],power[r-l]));\n  }\n  uint64_t combine(uint64_t h1,uint64_t h2,size_t h2len) {\n    expand(h2len);return add(mul(h1,power[h2len]),h2);\n  }\nprivate:\n  static inline uint64_t add(uint64_t a,uint64_t b) {\n    if((a+=b)>=MOD)a-=MOD;return a;\n  }\n  static inline uint64_t mul(uint64_t l,uint64_t r) {\n    auto lu=l>>31,ld=l&MASK31,ru=r>>31,rd=r&MASK31,mb=ld*ru+lu*rd;\n    return calc_mod(((lu*ru)<<1)+ld*rd+((mb&MASK30)<<31)+(mb>>30));\n  }\n  static inline uint64_t calc_mod(uint64_t val) {\n    val=(val&MOD)+(val>>61);if(val>MOD)val-=MOD;return val;\n  }\n  static inline uint64_t generate_base() {\n    mt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n    uniform_int_distribution<uint64_t> rand(1,RollingHash::MOD-1);\n    return rand(mt);\n  }\n  inline void expand(size_t sz) {\n    if(power.size()<sz+1) {\n      int pre_sz=power.size();power.resize(sz+1);\n      for(int i=pre_sz-1;i<sz;i++)power[i+1]=mul(power[i],base);\n    }\n  }\n};\n\nclass Solution {\npublic:\n  int minimumCost(string t, vector<string>& s, vector<int>& c) {\n    map<string,ll> ma;\n    rep(i,s.size()) {\n      if(ma.count(s[i])) ma[s[i]]=min(ma[s[i]],(ll)c[i]);\n      else ma[s[i]]=c[i];\n    }\n    s.clear(),c.clear();\n    tr(it,ma) {\n      s.pb(it->F);\n      c.pb(it->S);\n    }\n    RollingHash rh;\n    auto r1=rh.build(t);\n    vector<uint64_t> r[s.size()];\n    rep(i,s.size()) r[i]=rh.build(s[i]);\n    vector<P> v[t.size()+1];\n    vector<P> e[26];\n    rep(i,s.size()) e[s[i][0]-'a'].pb(P(s[i].size(),i));\n    rep(i,26) sort(all(e[i]));\n    ll d[t.size()+1];\n    fill(d,d+t.size()+1,MAXL);\n    d[0]=0;\n    rep(i,t.size()) {\n      if(d[i]<d[t.size()]) {\n      rep(j,e[t[i]-'a'].size()) {\n        ll k=e[t[i]-'a'][j].S;\n        if(i+s[k].size()>t.size()) break;\n        uint64_t hh=rh.query(r[k],0,s[k].size());\n        uint64_t h=rh.query(r1,i,i+s[k].size());\n        if(h==hh) d[i+s[k].size()]=min(d[i+s[k].size()],d[i]+c[k]);\n      }\n      }\n    }\n    ll ans=d[t.size()];\n    if(ans==MAXL) ans=-1;\n    return ans;\n  }\n};",
    "submit_ts": "1720323417",
    "subm_id": "1312375046"
}