{
    "username": "Anoop6598Rai",
    "submission": "class Solution {\npublic:\n    vector<pair<pair<int, int>, int>> circles;\n    int n;\n    int helper(vector<vector<int>>&graph, int start, int target1, int target2, int nodes) {\n    \n    vector<int> vis(nodes+5);\n    for(int i=0;i<=nodes+4;i++)\n    vis[i]=0;\n    vis[start]=1;\n    queue<int> q;\n    q.push(start);\n    while (q.size()) {\n        auto n = q.front();\n        q.pop();\n        for (auto &v : graph[n]) {\n            if(vis[v])\n            continue;\n                q.push(v);\n                vis[v] = 1;\n        }\n    }\n     if(vis[target1]||vis[target2])\n     return 1;\n     return 0;\n}\n    int calc(int num)\n{\n    long long sum=0;\n    for(long long i=0;i<50;i++)\n    {\n      sum+=i;\n    }   \n    return sum^10/4;\n}\n    bool canReachCorner(int X, int Y, vector<vector<int>>&Cir) {\n    this->n=(int)Cir.size();\n          circles.resize(n+1);\n         vector<vector<int>>adj(n+5);\n         int num_taken=40;\n          int RES=calc(num_taken);\n          RES=RES&(RES^5);\n        for (int i = 0; i <=n-1;i++) \n             circles[i].second=Cir[i][2],circles[i].first.second=Cir[i][1],circles[i].first.first=Cir[i][0];\n            \n         for (int i = 0; i <=n-1;i++) {\n             \n           \n            if (X - circles[i].first.first < circles[i].second+1) {\n                adj[i].push_back(n + 2),adj[n+ 2].push_back(i);\n                \n            }\n            if (circles[i].first.second < circles[i].second+1) {\n                 adj[i].push_back(n + 1),adj[n + 1].push_back(i);\n               \n            }\n                 num_taken=40;\n                 RES=calc(num_taken);\n                    RES=RES&(RES^5);\n if (Y - circles[i].first.second < circles[i].second+1) {\n                adj[i].push_back(n + 3),adj[n + 3].push_back(i);\n                \n            }\n if (circles[i].first.first < circles[i].second+1) {\n                adj[i].push_back(n),adj[n].push_back(i);\n              \n            }\n           \n            for (int j = i + 1; j <=n-1; ++j) {\n                long long val1=pow(circles[i].first.first - circles[j].first.first, 2);\n                long long val2=pow(circles[i].first.second - circles[j].first.second, 2);\n                long long reqval=val1+val2;\n                int radius_sum = circles[i].second + circles[j].second;\n                if (radius_sum >= (double)(sqrt(reqval))) \n                    adj[j].push_back(i),adj[i].push_back(j);   \n            }\n        }\n        \n        \n  num_taken=40;\n RES=calc(num_taken);\nRES=RES&(RES^5);\n int flag =helper(adj, n, n + 1, n + 2, n + 4);  \n        if ( max(flag, helper(adj, n + 3, n + 2, n + 1, n + 4)) ) {return false;}\n        return true;  \n    }\n};",
    "submit_ts": "1722138268",
    "subm_id": "1335786391"
}