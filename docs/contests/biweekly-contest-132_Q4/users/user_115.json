{
    "username": "AnantBansal",
    "submission": "#pragma GCC optimize(\"-Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define dbg(x) cout << #x << \" = \" << x << \"\\n\"\n#define pb push_back\n#define fi first\n#define se second\n#define INF 1e18\n#define all(x) (x).begin(), (x).end()\n#define set_bits(x) __builtin_popcountll(x)\nclass STLazy{\n    public:\n    vector<ll> st,lazy;\n    static ll N;\n    STLazy(ll n){\n        st.resize(4*n+1);\n        lazy.resize(4*n+1);\n        N = n;\n    }\n    void build(vector<ll>& arr, ll idx = 0, ll low = 0, ll high = N - 1){\n        if(low==high){\n            st[idx] = arr[low];\n            return;\n        }\n        ll mid = (low + high) >> 1;\n        build(arr, 2*idx+1, low, mid);\n        build(arr, 2*idx+2, mid+1, high);\n        st[idx] = st[2*idx+1] + st[2*idx+2];\n    }\n    void update(ll l, ll r, ll val, ll idx = 0, ll low = 0, ll high = N - 1){\n        if(lazy[idx] != 0){\n            st[idx] += (high - low + 1)*lazy[idx];  \n            if(low != high){\n                lazy[2*idx+1] += lazy[idx];\n                lazy[2*idx+2] += lazy[idx];\n            }\n            lazy[idx] = 0;\n        }\n        if(l>high || low>r){\n            return;\n        }\n        if(low>=l and r>=high){\n            st[idx] += (high - low + 1)*val;\n            if(low!=high){\n                lazy[2*idx+1] += val; // check these two next time you use them!\n                lazy[2*idx+2] += val;\n            }\n            return;\n        }\n        ll mid = (low + high) >> 1;\n        update(l, r, val, 2*idx+1, low, mid);\n        update(l, r, val, 2*idx+2, mid+1, high);\n        st[idx] = st[2*idx+1] + st[2*idx+2];\n    }\n    ll query(ll l, ll r, ll idx = 0, ll low = 0, ll high = N - 1){\n        if(lazy[idx] != 0){\n            st[idx] += (high - low + 1)*lazy[idx];  \n            if(low != high){\n                lazy[2*idx+1] += lazy[idx];\n                lazy[2*idx+2] += lazy[idx];\n            }\n            lazy[idx] = 0;\n        }\n        if(low>=l and r>=high){\n            return st[idx];\n        }\n        if(l>high || low>r){\n            return 0;\n        }\n        ll mid = (low + high) >> 1;\n        return (query(l, r, 2*idx+1,low,mid) + query(l, r, 2*idx+2, mid+1, high));\n    }\n};\nll STLazy::N;\nclass Solution {\npublic:\n    \n    int maximumLength(vector<int>& nums, int K) {\n        int N = nums.size();\n        vector<int> mx(K + 1, 1);   \n        vector<int> prv(N, -1);   \n        map<int, int> pos;          \n\n        for (int i = 0; i < N; ++i) {\n            if (pos.find(nums[i]) == pos.end()) {\n                pos[nums[i]] = i;\n            } else {\n                prv[i] = pos[nums[i]];\n                pos[nums[i]] = i;\n            }\n        }\n        vector<vector<int>> dp(N, vector<int>(K + 1, 1));\n        int ans = 1; \n\n        for (int i = 1; i < N; ++i) {\n            for (int k = K - 1; k >= 0; --k) {\n                dp[i][k + 1] = max(dp[i][k + 1], 1 + mx[k]);\n                mx[k + 1] = max(mx[k + 1], dp[i][k + 1]);\n            }\n            if (prv[i] != -1) {\n                int j = prv[i];\n                for (int k = 0; k <= K; ++k) {\n                    dp[i][k] = max(dp[i][k], 1 + dp[j][k]);\n                    mx[k] = max(mx[k], dp[i][k]);\n                }\n            }\n        }\n\n        for (int k = 0; k <= K; ++k) {\n            ans = max(ans, mx[k]);\n        }\n\n        return ans;\n        \n    }\n};",
    "submit_ts": 1717860512.0
}