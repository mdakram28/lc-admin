{
    "username": "Windlike man",
    "submission": "template<typename T>\nstruct BITADD\n{\n    inline static T &InlineMerge(T &l, T r)\n    {\n        return l += r;\n    }\n    inline static T &InlineRemove(T &t)\n    {\n        return t = -t;\n    }\n};\n#define Merge  InlineMerge\n#define Remove InlineRemove\n\ntemplate<typename T, typename OPES = BITADD<T>>\nstruct BIT : public OPES\n{\n#define LOWEST(idx) (idx & -idx)\n    using OPES::Merge;\n    using OPES::Remove;\n    int       n;\n    vector<T> c;\n    BIT(int n)\n    {\n        c.resize((this->n = n) + 1);\n    }\n\n    // [data, data_end)\n    BIT(int n, T *data, T *data_end)\n    {\n        c.resize((this->n = n) + 1);\n        for (int i = 1; i <= min<int>(n, data_end - data); ++i)\n        {\n            c[i] += data[i - 1];\n            if (i + LOWEST(i) <= n)\n                c[i + LOWEST(i)] += c[i];\n        }\n    }\n\n    // idx >=1\n    void update_dif(int idx, T dif)\n    {\n        while (idx <= n)\n        {\n            c[idx] = Merge(c[idx], dif);\n            idx += LOWEST(idx);\n        }\n    }\n\n    // [1,idx]\n    T prefix(int idx)\n    {\n        T ans{};\n        while (idx > 0)\n        {\n            ans = Merge(ans, c[idx]);\n            idx -= LOWEST(idx);\n        }\n        return ans;\n    }\n\n    // [l,r]\n    T range(int l, int r)\n    {\n        T vl = prefix(l - 1);\n        T vr = prefix(r);\n        return Merge(vr, Remove(vl));\n    }\n};\n\nusing Int = long long;\nclass Solution\n{\npublic:\n    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>> &queries)\n    {\n        int n = s.size();\n\n        vector<int> _l, _r;\n        for (int i = 0; i < n; ++i)\n            if (s[i] == '0')\n                _l.push_back(i);\n            else\n                _r.push_back(i);\n        for (int i = 0; i <= k; ++i)\n        {\n            _l.push_back(n);\n            _r.push_back(n);\n        }\n\n        int _l_size = _l.size(), _r_size = _r.size();\n        // bound as open limit\n        vector<Int> len(n), rightBound(n);\n\n        for (int pl = 0, pr = 0, i = 0; i < n; ++i)\n        {\n            int bound = max(_l[pl + k], _r[pr + k]);\n            rightBound[i] = bound;\n            len[i] = bound - i;\n            if (s[i] == '0')\n                pl++;\n            else\n                pr++;\n        }\n        BIT<Int> bit(n + 1, len.data(), len.data() + n);\n\n        vector<Int> ans;\n        for (int qi = 0; qi < queries.size(); ++qi)\n        {\n            int rangL = queries[qi][0], rangR = queries[qi][1];\n            int pOF = (upper_bound(rightBound.begin(), rightBound.end(), rangR) - rightBound.begin());\n            pOF = clamp(pOF, rangL, rangR + 1);\n\n            Int leftPart = bit.range(rangL + 1, pOF);\n            Int rightLen = rangR + 1 - pOF;\n            Int rightPart = (1 + rightLen) * rightLen / 2;\n            Int a = leftPart + rightPart;\n            ans.push_back(a);\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": "1723951899",
    "subm_id": "556408362"
}