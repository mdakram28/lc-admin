{
    "username": "milind0110",
    "submission": "const int N = 2e5 + 5;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    const static M G;\n    int v;\n    ModInt(ll _v = 0) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<998244353>;\ntemplate<> const Mint Mint::G = Mint(3);\n\n// template <class Mint> void nft(bool type, V<Mint>& a) {\n//     int n = int(a.size()), s = 0;\n//     while ((1 << s) < n) s++;\n//     assert(1 << s == n);\n\n//     static V<Mint> ep, iep;\n//     while (int(ep.size()) <= s) {\n//         ep.push_back(Mint::G.pow(Mint(-1).v / (1 << ep.size())));\n//         iep.push_back(ep.back().inv());\n//     }\n//     V<Mint> b(n);\n//     for (int i = 1; i <= s; i++) {\n//         int w = 1 << (s - i);\n//         Mint base = type ? iep[i] : ep[i], now = 1;\n//         for (int y = 0; y < n / 2; y += w) {\n//             for (int x = 0; x < w; x++) {\n//                 auto l = a[y << 1 | x];\n//                 auto r = now * a[y << 1 | x | w];\n//                 b[y | x] = l + r;\n//                 b[y | x | n >> 1] = l - r;\n//             }\n//             now *= base;\n//         }\n//         swap(a, b);\n//     }\n// }\n\n// template <class Mint> V<Mint> multiply(const V<Mint>& a, const V<Mint>& b) {\n//     assert(false);\n//     incase of cross-correlation reverse b and the answer will be at length of reversed array - the index for answer\n//     int n = int(a.size()), m = int(b.size());\n//     if (!n || !m) return {};\n//     int lg = 0;\n//     while ((1 << lg) < n + m - 1) lg++;\n//     int z = 1 << lg;\n//     auto a2 = a, b2 = b;\n//     a2.resize(z);\n//     b2.resize(z);\n//     nft(false, a2);\n//     nft(false, b2);\n//     for (int i = 0; i < z; i++) a2[i] *= b2[i];\n//     nft(true, a2);\n//     a2.resize(n + m - 1);\n//     Mint iz = Mint(z).inv();\n//     for (int i = 0; i < n + m - 1; i++) a2[i] *= iz;\n//     return a2;\n// }\n\n// Mint fact[N];\n// Mint inv[N];\n// void precalc(){\n//     fact[0] = 1;\n//     for(int i = 1; i < N; i++){\n//         fact[i] = fact[i - 1];\n//         fact[i] *= i;\n//     }\n//     for(int i = 0; i < N; i++){\n//         inv[i] = 1;\n//         inv[i] /= fact[i];\n//     }\n// }\n// Mint ncrmodp(int n,int r){\n//     if(n < 0 || n < r)\n//         return 0;\n//     return fact[n]*inv[n-r]*inv[r];\n// }\nclass Solution {\npublic:\n    vector<Mint> pp = {31,37};\n    vector<array<Mint,2>> p,ip;\n    vector<array<Mint,2>> compute_hash(string const& s) {\n        int n = s.length();\n        vector<array<Mint,2>> hash(n + 1);\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < 2; j++){\n                hash[i + 1][j] = (hash[i][j] + p[i][j] * (s[i] - 'a' + 1));\n            }\n        }\n        return hash;\n    }\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        set<int> lens;\n        int n = target.size();\n        for(auto i : words){\n            lens.insert((int)i.length());\n        }\n        vector<int> ulens(lens.begin(),lens.end());\n        p = vector<array<Mint,2>>(n + 1);\n        ip = vector<array<Mint,2>>(n + 1);\n        p[0][0] = 1;\n        p[0][1] = 1;\n        ip[0][0] = 1;\n        ip[0][1] = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < 2; j++){\n                p[i + 1][j] = (p[i][j] * pp[j]);\n                ip[i + 1][j] = p[i + 1][j].inv();\n            }\n        }\n        int m = words.size();\n        vector<map<array<int,2>,int>> c(n + 1);\n        for(int i = 0; i < m; i++){\n            int len = words[i].size();\n            if(len > n) continue;\n            auto ha = compute_hash(words[i]);\n            array<int,2> h = {ha.back()[0].v,ha.back()[1].v};\n            if(c[len].count(h)){\n                c[len][h] = min(c[len][h],costs[i]);\n            } else {\n                c[len][h] = costs[i];\n            }\n        }\n        auto h = compute_hash(target);\n        const int inf = 1e9;\n        vector<long long> dp(n + 1,inf);\n        dp[0] = 0;\n        for(int i = 0; i < n; i++){\n            for(auto len : ulens){\n                if(i + 1 - len < 0) break;\n                array<int,2> hash;\n                for(int j = 0; j < 2; j++){\n                    hash[j] = ((h[i + 1][j] - h[i + 1 - len][j]) * ip[i + 1 - len][j]).v;\n                }\n                if(c[len].count(hash)){\n                    dp[i + 1] = min(dp[i + 1],dp[i + 1 - len] + c[len][hash]);\n                }\n            }\n        }\n        return (dp[n] == inf ? -1 : dp[n]);\n        \n    }\n};",
    "submit_ts": "1720322608",
    "subm_id": "1312354438"
}