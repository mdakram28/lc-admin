{
    "username": "vwv",
    "submission": "// clang-format off\nstatic const auto io_sync_off = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\n#define tT template<typename T>\n#define DA decltype(auto)\n#define FD(v) std::forward<decltype(v)>(v)\n#define DD(v) decay_t<decltype(v)>\n#define DDv(v) typename DD(v)::value_type\n#define DDm(m) typename DD(m)::mapped_type\n#define DDp(m) pair<typename DD(m)::key_type, DDm(m)>\nusing ll = long long; using S = string;\nusing pii = pair<int, int>; using pis = pair<int, S>; using psi = pair<S, int>;\ntT using V = vector<T>; tT using VV = V<V<T>>; tT using VVV = VV<V<T>>;\nusing vi = V<int>; using vvi = VV<int>; using vvvi = VVV<int>; using vb = V<bool>; using vvb = VV<bool>; using vs = V<S>; using vd = V<double>; using vli = V<list<int>>;\ntT using US = unordered_set<T>; template<typename A, typename B> using UM = unordered_map<A, B>;\nusing si = set<int>; using usi = US<int>; using uss = US<S>;\nusing mii = map<int, int>; using umii = UM<int, int>; using umib = UM<int, bool>; using umsi = UM<S, int>;\nusing pqi = priority_queue<int, vi, greater<int>>; using pqri = priority_queue<int, vi>;\nconstexpr int BIG = 1e9; constexpr int MOD = 1e9 + 7; constexpr int MAX_INT = INT_MAX; constexpr bool fasle = false; constexpr bool ture = true;\n#define fi first\n#define se second\n#define pb push_back\n#define F(i, a, b) for(int(i) = (a); (i) < (b); ++(i))\n#define Fs(i, a, b, s) for(int(i) = (a); (i) < (b); (i) += (s))\n#define Fe(i, a, b) for(int(i) = (a); (i) <= (b); ++(i))\n#define FR(i, a, b) for(int(i) = (a); (i) >= (b); --(i))\n#define FRn(i, a, b) for(int(i) = (a); (i) > (b); --(i))\n#define FE(a, v) for(auto &&(a): (v)) // For each element in a container... Use `&&` due to `vb`.\n#define FEv(v, m) for(auto &[k, v]: (m)) // For each element in a map or unordered_map...\n#define FEt(t, s) stringstream ss(s); for(S (t); ss >> (t);) // For each token in a S...\n#define W(n) while((n)--)\n#define ALL(v) (v).begin(), (v).end()\n#define ALLR(v) (v).rbegin(), (v).rend()\ntT concept FS = requires(T t) { t.fi, t.se; }; tT concept BE = requires(T t) { ALL(t); }; tT concept FP = requires(T t) { t.front(), t.pop(); }; tT concept TP = requires(T t) { t.top(), t.pop(); };\nDA R(auto &&v) { reverse(ALL(v)); return FD(v); }\nDA SORT(auto &&v) { sort(ALL(v)); return FD(v); } DA SORTR(auto &&v) { sort(ALL(v), greater()); return FD(v); }\n#define SORTfab(v, fab) (sort(ALL(v), [&](const auto &a, const auto &b) { return (fab); }), v) // Sort elements based on a function of any 2 elements `a` and `b`.\nDA UE(auto &&v) { v.erase(unique(ALL(v)), v.end()); return FD(v); } DA SUE(auto &&v) { return UE(SORT(v)); }\nDA COUNT(const auto &v, const auto &k) { return count(ALL(v), k); }\n#define COUNTifa(v, ifa) count_if(ALL(v), [&](const auto &a) { return (ifa); }) // Count elements based on an if-condition of any elemnent `a`.\nDA sz(const auto &v) { return v.size(); }\n#define szXY(vv) int X = sz(vv), Y = X ? sz((vv)[0]) : 0\nDA maxe(auto &v) { return max_element(ALL(v)); } DA mine(auto &v) { return min_element(ALL(v)); } DA maxer(auto &v) { return max_element(ALLR(v)).base() - 1; } DA miner(auto &v) { return min_element(ALLR(v)).base() - 1; } DA maxv(const auto &v) { return *maxe(v); } DA minv(const auto &v) { return *mine(v); } DA maxvi(const auto &v) { return maxe(v) - v.begin(); } DA minvi(const auto &v) { return mine(v) - v.begin(); } DA maxvir(const auto &v) { return maxer(v) - v.begin(); } DA minvir(const auto &v) { return miner(v) - v.begin(); }\nDA lb(auto &v, const auto &k) { return lower_bound(ALL(v), k); } DA ub(auto &v, const auto &k) { return upper_bound(ALL(v), k); } DA lub(auto &v, const auto &k) { return pair{lb(v, k), ub(v, k)}; } DA lbi(auto &v, const auto &k) { return lower_bound(ALL(v), k) - v.begin(); } DA ubi(auto &v, const auto &k) { return upper_bound(ALL(v), k) - v.begin(); } DA lubi(auto &v, const auto &k) { return pair{lbi(v, k), ubi(v, k)}; }\nDA findi(auto &v, const auto &k) { return find(ALL(v), k) - v.begin(); }\nDA SUM(const auto &v) { return accumulate(ALL(v), DDv(v){}); }\n#define SUMifa(v, ifa) accumulate(ALL(v), DDv(v){}, [](const auto &s, const auto &a) { return s + ((ifa) ? a : DDv(v){}); }) // Sum elements based on an if-condition of any element `a`.\n#define SUMfa(v, fa) accumulate(ALL(v), DDv(v){}, [](const auto &s, const auto &a) { return s + (fa); }) // Sum elements with a function of any element `a`.\nDA PSUM(const auto &v) { auto r = v; F(i, 1, sz(r)) r[i] += r[i - 1]; return r; } DA PSUM0(const auto &v) { DD(v) r; r.reserve(sz(r) + 1); r.pb(DDv(v){}); r.insert(r.end(), v.begin(), v.end()); F(i, 2, sz(r)) r[i] += r[i - 1]; return r; }\nDA HISTV(const auto &v, int n, int b = 0, const function<bool(int)> &if_ = [](int) { return true; }) { vi hist(n); FE(a, v) if(if_(a)) hist[a - b]++; return hist; }\n#define HISTVifa(v, n, b, ifa) HISTV((v), (n), (b), [](int a) { return (ifa); })\nDA HISTM(const auto &v) { UM<DDv(v), int> um; FE(a, v) um[a]++; return um; } DA HISTMif(const auto &v, const function<bool(const DDv(v) &)> &if_) { UM<DDv(v), int> um; FE(a, v) if(if_(a)) um[a]++; return um; }\n#define HISTMifa(v, ifa) HISTMif((v), [](const auto &a) { return (ifa); })\nDA Mp2V(const auto &m) { V<DDp(m)> v(sz(m)); int i = 0; FE(p, m) v[i++] = p; return v; } DA Mv2V(const auto &m) { V<DDm(m)> v(sz(m)); int i = 0; FEv(a, m) v[i++] = a; return v; }\nDA IOTA(int n, int b = 0) { vi v(n); iota(ALL(v), b); return v; } // Create a `vector<int>` with b+0, b+1, b+2, ..., b+n-1. `b` means base.\nDA BS(int a, int b, const function<bool(int)> &FirstTrue) { while(a <= b) { int m = a + (b - a) / 2; if(FirstTrue(m)) b = m - 1; else a = m + 1; } return a; }\n#define BSfm(a, b, fm) BS((a), (b), [&](int m) { return (fm); })\nDA TOKEN(const S &s) { vs v; FEt(t, s) v.pb(t); return v; }\nDA POP(FP auto &v) { auto r = v.front(); v.pop(); return r; } DA POP(TP auto &v) { auto r = v.top(); v.pop(); return r; }\nDA _T(const auto &vv) { szXY(vv); DD(vv) r(X, DDv(vv)(Y)); F(y, 0, Y) F(x, 0, X) r[y][x] = vv[x][y]; return r; }\nDA _P(const auto &k) { cout << \" \" << k ; } DA _P(const S &s) { cout << \" \" << s << endl; } DA _P(const FS auto &p) { cout << \" (\"; _P(p.fi); _P(p.se); cout << \")\"; } DA _P(const BE auto &v) { cout << endl; FE(k, v) _P(k); }\nDA P(const auto &...k) { (_P(k), ...); cout << endl; }\nDA operator+(const FS auto &a, const auto &b) { return DD(a){a.fi + b.fi, a.se + b.se}; } DA operator+=(FS auto &&a, const auto &b) { a.fi += b.fi; a.se += b.se; return FD(a); } DA operator-(const FS auto &a, const auto &b) { return DD(a){a.fi - b.fi, a.se - b.se}; } DA operator-=(FS auto &&a, const auto &b) { a.fi -= b.fi; a.se -= b.se; return FD(a); }\nDA operator+(const BE auto &a, const auto &b) { DD(a) c; c.reserve(sz(a)); transform(ALL(a), b.begin(), back_inserter(c), plus()); return c; } DA operator+=(auto &&a, const auto &b) { transform(ALL(a), b.begin(), a.begin(), plus()); return FD(a); } DA operator-(const BE auto &a, const auto &b) { DD(a) c; c.reserve(sz(a)); transform(ALL(a), b.begin(), back_inserter(c), minus()); return c; } DA operator-=(auto &&a, const auto &b) { transform(ALL(a), b.begin(), a.begin(), minus()); return FD(a); }\n// clang-format on\n\n/*\nint r = 0, n = sz(v);\nreturn r;\n*/\n\n//****************************************************************************************************\n\nclass Solution1 {\npublic:\n    int r = 0;\n    void test(vi &v, int k, int a, int b) {\n        if(k == sz(v)) {\n            r++;\n            return;\n        }\n        Fe(i, max(a, v[k] - b), v[k]) test(v, k + 1, i, v[k] - i);\n    }\n    int countOfPairs(vector<int> &v) {\n        test(v, 0, 0, BIG);\n        return r;\n    }\n};\n\nclass Solution {\npublic:\n    int countOfPairs(vector<int> &v) {\n        int n = sz(v), mi = 0;\n        F(i, 1, n) mi = max(v[i] - (v[i - 1] - mi), mi);\n        mi = v[n - 1] - mi + 1;\n        if(mi <= 0) return 0;\n        vi dp(mi, 1);\n        Fe(i, 1, n) F(j, 1, mi) dp[j] = (dp[j] + dp[j - 1]) % MOD;\n        return dp.back();\n    }\n};\n",
    "submit_ts": "1723347978",
    "subm_id": "1351609242"
}