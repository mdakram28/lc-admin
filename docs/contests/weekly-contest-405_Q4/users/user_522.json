{
    "username": "Romy67",
    "submission": "#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define per(i, a, b) for(int i = a; i > (b); --i)\n#define ar array\n#define sz(x) (int) (x).size()\n#define pii pair<int,int>\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\n\ntemplate<typename T>\nvoid min_self(T& A, T B) {\n    A = min(A,B);\n}\ntemplate<typename T>\nvoid max_self(T& A, T B) {\n    A = max(A,B);\n}\n\nstruct AhoCorasick {\n    enum {alpha = 26, first = 'a'}; // change this!\n    struct Node {\n        // (nmatches is optional)\n        int back, next[alpha], start = -1, end = -1, nmatches = 0;\n        Node(int v) { memset(next, v, sizeof(next)); }\n    };\n    vector<Node> N;\n    vi backp;\n    void insert(string& s, int j) {\n        assert(!s.empty());\n        int n = 0;\n        for (char c : s) {\n            int& m = N[n].next[c - first];\n            if (m == -1) { n = m = sz(N); N.emplace_back(-1); }\n            else n = m;\n        }\n        if (N[n].end == -1) N[n].start = j;\n        backp.push_back(N[n].end);\n        N[n].end = j;\n        N[n].nmatches++;\n    }\n    AhoCorasick(vector<string>& pat) : N(1, -1) {\n        rep(i,0,sz(pat)) insert(pat[i], i);\n        N[0].back = sz(N);\n        N.emplace_back(0);\n\n        queue<int> q;\n        for (q.push(0); !q.empty(); q.pop()) {\n            int n = q.front(), prev = N[n].back;\n            rep(i,0,alpha) {\n                int &ed = N[n].next[i], y = N[prev].next[i];\n                if (ed == -1) ed = y;\n                else {\n                    N[ed].back = y;\n                    (N[ed].end == -1 ? N[ed].end : backp[N[ed].start])\n                        = N[y].end;\n                    N[ed].nmatches += N[y].nmatches;\n                    q.push(ed);\n                }\n            }\n        }\n    }\n    vi find(string word) {\n        int n = 0;\n        vi res; // ll count = 0;\n        for (char c : word) {\n            n = N[n].next[c - first];\n            res.push_back(N[n].end);\n            // count += N[n].nmatches;\n        }\n        return res;\n    }\n    vector<vi> findAll(vector<string>& pat, string word) {\n        vi r = find(word);\n        vector<vi> res(sz(word));\n        rep(i,0,sz(word)) {\n            int ind = r[i];\n            while (ind != -1) {\n                res[i - sz(pat[ind]) + 1].push_back(ind);\n                ind = backp[ind];\n            }\n        }\n        return res;\n    }\n};\n\ntypedef uint64_t ull;\nstruct H {\n\tull x; H(ull x=0) : x(x) {}\n\tH operator+(H o) { return x + o.x + (x + o.x < x); }\n\tH operator-(H o) { return *this + ~o.x; }\n\tH operator*(H o) { auto m = (__uint128_t)x * o.x;\n\t\treturn H((ull)m) + (ull)(m >> 64); }\n\tull get() const { return x + !~x; }\n\tbool operator==(H o) const { return get() == o.get(); }\n\tbool operator<(H o) const { return get() < o.get(); }\n};\nstatic const H C = (ll)1e11+3; // (order ~ 3e9; random also ok)\n\nH hashString(string& s){H h{}; for(char c:s) h=h*C+c;return h;}\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        vector<H> wh;\n        rep(i,0,sz(words)) {\n            wh.push_back(hashString(words[i]));\n        }\n        map<ull,pii> mp;\n        rep(i,0,sz(words)) {\n            ull hs = wh[i].get();\n            if(mp.count(hs)) {\n                min_self(mp[hs], (pii){costs[i],i});\n            } else {\n                mp[hs] = {costs[i],i};  \n            }\n        }\n        vector<string> w2;\n        map<int,int> w2cost;\n        for(auto [hsi, cid]: mp) {\n            auto [c, id] = cid;\n            w2cost[sz(w2)] = c;\n            w2.push_back(words[id]);\n        }\n        AhoCorasick ac(w2);\n        auto res = ac.findAll(w2, target);\n        vector<int> dp(sz(target)+1, 1e9);\n        dp[0] = 0;\n        rep(i,0,sz(target)) {\n            for(int id: res[i]) {\n                int len = sz(w2[id]);\n                min_self(dp[i+len], dp[i]+w2cost[id]);\n            }\n        }\n        if(dp[sz(target)]==1e9) {\n            return -1;\n        } else {\n            return dp[sz(target)];\n        }\n    }\n};",
    "submit_ts": "1720322349",
    "subm_id": "1312347517"
}