{
    "username": "animesh_2403",
    "submission": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findDiameter(const vector<vector<int>>& tree, int startNode) {\n        int n = tree.size();\n        vector<int> dist(n, -1);\n        queue<int> q;\n        q.push(startNode);\n        dist[startNode] = 0;\n        int farthestNode = startNode;\n\n        // BFS to find the farthest node from startNode\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            for (int neighbor : tree[node]) {\n                if (dist[neighbor] == -1) {\n                    dist[neighbor] = dist[node] + 1;\n                    q.push(neighbor);\n                    if (dist[neighbor] > dist[farthestNode]) {\n                        farthestNode = neighbor;\n                    }\n                }\n            }\n        }\n\n        // BFS from the farthest node found to find the diameter\n        fill(dist.begin(), dist.end(), -1);\n        q.push(farthestNode);\n        dist[farthestNode] = 0;\n        int diameter = 0;\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            for (int neighbor : tree[node]) {\n                if (dist[neighbor] == -1) {\n                    dist[neighbor] = dist[node] + 1;\n                    q.push(neighbor);\n                    diameter = max(diameter, dist[neighbor]);\n                }\n            }\n        }\n\n        return diameter;\n    }\n\n    int minimumDiameterAfterMerge( vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n=edges1.size()+1;\n        int m=edges2.size()+1;\n        vector<vector<int>> tree1(n), tree2(m);\n\n        for (const auto& edge : edges1) {\n            tree1[edge[0]].push_back(edge[1]);\n            tree1[edge[1]].push_back(edge[0]);\n        }\n\n        for (const auto& edge : edges2) {\n            tree2[edge[0]].push_back(edge[1]);\n            tree2[edge[1]].push_back(edge[0]);\n        }\n\n        int diameter1 = findDiameter(tree1, 0);\n        int diameter2 = findDiameter(tree2, 0);\n\n        int radius1 = (diameter1 + 1) / 2;\n        int radius2 = (diameter2 + 1) / 2;\n\n        int newDiameter = max({diameter1, diameter2, radius1 + radius2 + 1});\n        return newDiameter;\n    }\n};\n",
    "submit_ts": 1719717224.0
}