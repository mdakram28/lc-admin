{
    "username": "leetgoat_dot_dev",
    "submission": "from sortedcontainers import SortedList\n\n\n\n\nclass SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (4 * n)\n        self.lazy = [0] * (4 * n)\n    \n    def propagate(self, node, start, end):\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n    \n    def addXToRange(self, l, r, x):\n        # print(f'{self._line()} ADD {x} TO RANGE CALLED, l={l}, r={r} {self._line()}')\n        self.addXToRangeUtil(0, 0, self.n - 1, l, r, x)\n    \n    def addXToRangeUtil(self, node, start, end, l, r, x):\n        self.propagate(node, start, end)\n        \n        if start > end or start > r or end < l:\n            return\n        \n        if start >= l and end <= r:\n            self.tree[node] += x * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += x\n                self.lazy[2 * node + 2] += x\n            # print(f'Updated node {node} with range [{start},{end}] to {self.tree[node]}')\n            return\n        \n        mid = (start + end) // 2\n        self.addXToRangeUtil(2 * node + 1, start, mid, l, r, x)\n        self.addXToRangeUtil(2 * node + 2, mid + 1, end, l, r, x)\n        self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n        # print(f'Updated node {node} after combining children with range [{start},{end}] to {self.tree[node]}')\n    \n    def queryPoint(self, index):\n        # print(f'{self._line()} QUERY POINT CALLED, index={index} {self._line()}')\n        return self.queryPointUtil(0, 0, self.n - 1, index)\n    \n    def queryPointUtil(self, node, start, end, index):\n        self.propagate(node, start, end)\n        \n        if start == end:\n            # print(f'Query result for index {index}: {self.tree[node]}')\n            return self.tree[node]\n        \n        mid = (start + end) // 2\n        if index <= mid:\n            return self.queryPointUtil(2 * node + 1, start, mid, index)\n        else:\n            return self.queryPointUtil(2 * node + 2, mid + 1, end, index)\n    \n#     def __str__(self):\n#         result = []\n#         def _printTree(i, tl, tr, indent):\n#             if tl == tr:\n#                 result.append(f'{\" \" * indent}{self._getPrintFormattedVal(self.tree[i], tl, tr)}')\n#                 return\n#             tm = (tl + tr) // 2\n#             result.append(f'{\" \" * indent}{self._getPrintFormattedVal(self.tree[i], tl, tr)}')\n#             _printTree(2 * i, tl, tm, indent + 4)\n#             _printTree(2 * i + 1, tm + 1, tr, indent + 4)\n#         _printTree(0, 0, self.n - 1, 0)\n#         return f'{self._line()} SEGMENT TREE VISUALIZATION {self._line()}\\n' + \"\\n\".join(result)\n\n#     def _getPrintFormattedVal(self, val, tl, tr):\n#         prefix = f'[{tl},{tr}] '\n#         return prefix + str(val)\n\n#     def _line(self):\n#         return '________________________________________'\n        \n        \n        \n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        edges = [num for num in range(n)] # 0->1->2->3->4 = [0, 1, 2, 3] as the edges\n        sl = SortedList(edges)\n        \n        # print(f'init sl: {sl}')\n        \n        def removeRange(l, r):\n            leftIndex = sl.bisect_left(l)\n            rightIndex = sl.bisect_right(r)\n            removedCount = rightIndex - leftIndex\n            del sl[leftIndex:rightIndex]\n            return removedCount\n        \n        # removeRange(1, 2)\n        \n        # print(f'sl after removing [1, 2]: {sl}')\n        \n        st = SegmentTree(n)\n        \n        # print(f'st is: {st}')\n        \n        res = []\n        for l, r in queries:\n            if l < r - 1:\n                \n                # print(f'______________ ITER ON QUERIES: l={l} r={r}')\n                # print(f'current st: {st}')\n                # print(f'current sl: {sl}')\n                newSkipped = removeRange(l + 1, r - 1)\n                # print(f'new slipped: {newSkipped}')\n                st.addXToRange(r, n - 1, newSkipped)\n                \n            res.append((n - 1) - st.queryPoint(n - 1))\n        \n        return res\n        \n        ",
    "submit_ts": "1722740883",
    "subm_id": "1343731166"
}