{
    "username": "prem__",
    "submission": "template<typename T=long long>\nT func(T a, T b) {\n    return max(a,b) ;\n}\n\n\ntemplate<typename T=long long>\nclass SegmentTree {\n    vector<T> tree;\n    int size;\n    T mnVal;\n \npublic:\n    SegmentTree(vector<T>& array, T val) {\n        size = array.size();\n        tree.resize(4 * size);\n        mnVal = val;\n        buildTree(array, 0, 0, size - 1);\n    }\n \nprivate:\n    void buildTree(vector<T>& array, int treeIndex, int left, int right) {\n        if (left == right) {\n            tree[treeIndex] = array[left];\n            return;\n        }\n        int mid = left + (right - left) / 2;\n        buildTree(array, 2 * treeIndex + 1, left, mid);\n        buildTree(array, 2 * treeIndex + 2, mid + 1, right);\n        tree[treeIndex] = func<T>(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n    }\n \n    T query(int treeIndex, int left, int right, int queryLeft, int queryRight) {\n        if (queryLeft <= left && right <= queryRight)\n            return tree[treeIndex];\n        int mid = left + (right - left) / 2;\n        T value = mnVal ;\n        if (queryLeft <= mid)\n            value = func<T>(value, query(2 * treeIndex + 1, left, mid, queryLeft, queryRight));\n        if (queryRight > mid)\n            value = func<T>(value, query(2 * treeIndex + 2, mid + 1, right, queryLeft, queryRight));\n        return value;\n    }\n    T update(int treeIndex, int left, int right, int pos, T val){\n        if(left==pos && right==pos) {\n            tree[treeIndex] = val ;\n            return val;\n        }\n        int mid = left + (right-left)/2 ;\n        T value = mnVal ;\n        if(pos<=mid) {\n            value = func<T>(value, update(2 * treeIndex + 1, left, mid, pos, val));\n            value = func<T>(value, tree[2 * treeIndex + 2]);\n        }else {\n            value = func<T>(value, update(2 * treeIndex + 2, mid+1, right, pos, val));\n            value = func<T>(value, tree[2 * treeIndex + 1]);\n        }\n        tree[treeIndex] = value ;\n        return value ;\n    }\n \npublic:\n    T query(int left, int right) {\n        return query(0, 0, size - 1, left, right);\n    }\n    void update(int pos, T val) {\n        update(0, 0, size-1, pos, val) ;\n    }\n};\n\n\nclass Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {\n        int n=nums.size(), tmp, tmp2;\n        vector<int> ans(n, 0);\n        SegmentTree<int> tr1(ans, 0), tr2(ans, 0), *tr, *trp ;\n        map<long long, int> mp;\n        tr1.update(0, 1);\n        tr2.update(0,1);\n        \n        for(int i=0; i<n; ++i) {\n            if(mp.find(nums[i])!=mp.end()) {\n                mp[nums[i]] += 1;\n                tr1.update(i, mp[nums[i]]);\n            }else{\n                mp.insert({nums[i],1});\n                tr1.update(i, 1);\n            }\n        }\n        \n        \n        for(int j=0; j<k; ++j) {\n            \n            mp.clear();\n            mp.insert({nums[0], 1});\n            for(int i=1; i<n; ++i) {\n                tmp = 0;\n                if(j&1) {\n                    tr = &tr1;\n                    trp = &tr2;\n                }else {tr = &tr2;trp = &tr1;}\n\n                tmp  = trp->query(0, i-1) + 1;\n                // cout<<tmp<<'a ';\n                if(mp.find(nums[i])!=mp.end()) {\n                    tmp = max(tmp, mp[nums[i]]+1);\n                    mp[nums[i]] = tmp;\n                }else {\n                    mp.insert({nums[i], tmp});\n                }\n\n                tr->update(i, tmp);\n                // mp.clear();\n                // cout<<tmp<<' ';\n                \n            }\n            // cout<<endl;\n            \n        }\n        \n        return max(tr1.query(0,n-1), tr2.query(0,n-1));\n        \n    }\n};",
    "submit_ts": "1717859698",
    "subm_id": "1281731812"
}