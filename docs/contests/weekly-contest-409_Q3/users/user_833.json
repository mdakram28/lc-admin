{
    "username": "soupboy",
    "submission": "class Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {        \n        \n        // for every starting point , lets store the maxJumpSize.\n        \n        vector<int>maxJumpSize(n,1);\n        \n        vector<int> ret(queries.size());\n        int jumps = n-1;\n        // cout<<jumps<<\"\\n\";\n        set<int>starts;\n        for(int i=0;i<queries.size();i++) {\n            int src = queries[i][0];\n            int dst = queries[i][1];\n            \n            // find out if a covering thing exist;\n            auto low = starts.lower_bound(src);\n            if(low == starts.end()) {\n                if(low != starts.begin()) {\n                    low--;\n                    int prevStart =*(low);\n                    int prevEnd = maxJumpSize[prevStart] + prevStart;\n\n                    if(prevEnd >= dst) {\n                        ret[i] = jumps;\n                        continue;\n                    }\n                }\n            } else if((*(low)) == src) {\n                int prevStart =*(low);\n                int prevEnd = maxJumpSize[prevStart] + prevStart;\n                \n                if(prevEnd >= dst) {\n                    ret[i] = jumps;\n                    continue;\n                }\n            } else if(low != starts.begin()) {\n                low--;\n                int prevStart =*(low);\n                int prevEnd = maxJumpSize[prevStart] + prevStart;\n                \n                if(prevEnd >= dst) {\n                    ret[i] = jumps;\n                    continue;\n                }\n            }\n            \n            // lets find out how many starts exist between src1+ and dst and erase all of them;\n            \n            auto ite = starts.upper_bound(src);\n            \n            while(ite != starts.end()) {\n                \n                int v = *(ite);\n                \n                auto cur = ite;\n                ite++;\n                \n                if(v >= dst) {                    \n                    break;\n                }\n                \n                // erase v and add back to jumps;\n                \n                int toErase = maxJumpSize[v]-1;\n                jumps+=toErase;\n                \n                starts.erase(cur);                                \n            }\n            \n            // now lets add this jump.\n            starts.insert(src);\n            int dis = dst-src;\n            if(maxJumpSize[src] >= dis) {\n                // already there is a bigger jump present;\n                ret[i] = jumps;\n                continue;\n            }\n            int extra = dis - maxJumpSize[src] ;\n            maxJumpSize[src] = dis;\n            jumps -= extra;\n            ret[i]=jumps;\n            \n        }\n        \n        return ret;\n        \n        \n    }\n};",
    "submit_ts": "1722742971",
    "subm_id": "1343781315"
}