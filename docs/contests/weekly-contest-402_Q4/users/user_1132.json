{
    "username": "__ARYAN1__",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define mod 998244353\n\n#define ll long long\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vi vector<int>\n#define vb vector<bool>\n#define vvi vector<vector<int>>\n#define vvb vector<vector<bool>>\n#define vvc vector<vector<char>>\n#define vvll vector<vector<long long int>>\n#define vc vector<char>\n#define vll vector<long long>\n#define mii map<int, int>\n#define umii unordered_map<int, int>\n#define si set<int>\n#define rep(i, s, e) for (ll i = s; i <= e; i++)\n#define ren(i, s, e) for (ll i = s; i >= e; i--)\n\nclass Solution {\npublic:\n    vll segmentTree;\n    void build(int low, int high, int idx, vi &a){\n        if(low == high) {\n            segmentTree[idx] = 0;\n            return;\n        }\n        \n        if(high - low + 1 == 2) return;\n        \n        int mid = (low + high) / 2;\n        build(low, mid, (2 * idx) + 1, a);\n        build(mid + 1, high, (2 * idx) + 2, a);\n        \n\n        int n1 = segmentTree[(2*idx) + 1], n2 = segmentTree[(2*idx) + 2];\n        \n        segmentTree[idx] = n1 + n2;\n        \n        if(a[mid] > a[mid-1] and a[mid] > a[mid+1]) segmentTree[idx] += 1;\n        else if(a[mid+1] > a[mid]){\n            if(high - mid > 1){\n                if(a[mid+1] > a[mid+2]) segmentTree[idx] += 1;\n            }\n        }\n        \n    }\n    \n    ll range_query(int low, int high, int left, int right, int idx, vi &a){\n        if(low > right || high < left) return 0;\n        if(low >= left and high <= right) return segmentTree[idx];\n        int mid = (low + high) >> 1;\n        ll n1 = range_query(low, mid, left, right, (2*idx + 1), a);\n        ll n2 = range_query(mid+1, high, left, right, (2*idx + 2), a);\n        \n        int l = max(low, left), r = min(high, right);\n        \n        if(r - l + 1 == 2) return n1 + n2;\n        // if(a[mid] > a[mid-1] and a[mid] > a[mid+1]) return n1 + n2 + 1;\n        // else if(a[mid+1] > a[mid]){\n        //      if(r - mid > 1){\n        //          if(a[mid+1] > a[mid+2]) return n1 + n2 + 1;\n        //      }\n        // }\n        \n        if(mid - 1 >= l and mid + 1 <= r){\n            if(a[mid] > a[mid-1] and a[mid] > a[mid+1]) return n1 + n2 + 1;\n        }\n        if(mid >= l and mid + 2 <= r){\n            if(a[mid+1] > a[mid] and a[mid+1] > a[mid+2]) return n1 + n2 + 1;\n        }\n        return n1 + n2;\n    }\n\n    void point_query(int low, int high, int idx, int tar, int val, vi &a){\n        if(low == high){\n            a[tar] = val;\n            return;\n        }\n        ll mid = (low + high) >> 1;\n        if(tar > mid){\n            point_query(mid+1, high, (2*idx + 2), tar, val, a);\n        }\n        else\n            point_query(low, mid, (2*idx + 1), tar, val, a);\n        \n        if(high - low + 1 == 2) return;\n        \n        int n1 = segmentTree[(2*idx) + 1], n2 = segmentTree[(2*idx) + 2];\n        \n        segmentTree[idx] = n1 + n2;\n        \n        if(a[mid] > a[mid-1] and a[mid] > a[mid+1]) segmentTree[idx] += 1;\n        else if(a[mid+1] > a[mid]){\n            if(high - mid > 1){\n                if(a[mid+1] > a[mid+2]) segmentTree[idx] += 1;\n            }\n        }\n\n    }\n    vi countOfPeaks(vi &nums, vvi &queries) {\n        int n = nums.size();\n        segmentTree.resize(4*n, 0);\n        build(0, n-1, 0, nums);\n\n        int q = queries.size();\n        vi res;\n        rep(i, 0, q-1){\n            int type = queries[i][0];\n            if(type == 1){\n                int l = queries[i][1], r = queries[i][2];\n                res.push_back(range_query(0, n-1, l, r, 0, nums));\n            }\n            else{\n                int id = queries[i][1], val = queries[i][2];\n                point_query(0, n-1, 0, id, val, nums);\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1718509324.0
}