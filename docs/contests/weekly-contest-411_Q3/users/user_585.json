{
    "username": "ALTAIR",
    "submission": "class Solution {\npublic:\n    char memo[100001][7];\n    char memoNonZero[100001][7];\n    int nextMod[100001][7];\n    int nextModNonZero[100001][7];\n\n    string largestPalindrome(int n, int k) {\n        if (k == 1 || k == 3 || k == 9) return string(n, '9');\n        \n        if (k == 2) return handleSpecialCase(n, '8');\n        if (k == 5) return handleSpecialCase(n, '5');\n        if (k == 4) return handleCaseFour(n);\n        if (k == 8) return handleCaseEight(n);\n        if (k == 6) return handleCaseSix(n);\n        if (k == 7) return handleCaseSeven(n);\n\n        return \"\";\n    }\n\nprivate:\n    string handleSpecialCase(int n, char digit) {\n        if (n == 1) return string(1, digit);\n        string result(n, '9');\n        result[0] = result[n - 1] = digit;\n        return result;\n    }\n\n    string handleCaseFour(int n) {\n        if (n <= 3) return string(n, '8');\n        string result(n, '9');\n        result[0] = result[1] = result[n - 2] = result[n - 1] = '8';\n        return result;\n    }\n\n    string handleCaseEight(int n) {\n        if (n <= 5) return string(n, '8');\n        string result(n, '9');\n        result[0] = result[1] = result[2] = result[n - 3] = result[n - 2] = result[n - 1] = '8';\n        return result;\n    }\n\n    string handleCaseSix(int n) {\n        if (n == 1) return \"6\";\n        if (n == 2) return \"66\";\n        if (n == 3) return \"888\";\n        string result(n, '9');\n        result[0] = result[n - 1] = '8';\n        if (n % 2 == 1) {\n            result[n / 2] = '8';\n        } else {\n            result[n / 2] = result[(n / 2) - 1] = '7';\n        }\n        return result;\n    }\n\n    string handleCaseSeven(int n) {\n        if (n == 1) return \"7\";\n        initializeMemo();\n        buildDynamicProgramming();\n        return constructPalindrome(n);\n    }\n\n    void initializeMemo() {\n        memset(memo, 0, sizeof(memo));\n        memset(memoNonZero, 0, sizeof(memoNonZero));\n        for (int i = 1; i < 10; ++i) {\n            memo[1][i % 7] = '0' + i;\n            if (i != 0) memoNonZero[1][i % 7] = '0' + i;\n        }\n    }\n\n    void buildDynamicProgramming() {\n        int baseMod = 10 % 7;\n        for (int len = 0; len <= 99998; ++len) {\n            for (int mod = 0; mod < 7; ++mod) {\n                if ((len == 0 && mod != 0) || (len > 0 && memo[len][mod] == 0)) continue;\n                for (int digit = 9; digit >= 0; --digit) {\n                    int newMod = (baseMod * digit + digit + mod * 10) % 7;\n                    updateMemo(len + 2, newMod, digit, mod);\n                }\n            }\n            baseMod = (baseMod * 10) % 7;\n        }\n    }\n\n    void updateMemo(int len, int newMod, int digit, int mod) {\n        char digitChar = '0' + digit;\n        if (memo[len][newMod] == 0 || memo[len][newMod] < digitChar) {\n            memo[len][newMod] = digitChar;\n            nextMod[len][newMod] = mod;\n        }\n        if (digit != 0 && (memoNonZero[len][newMod] == 0 || memoNonZero[len][newMod] < digitChar)) {\n            memoNonZero[len][newMod] = digitChar;\n            nextModNonZero[len][newMod] = mod;\n        }\n    }\n\n    string constructPalindrome(int n) {\n        string front(1, memoNonZero[n][0]);\n        string back(1, memoNonZero[n][0]);\n        int mod = nextModNonZero[n][0];\n        n -= 2;\n        while (n > 0) {\n            front += memo[n][mod];\n            if (n > 1) back += memo[n][mod];\n            mod = nextMod[n][mod];\n            n -= 2;\n        }\n        reverse(back.begin(), back.end());\n        return front + back;\n    }\n};",
    "submit_ts": "1723953104",
    "subm_id": "1359812451"
}