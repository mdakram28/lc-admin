{
    "username": "ch365",
    "submission": "#pragma region template\n\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n#include <array>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; --i)\n#define forab(i, a, b) for(int i=(a);i<(b);++i)\n#define fore(v, a) for(auto &v: a)\n#define sqr(x) ((x)*(x))\n#define clr(a, b) memset(a, b, sizeof(a))\n#define sz(a) ((int)a.size())\n#define all(a) (a).begin(),(a).end()\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef map<int,int> mii;\ntypedef map<int,string> mis;\ntypedef map<string,int> msi;\ntemplate <class T> using max_heap = priority_queue<T>;\ntemplate <class T> using min_heap = priority_queue<T, vector<T>, greater<>>;\nconst double eps = 1e-8;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / 2;\nint dcmp(double x) { if (x < -eps) return -1; else return x > eps;}\ntemplate <typename T> bool chmax(T &m, const T q) { return m < q ? (m = q, true) : false; }\ntemplate <typename T> bool chmin(T &m, const T q) { return m > q ? (m = q, true) : false; }\nconstexpr pii dx4[4] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\nconstexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\ntemplate <class T> using vc = vector<T>;\ntemplate <class T> using vvc = vector<vc<T>>;\ntemplate <class T> using vvvc = vector<vvc<T>>;\n#define minall(v) *min_element(all(v))\n#define maxall(v) *max_element(all(v))\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\n#define unq(x) sort(all(x)), x.erase(unique(all(x)), x.end())\nint popcnt(unsigned int x) { return __builtin_popcount(x); }\nint popcntll(unsigned long long x) { return __builtin_popcountll(x); }\ntemplate <class T, class U> ostream& operator<<(ostream& os, const pair<T, U>& p){ return os<<\"(\"<<p.fi<<\",\"<<p.se<<\")\"; }\nvoid see0(){ cout<<endl; }\ntemplate<class H, class ...T> void see0(H && h, T && ...t) { cout<<h<<\",\"; see0(t...); }\n\n#pragma endregion template\n\n#ifdef CHEN_PC\n#include \"lc-struct.h\"\n#define see(...) {cout<<__LINE__<<\": \"<<#__VA_ARGS__<<\" = \";see0(__VA_ARGS__);}\n#define seev(a) {cout<<__LINE__<<\": \"<<#a<<\" = [\"; fore(v, a)cout<<(v)<<\",\"; cout<<\"]\"<<endl;}\n#else\n#define see(...)\n#define seev(...)\n#endif\n\nconst int N = 30010;\nconst int mod = 1000000007; // 10^9+7\n\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n}\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    explicit segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    explicit segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) const {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) const {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() const { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) const {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) const {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) const {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) const {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\n}  // namespace atcoder\n\nusing S=int;\nS e(){return 0;}\nS op(S x,S y){return max(x, y);}\nusing ST = atcoder::segtree<S,op,e>;\n\n\nclass Solution {\npublic:\n\tvector<bool> getResults(vector<vector<int>>& q) {\n\t\tint m = 0;\n\t\tfore (v, q) chmax(m, v[1]);\n\t\tST seg(m+5);\n\t\tvc<bool> ans;\n\t\tmii book;\n\t\tbook[0] = 0;\n\t\tbook[m+1] = m+1;\n\t\tfore (v, q) {\n\t\t\tint t = v[0];\n\t\t\tint x = v[1];\n\t\t\tauto itr = book.lower_bound(x);\n\t\t\tauto pre = prev(itr);\n\t\t\tint x1 = pre->fi;\n\t\t\tint y1 = pre->se;\n\t\t\tint x2 = itr->fi;\n\t\t\tint y2 = itr->se;\n\t\t\tif (t == 1) {\n\t\t\t\tbook[x] = x-x1;\n\t\t\t\tbook[x2] = x2-x;\n\t\t\t\tseg.set(x, x-x1);\n\t\t\t\tseg.set(x2, x2-x);\n\t\t\t} else {\n\t\t\t\tint y = v[2];\n\t\t\t\tif (x - x1 >= y) {\n\t\t\t\t\tans.push_back(true);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint z = seg.prod(0, x1+1);\n\t\t\t\tseev(book);\n\t\t\t\tsee(x,y,z,x1);\n\t\t\t\tif (z >= y) {\n\t\t\t\t\tans.push_back(true);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans.push_back(false);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};",
    "submit_ts": "1716649547",
    "subm_id": "534767046"
}