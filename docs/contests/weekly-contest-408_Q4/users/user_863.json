{
    "username": "hello_wrld",
    "submission": "class Solution {\n    struct Circle {\n        int x, y, r;\n        Circle(int x, int y, int r) : x(x), y(y), r(r) {}\n    };\n\n    void dfs(const vector<std::vector<int>>& graph, int x, unordered_set<int>& visited) {\n        if (visited.count(x)) return;\n\n        visited.insert(x);\n        for (int v : graph[x]) {\n            dfs(graph, v, visited);\n        }\n    }\n\n    bool isPath(vector<Circle>& circles, unordered_set<int>& component, int X, int Y) {\n        int maxY = -1;\n        int minY = Y + 1;\n        int maxX = -1;\n        int minX = X + 1;\n        \n        for (int c : component) {\n            const Circle& circle = circles[c];\n\n            maxY = max(maxY, circle.y + circle.r);\n            maxX = max(maxX, circle.x + circle.r);\n            minY = min(minY, circle.y - circle.r);\n            minX = min(minX, circle.x - circle.r);\n        }\n\n        if (maxY >= Y and minY <= 0) return true;\n        if (maxX >= X and minX <= 0) return true;\n        if (maxY >= Y and maxX >= X) return true;\n        if (minY <= 0 and minX <= 0) return true;\n\n        return false;\n    }\n\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& cs) {\n        vector<Circle> circles;\n\n        for (auto circle: cs) {\n            circles.push_back(Circle(circle[0], circle[1], circle[2]));\n        }\n\n        int n = circles.size();\n        \n        vector<vector<int>> graph(n);\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                int dx = circles[j].x - circles[i].x;\n                int dy = circles[j].y - circles[i].y;\n\n                long long d = 1LL * dx * dx + 1LL * dy * dy;\n                long long span = 1LL * circles[i].r + 1LL * circles[j].r;\n    \n                if (d > span * span) continue;\n\n                graph[i].push_back(j);\n                graph[j].push_back(i);\n            }\n        }\n\n        unordered_set<int> visited;\n\n        for (int i = 0; i < n; ++i) {\n            if (visited.contains(i)) continue;\n\n            unordered_set<int> component;\n            dfs(graph, i, component);\n\n            visited.insert(component.begin(), component.end());\n        \n            if (isPath(circles, component, X, Y)) return false;\n        }\n\n        return true;\n    }\n};",
    "submit_ts": "1722138840",
    "subm_id": "1335801058"
}