{
    "username": "ryanlin118",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        vector<vector<int>> g1 = getGraph(edges1);\n        vector<vector<int>> g2 = getGraph(edges2);\n        int d1 = getDiameter(g1);\n        int d2 = getDiameter(g2);\n        int mx1 = max(d1, d2);\n        return max(mx1, (int)ceil((double)d1/2) + (int)ceil((double)d2/2) + 1);\n    }\n    vector<vector<int>> getGraph(vector<vector<int>> & edges) {\n        vector<vector<int>> graph(edges.size() + 1);\n        for (vector<int>& edge: edges) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n        return graph;\n    }\n    int getDiameter(vector<vector<int>>& graph) {\n        // dfs to find maximum distance leaf node\n        // dfs to find other maximum distance leaf node\n        vector<int> depth1(graph.size());\n        getDepth(0, graph, depth1, 0, -1);\n        int u = findMaxIdx(depth1);\n        vector<int> depth2(graph.size());\n        getDepth(u, graph, depth2, 0, -1);\n        int v = findMaxIdx(depth2);\n        return depth2[v];\n    }\n    void getDepth(int u, vector<vector<int>>& graph, vector<int>& depth, int d, int par) {\n        depth[u] = d;\n        for (int v: graph[u]) {\n            if (v != par) {\n                getDepth(v, graph, depth, d + 1, u);\n            }\n        }\n    }\n    int findMaxIdx(vector<int>& depth) {\n        int max_depth = -1;\n        int max_idx = -1;\n        for (int i = 0; i < depth.size(); i++) {\n            if (depth[i] > max_depth) {\n                max_depth = depth[i];\n                max_idx = i;\n            }\n        }\n        return max_idx;\n    }\n};",
    "submit_ts": 1719719726.0
}