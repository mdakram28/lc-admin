{
    "username": "Albert_Zhang",
    "submission": "\"\"\" === Method 1. use a linked list\n(1) Since there are no interweaving edges, we can \"collapse\" the nodes within edges safely.\n(2) We can use a linked list along with a hash map.\nO(n + q) time | O(n + q) space - where q is the number of queries.  \n\"\"\"\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        minDistances = [1] * len(queries)\n        linkedList = self.createLinkedList(n)\n        for i, (u, v) in enumerate(queries):\n            if i > 0 and minDistances[i - 1] == 1: # already 1\n                break\n            if u in linkedList.valueToNodes and v in linkedList.valueToNodes:\n                linkedList.collapse(linkedList.valueToNodes[u], linkedList.valueToNodes[v])\n            minDistances[i] = linkedList.length - 1\n        return minDistances\n\n    def createLinkedList(self, n):\n        linkedList = DoublyLinkedList()\n        for i in range(n):\n            node = Node(i)\n            linkedList.setTail(node)\n            linkedList.valueToNodes[i] = node\n        return linkedList\n\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\n# Feel free to add new properties and methods to the class.\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.valueToNodes = {}\n        self.length = 0\n\n    ### O(1) time | O(1) space\n    def setHead(self, node):\n        if not self.head: # empty list\n            self.head = node\n            self.tail = node\n        else:\n            self.insertBefore(self.head, node)\n        self.length += 1\n        \n    ### O(1) time | O(1) space\n    def setTail(self, node):\n        if not self.tail: # empty list\n            self.head = node\n            self.tail = node\n        else:\n            self.insertAfter(self.tail, node)    \n        self.length += 1\n\n    def collapse(self, node1, node2):\n        while node1.next is not node2:\n            del self.valueToNodes[node1.next.value]\n            self.remove(node1.next)\n\n    ### O(1) time | O(1) space\n    def insertBefore(self, node, nodeToInsert):\n        isStandAlone = self.getStandAlone(nodeToInsert)\n        if isStandAlone:\n            if not node: # empty list\n                self.head = nodeToInsert\n                self.tail = nodeToInsert\n            elif node == self.head: # insert before the previous head\n                nodeToInsert.next = self.head\n                self.head.prev = nodeToInsert\n                self.head = nodeToInsert\n            else:\n                node.prev.next = nodeToInsert\n                nodeToInsert.prev = node.prev\n                node.prev = nodeToInsert\n                nodeToInsert.next = node\n        else: # the nodeToInsert already exists in the list\n            self.remove(nodeToInsert)\n            self.insertBefore(node, nodeToInsert)\n            \n    ### O(1) time | O(1) space\n    def insertAfter(self, node, nodeToInsert):\n        isStandAlone = self.getStandAlone(nodeToInsert)\n        if isStandAlone:\n            if node == self.tail: # insert after the list tail\n                nodeToInsert.prev = self.tail\n                self.tail.next = nodeToInsert\n                self.tail = nodeToInsert\n            else:\n                node.next.prev = nodeToInsert\n                nodeToInsert.next = node.next\n                node.next = nodeToInsert\n                nodeToInsert.prev = node\n        else: # the nodeToInsert already exists in the list\n            self.remove(nodeToInsert)\n            self.insertAfter(node, nodeToInsert)\n\n    ### O(p) time | O(1) space\n    def insertAtPosition(self, position, nodeToInsert):\n        if self.head == nodeToInsert and position == 1:\n            return\n        count = 1\n        currNode = self.head\n        while currNode and count != position:\n            currNode = currNode.next\n            count += 1\n        if not currNode:\n            self.setTail(nodeToInsert)\n        else:\n            self.insertBefore(currNode, nodeToInsert)\n\n    ### O(n) time | O(1) space\n    def removeNodesWithValue(self, value):\n        currNode = self.head\n        while currNode:\n            if currNode.value == value:\n                temp = currNode.next\n                self.remove(currNode)\n                currNode = temp\n            else:\n                currNode = currNode.next\n\n    ### O(1) time | O(1) space\n    def remove(self, node):\n        if node == self.head:\n            if node.next: # the list have 2 nodes\n                self.head = node.next\n                node.next.prev = None\n                node.next = None\n            else: # a single-node list\n                self.head = None\n                self.tail = None\n        elif node == self.tail:\n            if node.prev: # the list have 2 nodes\n                self.tail = node.prev\n                node.prev.next = None\n                node.prev = None\n            else: # a single-node list (although it should be covered before)\n                self.head = None\n                self.tail = None\n        else:\n            node.prev.next = node.next\n            node.next.prev = node.prev\n            node.next = None\n            node.prev = None\n        self.length -= 1\n\n    ### O(n) time | O(1) space\n    def containsNodeWithValue(self, value):\n        currNode = self.head\n        while currNode:\n            if currNode.value == value:\n                return True\n            currNode = currNode.next\n        return False\n\n    ### O(1) time | O(1) space\n    def getStandAlone(self, node): # determine if a node is a standAlone node\n        if (not node.prev) and (not node.next):\n            return True\n        else:\n            return False",
    "submit_ts": "1722741570",
    "subm_id": "1343748172"
}