{
    "username": "liketheflower",
    "submission": "class FenwickTreeOneBasedIndexing {\npublic:\n    vector<int> bit;  // binary indexed tree\n    int n;\n\n    FenwickTreeOneBasedIndexing(int n) {\n        this->n = n + 1;\n        bit.assign(n + 1, 0);\n    }\n\n    FenwickTreeOneBasedIndexing(vector<int> a)\n    : FenwickTreeOneBasedIndexing(a.size()) {\n        for (size_t i = 0; i < a.size(); i++)\n            add(i, a[i]);\n    }\n\n    int sum(int idx) {\n        int ret = 0;\n        for (++idx; idx > 0; idx -= idx & -idx)\n            ret += bit[idx];\n        return ret;\n    }\n\n    int sum(int l, int r) {\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int idx, int delta) {\n        for (++idx; idx < n; idx += idx & -idx)\n            bit[idx] += delta;\n    }\n};\n\nclass Solution {\npublic:\nvoid check_update(vector<int>&nums, FenwickTreeOneBasedIndexing & ft, int idx, int ii, int val){\n    if (idx == 0 || idx == nums.size() - 1)return;\n\n    bool old_peak = nums[idx] > nums[idx-1] && nums[idx] > nums[idx+1];\n    int cv = ii == idx?val:nums[idx];\n    \n    bool new_peak = cv > (idx - 1 == ii?val: nums[idx-1]) && cv > (idx + 1 == ii?val: nums[idx+1]);\n    if (old_peak == new_peak){\n        return;\n    }\n    if (old_peak && !new_peak){\n        ft.add(idx, -1);\n    } else if (!old_peak && new_peak){\n        ft.add(idx, 1);\n    }\n    return;\n}\nvector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n    vector<int> peaks(nums.size(), 0);\n    for (int i = 1; i < nums.size() - 1; i++) {\n        if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {\n            peaks[i] = 1;\n        }\n    }\n    int n = nums.size();\n    vector<int>ret;\n    //for (auto p: peaks)cout <<p<<\" \";\n    //cout << endl;\n    FenwickTreeOneBasedIndexing ft(peaks);\n    //cout <<\"debug \"<< ft.sum(1, 3)<<endl;\n    int this_ret;\n    for (auto q: queries) {\n        if (q[0] == 1) {\n            if (q[2]-q[1]<=1){\n                this_ret = 0;\n            }else{\n            this_ret = ft.sum(q[1]+1, q[2]-1);\n            \n        }\n        ret.push_back(this_ret);\n    } else {\n            int idx = q[1];\n            int val = q[2];\n            if (idx ==0){\n                // check idx + 1\n                check_update(nums, ft, idx+1, idx, val);\n            } else if (idx == n -1){\n                check_update(nums, ft, idx-1, idx, val);\n            }else {\n                check_update(nums, ft, idx-1, idx, val);\n                check_update(nums, ft, idx, idx, val);\n                check_update(nums, ft, idx+1,idx, val);\n            }\n            nums[idx] = val;\n        }\n    }\n    return ret;\n}\n};\n/*\n[10,7,10]\n[[2,0,1],[2,1,3],[2,0,6]]\n\nLine 1037: Char 34: runtime error: addition of unsigned offset to 0x5020000012b0 overflowed to 0x5020000012ac (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\n*/\n",
    "submit_ts": 1718508332.0
}