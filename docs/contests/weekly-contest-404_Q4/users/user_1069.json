{
    "username": "kunal_mamgain",
    "submission": "class Solution {\npublic:\n    vector<vector<int>> adj;\n    \n    pair<int, int> dfs(int node, int parent) {\n        int far = node;\n        int maxdis = 0;\n        for (int neigh : adj[node]) {\n            if (neigh != parent) {\n                auto [childfar, childdis] = dfs(neigh, node);\n                if (childdis + 1 > maxdis) {\n                    maxdis = childdis + 1;\n                    far = childfar;\n                } \n            }\n        }\n        return {far, maxdis};\n    }\n    \n    int treeDiameter(vector<vector<int>>& edges, int n) {\n        adj.clear();\n        adj.resize(n);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            adj[e[1]].push_back(e[0]);\n        }\n        \n        auto [leaf, _] = dfs(0, -1);\n        auto [temo, dia] = dfs(leaf, -1);\n        \n        return dia;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1, m = edges2.size() + 1;\n        \n        int dia1 = treeDiameter(edges1, n);\n        int dia2 = treeDiameter(edges2, m);\n        \n        int rad1 = (dia1 + 1) / 2;\n        int rad2 = (dia2 + 1) / 2;\n        \n        return max(max(dia1, dia2), rad1 + rad2 + 1);\n    }\n};",
    "submit_ts": "1719717582",
    "subm_id": "1304395393"
}