{
    "username": "king0203",
    "submission": "class Solution {\npublic:\n    vector<vector<int>>f;\n    vector<vector<int>>s;\n    vector<int> depth1; \n    vector<int> depth2;\n    vector<int> ans1; \n    vector<int> ans2;\n\n    void calDepth(int node, int par, vector<vector<int>>& adj, vector<int>& depth) {\n        int currLen = 0;    \n        for (auto ch : adj[node]) {\n            if (ch != par) {\n                calDepth(ch, node, adj, depth);\n                currLen = max(currLen, 1 + depth[ch]);\n            }\n        }\n        depth[node] = currLen;\n    }\n\n    void solve(int node, int par, int part_ans, vector<vector<int>>& adj, vector<int>& depth, vector<int>& ans) {\n        vector<int> prefixMax, suffixMax;\n        for (auto ch : adj[node]) {\n            if (ch != par) {\n                prefixMax.push_back(depth[ch]);\n                suffixMax.push_back(depth[ch]);\n            }\n        }\n        for (int i = 1; i < prefixMax.size(); i++) {\n            prefixMax[i] = max(prefixMax[i-1], prefixMax[i]);\n        }\n        for (int i = suffixMax.size() - 2; i >= 0; i--) {\n            suffixMax[i] = max(suffixMax[i+1], suffixMax[i]);\n        }\n\n        int ind = 0;\n        for (auto ch : adj[node]) {\n            if (ch == par) continue;\n            int leftmax = (ind == 0) ? INT_MIN : prefixMax[ind-1];\n            int rightmax = (ind == suffixMax.size() - 1) ? INT_MIN : suffixMax[ind+1];\n            int partial_ans = 1 + max(part_ans, max(leftmax, rightmax));\n\n            solve(ch, node, partial_ans, adj, depth, ans);\n            ind++;\n        }\n\n        ans[node] = 1 + max(part_ans, (prefixMax.empty() ? -1 : prefixMax.back()));\n    }\n\n    void processTree(vector<vector<int>>& edges, vector<vector<int>>& adj, vector<int>& depth, vector<int>& ans) {\n        int n = edges.size() + 1;\n        adj.resize(n);\n        depth.resize(n, 0);\n        ans.resize(n, 0);\n\n        for (auto& a : edges) {\n            int x = a[0], y = a[1];\n            adj[x].push_back(y);\n            adj[y].push_back(x);\n        }\n\n        calDepth(0, -1, adj, depth);\n        solve(0, -1, -1, adj, depth, ans);\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        processTree(edges1, f, depth1, ans1);\n        processTree(edges2, s, depth2, ans2);\n        sort(ans1.begin(), ans1.end());\n        sort(ans2.begin(), ans2.end());\n        int len1=ans1.size();\n        int len2=ans2.size();\n        int tempans1=ans1[len1-1];\n        int tempans2=ans2[len2-1];\n        int tempans3=ans1[0]+ans2[0]+1;\n        return max(tempans3, max(tempans2, tempans1));\n    }\n};",
    "submit_ts": "1719717780",
    "subm_id": "1304400567"
}