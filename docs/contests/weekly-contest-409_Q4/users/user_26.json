{
    "username": "penguinhacker",
    "submission": "template<class T> struct BIT { //try to always use long long\n\tvector<T> bit;\n    int n;\n\tBIT(int n): n(n) {\n\t\tbit.resize(n + 1);\n\t}\n\tvoid upd(int i, T val) {\n\t\tfor (++i; i <= n; i += i & -i)\n\t\t\tbit[i] += val;\n\t}\n\tT qry(int i) {T res = 0;\n\t\tfor (++i; i > 0; i -= i & -i)\n\t\t\tres += bit[i];\n\t\treturn res;\n\t}\n\tT qry(int l, int r) {\n\t\treturn qry(r) - qry(l - 1);\n\t}\n};\n\ntemplate<class T> struct BIT_range { //try to always use long long\n    BIT<T> b0, b1;\n    int n;\n    BIT_range(int n): n(n), b0(n), b1(n) {\n    }\n\tvoid upd(int l, int r, T val) {\n\t\tb0.upd(l, -(l - 1) * val);\n\t\tb0.upd(r + 1, r * val);\n\t\tb1.upd(l, val);\n\t\tb1.upd(r + 1, -val);\n\t}\n\tT prefix(int i) {\n\t\treturn i * b1.qry(i) + b0.qry(i);\n\t}\n\tT qry(int l, int r) {\n\t\treturn prefix(r) - prefix(l - 1);\n\t}\n};\n\nclass Solution {\npublic:\n    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {\n        BIT_range<int> ft(colors.size() + 2);\n        map<int, int> mp;\n        int cur=0;\n        for (int i=0; i<colors.size(); ++i)  {\n            if (i&&colors[i]!=(colors[i-1]^1)) {\n                mp[i-cur]=cur;\n                ft.upd(1, cur, 1);\n                cur=0;\n            }\n            cur++;\n        }\n        mp[colors.size()-cur]=cur;\n        // mp[-1]=0;\n        ft.upd(1, cur, 1);\n        vector<int> ans;\n        for (auto x : queries) {\n            // for (auto y: mp) {\n            //     cout << y.first << \" \" << y.second << \"\\n\";\n            // }\n            // cout << \"\\n\\n\";\n            if (x[0]==1) {\n                if (mp.size()==1) {\n                    ans.push_back(colors.size()%2?ft.qry(x[1], colors.size()):colors.size());\n                } else {\n                    if (colors.back()!=colors[0]) {\n                        int a=mp.begin()->second;\n                        int b=mp.rbegin()->second;\n                        ft.upd(1, a, -1);\n                        ft.upd(1, b, -1);\n                        ft.upd(1, a+b, 1);\n                    }\n                    ans.push_back(ft.qry(x[1], colors.size()));\n                    if (colors.back()!=colors[0]) {\n                        int a=mp.begin()->second;\n                        int b=mp.rbegin()->second;\n                        ft.upd(1, a, 1);\n                        ft.upd(1, b, 1);\n                        ft.upd(1, a+b, -1);\n                    }\n                }\n            } else {\n                int i=x[1], c=x[2];\n                if (colors[i]==c)\n                    continue;\n                colors[i]=c;\n                int before = colors[(i+colors.size()-1)%colors.size()];\n                int after = colors[(i+1)%colors.size()];\n                auto it = prev(mp.upper_bound(i));\n                if (it->first==i) {\n                    if (it->second==1) {\n                        if (next(it)!=mp.end()) {\n                            ft.upd(1, next(it)->second, -1);\n                            ft.upd(1, it->second, -1);\n                            it->second+=next(it)->second;\n                            ft.upd(1, it->second, 1);\n                            mp.erase(next(it));\n                        }\n                        if (it!=mp.begin()) {\n                            it=prev(it);\n                            ft.upd(1, next(it)->second, -1);\n                            ft.upd(1, it->second, -1);\n                            it->second+=next(it)->second;\n                            ft.upd(1, it->second, 1);\n                            mp.erase(next(it));\n                        }\n                    } else {\n                        if (it!=mp.begin()) {\n                            ft.upd(1, prev(it)->second, -1);\n                            ft.upd(1, 1, -1);\n                            ++(prev(it)->second);\n                            ft.upd(1, prev(it)->second, 1);\n                            int ss = it->second;\n                            mp.erase(it);\n                            mp[i+1]=ss-1;\n                            ft.upd(1, ss, -1);\n                            ft.upd(1, ss-1, 1);\n                        } else {\n                            ft.upd(1, 1, 1);\n                            int ss = it->second;\n                            mp[0]=1;\n                            mp[i+1]=ss-1;\n                            ft.upd(1, ss, -1);\n                            ft.upd(1, ss-1, 1);\n                        }\n                    }\n                } else {\n                    int pos=it->first;\n                    int ss=it->second;\n                    it->second = i-pos;\n                    ft.upd(1, ss, -1);\n                    ft.upd(1, it->second, 1);\n                    \n                    if (i!=pos+ss-1) { // in the middle\n                        mp[i]=1;\n                        ft.upd(1, 1, 1);\n                        mp[i+1]=ss-it->second-1;\n                        ft.upd(1, mp[i+1], 1);\n                    } else if (i==colors.size()-1) {\n                        mp[i]=1;\n                        ft.upd(1, 1, 1);\n                    } else {\n                        int sss=next(it)->second;\n                        ft.upd(1, sss, -1);\n                        ft.upd(1, sss+1, 1);\n                        mp[i]=sss+1;\n                        mp.erase(i+1);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722742172",
    "subm_id": "1343762710"
}