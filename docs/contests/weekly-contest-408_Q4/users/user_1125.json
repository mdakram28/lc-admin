{
    "username": "Harshit5837",
    "submission": "class Solution {\npublic:\n    bool canReachCorner(int l, int m, vector<vector<int>>& n) {\n        int o = n.size(); // Number of obstacles\n        vector<vector<int>> p(o + 4); // Graph to represent connections\n\n        // Build the graph based on circles and rectangle borders\n        for (int q = 0; q < o; ++q) {\n            int r = n[q][0], s = n[q][1], t = n[q][2];\n\n            // Check if the circle touches the left border of the rectangle\n            if (r <= t) {\n                p[o].push_back(q);\n                p[q].push_back(o);\n            }\n\n            // Check if the circle touches the right border of the rectangle\n            if (l - r <= t) {\n                p[o + 2].push_back(q);\n                p[q].push_back(o + 2);\n            }\n\n            // Check if the circle touches the bottom border of the rectangle\n            if (s <= t) {\n                p[o + 1].push_back(q);\n                p[q].push_back(o + 1);\n            }\n\n            // Check if the circle touches the top border of the rectangle\n            if (m - s <= t) {\n                p[o + 3].push_back(q);\n                p[q].push_back(o + 3);\n            }\n\n            // Check if the circles overlap each other\n            int u = q + 1;\n            while (u < o) {\n                int v = n[u][0], w = n[u][1], x = n[u][2];\n                double y = sqrt(pow(r - v, 2) + pow(s - w, 2));\n                if (t + x >= y) {\n                    p[q].push_back(u);\n                    p[u].push_back(q);\n                }\n                ++u;\n            }\n        }\n\n        // Check for connectivity from bottom-left to any other side\n        if (bfs(p, o, o + 1, o + 2, o + 4)) \n            return false; // If path exists from left to bottom or right, return false\n\n        // Check for connectivity from top-right to any other side\n        if (bfs(p, o + 3, o + 2, o + 1, o + 4)) \n            return false; // If path exists from right to top or bottom, return false\n\n        return true; // If no blocking paths found, return true\n    }\n\nprivate:\n    // Perform BFS to check if there's a path from the startNode to either targetNode1 or targetNode2\n    bool bfs(vector<vector<int>>& p, int start, int target1, int target2, int totalNodes) {\n        queue<int> q; // Queue for BFS\n        vector<bool> visited(totalNodes, false); // Visited array to track visited nodes\n        q.push(start); // Start BFS from the start node\n        visited[start] = true;\n\n        // Continue until the queue is empty\n        while (!q.empty()) {\n            int current = q.front(); // Get the current node\n            q.pop(); // Remove the current node from the queue\n            for (int neighbor : p[current]) { // Iterate through all adjacent nodes\n                if (!visited[neighbor]) { // If the adjacent node is not visited\n                    q.push(neighbor); // Add it to the queue\n                    visited[neighbor] = true; // Mark it as visited\n                }\n            }\n        }\n\n        // Return true if either targetNode1 or targetNode2 is visited\n        return visited[target1] || visited[target2];\n    }\n};\n",
    "submit_ts": "1722139111",
    "subm_id": "1335808163"
}