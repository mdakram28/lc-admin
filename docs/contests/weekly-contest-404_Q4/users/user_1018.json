{
    "username": "bleedin_maroon",
    "submission": "class Solution {\npublic:\n    void findDownPath(int src, int par, vector<vector<int>>& adj, vector<int>& dp){\n        int bc = 0;\n        bool leaf = 1;\n        for(auto it: adj[src]){\n            if(it == par) continue;\n            leaf = 0;\n            findDownPath(it, src, adj, dp);\n            bc = max(bc, dp[it]);\n        }\n        if(leaf) dp[src] = 0;\n        else dp[src] = 1 + bc;\n    }\n \n    void solve(int src, int par, vector<vector<int>>& adj, vector<int>& dp, vector<int>& dia, vector<int>& depth, int par_ans){\n        depth[src] = max(dp[src], par_ans);\n        multiset<int> st;\n        for(auto it: adj[src]){\n            if(it == par) continue;\n            st.insert(dp[it]);\n        }\n        int ans = 0;\n        vector<int> cdp;\n        for(auto it: adj[src]){\n            if(it == par) continue;\n            st.erase(st.find(dp[it]));\n            int new_depth = st.size() ? (*st.rbegin() + 2) : 1;\n            solve(it, src, adj, dp, dia, depth, max(new_depth, par_ans + 1));\n            st.insert(dp[it]);\n            cdp.push_back(dp[it]);\n            ans = max(ans, dia[it]);\n        }\n        int n = cdp.size();\n        sort(cdp.rbegin(), cdp.rend());\n        if(n == 0) dia[src] = 0;\n        else if(n == 1) dia[src] = 1 + cdp[0];\n        else dia[src] = 2 + cdp[0] + cdp[1];\n        dia[src] = max(dia[src], ans);\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size();\n        vector<vector<int>> adj1(n+1);\n        int m = edges2.size();\n        vector<vector<int>> adj2(m+1);\n        for(auto &i: edges1){\n            adj1[i[0]].push_back(i[1]);\n            adj1[i[1]].push_back(i[0]);\n        }\n        for(auto &i: edges2){\n            adj2[i[0]].push_back(i[1]);\n            adj2[i[1]].push_back(i[0]);\n        }\n        vector<int> dp1(n+1), dia1(n+1), depth1(n+1);\n        findDownPath(0, -1, adj1, dp1);\n        solve(0, -1, adj1, dp1, dia1, depth1, 0);\n        vector<int> dp2(m+1), dia2(m+1), depth2(m+1);\n        findDownPath(0, -1, adj2, dp2);\n        solve(0, -1, adj2, dp2, dia2, depth2, 0);\n        int maxi = max(dia1[0], dia2[0]);\n        int min1 = *min_element(depth1.begin(), depth1.end());\n        int min2 = *min_element(depth2.begin(), depth2.end());\n        maxi = max(maxi, 1 + min1 + min2);\n        return maxi;\n    }\n};",
    "submit_ts": "1719718739",
    "subm_id": "1304424880"
}