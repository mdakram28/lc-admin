{
    "username": "ajinkya1p3",
    "submission": "class Solution {\nprivate:\n    const int MAX = 50000;\n    int tree[200005], lazy[200005];\n    \n    void lazyProp(int left, int right, int root)\n    {\n        tree[root] = lazy[root];\n        \n        if (left != right)\n        {\n            lazy[root * 2] = lazy[root];\n            lazy[root * 2 + 1] = lazy[root];\n        }\n        \n        lazy[root] = 0;\n    }\n    \n    void update(int left, int right, int L, int R, int val, int root)\n    {\n        if (lazy[root])\n            lazyProp(left, right, root);\n        \n        if (left > R || right < L)\n            return;\n        \n        if (left >= L && right <= R)\n        {\n            tree[root] = val;\n            \n            if (left != right)\n                lazy[root * 2] = lazy[root * 2 + 1] = val;\n            \n            return;\n        }\n        \n        int mid = (left + right) / 2;\n        \n        update(left, mid, L, R, val, root * 2);\n        update(mid + 1, right, L, R, val, root * 2 + 1);\n        \n        tree[root] = max(tree[root * 2], tree[root * 2 + 1]);\n    }\n    \n    int query(int left, int right, int L, int R, int root)\n    {\n        if (lazy[root])\n            lazyProp(left, right, root);\n        \n        if (left > R || right < L)\n            return 0;\n        \n        if (left >= L && right <= R)\n            return tree[root];\n        \n        int mid = (left + right) / 2;\n        \n        return max(query(left, mid, L, R, root * 2), query(mid + 1, right, L, R, root * 2 + 1));\n    }\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        set<int> breakPoints;\n        \n        for (auto q: queries)\n        {\n            int type = q[0];\n            \n            if (type == 1)\n                breakPoints.insert(q[1]);\n        }\n        \n        int prv = 0;\n        \n        for (int b: breakPoints)\n        {\n            update(0, MAX, prv, b - 1, b - prv, 1);\n            prv = b;\n        }\n        \n        breakPoints.insert(0);\n        \n        int q = queries.size();\n        vector<bool> res;\n        \n        for (int i = q - 1; i >= 0; i--)\n        {\n            int type = queries[i][0];\n            int x = queries[i][1];\n            \n            if (type == 1)\n            {\n                auto ptr = breakPoints.find(x);\n                \n                int nxtx = MAX, prevx = -1;\n                \n                ptr++;\n                \n                if (ptr != breakPoints.end())\n                    nxtx = *ptr;\n                \n                ptr--, ptr--;\n                prevx = *ptr;\n                \n                breakPoints.erase(x);\n                update(0, MAX, prevx, nxtx - 1, nxtx - prevx, 1);\n            }\n            else\n            {\n                bool ans = false;\n                int sz = queries[i][2];\n                \n                auto ptr = breakPoints.upper_bound(x);\n                ptr--;\n                \n                int lastBreakPt = *ptr;\n                \n                ans |= (query(0, MAX, 0, lastBreakPt - 1, 1) >= sz);\n                ans |= ((x - lastBreakPt) >= sz);\n                \n                res.push_back(ans);\n            }\n        }\n        \n        reverse(res.begin(), res.end());\n        \n        return res;\n    }\n};",
    "submit_ts": "1716649610",
    "subm_id": "1267592883"
}