{
    "username": "LLIEPJIOK",
    "submission": "class Solution {\npublic:\n    struct Item {\n        long long all;\n        long long left;\n        long long right;\n        long long mid;\n\n        Item() {\n            all = 0;\n            left = 0;\n            right = 0;\n            mid = 0;\n        }\n\n        Item(long long _all, long long _left, long long _right, long long _mid) {\n            all = _all;\n            left = _left;\n            right = _right;\n            mid = _mid;\n        }\n    };\n\n    vector<Item> segment_tree;\n    int n;\n\n    Item get(int cur, int l, int r, int need_l, int need_r) {\n        if (need_r <= need_l) {\n            return Item();\n        }\n        if (r <= need_l || l >= need_r) {\n            return Item();\n        }\n        if (need_l <= l && r <= need_r) {\n            return segment_tree[cur];\n        }\n        int mid = (l + r) / 2;\n        auto first = get(2 * cur, l, mid, need_l, need_r);\n        auto second = get(2 * cur + 1, mid, r, need_l, need_r);\n        Item it;\n        it.all = max(first.right + second.all, first.all + second.left);\n        it.left = max(first.mid + second.all, first.left + second.left);\n        it.right = max(first.right + second.right, first.all + second.mid);\n        it.mid = max(first.left + second.mid, first.mid + second.right);\n        return it;\n    }\n\n    void build(int cur, int l, int r, vector<int>& nums) {\n        if (l + 1 == r) {\n            segment_tree[cur] = Item(nums[l], 0, 0, 0);\n            return;\n        }\n        int mid = (l + r) / 2;\n        build(2 * cur, l, mid, nums);\n        build(2 * cur + 1, mid, r, nums);\n        auto first = segment_tree[2 * cur];\n        auto second = segment_tree[2 * cur + 1];\n        segment_tree[cur].all = max(first.right + second.all, first.all + second.left);\n        segment_tree[cur].left = max(first.mid + second.all, first.left + second.left);\n        segment_tree[cur].right = max(first.right + second.right, first.all + second.mid);\n        segment_tree[cur].mid = max(first.left + second.mid, first.mid + second.right);\n    }   \n\n    void update(int cur, int l, int r, int need_l, int need_r, vector<int>& nums) {\n        if (r <= need_l || l >= need_r) {\n            return;\n        }\n        if (l + 1 == r) {\n            segment_tree[cur] = Item(nums[l], 0, 0, 0);\n            return;\n        }\n        int mid = (l + r) / 2;\n        update(2 * cur, l, mid, need_l, need_r, nums);\n        update(2 * cur + 1, mid, r, need_l, need_r, nums);\n        auto first = segment_tree[2 * cur];\n        auto second = segment_tree[2 * cur + 1];\n        segment_tree[cur].all = max(first.right + second.all, first.all + second.left);\n        segment_tree[cur].left = max(first.mid + second.all, first.left + second.left);\n        segment_tree[cur].right = max(first.right + second.right, first.all + second.mid);\n        segment_tree[cur].mid = max(first.left + second.mid, first.mid + second.right);\n    }\n\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        segment_tree.resize(4 * nums.size());\n        n = nums.size();\n        build(1, 0, n, nums);\n        long long ans = 0;\n        int mod = 1e9 + 7;\n        for (auto& i : queries) {\n            nums[i[0]] = i[1];\n            update(1, 0, n, i[0], i[0] + 1, nums);\n            ans = ans + max(0ll, get(1, 0, n, 0, n).all);\n        }\n        return ans % mod;\n    }\n};",
    "submit_ts": 1716694716.0
}