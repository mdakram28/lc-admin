{
    "username": "ceaxyz",
    "submission": "from sortedcontainers import SortedList\n\nclass Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        num_points = len(points)\n        transformed = [[0] * num_points for _ in range(4)]\n        sorted_indices = [[0] * num_points for _ in range(4)]\n\n        # Transform the points and initialize sorted indices\n        for i in range(num_points):\n            transformed[0][i] = points[i][0] + points[i][1]\n            transformed[1][i] = -points[i][0] + points[i][1]\n            transformed[2][i] = points[i][0] - points[i][1]\n            transformed[3][i] = -points[i][0] - points[i][1]\n            for j in range(4):\n                sorted_indices[j][i] = i\n\n        # Sort indices based on transformed points\n        for i in range(4):\n            sorted_indices[i].sort(key=lambda idx: transformed[i][idx])\n\n        min_distance = float('inf')\n\n        # Calculate the minimum of the maximum distances after removing a point\n        for i in range(4):\n            for drop in range(2):  # Check for dropping the first or last index\n                dropped_index = sorted_indices[i][drop * (num_points - 1)]\n                max_distance = 0\n                \n                # Calculate the maximum distance for each transformation\n                for j in range(4):\n                    if j == i:\n                        continue\n\n                    first_index, last_index = sorted_indices[j][0], sorted_indices[j][-1]\n                    if first_index == dropped_index:\n                        first_index = sorted_indices[j][1]\n                    if last_index == dropped_index:\n                        last_index = sorted_indices[j][-2]\n                    max_distance = max(max_distance, transformed[j][last_index] - transformed[j][first_index])\n\n                min_distance = min(min_distance, max_distance)\n\n        return min_distance"
}