{
    "username": "Maillew",
    "submission": "\ntypedef long long ll;\n\ntypedef long double ld;\ntypedef pair<int,int> pii;\nbool DEBUG = 1;\n#define log2(x) ((x==0)? 0:63 - __builtin_clzll(x))\n#define pb push_back\n#define ms(x, y) memset(x, y, sizeof x)\n#define popcount __builtin_popcount\n#define all(v) v.begin(), v.end()\n\nconst int inf=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3f;\ninline ll gcd(ll a, ll b) {return b == 0 ? a : gcd(b, a % b);}\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b;}\n\n#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename... Args>\nvoid logger(string vals, Args &&...values){\n    if (DEBUG){\n        cout << vals << \" = \";\n        string delim = \"\";\n        (..., (cout << delim << values, delim = \", \"));\n        cout << endl;\n    }\n}\n\n//cant compile == MLE\n//assert ideas with ur slow, to find out why ur fast WA\n//make sure to fully actuate your ideas before coding it up; spend more time on samples and examples\n//cant do ms on doubles\n//be more thoughtful and careful in impl; work on one shot ac -> this means be more thoughtful and careful in impl\n\n/*\n    *int overflow, array bounds\n    *special/edge cases n=1, n=0,\n    *reread when stuck -> couldve missed small detail\n    *write stuff down\n    *take it slow and read\n    *if WA, reread\n*/\n\n/*\n    STRATEGIES:\n    Invariants, Binary Search, SQRT distinct, Surprise Graph\n    Characteristics of the optimal solution\n    Recall - Specific to General - Guess - Think like a problem - Pick a Method - Print Out and Look\n*/\n\n// SUNK COST FALLACY\n// WRITE STUFF DOWN - SAMPLES AND EXAMPLES - GO SLOW - DONT TUNNEL VISION - DONT SPAM SUB\n\nconst ll mod = 1e9+7;\nstruct tri{\n    ll x,y,z;\n    bool operator<(const tri &one)const{\n        if(x==one.x) return y<one.y;\n        return x<one.x;\n    }//pqs are backwards\n};\nll fpow(ll a, ll b){\n    if (b == 0) return 1;\n    ll res = fpow(a, b / 2)%mod;\n    if (b % 2) return ((res * res)%mod * a) %mod;\n    else return (res * res) %mod;\n}\nconst int maxn = 40;\nll fact[maxn];\nll inv[maxn];\n\nbool fr = false;\nvoid init(){\n    if(fr) return;\n    fact[0] = 1;\n    inv[0] = 1;\n    for(int i =1; i<maxn; i++){\n        fact[i] = (fact[i-1]*i)%mod;\n        inv[i] = fpow(fact[i],mod-2);\n    }\n    fr = true;\n}\nll choose(int _n, int _k){\n    return (((fact[_n]*inv[_k])%mod)*inv[_n-_k])%mod;\n}\nll permute(int _n, int _k){\n    return ((fact[_n]*inv[_n-_k])%mod);\n}\n\nll calc(int n, int k){\n    ll dp[n+10][k+10][2]; ms(dp,0); //1 we are a 1\n    dp[0][0][0] = 1;\n    for(int i = 1; i<=n; i++){\n        dp[i][0][0] = 1;\n        for(int j =1; j<=k; j++){\n            dp[i][j][1] = dp[i-1][j-1][0]; //insert a 1, prev has to be a 0\n            dp[i][j][0] = dp[i-1][j][0] + dp[i-1][j][1];//insert a 0, prev can be either\n        }\n    }\n    return dp[n][k][0] + dp[n][k][1];//end in 0 or 1\n}\nclass Solution {\npublic:\n    ll waysToReachStair(int k) {\n        ll ans =0;\n        for(int jumps = 0; jumps<30; jumps++){//num  of jumps\n            int pos = (1<<(jumps))-1;\n            if(pos+1>=k){\n                int j = pos-k+1;\n                if(j<=jumps+1){\n                    ans+=calc(jumps+j,j);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1716087898",
    "subm_id": "1261797798"
}