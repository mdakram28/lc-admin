{
    "username": "user3744L",
    "submission": "class Solution {\npublic:\n    void dfs(int node, int parent, vector<vector<int>>& adj, int& maxDist, int& farthestNode, int dist) {\n        if (dist > maxDist) {\n            maxDist = dist;\n            farthestNode = node;\n        }\n        for (int neighbor : adj[node]) {\n            if (neighbor != parent) {\n                dfs(neighbor, node, adj, maxDist, farthestNode, dist + 1);\n            }\n        }\n    }\n\n    // Function to calculate the diameter of the tree\n    int treeDiameter(vector<vector<int>>& edges, int n) {\n        if (n == 0) return 0;\n\n        // Build the adjacency list\n        vector<vector<int>> adj(n);\n        for (auto& edge : edges) {\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n\n        // Perform the first DFS to find the farthest node from node 0\n        int maxDist = 0;\n        int farthestNode = 0;\n        dfs(0, -1, adj, maxDist, farthestNode, 0);\n\n        // Perform the second DFS from the farthest node found in the first DFS\n        maxDist = 0;\n        dfs(farthestNode, -1, adj, maxDist, farthestNode, 0);\n\n        return maxDist;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int m = edges1.size() + 1, n = edges2.size() + 1;\n        int ans1 = treeDiameter(edges1, m);\n        int ans2 = treeDiameter(edges2, n);\n\n        return max({ans1, ans2, 1 + (int)(ceil(ans1/2.0) + ceil(ans2/2.0))});\n    }\n};",
    "submit_ts": 1719715099.0
}