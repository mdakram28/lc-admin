{
    "username": "l_returns",
    "submission": "const int INF = 1e9; // Adjust for your specific maximum value\n\nstruct Node {\n    int value, lazy;\n\n    Node(int val = 0, int laz = 0) : value(val), lazy(laz) {}\n};\n\nclass LazySegmentTree {\nprivate:\n    vector<Node> tree;\n    int n;\n\n    void build(int node, int start, int end, const vector<int>& arr) {\n        if (start == end) {\n            tree[node].value = arr[start];\n            return;\n        }\n\n        int mid = start + (end - start) / 2;\n        build(2 * node, start, mid, arr);\n        build(2 * node + 1, mid + 1, end, arr);\n\n        tree[node].value = max(tree[2 * node].value, tree[2 * node + 1].value);\n    }\n\n    void propagate(int node) {\n        if (tree[node].lazy != 0) {\n            tree[2 * node].value -= tree[node].lazy;\n            tree[2 * node + 1].value -= tree[node].lazy;\n            tree[2 * node].lazy += tree[node].lazy;\n            tree[2 * node + 1].lazy += tree[node].lazy;\n            tree[node].lazy = 0;\n        }\n    }\n\n    void update(int node, int start, int end, int l, int r, int val) {\n        if (start > r || end < l) {\n            return;\n        }\n\n        if (start >= l && end <= r) {\n            tree[node].value -= val;\n            tree[node].lazy += val;\n            return;\n        }\n\n        propagate(node); // Propagate lazy updates before processing children\n\n        int mid = start + (end - start) / 2;\n        update(2 * node, start, mid, l, r, val);\n        update(2 * node + 1, mid + 1, end, l, r, val);\n\n        tree[node].value = max(tree[2 * node].value, tree[2 * node + 1].value);\n    }\n\n    int query(int node, int start, int end, int l, int r) {\n        if (start > r || end < l) {\n            return -INF; // Adjust based on your minimum value\n        }\n\n        if (start >= l && end <= r) {\n            return tree[node].value;\n        }\n\n        propagate(node); // Propagate lazy updates before querying children\n\n        int mid = start + (end - start) / 2;\n        int leftMax = query(2 * node, start, mid, l, r);\n        int rightMax = query(2 * node + 1, mid + 1, end, l, r);\n\n        return max(leftMax, rightMax);\n    }\n\npublic:\n    LazySegmentTree(const vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n); // Allocate 4 times the array size\n        build(1, 0, n - 1, arr);\n    }\n\n    void updateRange(int left, int right, int value) {\n        update(1, 0, n - 1, left, right, value);\n    }\n\n    int queryMax(int left, int right) {\n        return query(1, 0, n - 1, left, right);\n    }\n};\n\n\nclass Solution {\n    \n    \npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector<int> v;\n        for(int i=0;i<=50000;i++)\n            v.push_back(i);\n        LazySegmentTree seg(v);\n        set<int> st;\n        vector<bool> ans;\n        for(auto qr:queries) {\n            if(qr[0]==1) {\n                int l = qr[1]+1;\n                int r = 50000;\n                \n                auto it = st.lower_bound(qr[1]);\n                st.insert(qr[1]);\n                if(it != st.end())\n                    r = (*it);\n                int val = seg.queryMax(l-1,l-1);\n                seg.updateRange(l,r,val);\n                continue;\n            }\n            ans.push_back(seg.queryMax(0,qr[1])>=qr[2]);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1716649283",
    "subm_id": "1267583344"
}