{
    "username": "dgeyfman",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def min_max_dist(edges):\n            n=len(edges)+1\n            tree = {i : set() for i in range(n)}\n            for u,v in edges:\n                tree[u].add(v)\n                tree[v].add(u)\n            adj = defaultdict(list)\n            for u, v in edges:\n                adj[u].append(v)\n                adj[v].append(u)\n            \n            leaves = [i for i in range(n) if len(tree[i]) <= 1]\n\n            while n > 2:\n                n -= len(leaves)\n                newLeaves = []\n                for leaf in leaves:\n                    neighbor = tree[leaf].pop()\n                    tree[neighbor].remove(leaf)\n                    if len(tree[neighbor]) == 1:\n                        newLeaves.append(neighbor)\n                leaves = newLeaves\n            def bfs(start):\n                dist = {start: 0}\n                queue = deque([start])\n                farthest = start\n                while queue:\n                    node = queue.popleft()\n                    #print(node)\n                    for nxt in adj[node]:\n                        if nxt not in dist:\n                            dist[nxt] = dist[node] + 1\n                            queue.append(nxt)\n                            farthest = nxt\n                return dist[farthest]\n            #print(\"aaa\")\n            return bfs(leaves[0])\n        \n        def tree_diam(edges):\n            if len(edges)==0:\n                return 0\n\n            adj = defaultdict(list)\n            for u, v in edges:\n                adj[u].append(v)\n                adj[v].append(u)\n\n            def bfs(start):\n                dist = {start: 0}\n                queue = deque([start])\n                farthest = start\n                while queue:\n                    node = queue.popleft()\n                    for nxt in adj[node]:\n                        if nxt not in dist:\n                            dist[nxt] = dist[node] + 1\n                            queue.append(nxt)\n                            farthest = nxt\n                return farthest, dist[farthest]\n\n            st = edges[0][0]\n            farthest, _ = bfs(st)\n            other_farthest, d = bfs(farthest)\n\n            return d\n        \n\n        e1 = min_max_dist(edges1)\n        e2 = min_max_dist(edges2)\n        #print(e1)\n        #print(e2)\n        #print(tree_diam(edges1))\n        #print(tree_diam(edges2))\n        return max(e1+e2+1,tree_diam(edges1),tree_diam(edges2))\n        ",
    "submit_ts": 1719716843.0
}