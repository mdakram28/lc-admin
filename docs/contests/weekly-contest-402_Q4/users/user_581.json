{
    "username": "trigerrr",
    "submission": "class Solution {\npublic:\n    #define ll long long\n    template<class T, class U>\n    struct Lsegtree{\n        vector<T>st;\n        vector<U>lazy;\n        ll n;\n        T identity_element;\n        U identity_update;\n        Lsegtree(ll n, T identity_element, U identity_update)\n        {\n            this->n = n;\n            this->identity_element = identity_element;\n            this->identity_update = identity_update;\n            st.assign(4*n,identity_element);\n            lazy.assign(4*n, identity_update);\n        }\n        T combine(T l, T r)\n        {\n            T ans = (l + r);\n            return ans;\n        }\n        void buildUtil(ll v, ll tl, ll tr, vector<T>&a)\n        {\n            if(tl == tr)\n            {\n                st[v] = a[tl];\n                return;\n            }\n            ll tm = (tl + tr)>>1;\n            buildUtil(2*v + 1, tl, tm,a);\n            buildUtil(2*v + 2,tm+1,tr,a);\n            st[v] = combine(st[2*v + 1], st[2*v + 2]);\n        }\n        // change the following 2 functions, and you're more or less done.\n        T apply(T curr, U upd, ll tl, ll tr)\n        {\n            T ans = (tr-tl+1)*upd;\n            return ans;\n        }\n        U combineUpdate(U old_upd, U new_upd, ll tl, ll tr)\n        {\n            U ans = old_upd;\n            ans=new_upd;\n            return ans;\n        }  \n        void push_down(ll v, ll tl, ll tr)\n        {\n            if(lazy[v] == identity_update)return;\n            st[v] = apply(st[v], lazy[v], tl, tr);\n            if(2*v + 2 < 4*n)\n            {\n                ll tm = (tl + tr)>>1;\n                lazy[2*v + 1] = combineUpdate(lazy[2*v+1], lazy[v], tl, tm);\n                lazy[2*v + 2] = combineUpdate(lazy[2*v+2], lazy[v], tm+1,tr);            \n            }\n            lazy[v] = identity_update;\n        }\n        T queryUtil(ll v, ll tl, ll tr, ll l, ll r)\n        {\n            push_down(v,tl,tr);\n            if(l > r)return identity_element;\n            if(tr < l or tl > r)\n            {\n                return identity_element;\n            }\n            if(l <= tl and r >= tr)\n            {\n                return st[v];\n            }\n            ll tm = (tl + tr)>>1;\n            return combine(queryUtil(2*v+1,tl,tm,l,r), queryUtil(2*v+2,tm+1,tr,l,r));\n        }\n\n        void updateUtil(ll v, ll tl, ll tr, ll l, ll r, U upd)\n        {\n            push_down(v,tl,tr); \n            if(tr < l or tl > r)return;\n            if(tl >=l and tr <=r)\n            {\n                lazy[v] = combineUpdate(lazy[v],upd,tl,tr);\n                push_down(v,tl,tr);\n            }\n            else\n            {\n                ll tm = (tl + tr)>>1;\n                updateUtil(2*v+1,tl,tm,l,r,upd);\n                updateUtil(2*v+2,tm+1,tr,l,r,upd);\n                st[v] = combine(st[2*v + 1], st[2*v+2]);\n            }\n        }\n\n\n\n        void build(vector<T>a)\n        {\n            assert(sz(a) == n);\n            buildUtil(0,0,n-1,a);\n        }\n        T query(ll l, ll r)\n        {\n            return queryUtil(0,0,n-1,l,r);\n        }\n        void update(ll l,ll r, U upd)\n        {\n            updateUtil(0,0,n-1,l,r,upd);\n        }\n    };\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = (nums).size();\n        vector<int> ans;\n        Lsegtree<int,int> s(n,0,-1);\n        for(int i = 1; i < n-1; i++){\n            if(nums[i] > nums[i-1] && nums[i] > nums[i+1]) s.update(i,i,1);\n            else s.update(i,i,0);\n        }\n        auto upd = [&](int x){\n            if(x > 0 && x < n-1){\n                if(nums[x] > nums[x-1] && nums[x] > nums[x+1]) s.update(x,x,1);\n                else s.update(x,x,0);\n            }\n        };\n        for(auto q : queries){\n            int t = q[0], x = q[1], y = q[2];\n            if(t == 1){\n                x++, y--;\n                if(y < x) ans.push_back(0);\n                else ans.push_back(s.query(x,y));\n            }\n            else{\n                nums[x] = y;\n                for(int i =  x-1;i <= x+1; i++){\n                    upd(i);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1718507975",
    "subm_id": "1289668102"
}