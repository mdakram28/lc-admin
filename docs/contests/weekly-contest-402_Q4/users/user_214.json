{
    "username": "fsyun",
    "submission": "class Solution {\n    class STNode {\n        STNode left, right;\n        int from, to, mid, sum;\n        STNode(int from, int to) {\n            this.from = from;\n            this.to = to;\n            mid = from + (to - from) / 2;\n            sum = 0;\n            left = null;\n            right = null;\n        }\n        void add(int p) {\n            if (from != to) {\n                if (p <= mid) {\n                    if (left == null)\n                        left = new STNode(from, mid);\n                    left.add(p);\n                } else {\n                    if (right == null)\n                        right = new STNode(mid + 1, to);\n                    right.add(p);\n                }\n                sum = (left == null ? 0 : left.sum) + (right == null ? 0 : right.sum);\n            } else\n                sum = 1;\n        }\n        void remove(int p) {\n            if (from != to) {\n                if (p <= mid) {\n                    if (left == null)\n                        left = new STNode(from, mid);\n                    left.remove(p);\n                } else {\n                    if (right == null)\n                        right = new STNode(mid + 1, to);\n                    right.remove(p);\n                }\n                sum = (left == null ? 0 : left.sum) + (right == null ? 0 : right.sum);\n            } else\n                sum = 0;\n        }\n        int getSum(int p, int q) {\n            if (p == from && q == to)\n                return sum;\n            if (q <= mid)\n                return left == null ? 0 : left.getSum(p, q);\n            else if (p > mid)\n                return right == null ? 0 : right.getSum(p, q);\n            else {\n                int a = left == null ? 0 : left.getSum(p, mid);\n                int b = right == null ? 0 : right.getSum(mid + 1, q);\n                return a + b;\n            }\n        }\n    }\n    boolean peak(int[] nums, int p) {\n        if (p == 0 || p == nums.length - 1)\n            return false;\n        return nums[p] > nums[p - 1] && nums[p] > nums[p + 1];\n    }\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        int n = nums.length;\n        STNode root = new STNode(0, n - 1);\n        for (int i = 0; i < n; i++)\n            if (peak(nums, i)) {\n                root.add(i);\n            }\n        List<Integer> l = new LinkedList<>();\n        for (int[] q : queries) {\n            if (q[0] == 1) {\n                int a = q[1], b = q[2], res = b - a < 2 ? 0 : root.getSum(a + 1, b - 1);\n                l.addLast(res);\n            } else {\n                int idx = q[1], val = q[2];\n                nums[idx] = val;\n                for (int pos = idx - 1; pos <= idx + 1; pos++)\n                    if (pos >= 0 && pos < n) {\n                        if (peak(nums, pos)) {\n                            root.add(pos);\n                        } else {\n                            root.remove(pos);\n                        }\n                    }\n            }\n        }\n        return l;\n    }\n}",
    "submit_ts": 1718507100.0
}