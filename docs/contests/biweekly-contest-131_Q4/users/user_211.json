{
    "username": "non_deterministic",
    "submission": "#define lld long long\n#define rep(i,a,n) for(lld i = (a); i <= (n); ++i)\n#define repI(i,a,n) for(int i = (a); i <= (n); ++i)\n#define repD(i,a,n) for(lld i = (a); i >= (n); --i)\n#define repDI(i,a,n) for(int i = (a); i >= (n); --i)\n#define all(c) (c).begin(), (c).end()\n#define sz(a) ((int)a.size())\n\n#define Error(x...) { cout << \"(\" << #x << \")\" << \" = ( \"; printIt(x); }\ntemplate <typename T1> void printIt(T1 t1) { cout << t1 << \" )\" << endl; }\ntemplate <typename T1, typename... T2>\nvoid printIt(T1 t1, T2... t2) { cout << t1 << \" , \"; printIt(t2...); }\n#define errorpair(a) cout<<#a<<\" = ( \"<<((a).first)<<\" , \"<<((a).second)<<\" )\\n\";\n\n\n\nint A[(int)1e5 + 20];\n\n// Segment Tree Class\n// call buildTree() please, intentionally not inside the constructor\n// change\n// - treeNode default function for initialization without doing anything\n// - buildNode for initialization, building stage\n// - operator+ for merging\n// - applyToNode for updating value, on modify queries\ntemplate<typename StoreType>\nstruct SegmentTreeTemplate {\n    using updateType = StoreType;\n    struct treeNode{\n        StoreType maxConsectiveOne, leftConsectiveOne, rightConsectiveOne, sum;\n        treeNode() {\n            maxConsectiveOne = leftConsectiveOne = rightConsectiveOne = sum = 0;\n        }\n        treeNode operator+(const treeNode& rhs) const {\n            treeNode res;\n            if(maxConsectiveOne == sum) res.leftConsectiveOne = maxConsectiveOne + rhs.leftConsectiveOne;\n            else res.leftConsectiveOne = leftConsectiveOne;\n            if(rhs.maxConsectiveOne == rhs.sum) res.rightConsectiveOne = rhs.maxConsectiveOne + rightConsectiveOne;\n            else res.rightConsectiveOne = rhs.rightConsectiveOne;\n            res.maxConsectiveOne = max(max(maxConsectiveOne, rhs.maxConsectiveOne), rightConsectiveOne + rhs.leftConsectiveOne);\n            res.sum = sum + rhs.sum;\n            // Error(leftConsectiveOne, rightConsectiveOne, maxConsectiveOne, sum);\n            // Error(rhs.leftConsectiveOne, rhs.rightConsectiveOne, rhs.maxConsectiveOne, rhs.sum);\n            // Error(res.leftConsectiveOne, res.rightConsectiveOne, res.maxConsectiveOne, res.sum);\n            return res;\n        }\n        void buildNode(StoreType val) {\n            maxConsectiveOne = leftConsectiveOne = rightConsectiveOne = sum = val;\n            sum = 1;\n        }\n        void applyToNode(updateType val) {\n            maxConsectiveOne = leftConsectiveOne = rightConsectiveOne = sum = val;\n            sum = 1;\n        }\n    };\n\n    vector<treeNode> M;\n    int n;\n    StoreType* A;\n    SegmentTreeTemplate(int n, StoreType TempA[]) : n(n) {\n        M.resize((n << 2) + 5);\n        A = TempA;\n    }\n    void buildTree(int st, int end, int ind){\n        if(st == end){\n            M[ind].buildNode(A[st]);\n            return ;\n        }\n        int mid, a, b;\n        mid = st+(end-st)/2;\n        a = (ind << 1) + 1;\n        b = (ind << 1) + 2;\n        buildTree(st, mid, a);\n        buildTree(mid + 1, end, b);\n        M[ind] = M[a] + M[b];\n    }\n\n    void updateTree(int st, int end, int ind, int updateInd, updateType val){\n        if(st == updateInd && end == updateInd){\n            M[ind].applyToNode(val);\n            return ;\n        }\n        int mid, a, b;\n        mid = st + (end-st)/2;\n        a = (ind << 1) + 1;\n        b = (ind << 1) + 2;\n        if(updateInd <= mid) updateTree(st, mid, a, updateInd, val);\n        else updateTree(mid + 1, end, b, updateInd, val);\n        M[ind] = M[a] + M[b];\n    }\n    treeNode queryTree(int st, int end, int ind, int l, int r){\n        if(st == l && end == r) return M[ind];\n        int mid;\n        mid = st+(end-st)/2;\n        if(r <= mid) return queryTree(st, mid, (ind << 1) + 1, l, r);\n        if(l > mid) return queryTree(mid + 1, end, (ind << 1) + 2, l, r);\n        treeNode p1 = queryTree(st, mid, (ind << 1) + 1, l, mid);\n        treeNode p2 = queryTree(mid + 1, end, (ind << 1) + 2, mid + 1, r);\n        return p1 + p2;\n    }\n    // int findFirstOneTree(int st, int end, int ind, int l, int r) {\n    //     if(st == end and l == r) return l;\n    //     int mid;\n    //     mid = st + (end - st) / 2;\n    //     if(r <= mid) return findFirstOneTree(st, mid, (ind << 1) + 1, l, r);\n    //     if(l > mid) return findFirstOneTree(mid + 1, end, (ind << 1) + 2, l, r);\n    //     treeNode p1 = queryTree(st, mid, (ind << 1) + 1, l, mid);\n    //     if(p1.sum > 0) return findFirstOneTree(st, mid, (ind << 1) + 1, l, mid);\n    //     return findFirstOneTree(mid + 1, end, (ind << 1) + 2, mid + 1, r);\n    // }\n    void build() {\n        buildTree(0, n - 1, 0);\n    }\n    void update(int updateInd, updateType val) {\n        updateTree(0, n - 1, 0, updateInd, val);\n    }\n    treeNode query(int l, int r) {\n        if(l > r) return treeNode();\n        return queryTree(0, n - 1, 0, l, r);\n    }\n    // int findFirstOne(int l, int r) {\n    //     return findFirstOneTree(0, n - 1, 0, l, r);\n    // }\n};\n\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int limit = 5e4 + 10;\n        repI(i, 0, limit - 1) A[i] = 1;\n        SegmentTreeTemplate<int> segTree(limit, A);\n        segTree.build();\n        vector<bool> ans;\n        for(auto& q : queries) {\n            if(q[0] == 1) {\n                int pos = q[1];\n                // Error(\"block\", pos);\n                segTree.update(pos, 0);\n            }\n            else {\n                int pos = q[1], sz = q[2];\n                // Error(pos, sz);\n                auto res = segTree.query(1, pos - 1);\n                // Error(res.maxConsectiveOne);\n                if(res.maxConsectiveOne + 1 >= sz && pos >= sz) ans.push_back(true);\n                else ans.push_back(false);\n            }\n        }\n        return ans;\n    }\n};\n",
    "submit_ts": 1716650528.0
}