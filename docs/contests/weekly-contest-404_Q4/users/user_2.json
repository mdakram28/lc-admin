{
    "username": "arignote",
    "submission": "class Solution {\n\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int x = treeDiameter(edges1), y = treeDiameter(edges2);\n        return Math.max(x, Math.max(y, (x + 1) / 2 + (y + 1) / 2 + 1));\n    }\n\n    private Map<Integer, Set<Integer>> g;\n    private boolean[] vis;\n    private int next;\n    private int ans;\n\n    public int treeDiameter(int[][] edges) {\n        int n = edges.length;\n        if (n == 0) {\n            return 0;\n        }\n        ans = 0;\n        g = new HashMap<>();\n        for (int[] e : edges) {\n            g.computeIfAbsent(e[0], k -> new HashSet<>()).add(e[1]);\n            g.computeIfAbsent(e[1], k -> new HashSet<>()).add(e[0]);\n        }\n        vis = new boolean[n + 1];\n        next = edges[0][0];\n        dfs(next, 0);\n        vis = new boolean[n + 1];\n        dfs(next, 0);\n        return ans;\n    }\n\n    private void dfs(int u, int t) {\n        if (vis[u]) {\n            return;\n        }\n        vis[u] = true;\n        if (ans < t) {\n            ans = t;\n            next = u;\n        }\n        for (int v : g.get(u)) {\n            dfs(v, t + 1);\n        }\n    }\n}",
    "submit_ts": 1719715344.0
}