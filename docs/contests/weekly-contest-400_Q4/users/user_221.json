{
    "username": "NULLgorithm",
    "submission": "#define ll long long\n\nstruct node{\n    //what to store??\n    ll val;\n};\n\nstruct segtree{\n    int size;\n    vector<node> values;\n\n    //When nothing\n    node NEUTRAL_ELEMENT={(1LL<<32)-1LL};\n\n    node merge(node a, node b){\n        //merge function\n        return {a.val&b.val};\n    }\n\n    node single(int v){\n        //leaf node\n        return {1LL*v};\n    }\n\n    void init(int n){\n        size=1;\n        while(size<n) size*=2;\n        values.resize(2*size);\n    }\n\n    void build(vector<int>& a, int x, int lx, int rx){\n        if(rx-lx==1){\n            if(lx<(int)a.size()){\n                values[x]=single(a[lx]);\n            }\n            return;\n        }\n        int mid=(lx+rx)/2;\n        build(a, 2*x+1, lx, mid);\n        build(a, 2*x+2, mid, rx);\n        values[x]=merge(values[2*x+1], values[2*x+2]);\n    }\n\n    void build(vector<int>& a){\n        build(a, 0, 0, size);\n    }\n\n    void set(int i, int v, int x, int lx, int rx){\n        if(rx-lx==1){\n            values[x]=single(v);\n            return;\n        }\n        int mid=(lx+rx)/2;\n        if(i<mid){\n            set(i, v, 2*x+1, lx, mid);\n        }\n        else{\n            set(i, v, 2*x+2, mid, rx);\n        }\n        values[x]=merge(values[2*x+1], values[2*x+2]);\n    }\n\n    void set(int i, int v){\n        set(i, v, 0, 0, size);\n    }\n\n    node calc(int l, int r, int x, int lx, int rx){\n        if(lx>=r|| l>=rx) return NEUTRAL_ELEMENT;\n        if(lx>=l && rx<=r) return values[x];\n        int mid=(lx+rx)/2;\n        node left_calc=calc(l, r, 2*x+1, lx, mid);\n        node right_calc=calc(l, r, 2*x+2, mid, rx);\n        return merge(left_calc, right_calc);\n    }\n\n    node calc(int l, int r){\n        return calc(l, r, 0, 0, size);\n    }\n\n    //use sum implementation\n    int kth_one(int k, int x, int lx, int rx){\n        if(rx-lx==1) return lx;\n        int mid=(lx+rx)/2;\n        if(values[2*x+1].val>k){\n            return kth_one(k, 2*x+1, lx, mid);\n        }else{\n            return kth_one(k-values[2*x+1].val, 2*x+2, mid, rx);\n        }\n    }\n\n    int kth_one(int k){\n        return kth_one(k, 0, 0, size);\n    }\n};\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        segtree st;\n        int n=nums.size();\n        st.init(n);\n        st.build(nums);\n        int ans=1e9;\n        for(int i=0;i<n;i++){\n            int l=i+1, r=n;\n            while(r-l>1){\n                int mid=(l+r)/2;\n                int q=(int)(st.calc(i,mid).val);\n                if(q<k){\n                    r=mid;\n                }else{\n                    l=mid;\n                }\n            }\n            if(l!=i-1){\n                ans=min(ans, abs((int)(st.calc(i,l).val)-k));\n            }\n            ans=min(ans, abs(k-(int)(st.calc(i,r).val)));\n        }\n        return ans;\n        \n    }\n};",
    "submit_ts": "1717298176",
    "subm_id": "1274770075"
}