{
    "username": "sammochen",
    "submission": "\n#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef DEBUG\n#include \"debug.h\"\n#else\n#define debug(...) 1\n#endif\n\nusing ll = long long;\nusing db = long double;\nusing VS = vector<string>;\nusing VLL = vector<ll>;\nusing VVLL = vector<VLL>;\nusing VVVLL = vector<VVLL>;\nusing PLL = pair<ll, ll>;\nusing MLL = map<ll, ll>;\nusing SLL = set<ll>;\nusing QLL = queue<ll>;\nusing SS = stringstream;\n\n#define rep(x, l, u) for (ll x = l; x < u; x++)\n#define rrep(x, l, u) for (ll x = l; x >= u; x--)\n#define fe(x, a) for (auto x : a)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define mst(x, v) memset(x, v, sizeof(x))\n#define sz(x) (ll) x.size()\n\n#define umap unordered_map\n#define uset unordered_set\n#define mset multiset\n\n// clang-format off\n\nll ob(ll i, ll n) { return i < 0 || i >= n; }\nll tp(ll x) { return ( 1LL << x ); }\nll rup(ll a, ll b) { return a % b ? a/b + 1 : a/b; }\nll sign(ll x) {\treturn x == 0 ? 0 : x / abs(x); }\nvoid makemod(ll& x, ll m) { x %= m; if (x < 0) { x += m; } }\nll getmod(ll x, ll m) { makemod(x, m); return x; }\nll powmod(ll a, ll b, ll m) { if (b == 0) return 1; ll h = powmod(a, b/2, m); ll ans = h*h%m; return b%2 ? ans*a%m : ans; }\nll invmod(ll a, ll m) { return powmod(a, m - 2, m); }\nvoid inll(ll& x) { scanf(\"%lld\", &x); }\n\ntemplate <typename A, typename B> bool upmin(A& x, B v) { if (v >= x) return false; return x = v, true; }\ntemplate <typename A, typename B> bool upmax(A& x, B v) { if (v <= x) return false; return x = v, true; }\n// clang-format on\n\nconst VLL di = {0, 0, 1, -1, 1, -1, 1, -1}, dj = {1, -1, 0, 0, -1, -1, 1, 1};\nconst ll inf = 1e18;\nconst ll mod = 1e9 + 7;\nconst string vowels = \"aeiou\";\nll isvowel(char c) {\n    c = tolower(c);\n    return vowels.find(c) != string::npos;\n}\n\nll farthestDist = -1;\nll farthestNode = -1;\n\nvoid dfs(ll at, ll prev, ll dist, VVLL& E) {\n    if (prev == -1) {\n        // reset\n        farthestDist = -1;\n        farthestNode = -1;\n    }\n\n    if (dist > farthestDist) {\n        farthestDist = dist;\n        farthestNode = at;\n    }\n\n    for (auto to : E[at]) {\n        if (to == prev) continue;\n        dfs(to, at, dist + 1, E);\n    }\n}\n\nll diameter(vector<vector<int>>& edges) {\n    ll n = edges.size() + 1;\n    VVLL E(n);\n    for (auto& e : edges) {\n        E[e[0]].push_back(e[1]);\n        E[e[1]].push_back(e[0]);\n    }\n\n    dfs(0, -1, 0, E);\n    dfs(farthestNode, -1, 0, E);\n\n    // then you find the parent\n\n    return farthestDist;\n}\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {  // !\n        auto cands1 = diameter(edges1);\n        auto cands2 = diameter(edges2);\n\n        ll ans = rup(cands1, 2) + rup(cands2, 2) + 1;\n        upmax(ans, cands1);\n        upmax(ans, cands2);\n        return ans;\n    }\n};\n",
    "submit_ts": 1719716735.0
}