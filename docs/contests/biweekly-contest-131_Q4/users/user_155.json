{
    "username": "winter_dragon",
    "submission": "class SegTree {\npublic:\n    SegTree(int N) {\n        H = 0;\n        while ((1 << H) <= N) H++;\n        tree.resize(2 << H);\n        _left.resize(2 << H);\n        _right.resize(2 << H);\n        for (int x = 0;x < (1 << H); x++) {\n            int pos = treePos(H, x);\n            tree[pos] = 0;\n            _left[pos] = _right[pos] = x;\n        }\n        for (int h = H - 1;h >= 0; h--) {\n            for (int x = 0;x < (1 << h); x++) {\n                int pos = treePos(h, x);\n                tree[pos] = 0;\n                int pos1 = 2 * pos + 1;\n                _left[pos] = _left[pos1];\n                _right[pos] = _right[pos1 + 1];\n            }\n        }\n    }\n    \n    void set(int x, int v) {\n        int pos = treePos(H, x);\n        tree[pos] = v;\n        for (int h = H - 1;h >= 0; h--) {\n            pos = (pos - 1) / 2;\n            tree[pos] = max(tree[2 * pos + 1], tree[2 * pos + 2]);\n        }\n    }\n    \n    int upto(int x) {\n        // max(a[0] ... a[x])\n        int ret = 0, pos = 0;\n        for (int h = 0;h < H; h++) {\n            int lft = _left[pos];\n            int rgt = _right[pos];\n            int count = rgt - lft + 1;\n            if (rgt <= x) {\n                ret = max(ret, tree[pos]);\n                return ret;\n            }\n            int half = count / 2;\n            if (x < lft + half) {\n                pos = 2 * pos + 1;\n            } else {\n                ret = max(ret, tree[2 * pos + 1]);\n                pos = 2 * pos + 2;\n            }\n        }\n        ret = max(ret, tree[pos]);\n        return ret;\n    }\n\nprivate:\n    int H;\n    vector<int> tree, _left, _right;\n    \n    inline int treePos(int h, int x) {\n        int offset = (1 << h) - 1;\n        return x + offset;\n    }\n};\n\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        const int MAXX = 200001;\n        SegTree segTree(100010);\n        vector<bool> ret;\n        set<int> obstacles;\n        obstacles.insert(0);\n        obstacles.insert(100005);\n        segTree.set(0, 100005);\n        for (auto& qry: queries) {\n            int t = qry[0];\n            if (t == 1) {\n                int x = qry[1], lft_x = -1, rgt_x = -1;\n                auto it = obstacles.lower_bound(x);\n                if (it != obstacles.begin()) {\n                    it--;\n                    lft_x = *it;\n                    it++;\n                }\n                rgt_x = *it;\n                // lft_x <-> rgt_x was the previous gap\n                segTree.set(lft_x, x - lft_x);\n                segTree.set(x, rgt_x - x);\n                obstacles.insert(x);\n            } else {\n                int x = qry[1], sz = qry[2];\n                if (x >= sz) {\n                    int n = x - sz;\n                    int best = segTree.upto(n);\n                    ret.push_back(best >= sz);\n                } else {\n                    ret.push_back(false);\n                }\n            }\n        }\n        \n        return ret;\n    }\n};",
    "submit_ts": "1716650534",
    "subm_id": "1267618079"
}