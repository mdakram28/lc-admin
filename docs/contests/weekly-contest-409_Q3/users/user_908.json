{
    "username": "didwhddks",
    "submission": "constexpr int inf = 2E5;\n\ntemplate <typename T>\nstruct Fenwick {\n\tint n;\n\tvector<T> a;\n\n\tFenwick(int n = 0) {\n\t\tinit(n);\n\t}\n\n\tvoid init(int n) {\n\t\tthis->n = n;\n\t\ta.assign(n + 1, T());\n\t}\n\n\tvoid add(int i, T val) {\n\t\tfor (++i; i <= n; i += i & -i) {\n\t\t\ta[i] += val;\n\t\t}\n\t}\n\n\tT query(int i) {\n\t\tT res = T();\n\t\tfor (++i; i; i -= i & -i) {\n\t\t\tres += a[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tT rangeSum(int L, int R) {\n\t\tif (L > R) {\n\t\t\treturn T();\n\t\t}\n\t\treturn query(R) - query(L - 1);\n\t}\n};\n\ntemplate <typename Info>\nstruct SegmentTree {\n    int n;\n    vector<Info> info;\n \n    SegmentTree(int n = 0) {\n        init(n);\n    }\n \n    void init(int n) {\n        this->n = n;\n        info.assign(4 * n, Info());\n    }\n \n    void pull(int i) {\n        info[i] = info[2 * i] + info[2 * i + 1];\n    }\n \n    void set(int idx, Info _info, int i, int L, int R) {\n        if (L == R) {\n            info[i] = _info;\n            return;\n        }\n        int mid = (L + R) / 2;\n        if (idx <= mid) {\n            set(idx, _info, 2 * i, L, mid);\n        } else {\n            set(idx, _info, 2 * i + 1, mid + 1, R);\n        }\n        pull(i);\n    }\n\n    void set(int idx, Info _info) {\n        set(idx, _info, 1, 0, n - 1);\n    }\n \n    Info rangeQuery(int qL, int qR, int i, int L, int R) {\n        if (R < qL || qR < L) {\n            return Info();\n        }\n        if (qL <= L && R <= qR) {\n            return info[i];\n        }\n        int mid = (L + R) / 2;\n        Info a = rangeQuery(qL, qR, 2 * i, L, mid);\n        Info b = rangeQuery(qL, qR, 2 * i + 1, mid + 1, R);\n        return a + b;\n    }\n\n    Info rangeQuery(int qL, int qR) {\n        return rangeQuery(qL, qR, 1, 0, n - 1);\n    }\n};\n\nstruct Info {\n    int mn;\n    Info(int x = inf) {\n        mn = x;\n    }\n    Info operator+(const Info& b) {\n        Info c;\n        c.mn = min(mn, b.mn);\n        return c;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& Q) {\n        vector adj(n, vector<int>());\n        for (int i = 0; i < n; ++i) {\n            adj[i].push_back(i + 1);\n        }\n        \n        const int q = Q.size();\n        Fenwick<int> fen(n);\n        SegmentTree<Info> seg(n);\n        \n        vector<int> ans(q);\n        map<int, vector<int>> f;\n        for (int i = 0; i < q; ++i) {\n            int u = Q[i][0];\n            int v = Q[i][1];\n            int mn = seg.rangeQuery(v, n - 1).mn;\n            if (mn <= u) {\n                ans[i] = n - 1 - fen.rangeSum(0, n - 1);\n                continue;\n            }\n            // cout << i << \"\\n\";\n            if (fen.rangeSum(v, v) < v - u - 1) {\n                auto l = f.lower_bound(u);\n                vector<int> r;\n                while (l != f.end() && l->first < v) {\n                    for (auto x : l->second) {\n                        fen.add(x, -fen.rangeSum(x, x));\n                        seg.set(x, inf);\n                    }\n                    r.push_back(l->first);\n                    l = next(l);\n                }\n                for (auto x : r) {\n                    f.erase(x);\n                }\n                fen.add(v, -fen.rangeSum(v, v));\n                fen.add(v, v - u - 1);\n                f[u].push_back(v);\n                seg.set(v, u);\n            }\n            ans[i] = n - 1 - fen.rangeSum(0, n - 1);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722743502",
    "subm_id": "1343793370"
}