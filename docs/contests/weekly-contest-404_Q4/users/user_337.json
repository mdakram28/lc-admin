{
    "username": "Samuel3Shin",
    "submission": "class Solution {\npublic:\n    \n     pair<int, int> bfs2(int start, unordered_map<int, vector<int>>& graph) {\n        queue<pair<int, int>> q;\n        q.push({start, 0});\n        unordered_set<int> visited;\n        visited.insert(start);\n\n        int farthest_node = start;\n        int max_distance = 0;\n        while (!q.empty()) {\n            int node = q.front().first;\n            int distance = q.front().second;\n            q.pop();\n\n            if (distance > max_distance) {\n                max_distance = distance;\n                farthest_node = node;\n            }\n\n            for (int neighbor : graph[node]) {\n                if (visited.find(neighbor) == visited.end()) {\n                    visited.insert(neighbor);\n                    q.push({neighbor, distance + 1});\n                }\n            }\n        }\n\n        return {farthest_node, max_distance};\n    }\n    \n    int longestDiameter(vector<vector<int>>& edges) {\n        if (edges.empty()) return 0;\n\n        unordered_map<int, vector<int>> graph;\n        for (const auto& edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n\n        pair<int, int> first_bfs_result = bfs2(0, graph);\n        pair<int, int> second_bfs_result = bfs2(first_bfs_result.first, graph);\n\n        return second_bfs_result.second;\n    }\n    \n    int bfs(int start, unordered_map<int, vector<int>>& graph) {\n        queue<pair<int, int>> q;\n        q.push({start, 0});\n        unordered_set<int> visited;\n        visited.insert(start);\n\n        int max_distance = 0;\n        while (!q.empty()) {\n            int node = q.front().first;\n            int distance = q.front().second;\n            q.pop();\n            max_distance = max(max_distance, distance);\n\n            for (int neighbor : graph[node]) {\n                if (visited.find(neighbor) == visited.end()) {\n                    visited.insert(neighbor);\n                    q.push({neighbor, distance + 1});\n                }\n            }\n        }\n\n        return max_distance;\n    }\n    \n    int minimumDiameter(vector<vector<int>>& edges) {\n        if (edges.empty()) return 0;\n\n        unordered_map<int, vector<int>> graph;\n        unordered_map<int, vector<int>> graph2;\n        \n        for (const auto& edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n            \n            graph2[edge[0]].push_back(edge[1]);\n            graph2[edge[1]].push_back(edge[0]);\n        }\n\n        vector<int> leaves;\n        for (const auto& node : graph) {\n            if (node.second.size() == 1) {\n                leaves.push_back(node.first);\n            }\n        }\n\n        int remaining_nodes = graph.size();\n        while (remaining_nodes > 2) {\n            remaining_nodes -= leaves.size();\n            vector<int> new_leaves;\n            for (int leaf : leaves) {\n                for (int neighbor : graph[leaf]) {\n                    graph[neighbor].erase(remove(graph[neighbor].begin(), graph[neighbor].end(), leaf), graph[neighbor].end());\n                    if (graph[neighbor].size() == 1) {\n                        new_leaves.push_back(neighbor);\n                    }\n                }\n            }\n            leaves = new_leaves;\n        }\n\n        int diameter = INT_MAX;\n        for (int center : leaves) {\n            // cout << center << \" \";\n            // int dist = bfs(center, graph2);\n            // cout << dist << endl;\n            diameter = min(diameter, bfs(center, graph2));\n        }\n        // cout << endl;\n        // cout << diameter;\n\n        return diameter;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        \n//         unordered_map<int, vector<int>> graph;\n//         for (const auto& edge : edges1) {\n//             graph[edge[0]].push_back(edge[1]);\n//             graph[edge[1]].push_back(edge[0]);\n//         }\n        \n//         // cout << bfs(0, graph) << endl;\n        \n//         unordered_map<int, vector<int>> graph2;\n//         for (const auto& edge : edges2) {\n//             graph2[edge[0]].push_back(edge[1]);\n//             graph2[edge[1]].push_back(edge[0]);\n//         }\n        \n        // cout << bfs(0, graph2) << endl;\n        \n        int cand1 = minimumDiameter(edges1);\n        int cand2 = minimumDiameter(edges2);\n        \n        int cand3 = longestDiameter(edges1);\n        int cand4 = longestDiameter(edges2);\n        \n        int cand = max(cand3, cand4);\n        // cout << cand1 << \" \" << cand2 << endl;\n        \n        return max(cand1 + cand2 + 1, cand);   \n        // return 0;\n    }\n};",
    "submit_ts": "1719718575",
    "subm_id": "1304420715"
}