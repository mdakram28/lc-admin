{
    "username": "U_U",
    "submission": "class Solution {\npublic:\n    int retMaxDist;\n    int maxDepth, selfDist1, selfDist2;\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        \n        vector<int> nodes1 = findMinHeightTrees(n, edges1);\n        selfDist1 = maxDepth;\n        int dist1 = retMaxDist;\n        if (nodes1.size() > 1) dist1++;\n            \n        vector<int> nodes2 = findMinHeightTrees(m, edges2);\n        selfDist2 = maxDepth;\n        int dist2 = retMaxDist;\n        if (nodes2.size() > 1) dist2++;\n        \n        int temp = 0;        \n        if (n > 0 && m > 0)        \n        {\n            temp = dist1 + dist2 + 1;    \n        }\n        else if (n > 0)\n        {\n            temp = dist1;\n        }\n        else\n        {\n            temp = dist2;\n        }        \n        \n        \n        return max(max(selfDist1, selfDist2), temp);\n    }\n    \n    \n    int DFS(int u, int p, vector< vector<int> >& adj, int depth)\n    {\n       maxDepth = max(maxDepth, depth);         \n       int retMax = 0;\n       int retSecondMax = 0;\n       set<int> dict;\n       for (auto& v : adj[u]) \n       {\n           if (v == p) continue;\n           int next = DFS(v, u, adj, depth + 1);\n           if (next > retMax)\n           {\n               retSecondMax = retMax;\n               retMax = next;\n           }\n           else if (next > retSecondMax)\n           {\n               retSecondMax = next;\n           }           \n           dict.insert(next);\n       }\n        if (retMax > 0 && retSecondMax > 0) maxDepth = max(maxDepth, retMax + retSecondMax);\n                \n       return retMax + 1;\n    }\n    \n    \n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        \n         \n        \n        vector< vector<int> > adj;\n        vector<int> degree(n, 0);\n        adj.assign(n, vector<int>());\n        for (auto& e : edges)\n        {\n            adj[e[0]].push_back(e[1]);\n            adj[e[1]].push_back(e[0]);\n            degree[e[0]]++;\n            degree[e[1]]++;\n        }\n        \n        maxDepth = 0;\n        DFS(0, -1, adj, 0);\n      //  cout << maxDepth << endl;\n\n        deque<int> Q;\n        for (int u = 0; u < n; ++u)\n        {\n            if (degree[u] == 1) \n            {\n                degree[u] = 0;\n                Q.push_back(u);\n            }\n        }\n\n        int maxVal = 0;\n        vector<int> dist(n, 0);\n        while (Q.size() > 0)\n        {\n            int u = Q.front();\n            Q.pop_front();\n            for (auto& v : adj[u])\n            {\n                degree[v]--;\n                if (degree[v] == 1)\n                {\n                    dist[v] = dist[u] + 1;\n                    maxVal = max(maxVal, dist[v]);\n                    Q.push_back(v);\n                    degree[v] = 0;\n                }\n            }\n        }        \n\n        vector<int> res;\n        for (int u = 0; u < dist.size(); ++u)\n        {\n            if (dist[u] == maxVal) res.push_back(u);\n        }\n        retMaxDist = maxVal;\n        return res;\n    }\n};",
    "submit_ts": "1719717781",
    "subm_id": "1304400587"
}