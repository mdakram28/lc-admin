{
    "username": "cklzzz",
    "submission": "type SegmentNode struct {\n    Left, Right *SegmentNode\n    L, R int\n    Val int\n}\n\nfunc buildSegmentTree(nums []int, l, r int) *SegmentNode {\n    if l > r {\n        return nil\n    }\n    if l == r {\n        var val int\n        if l > 0 && l < len(nums)-1 && nums[l] > nums[l-1] && nums[l] > nums[l+1] {\n            val = 1\n        }\n        return &SegmentNode{\n            L: l,\n            R: r,\n            Val: val,\n        }\n    }\n    mid := (l+r) / 2\n    left, right := buildSegmentTree(nums, l, mid), buildSegmentTree(nums, mid+1, r)\n    var val int\n    if left != nil {\n        val += left.Val\n    }\n    if right != nil {\n        val += right.Val\n    }\n    return &SegmentNode{\n        Left: left,\n        Right: right,\n        L: l,\n        R: r,\n        Val: val,\n    }\n}\n\nfunc (node *SegmentNode) Search(l, r int) int {\n    if node == nil {\n        return 0\n    }\n    if node.L == l && node.R == r {\n        return node.Val\n    }\n    mid := (node.L + node.R) / 2\n    if r <= mid {\n        return node.Left.Search(l, r)\n    }\n    if l >= mid+1 {\n        return node.Right.Search(l, r)\n    }\n    return node.Left.Search(l, mid) + node.Right.Search(mid+1, r)\n}\n\nfunc (node *SegmentNode) Change(p, c int) {\n    if node == nil {\n        return\n    }\n    node.Val += c\n    if node.L == p && node.R == p {\n        return\n    }\n    mid := (node.L + node.R) / 2\n    if p <= mid {\n        node.Left.Change(p, c)\n    } else {\n        node.Right.Change(p, c)\n    }\n}\n\nfunc countOfPeaks(nums []int, queries [][]int) []int {\n    root := buildSegmentTree(nums, 0, len(nums)-1)\n    var ans []int\n    for _, q := range queries {\n        if q[0] == 1 {\n            v := root.Search(q[1], q[2])\n            if q[1] > 0 && q[1] < len(nums)-1 && nums[q[1]] > nums[q[1]-1] && nums[q[1]] > nums[q[1]+1] {\n                v--\n            }\n            if q[1] != q[2] && q[2] > 0 && q[2] < len(nums)-1 && nums[q[2]] > nums[q[2]-1] && nums[q[2]] > nums[q[2]+1] {\n                v--\n            }\n            ans = append(ans, v)\n        } else {\n            var c int\n            p := q[1]\n            if p > 1 && nums[p-1] > nums[p-2] && nums[p-1] > nums[p] && nums[p-1] <= q[2] {\n                c = -1\n            }\n            if p > 1 && nums[p-1] > nums[p-2] && nums[p-1] <= nums[p] && nums[p-1] > q[2] {\n                c = 1\n            }\n            if c != 0 {\n                root.Change(p-1, c)\n            }\n            c = 0\n            if p < len(nums)-2 && nums[p+1] > nums[p+2] && nums[p+1] > nums[p] && nums[p+1] <= q[2] {\n                c = -1\n            }\n            if p < len(nums)-2 && nums[p+1] > nums[p+2] && nums[p+1] <= nums[p] && nums[p+1] > q[2] {\n                c = 1\n            }\n            if c != 0 {\n                root.Change(p+1, c)\n            }\n            c = 0\n            if p > 0 && p < len(nums)-1 && nums[p] > nums[p-1] && nums[p] > nums[p+1] && !(q[2] > nums[p-1] && q[2] > nums[p+1]) {\n                c = -1\n            }\n            if p > 0 && p < len(nums)-1 && !(nums[p] > nums[p-1] && nums[p] > nums[p+1]) && q[2] > nums[p-1] && q[2] > nums[p+1] {\n                c = 1\n            }\n            if c != 0 {\n                root.Change(p, c)\n            }\n            nums[p] = q[2]\n        }\n    }\n    return ans\n}",
    "submit_ts": 1718508501.0
}