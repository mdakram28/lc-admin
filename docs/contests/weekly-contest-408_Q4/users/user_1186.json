{
    "username": "madhurgyani",
    "submission": "class Solution {\npublic:\nconst int LEFT = -1;\nconst int RIGHT = -2;\nconst int BOTTOM = -3;\nconst int TOP = -4;\n\nbool intersects(const vector<int>& c1, const vector<int>& c2) {\n    long long distSq = static_cast<long long>(c1[0] - c2[0]) * (c1[0] - c2[0]) + \n                       static_cast<long long>(c1[1] - c2[1]) * (c1[1] - c2[1]);\n    long long radSumSq = static_cast<long long>(c1[2] + c2[2]) * (c1[2] + c2[2]);\n    return distSq <= radSumSq;\n}\n\nvector<pair<int, int>> generateEdgeList(const vector<vector<int>>& circles, int X, int Y) {\n    vector<pair<int, int>> edgeList;\n    int n = circles.size();\n    \n    // Check for intersections between circles\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (intersects(circles[i], circles[j])) {\n                edgeList.emplace_back(i, j);\n            }\n        }\n    }\n\n    // Check for intersections between circles and rectangle sides\n    for (int i = 0; i < n; ++i) {\n        if (circles[i][0] - circles[i][2] <= 0) {\n            edgeList.emplace_back(LEFT, i);\n        }\n        if (circles[i][0] + circles[i][2] >= X) {\n            edgeList.emplace_back(RIGHT, i);\n        }\n        if (circles[i][1] - circles[i][2] <= 0) {\n            edgeList.emplace_back(BOTTOM, i);\n        }\n        if (circles[i][1] + circles[i][2] >= Y) {\n            edgeList.emplace_back(TOP, i);\n        }\n    }\n    \n    return edgeList;\n}\n\nbool dfs(int node, unordered_set<int>& visited, unordered_set<int>& targets, unordered_map<int, vector<int>>& graph) {\n    if (targets.count(node)) return true;\n    visited.insert(node);\n\n    for (int neighbor : graph[node]) {\n        if (!visited.count(neighbor) && dfs(neighbor, visited, targets, graph)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool canReachCorner(int X, int Y, const vector<vector<int>>& circles) {\n    vector<pair<int, int>> edgeList = generateEdgeList(circles, X, Y);\n\n    unordered_map<int, vector<int>> graph;\n    for (const auto& edge : edgeList) {\n        graph[edge.first].push_back(edge.second);\n        graph[edge.second].push_back(edge.first);\n    }\n\n    unordered_set<int> visited;\n    unordered_set<int> leftTarget = {RIGHT};\n    unordered_set<int> bottomTarget = {TOP};\n    unordered_set<int> bottomLeftTarget = {LEFT};\n    unordered_set<int> topRightTarget = {RIGHT};\n\n    // Check if there is a path from LEFT to RIGHT\n    visited.clear();\n    for (int startNode : graph[LEFT]) {\n        if (dfs(startNode, visited, leftTarget, graph)) return false;\n    }\n\n    // Check if there is a path from BOTTOM to TOP\n    visited.clear();\n    for (int startNode : graph[BOTTOM]) {\n        if (dfs(startNode, visited, bottomTarget, graph)) return false;\n    }\n\n    // Check if there is a path from BOTTOM to LEFT\n    visited.clear();\n    for (int startNode : graph[BOTTOM]) {\n        if (dfs(startNode, visited, bottomLeftTarget, graph)) return false;\n    }\n\n    // Check if there is a path from TOP to RIGHT\n    visited.clear();\n    for (int startNode : graph[TOP]) {\n        if (dfs(startNode, visited, topRightTarget, graph)) return false;\n    }\n\n    return true;\n}\n\n\n};",
    "submit_ts": "1722139113",
    "subm_id": "1335808198"
}