{
    "username": "varangrai",
    "submission": "class Solution {\npublic:\n    void dfs(vector<vector<int>>& tree, int node, int parent, int depth,\n             int& farthestNode, int& maxDepth) {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            farthestNode = node;\n        }\n        for (int neighbor : tree[node]) {\n            if (neighbor != parent) {\n                dfs(tree, neighbor, node, depth + 1, farthestNode, maxDepth);\n            }\n        }\n    }\n\n    int treeDiameter(vector<vector<int>>& edges) {\n        int n = edges.size() + 1; \n        vector<vector<int>> tree(n);\n        for (auto& edge : edges) {\n            tree[edge[0]].push_back(edge[1]);\n            tree[edge[1]].push_back(edge[0]);\n        }\n\n        int farthestNode = 0, maxDepth = 0;\n        dfs(tree, 0, -1, 0, farthestNode, maxDepth);\n\n        maxDepth = 0;\n        dfs(tree, farthestNode, -1, 0, farthestNode, maxDepth);\n\n        return maxDepth;\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int dia1 = treeDiameter(edges1);\n        int dia2 = treeDiameter(edges2);\n\n\n        if((dia1&1) && (dia2&1)){\n            return max({(dia1 + 1)/2 + (dia2 + 1)/2 + 1, dia1, dia2});\n        }\n        else if((dia1&1)==0 && (dia2&1)==0)\n            return max({dia1/2 + dia2/2 + 1, dia1, dia2});\n        else{\n            return max({dia1, dia2, (dia1 + 1)/2 + (dia2 + 1)/2 + 1});\n        }\n    }\n};",
    "submit_ts": 1719718653.0
}