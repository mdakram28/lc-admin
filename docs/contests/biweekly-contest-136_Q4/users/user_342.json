{
    "username": "pku_erutan",
    "submission": "class Solution:\n    def timeTaken(self, edges: List[List[int]]) -> List[int]:\n        n = len(edges) + 1\n        neighbour = collections.defaultdict(list)\n        for u, v in edges :\n            neighbour[u].append(v)\n            neighbour[v].append(u)\n            \n        times = {}\n        memory = {}\n        father_id = {}\n        self.n = 0\n        def solve(fp=-1, np=0) :\n            to_ret_base = (1 if np % 2 == 1 else 2)\n            to_ret_add = 0\n            memt = []\n            for ison, sont in enumerate(neighbour[np]) :\n                self.n += 1\n                if sont == fp :\n                    memt.append(-1)\n                    father_id[np]=ison\n                    continue\n                solve_next = solve(np, sont)\n                memt.append(solve_next)\n                to_ret_add = max(to_ret_add, solve_next)\n            memory[np] = memt\n            times[(fp, np)] = to_ret_base+to_ret_add\n            return to_ret_base+to_ret_add\n        \n        \n        memory[0] = []\n        for ni in neighbour[0] :\n            memory[0].append(solve(0, ni))\n        # print(times)\n        # print(memory)\n        \n        @functools.lru_cache(None)\n        def get_sorted(fp) :\n            return sorted([[t, i] for i, t in enumerate(memory[fp])], reverse=True)\n    \n        def solve2(fp=-1, np=0) :\n            # memt = sorted([[t, i] for i, t in enumerate(memory[fp])], reverse=True)\n            memt = get_sorted(fp)\n            # print(fp, np, memt)\n            \n                    \n            if len(memt) == 1 :\n                maxt = 0\n            elif not np == neighbour[fp][memt[0][1]] :\n                maxt = memt[0][0]\n            else :\n                maxt = memt[1][0]\n                \n            times[(np, fp)] = maxt + (1 if fp % 2 == 1 else 2)\n            memory[np][father_id[np]] = times[(np, fp)]\n            \n            for sont in neighbour[np] :\n                if not sont == fp :\n                    solve2(np, sont)\n                \n        \n        for ni in neighbour[0] :\n            solve2(0, ni)\n            \n        # print(times)\n        to_ret = []\n        for i in range(n) :\n            to_ret.append(max([times[(i, ni)] for ni in neighbour[i]]))\n        print(self.n)\n        return to_ret",
    "submit_ts": "1722700079",
    "subm_id": "552278309"
}