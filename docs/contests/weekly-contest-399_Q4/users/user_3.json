{
    "username": "megurine",
    "submission": "template<typename K>\nclass SegmentTree {\n    vector<K> nodes;\n    int n;\npublic:\n    SegmentTree(int n) : n(n), nodes(n * 2) {}\n\n    template<typename Gen>\n    void build(Gen gen) {\n        function<void(int, int, int)> _build = [&](int L, int R, int p) {\n            if (L == R) {\n                nodes[p] = gen(L);\n                return;\n            }\n            int mid = (L + R) / 2, lp = p + 1, rp = p + (mid - L + 1) * 2;\n            _build(L, mid, lp), _build(mid + 1, R, rp);\n            nodes[p] = nodes[lp] + nodes[rp];\n        };\n        _build(0, n - 1, 1);\n    }\n\n    void modify(int id, K v, bool is_add = false) {\n        function<void(int, int, int)> _modify = [&](int L, int R, int p) {\n            if (L == R) {\n                nodes[p] = v;\n                return;\n            }\n            int mid = (L + R) / 2, lp = p + 1, rp = p + (mid - L + 1) * 2;\n            if (id <= mid) _modify(L, mid, lp);\n            else _modify(mid + 1, R, rp);\n            nodes[p] = nodes[lp] + nodes[rp];\n        };\n        _modify(0, n - 1, 1);\n    }\n\n    K query(int l, int r) {\n        function<K(int, int, int)> _query = [&](int L, int R, int p) -> K {\n            if (l <= L && R <= r) {\n                return nodes[p];\n            }\n            int mid = (L + R) / 2, lp = p + 1, rp = p + (mid - L + 1) * 2;\n            if (mid >= l && mid < r)\n                return _query(L, mid, lp) + _query(mid + 1, R, rp);\n            else if (mid >= l)\n                return _query(L, mid, lp);\n            else\n                return _query(mid + 1, R, rp);\n        };\n        return _query(0, n - 1, 1);\n    }\n\n    template<typename V, typename Fn, typename Fn2>\n    V query(int l, int r, V init_value, Fn merge, Fn2 parse) {\n        function<V(int, int, int)> _query = [&](int L, int R, int p) -> V {\n            if (l <= L && R <= r) {\n                V ret = parse(nodes[p]);\n                return ret;\n            }\n            int mid = (L + R) / 2, lp = p + 1, rp = p + (mid - L + 1) * 2;\n            V ret = init_value;\n            if (mid >= l) ret = merge(ret, _query(L, mid, lp));\n            if (mid < r) ret = merge(ret, _query(mid + 1, R, rp));\n            return ret;\n        };\n        return _query(0, n - 1, 1);\n    }\n};\n\ntemplate<typename T>\nT chmax(T &a, T b) { return a > b ? a : (a = b); }\n\ntemplate<typename T>\nT chmin(T &a, T b) { return a < b ? a : (a = b); }\n\nusing i64 = int64_t;\n\nconstexpr i64 inf = 1e18, mod = 1e9 + 7;\n\nstruct node {\n    i64 v[2][2];\n\n    node(i64 x = -inf) {\n        v[0][0] = 0, v[1][1] = x;\n        v[0][1] = v[1][0] = -inf;\n    }\n};\n\nnode operator+(const node &a, const node &b) {\n    node c;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            for (int x = 0; x < 2; ++x) {\n                for (int y = 0; y < 2; ++y) {\n                    if (j && x) continue;\n                    chmax(c.v[i][y], a.v[i][j] + b.v[x][y]);\n                }\n            }\n        }\n    }\n    return c;\n}\n\nclass Solution {\npublic:\n    int maximumSumSubsequence(vector<int> &nums, vector<vector<int>> &queries) {\n        int n = nums.size();\n        SegmentTree<node> seg(n);\n        seg.build([&](int i) { return node(nums[i]); });\n        i64 ans = 0;\n        for (auto &it: queries) {\n            seg.modify(it[0], node(it[1]));\n            node ret = seg.query(0, n - 1);\n            i64 cur = 0;\n            for (int i = 0; i < 2; ++i) {\n                for (int j = 0; j < 2; ++j ) {\n                    chmax(cur, ret.v[i][j]);\n                }\n            }\n            ans += cur % mod;\n        }\n        return ans % mod;\n    }\n};",
    "submit_ts": 1716691792.0
}