{
    "username": "nicholastung47",
    "submission": "from functools import cache, lru_cache\nfrom collections import defaultdict\nclass Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        \"\"\"\n        smells like a classic dp again?\n        terminate if additions go past len of target\n        find prefix in words, trim and repeat, return min cost\n\n        \n        \"\"\"\n\n        lt = defaultdict(lambda: float(\"inf\"))\n        for word, cost in zip(words, costs):\n            lt[word] = min(lt[word], cost)\n\n        # print(len(words))\n        # print(len(lt.keys()))\n\n        # ordered_keys = list(lt.keys())\n        # ktp = { k: i for i, k in enumerate(ordered_keys) }\n        # paths = [0] * len(lt.keys())\n        # rem = [target for _ in lt.keys()]\n        \n        # while len(ktp.keys()) != 0:\n        #     # explore paths starting with prefix i\n        #     for i in range(len(ordered_keys)):\n        #         r = rem[i]\n        #         ans = float(\"inf\")\n        #         if r in lt.keys():\n\n\n        # returns cost to build target, inf if impossible\n        # @lru_cache(maxsize=4*len(lt.keys()))\n        @cache\n        def sol(ts):\n            ans = float(\"inf\")\n            if target[ts:] in lt.keys():\n                ans = lt[target[ts:]]\n            \n            for k, v in lt.items():\n                if k == target[ts:ts+len(k)]:\n                    ans = min(ans, v + sol(ts+len(k)))\n            return ans\n        \n        ans = sol(0)\n        return -1 if ans == float(\"inf\") else ans\n\n        # return -1",
    "submit_ts": "1720324760",
    "subm_id": "1312407518"
}