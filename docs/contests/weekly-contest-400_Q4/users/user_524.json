{
    "username": "surajprajapati555",
    "submission": "class Solution {\npublic:\n    \n    class SegmentTree {\nprivate:\n    vector<int> tree;\n    int n;\n\n    // Build the tree from the given array\n    void build(const vector<int>& arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(arr, 2 * node, start, mid);\n            build(arr, 2 * node + 1, mid + 1, end);\n            tree[node] = tree[2 * node] & tree[2 * node + 1];\n        }\n    }\n\n    // Query the AND of the range [L, R]\n    int query(int node, int start, int end, int L, int R) {\n        if (R < start || end < L) {\n            return INT_MAX; // Identity for AND\n        }\n        if (L <= start && end <= R) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int left = query(2 * node, start, mid, L, R);\n        int right = query(2 * node + 1, mid + 1, end, L, R);\n        return left & right;\n    }\n\n    // Update the element at index idx\n    void update(int node, int start, int end, int idx, int value) {\n        if (start == end) {\n            tree[node] = value;\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid) {\n                update(2 * node, start, mid, idx, value);\n            } else {\n                update(2 * node + 1, mid + 1, end, idx, value);\n            }\n            tree[node] = tree[2 * node] & tree[2 * node + 1];\n        }\n    }\n\npublic:\n    SegmentTree(const vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        build(arr, 1, 0, n - 1);\n    }\n\n    // Public method to query the AND of the range [L, R]\n    int query(int L, int R) {\n        return query(1, 0, n - 1, L, R);\n    }\n\n    // Public method to update the element at index idx\n    void update(int idx, int value) {\n        update(1, 0, n - 1, idx, value);\n    }\n};\n    \n    int minimumDifference(vector<int>& nums, int k) {\n        \n        SegmentTree seg(nums);\n        \n        int ans=INT_MAX;\n        for(int i=0;i<nums.size();i++)\n        {\n            if(nums[i]<k)\n            {\n                ans=min(ans,abs(k-nums[i]));\n            }\n            else if(i==nums.size()-1)\n            {\n                ans=min(ans,abs(k-nums[i]));\n            }\n            else\n            {\n                int lo=i;\n                int hi=nums.size()-1;\n                \n                while(lo<=hi)\n                {\n                    int mid=(lo+hi)/2;\n                    \n                    int val=seg.query(i,mid);\n                    \n                    if(val>k)\n                    {\n                        ans=min(ans,abs(k-val));\n                        lo=mid+1;\n                    }\n                    else\n                    {\n                        ans=min(ans,abs(k-val));\n                        hi=mid-1;\n                    }\n                }\n            }\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": 1717298742.0
}