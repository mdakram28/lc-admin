{
    "username": "nudroid",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size();\n        int m = edges2.size();\n        vector<vector<int>> adj1(n+1);vector<vector<int>> adj2(m+1);\n\n        for (auto edge : edges1) {\n            adj1[edge[0]].push_back(edge[1]);adj1[edge[1]].push_back(edge[0]);\n        }\n\n        for (auto edge : edges2) {\n            adj2[edge[0]].push_back(edge[1]);adj2[edge[1]].push_back(edge[0]);\n        }\n\n        int dia1 = getDiameter(adj1);int dia2 = getDiameter(adj2);\n\n        return max(max(dia1, dia2), (dia1+1)/2 + (dia2+1)/2 + 1);\n    }\nprivate: \n    pair<int, int> bfs(vector<vector<int>>& adj, int start) {\n        vector<int> dist(adj.size(), -1);\n        dist[start] = 0;\n        queue<int> q;q.push(start);\n        int fNode = start; int maxDist = 0;\n        while (!q.empty()) {\n        int elem = q.front();q.pop();\n        for (int near : adj[elem]) {\n                if (dist[near] == -1) {\n                    dist[near] = dist[elem] + 1; q.push(near);\n                    if (dist[near] > maxDist) { maxDist = dist[near];fNode = near;}\n                }\n            }\n        }\n\n        return {fNode, maxDist};\n    }\n\n    int getDiameter(vector<vector<int>>& adj) {\n        pair<int, int> initial = bfs(adj, 0); pair<int, int> secondary = bfs(adj, initial.first);\n        return secondary.second;\n    }\n};",
    "submit_ts": "1719718253",
    "subm_id": "1304412604"
}