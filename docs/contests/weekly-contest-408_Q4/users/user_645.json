{
    "username": "Xenoid",
    "submission": "class Circle {\npublic:\n    Circle(const vector<int>& data) {\n        x_ = data[0];\n        y_ = data[1];\n        r_ = data[2];\n    }\n    Circle(int x, int y, int r) : x_(x), y_(y), r_(r) {}\n    bool intersects(const Circle& other) const {\n        // Distance between the centers, squared.\n        long long dsqr = ((long long)x_ - other.x()) * ((long long)x_ -other.x()) + ((long long)y_ - other.y()) * ((long long) y_ - other.y());\n        long long raddist = ((long long) r_ + other.r()) * ((long long) r_ + other.r());\n        return dsqr <= raddist;\n    }\n    bool MeetsXBetweenYs(int x, int y1, int y2) const {\n        if (y_ < y1) {\n            return intersects(Circle(x, y1, 0));\n        } else if (y_ > y2) {\n            return intersects(Circle(x, y2, 0));\n        } else {\n            return intersects(Circle(x, y_, 0));\n        }\n    }\n    bool MeetsYBetweenXs(int y, int x1, int x2) const {\n        if (x_ < x1) {\n            return intersects(Circle(x1, y, 0));\n        } else if (x_ > x2) {\n            return intersects(Circle(x2, y, 0));\n        } else {\n            return intersects(Circle(x_, y, 0));\n        }\n    }\n    int x() const { return x_; }\n    int y() const { return y_; }\n    int r() const { return r_; }\nprivate:\n    int x_;\n    int y_;\n    int r_;\n};\n\nbool operator==(const Circle& c1, const Circle& c2) {\n    return c1.x() == c2.x() && c1.y() == c2.y() && c1.r() == c2.r();\n}\n\ntemplate <>\nstruct std::hash<Circle> {\n    size_t operator()(const Circle& c) const {\n        return (c.x()) % 1000000 + (c.y()) % 1000000 + (c.r()) % 1000000;\n    }\n};\n\nclass CircleSet {\npublic:\n    void Add(const Circle& circle) {\n        circles_.insert(circle);\n    }\n    void Delete(const Circle& circle) {\n        circles_.erase(circle);\n    }\n    bool Meets(const Circle& circle) {\n        for (const Circle& c : circles_) {\n            if (c.intersects(circle)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    bool MeetsXBetweenYs(int x, int y1, int y2) {\n        for (const Circle& c : circles_) {\n            if (c.MeetsXBetweenYs(x, y1, y2)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    bool MeetsYBetweenXs(int y, int x1, int x2) {\n        for (const Circle& c : circles_) {\n            if (c.MeetsYBetweenXs(y, x1, x2)) {\n                return true;\n            }\n        }\n        return false;\n    }\nprivate:\n    unordered_set<Circle> circles_;\n};\n\nclass Solution {\npublic:\n    bool canReachCorner(int x, int y, vector<vector<int>>& circles) {\n        vector<Circle> c;\n        for(const vector<int>& circle : circles) {\n            c.emplace_back(circle);\n        }\n        while (!c.empty()) {\n            CircleSet cset;\n            cset.Add(c.back());\n            c.pop_back();\n            bool new_circle_added = false;\n            do {\n                new_circle_added = false;\n                unordered_set<Circle> erasures;\n                for(auto iter = c.begin(); iter != c.end(); ++iter) {\n                    if (cset.Meets(*iter)) {\n                        cset.Add(*iter);\n                        new_circle_added = true;\n                        c.erase(iter);\n                        break;\n                    }\n                }\n            } while (new_circle_added);\n            if (cset.MeetsXBetweenYs(0, 0, y) && cset.MeetsXBetweenYs(x, 0, y)) {\n                return false;\n            }\n            if (cset.MeetsXBetweenYs(0, 0, y) && cset.MeetsYBetweenXs(0, 0, x)) {\n                return false;\n            }\n            if (cset.MeetsXBetweenYs(x, 0, y) && cset.MeetsYBetweenXs(y, 0, x)) {\n                return false;\n            }\n            if (cset.MeetsYBetweenXs(0, 0, x) && cset.MeetsYBetweenXs(y, 0, x)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};",
    "submit_ts": "1722137537",
    "subm_id": "1335766640"
}