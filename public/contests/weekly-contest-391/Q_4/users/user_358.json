{
    "username": "jcoves",
    "submission": "\n#ifdef LOCAL_RUN\n#include \"debug_leet.h\"\n    #else\n    #define debug(x)\n    #define debuga(a, n)\n    #define debug2(x, y)\n    #define debug3(x, y, z)\n    #define debug4(x, y, z, w)\n    #define ctime()\n    int recur_depth = 0; bool rec_indent = true;\n    template <typename Arg, typename... Args>\n    void trace(Arg&& arg, Args&&... args){}\n    void display(TreeNode* root) {}\n    #endif\n\n    #define pb push_back\n    #define eb emplace_back\n    #define popb pop_back\n    #define all(v) begin(v), end(v)\n    #define rall(v) (v).rbegin(),(v).rend()\n    #define make_unique(v) (v).erase(unique(all(v)), (v).end())\n    #define sz(c) ((int) c.size())\n    #define forn(i,n) for(int i=0;i<(int)(n);i++)\n    #define fornn(i,s,n) for(int i=s;i<(int)(n);i++)\n    #define forb(i,n) for(int i=n-1;i>=0;i--)\n    #define forbn(i,s,n) for(int i=n-1;i>=(int)(s);i--)\n    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n    #define mem(a,b) memset(a,b,sizeof(a))\n    #define abs(x) (((x) < 0) ? -(x) : (x))\n    #define sqr(x) ((x) * (x))\n    #define sqrt(x) sqrt(abs(x))\n    #define has(c,x) (c.find(x)!=c.end())\n    #define pw(x) (1LL << (x))\n    #define ibit(x,i) ((x >> i) & 1)\n    #define preturn(s) {out(s); return;}\n    #define yesno(b) ((b) ? \"Yes\" : \"No\")\n    #define data(v) v.data(), sz(v) // vi -> vai\n\n\n    typedef stringstream sstr;\n    typedef long long ll;\n    typedef long double ld;\n    typedef pair<int, int> pii;\n    typedef pair<ll,ll> pll;\n    typedef pair<ld,ld> pdd;\n    typedef vector<int> vi;\n    typedef vector<ll> vll;\n    typedef vector<pii> vpii;\n    typedef vector<vi> vvi;\n    typedef vector<vll> vvll;\n    typedef valarray<int> vai;\n    template <class T>\n    using min_pq = priority_queue<T, vector<T>, greater<T>>;\n    template <class T>\n    using vc = vector<T>;\n    template <class T>\n    using vvc = vector<vc<T>>;\n    template <class T>\n    using vvvc = vector<vvc<T>>;\n    template <class T>\n    using vvvvc = vector<vvvc<T>>;\n    template <class T>\n    using vvvvvc = vector<vvvvc<T>>;\n\n    template<class F>\n    struct y_combinator_result{\n        F f;\n        template<class T> explicit y_combinator_result(T &&f_in): f(forward<T>(f_in)){ }\n        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }\n    };\n    template<class F>\n    decltype(auto) y_combinator(F &&f){\n        return y_combinator_result<decay_t<F>>(forward<F>(f));\n    }\n\n    inline int ni(){ int x; cin >> x;   return x; }\n    inline ll  nl() { ll  x; cin >> x; return x; }\n\n    template <typename T> void mmin(T& a, const T& b) {\n        a = (a) < (b) ? (a) : (b);\n    }\n    template <typename T> void mmax(T& a, const T& b) {\n        a = (a) > (b) ? (a) : (b);\n    }\n    template <class T> vc<vc<T>> vv(int d1, int d2, T x){\n        return vc<vc<T>>(d1, vc<T>(d2, x));\n    }\n    template <class T> auto vvv(int d1, int d2, int d3, T x){\n        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));\n    }\n    template <class T> auto vvvv(int d1, int d2, int d3, int d4, T x){\n        return vc<vc<vc<vc<T>>>>(d1, vvv(d2, d3, d4, x));\n    }\n    template <typename Iter> void outIt (Iter it, Iter end) {\n        for (; it!=end; ++it) { cout<< *it <<\" \"; } cout << endl;\n    }\n    template <typename Iter> void readIt (Iter it, Iter end) {\n        if(it == end) trace(\"readIt empty\");\n        for (; it!=end; ++it) { cin>> *it; }\n    }\n    void outv(auto &v){\n        for(auto &x: v) {cout<< x <<\" \";} cout<<endl;\n    }\n    void readv(auto &v, int &n){\n        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);\n    }\n    void readv(auto &v){\n        if(sz(v)==0) trace(\"readv empty\");\n        for(auto &x: v) cin >> (x);\n    }\n    template <typename Arg, typename... Args>\n    void read(Arg&& arg, Args&&... args){\n        cin >> std::forward<Arg>(arg); using expander = int[];\n        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};\n    }\n    template <typename Arg, typename... Args>\n    void out(Arg&& arg, Args&&... args){\n        cout << std::forward<Arg>(arg); using expander = int[];\n        (void)expander{0, (void(cout << \" \" << std::forward<Args>(args)),0)...};\n        cout << endl;\n    }\n\n    ll pwr(ll base, ll p, ll mod){\n        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;\n            base=(base*base)%mod; p/=2;}\n        return ans;\n    }\n    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }\n    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }\n\n    const long double PI = (long double)(3.1415926535897932384626433832795);\n    const ll  mx_ll   = numeric_limits<ll> :: max();\n    const int mx_int  = numeric_limits<int> :: max();\n\n    const int oo = 0x3f3f3f3f;\n    const ll  OO = 0x3f3f3f3f3f3f3f3fll;\n    const double eps = 1e-9;\n    // const int dx[8]={0,1, 0,-1,-1,1,-1, 1};\n    // const int dy[8]={1,0,-1, 0,-1,1, 1,-1};\n    const int dx[4]={0,1, 0,-1};\n    const int dy[4]={1,0,-1, 0};\n\nconst int maxn = 1e5 + 3;\nconst int mod = 1e9+7;\nclass Solution {\npublic:\n    int furthest(int id, vpii &a, int exclude=-1){\n        auto [cx, cy] = a[id];\n        pii best = {-1, -1};\n        forn(i, sz(a)) {\n            if(i==exclude) continue;\n            auto [x, y] = a[i];\n            mmax(best, {abs(cx-x)+abs(cy-y), i});\n        }\n        return best.first;\n    }\n    int minimumDistance(vector<vector<int>>& points) {\n        vpii a; int n = sz(points);\n        for(auto &v: points) a.emplace_back(v[0], v[1]);\n        debug(a);\n        vpii sum, minus;\n        forn(i, n){\n            auto [x, y] = a[i];\n            sum.eb(x+y, i);\n            minus.eb(x-y, i);\n        }\n        sort(all(sum)); sort(all(minus));\n        vi cands = {sum[0].second, minus[0].second, sum.back().second, minus.back().second};\n        int ans = oo;\n        for(auto id: cands){\n            int dis = 0;\n            for(auto corner: cands){\n                if(corner == id) continue;\n                mmax(dis, furthest(corner, a, id));\n            }\n            debug3(id, a[id], dis);\n            mmin(ans, dis);\n        }\n        // vc<tuple<int,int,int>> ds;\n        // forn(i, n) forn(j, i) ds.eb(\n        //     abs(a[i].first-a[j].first) + abs(a[i].second-a[j].second),\n        //     i, j);\n        // sort(all(ds));\n        // debug(ds);\n        return ans;\n    }\n};"
}