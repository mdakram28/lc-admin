{
    "username": "SomuDEb",
    "submission": "from collections import deque\n\nclass Solution:\n    def treeDiameter(self, edges: List[List[int]]) -> int:\n        n = len(edges) + 1\n        adj = [[] for _ in range(n)]\n        \n        for edge in edges:\n            adj[edge[0]].append(edge[1])\n            adj[edge[1]].append(edge[0])\n        \n        # Perform first BFS to find the farthest node from any node (let's start from node 0)\n        def bfs(start):\n            dist = [-1] * n\n            q = deque([start])\n            dist[start] = 0\n            farthest_node = start\n            \n            while q:\n                node = q.popleft()\n                for neighbor in adj[node]:\n                    if dist[neighbor] == -1:\n                        dist[neighbor] = dist[node] + 1\n                        q.append(neighbor)\n                        if dist[neighbor] > dist[farthest_node]:\n                            farthest_node = neighbor\n            \n            return farthest_node, dist[farthest_node]\n        \n        first_bfs = bfs(0)\n        second_bfs = bfs(first_bfs[0])\n        \n        return second_bfs[1]\n\n    def findTreeCenters(self, edges: List[List[int]]) -> List[int]:\n        n = len(edges) + 1\n        adj = [[] for _ in range(n)]\n        degree = [0] * n\n        \n        for edge in edges:\n            adj[edge[0]].append(edge[1])\n            adj[edge[1]].append(edge[0])\n            degree[edge[0]] += 1\n            degree[edge[1]] += 1\n        \n        leaves = deque()\n        for i in range(n):\n            if degree[i] == 1:\n                leaves.append(i)\n        \n        remaining_nodes = n\n        while remaining_nodes > 2:\n            leaves_count = len(leaves)\n            remaining_nodes -= leaves_count\n            \n            for _ in range(leaves_count):\n                leaf = leaves.popleft()\n                for neighbor in adj[leaf]:\n                    degree[neighbor] -= 1\n                    if degree[neighbor] == 1:\n                        leaves.append(neighbor)\n        \n        centers = list(leaves)\n        return centers\n    \n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        if not edges1 and not edges2:\n            return 1\n        if not edges1 or not edges2:\n            return 2\n        \n        sol = Solution()\n        d1 = sol.treeDiameter(edges1)\n        d2 = sol.treeDiameter(edges2)\n        \n        centers1 = sol.findTreeCenters(edges1)\n        centers2 = sol.findTreeCenters(edges2)\n        \n        min_diameter = float('inf')\n        for c1 in centers1:\n            for c2 in centers2:\n                new_diameter = max(d1, d2, (d1 + 1) // 2 + (d2 + 1) // 2 + 1)\n                min_diameter = min(min_diameter, new_diameter)\n        \n        return min_diameter\n",
    "submit_ts": "1719719879",
    "subm_id": "1304452944"
}