{
    "username": "KyQxVeAr4m",
    "submission": "typedef long long int ll;\nclass SegmentTree {\nprivate:\n    vector<long long> tree, lazy;\n    int n;\n\n    void build(const vector<long long>& arr, int v, int tl, int tr) {\n        if (tl == tr) {\n            tree[v] = arr[tl];\n        } else {\n            int tm = (tl + tr) / 2;\n            build(arr, v * 2, tl, tm);\n            build(arr, v * 2 + 1, tm + 1, tr);\n            tree[v] = min(tree[v * 2], tree[v * 2 + 1]);\n        }\n    }\n\n    void push(int v) {\n        if (lazy[v] != 0) {\n            tree[v * 2] -= lazy[v];\n            lazy[v * 2] += lazy[v];\n            tree[v * 2 + 1] -= lazy[v];\n            lazy[v * 2 + 1] += lazy[v];\n            lazy[v] = 0;\n        }\n    }\n\n    void update(int v, int tl, int tr, int l, int r, long long addend) {\n        if (l > r) \n            return;\n        if (l == tl && r == tr) {\n            tree[v] -= addend;\n            lazy[v] += addend;\n        } else {\n            push(v);\n            int tm = (tl + tr) / 2;\n            update(v * 2, tl, tm, l, min(r, tm), addend);\n            update(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, addend);\n            tree[v] = min(tree[v * 2], tree[v * 2 + 1]);\n        }\n    }\n\n    long long query(int v, int tl, int tr, int l, int r) {\n        if (l > r)\n            return LLONG_MAX;\n        if (l <= tl && tr <= r)\n            return tree[v];\n        push(v);\n        int tm = (tl + tr) / 2;\n        return min(query(v * 2, tl, tm, l, min(r, tm)),\n                   query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));\n    }\n\npublic:\n    SegmentTree(const vector<long long>& arr) {\n        n = arr.size();\n        tree.resize(n * 4);\n        lazy.resize(n * 4, 0);\n        build(arr, 1, 0, n - 1);\n    }\n\n    void update(int l, int r, long long addend) {\n        update(1, 0, n - 1, l, r, addend);\n    }\n\n    long long query(int l, int r) {\n        return query(1, 0, n - 1, l, r);\n    }\n};\n\nclass Solution {\nprivate:\n    long long get(vector<long long>& temp) {\n    int n = temp.size();\n    SegmentTree segTree(temp);\n    \n    //Goal - To make array temp 0 //Operations select the whole or some part of temp having contigous non //zero values and subtract them by one until one of them becomes zero //this can be done efficiently by just subtracting all values with the //minimum in the range //after the miniumum is set to zero the values to its left or right //will remain or not remain zero but you have to do the same thing //for the remaining array uintil the whole of temp becomes zero //also the return value is the count of the operations done //\n    long long operations = 0;\n\n    while (true) {\n        int start = -1;\n        // Find the start of the next segment of non-zero values\n        for (int i = 0; i < n; ++i) {\n            if (temp[i] != 0) {\n                start = i;\n                break;\n            }\n        }\n        // If no non-zero segment is found, break the loop\n        if (start == -1) break;\n\n        // Find the end of the current segment of non-zero values\n        int end = start;\n        for (int i = start; i < n; ++i) {\n            if (temp[i] == 0) break;\n            end = i;\n        }\n\n        // Find the minimum value in the current segment\n        long long minVal = segTree.query(start, end);\n\n        // Subtract the minimum value from all elements in the current segment\n        segTree.update(start, end, minVal);\n\n        // Increment the operation count\n        operations += minVal;\n\n        // Update the temp array to reflect changes (for non-zero check)\n        for (int i = start; i <= end; ++i) {\n            temp[i] -= minVal;\n        }\n    }\n\n    return operations;\n}\npublic:\n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n        int n = nums.size();\n        vector<ll> diff(n);\n        for(int i = 0;i < n;i++){\n            diff[i] = nums[i] - target[i];\n        }\n        ll res = 0;\n        \n\n        for(int i = 0;i < n;i++){\n            if(diff[i] >= 0){\n                vector<ll> temp;\n                while(i < n && diff[i] >= 0){\n                    temp.push_back(diff[i]);\n                    i++;\n                }\n                i--;\n                res += get(temp);\n            }\n            if(diff[i] < 0){\n                vector<ll> temp;\n                while(i < n && diff[i] < 0){\n                    temp.push_back(abs(diff[i]));\n                    i++;\n                }\n                i--;\n                \n                res += get(temp);\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": "1721532459",
    "subm_id": "1327986327"
}