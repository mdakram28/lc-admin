{
    "username": "STARs_56789",
    "submission": "#ifndef LOCAL\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\n\nnamespace mitsuha{\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &A) {\n    os << A.first << \" \" << A.second;\n    return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &A) {\n    for (size_t i = 0; i < A.size(); i++) {\n        if (i) os << \" \";\n        os << A[i];\n    }\n    return os;\n}\n\nvoid print() {\n    std::cout << \"\\n\";\n    std::cout.flush();\n}\n\ntemplate <class Head, class... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n    std::cout << head;\n    if (sizeof...(Tail)) std::cout << \" \";\n    print(std::forward<Tail>(tail)...);\n}\n}\n\nnamespace mitsuha {\ntemplate <class T> bool chmin(T& x, const T& y) { \n    return y >= x ? false : (x = y, true); \n}\ntemplate <class T> bool chmax(T& x, const T& y) { \n    return y <= x ? false : (x = y, true); \n}\ntemplate <class T> constexpr T fld(const T x, const T y) { \n    T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); \n}\ntemplate <class T> constexpr T cld(const T x, const T y) { \n    T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); \n}\ntemplate <class T> constexpr T rem(const T x, const T y) { \n    return x - y * fld(x, y); \n}\ntemplate <class Iterable> void settify(Iterable& a) { \n    std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); \n}\ntemplate <size_t D> struct Dim : std::array<int, D> {\n    template <typename ...Ints> Dim(const Ints& ...ns) : \n        std::array<int, D>::array{ static_cast<int>(ns)... } {}\n};\ntemplate <typename ...Ints> Dim(const Ints& ...) -> Dim<sizeof...(Ints)>;\ntemplate <class T, size_t D, size_t I = 0>\nauto ndvec(const Dim<D> &ns, const T& value = {}) {\n    if constexpr (I + 1 < D) {\n        return std::vector(ns[I], ndvec<T, D, I + 1>(ns, value));\n    } else {\n        return std::vector<T>(ns[I], value);\n    }\n}\n}\n\nnamespace mitsuha {\nusing str = std::string;\nusing int128 = __int128;\nusing uint128 = unsigned __int128;\ntemplate <class T> using min_priority_queue \n                            = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T> using max_priority_queue \n                            = std::priority_queue<T, std::vector<T>, std::less<T>>;\n}\nnamespace mitsuha { \n    const std::vector<std::string> Yes = {\"No\", \"Yes\"};\n    const std::vector<std::string> YES = {\"NO\", \"YES\"};\n}\n \n#ifndef __COUNTER__\n#define __COUNTER__ __LINE__\n#endif\n\n#define TL (long long)\n \n#define OVERLOAD5(a, b, c, d, e, ...) e\n#define REP1_0(b, c) REP1_1(b, c)\n#define REP1_1(b, c) for (long long REP_COUNTER_##c = 0; REP_COUNTER_##c < TL(b); ++REP_COUNTER_##c)\n#define REP1(b) REP1_0(b, __COUNTER__)\n#define REP2(i, b) for (long long i = 0; i < TL(b); ++i)\n#define REP3(i, a, b) for (long long i = TL(a); i < TL(b); ++i)\n#define REP4(i, a, b, c) for (long long i = TL(a); i < TL(b); i += TL(c))\n#define For(...) OVERLOAD5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)\n#define Frr(i, a) for (long long i = TL(a)-1; i >= 0; --i)\n\n#define All(iterable) std::begin(iterable), std::end(iterable)\n#define len(iterable) TL iterable.size()\n#define elif else if\n\n#define KBIT(a, k) (a & (1ULL << k))\n\n#define Assert(x) void(0);\n\nusing namespace mitsuha;\nusing namespace std;\n \nconstexpr int iinf = std::numeric_limits<int>::max() / 2;\nconstexpr long long linf = std::numeric_limits<long long>::max() / 2;\n\nnamespace mitsuha{\nunsigned long long RNG_64() {\n    static uint64_t x_\n            = uint64_t(chrono::duration_cast<chrono::nanoseconds>(\n                    chrono::high_resolution_clock::now().time_since_epoch())\n                               .count())\n              * 10150724397891781847ULL;\n    x_ ^= x_ << 7;\n    return x_ ^= x_ >> 9;\n}\n\nunsigned long long RNG(unsigned long long lim) { return RNG_64() % lim; }\n\nlong long RNG(long long l, long long r) { return l + RNG_64() % (r - l); }\n} // namespace mitsuha\n\nnamespace mitsuha{\nstruct modint61 {\n    static constexpr unsigned long long mod = (1ULL << 61) - 1;\n    unsigned long long val;\n    constexpr modint61() : val(0ULL) {}\n    constexpr modint61(unsigned int x) : val(x) {}\n    constexpr modint61(unsigned long long x) : val(x % mod) {}\n    constexpr modint61(int x) : val((x < 0) ? (x + static_cast<long long>(mod)) : x) {}\n    constexpr modint61(long long x) : val(((x %= static_cast<long long>(mod)) < 0) ? (x + static_cast<long long>(mod)): x) {}\n    static constexpr unsigned long long get_mod() { return mod; }\n    modint61 &operator+=(const modint61 &a) {\n        val = ((val += a.val) >= mod) ? (val - mod) : val;\n        return *this;\n    }\n    modint61 &operator-=(const modint61 &a) {\n        val = ((val -= a.val) >= mod) ? (val + mod) : val;\n        return *this;\n    }\n    modint61 &operator*=(const modint61 &a) {\n        const unsigned __int128 y = static_cast<unsigned __int128>(val) * a.val;\n        val = (y >> 61) + (y & mod);\n        val = (val >= mod) ? (val - mod) : val;\n        return *this;\n    }\n    modint61 operator-() const { return modint61(val ? mod - val : 0ULL); }\n    modint61 &operator/=(const modint61 &a) { return (*this *= a.inverse()); }\n    modint61 operator+(const modint61 &p) const { return modint61(*this) += p; }\n    modint61 operator-(const modint61 &p) const { return modint61(*this) -= p; }\n    modint61 operator*(const modint61 &p) const { return modint61(*this) *= p; }\n    modint61 operator/(const modint61 &p) const { return modint61(*this) /= p; }\n    bool operator==(const modint61 &p) const { return val == p.val; }\n    bool operator!=(const modint61 &p) const { return val != p.val; }\n    modint61 inverse() const {\n        long long a = val, b = mod, u = 1, v = 0, t;\n        while (b > 0) {\n            t = a / b;\n            swap(a -= t * b, b), swap(u -= t * v, v);\n        }\n        return modint61(u);\n    }\n    modint61 pow(long long n) const {\n        assert(n >= 0);\n        modint61 ret(1), mul(val);\n        while (n > 0) {\n            if (n & 1) ret *= mul;\n            mul *= mul, n >>= 1;\n        }\n        return ret;\n    }\n};\n\n#ifdef FASTIO\nvoid rd(modint61 &number){\n    io::rd(number.val);\n}\nvoid wt(const modint61 &number){\n    io::wt(number.val);\n}\n#endif\nostream &operator<<(ostream &out, const modint61 &number){ return out << number.val; }\n} // namespace mitsuha\n\nnamespace mitsuha{\nstruct RollingHash {\n    using mint = modint61;\n    static constexpr unsigned long long mod = mint::get_mod();\n    const mint base;\n    vector<mint> power;\n\n    static inline mint generate_base() { return RNG(mod); }\n\n    inline void expand(size_t sz) {\n        if (power.size() < sz + 1) {\n            int pre_sz = (int)power.size();\n            power.resize(sz + 1);\n            for(int i = pre_sz - 1; i < sz; ++i) power[i + 1] = power[i] * base;\n        }\n    }\n\n    explicit RollingHash(mint base = generate_base()) : base(base), power{1} {}\n\n    template <typename STRING>\n    vector<mint> build(const STRING& s) const {\n        int sz = s.size();\n        vector<mint> hashed(sz + 1, mint(0));\n        for (int i = 0; i < sz; i++) { hashed[i + 1] = hashed[i] * base + s[i]; }\n        return hashed;\n    }\n\n    template <typename STRING>\n    mint eval(STRING& s) {\n        mint x = 0;\n        for (auto& ch: s) x = base * x + ch;\n        return x;\n    }\n\n    mint query(const vector<mint>& s, int l, int r) {\n        expand(r - l);\n        return (s[r] - s[l] * power[r - l]);\n    }\n\n    mint combine(mint h1, mint h2, int h2len) {\n        expand(h2len);\n        return h1 * power[h2len] + h2;\n    }\n\n    mint add_char(mint h, int x) { return h * base + mint(x); }\n\n    int lcp(const vector<mint>& a, int l1, int r1, const vector<mint>& b, int l2, int r2) {\n        int len = min(r1 - l1, r2 - l2);\n        int low = 0, high = len + 1;\n        while (high - low > 1) {\n            int mid = (low + high) / 2;\n            if (query(a, l1, l1 + mid) == query(b, l2, l2 + mid))\n                low = mid;\n            else\n                high = mid;\n        }\n        return low;\n    }\n};\n} // namespace mitsuha\n\nclass Solution {\npublic:\n    int numberOfAlternatingGroups(vector<int>& colors, int k) {\n        \n        vector<int> a(k), b(k);\n\n        For(x, k){\n            a[x] = x & 1;\n            b[x] = 1 ^ a[x];\n        }\n\n        int n = len(colors);\n\n        RollingHash Rh;\n\n        auto A = Rh.build(a);\n        auto B = Rh.build(b);\n\n        auto Ac = Rh.query(A, 0, k);\n        auto Bc = Rh.query(B, 0, k);\n\n        For(x, n){\n            colors.push_back(colors[x]);\n        }\n        auto C = Rh.build(colors);\n        int ret = 0;\n        For(x, n){\n            if (Rh.query(C, x, x + k) == Ac or Rh.query(C, x, x + k) == Bc){\n                ret += 1;\n            }\n        }\n        return ret;\n    }\n};\n\n",
    "submit_ts": "1720277507",
    "subm_id": "1311666925"
}