{
    "username": "minhdpbdbpvn",
    "submission": "constexpr int INF = -int(1e9);\nclass SegmentTree {\nprivate:\n    vector<int> st;\n    vector<int> leaf;\n    int sz;\n\n    void build(int l, int r, int x=1) {\n        if (l == r) {\n            leaf[l] = x;\n            return;\n        }\n        int m = (l+r) / 2;\n        build(l, m, 2*x);\n        build(m+1, r, 2*x + 1);\n    }\n    int _getmax(int u, int v, int l, int r, int x = 1) {\n        if (v < l || u > r)\n            return INF;\n        if (u <= l && r <= v)\n            return st[x];\n        int m = (l+r) / 2;\n        return max(_getmax(u, v, l, m, 2*x), _getmax(u, v, m+1, r, 2*x + 1));\n    }\npublic:\n    SegmentTree() {}\n    SegmentTree(int N) {\n        sz = N;\n        st.resize(4*sz + 4);\n        leaf.resize(sz+1);\n        build(1, sz);\n    }\n    void update(int pos, int val) {\n        int x = leaf[pos];\n        st[x] = val;\n        while (x > 1) {\n            x /= 2;\n            st[x] = max(st[2*x], st[2*x + 1]);\n        }\n    }\n    int getmax(int u, int v) {\n        if (u > v)\n            return INF;\n        return _getmax(u, v, 1, sz);\n    }\n};\nclass Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {\n        set<int> myset(nums.begin(), nums.end());\n        vector<int> tmp(myset.begin(), myset.end());\n        for (int& x : nums) {\n            x = lower_bound(tmp.begin(), tmp.end(), x) - tmp.begin() + 1;\n        }\n\n        int N = int(nums.size());\n        vector<vector<int>> dp(N+1, vector<int>(51, 1));\n        vector<SegmentTree> cache(k+1);\n        for (int i = 0; i <= k; ++i)\n            cache[i] = SegmentTree(N);\n        for (int t = 0; t <= k; ++t) {\n            // dp[1][t] = 1;\n            cache[t].update(nums[0], 1);\n        }\n        for (int i = 2; i <= N; ++i) {\n            for (int t = 0; t <= k; ++t) {\n                dp[i][t] = max(dp[i][t], cache[t].getmax(nums[i-1], nums[i-1]) + 1);\n                if (t > 0) {\n                    dp[i][t] = max(dp[i][t], cache[t-1].getmax(1, nums[i-1]-1) + 1);\n                    dp[i][t] = max(dp[i][t], cache[t-1].getmax(nums[i-1]+1, N) + 1);\n                }\n                cache[t].update(nums[i-1], dp[i][t]);\n            }\n        }\n        int ans = 0;\n        for (int i = 1; i <= N; ++i)\n            ans = max(ans, dp[i][k]);\n        return ans;\n    }\n};",
    "submit_ts": 1717861658.0
}