{
    "username": "anand_hu",
    "submission": "class Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        // Transform circle data into a more accessible format\n        vector<pair<pair<int, int>, int>> circleDetails(circles.size());\n        for (int i = 0; i < circles.size(); ++i) {\n            circleDetails[i] = {{circles[i][0], circles[i][1]}, circles[i][2]};\n        }\n\n        // Initialize the graph\n        int totalNodes = circles.size() + 4;\n        vector<vector<int>> adjList(totalNodes);\n        \n        // Build the graph\n        buildGraph(X, Y, circleDetails, adjList);\n        \n        // Check for connectivity\n        if (checkConnectivity(adjList, circles.size(), circles.size() + 1, circles.size() + 2, totalNodes) || \n            checkConnectivity(adjList, circles.size() + 3, circles.size() + 2, circles.size() + 1, totalNodes)) {\n            return false;\n        }\n        \n        return true;\n    }\n\nprivate:\n    void buildGraph(int X, int Y, vector<pair<pair<int, int>, int>>& circleDetails, vector<vector<int>>& adjList) {\n        int numCircles = circleDetails.size();\n        \n        for (int i = 0; i < numCircles; ++i) {\n            auto& circle = circleDetails[i];\n            int cx = circle.first.first;\n            int cy = circle.first.second;\n            int r = circle.second;\n            \n            if (cx <= r) {\n                adjList[numCircles].push_back(i);\n                adjList[i].push_back(numCircles);\n            }\n            if (X - cx <= r) {\n                adjList[numCircles + 2].push_back(i);\n                adjList[i].push_back(numCircles + 2);\n            }\n            if (cy <= r) {\n                adjList[numCircles + 1].push_back(i);\n                adjList[i].push_back(numCircles + 1);\n            }\n            if (Y - cy <= r) {\n                adjList[numCircles + 3].push_back(i);\n                adjList[i].push_back(numCircles + 3);\n            }\n            for (int j = i + 1; j < numCircles; ++j) {\n                if (areCirclesConnected(circle, circleDetails[j])) {\n                    adjList[i].push_back(j);\n                    adjList[j].push_back(i);\n                }\n            }\n        }\n    }\n    \n    bool areCirclesConnected(pair<pair<int, int>, int>& c1, pair<pair<int, int>, int>& c2) {\n        long long dx = c1.first.first - c2.first.first;\n        long long dy = c1.first.second - c2.first.second;\n        long long distanceSquared = dx * dx + dy * dy;\n        long long radiusSum = c1.second + c2.second;\n        return distanceSquared <= radiusSum * radiusSum;\n    }\n\n    bool checkConnectivity(vector<vector<int>>& graph, int start, int t1, int t2, int nodeCount) {\n        vector<bool> visited(nodeCount, false);\n        queue<int> q;\n        q.push(start);\n        visited[start] = true;\n\n        while (!q.empty()) {\n            int current = q.front();\n            q.pop();\n            for (int neighbor : graph[current]) {\n                if (!visited[neighbor]) {\n                    q.push(neighbor);\n                    visited[neighbor] = true;\n                }\n            }\n        }\n        \n        return visited[t1] || visited[t2];\n    }\n};",
    "submit_ts": "1722136906",
    "subm_id": "1335748450"
}