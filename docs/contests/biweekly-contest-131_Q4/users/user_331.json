{
    "username": "Fasdr",
    "submission": "class Solution {\n    public List<Boolean> getResults(int[][] queries) {\n        int maxSize = 60_000;\n        SegmentTree st = new SegmentTree(maxSize);\n        TreeSet<Integer> blocks = new TreeSet<>();\n        blocks.add(0);\n        List<Boolean> res = new ArrayList<>();\n        for (int[] query : queries) {\n            if (query[0] == 1) {\n                int x = query[1];\n                int left = blocks.floor(x);\n                st.update(left, x - 1, x - left - st.max(left, x - 1));\n                Integer right = blocks.ceiling(x);\n                if (right != null)\n                    st.update(x, right - 1, right - x - st.max(x, right - 1));\n                blocks.add(x);\n                \n                \n            } else {\n\n                \n                int x = query[1], sz = query[2];\n                int old = 0;\n                int left = 0;\n                if (!blocks.contains(x)) {\n                    left = blocks.floor(x);\n                    old = st.max(left, x - 1);\n                    st.update(left, x - 1, (x - left) - old);\n                }\n                if (sz <= st.max(0, x - 1))\n                    res.add(true);\n                else\n                    res.add(false);\n                \n                if (!blocks.contains(x)) {\n                    st.update(left, x - 1, old - (x - left));\n                }\n\n            }\n        }\n        \n        \n        return res;\n    }\n}\n\nclass SegmentTree {\n    \n    public int[] tree;\n    public int[] lazy;\n    private int n;\n    \n    public SegmentTree(int n) {\n        tree = new int[4 * n];\n        lazy = new int[4 * n];\n        this.n = n;\n    }\n    \n    // max in [lq, rq] including\n    public int max(int lq, int rq) {\n        return maxH(1, lq, rq, 0, n);\n    }\n    \n    private int maxH(int p, int lq, int rq, int lt, int rt) {\n        int ls = 2 * p, rs = 2 * p + 1;\n        if (lazy[p] != 0) {\n            tree[p] += lazy[p];\n            if (lt != rt) {\n                lazy[ls] += lazy[p];\n                lazy[rs] += lazy[p];\n            }\n            lazy[p] = 0;\n        }\n        if (rq < lt || rt < lq)\n            return 0;\n        if (lq <= lt && rt <= rq)\n            return tree[p];\n        int piv = lt + (rt - lt) / 2;\n        return Math.max(\n            maxH(ls, lq, rq, lt, piv),\n            maxH(rs, lq, rq, piv + 1, rt)\n        );\n    }\n    \n    // update elements in [l1, rq] including to val\n    public void update(int lq, int rq, int val) {\n        updateH(1, lq, rq, val, 0, n);\n    }\n    \n    private int updateH(int p, int lq, int rq, int val, int lt, int rt) {\n        if (lq <= lt && rt <= rq)\n            lazy[p] += val;\n        int ls = 2 * p, rs = 2 * p + 1;\n        if (lazy[p] != 0) {\n            tree[p] += lazy[p];\n            if (lt != rt) {\n                lazy[ls] += lazy[p];\n                lazy[rs] += lazy[p];\n            }\n            lazy[p] = 0;\n        }\n        if (rq < lt || rt < lq)\n            return tree[p];\n        if (lq <= lt && rt <= rq)\n            return tree[p];\n        int piv = lt + (rt - lt) / 2;\n        return tree[p] = Math.max(\n            updateH(ls, lq, rq, val, lt, piv),\n            updateH(rs, lq, rq, val, piv + 1, rt)\n        );\n    }\n}",
    "submit_ts": 1716652455.0
}