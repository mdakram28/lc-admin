{
    "username": "dennis753951",
    "submission": "class Solution {\npublic:\n    long* segmentTree;\n    int N;\n\n    void buildTree(vector<int>& nums) {\n        N = nums.size();\n        segmentTree = new long[N << 1]{};\n        \n        // Leaf Nodes\n        for(int i = N + 1, j = 1; j != N - 1; ++i, ++j)\n            segmentTree[i] = (nums[j] > nums[j - 1]) && (nums[j] > nums[j + 1]);\n        \n        // Middle Nodes\n        for(int i = N - 1; i != 0; --i)\n            segmentTree[i] = segmentTree[i << 1] + segmentTree[(i << 1) + 1];\n    }\n\n    void update(int index, int value) {\n        // cout << \"update \" << index << \", \" << value << \"\\n\";\n        int toBeAdded = value - segmentTree[N + index];\n        for(int i = N + index; i != 0; i >>= 1)\n            segmentTree[i] += toBeAdded;\n    }\n\n    long sumRange(int left, int right) {\n        left += N;\n        right += N;\n        long sum = 0;\n        while(left <= right) {\n            if(left & 1){\n                sum += segmentTree[left++];\n            }\n            if(!(right & 1)){\n                sum += segmentTree[right--];\n            }\n            left >>= 1, right >>= 1;\n        }\n        return sum;\n    }\n    \n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& q) {\n        vector<int> res;\n        int n = nums.size(), t;\n        \n        buildTree(nums);\n        int val;\n        \n        for(auto &v : q) {\n            if(v[0] == 1) { // cnt\n                t = sumRange(v[1], v[2])\n                    - (v[1] && (v[1] != n - 1) && (nums[v[1]] > nums[v[1] - 1]) && (nums[v[1]] > nums[v[1] + 1]));\n                \n                if(v[1] != v[2])\n                    t -= (v[2] && (v[2] != n - 1) && (nums[v[2]] > nums[v[2] - 1]) && (nums[v[2]] > nums[v[2] + 1]));\n                \n                res.push_back(t);\n            }\n            else { // update\n                nums[v[1]] = v[2];\n                \n                val = v[1] && (v[1] != n - 1) && (nums[v[1]] > nums[v[1] - 1]) && (nums[v[1]] > nums[v[1] + 1]);\n                update(v[1], val);\n                \n                if(v[1] - 1 > 0) {\n                    val = (nums[v[1] - 1] > nums[v[1] - 2]) && (nums[v[1] - 1] > nums[v[1]]);\n                    update(v[1] - 1, val);\n                }\n                \n                if(v[1] + 1 < n - 1) {\n                    val = (nums[v[1] + 1] > nums[v[1]]) && (nums[v[1] + 1] > nums[v[1] + 2]);\n                    update(v[1] + 1, val);\n                }\n            }\n        }\n        \n        return res;\n    }\n};",
    "submit_ts": "1718506682",
    "subm_id": "1289627423"
}