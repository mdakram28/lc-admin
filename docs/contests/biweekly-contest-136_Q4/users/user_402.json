{
    "username": "i777slam73",
    "submission": "\nclass Solution {\npublic:\n    class LCA {\n        int n, Log, root = 1;\n        vector<int> depth,depth2,depth3, sz;\n        vector<vector<int> > adj, lca;\n\n        void dfs(int node, int par) {\n            lca[node][0] = par;\n            if (par != -1) depth[node] = depth[par] + 1;\n            if (par != -1) depth2[node] = depth2[par] + 1 + (node % 2);\n            if (par != -1) depth3[node] = depth3[par] + 1 + (par % 2);\n\n            sz[node] = 1;\n            for (int i = 1; i <= Log; i++) {\n                int up = lca[node][i - 1];\n                if (~up) lca[node][i] = lca[up][i - 1];\n            }\n            for (auto &it: adj[node]) {\n                if (it == par) continue;\n                dfs(it, node);\n                if (~par) sz[node] += sz[it];\n            }\n        }\n\n    public:\n        LCA(const vector<vector<int> > &_adj, int root = 1) : root(root), adj(_adj) {\n            n = adj.size() - 1;\n            Log = log2(n);\n            lca = vector<vector<int> >(n + 1, vector<int>(Log + 1, -1));\n            depth =depth2 =depth3 = sz = vector<int>(n + 1);\n            dfs(root, -1);\n        }\n\n        int get_lca(int x, int y) {\n            if (depth[x] < depth[y]) swap(x, y);\n            for (int i = Log; i >= 0; i--) {\n                if (depth[x] - (1 << i) >= depth[y]) {\n                    x = lca[x][i];\n                }\n            }\n            if (x == y) return x;\n            for (int i = Log; i >= 0; i--) {\n                if (lca[x][i] != lca[y][i]) {\n                    x = lca[x][i];\n                    y = lca[y][i];\n                }\n            }\n            return lca[x][0];\n        }\n\n        int get_dis(int u, int v) {\n            int lc = get_lca(u, v);\n            return depth3[u] + depth2[v] - depth2[get_lca(u, v)] - depth3[lc] ;\n        }\n\n        int get_sz(int node) {\n            return sz[node];\n        }\n\n        int shifting(int node, int dis) {\n            for (int i = Log; i >= 0 && ~node; i--) {\n                if (dis & (1 << i)) {\n                    node = lca[node][i];\n                }\n            }\n            return node;\n        }\n    };\n\n    int node, mx = 0, n;\n    vector<vector<int> > adj;\n\n    void dfs(int i, int par, int d) {\n        if (d > mx) {\n            mx = d;\n            node = i;\n        }\n        for (auto &it: adj[i]) {\n            if (it == par) continue;\n            dfs(it, i, d + 1 + it % 2);\n        }\n    }\n\n    vector<int> timeTaken(vector<vector<int> > &edges) {\n        for (auto &it: edges)n = max({n, it[0], it[1]});\n        n++;\n        adj = vector<vector<int> >(n + 1);\n        for (auto &it: edges) {\n            it[0]++;\n            it[1]++;\n            adj[it[0]].push_back(it[1]);\n            adj[it[1]].push_back(it[0]);\n        }\n        dfs(1, -1, 0);\n        mx = 0;\n        int l = node;\n        dfs(node, -1, 0);\n        int r = node;\n        int diam = mx;\n\n        LCA lca(adj);\n        vector<int>ans(n);\n\n        for (int i = 1; i <= n; i++) {\n            ans[i - 1] = max(lca.get_dis(i, l), lca.get_dis(i, r));\n        }\n        return ans;\n    }\n};\n",
    "submit_ts": "1722700576",
    "subm_id": "1343246145"
}