{
    "username": "TangJing",
    "submission": "class SegmentTree {\nprivate:\n  vector<long long> tree;\n  vector<long long> lazy;\n  int n;\n\n  void updateRange(int node, int start, int end, int l, int r, long long val) {\n    if (lazy[node] != 0) {\n      tree[node] += (end - start + 1) * lazy[node];\n      if (start != end) {\n        lazy[2 * node + 1] += lazy[node];\n        lazy[2 * node + 2] += lazy[node];\n      }\n      lazy[node] = 0;\n    }\n\n    if (start > end || start > r || end < l) {\n      return;\n    }\n\n    if (start >= l && end <= r) {\n      tree[node] += (end - start + 1) * val;\n      if (start != end) {\n        lazy[2 * node + 1] += val;\n        lazy[2 * node + 2] += val;\n      }\n      return;\n    }\n\n    int mid = start + (end - start) / 2;\n    updateRange(2 * node + 1, start, mid, l, r, val);\n    updateRange(2 * node + 2, mid + 1, end, l, r, val);\n    tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n  }\n\n  long long queryRange(int node, int start, int end, int l, int r) {\n    if (start > end || start > r || end < l) {\n      return 0;\n    }\n\n    if (lazy[node] != 0) {\n      tree[node] += (end - start + 1) * lazy[node];\n      if (start != end) {\n        lazy[2 * node + 1] += lazy[node];\n        lazy[2 * node + 2] += lazy[node];\n      }\n      lazy[node] = 0;\n    }\n\n    if (start >= l && end <= r) {\n      return tree[node];\n    }\n\n    int mid = start + (end - start) / 2;\n    long long p1 = queryRange(2 * node + 1, start, mid, l, r);\n    long long p2 = queryRange(2 * node + 2, mid + 1, end, l, r);\n    return (p1 + p2);\n  }\n\npublic:\n  SegmentTree(int n) : n(n) {\n    tree.resize(4 * n, 0);\n    lazy.resize(4 * n, 0);\n  }\n\n  void update(int l, int r, long long val) {\n    updateRange(0, 0, n - 1, l, r, val);\n  }\n\n  long long query(int l, int r) { return queryRange(0, 0, n - 1, l, r); }\n};\n\nclass Solution {\npublic:\n  vector<long long> countKConstraintSubstrings(string s, int k,\n                                               vector<vector<int>> &queries) {\n    int n = s.size();\n    int x = 0, y = 0;\n    vector<int> r(n);\n    for (int i = 0, j = -1; i < n; ++i) {\n      while (j + 1 < n &&\n             ((x + (s[j + 1] == '0') <= k || (y + (s[j + 1] == '1') <= k)))) {\n        x += s[j + 1] == '0';\n        y += s[j + 1] == '1';\n        ++j;\n      }\n      r[i] = j;\n      x -= s[i] == '0';\n      y -= s[i] == '1';\n    }\n    struct node {\n      int l, r, idx;\n    };\n    int q = queries.size();\n    vector<node> query(q);\n    for (int i = 0; i < queries.size(); ++i) {\n      query[i].l = queries[i][0];\n      query[i].r = queries[i][1];\n      query[i].idx = i;\n    }\n\n    sort(query.begin(), query.end(),\n         [&](const node &x, const node &y) { return x.l > y.l; });\n\n    SegmentTree tree(n);\n    vector<long long> ans(q);\n    for (int i = 0, j = n - 1; i < q; ++i) {\n      while (j >= query[i].l) {\n        tree.update(j, r[j], 1);\n        --j;\n      }\n      ans[query[i].idx] = tree.query(query[i].l, query[i].r);\n    }\n    return ans;\n  }\n};",
    "submit_ts": "1723950861",
    "subm_id": "556401736"
}