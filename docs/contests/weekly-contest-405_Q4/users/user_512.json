{
    "username": "BurgerDragon",
    "submission": "from collections import defaultdict, deque\n\nclass ACAutomaton:\n    def __init__(self, words):\n        self.trie = defaultdict(dict)\n        self.end = defaultdict(list)\n        self.fail = {}\n        self.words = words\n        self.root = 0\n        self.state_count = 1\n\n    def add_word(self, word, idx):\n        current = self.root\n        for char in word:\n            if char not in self.trie[current]:\n                self.trie[current][char] = self.state_count\n                self.state_count += 1\n            current = self.trie[current][char]\n        self.end[current].append(idx)\n\n    def build_automaton(self):\n        queue = deque()\n        for char in self.trie[self.root]:\n            self.fail[self.trie[self.root][char]] = self.root\n            queue.append(self.trie[self.root][char])\n\n        while queue:\n            current = queue.popleft()\n            for char in self.trie[current]:\n                child = self.trie[current][char]\n                queue.append(child)\n                f = self.fail[current]\n                while f != self.root and char not in self.trie[f]:\n                    f = self.fail[f]\n                if char in self.trie[f]:\n                    self.fail[child] = self.trie[f][char]\n                else:\n                    self.fail[child] = self.root\n                self.end[child].extend(self.end[self.fail[child]])\n\n    def search_in(self, target):\n        word_position_map = defaultdict(list)\n        current_state = self.root\n        for i in range(len(target)):\n            while current_state != self.root and target[i] not in self.trie[current_state]:\n                current_state = self.fail[current_state]\n            if target[i] in self.trie[current_state]:\n                current_state = self.trie[current_state][target[i]]\n            else:\n                current_state = self.root\n            for idx in self.end[current_state]:\n                word_len = len(self.words[idx])\n                if i - word_len + 1 >= 0:  # Ensure valid start index\n                    word_position_map[i - word_len + 1].append(idx)\n        return word_position_map\n\nclass Solution:\n    def minimumCost(self, target: str, words: list[str], costs: list[int]) -> int:\n        # Preprocess words and costs to only keep the lowest cost for each unique word\n        word_cost_map = {}\n        for idx, word in enumerate(words):\n            if word not in word_cost_map or costs[idx] < word_cost_map[word]:\n                word_cost_map[word] = costs[idx]\n\n        unique_words = list(word_cost_map.keys())\n        unique_costs = [word_cost_map[word] for word in unique_words]\n\n        ac_automaton = ACAutomaton(unique_words)\n        for idx, word in enumerate(unique_words):\n            ac_automaton.add_word(word, idx)\n        \n        ac_automaton.build_automaton()\n\n        n = len(target)\n        word_position_map = ac_automaton.search_in(target)\n\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n\n        for i in range(n):\n            if dp[i] == float('inf'):\n                continue\n            for idx in word_position_map[i]:\n                word_len = len(unique_words[idx])\n                cost = unique_costs[idx]\n                if i + word_len <= n:\n                    dp[i + word_len] = min(dp[i + word_len], dp[i] + cost)\n\n        return dp[n] if dp[n] != float('inf') else -1\n\n# # Provided Test Cases\n# solution = Solution()\n# print(solution.minimumCost(\"abcdef\", [\"abdef\",\"abc\",\"d\",\"def\",\"ef\"], [100, 1, 1, 10, 5]))  # Expected: 7\n# print(solution.minimumCost(\"aaaa\", [\"z\",\"zz\",\"zzz\"], [1,10,100]))  # Expected: -1\n\n# # Additional Test Cases\n# print(solution.minimumCost(\"target\", [\"t\",\"tar\",\"get\",\"g\",\"et\"], [1, 5, 2, 3, 4]))  # Expected: appropriate min cost or -1\n# print(solution.minimumCost(\"minimum\", [\"min\",\"imum\",\"um\",\"mi\",\"ni\"], [1, 2, 3, 4, 5]))  # Expected: appropriate min cost or -1\n# print(solution.minimumCost(\"impossible\", [\"imp\",\"poss\",\"i\",\"ble\"], [10, 15, 1, 5]))  # Expected: appropriate min cost or -1",
    "submit_ts": "1720322014",
    "subm_id": "1312338383"
}