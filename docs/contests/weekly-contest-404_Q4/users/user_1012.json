{
    "username": "Ahemad_14",
    "submission": "/*\n    Name :- Tafheem Ahemad\n*/\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define ll long long int\n#define ld long double\n#define F first\n#define S second\nconst int MOD = 1e9 + 7;\n#define vl vector<ll>\n#define vi vector<int>\n#define vs vector<string>\n#define vll vector<vl>\n#define vii vector<vi>\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define ump unordered_map\n#define all(v) v.begin(), v.end()\n#define take_matrix(a, n, m) for(int i = 0; i < n; i++) { for(int j = 0; j < m; j++) { cin >> a[i][j]; } }\n#define print_matrix(a, n, m) for(int i = 0; i < n; i++) { for(int j = 0; j < m; j++) { cout << a[i][j] << ' '; } cout << endl; }\n#define input(a) for(auto &x : a) cin >> x;\n#define printv(a) for(auto i : a) cout << i << ' '; cout << endl;\n#define cl(n) for(int i = 0; i <= n + 5; i++) g[i].clear()\n#define mem(v, z) memset(v, z, sizeof(v))\n#define fast() ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define pb push_back\n#define in insert\ntemplate <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nvector<vector<ll>> delta1 = {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};\nvector<vector<ll>> delta2 = {{1, 0}, {-1, 0}, {0, -1}, {0, 1}, {1, 1}, {-1, 1}, {1, -1}, {-1, -1}};\n\nclass Solution {\npublic:\n    ll ans;\n    \n    ll depth(int node, int par, vl &height, vector<list<ll>>& g) {\n        if (height[node] != -1) return height[node];\n    \n        ll mx = 0;\n        for (auto i : g[node]) {\n            if (i == par) continue;\n    \n            mx = max(mx, 1 + depth(i, node, height, g));\n        }\n    \n        height[node] = mx;\n        return mx;\n    }\n    \n    void solve1(int node, int par, ll parent_mx, vl &ans, vl &height, vector<list<ll>>& g) {\n        ans[node] = max(height[node], 1 + parent_mx);\n    \n        multiset<ll> st;\n        st.insert(-1e9);\n        st.insert(-1e9);\n        st.insert(parent_mx);\n        for (auto i : g[node]) {\n            if (i == par) continue;\n    \n            st.insert(height[i]);\n        }\n    \n        for (auto i : g[node]) {\n            if (i == par) continue;\n    \n            st.erase(st.find(height[i]));\n            solve1(i, node, 1ll + *prev(st.end()), ans, height, g);\n            st.insert(height[i]);\n        }\n    }\n    \n    ll solve2(int node, int par, vl &dp, vector<list<ll>>& g) {\n        if (dp[node] != -1) return dp[node];\n    \n        multiset<ll> st;\n        st.insert(0ll);\n        st.insert(0ll);\n        for (auto i : g[node]) {\n            if (i == par) continue;\n    \n            ll z = solve2(i, node, dp, g);\n            st.insert(z);\n            if (st.size() > 2) st.erase(st.begin());\n        }\n    \n        ll a, b;\n        a = *st.begin();\n        st.erase(st.begin());\n        b = *st.begin();\n    \n        ans = max(ans, a + b + 1);\n        return dp[node] = max(a, b) + 1ll;\n    }\n\n    ll find_dia(vector<list<ll>> &g, ll n) {\n        vl dp(n + 1, -1);\n        ans = -1e18;\n        solve2(1, -1, dp, g);\n        return ans - 1;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n1 = edges1.size() + 1;\n        int n2 = edges2.size() + 1;\n        vector<list<ll>> g1(n1 + 2);\n        vector<list<ll>> g2(n2 + 2);\n\n        for (auto it : edges1) {\n            ll a = it[0] + 1;\n            ll b = it[1] + 1;\n            g1[a].pb(b);\n            g1[b].pb(a);\n        }\n        for (auto it : edges2) {\n            ll a = it[0] + 1;\n            ll b = it[1] + 1;\n            g2[a].pb(b);\n            g2[b].pb(a);\n        }\n\n        vl h1(n1 + 2, -1);\n        vl h2(n2 + 2, -1);\n\n        depth(1, -1, h1, g1);\n        depth(1, -1, h2, g2);\n\n        vl ans1(n1 + 2);\n        vl ans2(n2 + 2);\n\n        solve1(1, -1, -1, ans1, h1, g1);\n        solve1(1, -1, -1, ans2, h2, g2);\n\n        ll mn1 = 1e9, mn2 = 1e9;\n        for (int i = 1; i <= n1; i++) {\n            mn1 = min(mn1, ans1[i]);\n        }\n        for (int i = 1; i <= n2; i++) {\n            mn2 = min(mn2, ans2[i]);\n        }\n\n        // printv(ans2);\n        // cout<<mn1<<\" \"<<mn2<<endl;\n        ll re1 = mn1 + mn2 + 1;\n\n        cout<<re1<<endl;\n        ll d1 = find_dia(g1, n1);\n        ll d2 = find_dia(g2, n2);\n\n        return max({re1, d1, d2});\n    }\n};\n",
    "submit_ts": "1719718823",
    "subm_id": "1304426976"
}