{
    "username": "TheCleanser",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll; \ntypedef long double ld;\ntypedef pair<ll, ll> pl;\n\n#define f(i, s, e, inc) for(ll i = (s); i < (e); i += (inc)) \n#define fd(i, s, e, dec) for(ll i = (s); i >= (e); i -= (dec))\n\n\n#define N 100069 // 2e5 \n#define L 20\n//#define MOD 1000000007\n//#define MOD 998244353\n#define LLMX LONG_LONG_MAX\n#define LLMN LONG_LONG_MIN\n\n#define pb(i) push_back((i))\n#define mp(i, j) make_pair((i), (j))\n\nstruct lztree{ \n    \n    typedef pair<ll, ll> T; // Type value\n    typedef ll U; // Update value\n \n    T idT = {0, 1}, t[2 * N];\n    U idU = LONG_LONG_MIN, d[N];\n    ll x = (fill_n(d, N, idU), 0);\n \n    T combine(T a, T b) { \n        return {a.first + b.first, a.second + b.second}; \n    }\n    U combineUpdates(U b, U a) {\n        if(b == idU) return a;\n        else return b;\n    }\n    T update(U b, T a) { \n        if(b == idU) return a;\n        else return {a.second * b, a.second};\n    }\n\n\n    /*\n        Updating a combined segment == Combining updated segments\n        update(x, combine(a, b)) = combine(update(x, a), update(x, b))\n\n        Applying combined updates == Applying each update separately\n        update(combineUpdates(x, y), a) = update(x, update(y, a))\n\n        Usually u change the combine method for querying\n    */\n\n    void calc(ll p) { t[p] = update(d[p], combine(t[p * 2], t[p * 2 + 1])); }\n\n    void apply(ll p, U v) {\n        t[p] = update(v, t[p]);\n        if(p < N) d[p] = combineUpdates(v, d[p]);\n    }\n\n    void push(ll p) {\n        p += N;\n        for(ll s = L - 1; s > (0); --s){\n            ll i = p >> s;\n            if(d[i] != idU) {\n                apply(i * 2, d[i]);\n                apply(i * 2 + 1, d[i]);\n                d[i] = idU;\n            }\n        }\n    }\n\n    void modify(ll p, T v) {\n        push(p);\n        t[p += N] = v;\n        while(p > 1) calc(p /= 2);\n    }\n\n    void modify(ll l, ll r, U v) {\n        push(l), push(r - 1);\n        bool cl = false, cr = false;\n        for(l += N, r += N; l < r; l /= 2, r /= 2) {\n            if(cl) calc(l - 1);\n            if(cr) calc(r);\n            if(l & 1) apply(l++, v), cl = true;\n            if(r & 1) apply(--r, v), cr = true;\n        }\n        for(--l; r; l /= 2, r /= 2) {\n            if(cl) calc(l);\n            if(cr) calc(r);\n        }\n    }\n\n    T query(ll l, ll r) {\n        push(l), push(r - 1);\n        T resl = idT, resr = idT;\n        for(l += N, r += N; l < r; l /= 2, r /= 2) {\n            if(l & 1) resl = combine(resl, t[l++]);\n            if(r & 1) resr = combine(t[--r], resr);\n        }\n        return combine(resl, resr);\n    }\n};\n\nstruct lztree lz;\n\nclass Solution {\npublic:\n    \n    void merge(set<int>& a, set<int>& b)\n    {\n        if (a.size() < b.size()) swap(a, b);\n        for (int x : b) a.insert(x);\n\n    }\n    \n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        \n        f(i, 0, n - 1, 1){\n            lz.modify(i, mp(1, 1));\n        }\n            \n        \n        lz.modify(n - 1, mp(0, 1));\n        \n        vector<int> ans;\n        \n\n        \n        f(i, 0, queries.size(), 1){\n            ll u = queries[i][0]; ll v = queries[i][1];\n            \n            if(u + 1 < v){\n                lz.modify(u + 1, v, 0);\n            }\n            \n            ans.pb((lz.query(0, n)).first);\n        }\n        \n        f(i, 0, n, 1){\n            lz.modify(i, mp(0, 1));\n        }\n        \n        return ans;\n        \n    }\n};",
    "submit_ts": "1722741875",
    "subm_id": "1343755589"
}