{
    "username": "etan0",
    "submission": "class SegmentTree():\n\n    def __init__(self, array):\n        # first pad array to nearest 2^k\n        # https://stackoverflow.com/questions/466204/rounding-up-to-next-power-of-2\n        n = len(array) - 1\n\n        n |= n >> 1\n        n |= n >> 2\n        n |= n >> 4\n        n |= n >> 8\n        n |= n >> 16\n\n        n += 1\n\n        self.arr_len = n\n\n        tree = [0] * (n-1) + array + [0] * (n - len(array))\n        # build binary tree\n        for i in range(n-2, -1, -1):\n            tree[i] = sum(tree[i*2 + 1: i*2 + 3])\n\n        self.tree = tree\n\n    def get_sum(self, l, r):\n        # get leaf with value 'l'\n        l += self.arr_len - 1\n        # get leaf with value 'r'\n        r += self.arr_len - 2\n\n        sum = 0\n\n        while (l <= r):\n\n            if ((l % 2) == 0):\n                # it means l is a right child\n                sum += self.tree[l]\n\n                # move l to right by 1, so it becomes a left child and find its parent\n                l = (l + 1 - 1) // 2\n            else:\n                # when l is a left child, when just find its parent\n                l = (l - 1) // 2\n\n            if ((r % 2) == 1):\n                # it means r is a left chid\n                sum += self.tree[r]\n\n                # move r to left by 1, so it becomes a right child and find its parent\n                r = (r - 1 - 2) // 2\n            else:\n                # when r is a right child\n                r = (r - 2) // 2\n\n        return sum\n\n    def update(self, i, value):\n\n        node = self.arr_len - 1 + i\n\n        self.tree[node] = value\n\n        while node > 0:\n            # find parent node\n            node = (node - 1) // 2\n\n            left_child = node * 2 + 1\n            right_child = node * 2 + 2\n\n            self.tree[node] = self.tree[left_child] + self.tree[right_child]\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        \n        def isPeak(i):\n            if i == 0 or i == len(nums) - 1:\n                return 0\n            return int(nums[i - 1] < nums[i] > nums[i + 1])\n        \n        x = [isPeak(i) for i in range(len(nums))]\n        s = SegmentTree(x)\n        output = []\n        \n        for t, a, b in queries:\n            if t == 1:\n                output.append(s.get_sum(a + 1, b))\n            else:\n                nums[a] = b\n                for ai in (a - 1, a, a + 1):\n                    if 0 <= ai < len(nums) and isPeak(ai) != x[ai]:\n                        x[ai] = isPeak(ai)\n                        s.update(ai, isPeak(ai))\n        \n        return output",
    "submit_ts": 1718507997.0
}