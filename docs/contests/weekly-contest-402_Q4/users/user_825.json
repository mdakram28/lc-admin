{
    "username": "bhatganeshdarshan10",
    "submission": "class PeakSegmentTree {\nprivate:\n    vector<int> segmentTree;\n    int arraySize;\n\n    void buildTree(const vector<int>& nums, int nodeIndex, int left, int right) {\n        if (left == right) {\n            segmentTree[nodeIndex] = isPeak(nums, left) ? 1 : 0;\n        } else {\n            int mid = (left + right) / 2;\n            buildTree(nums, 2 * nodeIndex + 1, left, mid);\n            buildTree(nums, 2 * nodeIndex + 2, mid + 1, right);\n            segmentTree[nodeIndex] = segmentTree[2 * nodeIndex + 1] + segmentTree[2 * nodeIndex + 2];\n        }\n    }\n\n    void updateTree(const vector<int>& nums, int nodeIndex, int left, int right, int updateIndex) {\n        if (left == right) {\n            segmentTree[nodeIndex] = isPeak(nums, updateIndex) ? 1 : 0;\n        } else {\n            int mid = (left + right) / 2;\n            if (left <= updateIndex && updateIndex <= mid) {\n                updateTree(nums, 2 * nodeIndex + 1, left, mid, updateIndex);\n            } else {\n                updateTree(nums, 2 * nodeIndex + 2, mid + 1, right, updateIndex);\n            }\n            segmentTree[nodeIndex] = segmentTree[2 * nodeIndex + 1] + segmentTree[2 * nodeIndex + 2];\n        }\n    }\n\n    int queryTree(int nodeIndex, int left, int right, int queryLeft, int queryRight) {\n        if (queryRight < left || right < queryLeft) {\n            return 0;\n        }\n        if (queryLeft <= left && right <= queryRight) {\n            return segmentTree[nodeIndex];\n        }\n        int mid = (left + right) / 2;\n        int leftResult = queryTree(2 * nodeIndex + 1, left, mid, queryLeft, queryRight);\n        int rightResult = queryTree(2 * nodeIndex + 2, mid + 1, right, queryLeft, queryRight);\n        return leftResult + rightResult;\n    }\n\n    bool isPeak(const vector<int>& nums, int index) {\n        if (index == 0 || index == nums.size() - 1) {\n            return false;\n        }\n        return nums[index] > nums[index - 1] && nums[index] > nums[index + 1];\n    }\n\npublic:\n    PeakSegmentTree(const vector<int>& nums) {\n        arraySize = nums.size();\n        segmentTree.resize(4 * arraySize);\n        buildTree(nums, 0, 0, arraySize - 1);\n    }\n\n    void update(const vector<int>& nums, int updateIndex) {\n        updateTree(nums, 0, 0, arraySize - 1, updateIndex);\n        if (updateIndex > 0) {\n            updateTree(nums, 0, 0, arraySize - 1, updateIndex - 1);\n        }\n        if (updateIndex < arraySize - 1) {\n            updateTree(nums, 0, 0, arraySize - 1, updateIndex + 1);\n        }\n    }\n\n    int query(int left, int right) {\n        if (left >= right) {\n            return 0;\n        }\n        return queryTree(0, 0, arraySize - 1, left + 1, right - 1);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        PeakSegmentTree peakTree(nums);\n        vector<int> result;\n\n        for (const auto& query : queries) {\n            if (query[0] == 1) {\n                int left = query[1];\n                int right = query[2];\n                result.push_back(peakTree.query(left, right));\n            } else if (query[0] == 2) {\n                int index = query[1];\n                int value = query[2];\n                nums[index] = value;\n                peakTree.update(nums, index);\n            }\n        }\n\n        return result;\n    }\n};",
    "submit_ts": 1718508255.0
}