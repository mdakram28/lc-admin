{
    "username": "DhruvMalik07",
    "submission": "class Solution {\npublic:\n    \n    int bfs1(int sr, vector<vector<int>> adj)\n    {\n        int node;\n        queue<int> q;\n        int n=adj.size();\n        vector<bool> vis(n,false);\n        \n        q.push(sr);\n        vis[sr]=true;\n        \n        while(!q.empty())\n        {\n            int sz=q.size();\n            for(int i=0;i<sz;i++)\n            {\n                int temp=q.front();\n                node=temp;\n                q.pop();\n                for(auto i:adj[temp])\n                {\n                    if(!vis[i])\n                    {\n                        vis[i]=true;\n                        q.push(i);\n                    }\n                }\n            }\n        }\n        return node;\n    }\n    \n    int bfs(int sr, vector<vector<int>> adj)\n    {\n        int ct=0;\n        queue<int> q;\n        int n=adj.size();\n        vector<bool> vis(n,false);\n        \n        q.push(sr);\n        vis[sr]=true;\n        \n        while(!q.empty())\n        {\n            ct++;\n            int sz=q.size();\n            for(int i=0;i<sz;i++)\n            {\n                int temp=q.front();\n                q.pop();\n                for(auto i:adj[temp])\n                {\n                    if(!vis[i])\n                    {\n                        vis[i]=true;\n                        q.push(i);\n                    }\n                }\n            }\n        }\n        return ct-1;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) \n    {\n        int n=edges1.size()+1, m=edges2.size()+1;\n        vector<vector<int>> adj1(n,vector<int>());\n        vector<vector<int>> adj2(m,vector<int>());\n        \n        vector<int> indeg1(n,0), indeg2(m,0);\n        \n        for(auto i:edges1)\n        {\n            adj1[i[0]].push_back(i[1]);\n            adj1[i[1]].push_back(i[0]);\n            indeg1[i[1]]++; indeg1[i[0]]++;\n        }\n        \n        for(auto i:edges2)\n        {\n            adj2[i[0]].push_back(i[1]);\n            adj2[i[1]].push_back(i[0]);\n            indeg2[i[1]]++; indeg2[i[0]]++;\n        }\n        int s1=0, s2=0;\n        \n        for(auto i:indeg1) if(i==1) s1=i;\n        for(auto i:indeg2) if(i==1) s2=i;\n        \n        int n1  = bfs1(s1,adj1);\n        int dia1= bfs(n1,adj1);\n        \n        int n2  = bfs1(s2,adj2);\n        int dia2= bfs(n2,adj2);\n        \n        return max({(dia1+1)/2 + (dia2+1)/2 +1, dia1, dia2});\n        // +1 for extra connecting edge\n    }\n};",
    "submit_ts": 1719717680.0
}