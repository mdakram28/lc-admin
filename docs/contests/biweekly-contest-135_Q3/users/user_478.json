{
    "username": "noobatdevelopment",
    "submission": "#include<iostream>\n#include <vector>\n#include <algorithm>\nclass backchodimatkaro {\npublic:\n    bool isMatch(string s, string p) {\n        int m=p.length();\n        int n=s.length();\n        vector<vector<int>>dp(m+1,vector<int>(n+1));\n        dp[0][0]=1;\n        for(int i=0;i<m+1;i++){\n            for(int j=0;j<n+1;j++){\n                if(i==0 && j!=0)dp[i][j]=0;\n                else if(j==0 && i!=0){\n                    int chk=0;\n                    for(int i1=1;i1<=i;i1++){\n                        if(p[i1-1]!='*'){dp[i][j]=0;\n                                         chk=1;}\n                    }\n                    if(chk==0)dp[i][j]=1;\n                    \n                }\n            }\n        }\n        for(int i=1;i<m+1;i++){\n            for(int j=1;j<n+1;j++){\n                if(p[i-1]==s[j-1] || p[i-1]=='?'){\n                    dp[i][j]=dp[i-1][j-1];\n                }else if(p[i-1]=='*'){\n                    dp[i][j]=dp[i-1][j] || dp[i][j-1];\n                }\n            }\n        }\n        return dp[m][n];\n        \n    }\n};\nclass MyQueue {\npublic:\n    stack<int>s1;\n    stack<int>s2;\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        \n        while(!s1.empty()){\n            int top=s1.top();\n            s1.pop();\n            s2.push(top);\n        }\n        s1.push(x);\n        while(!s2.empty()){\n            int top=s2.top();\n            s2.pop();\n            s1.push(top);\n        }\n    }\n    \n    int pop() {\n        int ans=s1.top();\n        s1.pop();\n        return ans;\n    }\n    \n    int peek() {\n        return s1.top();\n    }\n    \n    bool empty() {\n       if(s1.size()==0)return 1;\n        return 0;\n    }\n};\nclass Solution2 {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        //try to apply the two pointer approach here\n        vector<vector<int>>ans;\n        //step one:simple sort the given array\n        sort(nums.begin(),nums.end());\n        int n=nums.size();\n        for(int i=0;i<nums.size();i++){\n            \n           if(i==0 || nums[i]!=nums[i-1]){\n                int low=i+1;\n            int high=n-1;\n            int ele=nums[i];\n            while(low<high){\n                //both low and high are different elements\n                int sum=nums[low]+nums[high]+ele;\n                if(sum==0){\n                    //it means triplet is found\n                    vector<int>temp;\n                    temp.push_back(nums[low]);\n                    temp.push_back(ele);\n                    temp.push_back(nums[high]);\n                    ans.push_back(temp);\n                    while(low<high && nums[low]==nums[low+1])low++;\n                    while(low<high && nums[high]==nums[high-1])high--;\n                    low++;\n                    high--;\n                }\n                else if(sum<0){\n                    low++;\n                }\n                else{\n                    high--;\n                }\n            }\n           }\n        }\n        return ans;\n    }\n};\nclass Solution34343 {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int n1=nums1.size();\n        int n2=nums2.size();\n        if(n1>n2){\n            return findMedianSortedArrays(nums2,nums1);\n        }\n        int n=n1+n2;\n        int left=(n1+n2+1)/2;\n        \n        int low=0;\n        int high=n1;\n        while(low<=high){\n            int mid1=low+(high-low)/2;\n            int mid2=left-mid1;\n            int l1=-1e8;\n            int l2=-1e8;\n            int r1=1e8;\n            int r2=1e8;\n            \n            if(mid1-1>=0)l1=nums1[mid1-1];\n            if(mid2-1>=0)l2=nums2[mid2-1];\n            if(mid1<n1)r1=nums1[mid1];\n            if(mid2<n2)r2=nums2[mid2];\n            \n            //condition\n            if(l1<=r2 && l2<=r1){\n                if(n%2==1){\n                    return max(l1,l2);\n                }\n                else{\n                    return (double)(min(r1,r2)+max(l1,l2))/2.0;\n                }\n            }\n            else if(l1>r2){\n                high=mid1-1;\n            }\n            else{\n                low=mid1+1;\n            }\n        }\n        return 0.0;\n    }\n};\nclass Solution739292 {\n    const int INF = 1e9;\n\npublic:\n    int numberOfSets(int n, int maxDistance, vector<vector<int>>& roads) {\n        int ans = 0;\n\n        for (int mask = 0; mask < (1 << n); mask++) {\n            unordered_set<int> c;\n\n            for (int i = 0; i < n; i++)\n                if (mask & (1 << i))\n                    c.insert(i);\n\n            vector<vector<int>> dp(n, vector<int>(n, INF));\n\n            for (auto& i : roads) {\n                if (c.count(i[0]) && c.count(i[1])) {\n                    int v = min(i[2], dp[i[0]][i[1]]);\n                    dp[i[0]][i[1]] = dp[i[1]][i[0]] = v;\n                }\n            }\n\n            for (int k = 0; k < n; k++) {\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < n; j++) {\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n                    }\n                }\n            }\n\n            for (int i = 0; i < n; i++) {\n                dp[i][i] = 0;\n            }\n\n            bool ok = true;\n\n            for (int i : c) {\n                for (int j : c) {\n                    if (dp[i][j] > maxDistance) {\n                        ok = false;\n                        break;\n                    }\n                }\n\n                if (!ok)\n                    break;\n            }\n\n            ans += ok;\n        }\n\n        return ans;\n    }\n};\nclass Solution4555555534 {\nprivate:\n    vector<int> tree;\n    int n;\n\n    void build(const vector<bool>& arr) {\n        n = arr.size();\n        tree.resize(2 * n, 0);\n\n        // insert leaf nodes in the tree\n        for (int i = 0; i < n; ++i) {\n            tree[n + i] = arr[i];\n        }\n\n        // build the tree by calculating parents\n        for (int i = n - 1; i > 0; --i) {\n            tree[i] = tree[i << 1] & tree[i << 1 | 1];\n        }\n    }\n\n    int query(int l, int r) {\n        int res = 1;\n\n        // loop to find the sum in the range\n        l += n;\n        r += n;\n        while (l < r) {\n            if (l & 1) {\n                res &= tree[l];\n                ++l;\n            }\n            if (r & 1) {\n                --r;\n                res &= tree[r];\n            }\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return res;\n    }\n\npublic:\n    bool have_same_frequency(map<char, int>& freq, int k) {\n        for (auto& pair : freq) {\n            if (pair.second != k && pair.second != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    int countCompleteSubstrings(const string &s, int k) {\n        int count = 0;\n        int distinct = set<char>(s.begin(), s.end()).size();\n        vector<bool> diff(s.size());\n        for (int i = 0; i + 1 < s.size(); i++) {\n            diff[i] = (abs(s[i] - s[i + 1]) <= 2);\n        }\n\n        build(diff);\n\n        for (int length = 1; length <= distinct; length++) {\n            int window_length = length * k;\n            map<char, int> freq;\n            int window_start = 0;\n            int window_end = window_start + window_length - 1;\n            bool ok = true;\n\n            for (int i = window_start; ok && i <= min(window_end, (int)s.length() - 1); i++) {\n                freq[s[i]]++;\n            }\n\n            while (window_end < s.length()) {\n                if (have_same_frequency(freq, k)) {\n                    if (query(window_start, window_end)) {\n                        count++;\n                    }\n                }\n                freq[s[window_start]]--;\n                window_start++;\n                window_end++;\n                if (window_length < s.length()) {\n                    freq[s[window_end]]++;\n                }\n            }\n        }\n\n        return count;\n    }\n};\n// class Solution {\n// public:\n//  std::vector<int64_t> preSum;\n\n//  void calcPresum(const std::vector<int>& v) {\n//  int n = v.size();\n//  preSum.clear();\n//  preSum.resize(n);\n//  preSum[0] = v[0];\n// for (int i = 1; i < n; i++) {\n//  preSum[i] = preSum[i - 1] + v[i];\n//  }\n//  }\n\n// int64_t rangeSum(int i, int j) {\n// return (i == 0) ? preSum[j] : preSum[j] - preSum[i - 1];\n//  }\n\n//  int64_t getCost(const std::vector<int>& v, int64_t st, int64_t en, int64_t mid) { \n//      int64_t costLeft = (v[mid] * static_cast<int64_t>(mid - st + 1)) - rangeSum(st, mid);\n// int64_t costRight = rangeSum(mid, en) - (v[mid] * static_cast<int64_t>(en - mid + 1));\n// return costLeft + costRight;\n// }\n\n//     int64_t costEq(const std::vector<int>& v, int64_t k) {\n//         int64_t n = v.size();\n//         int64_t ptr1 = 0, ptr2 = k - 1, cost = 1e18;\n//         for (; ptr2 < n; ptr2++, ptr1++) {\n//             if ((ptr2 - ptr1 + 1) % 2 == 1) {\n//                 cost = std::min(cost, getCost(v, ptr1, ptr2, (ptr1 + ptr2) / 2));\n//             } else {\n//                 cost = std::min({cost, getCost(v, ptr1, ptr2, (ptr1 + ptr2) / 2), getCost(v, ptr1, ptr2, (ptr1 + ptr2) / 2 + 1)});\n//             }\n//         }\n//         return cost;\n//     }\n\n//     int maxFrequencyScore(std::vector<int> v, int64_t k) {\n//         std::sort(v.begin(), v.end());\n//         int n = v.size();\n//         int ptr1 = 1, ptr2 = n;\n//         calcPresum(v);\n//         while (ptr1 < ptr2) {\n//             int mid = ptr1 + (ptr2 - ptr1 + 1) / 2;\n//             if (costEq(v, mid) <= k) {\n//                 ptr1 = mid;\n//             } else {\n//                 ptr2 = mid - 1;\n//             }\n//         }\n//         return ptr1;\n//     }\n// };\n\nclass Solution4433 {\npublic:\n    int reverse(int x) {\n        int r;int rev=0;\n        while(x!=0){\n            r=x%10;\n            if(rev>(INT_MAX)/10 || rev<(INT_MIN)/10){\n                return 0;\n            }\n            else{\n            rev=(rev*10)+r;\n            }\n            \n            x=x/10;\n        }\n        return rev;\n    }\n};\nclass Solution90908773 {\npublic:\n   \n    vector<int> findIntersectionValues(vector<int>& nums1, vector<int>& nums2) {\n        vector<int>ans;\n        map<int,int>mp1;\n        map<int,int>mp2;\n        for(auto it:nums1){\n            mp1[it]++;\n        }\n         for(auto it:nums2){\n            mp2[it]++;\n        }\n        \n        int c1=0;\n        for(int i=0;i<nums1.size();i++){\n            if(mp2.find(nums1[i])!=mp2.end()){\n            c1++;\n        }\n        }\n        ans.push_back(c1);\n        int c2=0;\n        for(int i=0;i<nums2.size();i++){\n            if(mp1.find(nums2[i])!=mp1.end()){\n            c2++;\n        }\n        }\n        ans.push_back(c2);\n        return ans;\n    }\n};\nclass Solution23 {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int n=s.length();\n        int i=0;\n        int j=0;\n        unordered_map<char,int>mp;\n        int ans=0;\n        while(j<s.length()){\n            mp[s[j]]++;\n            while(mp[s[j]]>1){\n                mp[s[i]]--;\n                i++;\n            }\n            ans=max(ans,j-i+1);\n            j++;\n        }\n        return ans;\n    }\n};\nstruct FR {\n    FR(const std::string& s, int r = 0): rating(r), food(s) {}\n    bool operator< (const FR& other) const { \n        return rating < other.rating || (rating == other.rating && food > other.food); \n    }\n    std::string food;\n    int rating;\n};\nclass Solutio32n {\npublic:\n    long long incremovableSubarrayCount(vector<int>& nums) {\n         long long n = nums.size();\n\n        auto binary_search = [&](long long start, long long x) {\n            long long l = start, r = n - 1;\n            if (nums[r] <= x) {\n                return n;\n            }\n            while (l < r) {\n                long long mid = l + (r - l) / 2;\n                if (nums[mid] > x) {\n                    r = mid;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            return l;\n        };\n\n        long long p2 = n - 2;\n        while (p2 >= 0 && nums[p2] < nums[p2 + 1]) {\n            p2 -= 1;\n        }\n        p2 += 1;\n\n        long long res = 0;\n        for (long long i = 0; i < n; ++i) {\n            if (i > 1 && nums[i - 1] <= nums[i - 2]) {\n                break;\n            }\n            long long x = (i == 0) ? -1 : nums[i - 1];\n            long long idx = binary_search(p2, x);\n            if (idx <= i) {\n                idx = i + 1;\n            }\n            res += n - idx + 1;\n        }\n\n        return res;\n    }\n};\nclass Solution73488743784 {\npublic:\n    int maximumLength(string s) {\n         int ans = 0;\n        std::vector<std::vector<int>> freq(26);\n\n        for (int i = 0; i < s.length(); i++) {\n            int j = i;\n            while (j < s.length() && s[j] == s[i]) {\n                j++;\n            }\n            freq[s[i] - 'a'].push_back(j - i);\n            i = j - 1;\n        }\n\n        for (auto& x : freq) {  // Remove const from here\n            if (x.empty()) continue;\n            std::sort(x.begin(), x.end());\n            int sz = x.size();\n            ans = std::max(ans, x[sz - 1] - 2);\n            if (sz > 1) {\n                ans = std::max(ans, std::min(x[sz - 1] - 1, x[sz - 2]));\n            }\n            if (sz > 2) {\n                ans = std::max(ans, x[sz - 3]);\n            }\n        }\n\n        if (ans == 0) ans = -1;\n        return ans;\n    }\n};\nclass FoodRatings {\npublic:\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\n        for (int i = 0; i < foods.size(); ++i) {\n            m_crs.try_emplace(foods[i], ratings[i], cuisines[i]);\n            m_food[cuisines[i]].insert(FR(foods[i], ratings[i]));\n        }\n    }\n    \n    void changeRating(string food, int newRating) {\n        auto [rating, cuisine] = m_crs.at(food);\n        if (rating != newRating) {\n            m_food[cuisine].erase(FR(food, rating));\n            m_food[cuisine].insert(FR(food, newRating));\n            m_crs.at(food).first = newRating;\n        }\n    }\n    \n    string highestRated(string cuisine) {\n        return m_food[cuisine].crbegin()->food;\n    }\nprivate:\n    std::unordered_map<std::string, std::set<FR>> m_food;\n    std::unordered_map<std::string, std::pair<int, std::string>> m_crs;\n};\nclass Solution {\npublic:\n    int minChanges(vector<int>& nums, int k) {\n        map<int,vector<int>> m;\n        vector<int> v;\n        for(int i = 0;i<nums.size()/2;i++){\n            int a = nums[i],b = nums[nums.size()-i-1];\n            int diff = abs(a-b);\n            int X = max({a,b,k-a,k-b});\n            m[diff].push_back(X);\n            v.push_back(X);\n        }\n        int ans = nums.size();\n        sort(v.begin(),v.end());\n       \n        for(auto &val:m){\n\n            int diff = val.first;\n            int T = lower_bound(v.begin(),v.end(),diff)-v.begin();\n            T = T*2+(nums.size()/2-T);\n\n            for(auto &X:val.second){\n                if(X<diff){\n                    T-=2;\n                }\n                else{\n                    T-=1;\n                }\n            }\n\n            ans = min(ans,T);\n\n        }\n\n        return ans;\n        \n    }\n};\nclass Solution87548754 {\npublic:\n    int minimumArrayLength(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int n = nums.size();\n        \n        if(n>2 && nums[0]!=nums[1])return 1;\n        \n         int gcd = nums[0];\n        for(auto i:nums){\n            gcd = __gcd(gcd,i);\n        }\n        \n        int cnt = 0;\n        for(auto i:nums)if(i == gcd)cnt++;\n        \n        return max(1,(cnt+1)/2);\n    }\n};\nclass lavdakabaal {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        //to find the longest common substring\n        //brute force approach\n        //between two string then other strings\n        if(strs.size()==0 )return \"\";\n        if(strs.size()==1)return strs[0];\n\n       string arr=strs[0];\n       for(int i=1;i<strs.size();i++){\n           string temp=\"\";\n           int t1=0;\n           int t2=0;\n           while(t1<arr.size() && t2<strs[i].size()){\n               if(arr[t1]==strs[i][t2]){\n                   temp+=arr[t1];\n                   t1++;\n                   t2++;\n               }\n               else{\n                   break;\n               }\n           }\n           arr=temp;\n       }\n       return arr;\n    }\n};\nclass tumjochutiyaho {\npublic:\n    struct node{\n        vector<node*> arr = vector<node*>(26,nullptr);\n        bool end;\n    };\n    void get(node* root,string str,int index){\n        if(index == str.size()){\n            root->end = true;\n            return ;\n        }\n        if(!root->arr[str[index]-'a'])\n        root->arr[str[index]-'a'] = new node();\n        get(root->arr[str[index]-'a'],str,index+1);\n    }\n    int find(node* root){\n        node* a = NULL;\n        for(int i=0;i<26;i++){\n            if(root->arr[i]){\n                if(!a)a = root->arr[i];\n                else return 0;\n            }\n        }\n        if(!a)return 0;\n        if(a->end)return 1;\n        return find(a)+1;\n    }\n    string longestCommonPrefix(vector<string>& strs) {\n        node* root = new node();\n        for(int i=0;i<strs.size();i++){\n            if(strs[i].size()){\n                if(!root->arr[strs[i][0]-'a']){\n                    root->arr[strs[i][0]-'a'] = new node();\n                }\n                get(root->arr[strs[i][0]-'a'],strs[i],1);\n            }\n            else{\n                return \"\";\n            }\n        }\n        int a = find(root);\n        return strs[0].substr(0,a);\n    }\n};\nclass yehbhifaltuhai {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        //cheapest price within k stops\n        //express everything in terms of the fligh itself\n        vector<int>dist(n,1e8);\n        dist[src]=0;\n        queue<pair<pair<int,int>,int>>q;\n        q.push({{0,src},0});\n        vector<pair<int,int>>adj[n];\n        for(int i=0;i<flights.size();i++){\n            int u=flights[i][0];\n            int v=flights[i][1];\n            int w=flights[i][2];\n            adj[u].push_back({v,w});\n        }\n        while(!q.empty()){\n            auto top=q.front();\n            q.pop();\n            int stops=top.first.first;\n            int node=top.first.second;\n            int dis=top.second;\n            \n            if(stops>k)continue;\n            \n            for(auto it:adj[node]){\n                if(it.second+dis<dist[it.first]){\n                    dist[it.first]=it.second+dis;\n                    q.push({{stops+1,it.first},dist[it.first]});\n                }\n            }\n        }\n        if(dist[dst]==1e8)return -1;\n        return dist[dst];\n    }\n};\n\n\n",
    "submit_ts": "1721488214",
    "subm_id": "1327415176"
}