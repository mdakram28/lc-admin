{
    "username": "aryabhatta0",
    "submission": "class Solution {\npublic:\n    int n, m;\n    vector<vector<int>> adj1, adj2;\n    vector<int> depth;\n\n    void dfs(int node, int par, vector<vector<int>>& adj) {\n        depth[node] = (par == -1) ? 0 : depth[par] + 1;\n        for (auto v : adj[node]) {\n            if (v != par) {\n                dfs(v, node, adj);\n            }\n        }\n    }\n\n    int treeDiameter(vector<vector<int>>& adj) {\n        int n = adj.size();\n        depth.resize(n, -1);\n        \n        // Initial DFS to find the farthest node from node 0\n        dfs(0, -1, adj);\n        int farthestNode = 0;\n        for (int i = 0; i < n; ++i) {\n            if (depth[i] > depth[farthestNode]) {\n                farthestNode = i;\n            }\n        }\n\n        // Second DFS from the farthest node found in the first DFS\n        dfs(farthestNode, -1, adj);\n        int diameter = 0;\n        for (int i = 0; i < n; ++i) {\n            diameter = max(diameter, depth[i]);\n        }\n        return diameter;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        n = edges1.size() + 1;\n        m = edges2.size() + 1;\n        \n        adj1.resize(n);\n        adj2.resize(m);\n        \n        for (const auto& edge : edges1) {\n            adj1[edge[0]].push_back(edge[1]);\n            adj1[edge[1]].push_back(edge[0]);\n        }\n        \n        for (const auto& edge : edges2) {\n            adj2[edge[0]].push_back(edge[1]);\n            adj2[edge[1]].push_back(edge[0]);\n        }\n        \n        int diameter1 = treeDiameter(adj1);\n        int diameter2 = treeDiameter(adj2);\n        cout << diameter1 << \" \" << diameter2 << \"\\n\";\n        \n        return max((diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1, max(diameter1, diameter2));\n    }\n};",
    "submit_ts": 1719719490.0
}