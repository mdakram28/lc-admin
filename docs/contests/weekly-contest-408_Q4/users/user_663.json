{
    "username": "Dev_sharma23",
    "submission": "public class Solution {\n        class pair{\n            int a;\n            int b;\n            public pair(int a,int b){\n                this.a=a;\n                this.b=b;\n            }\n\n        }\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        return solve(X, Y, circles);\n        \n    }\n\n    private boolean solve(int X, int Y, int[][] c) {\n        HashMap<Integer,Integer>map=new HashMap<>();\n        int nc = c.length; // Number of circles\n        List<List<Integer>> gr = new ArrayList<>(nc + 4);\n\n        for (int i = 0; i < nc + 4; i++) {\n            gr.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < nc; i++) {\n            int[] circle = c[i];\n\n            // Check for the boundary conditions\n            if (circle[0] <= circle[2]) {  // Left boundary\n                gr.get(nc).add(i);\n                gr.get(i).add(nc);\n            }\n            if (X - circle[0] <= circle[2]) { // Right boundary\n                gr.get(nc + 2).add(i);\n                gr.get(i).add(nc + 2);\n            }\n            if (circle[1] <= circle[2]) {  // Bottom boundary\n                gr.get(nc + 1).add(i);\n                gr.get(i).add(nc + 1);\n            }\n            if (Y - circle[1] <= circle[2]) { // Top boundary\n                gr.get(nc + 3).add(i);\n                gr.get(i).add(nc + 3);\n            }\n\n            \n            for (int j = i + 1; j < nc; ++j) {\n                int[] otherCircle = c[j];\n                double dist = Math.sqrt(Math.pow(circle[0] - otherCircle[0], 2) + Math.pow(circle[1] - otherCircle[1], 2));\n                int radSum = circle[2] + otherCircle[2];\n\n                if (radSum >= dist) {\n                    gr.get(i).add(j);\n                    gr.get(j).add(i);\n                }\n            }\n        }\n        HashSet<Boolean>set=new HashSet<>();\n\n        // Check if there's a path that blocks\n        int isBlocked = 0;\n        isBlocked = Math.max(isBlocked, bfs(gr, nc, nc + 1, nc + 2, nc + 4));\n        isBlocked = Math.max(isBlocked, bfs(gr, nc + 3, nc + 2, nc + 1, nc + 4));\n\n        return isBlocked == 0; \n    }\n\n    private int bfs(List<List<Integer>> g, int s, int t1, int t2, int n) {\n        Queue<Integer> q = new LinkedList<>();\n        boolean[] vis = new boolean[n + 4];\n\n        q.add(s);\n        vis[s] = true;\n\n        while (!q.isEmpty()) {\n            int u = q.poll();\n\n            for (int v : g.get(u)) {\n                if (!vis[v]) {\n                    q.add(v);\n                    vis[v] = true;\n                }\n            }\n        }\n\n    if(vis[t1] || vis[t2])return 1;\n    return 0;\n    }\n}",
    "submit_ts": "1722138524",
    "subm_id": "1335792944"
}