{
    "username": "jcoves",
    "submission": "\n#ifdef LOCAL_RUN\n#include \"debug_leet.h\"\n    #else\n    #define trace(...) ;\n    #define dbg(...) ;\n    #define debug(x) ;\n    #define debuga(a, n) ;\n    #define debug2(x, y) ;\n    #define debug3(x, y, z) ;\n    #define debug4(x, y, z, w) ;\n    #define debug5(a,b,c,d,e) ;\n    #define ctime() ;\n    #define lassert(x) ;\n    #define dassert(x, ...) ;\n    int recur_depth = 0; bool rec_indent = true;\n    const bool isLocal = false;\n    template <typename Arg, typename... Args>\n    void display(TreeNode* root) {}\n    #endif\n\n    #define pb push_back\n    #define eb emplace_back\n    #define popb pop_back\n    #define all(v) begin(v), end(v)\n    #define rall(v) (v).rbegin(),(v).rend()\n    #define make_unique(v) (v).erase(unique(all(v)), (v).end())\n    #define sz(c) ((int) c.size())\n    #define forn(i,n) for(int i=0;i<(int)(n);i++)\n    #define fornn(i,s,n) for(int i=s;i<(int)(n);i++)\n    #define forb(i,n) for(int i=n-1;i>=0;i--)\n    #define forbn(i,s,n) for(int i=n-1;i>=(int)(s);i--)\n    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n    #define mem(a,b) memset(a,b,sizeof(a))\n    #define abs(x) (((x) < 0) ? -(x) : (x))\n    #define sqr(x) ((x) * (x))\n    #define sqrt(x) sqrt(abs(x))\n    #define has(c,x) (c.find(x) != c.end())\n    #define pw(x) (1LL << (x))\n    #define ibit(x,i) (((x) >> (i)) & 1)\n    #define data(v) v.data(), sz(v) // vi -> vai\n\n    typedef stringstream sstr;\n    typedef long long ll;\n    typedef long double ld;\n    typedef pair<int, int> pii;\n    typedef pair<ll,ll> pll;\n    typedef pair<ld,ld> pdd;\n    typedef vector<int> vi;\n    typedef vector<ll> vll;\n    typedef vector<pii> vpii;\n    typedef vector<vi> vvi;\n    typedef vector<vll> vvll;\n    typedef valarray<int> vai;\n    template <class T>\n    using min_pq = priority_queue<T, vector<T>, greater<T>>;\n    template <class T>\n    using vc = vector<T>;\n    template <class T>\n    using vvc = vector<vc<T>>;\n    template <class T>\n    using vvvc = vector<vvc<T>>;\n    template <class T>\n    using vvvvc = vector<vvvc<T>>;\n    template <class T>\n    using vvvvvc = vector<vvvvc<T>>;\n\n    template<class F>\n    struct y_comb{\n        F f;\n        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }\n        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }\n    };\n    template<class F>\n    decltype(auto) yf(F &&f){\n        return y_comb<decay_t<F>>(forward<F>(f));\n    }\n\n    inline int ni(){ int x; cin >> x;   return x; }\n    inline ll  nl() { ll  x; cin >> x; return x; }\n\n    template <class T> void mmin(T& a, const T& b) {\n        a = (a) < (b) ? (a) : (b);\n    }\n    template <class T> void mmax(T& a, const T& b) {\n        a = (a) > (b) ? (a) : (b);\n    }\n    template <class T> auto vv(int d1, T x){\n        return vc<T>(d1, x);\n    }\n    template <class T> auto vv(int d1, int d2, T x){\n        return vc<vc<T>>(d1, vc<T>(d2, x));\n    }\n    template <class T> auto vv(int d1, int d2, int d3, T x){\n        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));\n    }\n    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){\n        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));\n    }\n    void outv(auto &v){\n        for(auto &x: v) {cout<< x <<\" \";} cout<<endl;\n    }\n    void rvec(int &n, auto &v){\n        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);\n    }\n    template <typename Arg, typename... Args>\n    void read(Arg&& arg, Args&&... args){\n        cin >> std::forward<Arg>(arg); using expander = int[];\n        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};\n    }\n    template <typename Arg, typename... Args>\n    void out(Arg&& arg, Args&&... args){\n        cout << std::forward<Arg>(arg); using expander = int[];\n        (void)expander{0, (void(cout << \" \" << std::forward<Args>(args)),0)...};\n        cout << endl;\n    }\n    template <class Integer, class F>\n    Integer find_first_false(Integer l, Integer r, F&& f) {\n        --l; // ++r;\n        while (r - l > 1) {\n            Integer m = midpoint(l, r);\n            if (f(m)) l = m;\n            else r = m;\n        }\n        return r;\n    }\n    template <class Integer, class F>\n    Integer find_first_true(Integer l, Integer r, F &&f) {\n        return find_first_false(l, r, [&f](Integer i) { return !f(i); });\n    }\n    auto init = []() {\n        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';\n    }();\n\n    ll pwr(ll base, ll p, ll mod){\n        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;\n            base=(base*base)%mod; p/=2;}\n        return ans;\n    }\n    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }\n    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }\n\n    const long double PI = (long double)(3.1415926535897932384626433832795);\n    const ll  mx_ll   = numeric_limits<ll> :: max();\n    const int mx_int  = numeric_limits<int> :: max();\n\n    const int oo = 0x3f3f3f3f;\n    const ll  OO = 0x3f3f3f3f3f3f3f3fll;\n    const double eps = 1e-9;\n    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};\n    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};\n\nconst int maxn = 1e5 + 3;\nconst int mod = 1e9+7;\nconst int opSum=0, opMax=1, opMin=2, opAnd=3, opOr=4, opXor=5, opGcd=6;\n    template<class T> struct Seg {\n        vector<T> t;\n        int n;\n        T neutral;\n        vector<T> neutrals = {\n            0, // sum\n            numeric_limits<T>::min(), // max\n            numeric_limits<T>::max(), // min\n            -1, // and\n            0, // or\n            0, // xor\n            0 // gcd\n        };\n        const int op;\n        T merge(T a, T b) {\n            switch(op) {\n                case 0: return a + b;\n                case 1: return max(a, b);\n                case 2: return min(a, b);\n                case 3: return a & b;\n                case 4: return a | b;\n                case 5: return a ^ b;\n                case 6: return gcd(a, b);\n            }\n            assert(0);\n            return T();\n        }\n        int operator [] (int i) {\n            lassert(t[i + n] == query(i, i));\n            return t[i + n];\n        }\n        void update(int p, const T x) {\n            for (t[p += n] = x; p >>= 1; ) t[p] = merge(t[p<<1], t[p<<1|1]);\n        }\n        T query(int l, int r) {\n            T ansl = neutral;\n            T ansr = neutral;\n            for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {\n                if (l & 1) ansl = merge(ansl, t[l++]);\n                if (r & 1) ansr = merge(t[--r], ansr);\n            }\n            return merge(ansl, ansr);\n        }\n        Seg(int _n, int _op) : n(_n), op(_op) {\n            neutral = neutrals[op];\n            t.assign(n << 1, neutral);\n        }\n        Seg(vector<T> &a, int _op) : n(sz(a)), op(_op) {\n            neutral = neutrals[op];\n            // if(isLocal) forn(i, 10) {T x = T(rng()); assert(x == merge(x, neutral) && x == merge(neutral, x));}\n            t.assign(n << 1, neutral);\n            forn(i, n) t[i + n] = a[i];\n            forb(i, n) t[i] = merge(t[i << 1], t[i << 1 | 1]);\n        }\n        vector<T> vals(){\n            vector<T> ans;\n            forn(i, n) ans.pb(query(i, i));\n            return ans;\n        }\n        int right_most(int l, int r, auto pass){ // max id in [l,r]: func(query(id, r)) = true\n            if(l == n) return n;\n            int lo = l, hi = min(r, n-1);\n            if(!pass(query(lo, lo))) return -1; // entire range is bad\n            if(pass(query(lo, hi))) return hi;\n            while(lo < hi){\n                int mid = (lo + hi + 1) / 2;\n                if(pass(query(l, mid))) lo = mid;\n                else hi = mid-1;\n            }\n            lassert(pass(query(l, hi)));\n            lassert(!pass(query(l, hi+1)));\n            return hi;\n        }\n        int left_most(int l, int r, auto pass){ // min id in [l,r]: func(query(l, id)) = true\n            if(l == n) return n;\n            int lo = l, hi = min(r, n-1);\n            if(pass(query(lo, lo))) return lo;\n            if(!pass(query(lo, hi))) return n; // entire range is bad\n            while(lo < hi){\n                int mid = (lo + hi + 0) / 2;\n                if(pass(query(l, mid))) hi = mid;\n                else lo = mid+1;\n            }\n            lassert(pass(query(l, lo)));\n            lassert(!pass(query(l, lo-1)));\n            return lo;\n        }\n    };\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& a, int k) {\n        int n = sz(a);\n        Seg<int> seg(a, opAnd);\n        int ans = oo;\n        forn(i, n){\n            mmin(ans, abs(a[i] - k));\n            if(a[i] < k) continue;\n            int r = seg.right_most(i, n-1, [&](int res){ return res >= k; });\n            mmin(ans, abs(seg.query(i, r) - k));\n            if(r+1 < n) {\n                mmin(ans, abs(seg.query(i, r+1) - k));\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1717297392.0
}