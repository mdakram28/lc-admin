{
    "username": "CuriousJianXu",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def bfs_farthest_node(start, edge_list, adj_list):  \n            n = len(edge_list)+1\n            visited = set()\n            dist = [0] * n\n            queue = deque([start])\n            visited.add(start)\n            farthest_node = start\n            while queue:\n                cur = queue.popleft()\n                for nei in adj_list[cur]:\n                    if nei not in visited:\n                        visited.add(nei)\n                        dist[nei] = dist[cur] + 1\n                        queue.append(nei)\n                        farthest_node = nei\n            return farthest_node, dist[farthest_node]\n            \n        \n        def get_tree_diameter(edge_list):\n            adj_list = defaultdict(list)\n            for u, v in edge_list:\n                adj_list[u].append(v)\n                adj_list[v].append(u)\n                \n            first_node, _ = bfs_farthest_node(0, edge_list, adj_list)\n            second_node, diameter = bfs_farthest_node(first_node, edge_list, adj_list)\n            return diameter\n        \n        \n        diameter_a = get_tree_diameter(edges1)\n        diameter_b = get_tree_diameter(edges2)\n        a_side = int(ceil(diameter_a/2))\n        b_side = int(ceil(diameter_b/2))\n        return max(diameter_a, diameter_b, a_side+b_side+1)",
    "submit_ts": 1719718798.0
}