{
    "username": "Positron23",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        n = len(edges1) + 1\n        m = len(edges2) + 1\n        adj_list1 = [[] for i in range(n)]\n        adj_list2 = [[] for i in range(m)]\n\n        for u, v in edges1:\n            adj_list1[u].append(v)\n            adj_list1[v].append(u)\n        for u, v in edges2:\n            adj_list2[u].append(v)\n            adj_list2[v].append(u)\n        \n        def get_diameter_of_tree(adj_list):\n            def get_furthest_with_bfs(start_node):\n                queue = collections.deque()\n                queue.append((start_node, 0))\n                furthest_node, furthest_dist = start_node, 0\n                visited = set()\n                while queue:\n                    node, dist = queue.popleft()\n                    visited.add(node)\n                    if dist > furthest_dist:\n                        furthest_node, furthest_dist = node, dist\n                    for neighbour in adj_list[node]:\n                        if neighbour not in visited:\n                            queue.append((neighbour, dist + 1))\n                return furthest_node, furthest_dist\n            \n            fn1, fd1 = get_furthest_with_bfs(0)\n            fn2, fd2 = get_furthest_with_bfs(fn1)\n            return fd2\n\n        diam1 = get_diameter_of_tree(adj_list1)\n        diam2 = get_diameter_of_tree(adj_list2)\n\n        radius1 = (diam1 + 1) // 2\n        radius2 = (diam2 + 1) // 2\n    \n        return max(diam1, diam2, radius1 + radius2 + 1)",
    "submit_ts": 1719716700.0
}