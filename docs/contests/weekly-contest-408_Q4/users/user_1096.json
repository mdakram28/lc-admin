{
    "username": "pramana",
    "submission": "using ll = long long;\n\nclass DSU {\n  private:\n\tvector<int> parents;\n\tvector<int> sizes;\n\n  public:\n    vector<vector<bool>> intersect = vector<vector<bool>>(4, vector<bool>());\n\tDSU(int size) : parents(size), sizes(size, 1) {\n\t\tfor (int i = 0; i < size; i++) { \n            parents[i] = i; \n            intersect[0] = vector<bool>(size, false);\n            intersect[1] = vector<bool>(size, false);\n            intersect[2] = vector<bool>(size, false);\n            intersect[3] = vector<bool>(size, false);\n        }\n\t}\n\n\t/** @return the \"representative\" node in x's component */\n\tint find(int x) {\n\t\treturn parents[x] == x ? x : (parents[x] = find(parents[x]));\n\t}\n\n\t/** @return whether the merge changed connectivity */\n\tbool unite(int x, int y) {\n\t\tint x_root = find(x);\n\t\tint y_root = find(y);\n\t\tif (x_root == y_root) { return false; }\n\n\t\tif (sizes[x_root] < sizes[y_root]) { swap(x_root, y_root); }\n\t\tsizes[x_root] += sizes[y_root];\n        for (int i = 0; i < 4; ++i) {\n            intersect[i][x_root] = intersect[i][x_root] | intersect[i][y_root];\n        }\n\t\tparents[y_root] = x_root;\n\t\treturn true;\n\t}\n\n\t/** @return whether x and y are in the same connected component */\n\tbool connected(int x, int y) { return find(x) == find(y); }\n};\n\nclass Solution {\npublic:\n    ll d(ll x, ll y, ll X, ll Y) {\n        return (x-X) * (x-X) + (y-Y)*(y-Y);\n    }\n\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n        DSU u = DSU(n);\n        \n        for (int i = 0; i < n; ++i) {\n            ll x = circles[i][0];\n            ll y = circles[i][1];\n            ll r = circles[i][2];\n\n            if ((d(x,y,0LL,0LL) <= r*r) || d(x,y,X,Y) <= r*r) return false;\n\n            if (y >= 0 && y <= Y) {\n                if (abs(x) <= r) {\n                    u.intersect[0][i] = true;\n                } \n                if (abs(x-X) <= r) {\n                    u.intersect[2][i] = true;\n                }\n            } else {\n                if ((y - Y) * (y - Y) + x * x <= r * r) {\n                    u.intersect[0][i] = true;\n                    u.intersect[2][i] = true;\n                }\n            }\n\n            if (x >= 0 && x <= X) {\n                if (abs(y) <= r) {\n                    u.intersect[3][i] = true;\n                } \n                if (abs(y-Y) <= r) {\n                    u.intersect[1][i] = true;\n                }\n            } else {\n                if ((x - X) * (x - X) + y * y <= r * r) {\n                    u.intersect[3][i] = true;\n                    u.intersect[1][i] = true;\n                }\n            }\n            cout << u.intersect[0][i] << \" \" << u.intersect[1][i] << \" \" << u.intersect[2][i] << \" \" << u.intersect[3][i] << \"\\n\";\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                ll x1 = circles[i][0];\n                ll y1 = circles[i][1];\n                ll r1 = circles[i][2];\n\n                ll x2 = circles[j][0];\n                ll y2 = circles[j][1];\n                ll r2 = circles[j][2];\n\n                if (d(x1,y1,x2,y2) <= (r1 + r2) * (r1 + r2)) {\n                    // cout << d(x1,y1,x2,y2) << \" \" << i << \" \" << j << \"\\n\";\n                    u.unite(i,j);\n                }\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            int p = u.find(i);\n            if ((u.intersect[0][p] && u.intersect[3][p]) \n                || (u.intersect[0][p] && u.intersect[2][p])\n                || (u.intersect[1][p] && u.intersect[2][p])\n                || (u.intersect[1][p] && u.intersect[3][p])) {\n                    return false;\n            }\n        }\n\n        return true;\n    }\n};",
    "submit_ts": "1722138369",
    "subm_id": "1335789020"
}