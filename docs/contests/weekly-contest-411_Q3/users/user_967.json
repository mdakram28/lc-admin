{
    "username": "daradaaryan",
    "submission": "// class Solution {\n// public:\n//     string largestPalindrome(int n, int k) {\n//         // Handle the single-digit case separately\n//         if (n == 1) {\n//             for (int i = 9; i >= 1; --i) {\n//                 if (i % k == 0) return to_string(i);\n//             }\n//         }\n        \n//         // Generate the largest possible first half\n//         string half = string((n + 1) / 2, '9');\n        \n//         while (true) {\n//             // Create the palindrome\n//             string palindrome = half + string(half.rbegin() + (n % 2), half.rend());\n            \n//             // Convert to long long and check divisibility\n//             long long num = stoll(palindrome);\n//             if (num % k == 0) return palindrome;\n            \n//             // Decrease the half and rebuild the palindrome\n//             if (!decreaseHalf(half)) break;\n//         }\n        \n//         return \"-1\"; // No valid palindrome found\n//     }\n    \n// private:\n//     bool decreaseHalf(string& half) {\n//         int len = half.size();\n//         for (int i = len - 1; i >= 0; --i) {\n//             if (half[i] > '0') {\n//                 half[i]--;\n//                 fill(half.begin() + i + 1, half.end(), '9');\n//                 return true;\n//             }\n//         }\n//         return false;\n//     }\n// };\n\n\n// class Solution {\n// public:\n//     string largestPalindrome(int n, int k) {\n//         if (n == 1) {\n//             for (int i = 9; i >= 1; --i) {\n//                 if (i % k == 0) return to_string(i);\n//             }\n//             return \"-1\";\n//         }\n\n//         // Maximum number represented by the first half\n//         long long high = pow(10, (n + 1) / 2) - 1;\n//         long long low = pow(10, (n - 1) / 2);\n        \n//         for (long long half = high; half >= low; --half) {\n//             // Create the palindrome\n//             string halfStr = to_string(half);\n//             string palindromeStr = halfStr + string(halfStr.rbegin() + (n % 2), halfStr.rend());\n            \n//             // Convert to long long and check divisibility\n//             long long palindrome = stoll(palindromeStr);\n//             if (palindrome % k == 0) {\n//                 return palindromeStr;\n//             }\n//         }\n\n//         return \"-1\";\n//     }\n// };\n\n\n// class Solution {\n// public:\n//     string largestPalindrome(int n, int k) {\n//         if (n == 1) {\n//             for (int i = 9; i >= 1; --i) {\n//                 if (i % k == 0) return to_string(i);\n//             }\n//             return \"-1\";\n//         }\n\n//         // Maximum half: starts with 999...9 (half length)\n//         long long maxHalf = pow(10, (n + 1) / 2) - 1;\n//         long long minHalf = pow(10, (n - 1) / 2);\n\n//         for (long long half = maxHalf; half >= minHalf; --half) {\n//             // Form the palindrome\n//             string halfStr = to_string(half);\n//             string palindromeStr = halfStr + string(halfStr.rbegin() + (n % 2), halfStr.rend());\n\n//             long long palindrome = stoll(palindromeStr);\n//             if (palindrome % k == 0) {\n//                 return palindromeStr;\n//             }\n//         }\n\n//         return \"-1\";\n//     }\n// };\n\n\n// class Solution {\n// public:\n//     string largestPalindrome(int n, int k) {\n//         if (n == 1) {\n//             for (int i = 9; i >= 1; --i) {\n//                 if (i % k == 0) return to_string(i);\n//             }\n//             return \"-1\";\n//         }\n\n//         string palindrome;\n        \n//         // Construct palindrome based on k\n//         switch (k) {\n//             case 2:\n//                 palindrome = buildPalindrome(n, '8', '8');\n//                 break;\n//             case 3:\n//                 palindrome = buildPalindrome(n, '9', '9');\n//                 break;\n//             case 4:\n//                 palindrome = buildPalindrome(n, '8', '8');\n//                 break;\n//             case 5:\n//                 palindrome = buildPalindrome(n, '9', '5');\n//                 break;\n//             case 6:\n//                 palindrome = buildPalindrome(n, '9', '8'); // Sum divisible by 3 and ends with an even number\n//                 break;\n//             case 7:\n//                 palindrome = buildPalindrome(n, '9', '9');\n//                 break;\n//             case 8:\n//                 palindrome = buildPalindrome(n, '8', '8');\n//                 break;\n//             case 9:\n//                 palindrome = buildPalindrome(n, '9', '9');\n//                 break;\n//             default:\n//                 return \"-1\";\n//         }\n\n//         // Convert palindrome string to number and check divisibility\n//         long long num = stoll(palindrome);\n//         if (num % k == 0) {\n//             return palindrome;\n//         }\n\n//         // If not divisible, try decrementing\n//         while (decrementPalindrome(palindrome)) {\n//             num = stoll(palindrome);\n//             if (num % k == 0) {\n//                 return palindrome;\n//             }\n//         }\n\n//         return \"-1\";\n//     }\n\n// private:\n//     string buildPalindrome(int n, char start, char end) {\n//         string half = string((n + 1) / 2, start);\n//         if (n % 2 == 0) {\n//             half.back() = end;\n//         }\n//         string palindrome = half + string(half.rbegin() + (n % 2), half.rend());\n//         return palindrome;\n//     }\n\n//     bool decrementPalindrome(string &palindrome) {\n//         int len = palindrome.size();\n//         int halfLen = (len + 1) / 2;\n\n//         // Decrement the first half\n//         for (int i = halfLen - 1; i >= 0; --i) {\n//             if (palindrome[i] > '0') {\n//                 palindrome[i]--;\n//                 fill(palindrome.begin() + i + 1, palindrome.begin() + halfLen, '9');\n//                 break;\n//             }\n//         }\n\n//         // Mirror the first half to the second half\n//         for (int i = 0; i < len / 2; ++i) {\n//             palindrome[len - 1 - i] = palindrome[i];\n//         }\n\n//         // Check if the palindrome is still valid (doesn't start with 0)\n//         return palindrome[0] != '0';\n//     }\n// };\n\n// class Solution {\n// public:\n//     string largestPalindrome(int n, int k) {\n//         if (n == 1) {\n//             for (int i = 9; i >= 1; --i) {\n//                 if (i % k == 0) return to_string(i);\n//             }\n//             return \"\";\n//         }\n\n//         // Construct the largest possible palindrome\n//         string half = string((n + 1) / 2, '9');\n//         while (true) {\n//             string palindrome = buildPalindrome(half, n);\n//             long long num = stoll(palindrome);\n//             if (num % k == 0) {\n//                 return palindrome;\n//             }\n\n//             // Decrease half to find the next largest palindrome\n//             if (!decreaseHalf(half)) {\n//                 break;\n//             }\n//         }\n        \n//         return \"\";\n//     }\n\n// private:\n//     string buildPalindrome(const string& half, int n) {\n//         string palindrome = half;\n//         if (n % 2 == 0) {\n//             palindrome += string(half.rbegin(), half.rend());\n//         } else {\n//             palindrome += string(half.rbegin() + 1, half.rend());\n//         }\n//         return palindrome;\n//     }\n\n//     bool decreaseHalf(string& half) {\n//         int len = half.size();\n//         for (int i = len - 1; i >= 0; --i) {\n//             if (half[i] > '0') {\n//                 half[i]--;\n//                 fill(half.begin() + i + 1, half.end(), '9');\n//                 return true;\n//             }\n//         }\n//         return false;\n//     }\n// };\n\n// class Solution {\n// public:\n//     string largestPalindrome(int n, int k) {\n//         if (n == 1) {\n//             // Handle single-digit case directly\n//             return findSingleDigitPalindrome(k);\n//         }\n\n//         string palindrome;\n//         switch (k) {\n//             case 1:\n//                 palindrome = string(n, '9'); // For k = 1, any number is divisible by 1\n//                 break;\n//             case 2:\n//                 palindrome = generateLargestPalindromeForK2(n);\n//                 break;\n//             case 3:\n//                 palindrome = generateLargestPalindrome(n, '9', '9'); // Sum of digits divisible by 3\n//                 break;\n//             case 4:\n//                 palindrome = generateLargestPalindromeForK4(n);\n//                 break;\n//             case 5:\n//                 palindrome = generateLargestPalindrome(n, '9', '5'); // Ends with 5 or 0\n//                 break;\n//             case 6:\n//                 palindrome = generateLargestPalindromeForK6(n);\n//                 break;\n//             case 7:\n//                 palindrome = findLargestPalindromeDivisibleBy(n, 7);\n//                 break;\n//             case 8:\n//                 palindrome = generateLargestPalindromeForK8(n);\n//                 break;\n//             case 9:\n//                 palindrome = generateLargestPalindrome(n, '9', '9'); // Sum of digits divisible by 9\n//                 break;\n//             default:\n//                 return \"-1\"; // In case of unexpected k value\n//         }\n        \n//         // Return the palindrome if it's divisible by k\n//         long long num = stoll(palindrome);\n//         if (num % k == 0) {\n//             return palindrome;\n//         }\n        \n//         // If not divisible, try decrementing\n//         while (decrementPalindrome(palindrome)) {\n//             num = stoll(palindrome);\n//             if (num % k == 0) {\n//                 return palindrome;\n//             }\n//         }\n        \n//         return \"\";\n//     }\n\n// private:\n//     string findSingleDigitPalindrome(int k) {\n//         for (int i = 9; i >= 1; --i) {\n//             if (i % k == 0) {\n//                 return to_string(i);\n//             }\n//         }\n//         return \"\";\n//     }\n\n//     string generateLargestPalindrome(int n, char start, char end) {\n//         string half = string((n + 1) / 2, start);\n//         if (n % 2 == 0) {\n//             half.back() = end;\n//         }\n//         string palindrome = half + string(half.rbegin() + (n % 2), half.rend());\n//         return palindrome;\n//     }\n\n//     string generateLargestPalindromeForK2(int n) {\n//         string half = string((n + 1) / 2, '9');\n//         if (n % 2 == 1) {\n//             half[(n + 1) / 2 - 1] = '8'; // Set the middle digit to 8\n//         } else {\n//             half[(n / 2) - 1] = '8'; // Set the middle digits to '88' for even lengths\n//         }\n//         return generateLargestPalindromeFromHalf(half, n);\n//     }\n\n//     string generateLargestPalindromeForK4(int n) {\n//         string half = string((n + 1) / 2, '9');\n//         if (n % 2 == 0) {\n//             half[(n / 2) - 1] = '8'; // Adjust to make sure last two digits are '88'\n//         } else {\n//             half[(n + 1) / 2 - 1] = '8'; // Adjust the middle digit\n//         }\n//         return generateLargestPalindromeFromHalf(half, n);\n//     }\n\n//     string generateLargestPalindromeForK6(int n) {\n//         string half = string((n + 1) / 2, '9');\n//         if (n % 2 == 0) {\n//             half[(n / 2) - 1] = '8'; // Make the last digit even for divisibility by 6\n//         } else {\n//             half[(n + 1) / 2 - 1] = '8'; // Adjust the middle digit\n//         }\n//         return generateLargestPalindromeFromHalf(half, n);\n//     }\n\n//     string generateLargestPalindromeForK8(int n) {\n//         string half = string((n + 1) / 2, '9');\n//         if (n % 2 == 0) {\n//             half[(n / 2) - 1] = '8'; // Ensure last three digits are divisible by 8\n//         } else {\n//             half[(n + 1) / 2 - 1] = '8'; // Adjust middle digit for divisibility\n//         }\n//         return generateLargestPalindromeFromHalf(half, n);\n//     }\n\n//     string findLargestPalindromeDivisibleBy(int n, int k) {\n//         string half = string((n + 1) / 2, '9');\n//         while (true) {\n//             string palindrome = generateLargestPalindromeFromHalf(half, n);\n//             long long num = stoll(palindrome);\n//             if (num % k == 0) {\n//                 return palindrome;\n//             }\n//             if (!decreaseHalf(half)) {\n//                 break;\n//             }\n//         }\n//         return \"\";\n//     }\n\n//     string generateLargestPalindromeFromHalf(const string& half, int n) {\n//         string palindrome = half;\n//         if (n % 2 == 0) {\n//             palindrome += string(half.rbegin(), half.rend());\n//         } else {\n//             palindrome += string(half.rbegin() + 1, half.rend());\n//         }\n//         return palindrome;\n//     }\n\n//     bool decreaseHalf(string& half) {\n//         int len = half.size();\n//         for (int i = len - 1; i >= 0; --i) {\n//             if (half[i] > '0') {\n//                 half[i]--;\n//                 fill(half.begin() + i + 1, half.end(), '9');\n//                 return true;\n//             }\n//         }\n//         return false;\n//     }\n\n//     bool decrementPalindrome(string& palindrome) {\n//         int len = palindrome.size();\n//         string firstHalf = palindrome.substr(0, (len + 1) / 2);\n        \n//         if (!decreaseHalf(firstHalf)) return false;\n        \n//         palindrome = generateLargestPalindromeFromHalf(firstHalf, len);\n//         return true;\n//     }\n// };\n\n// class Solution {\n// public:\n//     string largestPalindrome(int n, int k) \n//     {\n//         // Special case for single-digit palindromes\n//         if (n == 1) {\n//             int largestDivisible = findLargestSingleDigit(k);\n//             return largestDivisible > 0 ? to_string(largestDivisible) : \"\";\n//         }\n\n//         // dp[i][r] will hold the largest palindrome of length i with remainder r when divided by k\n//         vector<vector<string>> dp(n + 1, vector<string>(k, \"\"));\n\n//         // Base case for 1-digit palindromes\n//         for (int d = 1; d <= 9; ++d) {\n//             int remainder = d % k;\n//             dp[1][remainder] = to_string(d);\n//         }\n\n//         // Build palindromes of increasing lengths\n//         for (int length = 2; length <= n; ++length) {\n//             unordered_map<int, string> currentPalindromes;\n//             for (int remainder = 0; remainder < k; ++remainder) {\n//                 if (!dp[(length - 1) / 2][remainder].empty()) {\n//                     for (int digit = 0; digit <= 9; ++digit) {\n//                         string newPalindrome = to_string(digit) + dp[(length - 1) / 2][remainder] + to_string(digit);\n//                         int newRemainder = (remainder * 10 + digit * (1 + (length % 2))) % k;\n//                         if (newPalindrome.size() == length) {\n//                             if (currentPalindromes.find(newRemainder) == currentPalindromes.end() || newPalindrome > currentPalindromes[newRemainder]) {\n//                                 currentPalindromes[newRemainder] = newPalindrome;\n//                             }\n//                         }\n//                     }\n//                 }\n//             }\n//             for (const auto& entry : currentPalindromes) {\n//                 dp[length][entry.first] = entry.second;\n//             }\n//         }\n\n//         // Return the largest palindrome of length n that is divisible by k\n//         return dp[n][0];\n//     }\n\n// private:\n//     int findLargestSingleDigit(int k) {\n//         return (9 / k) * k;\n//     }\n// };\n\n// #include <vector> \n// #include <string> \n// #include <algorithm> \n \n// using namespace std; \n \n// class Solution { \n// public: \n//     char dp[100001][7]; \n//     char dp_non_zero[100001][7]; \n//     int nxt_mod[100001][7]; \n//     int non_zero_nxt_mod[100001][7]; \n     \n//     string largestPalindrome(int n, int k) { \n//         if (k == 1  or k == 3  or k == 9) { \n//             return string(n, '9'); \n//         } \n         \n//         if (k == 2) { \n//             if (n == 1) { \n//                 return \"8\"; \n//             } \n//             string result(n, '9'); \n//             result[0] = '8'; \n//             result[n - 1] = '8'; \n//             return result; \n//         } \n         \n//         if (k == 5) { \n//             if (n == 1) { \n//                 return \"5\"; \n//             } \n//             string result(n, '9'); \n//             result[0] = '5'; \n//             result[n - 1] = '5'; \n//             return result; \n//         } \n \n//         if (k == 4) { \n//             if (n <= 3) { \n//                 return string(n, '8'); \n//             } \n//             string result(n, '9'); \n//             result[0] = '8'; \n//             result[n - 1] = '8'; \n//             result[1] = '8'; \n//             result[n - 2] = '8'; \n//             return result; \n//         } \n         \n//         if (k == 5) { \n//             if (n <= 5) { \n//                 return string(n, '8'); \n//             } \n//             string result(n, '9'); \n//             result[0] = '8'; \n//             result[n - 1] = '8'; \n//             result[1] = '8'; \n//             result[n - 2] = '8'; \n//             result[2] = '8'; \n//             result[n - 3] = '8'; \n//             return result; \n//         } \n         \n//         if (k == 6) { \n//             if (n == 1) { \n//                 return \"6\"; \n//             } \n//             if (n == 2) { \n//                 return \"66\"; \n//             } \n//             if (n == 3) { \n//                 return \"888\"; \n//             } \n//             string result(n, '9'); \n//             result[0] = '8'; \n//             result[n - 1] = '8'; \n//             if (n % 2 == 1) { \n//                 result[n / 2] = '8'; \n//             } else { \n//                 result[n / 2] = '7'; \n//                 result[(n / 2) - 1] = '7'; \n//             } \n//             return result; \n//         } \n \n//         if (k == 7) { \n//             if (n == 1) { \n//                 return \"7\"; \n//             } \n             \n//             fill(&dp[0][0], &dp[0][0] + sizeof(dp), 0); \n//             fill(&dp_non_zero[0][0], &dp_non_zero[0][0] + sizeof(dp_non_zero), 0); \n \n//             for (int i = 1; i < 10; ++i) { \n//                 dp[1][i % 7] = '0' + i; \n//                 if (i != 0) { \n//                     dp_non_zero[1][i % 7] = '0' + i; \n//                 } \n//             } \n \n//             int base_mod = 10 % 7; \n//             for (int i = 0; i <= 100000 - 2; ++i) { \n//                 for (int j = 0; j < 7; ++j) { \n//                     if ((i == 0 && j != 0) || (i > 0 && dp[i][j] == 0)) { \n//                         continue; \n//                     } \n//                     for (int digit = 9; digit >= 0; --digit) { \n//                         int new_mod = (base_mod * digit + digit + j * 10) % 7; \n//                         if (dp[i + 2][new_mod] == 0 || dp[i + 2][new_mod] < '0' + digit) { \n//                             dp[i + 2][new_mod] = '0' + digit; \n//                             nxt_mod[i + 2][new_mod] = j; \n//                         } \n//                         if (digit == 0) continue; \n//                         if (dp_non_zero[i + 2][new_mod] == 0 || dp_non_zero[i + 2][new_mod] < '0' + digit) { \n//                             dp_non_zero[i + 2][new_mod] = '0' + digit; \n//                             non_zero_nxt_mod[i + 2][new_mod] = j; \n//                         } \n//                     } \n//                 } \n//                 base_mod = (base_mod * 10) % 7; \n//             } \n \n//             int q = n; \n//             string front(1, dp_non_zero[q][0]); \n//             string back(1, dp_non_zero[q][0]); \n//             int mod = non_zero_nxt_mod[q][0]; \n//             q -= 2; \n//             while (q) { \n//                 front += dp[q][mod]; \n//                 if (q > 1) back += dp[q][mod]; \n//                 else break; \n//                 mod = nxt_mod[q][mod]; \n//                 q -= 2; \n//             }\n// reverse(back.begin(), back.end()); \n//             return front + back; \n//         } \n \n//         return \"\"; \n//     } \n// };\n\nclass Solution {\nprivate:\n    long long dpTable[100005][10];\n    string largestPalindromeString = \"0\";\n\n    long long calculateModularExponentiation(long long base, long long exponent, long long modulo) {\n        base %= modulo;\n        long long result = 1;\n        while (exponent) {\n            if (exponent % 2) {\n                result = result * base % modulo;\n                --exponent;\n            } else {\n                base = base * base % modulo;\n                exponent /= 2;\n            }\n        }\n        return result;\n    }\n\n    bool findLargestPalindrome(int currentIndex, int currentRemainder, long long divisor, long long totalLength, string &currentPalindrome) {\n        long long mirrorIndex = (totalLength - 1) - currentIndex;\n        if (mirrorIndex < currentIndex) {\n            if (currentRemainder != 0) return false;\n            if (currentPalindrome > largestPalindromeString) {\n                largestPalindromeString = currentPalindrome;\n            }\n            return true;\n        }\n\n        if (dpTable[currentIndex][currentRemainder] != -1) return dpTable[currentIndex][currentRemainder];\n\n        int startingDigit = (currentIndex == 0) ? 1 : 0;\n        for (int digit = 9; digit >= startingDigit; --digit) {\n            long long powerAtCurrentIndex = calculateModularExponentiation(10, currentIndex, divisor);\n            long long powerAtMirrorIndex = calculateModularExponentiation(10, mirrorIndex, divisor);\n            powerAtCurrentIndex = (powerAtCurrentIndex * digit) % divisor;\n            powerAtMirrorIndex = (powerAtMirrorIndex * digit) % divisor;\n\n            currentPalindrome[currentIndex] = currentPalindrome[mirrorIndex] = char(digit + '0');\n            if (currentIndex != mirrorIndex) powerAtCurrentIndex = (powerAtCurrentIndex + powerAtMirrorIndex) % divisor;\n\n            if (findLargestPalindrome(currentIndex + 1, (currentRemainder + powerAtCurrentIndex) % divisor, divisor, totalLength, currentPalindrome)) {\n                return dpTable[currentIndex][currentRemainder] = true;\n            }\n        }\n\n        return dpTable[currentIndex][currentRemainder] = false;\n    }\n\npublic:\n    string largestPalindrome(int numberOfDigits, int divisor) {\n        memset(dpTable, -1, sizeof(dpTable));\n        string palindrome(numberOfDigits, '0');\n        findLargestPalindrome(0, 0, divisor, numberOfDigits, palindrome);\n        return largestPalindromeString;\n    }\n};\n\n\n\n",
    "submit_ts": "1723953556",
    "subm_id": "1359824542"
}