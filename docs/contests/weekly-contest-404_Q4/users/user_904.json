{
    "username": "bridge_four",
    "submission": "class Solution {\npublic:\n  vector<int> constructPath(int u, vector<int>& prev) {\n    vector<int> path;\n    while (u != -1) {\n      path.push_back(u);\n      u = prev[u];\n    }\n    return path;\n  }\n\n  pair<int, vector<int>> bfs(vector<vector<int>>& graph, int start) {\n    int n = graph.size();\n    queue<int> q;\n    vector<int> dist(n, INT_MAX);\n    dist[start] = 0;\n    q.push(start);\n    vector<int> prev(n, -1);\n\n    int maxDist = -1;\n    int endNode = -1;\n\n    while (!q.empty()) {\n      int u = q.front();\n      q.pop();\n\n      if (dist[u] > maxDist) {\n        endNode = u;\n        maxDist = dist[u];\n      }\n\n      for (auto v : graph[u]) {\n        if (dist[v] > dist[u] + 1) {\n          dist[v] = dist[u] + 1;\n          prev[v] = u;\n          q.push(v);          \n        }\n      }\n    }\n\n    return {endNode, constructPath(endNode, prev)};\n  }\n\n  vector<int> getDiameterPath(vector<vector<int>>& edges) {\n    vector<vector<int>> graph(edges.size() + 1);\n    for (auto& e : edges) {\n      graph[e[0]].push_back(e[1]);\n      graph[e[1]].push_back(e[0]);\n    }\n    auto b = bfs(graph, 0);\n    auto r = bfs(graph, b.first);\n    return r.second;\n  }\n\n  map<int, int> getPositionMap(vector<int>& v) {\n    map<int, int> pos;\n    for (int i = 0; i < v.size(); i++) {\n      pos[v[i]] = i;\n    }\n    return pos;\n  }\n\n  int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n    vector<int> g1 = getDiameterPath(edges1);\n    vector<int> g2 = getDiameterPath(edges2);\n\n    // map<int, int> pos1 = getPositionMap(g1);\n    // map<int, int> pos2 = getPositionMap(g2);\n\n    int m = g1.size() - 1;\n    int n = g2.size() - 1;\n\n    if (m == 0 || n == 0) {\n      return m == 0 && n == 0 ? 1 : max({m, n, 2});\n    }\n\n    // for (auto n : g1) cout << n << ' ';\n    // cout << endl;\n    // for (auto n : g2) cout << n << ' ';\n    // cout << endl;\n\n    int d = g1.size() / 2 + g2.size() / 2 + 1;\n    return max({d, m, n});\n\n    // if (g1.size() % 2 == 1 && g2.size() % 2 == 1) {\n    //   return g1.size() / 2 + g2.size() / 2;\n    // } else if (g1.size() % 2 == 1 && g2.size() % 2 == 0) {\n\n    // }\n\n    // int minD = INT_MAX;\n\n    // for (auto it : pos1) {\n    //   if (pos2.find(it.first) != end(pos2)) {\n    //     int x = it.second, y = m - x;\n    //     int p = pos2[it.first], q = n - p;\n    //     int d = max({x + p + 1, y + p + 1, x + q + 1, y + q + 1});\n    //     d = max({d, m, n});\n    //     minD = min(d, minD);\n    //   }\n    // }\n\n    // return minD;\n  }\n};",
    "submit_ts": 1719719507.0
}