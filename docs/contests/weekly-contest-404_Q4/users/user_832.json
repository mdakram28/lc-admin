{
    "username": "hahenz102880",
    "submission": "class Solution:\n    #def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n    \n    \n\n    def minimumDiameterAfterMerge(self,edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def tree_diameter(edges: List[List[int]]) -> int:\n            if not edges:\n                return 0\n\n            n = len(edges) + 1\n            graph = [[] for _ in range(n)]\n\n            for u, v in edges:\n                graph[u].append(v)\n                graph[v].append(u)\n\n            def bfs(start: int) -> (int, int):\n                dist = [-1] * n\n                dist[start] = 0\n                q = deque([start])\n                farthest_node = start\n                max_dist = 0\n\n                while q:\n                    node = q.popleft()\n                    for neighbor in graph[node]:\n                        if dist[neighbor] == -1:\n                            dist[neighbor] = dist[node] + 1\n                            q.append(neighbor)\n                            if dist[neighbor] > max_dist:\n                                max_dist = dist[neighbor]\n                                farthest_node = neighbor\n\n                return farthest_node, max_dist\n\n            far_node, _ = bfs(0)\n            _, diameter = bfs(far_node)\n            return diameter\n        \n        d1 = tree_diameter(edges1)\n        d2 = tree_diameter(edges2)\n\n        min_diameter = max((d1 + 1) // 2 + (d2 + 1) // 2 + 1, d1, d2)\n\n        return min_diameter",
    "submit_ts": "1719719961",
    "subm_id": "1304455223"
}