{
    "username": "NiloCodes",
    "submission": "class Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:\n        # dp[i][x]: opt answer ending in nums[i] using at most x steps.\n        dp = [[1]*(k+1) for _ in range(len(nums))]\n        # answer: max(dp) (can end anywhere and use any number of steps)\n        # formula:\n        # opt 1: continue current number: dp[i][x] = 1 + dp[j][x], where j is the previous occurrence of nums[i]\n        # opt 2: switch: dp[i][x] = 1 + max(dp[j][x-1] over all j < i) \n        \n        last_seen = defaultdict(list)\n        for i, x in enumerate(nums):\n            last_seen[x].append(i)\n        ls = [-1]*len(nums)\n        for x in last_seen:\n            if len(last_seen[x]) > 1:\n                for i in range(1, len(last_seen[x])):\n                    ls[last_seen[x][i]] = last_seen[x][i-1]\n        \n        for x in range(k+1):\n            prefixMax = [0]*len(nums)\n            if x > 0:\n                prefixMax = [0]*len(nums)\n                prefixMax[0] = dp[0][x-1]\n                for i in range(1, len(nums)):\n                    prefixMax[i] = max(dp[i][x-1], prefixMax[i-1])\n            for i in range(len(nums)):\n                j = ls[i]\n                if x == 0:\n                    if j == -1:\n                        dp[i][0] = 1\n                    else:\n                        dp[i][0] = 1 + dp[j][0]\n                elif i == 0:\n                    dp[i][x] = 1\n                else:\n                    f = prefixMax[i-1] #max([dp[l][x-1] for l in range(i)])\n                    if j == -1:\n                        dp[i][x] = 1 + f\n                    else:\n                        dp[i][x] = 1 + max(dp[j][x], f)\n        res = max([max(v) for v in dp])\n        return res\n                    \n                \n        \n        ",
    "submit_ts": "1717861378",
    "subm_id": "1281789070"
}