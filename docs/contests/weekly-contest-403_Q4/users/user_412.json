{
    "username": "NerdyCoder",
    "submission": "class Solution {\npublic:\n    int minimumSum(vector<vector<int>>& grid) {\n        const int m = grid.size();\n        const int n = grid[0].size();\n        vector<vector<int>> trans(n, vector<int>(m));\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                trans[j][i] = grid[i][j];\n            }\n        }\n        int result = min(solve(grid), solve(trans));\n        for (int i = 0, j = m - 1; i < j; ++i, --j) {\n            swap(grid[i], grid[j]);\n        }\n        result = min(result, solve(grid));\n        for (int i = 0, j = n - 1; i < j; ++i, --j) {\n            swap(trans[i], trans[j]);\n        }\n        result = min(result, solve(trans));\n        return result;\n    }\nprivate:\n    int solve(const vector<vector<int>> &grid) {\n        const int m = grid.size();\n        const int n = grid[0].size();\n        map<int, vector<int>> upper_i_map;\n        multiset<int> upper_j_vals;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    upper_i_map[i].push_back(j);\n                    upper_j_vals.insert(j);\n                }\n            }\n        }\n        const int i_max = upper_i_map.rbegin()->first;\n        \n        int result = INT_MAX;\n        vector<pair<int, int>> lower;\n        while (upper_i_map.size() >= 2) {\n            //cout <<0<<endl;\n            auto it = prev(upper_i_map.end());\n            for (int y_val : it->second) {\n                upper_j_vals.erase(upper_j_vals.find(y_val));\n                lower.emplace_back(it->first, y_val);\n            }\n            upper_i_map.erase(it);\n            //cout <<1<<endl;\n            int upper_area = (*upper_j_vals.rbegin() - *upper_j_vals.begin() + 1) * (upper_i_map.rbegin()->first - upper_i_map.begin()->first + 1);\n            //cout << 1.5<<endl;\n            map<int, vector<int>> middle_i_map;\n            multiset<int> middle_j_set;\n            for (const auto [i, j] : lower) {\n                middle_i_map[i].push_back(j);\n                middle_j_set.insert(j);\n            }\n            //cout << 1.6<<endl;\n            int lower_min_i = INT_MAX;\n            int lower_min_j = INT_MAX;\n            int lower_max_j = INT_MIN;\n            while (middle_i_map.size() >= 2) {\n                //cout << 1.8<<endl;\n                it = prev(middle_i_map.end());\n                lower_min_i = it->first;\n                for (int y_val : it->second) {\n                    middle_j_set.erase(middle_j_set.find(y_val));\n                    lower_min_j = min(lower_min_j, y_val);\n                    lower_max_j = max(lower_max_j, y_val);\n                }\n                middle_i_map.erase(it);\n                //cout << 1.85<<endl;\n                //assert(!middle_j_set.empty());\n                //assert(!middle_i_map.empty());\n                \n                int middle_area = (*middle_j_set.rbegin() - *middle_j_set.begin() + 1) * (middle_i_map.rbegin()->first - middle_i_map.begin()->first + 1);\n                int lower_area = (i_max - lower_min_i + 1) * (lower_max_j - lower_min_j + 1);\n                //cout << \"upper:middle:lower \"<<upper_area<<\" \"<<middle_area<<\" \"<<lower_area<<endl;\n                result = min(result, upper_area + middle_area + lower_area);\n                //cout << 1.89<<endl;\n            }\n            //cout << 2<<endl;\n            map<int, vector<int>> right_j_map;\n            multiset<int> right_i_vals;\n            for (const auto [i,j ] : lower) {\n                right_j_map[j].push_back(i);\n                right_i_vals.insert(i);\n            }\n            \n            int left_j_min = right_j_map.begin()->first;\n            int left_i_min = INT_MAX;\n            int left_i_max = INT_MIN;\n            int left_j_max = INT_MIN;\n            while (right_j_map.size() >= 2) {\n                it = right_j_map.begin();\n                left_j_max = it->first;\n                for (int i_val : it->second) {\n                    right_i_vals.erase(right_i_vals.find(i_val));\n                    left_i_min = min(left_i_min, i_val);\n                    left_i_max = max(left_i_max, i_val);\n                }\n                right_j_map.erase(it);\n                \n                int left_area = (left_i_max - left_i_min + 1) * (left_j_max - left_j_min + 1);\n                int right_area = (right_j_map.rbegin()->first - right_j_map.begin()->first + 1) * (*right_i_vals.rbegin() - *right_i_vals.begin() + 1);\n                //if (m == 3 && n == 4) \n                //cout << \"upper:left:right \"<<upper_area<<\" \"<<left_area<<\" \"<<right_area<<endl;\n                result = min(result, upper_area + left_area + right_area);\n            }\n            //cout <<3<<endl;\n            \n        }\n        return result;\n    }\n};",
    "submit_ts": 1719114344.0
}