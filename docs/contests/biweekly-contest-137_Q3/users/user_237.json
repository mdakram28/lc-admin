{
    "username": "prakharrrr4",
    "submission": "\n\ntemplate< class Cap, class Cost> struct mcf_graph {\nprivate:\n    int _n;\n    struct _edge\n    {\n        int  to, rev;\n        Cap  cap;\n        Cost cost;\n    };\n    vector<pair<int, int> >pos;\n    vector<vector<_edge> > g;\n    vector<Cost> h;\n    vector<Cost> dist;\n    vector<int> pv, pe;\n    vector<bool> vis;\n\n\n    // normalizing nodes weights in case of negative edges \n    //References :Geeks for Geeks: Johnson's Algorithm\n    void norm(int s, int t)\n    {\n        h.resize(_n, numeric_limits<Cost>::max());\n        h[s] = 0;\n        int ch = 1;\n        int it = _n;\n        while (ch-- && it--)\n        {\n            for (int i = 0; i < _n; i++)\n            {\n                if (h[i] == numeric_limits<Cost>::max()) continue;\n                for (auto e : g[i])\n                {\n\n                    if (e.cap == 0) continue;\n                    if (h[i] + e.cost < h[e.to])\n                    {\n                        h[e.to] = h[i] + e.cost;\n                        ch = 1;\n                    }\n                }\n            }\n            assert(it >= 0); // negative cost cycle\n        }\n        for (int i = 0; i < _n; i++)h[i] -= h[t];\n\n    }\n\n\n    //dijkstra algorithm\n    bool dijkstra(int s, int t)\n    {\n       \n        pv.clear();\n        pe.clear();\n        vis.clear();\n        dist.clear();\n        dist.resize(_n, numeric_limits<Cost>::max());\n        pv.resize(_n, -1);\n        pe.resize(_n, -1);\n        vis.resize(_n, false);\n\n\n        priority_queue<pair<Cost, int>, vector<pair<Cost, int>>, greater<pair<Cost, int>> > pq;\n        pq.push({ 0,s });\n        dist[s] = 0;\n        while (!pq.empty())\n        {\n            int x = pq.top().second;\n            pq.pop();\n            if (vis[x]) continue;\n            vis[x] = true;\n            if (x == t)\n                break;\n            for (int i = 0; i<int(g[x].size()); ++i)\n            {\n                auto e = g[x][i];\n                if (vis[e.to] || e.cap == 0)\n                    continue;\n                Cost cost = e.cost + h[x] - h[e.to];\n                if (dist[e.to] <= dist[x] + cost)\n                    continue;\n                dist[e.to] = dist[x] + cost;\n                pv[e.to] = x;\n                pe[e.to] = i;\n                pq.push({ dist[e.to],e.to });\n            }\n        }\n        if (vis[t] == false)\n            return false;\n        //update weights\n        for (int i = 0; i < _n; ++i)\n        {\n            if (!vis[i]) continue;\n            h[i] -= dist[t] - dist[i];\n        }\n        return true;\n\n    }\n\n\n\npublic:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap, Cost cost)\n    {\n        assert(from >= 0 && from < _n);\n        assert(to >= 0 && to < _n);\n        int m = int(pos.size());\n        pos.push_back({ from,int(g[from].size()) });\n        int from_id = int(g[from].size());\n        int to_id = int(g[to].size());\n        if (from == to) to_id++;\n        g[from].push_back(_edge{to,to_id,cap,cost });\n        g[to].push_back(_edge{ from, from_id, 0, -cost });\n        return m;\n    }\n    struct edge\n    {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    vector<edge> edges()\n    {\n        int m = int(pos.size());\n        vector<edge> result(m);\n        for (int i = 0; i < m; ++i)\n            result[i] = get_edge(i);\n        return result;\n    }\n    // pair<Cap, Cost> flow(int s, int t, bool neg = false)\n    // {\n    //     return flow(s, t, numeric_limits<Cap>::max(), neg);\n    // }\n    pair<Cap, Cost> flow(int s, int t, Cap flow_limit, bool neg = false)\n    {\n        return slope(s, t, flow_limit, neg).back();\n    }\n    vector<pair<Cap, Cost>> slope(int s, int t, bool neg = false)\n    {\n        return slope(s, t, numeric_limits<Cap>::max(), neg);\n    }\n    vector<pair<Cap, Cost>> slope(int s, int t, Cap flow_limit, bool neg = false)\n    {\n        assert(s >= 0 && s < _n);\n        assert(t >= 0 && t < _n);\n        assert(s != t);\n        h.clear();\n        if (!neg)\n            h.resize(_n, 0);\n        else norm(s,t);\n        Cap flow = 0;\n        Cost cost = 0, prev = -1;\n        vector<pair<Cap, Cost>> result;\n        result.push_back({ flow,cost });\n        while (flow < flow_limit)\n        {\n            if (dijkstra(s, t) == false)\n                break;\n            Cap c = flow_limit - flow;\n            for (int i = t; i != s; i = pv[i])\n            {\n                c = min(c, g[pv[i]][pe[i]].cap);\n            }\n            for (int i = t; i != s; i = pv[i])\n            {\n                auto& e = g[pv[i]][pe[i]];\n                e.cap -= c;\n                g[e.to][e.rev].cap += c;\n            }\n            Cost d = -h[s];\n            flow += c;\n            cost += c * d;\n            if (prev == d)\n                result.pop_back();\n            result.push_back({ flow,cost });\n            prev = d;\n        }\n        return result;\n    }\n};\n\nclass Solution {\npublic:\n    \n    long long maximumValueSum(vector<vector<int>>& board) {\n        int n = board.size();\n        int m = board[0].size();\n        mcf_graph<long long, long long> g(n+m+2);\n        int s = n+m;\n        int t = s + 1;\n        \n        for(int i=0;i<n;i++)\n        {\n            g.add_edge(s,i,1,0);\n        }\n        for(int i=0;i<m;i++)\n        {\n            g.add_edge(i+n,t,1,0);\n        }\n        long long INF = 1e13;\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++)\n                g.add_edge(i,j+n,1,-board[i][j]+INF);\n        \n        return 3*INF - g.flow(s,t,3).second ;\n        \n    }\n};",
    "submit_ts": "1723908410",
    "subm_id": "1359151416"
}