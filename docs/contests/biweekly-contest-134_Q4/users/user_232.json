{
    "username": "Andwerp",
    "submission": "typedef long long ll;\ntemplate <typename T>\nstruct Segtree {\n    //note that t[0] is not used\n    int n;\n    T* t;\n    T uneut, qneut;\n\n    //single element modification function\n    function<T(T, T)> fmodify;\n\n    //product of two elements for query and updating tree\n    function<T(T, T)> fcombine;\n\n    Segtree(int n, T updateNeutral, T queryNeutral, function<T(T, T)> fmodify, function<T(T, T)> fcombine) {\n        this -> n = n;\n        t = new T[2 * n];\n\n        this -> fmodify = fmodify;\n        this -> fcombine = fcombine;\n\n        uneut = updateNeutral;\n        qneut = queryNeutral;\n\n        for(int i = 0; i < n; i++){\n            t[i + n] = uneut;\n        }\n        build();\n    }\n\n    void assign(vector<T>& arr) {\n        for(int i = 0; i < min(n, arr.size()); i++){\n            t[i + n] = arr[i];\n        }\n        build();\n    }\n\n    void build() { // build the tree after manually assigning the values.\n        for (int i = n - 1; i > 0; i--) {   \n            t[i] = fcombine(t[i * 2], t[i * 2 + 1]);\n        }\n    }\n\n    void modify(int p, T value) { // set value at position p\n        p += n;\n        t[p] = fmodify(t[p], value);\n        for (p /= 2; p > 0; p /= 2) {\n            t[p] = fcombine(t[p * 2], t[p * 2 + 1]);\n        }\n    }\n\n    T query(int l, int r) { // sum on interval [l, r)\n        T l_res = qneut, r_res = qneut;\n        bool l_none = true, r_none = true;\n        for (l += n, r += n; l < r; l /= 2, r /= 2) {\n            if (l % 2 == 1) {\n                if(l_none) {\n                    l_none = false;\n                    l_res = t[l];\n                }\n                else {\n                    l_res = fcombine(l_res, t[l]);\n                }\n                l++;\n            }\n            if (r % 2 == 1) {\n                r--;\n                if(r_none) {\n                    r_none = false;\n                    r_res = t[r];\n                }\n                else {\n                    r_res = fcombine(t[r], r_res);\n                }\n            }\n        }\n        if(l_none) {\n            return r_res;\n        }\n        if(r_none) {\n            return l_res;\n        }\n        return fcombine(l_res, r_res);\n    }\n\n    T query(int ind) {\n        return this->query(ind, ind + 1);\n    }\n};\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        int n = nums.size();\n        function<int(int, int)> fmodify = [](const int src, const int val) -> int{return val;};\n        function<int(int, int)> fcombine = [](const int a, const int b) -> int{return a & b;};\n        Segtree<int> segt(n, 0, (1 << 30) - 1, fmodify, fcombine); \n        for(int i = 0; i < n; i++){\n            segt.modify(i, nums[i]);\n        }\n        vector<int> l(nums.size(), 0);\n        int ptr = 0;\n        for(int i = 0; i < n; i++){\n            while(ptr != n && segt.query(i, ptr + 1) > k) {\n                ptr ++;\n            }\n            l[i] = ptr;\n            // cout << \"L : \" << ptr << \"\\n\";\n        }\n        ptr = 0;\n        ll ans = 0;\n        for(int i = 0; i < n; i++){\n            while(ptr != n && segt.query(i, ptr + 1) >= k){\n                ptr ++;\n            }\n            ans += ptr - l[i];\n            // cout << \"R : \" << ptr << \"\\n\";\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720277560",
    "subm_id": "1311669499"
}