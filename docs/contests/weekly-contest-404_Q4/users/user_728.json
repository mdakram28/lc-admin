{
    "username": "tepamid",
    "submission": "\n#define fo(i, n) for (int i = 0; i < n; ++i)\n#define foback(i, n) for (int i = n - 1; i >= 0; --i)\n#define fo1(i, n) for (ll i = 1; i <= n; ++i)\n\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define makeunique(x) sort(all(x)), (x).resize(unique(all(x)) - (x).begin())\n\ntypedef long long ll;\n\n\nint dfsForCentroid(int u, int pu, vector<vector<int>>& g, vector<int>& sz) {\n    sz[u]=1;\n    for(auto v: g[u]) {\n        if (v==pu) continue;\n\n        sz[u] += dfsForCentroid(v,u,g,sz);\n    }\n    return sz[u];\n}\n\nint findCentroid (const vector<vector<int>>& g, const vector<int>& sz, int u, int pu) {\n    int n = g.size();\n\n    for (int v : g[u]){\n        if (v == pu) continue;\n\n        if (sz[v] > n / 2)\n            return findCentroid(g, sz, v, u);\n    }\n\n    return u;\n}\n\n\nclass TreeDiameter {\n    int n;\n    vector<int> d;\n\npublic:\n    pair<int,pair<int,int>> findTreeDiameter(vector<vector<int>> &g)\n    {\n        n = g.size();\n        d.resize(n);\n\n        int u = 0, v = 0, w = 0;\n\n        bfs(g, v);\n        fo(i, n) if (d[i] > d[u]) u = i;\n\n        // debug(u)\n        bfs(g, u);\n        fo(i, n) if (d[i] > d[w]) w = i;\n        // debug(w)\n        return {d[w], {u,w}};\n    }\n\nprivate:\n    void bfs(vector<vector<int>> &g, int u)\n    {\n        fo(i, n) d[i] = n;\n\n        d[u] = 0;\n        queue<int> q;\n        q.push(u);\n\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (auto w : g[v])\n            {\n                if (d[w] < n)\n                    continue;\n                d[w] = 1 + d[v];\n                q.push(w);\n            }\n        }\n    }\n\n};\n\n\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size()+1;\n        vector<vector<int>> g1(n);\n        for(auto& e:edges1) {\n            int u = e[0];\n            int v = e[1];\n            g1[u].push_back(v);\n            g1[v].push_back(u);\n        }\n        int m = edges2.size()+1;\n        vector<vector<int>> g2(m);\n        for(auto& e:edges2) {\n            int u = e[0];\n            int v = e[1];\n            g2[u].push_back(v);\n            g2[v].push_back(u);\n        }\n        \n\n//         vector<int> sz1(n);\n//         dfsForCentroid(0, 0, g1, sz1);\n//         int c1 = findCentroid(g1, sz1, 0, 0);\n        \n//         vector<int> sz2(m);\n//         dfsForCentroid(0, 0, g2, sz2);\n//         int c2 = findCentroid(g2, sz2, 0, 0);\n\n        \n            TreeDiameter td1, td2; \n            auto [d1, uv1] = td1.findTreeDiameter(g1);\n            auto [d2, uv2] = td2.findTreeDiameter(g2);\n        \n            cout << d1 << \" \" << d2 << endl;\n        \n            int r1 = (d1+1)/2;\n            int r2 = (d2+1)/2;\n            \n            return max({d1,d2,r1+r2+1});\n        \n    }\n};",
    "submit_ts": 1719719379.0
}