{
    "username": "xmentex",
    "submission": "template <class T> class MinSegmentTree {\n  private:\n\tconst T DEFAULT = std::numeric_limits<T>().max();\n\n\tvector<T> segtree;\n\tint len;\n\n  public:\n\tMinSegmentTree(int len) : len(len), segtree(len * 2, DEFAULT) {}\n\n\t/** Sets the value at ind to val. */\n\tvoid set(int ind, T val) {\n\t\tind += len;\n\t\tsegtree[ind] = val;\n\t\tfor (; ind > 1; ind /= 2) {\n\t\t\tsegtree[ind / 2] = std::min(segtree[ind], segtree[ind ^ 1]);\n\t\t}\n\t}\n\n\t/** @return the minimum element in the range [start, end) */\n\tT range_min(int start, int end) {\n\t\tT min = DEFAULT;\n\t\tfor (start += len, end += len; start < end; start /= 2, end /= 2) {\n\t\t\tif (start % 2 == 1) { min = std::min(min, segtree[start++]); }\n\t\t\tif (end % 2 == 1) { min = std::min(min, segtree[--end]); }\n\t\t}\n\t\treturn min;\n\t}\n};\n\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        set<int> x;\n        vector<bool> res;\n        \n        int end = 0;\n        \n        for (auto q : queries) {\n            if (q[0] == 1) {\n                if (q[1] > end) {\n                    end = q[1] ;\n                }  \n            } else {\n                if (q[1] + q[2] > end) {\n                    end = q[1] + q[2] ;\n                }\n            }\n        }\n        end *= 2;\n        \n        x.insert(0);\n        x.insert(end);\n        \n        auto ms = MinSegmentTree<int>(end + 1);\n        for (int i = 0; i < end; i++) {\n            ms.set(i, end);\n        }    \n            \n        ms.set(end, 0);\n        map<int, set<int>> p;\n        p[end].insert(0);\n            \n        for (auto q : queries) {\n            if (q[0] == 1) {\n                x.insert(q[1]);\n                auto it = x.find(q[1]);\n                it--;\n                int prev = *(it);\n                it++;\n                it++;\n                int next = *(it);\n                \n                int l = next - prev;\n                p[l].erase(prev);\n                if (p[l].size() == 0) {\n                    ms.set(l, end);    \n                } else {\n                    ms.set(l, *p[l].begin());\n                }\n                \n                int x = q[1] - prev;\n                p[ x ].insert(prev);\n                ms.set(x, *p[x].begin());\n                x = next - q[1];\n                p[ x ].insert(q[1]);\n                ms.set(x, *p[x].begin());\n            } else {\n                int d = q[1] - q[2];\n                int x = ms.range_min(q[2], end + 1);\n                if (x <= d) {\n                    res.push_back(true); \n                } else {\n                    res.push_back(false);\n                }\n            }\n        }\n        \n        return res;\n    }\n};",
    "submit_ts": 1716650094.0
}