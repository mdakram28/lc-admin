{
    "username": "ribhav_32",
    "submission": "\n//     vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n//         this->nums = nums;\n//         n = nums.size();\n//         peaks.resize(n, 0);\n//         segTree.resize(4 * n, 0);\n//         buildPeaks();\n//         buildSegmentTree(0, n-1, 0);\n\n\n#include <vector>\n#include <unordered_map>\n// class Solution {\n// public:\n//     int modValue = 1e9+7;\n\nclass Solution {\nprivate:\n    static const int MOD = 1e9 + 7;\n//         int startPointer = 0, endPointer = 0;\n//         int partitionCount = 0;\n//         while (startPointer < arraySize) {\n//             endPointer = max(endPointer, lastOccurrence[array[startPointer]]);\n//             if (startPointer == endPointer) {\n\n    static const int MAX_INVERSIONS = 400;\n\n//     int calculatePower(int base, int exponent, int modulus) {\n//         long long result = 1;\npublic:\n    int mod = 1e9 + 7;\n\n//         return calculatePower(2, partitionCount - 1, modValue);\n//     }\n// };\n    int power(int base, int exp, int mod) {\n        long long result = 1;\n        while (exp > 0) {\n            if (exp % 2 != 0)\n//         int startPointer = 0, endPointer = 0;\n//         int partitionCount = 0;\n//         while (startPointer < arraySize) {\n//             endPointer = max(endPointer, lastOccurrence[array[startPointer]]);\n//             if (startPointer == endPointer) {\n\n                result = (result * base) % mod;\n            exp = exp >> 1;//     }\n\n//     int numberOfGoodPartitions(vector<int>& array) {\n//         int arraySize = array.size();\n//         map<int, int> lastOccurrence;\n//         for (int i = 0; i < arraySize; i++)\n//             lastOccurrence[array[i]] = i;\n\n\n\n            base = (base * base) % mod;\n            \n//         return calculatePower(2, partitionCount - 1, modValue);\n//     }\n// };\n        }\n        return result;\n    }\n\n//         vector<int> result;\n//         for (const auto& query : queries) {\n//             if (query[0] == 1) {\n//                 int li = query[1], ri = query[2];\n//                 if (li == ri) {\n//                     result.push_back(0);\n//                 } else {\n//                     result.push_back(rangeQuery(li + 1, ri - 1, 0, n-1, 0));\n//                 }\n//             } else if (query[0] == 2) {\n//                 int index = query[1], val = query[2];\n//                 handleUpdate(index, val);\n//             }\n//         }\n//         return result;\n//     }\n// };\n//     int calculatePower(int base, int exponent, int modulus) {\n//         long long result = 1;\n    int numberOfGoodPartitions(std::vector<int>& arr) {\n        int n = arr.size();\n        std::map<int, int> valueIndexMap;\n        for (int i = 0; i < n; i++)\n//         int startPointer = 0, endPointer = 0;\n//         int partitionCount = 0;\n//         while (startPointer < arraySize) {\n//             endPointer = max(endPointer, lastOccurrence[array[startPointer]]);\n//             if (startPointer == endPointer) {\n\n            valueIndexMap[arr[i]] = i;\n\n        int leftPtr = 0, rightPtr = 0;\n        int partitionCount = 0;\n        while (leftPtr < n) {\n            rightPtr = std::max(rightPtr, valueIndexMap[arr[leftPtr]]);\n            if (leftPtr == rightPtr) {\n                partitionCount++;\n            }//                 partitionCount++;\n//             }\n//             startPointer++;\n//         }\n            leftPtr++;\n        }\n\n        return power(2, partitionCount - 1, mod);\n    }\n\n//     int calculatePower(int base, int exponent, int modulus) {\n//         long long result = 1;\n    int numberOfPermutations(int size, std::vector<std::vector<int>>& conditions) {\n        std::unordered_map<int, int> conditionMap;\n        for (const auto& condition : conditions) {\n//         while (exponent > 0) {\n//             if (exponent % 2 != 0)\n//                 result = (result * base) % modulus;\n//             exponent = exponent >> 1;\n//             base = (base * base) % modulus;\n//         }\n//         return result;\n\n            conditionMap[condition[0] + 1] = condition[1];//                 partitionCount++;\n//             }\n//             startPointer++;\n//         }\n        }\n\n//     int calculatePower(int base, int exponent, int modulus) {\n//         long long result = 1;\n        std::vector<std::vector<long>> permCounts(size + 1, std::vector<long>(MAX_INVERSIONS + 1, 0));\n        permCounts[0][0] = 1;\n\n        for (int length = 1; length <= size; ++length) {\n            for (int inv = 0; inv <= MAX_INVERSIONS; ++inv) {\n                for (int newPos = 0; newPos < length; ++newPos) {//                 partitionCount++;\n//             }\n//             startPointer++;\n//         }\n                    int prevInv = inv - newPos;\n                    if (prevInv >= 0) {\n                        permCounts[length][inv] = (permCounts[length][inv] + permCounts[length - 1][prevInv]) % MOD;\n                    }\n                }\n            }\n\n//     int calculatePower(int base, int exponent, int modulus) {\n//         long long result = 1;\n            if (conditionMap.find(length) != conditionMap.end()) {\n                int targetInv = conditionMap[length];\n                for (int inv = 0; inv <= MAX_INVERSIONS; ++inv) {//                 partitionCount++;\n//             }\n//             startPointer++;\n//         }\n                    if (inv != targetInv) {\n                        permCounts[length][inv] = 0;\n                    }\n                }\n            }\n        }\n        \n\n//     int calculatePower(int base, int exponent, int modulus) {\n//         long long result = 1;\n        long totalPermutations = 0;\n        for (const auto& count : permCounts[size]) {\n            \n//     void buildSegmentTree(int l, int r, int idx) {\n//         if (l == r) {\n//             segTree[idx] = peaks[l];\n//             return;\n//         }\n//         int mid = (l + r) / 2;\n//         buildSegmentTree(l, mid, 2 * idx + 1);\n//         buildSegmentTree(mid + 1, r, 2 * idx + 2);\n//         segTree[idx] = segTree[2 * idx + 1] + segTree[2 * idx + 2];\n//     }\n\n//     int rangeQuery(int ql, int qr, int l, int r, int idx) {\n//         if (ql > r || qr < l) return 0;\n//         if (ql <= l && qr >= r) return segTree[idx];\n//         int mid = (l + r) / 2;\n//         return rangeQuery(ql, qr, l, mid, 2 * idx + 1) + rangeQuery(ql, qr, mid + 1, r, 2 * idx + 2);\n//     }\n\n//     void updateSegmentTree(int pos, int l, int r, int idx) {\n//         if (l == r) {\n//             segTree[idx] = peaks[l];\n//             return;\n//         }\n//         int mid = (l + r) / 2;\n//         if (pos <= mid) {\n//             updateSegm\n            totalPermutations = (totalPermutations + count) % MOD;//                 partitionCount++;\n//             }\n//             startPointer++;\n//         }\n        }\n        return static_cast<int>(totalPermutations);\n    }\n};\n\n",
    "submit_ts": 1719071784.0
}