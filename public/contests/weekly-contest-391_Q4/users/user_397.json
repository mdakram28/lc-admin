{
    "username": "54CVhBa16A",
    "submission": "/**\n * @param {number[][]} points\n * @return {number}\n */\n\nclass SegmentNode {\n    constructor(a, b) {\n        this.start = a;\n        this.end = b;\n        this.info = -Number.MAX_VALUE;\n        this.info2 = Number.MAX_VALUE\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass SegmentTree {\n    constructor(root) {\n        this.root = root;\n    }\n\n    constructTree(node, a, b) {\n        if (a === b) {\n            return;\n        }\n        let mid = a + Math.floor((b - a) / 2);\n        node.left = new SegmentNode(a, mid);\n        node.right = new SegmentNode(mid + 1, b);\n        this.constructTree(node.left, a, mid);\n        this.constructTree(node.right, mid + 1, b);\n        node.info = Math.max(node.left.info, node.right.info);\n        node.info2 = Math.min(node.left.info2, node.right.info2);\n    }\n\n    update(node, index, info1, info2) {\n\t\tif (!node) return;\n        if (node.start > index || node.end < index) return;\n        if (node.start === index && node.end === index) {\n            node.info = info1;\n            node.info2 = info2;\n            return;\n        }\n        this.update(node.left, index, info1, info2);\n        this.update(node.right, index, info1, info2);\n        node.info = Math.max(node.left.info === null ? -Number.MAX_VALUE : node.left.info, node.right.info === null ?  -Number.MAX_VALUE : node.right.info);\n        node.info2 = Math.min(node.left.info2 === null ? Number.MAX_VALUE :node.left.info2, node.right.info2 === null ? Number.MAX_VALUE : node.right.info2);\n        \n    }\n\n\n    queryInfo(node, a, b) {\n\t\tif (!node) return -Number.MAX_VALUE;\n        if (a > node.end || b < node.start) {\n            return -Number.MAX_VALUE;\n        }\n        if (a <= node.start && b >= node.end) {\n            return node.info !== null ? node.info: -Number.MAX_VALUE;\n        }\n        return Math.max(this.query(node.left, a, b), this.query(node.right, a, b));\n    }\n    \n    queryInfo2(node, a, b) {\n\t\tif (!node) return Number.MAX_VALUE;\n        if (a > node.end || b < node.start) {\n            return Number.MAX_VALUE;\n        }\n        if (a <= node.start && b >= node.end) {\n            return node.info2 !== null ? node.info2 : Number.MAX_VALUE;\n        }\n        return Math.min(this.query(node.left, a, b), this.query(node.right, a, b));\n    }\n}\n\n\n\n\n\nvar minimumDistance = function(points) {\n    let n = points.length;\n    let root1 = new SegmentNode(0, n - 1);\n    let tree1 = new SegmentTree(root1);\n    tree1.constructTree(root1, 0, n - 1);\n    \n    let root2 = new SegmentNode(0, n - 1);\n    let tree2 = new SegmentTree(root2);\n    tree2.constructTree(root2, 0, n - 1);\n    for (let i = 0; i < n; i++) {\n        let cur = points[i];\n        let info1 = cur[0] + cur[1];\n        let info2 = cur[0] - cur[1];\n        tree1.update(root1, i, info1, info1);\n        tree2.update(root2, i, info2, info2);\n    }\n    let res = Number.MAX_VALUE;\n    for (let i = 0; i < n; i++) {\n        let cur = points[i];\n        tree1.update(root1, i, null, null);\n        tree2.update(root2, i, null, null);\n        let temp = Math.max(tree1.queryInfo(root1, 0, n - 1) - tree1.queryInfo2(root1, 0, n - 1), tree2.queryInfo(root2, 0, n - 1) - tree2.queryInfo2(root2, 0, n - 1));\n        // console.log(i, temp)\n        let info1 = cur[0] + cur[1];\n        let info2 = cur[0] - cur[1];\n        tree1.update(root1, i, info1, info1);\n        tree2.update(root2, i, info2, info2);\n        res = Math.min(res, temp);\n    }\n    return res;\n};\n//[[10,7],[5,5],[2,7],[2,6]]\n//5"
}