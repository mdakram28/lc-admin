{
    "username": "cuiwanyun",
    "submission": "class SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.arr = arr\n        self.tree = [0] * (4 * self.n)\n        self.build(1, 0, self.n - 1)\n\n    def build(self, node, start, end):\n        if start == end:\n            self.tree[node] = 0\n            return\n\n        mid = (start + end) // 2\n        self.build(2 * node, start, mid)\n        self.build(2 * node + 1, mid + 1, end)\n\n        self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]\n        if mid-1 >=start and self.is_peak(mid):\n            self.tree[node] += 1\n        if mid+2 <=end and self.is_peak(mid+1):\n            self.tree[node] += 1\n        #print(start,mid,end,self.tree[node])\n\n    def update(self, node, start, end, index, val):\n        if start == end:\n            self.tree[node] = 0\n            return\n\n        mid = (start + end) // 2\n        if index <= mid:\n            self.update(2 * node, start, mid, index, val)\n        else:\n            self.update(2 * node + 1, mid + 1, end, index, val)\n\n        self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]\n        if mid-1 >=start and self.is_peak(mid):\n            self.tree[node] += 1\n        if mid+2 <=end and self.is_peak(mid+1):\n            self.tree[node] += 1\n\n    def query(self, node, start, end, left, right):\n        if left > end or right < start:\n            return 0\n\n        if left <= start and end <= right:\n            return self.tree[node]\n\n        mid = (start + end) // 2\n        left_sum = self.query(2 * node, start, mid, left, right)\n        right_sum = self.query(2 * node + 1, mid + 1, end, left, right)\n        mid_sum = 0\n        \n        if left <= mid-1 and mid+1 <=right and start<=mid-1 and self.is_peak(mid):\n            mid_sum += 1\n        if mid+2 <= right and left<=mid and end>=mid+2 and self.is_peak(mid+1):\n            mid_sum += 1\n\n        answer = left_sum + right_sum + mid_sum\n        #print(self.n,start,end,answer)\n        return answer\n\n    def is_peak(self, index):\n        if index == 0:\n            return 0\n        elif index == self.n - 1:\n            return 0\n        else:\n            return self.arr[index] > self.arr[index - 1] and self.arr[index] > self.arr[index + 1]\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        segment_tree = SegmentTree(nums)\n        answer = []\n        #print(segment_tree.n)\n        #print(queries)\n\n        for query in queries:\n            #print(segment_tree.n)\n            if query[0] == 1:\n                left, right = query[1], query[2]\n                peak_count = segment_tree.query(1, 0, segment_tree.n - 1, left, right)\n                answer.append(peak_count)\n            else:\n                index, val = query[1], query[2]\n                segment_tree.arr[index] = val\n                segment_tree.update(1, 0, segment_tree.n - 1, index, val)\n        return answer\n\n        ",
    "submit_ts": 1718508966.0
}