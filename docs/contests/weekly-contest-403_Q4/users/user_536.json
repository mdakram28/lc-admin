{
    "username": "berkeleyColin",
    "submission": "class Solution {\npublic:\n    int dp[30][30][30][30];\n    int n;\n    int m;\n    void findMin(vector<vector<int>>& grid){\n        for(int topR=0;topR<n;topR++){\n            for(int bottomR=topR;bottomR<n;bottomR++){\n                for(int topC=0;topC<m;topC++){\n                    for(int bottomC=topC;bottomC<m;bottomC++){\n                        int tr=bottomR;\n                        int tc=bottomC;\n                        int br=topR;\n                        int bc=topC;\n                        for(int r=topR;r<=bottomR;r++){\n                            for(int c=topC;c<=bottomC;c++){\n                                if(grid[r][c]){\n                                    tr=min(tr,r);\n                                    tc=min(tc,c);\n                                    br=max(br,r);\n                                    bc=max(bc,c);\n                                }\n                            }\n                        }\n                        dp[topR][topC][bottomR][bottomC]=max(1,(br-tr+1)*(bc-tc+1));\n                    }\n                }\n            }\n        }\n    }\n    int dp2[30][30][30][30][4];\n    int recurse(int tr, int tc, int br, int bc, int numWalls){\n        if(dp2[tr][tc][br][bc][numWalls]!=-1)return dp2[tr][tc][br][bc][numWalls];\n        int best=INT_MAX;\n        for(int r=tr;r<br;r++){\n            if(numWalls==1){\n                int option1=dp[tr][tc][r][bc];\n                if(r+1<=br)option1+=dp[r+1][tc][br][bc];\n                best=min(best,option1);\n                continue;\n            }\n            int option1=recurse(tr,tc,r,bc,1);\n            if(r+1<=br)option1+=dp[r+1][tc][br][bc];\n            int option2=dp[tr][tc][r][bc];\n            if(r+1<=br){\n                option2+=recurse(r+1,tc,br,bc,1);\n            }\n            best=min(best,min(option1,option2));\n        }\n        for(int c=tc;c<bc;c++){\n            if(numWalls==1){\n                int option1=dp[tr][tc][br][c];\n                if(c+1<=bc)option1+=dp[tr][c+1][br][bc];\n                best=min(best,option1);\n                continue;\n            }\n            int option1=recurse(tr,tc,br,c,1);\n            if(c+1<=m)option1+=dp[tr][c+1][br][bc];\n            int option2=dp[tr][tc][br][c];\n            if(c+1<=m){\n                option2+=recurse(tr,c+1,br,bc,1);\n            }\n            best=min(best,min(option1,option2));\n        }\n        dp2[tr][tc][br][bc][numWalls]=best;\n        return best;\n    }\n    int minimumSum(vector<vector<int>>& grid) {\n        n=grid.size();\n        m=grid[0].size();\n        findMin(grid);\n        memset(dp2,-1,sizeof(dp2));\n        int best=recurse(0,0,n-1,m-1,2);\n        return best;\n        \n        \n    }\n};",
    "submit_ts": 1719114992.0
}