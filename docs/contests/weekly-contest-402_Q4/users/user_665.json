{
    "username": "JfOoab5BRP",
    "submission": "struct BIT {\n    vector<int> tree;\n    int n;\n    BIT(int nn) {\n        n = nn;\n        tree = vector<int>(n + 1);\n    }\n    int lowbit(int x) {\n        return x & (-x);\n    }\n    void add(int x, int u) {\n        for (int i = x; i <= n; i += lowbit(i)) {\n            tree[i] += u;\n        }\n    }\n    int ask(int x) {\n        int ans = 0;\n        for (int i = x; i > 0; i -= lowbit(i)) {\n            ans += tree[i];\n        }\n        return ans;\n    }\n    int ask(int x, int y) {\n        if (x > y) return 0;\n        return ask(y) - ask(x - 1);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& qs) {\n        int n = a.size();\n        int m = qs.size();\n\n        vector<int> fg(n);\n        BIT bit(n);\n        for (int i = 1; i < n - 1; i++) {\n            if (a[i] > a[i - 1] && a[i] > a[i + 1]) {\n                fg[i] = true;\n                // cout << i << \" \" << fg[i] << endl;\n                bit.add(i + 1, 1);\n            }\n        }\n\n        vector<int> res;\n        for (auto& q : qs) {\n            int op = q[0], l = q[1], r = q[2];\n            if (op == 1) {\n                int s = bit.ask(l + 1 + 1, r - 1 + 1);\n                res.push_back(s);\n            } else {\n                // 2\n                a[l] = r;\n                if (l - 1 >= 0 && fg[l - 1] && a[l] >= a[l - 1]) {\n                    fg[l - 1] = false;\n                    bit.add(l - 1 + 1, -1);\n                }\n                if (l - 2 >= 0 && !fg[l - 1] && a[l] < a[l - 1] && a[l - 1] > a[l - 2] ) {\n                    fg[l - 1] = true;\n                    bit.add(l - 1 + 1, 1);\n                }\n                if (l + 1 < n && fg[l + 1] && a[l] >= a[l + 1]) {\n                    fg[l + 1] = false;\n                    bit.add(l + 1 + 1, -1);\n                }\n                if (l + 2 < n && !fg[l + 1] && a[l] < a[l + 1] && a[l + 1] > a[l + 2]) {\n                    fg[l + 1] = true;\n                    bit.add(l + 1 + 1, 1);\n                }\n\n                if (l - 1 >= 0 && l + 1 < n && fg[l] && (a[l] <= a[l - 1] || a[l] <= a[l + 1])) {\n                    fg[l] = false;\n                    bit.add(l + 1, -1);\n                }\n                if (l - 1 >= 0 && l + 1 < n && !fg[l] && a[l] > a[l - 1] && a[l] > a[l + 1]) {\n                    fg[l] = true;\n                    bit.add(l + 1, 1);\n                }\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1718507874.0
}