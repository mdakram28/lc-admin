{
    "username": "ajit_kumar-12345",
    "submission": " class Solution {\npublic:\n    int N = 50005;\nint MAX = 4 * 50005 + 5;\nint arr[50005];\nint tree[4 * 50005 + 5];\nint lazy[4 * 50005 + 5];\n\n/**\n * Build and init tree\n */\nvoid build_tree(int node, int a, int b) {\n  \tif(a > b) return; // Out of range\n  \t\n  \tif(a == b) { // Leaf node\n    \t\ttree[node] = arr[a]; // Init value\n\t\treturn;\n\t}\n\t\n\tbuild_tree(node*2, a, (a+b)/2); // Init left child\n\tbuild_tree(node*2+1, 1+(a+b)/2, b); // Init right child\n\t\n\ttree[node] = max(tree[node*2], tree[node*2+1]); // Init root value\n}\n\n/**\n * Increment elements within range [i, j] with value value\n */\nvoid update_tree(int node, int a, int b, int i, int j, int value) {\n  \n  \tif(lazy[node] != 0) { // This node needs to be updated\n   \t\ttree[node] += lazy[node]; // Update it\n\n\t\tif(a != b) {\n\t\t\tlazy[node*2] += lazy[node]; // Mark child as lazy\n    \t\t\tlazy[node*2+1] += lazy[node]; // Mark child as lazy\n\t\t}\n\n   \t\tlazy[node] = 0; // Reset it\n  \t}\n  \n\tif(a > b || a > j || b < i) // Current segment is not within range [i, j]\n\t\treturn;\n    \n  \tif(a >= i && b <= j) { // Segment is fully within range\n    \t\ttree[node] += value;\n\n\t\tif(a != b) { // Not leaf node\n\t\t\tlazy[node*2] += value;\n\t\t\tlazy[node*2+1] += value;\n\t\t}\n\n    \t\treturn;\n\t}\n\n\tupdate_tree(node*2, a, (a+b)/2, i, j, value); // Updating left child\n\tupdate_tree(1+node*2, 1+(a+b)/2, b, i, j, value); // Updating right child\n\n\ttree[node] = max(tree[node*2], tree[node*2+1]); // Updating root with max value\n}\n\n/**\n * Query tree to get max element value within range [i, j]\n */\nint query_tree(int node, int a, int b, int i, int j) {\n\t\n\tif(a > b || a > j || b < i) return -1e9; // Out of range\n\n\tif(lazy[node] != 0) { // This node needs to be updated\n\t\ttree[node] += lazy[node]; // Update it\n\n\t\tif(a != b) {\n\t\t\tlazy[node*2] += lazy[node]; // Mark child as lazy\n\t\t\tlazy[node*2+1] += lazy[node]; // Mark child as lazy\n\t\t}\n\n\t\tlazy[node] = 0; // Reset it\n\t}\n\n\tif(a >= i && b <= j) // Current segment is totally within range [i, j]\n\t\treturn tree[node];\n\n\tint q1 = query_tree(node*2, a, (a+b)/2, i, j); // Query left child\n\tint q2 = query_tree(1+node*2, 1+(a+b)/2, b, i, j); // Query right child\n\n\tint res = max(q1, q2); // Return final result\n\t\n\treturn res;\n}\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        for(int i=0; i<N; i++) arr[i] = i;\n        build_tree(1, 0, N-1);\n        memset(lazy, 0, sizeof lazy);\n        vector<bool> ans;\n        set<int> st;\n        st.insert(N-1);\n        for(auto &it: queries){\n            if(it[0] == 1){\n                int val = query_tree(1, 0, N-1, it[1], it[1]);\n                int nv = *st.lower_bound(it[1]);\n                update_tree(1, 0, N-1, it[1] + 1, nv, -1 * val);\n                st.insert(it[1]);\n            }else{\n                int val = query_tree(1, 0, N-1, 0, it[1]);\n                if(val >= it[2]) ans.push_back(1);\n                else ans.push_back(0);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716651073.0
}