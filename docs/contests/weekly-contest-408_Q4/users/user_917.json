{
    "username": "user9104rY",
    "submission": "class Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        graph = [[] for _ in range(len(circles) + 4)]\n\n        for i in range(len(circles)):\n            if circles[i][0] <= circles[i][2]:\n                graph[len(circles)].append(i)\n                graph[i].append(len(circles))\n            if X - circles[i][0] <= circles[i][2]:\n                graph[len(circles) + 1].append(i)\n                graph[i].append(len(circles) + 1)\n            if circles[i][1] <= circles[i][2]:\n                graph[len(circles) + 2].append(i)\n                graph[i].append(len(circles) + 2)\n            if Y - circles[i][1] <= circles[i][2]:\n                graph[len(circles) + 3].append(i)\n                graph[i].append(len(circles) + 3)\n\n        for i in range(len(circles)):\n            for j in range(i + 1, len(circles)):\n                if circles[i][2] + circles[j][2] >= sqrt((circles[i][0] - circles[j][0]) ** 2 + (circles[i][1] - circles[j][1]) ** 2):\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        def bfs(node, target1, target2):\n            q = deque([node])\n            visited = {node}\n\n            while q:\n                node = q.popleft()\n                for neighbor in graph[node]:\n                    if neighbor in visited:\n                        continue\n\n                    visited.add(neighbor)\n                    q.append(neighbor)\n\n            return target1 in visited or target2 in visited\n\n        return not bfs(len(circles), len(circles) + 1, len(circles) + 2) and not bfs(len(circles) + 3, len(circles) + 2, len(circles) + 1)",
    "submit_ts": "1722138955",
    "subm_id": "1335804061"
}