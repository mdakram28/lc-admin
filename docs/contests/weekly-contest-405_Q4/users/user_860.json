{
    "username": "hkhzzz",
    "submission": "struct Node {\n    struct Node* next[26];\n    bool isend;\n    int cost = INT_MAX;\n    int mncost = INT_MAX;\n    Node() {\n        isend = false;\n        for (int i = 0; i < 26; i ++) {\n            next[i] = NULL;\n        }\n    }\n};\n\nclass Solution {\nprivate:\n    struct Node* root;\n    void insert(string word, int cost) {\n        struct Node* cur = root;\n        for (auto& c: word) {\n            if (!cur->next[c-'a']) {\n                cur->next[c-'a'] = new Node();\n            }\n            cur->mncost = min(cur->mncost, cost);\n            cur = cur->next[c-'a'];\n        }\n        cur->isend = true;\n        cur->cost = min(cur->cost, cost);\n        cur->mncost = min(cur->mncost, cost);\n    }\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        root = new Node();\n        \n        for (int i = 0; i < words.size(); i ++) {\n            reverse(words[i].begin(), words[i].end());\n            insert(words[i], costs[i]);\n        }\n        \n        int m = target.length();\n        vector<int> dp(m, INT_MAX); // minimum cost reaching target[i]\n        vector<int> dp2(m, INT_MAX);\n\n        for (int i = 0; i < m; i ++) {\n            struct Node* cur = root;\n            for (int j = i; j >= 0; j --) {\n                if (!cur->next[target[j] - 'a']) { // cannot find more\n                    break;\n                }\n                cur = cur->next[target[j] - 'a'];\n                // found the substring in the trie tree\n                if (cur->isend) {\n                    // cout << \"found at \" << i << \"->\" << j << \" \" << target[i] << \"->\" << target[j] << \": \";\n                    if (j == 0) { // full string found\n                        dp[i] = min(dp[i], cur->cost);\n                        // cout << \"min of \" << dp[i] << \", \" << cur->cost << endl;\n                        \n                    } else if (dp[j-1] < INT_MAX && dp[j-1] + cur->cost < dp[i]) { // can append to previous\n                        dp[i] = min(dp[i], dp[j-1] + cur->cost);\n                        // cout  << dp[j-1] << \" + \" << cur->cost << endl;\n                        \n                    } else if (cur->mncost >= dp[i]) { // impossible to better\n                        // cout << \"early stop (reach word) at \" << j << endl;\n                        \n                        break;\n                    } else {\n                        // other case not update\n                        // cout << \"other case: not update\" << endl;\n                    }\n                    \n                } else if (j > 0 && cur->mncost >= dp[i]) {\n                    // cout << \"early stop at \" << j << endl;\n                    break;\n                }\n\n            }\n            if (i > 0) {\n                dp2[i] = min(dp2[i-1], dp[i]);\n            } else {\n                dp2[i] = dp[i];\n            }\n        }\n        if (dp.back() == INT_MAX) return -1;\n        else return dp.back();\n    }\n};\n// \"r\"\n// [\"r\",\"r\",\"r\",\"r\"]\n// [1,6,3,3] -> 1\n// \"twnpxyhva\"\n// [\"pxyhva\",\"twnpxyhva\",\"wnpx\"]\n// [3,19,8] -> 19\n// \"zxu\"\n// [\"u\",\"x\",\"zxu\",\"zx\",\"z\"]\n// [9,17,5,5,9] -> 5",
    "submit_ts": "1720322090",
    "subm_id": "1312340407"
}