{
    "username": "cuiaoxiang",
    "submission": "#define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const multiset<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntemplate <class T> auto vect(const T& v, int n) { return vector<T>(n, v); }\ntemplate <class T, class... D> auto vect(const T& v, int n, D... m) {\n  return vector<decltype(vect(v, m...))>(n, vect(v, m...));\n}\n\nusing int64 = long long;\nusing int128 = __int128_t;\nusing ii = pair<int, int>;\n#define SZ(x) (int)((x).size())\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nmt19937_64 mrand(random_device{}());\nint64 rnd(int64 x) { return mrand() % x; }\nconstexpr inline int lg2(int64 x) { return x == 0 ? -1 : sizeof(int64) * 8 - 1 - __builtin_clzll(x); }\nconstexpr inline int64 p2ceil(int64 x) { return 1LL << (lg2(x - 1) + 1); }\ntemplate <class T> void out(const vector<T>& a) { for (int i = 0; i < SZ(a); ++i) cout << a[i] << \" \\n\"[i + 1 == SZ(a)]; }\ntemplate <class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate <class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate <class T> void dedup(vector<T>& v) { sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); }\ninline void add_mod(int& x, int y) { x += y; if (x >= MOD) x -= MOD; }\ninline void sub_mod(int& x, int y) { x += MOD - y; if (x >= MOD) x -= MOD; }\ninline int mod(int x) { return x >= MOD ? x - MOD : x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\ntemplate <typename T, T (*op)(const T&, const T&)>\nstruct SparseTable {\n  vector<vector<T>> st;\n  SparseTable(const vector<T>& a) {\n    int n = SZ(a);\n    st.resize(lg2(n) + 1);\n    st[0] = a;\n    for (int k = 1; (1 << k) <= n; ++k) {\n      st[k].resize(n - (1 << k) + 1);\n      for (int i = 0; i + (1 << k) <= n; ++i) {\n        st[k][i] = op(st[k - 1][i], st[k - 1][i + (1 << (k - 1))]);\n      }\n    }\n  }\n  T query(int x, int y) const {\n    // assert(x <= y);\n    int k = lg2(y - x + 1);\n    return op(st[k][x], st[k][y - (1 << k) + 1]);\n  }\n};\n\nauto op = [](const int& a, const int& b) { return a & b; };\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& a, int k) {\n        int n = a.size();\n        SparseTable<int, op> D(a);\n        int64 ret = 0;\n        auto contain =\n            [&](int x, int y) {\n            return (x & y) == y;\n        };\n        for (int i = 0; i < n; ++i) {\n            int low = i, high = n - 1;\n            if (!contain(a[i], k)) continue;\n            while (low != high) {\n                int mid = (low + high + 1) / 2;\n                int x = D.query(i, mid);\n                if (!contain(x, k)) {\n                    high = mid - 1;\n                } else {\n                    low = mid;\n                }\n            }\n            int R = high;\n            low = i, high = n;\n            while (low != high) {\n                int mid = (low + high) / 2;\n                int x = D.query(i, mid);\n                if (contain(x, k) && x != k) {\n                    low = mid + 1;\n                } else {\n                    high = mid;\n                }\n            }\n            int L = high;\n            //cout << i << \" \" << L << \" \" << R << endl;\n            if (L <= R) ret += R - L + 1;\n        }\n        return ret;\n    }\n};",
    "submit_ts": "1720277351",
    "subm_id": "544556102"
}