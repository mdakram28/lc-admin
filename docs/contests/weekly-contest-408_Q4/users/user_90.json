{
    "username": "lwm7708",
    "submission": "#include <algorithm>\n#include <cmath>\n#include <utility>\n#include <vector>\n\ntemplate <typename T>\nclass Point {\n\npublic:\n\n    static auto cross(Point a, Point b) {\n\n        return a.x * b.y - a.y * b.x;\n\n    }\n\n    static auto dot(Point a, Point b) {\n\n        return a.x * b.x + a.y * b.y;\n\n    }\n\n    T x = T();\n    T y = T();\n\n    explicit Point() = default;\n\n    explicit Point(T x, T y) : x(x), y(y) {}\n\n    auto operator-() const {\n\n        return Point(-x, -y);\n\n    }\n\n    auto operator+=(Point other) {\n\n        x += other.x;\n        y += other.y;\n\n    }\n\n    auto operator-=(Point other) {\n\n        x -= other.x;\n        y -= other.y;\n\n    }\n\n    auto operator*=(T fact) {\n\n        x *= fact;\n        y *= fact;\n\n    }\n\n    auto operator/=(T div) {\n\n        x /= div;\n        y /= div;\n\n    }\n\n    auto norm() const {\n\n        return Point::dot(*this, *this);\n\n    }\n\n    auto length() const {\n\n        return std::hypot(x, y);\n\n    }\n\n    auto quadrant() const {\n\n        if (y == 0) {\n            if (x == 0) {\n                return 0;\n            }\n            return x > 0 ? 1 : 3;\n        }\n\n        if (y > 0) {\n            return x > 0 ? 1 : 2;\n        }\n\n        return x < 0 ? 3 : 4;\n\n    }\n\n    friend auto operator==(Point lhs, Point rhs) {\n\n        return lhs.x == rhs.x && lhs.y == rhs.y;\n\n    }\n\n    friend auto operator+(Point lhs, Point rhs) {\n\n        lhs += rhs;\n\n        return lhs;\n\n    }\n\n    friend auto operator-(Point lhs, Point rhs) {\n\n        lhs -= rhs;\n\n        return lhs;\n\n    }\n\n    friend auto operator*(Point lhs, T rhs) {\n\n        lhs *= rhs;\n\n        return lhs;\n\n    }\n\n    friend auto operator/(Point lhs, T rhs) {\n\n        lhs /= rhs;\n\n        return lhs;\n\n    }\n\n    friend auto operator*(T lhs, Point rhs) {\n\n        return rhs * lhs;\n\n    }\n\n};\n\ntemplate <typename F>\nclass YCombinator {\n\nprivate:\n\n    const F f = nullptr;\n\npublic:\n\n    explicit YCombinator(F&& f) : f(f) {}\n\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const {\n\n        return f(*this, std::forward<Args>(args)...);\n\n    }\n\n};\n\ntemplate <typename F>\nYCombinator(F) -> YCombinator<F>;\n\ntemplate <typename T>\nclass Segment {\n\nprivate:\n\n    using PointT = Point<T>;\n\npublic:\n\n    static auto intersects(const Segment& s_1, const Segment& s_2) {\n\n        const auto sign = [](PointT v_1, PointT v_2) {\n            const auto prod = PointT::cross(v_1, v_2);\n            if (prod == 0) {\n                return 0;\n            }\n            return prod > 0 ? 1 : -1;\n        };\n\n        const auto sign_1 = sign(s_1.b - s_1.a, s_2.a - s_1.a);\n        const auto sign_2 = sign(s_1.b - s_1.a, s_2.b - s_1.a);\n\n        if (sign_1 == 0 && sign_2 == 0) {\n            const auto isects = [](T a_1, T a_2, T b_1, T b_2) {\n                if (a_1 > a_2) {\n                    std::swap(a_1, a_2);\n                }\n                if (b_1 > b_2) {\n                    std::swap(b_1, b_2);\n                }\n                return std::max(a_1, b_1) <= std::min(a_2, b_2);\n            };\n            return (\n                isects(s_1.a.x, s_1.b.x, s_2.a.x, s_2.b.x) &&\n                isects(s_1.a.y, s_1.b.y, s_2.a.y, s_2.b.y)\n            );\n        }\n\n        const auto vec = s_2.b - s_2.a;\n\n        return sign_1 != sign_2 && sign(vec, s_1.a - s_2.a) != sign(vec, s_1.b - s_2.a);\n\n    }\n\n    PointT a = PointT();\n    PointT b = PointT();\n\n    explicit Segment() = default;\n\n    explicit Segment(PointT a, PointT b) : a(a), b(b) {}\n\n    auto contains(PointT p) const {\n\n        const auto [mn_x, mx_x] = std::minmax(a.x, b.x);\n        const auto [mn_y, mx_y] = std::minmax(a.y, b.y);\n\n        return (\n            PointT::cross(b - a, p - a) == 0 && p.x >= mn_x && p.x <= mx_x && p.y >= mn_y &&\n            p.y <= mx_y\n        );\n\n    }\n\n    auto length() const {\n\n        return (b - a).length();\n\n    }\n\n    auto norm() const {\n\n        return (b - a).norm();\n\n    }\n\n};\n\nusing PtT = Point<long long>;\nusing SegT = Segment<long long>;\n\nclass Solution {\n\npublic:\n\n    auto canReachCorner(int x, int y, std::vector<std::vector<int>>& circles) {\n\n        const auto seg_1 = SegT(PtT(), PtT(0, y));\n        const auto seg_2 = SegT(PtT(0, y), PtT(x, y));\n        const auto seg_3 = SegT(PtT(x, y), PtT(x, 0));\n        const auto seg_4 = SegT(PtT(x, 0), PtT());\n        const auto sz = static_cast<int>(std::size(circles));\n\n        auto adj = std::vector<std::vector<bool>>(sz + 2, std::vector<bool>(sz + 2));\n        auto vis = std::vector<bool>(sz + 2);\n\n        for (auto i = 0; i < sz; ++i) {\n            for (auto j = 0; j < sz; ++j) {\n                const auto sqr = [](long long base) {\n                    return base * base;\n                };\n                adj[i][j] = (\n                    sqr(circles[i][0] - circles[j][0]) + sqr(circles[i][1] - circles[j][1]) <=\n                    sqr(circles[i][2] + circles[j][2])\n                );\n            }\n        }\n\n        for (auto i = 0; i < sz; ++i) {\n            const auto c_x = circles[i][0];\n            const auto c_y = circles[i][1];\n            const auto r = circles[i][2];\n            const auto diam_1 = SegT(PtT(c_x - r, c_y), PtT(c_x + r, c_y));\n            const auto diam_2 = SegT(PtT(c_x, c_y - r), PtT(c_x, c_y + r));\n            auto isect = SegT::intersects(diam_1, seg_1);\n            adj[i][sz] = adj[i][sz] || isect;\n            adj[sz][i] = adj[sz][i] || isect;\n            isect = SegT::intersects(diam_2, seg_2);\n            adj[i][sz] = adj[i][sz] || isect;\n            adj[sz][i] = adj[sz][i] || isect;\n            isect = SegT::intersects(diam_1, seg_3);\n            adj[i][sz + 1] = adj[i][sz + 1] || isect;\n            adj[sz + 1][i] = adj[sz + 1][i] || isect;\n            isect = SegT::intersects(diam_2, seg_4);\n            adj[i][sz + 1] = adj[i][sz + 1] || isect;\n            adj[sz + 1][i] = adj[sz + 1][i] || isect;\n        }\n\n        YCombinator(\n            [&](auto self, int node) -> void {\n                vis[node] = true;\n                for (auto i = 0; i < sz + 2; ++i) {\n                    if (adj[node][i] && !vis[i]) {\n                        self(i);\n                    }\n                }\n            }\n        )(sz);\n\n        return !vis[sz + 1];\n\n    }\n\n};\n",
    "submit_ts": "1722138180",
    "subm_id": "1335784219"
}