{
    "username": "vermachakshu",
    "submission": "typedef long long ll;\n\nstruct seg_tree{\n    int NEUTRAL_ELEMENT;\n    int NEUTRAL_UPDATE;\n    ll size;\n    int N;\n    vector<int> lazy;\n    vector<int> st;\n\n    void init(int n){\n        size = 1;\n        N = n;\n        while(size < n) size <<= 1;\n\n        NEUTRAL_UPDATE = -1;\n        NEUTRAL_ELEMENT = -1;\n        lazy.assign(2 * size, NEUTRAL_UPDATE);\n        st.assign(2 * size, 0);\n    }\n\n    int combine(int x, int y){\n        int res = max(x, y);\n        return res;\n    }\n\n    int apply(int curr, int upd, int lx, int rx){\n        if(upd == NEUTRAL_UPDATE)   return curr;\n        int res = upd; \n        return res;\n    }\n\n    int combineUpdate(int new_upd, int old_upd){\n        int res =(new_upd == NEUTRAL_UPDATE)?old_upd:new_upd;\n        return res;\n    }\n\n    void build(int node, int lx, int rx){\n        if(rx - lx == 1){\n            if(lx < N)\n                st[node] = 0;\n            return;\n        }\n        int tm = (lx + rx) >> 1;\n        build(2*node + 1, lx, tm);\n        build(2*node + 2, tm, rx);\n        st[node] = combine(st[2*node + 1], st[2*node + 2]);\n    }\n\n    void propagate(ll node, ll lx, ll rx){\n        if(rx - lx > 1){\n            // Non leaf node\n            int tm = (lx + rx) >> 1;\n            lazy[2*node + 1] = combineUpdate(lazy[node], lazy[2*node + 1]);\n            lazy[2*node + 2] = combineUpdate(lazy[node], lazy[2*node + 2]);\n            st[2*node + 1] = apply(st[2*node + 1], lazy[node], lx, tm);\n            st[2*node + 2] = apply(st[2*node + 2], lazy[node], tm, rx);\n            lazy[node] = NEUTRAL_UPDATE;\n        }\n    }\n\n    void update(int l, int r, int node, int val, int lx, int rx){\n        if(lx >= r || rx <= l){\n            return;\n        }\n        if(lx >= l && rx <= r){\n            lazy[node] = combineUpdate(val, lazy[node]);\n            st[node] = apply(st[node], val, lx, rx);\n            return;\n        }\n\n        propagate(node, lx, rx);\n        int m = (lx + rx) >> 1;\n        update(l, r, 2 * node + 1, val, lx, m);\n        update(l, r, 2 * node + 2, val, m, rx);\n        st[node] = combine(st[2 * node + 1], st[2 * node + 2]);\n    }\n\n    void update(int l, int r, int val){\n        update(l, r, 0, val, 0, size);\n    }\n\n    int query(int l, int r, int node, int lx, int rx){\n        if(rx <= l || lx >= r)  return NEUTRAL_ELEMENT;\n        if(lx >= l && rx <= r){\n            return st[node];\n        }\n        propagate(node, lx, rx);\n        int m = (lx + rx) >> 1;\n        int res = combine(query(l, r, 2 * node + 1, lx, m), query(l, r, 2 * node + 2, m, rx));\n        st[node] = combine(st[2 * node + 1], st[2 * node + 2]);\n        return res;\n    }\n\n    int query(int l, int r){\n        return query(l, r, 0, 0, size);\n    }\n\n    void build(){\n        build(0, 0, size);\n    }\n} st;\n\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& quer) {\n        vector<bool> ans;\n        int n = quer.size();\n        set<int> pts;\n        \n        seg_tree st;\n        st.init(3 * n + 2);\n        pts.insert(0);\n        \n        \n        for(auto q:quer){\n            int type = q[0];\n            int x = q[1];\n            if(type == 1){\n                auto ub = pts.upper_bound(x);\n                auto lb = prev(ub);\n                \n                st.update(x, x + 1, x - *lb);\n                if(ub != pts.end()) st.update(*ub, *ub + 1, *ub - x);\n                // cout << st.query(x, x + 1) << endl;\n                pts.insert(x);\n            }\n            else{\n                int sz = q[2];\n                int mx = st.query(1, x + 1);\n                // cout << mx << \" \";\n                auto ub = pts.upper_bound(x);\n                ub = prev(ub);\n                mx = max(mx, x - *ub);\n                // cout << *ub << endl;\n                ans.push_back(mx >= sz);\n            }\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": 1716649197.0
}