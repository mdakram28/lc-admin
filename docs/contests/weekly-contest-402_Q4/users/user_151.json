{
    "username": "megaspazz",
    "submission": "class Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        final int N = nums.length;\n        \n        PrimitiveAVLSegmentTree st = new PrimitiveAVLSegmentTree();\n        for (int i = 0; i < N; ++i) {\n            st.insert(i, isPeak(nums, i));\n        }\n        \n        List<Integer> ans = new ArrayList<>();\n        for (int[] query : queries) {\n            final int T = query[0];\n            if (T == 1) {\n                final int L = query[1];\n                final int R = query[2];\n                \n                ans.add((int) st.get(L + 1, R - 1));\n            } else {\n                final int IDX = query[1];\n                final int VAL = query[2];\n                \n                nums[IDX] = VAL;\n                for (int i = IDX - 1; i <= IDX + 1; ++i) {\n                    st.insert(i, isPeak(nums, i));\n                }\n            }\n        }\n        return ans;\n    }\n    \n    private static int isPeak(int[] nums, int i) {\n        final int N = nums.length;\n        if (i <= 0 || i >= N - 1) {\n            return 0;\n        }\n        if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {\n            return 1;\n        }\n        return 0;\n    }\n    \n\t/**\n\t * PrimitiveAVLSegmentTree does generic range operations in O(log N) time.\n\t * Use your editor's find-and-replace to rename the types into primitives, since Java doesn't support generics of primitives.\n\t */\n\tpublic static class PrimitiveAVLSegmentTree {\n\t\t// Implement the key comparison function, return type should be same as Comparator.compare.\n\t\tprivate static int compareKey(int a, int b) {\n\t\t\treturn Integer.compare(a, b);\n\t\t}\n\n\t\t// Implement the value merge function.\n\t\tprivate static long mergeValue(long a, long b) {\n            return a + b;\n\t\t}\n\n\t\t// The default value if nothing in range.\n\t\tprivate static final long DEFAULT_VALUE = 0;\n\n\t\tprivate AVLTreeNode root;\n\n\t\tpublic void insert(int key, long value) {\n\t\t\tif (root == null) {\n\t\t\t\troot = new AVLTreeNode(key);\n\t\t\t}\n\t\t\troot.insert(key, value);\n\t\t\troot = rebalance(root);\n\t\t}\n\n\t\tpublic void increment(int key, long value) {\n\t\t\tinsert(key, mergeValue(get(key), value));\n\t\t}\n\n\t\tpublic long get(int k) {\n\t\t\tif (root == null) {\n\t\t\t\treturn DEFAULT_VALUE;\n\t\t\t}\n\t\t\treturn root.get(k);\n\t\t}\n\n\t\tpublic long get(int lo, int hi) {\n\t\t\tif (root == null) {\n\t\t\t\treturn DEFAULT_VALUE;\n\t\t\t}\n\t\t\treturn root.get(lo, hi);\n\t\t}\n\n\t\tprivate static class AVLTreeNode {\n\t\t\tprivate int key;\n\t\t\tprivate long val;\n\t\t\tprivate long sum;  // more of an accumulator than a true \"sum\"\n\t\t\tprivate int ht;\n\n\t\t\tprivate AVLTreeNode left;\n\t\t\tprivate AVLTreeNode right;\n\n\t\t\tpublic AVLTreeNode(int key) {\n\t\t\t\tthis.key = key;\n\t\t\t\tthis.val = DEFAULT_VALUE;\n\t\t\t}\n\n\t\t\tpublic void insert(int k, long v) {\n\t\t\t\tint c = compareKey(k, key);\n\t\t\t\tif (c < 0) {\n\t\t\t\t\tleft = getOrCreate(left, k);\n\t\t\t\t\tleft.insert(k, v);\n\t\t\t\t} else if (c > 0) {\n\t\t\t\t\tright = getOrCreate(right, k);\n\t\t\t\t\tright.insert(k, v);\n\t\t\t\t} else {\n\t\t\t\t\tval = v;\n\t\t\t\t}\n\t\t\t\tleft = rebalance(left);\n\t\t\t\tright = rebalance(right);\n\t\t\t\tupdate();\n\t\t\t}\n\n\t\t\tpublic long get(int k) {\n\t\t\t\treturn get(k, k);\n\t\t\t}\n\n\t\t\tpublic long get(int lo, int hi) {\n\t\t\t\tAVLTreeNode curr = this;\n\t\t\t\twhile (curr != null) {\n\t\t\t\t\tif (compareKey(lo, curr.key) <= 0 && compareKey(curr.key, hi) <= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (compareKey(hi, curr.key) < 0) {\n\t\t\t\t\t\tcurr = curr.left;\n\t\t\t\t\t} else if (compareKey(lo, curr.key) > 0) {\n\t\t\t\t\t\tcurr = curr.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (curr == null) {\n\t\t\t\t\treturn DEFAULT_VALUE;\n\t\t\t\t}\n\n\t\t\t\tlong ans = curr.val;\n\t\t\t\tif (curr.left != null) {\n\t\t\t\t\tans = mergeValue(ans, curr.left.getSumGTE(lo));\n\t\t\t\t}\n\t\t\t\tif (curr.right != null) {\n\t\t\t\t\tans = mergeValue(ans, curr.right.getSumLTE(hi));\n\t\t\t\t}\n\t\t\t\treturn ans;\n\t\t\t}\n\n\t\t\tprivate void update() {\n\t\t\t\tcomputeHeight();\n\t\t\t\tcomputeSum();\n\t\t\t}\n\n\t\t\tprivate int computeHeight() {\n\t\t\t\tht = 1 + Math.max(getHeight(left), getHeight(right));\n\t\t\t\treturn ht;\n\t\t\t}\n\n\t\t\tprivate long computeSum() {\n\t\t\t\tsum = mergeValue(val, mergeValue(getSum(left), getSum(right)));\n\t\t\t\treturn sum;\n\t\t\t}\n\n\t\t\tprivate long getSumLTE(int k) {\n\t\t\t\tAVLTreeNode curr = this;\n\t\t\t\tlong sum = DEFAULT_VALUE;\n\t\t\t\twhile (curr != null) {\n\t\t\t\t\tif (compareKey(k, curr.key) < 0) {\n\t\t\t\t\t\tcurr = curr.left;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsum = mergeValue(sum, mergeValue(curr.val, getSum(curr.left)));\n\t\t\t\t\t\tcurr = curr.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\n\t\t\tprivate long getSumGTE(int k) {\n\t\t\t\tAVLTreeNode curr = this;\n\t\t\t\tlong sum = DEFAULT_VALUE;\n\t\t\t\twhile (curr != null) {\n\t\t\t\t\tif (compareKey(k, curr.key) > 0) {\n\t\t\t\t\t\tcurr = curr.right;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsum = mergeValue(sum, mergeValue(curr.val, getSum(curr.right)));\n\t\t\t\t\t\tcurr = curr.left;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\n\t\t\tprivate AVLTreeNode getOrCreate(AVLTreeNode node, int k) {\n\t\t\t\tif (node != null) {\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t\treturn new AVLTreeNode(k);\n\t\t\t}\n\n\t\t\tprivate long getSum(AVLTreeNode node) {\n\t\t\t\tif (node == null) {\n\t\t\t\t\treturn DEFAULT_VALUE;\n\t\t\t\t}\n\t\t\t\treturn node.sum;\n\t\t\t}\n\t\t}\n\n\t\tprivate static int getHeight(AVLTreeNode node) {\n\t\t\tif (node == null) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn node.ht;\n\t\t}\n\n\t\tprivate static int balanceFactor(AVLTreeNode root) {\n\t\t\treturn getHeight(root.left) - getHeight(root.right);\n\t\t}\n\n\t\tprivate static AVLTreeNode rebalance(AVLTreeNode node) {\n\t\t\tif (node == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tint bf = balanceFactor(node);\n\t\t\tif (bf > 1) {\n\t\t\t\treturn rotateRight(node);\n\t\t\t} else if (bf < -1) {\n\t\t\t\treturn rotateLeft(node);\n\t\t\t} else {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\n\t\tprivate static AVLTreeNode rotateRight(AVLTreeNode root) {\n\t\t\tAVLTreeNode pivot = root.left;\n\t\t\troot.left = pivot.right;\n\t\t\tpivot.right = root;\n\t\t\troot.update();\n\t\t\tpivot.update();\n\t\t\treturn pivot;\n\t\t}\n\n\t\tprivate static AVLTreeNode rotateLeft(AVLTreeNode root) {\n\t\t\tAVLTreeNode pivot = root.right;\n\t\t\troot.right = pivot.left;\n\t\t\tpivot.left = root;\n\t\t\troot.update();\n\t\t\tpivot.update();\n\t\t\treturn pivot;\n\t\t}\n\t}\n}",
    "submit_ts": "1718506251",
    "subm_id": "1289612334"
}