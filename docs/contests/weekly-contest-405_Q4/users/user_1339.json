{
    "username": "romadyag26",
    "submission": "class Solution {\npublic:\n\n// Fills lps[] for given pattern pat[0..M-1]\nvoid computeLPSArray(string& pat, int M, int* lps)\n{\n    // length of the previous longest prefix suffix\n    int len = 0;\n \n    lps[0] = 0; // lps[0] is always 0\n \n    // the loop calculates lps[i] for i = 1 to M-1\n    int i = 1;\n    while (i < M) {\n        if (pat[i] == pat[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        }\n        else // (pat[i] != pat[len])\n        {\n            // This is tricky. Consider the example.\n            // AAACAAAA and i = 7. The idea is similar\n            // to search step.\n            if (len != 0) {\n                len = lps[len - 1];\n \n                // Also, note that we do not increment\n                // i here\n            }\n            else // if (len == 0)\n            {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n}\n \n// Prints occurrences of pat[] in txt[]\nvoid KMPSearch(string& pat, string& txt, int pat_idx, vector<vector<int>>& vec)\n{\n    int M = pat.size();\n    int N = txt.size();\n    //vector<int> ans;\n    // create lps[] that will hold the longest prefix suffix\n    // values for pattern\n    int lps[M];\n \n    // Preprocess the pattern (calculate lps[] array)\n    computeLPSArray(pat, M, lps);\n \n    int i = 0; // index for txt[]\n    int j = 0; // index for pat[]\n    while ((N - i) >= (M - j)) {\n        if (pat[j] == txt[i]) {\n            j++;\n            i++;\n        }\n \n        if (j == M) {\n            //ans.push_back(i-j); //printf(\"Found pattern at index %d \", i - j);\n            vec[i-j].push_back(pat_idx);\n            j = lps[j - 1];\n        }\n \n        // mismatch after j matches\n        else if (i < N && pat[j] != txt[i]) {\n            // Do not match lps[0..lps[j-1]] characters,\n            // they will match anyway\n            if (j != 0)\n                j = lps[j - 1];\n            else\n                i = i + 1;\n        }\n    }\n    //return ans;\n}\n    int solve(vector<vector<int>>& vec, vector<string>& words, vector<int>& costs, vector<int>& dp, int i, int n)\n    {\n        if(i==n)\n            return 0;\n        if(dp[i]!=-1)\n            return dp[i];\n        int ans=INT_MAX;\n        for(auto idx:vec[i])\n        {\n            if(i+words[idx].size()<=n)\n            {\n                auto tmp=solve(vec, words, costs, dp, i+words[idx].size(), n);\n                if(tmp!=INT_MAX)\n                    ans=min(ans, costs[idx]+tmp);\n            }\n        }\n        return dp[i]=ans;\n    }\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int n=target.size();\n        vector<vector<int>> vec(n);\n        unordered_map<string, int> mp;\n        for(int i=0;i<words.size(); i++)\n        {\n            if(!mp.count(words[i]) || costs[i]<mp[words[i]])\n            {\n                KMPSearch(words[i], target, i, vec);\n                mp[words[i]]=costs[i];\n            }\n        }\n        \n        vector<int> dp(n, -1);\n        auto ans=solve(vec,words,costs,dp, 0, n);\n        return ans==INT_MAX? -1 : ans;\n        //return 0;\n    }\n};",
    "submit_ts": "1720323072",
    "subm_id": "1312366629"
}