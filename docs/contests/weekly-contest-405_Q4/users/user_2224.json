{
    "username": "user5976fh",
    "submission": "class Solution {\npublic:\n    vector<int> KMP(const string& target, const string& word) {\n        int m = word.size();\n        int n = target.size();\n        vector<int> lps(m, 0);\n\n        int j = 0;\n        for (int i = 1; i < m; ++i) {\n            while (j > 0 && word[i] != word[j]) {\n                j = lps[j - 1];\n            }\n            if (word[i] == word[j]) {\n                ++j;\n                lps[i] = j;\n            } else {\n                lps[i] = 0;\n            }\n        }\n\n        vector<int> occurrences;\n        int i = 0;\n        j = 0;\n        while (i < n) {\n            if (word[j] == target[i]) {\n                ++i;\n                ++j;\n            }\n            if (j == m) {\n                occurrences.push_back(i - j);\n                j = lps[j - 1];\n            } else if (i < n && word[j] != target[i]) {\n                if (j != 0) {\n                    j = lps[j - 1];\n                } else {\n                    ++i;\n                }\n            }\n        }\n        return occurrences;\n    }\n\n    bool dfs(int u, vector<vector<pair<int, int>>>& graph, vector<bool>& visited, vector<bool>& reachable) {\n        if (u == graph.size() - 1) return true;\n        if (visited[u]) return reachable[u];\n        visited[u] = true;\n\n        bool canReach = false;\n        for (auto it = graph[u].begin(); it != graph[u].end();) {\n            if (dfs(it->first, graph, visited, reachable)) {\n                canReach = true;\n                ++it;\n            } else {\n                it = graph[u].erase(it);\n            }\n        }\n\n        reachable[u] = canReach;\n        return canReach;\n    }\n\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n      // auto start = chrono::high_resolution_clock::now();\n        \n        unordered_map<string, int> minCostMap;\n        for (int i = 0; i < words.size(); ++i) {\n            if (minCostMap.find(words[i]) == minCostMap.end() || minCostMap[words[i]] > costs[i]) {\n                minCostMap[words[i]] = costs[i];\n            }\n        }\n\n        vector<string> prunedWords;\n        vector<int> prunedCosts;\n        for (const auto& entry : minCostMap) {\n            prunedWords.push_back(entry.first);\n            prunedCosts.push_back(entry.second);\n        }\n\n      //  auto end = chrono::high_resolution_clock::now();\n       // cout << \"Pruning words took \" << chrono::duration_cast<chrono::milliseconds>(end - start).count() << \" ms\" << endl;\n\n     //   start = chrono::high_resolution_clock::now();\n\n        int n = target.size();\n        vector<vector<pair<int, int>>> graph(n + 1);\n\n        for (int i = 0; i < prunedWords.size(); ++i) {\n            int cost = prunedCosts[i];\n            vector<int> occurrences = KMP(target, prunedWords[i]);\n            for (int startIdx : occurrences) {\n                int endIdx = startIdx + prunedWords[i].size();\n                graph[startIdx].emplace_back(endIdx, cost);\n            }\n        }\n\n    //    end = chrono::high_resolution_clock::now();\n    //    cout << \"Graph construction took \" << chrono::duration_cast<chrono::milliseconds>(end - start).count() << \" ms\" << endl;\n\n     //   start = chrono::high_resolution_clock::now();\n\n      //  vector<bool> visited(n + 1, false);\n    //    vector<bool> reachable(n + 1, false);\n       // dfs(0, graph, visited, reachable);\n\n      //  end = chrono::high_resolution_clock::now();\n      //  cout << \"DFS execution took \" << chrono::duration_cast<chrono::milliseconds>(end - start).count() << \" ms\" << endl;\n\n     //   start = chrono::high_resolution_clock::now();\n\n        vector<int> minCost(n + 1, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n\n        minCost[0] = 0;\n        pq.emplace(0, 0);\n\n        while (!pq.empty()) {\n            auto [currentCost, u] = pq.top();\n            pq.pop();\n\n            if (u == n) {\n               // end = chrono::high_resolution_clock::now();\n              //  cout << \"Shortest path search took \" << chrono::duration_cast<chrono::milliseconds>(end - start).count() << \" ms\" << endl;\n                return currentCost;\n            }\n\n            if (currentCost > minCost[u]) continue;\n\n            for (const auto& [v, edgeCost] : graph[u]) {\n                int newCost = currentCost + edgeCost;\n                if (newCost < minCost[v]) {\n                    minCost[v] = newCost;\n                    pq.emplace(newCost, v);\n                }\n            }\n        }\n\n      //  end = chrono::high_resolution_clock::now();\n    //    cout << \"Shortest path search took \" << chrono::duration_cast<chrono::milliseconds>(end - start).count() << \" ms\" << endl;\n\n        return -1;\n    }\n};",
    "submit_ts": "1720324155",
    "subm_id": "1312392875"
}