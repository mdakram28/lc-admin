{
    "username": "flashmt",
    "submission": "const int oo = 5e8;\n\ntemplate<typename T>\nstruct FenwickTree\n{\n  int n, indexBase;\n  vector<T> a;\n\n  FenwickTree(int n, T ini, int indexBase = 1): n(n), indexBase(indexBase)\n  {\n    a = vector<T>(n + 1, ini);\n  }\n\n  void add(int x, T v)\n  {\n    for (int i = x + 1 - indexBase; i <= n; i += i & -i)\n      a[i] = min(a[i], v);\n  }\n\n  T get(int x)\n  {\n    T res = make_pair(oo, -1);\n    for (int i = x + 1 - indexBase; i; i -= i & -i)\n      res = min(res, a[i]);\n    return res;\n  }\n};\n\nclass Solution {\npublic:\n  tuple<int, int, int> solve(vector<pair<int, int>> &a)\n  {\n    map<int, int> allY;\n    int n = size(a);\n    vector<int> id(n);\n    for (int i = 0; i < n; i++)\n    {\n      allY[a[i].second] = 0;\n      id[i] = i;\n    }\n\n    int cntY = 0;\n    for (auto [k, v] : allY)\n      allY[k] = cntY++;\n\n    sort(begin(id), end(id), [&](int u, int v) { return a[u] < a[v]; });\n    FenwickTree<pair<int, int>> tree(cntY, pair<int, int>(oo, -1), 0);\n    int maxDist = -1, resX = -1, resY = -1;\n    for (int i = 0; i < n; i++)\n    {\n      int curId = id[i];\n      auto [x, y] = a[curId];\n      int sum = x + y;\n      y = allY[y];\n      auto u = tree.get(y);\n      if (sum - u.first > maxDist)\n      {\n        maxDist = sum - u.first;\n        resX = curId;\n        resY = u.second;\n      }\n      tree.add(y, make_pair(sum, curId));\n    }\n\n    return make_tuple(maxDist, resX, resY);\n  }\n\n  tuple<int, int, int> getMaxDist(vector<pair<int, int>> a)\n  {\n    int res = -1, u = -1, v = -1;\n    for (int i = 0; i < 4; i++)\n    {\n      auto [ress, uu, vv] = solve(a);\n      if (ress > res)\n      {\n        res = ress;\n        u = uu;\n        v = vv;\n      }\n\n      for (int j = 0; j < size(a); j++)\n      {\n        auto [x, y] = a[j];\n        a[j] = make_pair(2e8 - y, x);\n      }\n    }\n\n    return make_tuple(res, u, v);\n  }\n\n  int minimumDistance(vector<vector<int>>& points) {\n    vector<pair<int, int>> a;\n    for (auto u : points)\n      a.push_back({u[0], u[1]});\n    auto [_, p, q] = getMaxDist(a);\n\n    auto b = a;\n    b.erase(begin(b) + p);\n    auto [dist1, p1, q1] = getMaxDist(b);\n\n    a.erase(begin(a) + q);\n    auto [dist2, p2, q2] = getMaxDist(a);\n\n    return min(dist1, dist2);\n  }\n};"
}