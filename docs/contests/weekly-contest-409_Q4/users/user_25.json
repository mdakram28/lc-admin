{
    "username": "flashmt",
    "submission": "template<typename T>\nstruct SegmentTree\n{\n  int low, mid, high;\n  T value, save;\n  SegmentTree *l, *r;\n\n  T merge(T u, T v)\n  {\n    return u + v;\n  }\n\n  SegmentTree(int low, int high): low(low), high(high)\n  {\n    mid = (low + high) / 2;\n    value = save = 0;\n    if (low == high) l = r = NULL;\n    else\n    {\n      l = new SegmentTree(low, mid);\n      r = new SegmentTree(mid + 1, high);\n    }\n  }\n\n  void updateNode(T v)\n  {\n    value += v * (high - low + 1);\n    save += v;\n  }\n\n  void pushDown()\n  {\n    if (!save)\n      return;\n    l->updateNode(save);\n    r->updateNode(save);\n    save = 0;\n  }\n\n  void update(int x, int y, T v)\n  {\n    if (low == x && high == y)\n    {\n      updateNode(v);\n      return;\n    }\n    pushDown();\n    if (x <= mid)\n      l->update(x, min(y, mid), v);\n    if (mid < y)\n      r->update(max(x, mid + 1), y, v);\n    value = merge(l->value, r->value);\n  }\n\n  T get(int x, int y)\n  {\n    if (low == x && high == y)\n      return value;\n    pushDown();\n    if (y <= mid) return l->get(x, y);\n    else if (x > mid) return r->get(x, y);\n    else return merge(l->get(x, mid), r->get(mid + 1, y));\n  }\n};\n\nclass Solution {\npublic:\n  vector<int> numberOfAlternatingGroups(vector<int>& a, vector<vector<int>>& queries) {\n    int n = size(a);\n    for (int i = 0; i < n; i++)\n      a.push_back(a[i]);\n    int bound = n * 2 - 3;\n    set<int> zeroes = {bound};\n    SegmentTree<int> tree(1, n * 2);\n\n    auto updateRange = [&](int from, int to, int val)\n    {\n      int low = 1, high = to - from + 1;\n      if (to >= n)\n        low += to - (n - 1);\n      if (low <= high)\n        tree.update(low, high, val);\n    };\n\n    for (int i = bound - 1, last = bound; i >= -1; i--)\n      if (i < 0 || a[i] == a[i + 1])\n      {\n        updateRange(i + 1, last - 1, 1);\n        last = i;\n        zeroes.insert(i);\n      }\n\n    auto flip = [&](int i)\n    {\n      if (zeroes.count(i))\n      {\n        zeroes.erase(i);\n        auto u = zeroes.lower_bound(i);\n        int r = *u, l = *prev(u);\n        updateRange(i + 1, r - 1, -1);\n        updateRange(l + 1, i - 1, -1);\n        updateRange(l + 1, r - 1, 1);\n      }\n      else\n      {\n        auto u = zeroes.lower_bound(i);\n        int r = *u, l = *prev(u);\n        updateRange(i + 1, r - 1, 1);\n        updateRange(l + 1, i - 1, 1);\n        updateRange(l + 1, r - 1, -1);\n        zeroes.insert(i);\n      }\n    };\n\n    vector<int> ans;\n    for (auto u : queries)\n      if (u[0] == 1)\n      {\n        int cnt = tree.get(u[1] - 1, n * 2);\n        ans.push_back(cnt);\n      }\n      else\n      {\n        int i = u[1], c = u[2];\n        if (a[i] != c)\n        {\n          flip(i);\n          if (i)\n            flip(i - 1);\n          a[i] = a[i + n] = c;\n          i += n;\n          if (i < bound)\n            flip(i);\n          if (i - 1 < bound)\n            flip(i - 1);\n        }\n      }\n\n    return ans;\n  }\n};",
    "submit_ts": "1722742889",
    "subm_id": "1343779426"
}