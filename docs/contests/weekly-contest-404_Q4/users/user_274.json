{
    "username": "TimmyChiang",
    "submission": "class Solution {\npublic:\n    void buildTree(vector<vector<int>>& G, const vector<vector<int>>& edges) {\n        for (auto &v: edges) {\n            G[v[0]].push_back(v[1]);\n            G[v[1]].push_back(v[0]);\n        }\n    }\n    void dfs(const vector<vector<int>>& G, int u, int &maxdepth, int &node, int level, int par) {\n        for (auto &v: G[u])\n            if (v != par)\n                dfs(G, v, maxdepth, node, level + 1, u);\n        if (level > maxdepth) {\n            maxdepth = level;\n            node = u;\n        }\n    }\n    void dfs2(const vector<vector<int>>& G, int u, int& maxdepth, int level, int par) {\n        for (auto &v: G[u])\n            if (v != par)\n                dfs2(G, v, maxdepth, level + 1, u);\n        maxdepth = max(maxdepth, level);\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        vector<vector<int>> G1(edges1.size()+1), G2(edges2.size()+1);\n        buildTree(G1, edges1);\n        buildTree(G2, edges2);\n        int maxdepth1 = 0, node1 = 0, maxdepth2 = 0, node2 = 0;\n        dfs(G1, 0, maxdepth1, node1, 0, -1);\n        maxdepth1 = 0;\n        dfs2(G1, node1, maxdepth1, 0, -1);\n        dfs(G2, 0, maxdepth2, node2, 0, -1);\n        maxdepth2 = 0;\n        dfs2(G2, node2, maxdepth2, 0, -1);\n        // cout << \"node1 = \" << node1 << \", node2 = \" << node2 << '\\n';\n        // cout << maxdepth1 << \" \" << maxdepth2 << '\\n';\n        return max({(maxdepth1 + 1) / 2 + (maxdepth2 + 1) / 2 + 1, maxdepth1, maxdepth2});\n    }\n};",
    "submit_ts": "1719718235",
    "subm_id": "1304412107"
}