{
    "username": "fjzzq2002",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ 63333\n#define fi first\n#define se second\ntypedef long long ll;\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\nint len(int x,int y) {\n    return (y-x+1);\n}\nint len(pii s) {\n    return len(s.fi,s.se);\n}\nstruct BB {\nint bs[SZ];\nvoid edt(int x,int y) {\n    x=SZ-10-x;\n    for(;x<SZ;x+=x&-x) bs[x]+=y;\n}\nint qry(int x) {\n    x=SZ-10-x;\n    int ans=0;\n    for(;x;x-=x&-x) ans+=bs[x];\n    return ans;\n}\nvoid clr(int x) {\n    x=SZ-10-x;\n    for(;x<SZ;x+=x&-x) bs[x]=0;\n}\n}B[2];\nvoid edt(int x,int y) {\n    cerr<<\"edt::\"<<x<<\" \"<<y<<\"\\n\";\n    B[1].edt(x,x*y);\n    B[0].edt(x,y);\n}\nint qry(int x) {\n    return B[1].qry(x)+(1-x)*B[0].qry(x);\n}\nclass Solution {\npublic:\n    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {\n        map<int,int> C;\n        int n=colors.size();\n        for(int i=0;i<colors.size();++i) {\n            int r=i;\n            while(r<colors.size() && (colors[r]+colors[i]+r+i)%2==0) ++r;\n            C[i]=r-1;\n            edt(r-i,1);\n            i=r-1;\n        }\n        vector<int> aa;\n        for(auto q:queries) {\n            if(q[0]==1) {\n                int ans=qry(q[1]);\n                auto A=*C.begin(),B=*C.rbegin();\n                if(A!=B) {\n                    // see if we can glue them\n                    if(colors[0]!=colors.back()) {\n                        int l1=A.se-A.fi+1;\n                        int l2=B.se-B.fi+1;\n                        ans-=max(l1-q[1]+1,0);\n                        ans-=max(l2-q[1]+1,0);\n                        ans+=max(l1+l2-q[1]+1,0);\n                    }\n                }\n                else if(colors[0]!=colors.back()) {\n                    ans=n;\n                }\n                aa.pb(ans);\n            }\n            else {\n                int x=q[1],y=q[2];\n                if(colors[x]==y) continue;\n                colors[x]=y;\n                // find the block x is in\n                auto it=C.upper_bound(x);\n                --it;\n                assert(it!=C.end()&&it->fi<=x&&it->se>=x);\n                int L=it->fi,R=it->se;\n                edt(len(*it),-1);\n                C.erase(it);\n                int ML=x,MR=x;\n                if(L!=ML) {\n                    C[L]=x-1;\n                    edt(len(L,x-1),1);\n                }\n                else {\n                    if(x&&colors[x]!=colors[x-1]) {\n                        // check prev block\n                        auto it=C.upper_bound(x);\n                        --it;\n                        ML=it->fi;\n                        edt(len(*it),-1);\n                        C.erase(it);\n                    }\n                }\n                if(R!=MR) {\n                    C[x+1]=R;\n                    edt(len(x+1,R),1);\n                }else{\n                    if(x+1<colors.size()&&colors[x+1]!=colors[x]) {\n                        auto it=C.upper_bound(x);\n                        MR=it->se;\n                        edt(len(*it),-1);\n                        C.erase(it);\n                    }\n                }\n                C[ML]=MR;\n                edt(len(ML,MR),1);\n            }\n        }\n        for(int i=0;i<=n+2;++i) B[0].clr(i),B[1].clr(i);\n        return aa;\n    }\n};",
    "submit_ts": "1722740293",
    "subm_id": "1343716087"
}