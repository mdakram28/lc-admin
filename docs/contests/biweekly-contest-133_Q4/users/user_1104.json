{
    "username": "U_U",
    "submission": "\nbool compareVec(vector<int>& a, vector<int>& b)\n{\n    return a[0] < b[0];\n}\n\nclass Solution {\npublic:\n    vector<int> limits;\n    vector<int> exact;\n    int64_t mod = 1e9 + 7;\n    int numberOfPermutations(int n, vector<vector<int>>& requirements) {\n        sort(requirements.begin(), requirements.end(), compareVec);\n        \n        int maxInv = n * (n - 1) / 2;\n        limits.assign(n + 1, -1);\n        exact.assign(n + 1, -1);                \n        \n        int maxVal = 0;\n        int index = 0;\n        for (int i = 0; i <= n; ++i)\n        {\n            if (index < requirements.size() && requirements[index][0] + 1 == i)\n            {\n                maxVal = max(maxVal, requirements[index][1]);\n                exact[ requirements[index][0] + 1 ] = requirements[index][1];\n                ++index;\n            }\n            limits[i] = maxVal; \n        }\n        \n                \n        vector< vector<int64_t> > dp(n + 1, vector<int64_t>(maxInv + 1, -1));\n        \n   \n            FindNum(requirements.back()[0] + 1, requirements.back()[1], dp);\n        \n              \n        return dp[ requirements.back()[0] + 1 ][ requirements.back()[1] ];\n    }\n    \n      \n    // method recursively calculates \n    // permutation with K inversion\n    int FindNum(int N, int K, vector< vector<int64_t>>& dp)\n    {   \n        if (dp[N][K] != -1) return dp[N][K];\n        \n        int64_t sum = 0;\n        // base cases\n        if (N == 0) \n        {\n            sum = 0;\n        }\n        else if (K == 0) \n        {\n            sum = 1;\n        }\n        else \n        {                \n            for (int i = 0; i <= K; i++)\n            {                 \n                if (i <= N - 1) \n                {\n                    if (exact[N - 1] == -1)\n                    {\n                      if (K - i >= limits[N - 1]) sum += FindNum(N - 1, K - i, dp);                    \n                    }\n                    else \n                    {\n                      if (K - i == exact[N - 1]) sum += FindNum(N - 1, K - i, dp);                    \n                    }\n                    //sum += FindNum(N - 1, K - i, dp);                    \n                }\n                sum %= mod;\n            }\n        }\n         \n        dp[N][K] = sum % mod;    \n        return sum;\n    }\n};",
    "submit_ts": 1719071165.0
}