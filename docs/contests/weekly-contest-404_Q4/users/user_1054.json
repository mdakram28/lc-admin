{
    "username": "foxintohumanbeing",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def tree_diameter(edges):\n            def bfs(start):\n                queue = deque([start])\n                visited = {start}\n                last_node = start\n                distance = {start: 0}\n\n                while queue:\n                    node = queue.popleft()\n                    last_node = node\n                    for neighbor in graph[node]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            distance[neighbor] = distance[node] + 1\n                            queue.append(neighbor)\n\n                return last_node, distance[last_node]\n\n            if not edges:\n                return 0\n\n            graph = defaultdict(list)\n            for u, v in edges:\n                graph[u].append(v)\n                graph[v].append(u)\n\n            farthest_node, _ = bfs(0)\n            opposite_node, diameter = bfs(farthest_node)\n\n            return diameter\n\n        d1 = tree_diameter(edges1)\n        d2 = tree_diameter(edges2)\n\n        return max(d1, d2, (d1 + 1) // 2 + (d2 + 1) // 2 + 1)\n",
    "submit_ts": "1719717869",
    "subm_id": "1304402817"
}