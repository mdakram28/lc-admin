{
    "username": "yuanwang2011",
    "submission": "// power, independent\nint power_mod(int a, int b, int p) {\n    if (b == 0) return 1;\n    if (a == 0) return 0;\n    int res = 1;\n    a %= p;\n    while (b > 0) {\n        if (b & 1) res = (1ll * res * a) % p;\n        b >>= 1;\n        a = (1ll * a * a) % p;\n    }\n    return res;\n}\n\n// combination\nconst long long N = 1e6 + 5;\nint fact[N], inv[N]; // factorial and inverse\n\nvoid pre(int p, int n) { // call before using fact/inv/n_choose_r\n    fact[0] = 1;\n    inv[0] = 1;\n    for(int i = 1; i <= n; i++) fact[i] = (int) (1ll * i * fact[i-1] % p);\n    for(int i = 1; i <= n; i++) inv[i] = power_mod(fact[i], p - 2, p);\n}\n\nint n_choose_r(int n, int r, int p) {\n    if (r > n || r < 0) return 0;\n    if (n == r || r == 0) return 1;\n    return (int) (((1ll * fact[n] * inv[r] % p) * inv[n-r]) % p);\n}\n\nclass Solution {\npublic:\n    // 0, 1, 3, 7, 15, ...\n    // 1, 2, 4, 8, 16, ...\n    int calc(int k) {\n        int pow = 1, cur = 1, cnt = 0, ans;\n        while (cur < k) {\n            cur += pow;\n            ++cnt;\n            pow <<= 1;\n        }\n        // cout << \"cur pow cnt: \" << cur << \" \" << pow << \" \" << cnt << endl;\n        if (cur == k) ans = (pow > cnt + 1 ? 1 : 2);\n        else {\n            int diff = cur - k;\n            if (diff > cnt) ans = 0;\n            else {\n                // cnt choose diff\n                int mod = 1e9 + 7;\n                pre(mod, cnt);\n                ans = n_choose_r(cnt, diff, mod);\n                // cout << k << \" \" << ans << endl;\n            }\n        }\n        return ans;\n    }\n\n    int waysToReachStair(int k) {\n        if (k == 0) return 2;\n        // if (k == 1) return 4;\n        return calc(k + 1) + calc(k);\n    }\n};",
    "submit_ts": "1716088955",
    "subm_id": "1261828870"
}