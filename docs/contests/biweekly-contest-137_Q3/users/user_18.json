{
    "username": "Takuki Kurokawa",
    "submission": "#include <bits/extc++.h>\n\ntemplate <typename T, typename C>\nclass MCMF {\n   public:\n    static constexpr T eps = (T) 1e-9;\n\n    struct edge {\n        int from;\n        int to;\n        T c;\n        T f;\n        C cost;\n        edge(int from_, int to_, T c_, T f_, C cost_) : from(from_), to(to_), c(c_), f(f_), cost(cost_) {}\n    };\n\n    int n;\n    vector<vector<int>> g;\n    vector<edge> edges;\n    vector<C> d;\n    vector<C> pot;\n    __gnu_pbds::priority_queue<pair<C, int>> q;\n    vector<typename decltype(q)::point_iterator> its;\n    vector<int> pe;\n    const C INF_C = numeric_limits<C>::max() / 2;\n\n    explicit MCMF(int n_) : n(n_), g(n), d(n), pot(n, 0), its(n), pe(n) {}\n\n    int add(int from, int to, T forward_cap, T backward_cap, C edge_cost) {\n        assert(0 <= from && from < n && 0 <= to && to < n);\n        assert(forward_cap >= 0 && backward_cap >= 0);\n        int id = static_cast<int>(edges.size());\n        g[from].emplace_back(id);\n        edges.emplace_back(from, to, forward_cap, 0, edge_cost);\n        g[to].emplace_back(id + 1);\n        edges.emplace_back(to, from, backward_cap, 0, -edge_cost);\n        return id;\n    }\n\n    void expath(int st) {\n        fill(d.begin(), d.end(), INF_C);\n        q.clear();\n        fill(its.begin(), its.end(), q.end());\n        its[st] = q.push({pot[st], st});\n        d[st] = 0;\n        while (!q.empty()) {\n            int i = q.top().second;\n            q.pop();\n            its[i] = q.end();\n            for (int id : g[i]) {\n                const edge &e = edges[id];\n                int j = e.to;\n                if (e.c - e.f > eps && d[i] + e.cost < d[j]) {\n                    d[j] = d[i] + e.cost;\n                    pe[j] = id;\n                    if (its[j] == q.end()) {\n                        its[j] = q.push({pot[j] - d[j], j});\n                    } else {\n                        q.modify(its[j], {pot[j] - d[j], j});\n                    }\n                }\n            }\n        }\n        swap(d, pot);\n    }\n\n    pair<T, C> max_flow_min_cost(int st, int fin) {\n        T flow = 0;\n        C cost = 0;\n        bool ok = true;\n        for (auto &e : edges) {\n            if (e.c - e.f > eps && e.cost + pot[e.from] - pot[e.to] < 0) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            expath(st);\n        } else {\n            vector<int> deg(n, 0);\n            for (int i = 0; i < n; i++) {\n                for (int eid : g[i]) {\n                    auto &e = edges[eid];\n                    if (e.c - e.f > eps) {\n                        deg[e.to] += 1;\n                    }\n                }\n            }\n            vector<int> que;\n            for (int i = 0; i < n; i++) {\n                if (deg[i] == 0) {\n                    que.emplace_back(i);\n                }\n            }\n            for (int b = 0; b < (int) que.size(); b++) {\n                for (int eid : g[que[b]]) {\n                    auto &e = edges[eid];\n                    if (e.c - e.f > eps) {\n                        deg[e.to] -= 1;\n                        if (deg[e.to] == 0) {\n                            que.emplace_back(e.to);\n                        }\n                    }\n                }\n            }\n            fill(pot.begin(), pot.end(), INF_C);\n            pot[st] = 0;\n            if (static_cast<int>(que.size()) == n) {\n                for (int v : que) {\n                    if (pot[v] < INF_C) {\n                        for (int eid : g[v]) {\n                            auto &e = edges[eid];\n                            if (e.c - e.f > eps) {\n                                if (pot[v] + e.cost < pot[e.to]) {\n                                    pot[e.to] = pot[v] + e.cost;\n                                    pe[e.to] = eid;\n                                }\n                            }\n                        }\n                    }\n                }\n            } else {\n                que.assign(1, st);\n                vector<bool> in_queue(n, false);\n                in_queue[st] = true;\n                for (int b = 0; b < (int) que.size(); b++) {\n                    int i = que[b];\n                    in_queue[i] = false;\n                    for (int id : g[i]) {\n                        const edge &e = edges[id];\n                        if (e.c - e.f > eps && pot[i] + e.cost < pot[e.to]) {\n                            pot[e.to] = pot[i] + e.cost;\n                            pe[e.to] = id;\n                            if (!in_queue[e.to]) {\n                                que.emplace_back(e.to);\n                                in_queue[e.to] = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        while (pot[fin] < INF_C) {\n            T push = numeric_limits<T>::max();\n            int v = fin;\n            while (v != st) {\n                const edge &e = edges[pe[v]];\n                push = min(push, e.c - e.f);\n                v = e.from;\n            }\n            v = fin;\n            while (v != st) {\n                edge &e = edges[pe[v]];\n                e.f += push;\n                edge &back = edges[pe[v] ^ 1];\n                back.f -= push;\n                v = e.from;\n            }\n            flow += push;\n            cost += push * pot[fin];\n            expath(st);\n        }\n        return make_pair(flow, cost);\n    }\n};\n\nclass Solution {\n   public:\n    long long maximumValueSum(vector<vector<int>> &a) {\n        int h = (int) a.size();\n        int w = (int) a[0].size();\n        MCMF<int, long long> g(h + w + 3);\n        for (int i = 0; i < h; i++) {\n            g.add(h + w, i, 1, 0, 0);\n        }\n        for (int j = 0; j < w; j++) {\n            g.add(j + h, h + w + 1, 1, 0, 0);\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                g.add(i, j + h, 1, 0, -a[i][j]);\n            }\n        }\n        g.add(h + w + 1, h + w + 2, 3, 0, 0);\n        return -g.max_flow_min_cost(h + w, h + w + 2).second;\n    }\n};",
    "submit_ts": "1723905845",
    "subm_id": "1359022059"
}