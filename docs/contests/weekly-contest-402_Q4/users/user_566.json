{
    "username": "sam_990",
    "submission": "#define ll long long\n#define ull unsigned long long\n#define lll __int128\n#define ulll unsigned __int128\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconst int mod = 1e9 + 7;\n\n\ntemplate<typename T1, typename T2>ostream& operator<<(ostream& os, const pair<T1, T2>& p) { os << '{' << p.first << ',' << p.second << '}'; return os; }\ntemplate<typename T, size_t s>ostream& operator<<(ostream& os, const array<T, s>& v) { if (v.empty()) { os << \"{}\"; return os; } os << \"{\"; for (int i = 0; i < s - 1; i++) { os << v[i] << \",\"; } os << v[s - 1] << \"}\"; return os; }\ntemplate<typename T>ostream& operator<<(ostream& os, const vector<T>& v) { if (v.empty()) { os << \"{}\"; return os; } os << \"{\"; for (auto it = v.begin(); it != --v.end(); it++) { os << *(it) << \",\"; } os << *(--v.end()) << \"}\"; return os; }\ntemplate<typename T>ostream& operator<<(ostream& os, const set<T>& st) { if (st.empty()) { os << \"{}\"; return os; } os << \"{\"; for (auto it = st.begin(); it != --st.end(); it++) { os << *(it) << \",\"; } os << *(--st.end()) << \"}\"; return os; }\ntemplate<typename T>ostream& operator<<(ostream& os, const multiset<T>& st) { if (st.empty()) { os << \"{}\"; return os; } os << \"{\"; for (auto it = st.begin(); it != --st.end(); it++) { os << *(it) << \",\"; } os << *(--st.end()) << \"}\"; return os; }\ntemplate<typename T>ostream& operator<<(ostream& os, const unordered_set<T>& st) { os << '{'; if (st.size() == 1) { os << *st.begin(); } else if (st.size() > 1) { auto it = st.begin(); os << *it++; while (it != st.end()) { os << ',' << *it; it++; } } os << '}'; return os; }\ntemplate<typename T1, typename T2>ostream& operator<<(ostream& os, const map<T1, T2>& mp) { if (mp.empty()) { os << \"{}\"; return os; } os << \"{\"; for (auto it = mp.begin(); it != --mp.end(); it++) { os << '{' << it->first << ',' << it->second << '}' << ','; } os << '{' << (--mp.end())->first << ',' << (--mp.end())->second << \"}}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, const unordered_map<T1, T2>& mp) { os << '{'; if (mp.size() == 1) { os << *mp.begin(); } else if (mp.size() > 1) { auto it = mp.begin(); os << *it; it++; while (it != mp.end()) { os << ',' << *it; it++; } } os << '}'; return os; }\nostream& operator<<(ostream& os, __int128 n) { string s = \"\"; while (n) { s += (n % 10) + '0'; n /= 10; } reverse(s.begin(), s.end()); os << s; return os; }\n\n\ntemplate<typename T>\nclass SegmentTree {\n    private:\n    T query_range(int l, int r, int lm, int rm, int in) {\n        if (r < lm || l > rm) {\n            return neutral_el;\n        }\n        if (l <= lm && r >= rm) {\n            return tree[in];\n        }\n        return func(query_range(l, r, lm, (lm + rm) / 2, 2 * in + 1),\n            query_range(l, r, (lm + rm) / 2 + 1, rm, 2 * in + 2));\n    }\n    void update_point(int k, T u, int size) {\n        int in = size - 1 + k;\n        tree[in] = u;\n        in = (in - 1) / 2;\n        while (true) {\n            tree[in] = func(tree[2 * in + 1], tree[2 * in + 2]);\n            if (in == 0)break;\n            in = (in - 1) / 2;\n        }\n    }\n\n    public:\n    int size;\n    T neutral_el;\n    // vector<int> tree;\n    T* tree;\n\n    SegmentTree() {\n        size = 0;\n        neutral_el = 0;\n    }\n    SegmentTree(vector<T> v, T neutral) {\n        neutral_el = neutral;\n        int n = v.size();\n        size = (1 << (31 - __builtin_clz(n)));\n        if (size != n) size <<= 1;\n        // tree.resize(2 * size - 1, neutral_el);\n        tree = new T[2 * size - 1];\n        fill(tree, tree + 2 * size - 1, neutral_el);\n        for (int i = 0; i < n; i++) {\n            tree[size + i - 1] = v[i];\n        }\n        for (int i = size - 2; i >= 0; i--) {\n            tree[i] = func(tree[2 * i + 1], tree[2 * i + 2]);\n        }\n    }\n\n    T func(T a, T b) { return a + b; }\n    // l , r -> INDICES\n    T query_range(int l, int r) { return query_range(l, r, 0, size - 1, 0); }\n    void update_point(int in, T u) { update_point(in, u, size); }\n\n    friend ostream& operator<<(ostream& os, const SegmentTree& s) { os << '{'; for (int i = 0; i < 2 * s.size - 1; i++) { os << s.tree[i] << \",}\"[i == 2 * s.size - 2]; } return os; }\n};\n\nclass Solution {\n    public:\n    vector<int> countOfPeaks(vector<int> nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> v(n, 0);\n\n        auto set = [&](int in) {\n            if (in < 0 || in >= n) return;\n            if (in == 0 || in == n - 1) {\n                v[in] = 0;\n            }\n            else if (nums[in] > nums[in - 1] && nums[in] > nums[in + 1]) {\n                v[in] = 1;\n            }\n            else {\n                v[in] = 0;\n            }\n        };\n\n        for (int i = 1; i < n - 1; i++) {\n            set(i);\n        }\n\n        SegmentTree st(v, 0);\n        vector<int> ans;\n        \n        // cout << v << '\\n';\n        // cout << st << '\\n';\n\n        for (auto q : queries) {\n            if (q[0] == 1) {\n                ans.push_back(st.query_range(q[1], q[2]) - v[q[1]] - (q[2] != q[1] ? v[q[2]] : 0));\n            }\n            else {\n                int in = q[1];\n                nums[in] = q[2];\n                set(in);\n                set(in - 1);\n                set(in + 1);\n                st.update_point(in, v[in]);\n                if (in - 1 >= 0) st.update_point(in - 1, v[in - 1]);\n                if (in + 1 < n) st.update_point(in + 1, v[in + 1]);\n            }\n            \n            // cout << q[0] << '\\n';\n            // cout << v << '\\n';\n            // cout << st << '\\n';\n        }\n\n        return ans;\n\n    }\n};",
    "submit_ts": 1718507625.0
}