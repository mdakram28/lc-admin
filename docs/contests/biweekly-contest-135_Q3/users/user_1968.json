{
    "username": "DarakMakos",
    "submission": "class Solution {\npublic:\n    int minChanges(vector<int>& nums, int k) {\n       unordered_map<int, vector<int>> diffToXMap; // Maps each difference to possible X values\n        vector<int> xValues; // To hold all X values for efficient processing\n\n        int n = nums.size();\n        int halfSize = n / 2;\n\n        // Populate the difference map and xValues vector\n        for (int i = 0; i < halfSize; ++i) {\n            int start = nums[i];\n            int end = nums[n - 1 - i];\n            int difference = abs(start - end);\n\n            int maxX = max({start, end, k - start, k - end});\n            diffToXMap[difference].push_back(maxX);\n            xValues.push_back(maxX);\n        }\n\n        // Sort all X values to facilitate efficient comparison\n        sort(xValues.begin(), xValues.end());\n\n        int minimumChanges = n; // Start with the maximum possible changes\n\n        // Process each unique difference\n        for (const auto& [diff, xList] : diffToXMap) {\n            // Determine the number of X values less than the current difference\n            int lessThanDiffCount = lower_bound(xValues.begin(), xValues.end(), diff) - xValues.begin();\n            int changesNeeded = lessThanDiffCount * 2 + (halfSize - lessThanDiffCount);\n\n            // Adjust changes based on X values\n            for (const int xValue : xList) {\n                if (xValue < diff) {\n                    changesNeeded -= 2; // Adjust if X is less than the difference\n                } else {\n                    changesNeeded -= 1; // Adjust if X is greater than or equal to the difference\n                }\n            }\n\n            // Update the minimum number of changes required\n            minimumChanges = min(minimumChanges, changesNeeded);\n        }\n\n        return minimumChanges;\n    }\n};",
    "submit_ts": "1721490290",
    "subm_id": "1327478442"
}