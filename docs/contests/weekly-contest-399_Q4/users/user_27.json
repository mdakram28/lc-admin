{
    "username": "megaspazz",
    "submission": "class Solution {\n    private static final int MOD = 1_000_000_007;\n    private static final long INF = 9_999_999_999L;\n    \n    public int maximumSumSubsequence(int[] nums, int[][] queries) {\n        final int N = nums.length;\n        final int Q = queries.length;\n        \n        GenericSegmentTree<long[]> st = new GenericSegmentTree<>(\n            N,\n            new GenericSegmentTree.Combiner<>() {\n                @Override\n                public long[] combine(long[] a, long[] b) {\n                    if (a == null && b == null) {\n                        return null;\n                    }\n                    if (a == null) {\n                        return b;\n                    }\n                    if (b == null) {\n                        return a;\n                    }\n                    \n                    long[] result = new long[4];\n                    for (int i = 0; i < 4; ++i) {\n                        for (int j = 0; j < 4; ++j) {\n                            if ((i & 1) != 0 && (j & 2) != 0) {\n                                continue;\n                            }\n                            int ij = (i & 2) | (j & 1);\n                            result[ij] = Math.max(result[ij], a[i] + b[j]);\n                        }\n                    }\n                    return result;\n                }\n            }\n        );\n        \n        for (int i = 0; i < N; ++i) {\n            st.insert(i, makeLeaf(nums[i]));\n        }\n        \n        long ans = 0;\n        for (int q = 0; q < Q; ++q) {\n            final int pos = queries[q][0];\n            final int x = queries[q][1];\n            \n            st.insert(pos, makeLeaf(x));\n            \n            long[] arr = st.get(0, N - 1);\n            ans = add(ans, arrayMax(arr) % MOD);\n        }\n        return (int) ans;\n    }\n    \n    private static long[] makeLeaf(int x) {\n        long[] leaf = new long[4];\n        leaf[0b00] = 0;\n        leaf[0b01] = -INF;\n        leaf[0b10] = -INF;\n        leaf[0b11] = x;\n        return leaf;\n    }\n    \n    private static long arrayMax(long[] arr) {\n        long ans = arr[0];\n        for (int i = 1; i < arr.length; ++i) {\n            ans = Math.max(ans, arr[i]);\n        }\n        return ans;\n    }\n    \n    private static final long RAW_MULTIPLY_MAX = 3037000499L;\n\n    private static final int CHUNK_SIZE = Long.SIZE - Long.numberOfLeadingZeros(Long.MAX_VALUE / MOD) - 1;\n    private static final long CHUNK_MASK = (1L << CHUNK_SIZE) - 1;\n\n    @SuppressWarnings(\"unused\")\n    public static long multiply(long a, long b) {\n        if (MOD <= RAW_MULTIPLY_MAX) {\n            return a * b % MOD;\n        }\n        return multiplyInternal(a, b);\n    }\n\n    public static long multiply(long... arr) {\n        long ans = 1;\n        for (long x : arr) {\n            ans = multiply(ans, x);\n        }\n        return ans;\n    }\n\n    public static long add(long a, long b) {\n        long ans = a + b;\n        if (ans >= MOD) {\n            ans -= MOD;\n        }\n        return ans;\n    }\n\n    public static long add(long... arr) {\n        long ans = 0;\n        for (long x : arr) {\n            ans = add(ans, x);\n        }\n        return ans;\n    }\n\n    public static long subtract(long a, long b) {\n        return add(a, MOD - b);\n    }\n\n    private static long normalize(long x) {\n        if (x <= -MOD || x >= MOD) {\n            x %= MOD;\n        }\n        if (x < 0) {\n            x += MOD;\n        }\n        return x;\n    }\n\n    /**\n     * Computes the value of (b ^ e) % MOD.\n     */\n    public static long modPow(long b, long e) {\n        long p = b;\n        long ans = 1;\n        while (e > 0) {\n            if ((e & 1) == 1) {\n                ans = multiply(ans, p);\n            }\n            p = multiply(p, p);\n            e >>= 1;\n        }\n        return ans;\n    }\n\n    /**\n     * Computes the modular inverse, such that: ak % MOD = 1, for some k.\n     * See this page for details:  http://rosettacode.org/wiki/Modular_inverse\n     */\n    public static long modInverse(long a) {\n        long b = MOD;\n        long x0 = 0, x1 = 1;\n        long t, q;\n\n        while (a > 1) {\n            q = a / b;\n\n            t = b;\n            b = a % b;\n            a = t;\n\n            t = x0;\n            x0 = x1 - q * x0;\n            x1 = t;\n        }\n\n        if (x1 < 0) {\n            x1 += MOD;\n        }\n        return x1;\n    }\n\n    private static long multiplyInternal(long a, long b) {\n        if (a > b) {\n            return multiplyInternal(b, a);\n        }\n        if (a == 0) {\n            return 0;\n        }\n\n        long ans = 0;\n        while (a > 0) {\n            long mask = a & CHUNK_MASK;\n            if (mask > 0) {\n                ans = add(ans, (mask * b) % MOD);\n            }\n            b = (b << CHUNK_SIZE) % MOD;\n            a >>= CHUNK_SIZE;\n        }\n        return ans;\n    }\n\n\t/**\n\t * Here is a generic Segment Tree implementation.\n\t * It requires a Combiner to define how to merge values.\n\t * It takes an optional DefaultProvider to replace null values; otherwise, the Combiner will need to manually handle null values.\n\t *\n\t * NOTE: Slightly prefer ArraySegmentTree for performance!\n\t */\n\tpublic static class GenericSegmentTree<T> {\n\t\tpublic ArrayList<SegmentTreeNode> leaves;\n\t\tpublic SegmentTreeNode root;\n\t\tpublic Combiner<T> combiner;\n\t\tpublic DefaultProvider<T> defaultProvider;\n\n\t\tpublic GenericSegmentTree(int n, Combiner<T> cmb) {\n\t\t\tthis(n, cmb, null);\n\t\t}\n\n\t\tpublic GenericSegmentTree(int n, Combiner<T> cmb, DefaultProvider<T> defProv) {\n\t\t\tthis.combiner = cmb;\n\t\t\tthis.defaultProvider = defProv;\n\t\t\tthis.leaves = new ArrayList<SegmentTreeNode>(n);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tthis.leaves.add(null);\n\t\t\t}\n\t\t\tthis.root = new SegmentTreeNode(null, 0, n - 1);\n\t\t}\n\n\t\tpublic GenericSegmentTree(T[] vals, Combiner<T> cmb, DefaultProvider<T> defProv) {\n\t\t\tthis(vals.length, cmb, defProv);\n\t\t\tfor (int i = 0; i < vals.length; i++) {\n\t\t\t\tthis.insert(i, vals[i]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void insert(int idx, T v) {\n\t\t\tthis.leaves.get(idx).setAndUpdate(v);\n\t\t}\n\n\t\tpublic T get(int idx) {\n\t\t\treturn this.leaves.get(idx).val;\n\t\t}\n\n\t\tpublic T get(int lowerInclusive, int upperInclusive) {\n\t\t\treturn this.root.getRange(lowerInclusive, upperInclusive);\n\t\t}\n\n\t\tpublic static interface Combiner<T> {\n\t\t\tpublic T combine(T lhs, T rhs);\n\t\t}\n\n\t\tpublic static interface DefaultProvider<T> {\n\t\t\tpublic T getDefault();\n\t\t}\n\n\t\tprivate class SegmentTreeNode {\n\t\t\tpublic int L;\n\t\t\tpublic int R;\n\n\t\t\tpublic T val;\n\n\t\t\tpublic SegmentTreeNode parent;\n\t\t\tpublic SegmentTreeNode left;\n\t\t\tpublic SegmentTreeNode rite;\n\n\t\t\tpublic SegmentTreeNode(SegmentTreeNode p, int lower, int upper) {\n\t\t\t\tthis.parent = p;\n\t\t\t\tthis.L = lower;\n\t\t\t\tthis.R = upper;\n\n\t\t\t\tif (lower == upper) {\n\t\t\t\t\t// access outer class GenericSegmentTree\n\t\t\t\t\tleaves.set(lower, this);\n\t\t\t\t} else {\n\t\t\t\t\tint mid = (lower + upper) / 2;\n\t\t\t\t\tthis.left = new SegmentTreeNode(this, lower, mid);\n\t\t\t\t\tthis.rite = new SegmentTreeNode(this, mid + 1, upper);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void setAndUpdate(T v) {\n\t\t\t\tthis.val = v;\n\t\t\t\tthis.update();\n\t\t\t}\n\n\t\t\tpublic void update() {\n\t\t\t\tif (this.left != null && this.rite != null) {\n\t\t\t\t\t// access outer class GenericSegmentTree\n\t\t\t\t\tthis.val = combiner.combine(this.left.getValueOrDefault(), this.rite.getValueOrDefault());\n\t\t\t\t} else if (this.left != null) {\n\t\t\t\t\tthis.val = this.left.getValueOrDefault();\n\t\t\t\t} else if (this.rite != null) {\n\t\t\t\t\tthis.val = this.rite.getValueOrDefault();\n\t\t\t\t}\n\n\t\t\t\tif (this.parent != null) {\n\t\t\t\t\tthis.parent.update();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic T getRange(int lower, int upper) {\n\t\t\t\tif (this.L >= lower && this.R <= upper) {\n\t\t\t\t\treturn getValueOrDefault();\n\t\t\t\t} else if (this.L > upper || this.R < lower) {\n\t\t\t\t\t// access outer class GenericSegmentTree\n\t\t\t\t\treturn defaultProvider.getDefault();\n\t\t\t\t} else {\n\t\t\t\t\t// access outer class GenericSegmentTree\n\t\t\t\t\treturn combiner.combine(this.left.getRange(lower, upper), this.rite.getRange(lower, upper));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprivate T getValueOrDefault() {\n\t\t\t\tif (val != null) {\n\t\t\t\t\treturn val;\n\t\t\t\t}\n\t\t\t\tif (defaultProvider != null) {\n\t\t\t\t\treturn defaultProvider.getDefault();\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}",
    "submit_ts": "1716692280",
    "subm_id": "1268048818"
}