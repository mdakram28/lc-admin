{
    "username": "FreeYourMind",
    "submission": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\n\n\"\"\"\n<p>You are given a 2D <strong>binary</strong> array <code>grid</code>. You need to find 3 <strong>non-overlapping</strong> rectangles having <strong>non-zero</strong> areas with horizontal and vertical sides such that all the 1&#39;s in <code>grid</code> lie inside these rectangles.</p>\n\n<p>Return the <strong>minimum</strong> possible sum of the area of these rectangles.</p>\n\n<p><strong>Note</strong> that the rectangles are allowed to touch.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">grid = [[1,0,1],[1,1,1]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">5</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/05/14/example0rect21.png\" style=\"padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 280px; height: 198px;\" /></p>\n\n\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">grid = [[1,0,1,0],[0,1,0,1]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">5</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/05/14/example1rect2.png\" style=\"padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 356px; height: 198px;\" /></p>\n\n\n\n\"\"\"\nmax = lambda x, y: x if x > y else y\nmin = lambda x, y: x if x < y else y\n\n\ndef gao(grid: List[List[int]], r1: int, r2: int, c1: int, c2: int) -> int:\n    lx, rx = c2, c1\n    uy, dy = r2, r1\n    for i in range(r1, r2):\n        for j in range(c1, c2):\n            if grid[i][j] == 1:\n                lx = min(lx, j)\n                rx = max(rx, j)\n                uy = min(uy, i)\n                dy = max(dy, i)\n    return (rx - lx + 1) * (dy - uy + 1)\n\n\ndef umd(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    res = m * n\n    for r1 in range(1, m - 1):\n        for r2 in range(r1 + 1, m):\n            res = min(\n                res,\n                gao(grid, 0, r1, 0, n)\n                + gao(grid, r1, r2, 0, n)\n                + gao(grid, r2, m, 0, n),\n            )\n    return res\n\n\ndef ulr(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    res = m * n\n    for r in range(1, m):\n        us = gao(grid, 0, r, 0, n)\n        for c in range(1, n):\n            ls = gao(grid, r, m, 0, c)\n            rs = gao(grid, r, m, c, n)\n            res = min(res, us + ls + rs)\n    return res\n\n\ndef calc(grid: List[List[int]]) -> int:\n    # \u679a\u4e3e\u4e09\u4e2a\u77e9\u5f62\u7684\u5206\u5272\u60c5\u51b5\n    # \u4e0a\u4e2d\u4e0b\uff0c\u6216\u8005\u4e0a\u5de6\u53f3\uff0c\u518d\u4e0a\u4e0b\u98a0\u5012\u540e\u7684\u4e0a\u5de6\u53f3\n    res1 = umd(grid)\n    res2 = ulr(grid)\n    grid.reverse()\n    res3 = ulr(grid)\n    return min(res1, min(res2, res3))\n\n\nclass Solution:\n    def minimumSum(self, grid: List[List[int]]) -> int:\n\n        res1 = calc(grid)\n        # \u65cb\u8f6c\u77e9\u9635 90 \u5ea6\n        grid = list(zip(*grid[::-1]))\n        res2 = calc(grid)\n        return min(res1, res2)\n\n\ntestcases = [\n    # [[[1, 0, 1], [1, 1, 1]]],\n    # [],\n]\n\ns = Solution()\nfunc_name = dir(s)[-1]\nfunc = getattr(s, func_name)\n\nfor args in testcases:\n    print(func(*args))\n",
    "submit_ts": 1719111130.0
}