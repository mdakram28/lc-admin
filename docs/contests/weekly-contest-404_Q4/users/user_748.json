{
    "username": "chenyuanqin826",
    "submission": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int d1 = findDiameter(edges1);\n        int d2 = findDiameter(edges2);\n        return Math.max(d2, Math.max(d1, (int)(Math.ceil(d1 / 2.0) + 1 + Math.ceil(d2 / 2.0))));\n    }\n    int findDiameter(int[][] edges) {\n        if (edges == null || edges.length == 0) {\n            return 0;\n        }\n        Map<Integer, List<Integer>> adj = new HashMap<>();\n        for (int[] edge : edges) {\n            adj.compute(edge[0], (k, v) -> (v == null) ? new ArrayList<>() : v).add(edge[1]);\n            adj.compute(edge[1], (k, v) -> (v == null) ? new ArrayList<>() : v).add(edge[0]);\n        }\n        return dfs(adj, edges[0][0], edges[0][0])[0];\n    }\n    \n    int[] dfs(Map<Integer, List<Integer>> adj, int v, int parent) {\n        int length = 0;\n        int[] path = new int[]{-1, -1};\n        for (int u : adj.get(v)) {\n            if (u == parent) {\n                continue;\n            }\n            int[] ret = dfs(adj, u, v);\n            length = Math.max(length, ret[0]);\n            if (ret[1] > path[0]) {\n                path[1] = path[0];\n                path[0] = ret[1];\n            } else if (ret[1] > path[1]) {\n                path[1] = ret[1];\n            }\n        }\n        length = Math.max(length, path[0] + path[1] + 2);\n        return new int[]{length, Math.max(path[0], path[1]) + 1};\n    }\n}",
    "submit_ts": 1719719761.0
}