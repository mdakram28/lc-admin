{
    "username": "Kareem_Elgoker",
    "submission": "typedef long long ll;\nconst static auto _ = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\n// Don't forget long long due to overflow !!!!!!!!!\n\nstruct SuffixArray\n{\n    string s;\n    int n;\n    vector<int> p, c;\n    SuffixArray(){};\n    SuffixArray(string & in)\n    {\n        s = in;\n        s += ' ';\n        n = s.length();\n        p.resize(n);\n        c.resize(n);\n\n        PhaseZero();\n        RemainingPhases();\n    }\n\n    void PhaseZero()\n    {\n        vector<pair<char, int>> ch_pos(n);\n        for (int i = 0; i < n; ++i) {\n            ch_pos[i] = {s[i], i};\n        }\n\n        sort(ch_pos.begin(), ch_pos.end());\n\n        for (int i = 0; i < n; ++i) {\n            p[i] = ch_pos[i].second;\n        }\n\n        c[p[0]] = 0;\n\n        for (int i = 1; i < n; ++i) {\n            if(ch_pos[i].first == ch_pos[i - 1].first)\n                c[p[i]] = c[p[i - 1]];\n            else\n                c[p[i]] = c[p[i - 1]] + 1;\n        }\n    }\n\n    void CountSort()\n    {\n        vector<int> freq(n);\n        for (int i = 0; i < n; ++i) {\n            ++freq[c[i]];\n        }\n\n        vector<int> p_new(n);\n\n        vector<int> pos(n);\n        pos[0] = 0;\n        for (int i = 1; i < n; ++i) {\n            pos[i] = pos[i - 1] + freq[i - 1];\n        }\n\n        for (int i = 0; i < n; ++i) {\n            p_new[pos[c[p[i]]]] = p[i];\n            ++pos[c[p[i]]];\n        }\n\n        p = p_new;\n    }\n\n    void RemainingPhases()\n    {\n        int k = 0;\n        while ((1ll<<k) < n)\n        {\n            // this makes the pair is sorted by the second half\n            for (int i = 0; i < n; ++i) {\n                p[i] = p[i] - (1ll<<k);\n                if(p[i] < 0) p[i] += n;\n            }\n\n            // sort the first half of the pair\n            CountSort();\n\n            vector<int> c_new(n);\n            c_new[p[0]] = 0;\n\n            for (int i = 1; i < n; ++i) {\n\n                int sec_prev = p[i - 1] + (1ll<<k);\n                if(sec_prev >= n) sec_prev -= n;\n\n                int sec_now = p[i] + (1ll<<k);\n                if(sec_now >= n) sec_now -= n;\n\n                pair<int, int> prev = {c[p[i - 1]], c[sec_prev]};\n                pair<int, int> now = {c[p[i]], c[sec_now]};\n\n                if(now == prev)\n                    c_new[p[i]] = c_new[p[i - 1]];\n                else\n                    c_new[p[i]] = c_new[p[i - 1]] + 1;\n            }\n\n            c = c_new;\n\n            // if all the strings has different values then stop\n            if(c[p.back()] == n - 1)\n                break;\n\n            ++k;\n        }\n    }\n};\nSuffixArray SA;\nvector<vector<pair<int, int>>> adj;\nvoid Get_All_Occ(string const & patt, string const & s, int&w)\n{\n    if(patt.length() > s.length())\n    {\n        return;\n    }\n    int low = 0, high = s.length(), mid, ans_low = -1;\n    while (low <= high)\n    {\n        mid = low + (high - low) / 2;\n        int l = patt.length();\n        l = min(l, (int)s.length() - SA.p[mid]);\n        if(s.substr(SA.p[mid], l) >= patt)\n        {\n            high = mid - 1;\n            ans_low = mid;\n        }\n        else low = mid + 1;\n    }\n    if(ans_low == -1)\n        return;\n    int l = patt.length();\n    l = min(l, (int)s.length() - SA.p[ans_low]);\n    if(ans_low == -1 || s.substr(SA.p[ans_low], l) != patt)\n    {\n        return;\n    }\n    low = 0, high = s.length();\n    int ans_high = -1;\n    while (low <= high)\n    {\n        mid = low + (high - low) / 2;\n        int l = patt.length();\n        l = min(l, (int)s.length() - SA.p[mid]);\n        if(s.substr(SA.p[mid], l) <= patt)\n        {\n            low = mid + 1;\n            ans_high = mid;\n        }\n        else high = mid - 1;\n    }\n    vector<int> ans;\n    for (int i = ans_low; i <= ans_high; ++i) {\n        adj[SA.p[i]].push_back({SA.p[i] + patt.length(), w});\n    }\n}\nvector<int> dp;\nint func(int l)\n{\n    if(l == adj.size())\n        return 0;\n    int &ret = dp[l];\n    if(~ret)\n        return ret;\n    int ans = 1e9;\n    for(auto &[v, w] : adj[l])\n    {\n        ans = min(ans, func(v) + w);\n    }\n    return ret = ans;\n}\n\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        string s = target;\n        dp.assign(s.length(), -1);\n        adj.assign(s.length(), {});\n        SA = SuffixArray(s);\n        unordered_map<string, int> cost;\n        for (int i = 0; i < words.size(); ++i) {\n            if(cost.count(words[i]))\n                cost[words[i]] = min(costs[i], cost[words[i]]);\n            else\n                cost[words[i]] = costs[i];\n        }\n        for(auto &[patt, w] : cost)\n        {\n            Get_All_Occ(patt, s, w);\n        }\n        return (func(0) >= 1e9?-1: (int)func(0));\n    }\n};\n",
    "submit_ts": "1720323494",
    "subm_id": "1312376963"
}