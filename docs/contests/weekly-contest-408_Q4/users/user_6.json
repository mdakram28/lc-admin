{
    "username": "wjli",
    "submission": "\n\n// COPY ALL MACROS BELOW\n\ntypedef long long LL;\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define LB lower_bound\n#define UB upper_bound\n#define SZ(x) ((int)x.size())\n#define LEN(x) ((int)x.length())\n#define ALL(x) begin(x), end(x)\n#define RSZ resize\n#define ASS assign\n#define REV(x) reverse(x.begin(), x.end());\n#define trav(a, x) for (auto& a : x)\ntypedef pair<LL, LL> PL;\ntypedef vector<LL> VL;\ntypedef vector<PL> VPL;\ntypedef vector<VL> VVL;\ntypedef vector<VVL> VVVL;\ntypedef vector<VVVL> VVVVL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PI;\ntypedef vector<int> VI;\ntypedef vector<PI> VPI;\ntypedef vector<vector<int>> VVI;\ntypedef vector<vector<PI>> VVPI;\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\n#define FOR(i, n) for (int i = 0; i < n; i++) \n#define FOR1(i, n) for (int i = 1; i <= n; i++) \n#define SORT(x) sort(x.begin(), x.end())\n#define RSORT(x) sort(x.rbegin(), x.rend())\n#define SUM(x) accumulate(x.begin(), x.end(), 0LL)\n\n\n// Union-Find Disjoint Sets Library written in OOP manner, using both path compression and union by rank heuristics\n// initialize: UnionFind UF(N)\n\nclass UnionFind {                                              // OOP style\nprivate:\n\tvector<int> p, rank, setSize;\n\t// p = path toward the root of disjoint set; p[i] = i means it is root\n\t// rank = upper bound of the actual height of the tree; not reliable as accurate measure\n\t// setSize = size of each disjoint set\n\n\tint numSets;\npublic:\n\tUnionFind(int N) {\n\t\tsetSize.assign(N, 1);\n\t\tnumSets = N;\n\t\trank.assign(N, 0);\n\t\tp.assign(N, 0);\n\t\tfor (int i = 0; i < N; i++) p[i] = i;\t// each belongs to its own set\n\t}\n\n\tint findSet(int i) {\n\t\treturn (p[i] == i) ? i : (p[i] = findSet(p[i]));\t\t// path compression: cut short of the path if possible\n\t}\n\n\tbool isSameSet(int i, int j) {\n\t\treturn findSet(i) == findSet(j);\n\t}\n\n\tvoid unionSet(int i, int j) {\n\t\tif (!isSameSet(i, j)) {\n\t\t\tnumSets--;\n\t\t\tint x = findSet(i), y = findSet(j);\n\t\t\t// rank is used to keep the tree short\n\t\t\tif (rank[x] > rank[y]) { p[y] = x; setSize[x] += setSize[y]; }\n\t\t\telse {\n\t\t\t\tp[x] = y; setSize[y] += setSize[x];\n\t\t\t\tif (rank[x] == rank[y]) rank[y]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint numDisjointSets() {\t\t// # of disjoint sets\n\t\treturn numSets;\n\t}\n\n\tint sizeOfSet(int i) {\t\t// size of set\n\t\treturn setSize[findSet(i)];\n\t}\n};\n\nclass Solution {\npublic:\n\tbool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n\t\tLL n = circles.size(), i, j, k;\n\t\tVL x(n), y(n), r(n);\n\t\tLL xx, yy, d, dd;\n\t\tbool valid = true;\n\n\t\tUnionFind uf(n + 4);\n\t\tFOR(i, n) {\n\t\t\tx[i] = circles[i][0];\n\t\t\ty[i] = circles[i][1];\n\t\t\tr[i] = circles[i][2];\n\n\t\t\td = (LL)(X - x[i]) * (X - x[i]) + (LL)(Y - y[i]) * (Y - y[i]);\n\t\t\tif (d <= r[i] * r[i]) return false;\t// inside circle\n\n\t\t\td = (LL)(0 - x[i]) * (0 - x[i]) + (LL)(0 - y[i]) * (0 - y[i]);\n\t\t\tif (d <= r[i] * r[i]) return false;\t// inside circle\n\t\t}\n\n\t\tFOR(i, n) {\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\td = (LL)(x[j] - x[i]) * (x[j] - x[i]) + (LL)(y[j] - y[i]) * (y[j] - y[i]);\n\t\t\t\tif (d <= (r[i] + r[j]) * (r[i] + r[j])) {\n\t\t\t\t\tuf.unionSet(i, j);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// top\n\t\t\tyy = Y;\n\t\t\tif (x[i] < 0) xx = 0;\n\t\t\telse if (x[i] > X) xx = X;\n\t\t\telse xx = x[i];\n\n\t\t\td = (LL)(xx - x[i]) * (xx - x[i]) + (LL)(yy - y[i]) * (yy - y[i]);\n\t\t\tif (d <= r[i] * r[i]) \n\t\t\t\tuf.unionSet(i, n + 0);\n\n\t\t\t// bottom\n\t\t\tyy = 0;\n\t\t\tif (x[i] < 0) xx = 0;\n\t\t\telse if (x[i] > X) xx = X;\n\t\t\telse xx = x[i];\n\n\t\t\td = (LL)(xx - x[i]) * (xx - x[i]) + (LL)(yy - y[i]) * (yy - y[i]);\n\t\t\tif (d <= r[i] * r[i]) \n\t\t\t\tuf.unionSet(i, n + 2);\n\n\t\t\t// left\n\t\t\txx = 0;\n\t\t\tif (y[i] < 0) yy = 0;\n\t\t\telse if (y[i] > Y) yy = Y;\n\t\t\telse yy = y[i];\n\n\t\t\td = (LL)(xx - x[i]) * (xx - x[i]) + (LL)(yy - y[i]) * (yy - y[i]);\n\t\t\tif (d <= r[i] * r[i]) \n\t\t\t\tuf.unionSet(i, n + 3);\n\n\t\t\t// right\n\t\t\txx = X;\n\t\t\tif (y[i] < 0) yy = 0;\n\t\t\telse if (y[i] > Y) yy = Y;\n\t\t\telse yy = y[i];\n\n\t\t\td = (LL)(xx - x[i]) * (xx - x[i]) + (LL)(yy - y[i]) * (yy - y[i]);\n\t\t\tif (d <= r[i] * r[i]) \n\t\t\t\tuf.unionSet(i, n + 1);\n\t\t}\n\n\t\tvalid = true;\n\t\tif (uf.isSameSet(n + 0, n + 2)) valid = false;\n\t\tif (uf.isSameSet(n + 3, n + 1)) valid = false;\n\t\tif (uf.isSameSet(n + 0, n + 1)) valid = false;\n\t\tif (uf.isSameSet(n + 3, n + 2)) valid = false;\n\n\n\n\t\treturn valid;\n\t}\n};\n",
    "submit_ts": "1722135587",
    "subm_id": "1335706861"
}