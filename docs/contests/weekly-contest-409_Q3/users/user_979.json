{
    "username": "mananghetia",
    "submission": "class Solution {\npublic:\n    /*Multi purpose Segment Tree Template*/\n/*range are half-open i.e [l,r)*/\n/*By default it will perform range increment update and calculate range sum*/\nstruct segNode\n{\n    long long val;\n    int l, r;\n    segNode() // default value of Segment tree main node\n    {\n        val = 0;\n        l = -1, r = -1;\n    }\n};\nstruct lazyNode\n{\n    long long val;\n    lazyNode() // default value of Segment tree lazy node\n    {\n        val = 0;\n    }\n};\nstruct segTree\n{\n    int N;\n    vector<segNode> seg;\n    vector<lazyNode> lazy;\n    segTree(int n) // Default Segment Tree\n    {\n        N = n;\n        seg.resize(4 * N + 5);\n        lazy.resize(4 * N + 5);\n        vector<int> a(N, seg[0].val); // check this\n        build(a, 0, N, 0);\n    }\n    segTree(vector<int> &a) // Pre-Computed Segment Tree\n    {\n        N = a.size();\n        seg.resize(4 * N + 5);\n        lazy.resize(4 * N + 5);\n        build(a, 0, N, 0);\n    }\n    void merge(segNode &cur, segNode &left, segNode &right) // change this function\n    {\n        assert(cur.l == left.l && cur.r == right.r);\n\n        cur.val = left.val + right.val;\n    }\n    void propogate(int id) // change this function\n    {\n        int l = seg[id].l, r = seg[id].r;\n        seg[id].val += lazy[id].val;\n        if (l + 1 != r)\n        {\n            int mid = (l + r) >> 1LL, left = 2 * id + 1, right = 2 * id + 2;\n            lazy[left].val += lazy[id].val;\n            lazy[right].val += lazy[id].val;\n        }\n        lazy[id].val = 0;\n    }\n    void build(vector<int> &a, int l, int r, int id)\n    {\n        seg[id].l = l;\n        seg[id].r = r;\n        if (l + 1 == r) // check this block\n        {\n            seg[id].val = a[l];\n            return;\n        }\n        int mid = (l + r) >> 1LL, left = 2 * id + 1, right = 2 * id + 2;\n        build(a, l, mid, left);\n        build(a, mid, r, right);\n        merge(seg[id], seg[left], seg[right]);\n    }\n    void update(int ql, int qr, int val, int id = 0)\n    {\n        propogate(id);\n        int l = seg[id].l;\n        int r = seg[id].r;\n        if (ql >= r || l >= qr)\n            return;\n        if (ql <= l && r <= qr) // check this block\n        {\n            lazy[id].val = val;\n            propogate(id);\n            return;\n        }\n        int mid = (l + r) >> 1LL, left = 2 * id + 1, right = 2 * id + 2;\n        update(ql, qr, val, left);\n        update(ql, qr, val, right);\n        merge(seg[id], seg[left], seg[right]);\n    }\n    segNode query(int ql, int qr, int id = 0)\n    {\n        propogate(id);\n        segNode ans;\n        int l = seg[id].l;\n        int r = seg[id].r;\n        if (ql >= r)\n        {\n            ans.l = ans.r = ql;\n            return ans;\n        }\n        if (l >= qr)\n        {\n            ans.l = ans.r = qr;\n            return ans;\n        }\n        if (ql <= l && r <= qr)\n            return seg[id];\n        int mid = (l + r) >> 1LL, left = 2 * id + 1, right = 2 * id + 2;\n        segNode ansl = query(ql, qr, left);\n        segNode ansr = query(ql, qr, right);\n        ans.l = ansl.l;\n        ans.r = ansr.r;\n        merge(ans, ansl, ansr);\n        return ans;\n    }\n};\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int> a(n);\n        for(int i=0;i<n;i++)\n            a[i]=i;\n        segTree s(a);\n        vector<int> ans;\n        set<pair<int,int>> st;\n        for(auto i:queries)\n        {\n            int u=i[0],v=i[1];\n            if(!st.empty()){\n                auto it=st.lower_bound({u,u});\n                if(it==st.end())\n                    it--;\n                    if(it->first<=u&&it->second>=v)\n                    {\n                        // cout<<\"here->\"<<u<<\" \"<<v<<endl;\n                        ans.push_back(ans.back());\n                        continue;\n                    }\n                if(it!=st.begin())\n                    it--;\n                    if(it->first<=u&&it->second>=v)\n                    {\n                        // cout<<\"here->\"<<u<<\" \"<<v<<endl;\n                        ans.push_back(ans.back());\n                        continue;\n                    }\n            }\n            auto it=st.lower_bound({u,u});\n            while(it!=st.end())\n            {\n                if(it->second<=v)\n                {\n                    auto jt=it;\n                    it++;\n                    st.erase(jt);\n                }\n                else \n                    break;\n            }\n            st.insert({u,v});\n            int su=s.query(u,u+1).val,sv=s.query(v,v+1).val;\n            int dif=max(sv-su-1,0);\n            s.update(v,n,-dif);\n            ans.push_back(s.query(n-1,n).val);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722742813",
    "subm_id": "1343777757"
}