{
    "username": "Darren Hp",
    "submission": "// \u6ce8\u610f\u7ebf\u6bb5\u6811\u662f\"\u5de6\u95ed\u53f3\u5f00\"\u533a\u95f4\nstruct Tag {\n  int64_t a = 0;\n  void apply(Tag t) {\n    a += t.a;\n  }\n};\n \nstruct Info {\n  int64_t cnt = 0;\n  int64_t sum = 0;\n  void apply(Tag t) {\n    sum += t.a * cnt;\n  }\n};\nInfo operator+(Info a, Info b) { //\u6ce8\u610f\uff1a\u9700\u8981\u6ee1\u8db3Info \u9ed8\u8ba4\u503c\u662f\"\u5355\u4f4d\u5143\"\n  return Info{a.cnt + b.cnt, a.sum + b.sum};\n}\n \ntemplate<class Info, class Tag>\nstruct LazySegmentTree {\n  int n;\n  std::vector<Info> info;\n  std::vector<Tag> tag;\n  LazySegmentTree() : n(0) {}\n  LazySegmentTree(int n_, Info v_ = Info()) {\n    init(n_, v_);\n  }\n  template<class T>\n  LazySegmentTree(std::vector<T> init_) {\n    init(init_);\n  }\n  void init(int n_, Info v_ = Info()) {\n    init(std::vector(n_, v_));\n  }\n  template<class T>\n  void init(std::vector<T> init_) {\n    n = init_.size();\n    info.assign(4 << std::__lg(n), Info());\n    tag.assign(4 << std::__lg(n), Tag());\n    std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n      if (r - l == 1) {\n        info[p] = init_[l];\n        return;\n      }\n      int m = (l + r) / 2;\n      build(2 * p, l, m);\n      build(2 * p + 1, m, r);\n      pull(p);\n    };\n    build(1, 0, n);\n  }\n  void pull(int p) {\n    info[p] = info[2 * p] + info[2 * p + 1];\n  }\n  void apply(int p, const Tag& v) {\n    info[p].apply(v);\n    tag[p].apply(v);\n  }\n  void push(int p) {\n    apply(2 * p, tag[p]);\n    apply(2 * p + 1, tag[p]);\n    tag[p] = Tag();\n  }\n  void modify(int p, int l, int r, int x, const Info& v) {\n    if (r - l == 1) {\n      info[p] = v;\n      return;\n    }\n    int m = (l + r) / 2;\n    push(p);\n    if (x < m) {\n      modify(2 * p, l, m, x, v);\n    } else {\n      modify(2 * p + 1, m, r, x, v);\n    }\n    pull(p);\n  }\n  void modify(int p, const Info& v) {\n    modify(1, 0, n, p, v);\n  }\n  Info rangeQuery(int p, int l, int r, int x, int y) {\n    if (l >= y || r <= x)  return Info();\n    if (l >= x && r <= y)  return info[p];\n    int m = (l + r) / 2;\n    push(p);\n    pull(p);\n    return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);\n  }\n  Info rangeQuery(int l, int r) {\n    return rangeQuery(1, 0, n, l, r);\n  }\n  void rangeApply(int p, int l, int r, int x, int y, const Tag& v) {\n    if (l >= y || r <= x)  return;\n    if (l >= x && r <= y) {\n      apply(p, v);\n      return;\n    }\n    int m = (l + r) / 2;\n    push(p);\n    rangeApply(2 * p, l, m, x, y, v);\n    rangeApply(2 * p + 1, m, r, x, y, v);\n    pull(p);\n  }\n  void rangeApply(int l, int r, const Tag& v) {\n    return rangeApply(1, 0, n, l, r, v);\n  }\n  template<class F>\n  int findFirst(int p, int l, int r, int x, int y, F pred) {\n    if (l >= y || r <= x || !pred(info[p]))  return -1;\n    if (r - l == 1)  return l;\n    int m = (l + r) / 2;\n    push(p);\n    int res = findFirst(2 * p, l, m, x, y, pred);\n    if (res == -1)  res = findFirst(2 * p + 1, m, r, x, y, pred);\n    return res;\n  }\n  template<class F>\n  int findFirst(int l, int r, F pred) {\n    return findFirst(1, 0, n, l, r, pred);\n  }\n  template<class F>\n  int findLast(int p, int l, int r, int x, int y, F pred) {\n    if (l >= y || r <= x || !pred(info[p]))  return -1;\n    if (r - l == 1)  return l;\n    int m = (l + r) / 2;\n    push(p);\n    int res = findLast(2 * p + 1, m, r, x, y, pred);\n    if (res == -1)  res = findLast(2 * p, l, m, x, y, pred);\n    return res;\n  }\n  template<class F>\n  int findLast(int l, int r, F pred) {\n    return findLast(1, 0, n, l, r, pred);\n  }\n};\n\nclass Solution {\npublic:\n  vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n    int n = s.size();\n    vector<int> C(2);\n    vector<Info> infos(n); for (auto &i: infos) i.cnt = 1;\n    LazySegmentTree<Info, Tag> tr(infos);\n    vector<array<int64_t, 4>> Q;\n    for (int i = 0; i < queries.size(); i++) Q.push_back({queries[i][1], queries[i][0], i, 0});\n    int L = 0;\n    sort(Q.begin(), Q.end());\n    for (int i = 0, j = 0; i < n; i++) {\n      C[s[i]-'0']++;\n      while (C[0]>k&&C[1]>k) C[s[j++]-'0']--;\n      //cout << \"apply:\" << j << \" \" << i + 1 << endl;\n      tr.rangeApply(j, i+1, Tag{1});\n      while (L < Q.size() && get<0>(Q[L]) < i) L++;\n      while (L < Q.size() && get<0>(Q[L]) == i) {\n        auto &[r, l, i, ans] = Q[L++];\n        ans = tr.rangeQuery(l, r+1).sum;\n       // cout << \"query: \" << r << \" \" << l << \" \" << i << \":\" << tr.rangeQuery(l, r+1).cnt << \" \" << tr.rangeQuery(l, r+1).sum << endl;\n      }\n    }\n    sort(Q.begin(), Q.end(), [](auto &l, auto &r) {\n      return get<2>(l)<get<2>(r);\n    });\n    vector<long long> res; for (auto &[r, l, i, ans]: Q) res.push_back(ans);\n    return res;\n  }\n};",
    "submit_ts": "1723950658",
    "subm_id": "556400488"
}