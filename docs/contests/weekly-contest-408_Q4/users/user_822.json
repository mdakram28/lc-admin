{
    "username": "coder_162003",
    "submission": "// class Solution {\n// public:\n    // bool isValid(int x, int y, int X, int Y, const vector<vector<bool>>& grid) {\n    //     return x >= 0 && x <= X && y >= 0 && y <= Y && grid[x][y];\n    // }\n//bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n    //     vector<vector<bool>> grid(X + 1, vector<bool>(Y + 1, true));\n    //     for (auto it : circles) {\n    //         int xi = it[0];\n    //         int yi = it[1];\n    //         int ri = it[2];\n    //         for (int i = max(0, xi - ri); i <= min(X, xi + ri); ++i) {\n    //             for (int j = max(0, yi - ri); j <= min(Y, yi + ri); ++j) {\n    //                 if ((i - xi) * (i - xi) + (j - yi) * (j - yi) <= ri * ri) {\n    //                     grid[i][j] = false;\n    //                 }\n    //             }\n    //         }\n    //     }\n\n    //     queue<pair<int, int>> q;\n    //     q.push({0, 0});\n    //     vector<vector<bool>> vis(X + 1, vector<bool>(Y + 1, false));\n    //     vis[0][0] = true;\n    //     vector<pair<int, int>> directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n    //     while (!q.empty()) {\n    //         auto [x, y] = q.front();\n    //         q.pop();\n    //         if (x == X && y == Y) {\n    //             return true;\n    //         }\n\n    //         for (auto& [dx, dy] : directions) {\n    //             int nx = x + dx;\n    //             int ny = y + dy;\n    //             if (isValid(nx, ny, X, Y, grid) && !vis[nx][ny]) {\n    //                 q.push({nx, ny});\n    //                 vis[nx][ny] = true;\n    //             }\n    //         }\n    //     }\n\n    //     return false;\n    // }\n//      unordered_set<string> uniqueCircles;\n//         for (auto& circle : circles) {\n//             uniqueCircles.insert(to_string(circle[0]) + \",\" + to_string(circle[1]) + \",\" + to_string(circle[2]));\n//         }\n\n//         vector<vector<int>> uniqueCirclesArray;\n//         for (auto& circleStr : uniqueCircles) {\n//             stringstream ss(circleStr);\n//             string item;\n//             vector<int> circle;\n//             while (getline(ss, item, ',')) {\n//                 circle.push_back(stoi(item));\n//             }\n//             uniqueCirclesArray.push_back(circle);\n//         }\n\n//         vector<vector<bool>> visited(X + 1, vector<bool>(Y + 1, false));\n//         queue<pair<int, int>> q;\n//         q.push({0, 0});\n//         visited[0][0] = true;\n\n//         vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n//         while (!q.empty()) {\n//             auto [x, y] = q.front();\n//             q.pop();\n\n//             if (x == X && y == Y) {\n//                 return true;\n//             }\n\n//             for (auto& dir : directions) {\n//                 int nx = x + dir.first, ny = y + dir.second;\n//                 if (nx >= 0 && nx <= X && ny >= 0 && ny <= Y && !visited[nx][ny] && isValid(nx, ny, uniqueCirclesArray)) {\n//                     q.push({nx, ny});\n//                     visited[nx][ny] = true;\n//                 }\n//             }\n//         }\n\n//         return false;\n//     }\n\n// private:\n//     bool isValid(int x, int y, vector<vector<int>>& circles) {\n//         for (auto& circle : circles) {\n//             int xi = circle[0], yi = circle[1], ri = circle[2];\n//             if ((x - xi) * (x - xi) + (y - yi) * (y - yi) <= ri * ri) {\n//                 return false;\n//             }\n//         }\n//         return true;\nclass Solution {\npublic:\n    \n   bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        return solve(X, Y, circles);\n    }\n    \nprivate:\n    bool solve(int X, int Y, vector<vector<int>>& circles) {\n        int m = circles.size();\n        vector<vector<int>> grid(m + 4);\n        \n        for (int i = 0; i < m; i++) {\n            if (circles[i][0] <= circles[i][2]) {\n                grid[m].push_back(i);\n                grid[i].push_back(m);\n            }\n            if (X - circles[i][0] <= circles[i][2]) {\n                grid[m + 2].push_back(i);\n                grid[i].push_back(m + 2);\n            }\n            if (circles[i][1] <= circles[i][2]) {\n                grid[m + 1].push_back(i);\n                grid[i].push_back(m + 1);\n            }\n            if (Y - circles[i][1] <= circles[i][2]) {\n                grid[m + 3].push_back(i);\n                grid[i].push_back(m + 3);\n            }\n            for (int j = i + 1; j < m; ++j) {\n                double dist = sqrt(pow(circles[i][0] - circles[j][0], 2) + pow(circles[i][1] - circles[j][1], 2));\n                int radSum = circles[i][2] + circles[j][2];\n                if (radSum >= dist) {\n                    grid[i].push_back(j);\n                    grid[j].push_back(i);\n                }\n            }\n        }\n        \n        int isBloc = 0;\n        isBloc = max(isBloc, bfs(grid, m, m + 1, m + 2, m + 4));\n        isBloc = max(isBloc, bfs(grid, m + 3, m + 2, m + 1, m + 4)); \n        \n        return isBloc == 0;\n    }\n    \n    int bfs(vector<vector<int>>& g, int s, int t1, int t2, int n) {\n        queue<int> q;\n        vector<bool> vis(n + 4, false);\n        q.push(s);\n        vis[s] = true;\n        \n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            \n            for (int v : g[u]) {\n                if (!vis[v]) {\n                    q.push(v);\n                    vis[v] = true;\n                }\n            }\n        }\n        \n        return (vis[t1] || vis[t2] ? 1 : 0);\n    }\n};\n",
    "submit_ts": "1722138731",
    "subm_id": "1335798225"
}