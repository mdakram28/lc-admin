{
    "username": "browndwarf",
    "submission": "class Solution:\n    def largestPalindrome(self, n: int, k: int) -> str:\n        def f(n,k):\n            def strmax(strA, strB):\n                if len(strA) > len(strB):\n                    return strA\n                if len(strB) > len(strA):\n                    return strB\n                L = len(strA)\n                for i in range(L):\n                    if strA[i] > strB[i]:\n                        return strA\n                    elif strB[i] > strA[i]:\n                        return strB\n                return strA\n            # precompute ten power mod k\n            #tpm = np.zeros(n, dtype=int)\n            tpm = [0] * n\n            # tpm[i] = (10^i) mod k\n            res = 1\n            for i in range(n):\n                tpm[i] = res % k\n                res = (res * 10) % k\n            # dp\n            dp = [['' for i in range(k)] for j in range(n)]\n            old = ['' for i in range(k)]\n            new = ['' for i in range(k)]\n            # dp[l, k] = max_{i\\in [k]} (dp[l-1, i])*10 + (10^(2l-1+bias) + 1)*(j)\n            bias = n % 2\n            if bias==1:\n                for i in range(10):\n                    old[i%k] = strmax(old[i%k], str(i))\n            else:\n                for i in range(10):\n                    old[i%k] = ''\n            for l in range(1, n//2+1):\n                minLin = 0\n                if l == n//2:\n                    minLin = 1\n\n                for j in (range(minLin, 10)):\n                    for i in range(k):\n                        if (bias==0) and (l==1):\n                            newmod = (j * (1 + tpm[2*l-1+bias])) % k\n                        else:\n                            newmod = ((i * 10) + j * (1 + tpm[2*l-1+bias])) % k\n                        newstr = str(j) + old[i] + str(j)\n                        #new[newmod] = newstr\n                        new[newmod] = strmax(new[newmod], newstr)\n                #print(old)\n                old = new.copy()\n            #print(old)\n            #print(len(dp[n//2][0]))\n            return (old[0]), old\n        if k==1 or k==3 or k==9:\n            return \"9\"*n\n        if k==5:\n            if n==1:\n                return \"5\"\n            elif n==2:\n                return \"55\"\n            return \"5\" + \"9\" * (n-2) + \"5\"\n        if k==2:\n            if n==1:\n                return \"8\"\n            return \"8\" + \"9\"*(n-2) + \"8\"\n        if k==4:\n            if n==1:\n                return \"8\"\n            if n==2:\n                return \"88\"\n            if n==3:\n                return \"888\"\n            return \"88\" + \"9\"*(n-4) + \"88\"\n        if k==6:\n            if n==1:\n                return \"6\"\n            if n==2:\n                return \"66\"\n            if n%2==1:\n                m = (n-3)//2\n                return \"8\" + \"9\"*m + \"8\" + \"9\"*m + \"8\"\n            m = (n-4)//2\n            return \"8\" + \"9\"*m + \"77\" + \"9\"*m + \"8\"\n        if k==7:\n            if n<100:\n                ans, dp = f(n,k)\n                return ans\n            ans, dp = f(10+n%2,k)\n            m = (n - (10+n%2))//2\n            \n            outer = 0\n            \n            tpm = [0] * n\n            # tpm[i] = (10^i) mod k\n            res = 1\n            for i in range(n):\n                tpm[i] = res % k\n                res = (res * 10) % k\n            for i in range(m):\n                outer = (outer + tpm[i]*9) % k\n            for i in range(m):\n                outer = (outer + tpm[i+m+10+n%2]*9) % k\n            for j in range(k):\n                total = (j * tpm[m] + outer) % k\n                if total ==0:\n                    return \"9\"*m + dp[j] + \"9\"*m\n            return \"9\"*m + dp[(-outer)%k] + \"9\"*m\n        if k==8:\n            if n<=6:\n                return \"8\"*n\n            return \"888\" + \"9\"*(n-6) + \"888\"",
    "submit_ts": "1723953132",
    "subm_id": "1359813219"
}