{
    "username": "SR3mix",
    "submission": "class TreeMaxDists {\npublic:\n    vector<int>firstMax,secondMax,maxPathChild;\n    vector<vector<int>>e;\n    TreeMaxDists(int n, vector<vector<int>>& edges) {\n        e = edges;\n        firstMax = vector<int>(n);\n        secondMax = vector<int>(n);\n        maxPathChild = vector<int>(n);\n        dfs(0,-1);\n        dfs2(0,-1);\n    }\n    void dfs(int v, int p) {\n        firstMax[v] = 0;\n        secondMax[v] = 0;\n        for (auto x : e[v]) {\n            if (x == p) continue;\n            dfs(x, v);\n            if (firstMax[x] + 1 > firstMax[v]) {\n                secondMax[v] = firstMax[v];\n                firstMax[v] = firstMax[x] + 1;\n                maxPathChild[v] = x;\n            } else if (firstMax[x] + 1 > secondMax[v]) {\n                secondMax[v] = firstMax[x] + 1;\n            }\n        }\n    }\n    void dfs2(int v, int p) {\n        for (auto x : e[v]) {\n            if (x == p) continue;\n            if (maxPathChild[v] == x) {\n                if (firstMax[x] < secondMax[v] + 1) {\n                    secondMax[x] = firstMax[x];\n                    firstMax[x] = secondMax[v] + 1;\n                    maxPathChild[x] = v;\n                } else {\n                    secondMax[x] = max(secondMax[x], secondMax[v] + 1);\n                }\n            } else {\n                secondMax[x] = firstMax[x];\n                firstMax[x] = firstMax[v] + 1;\n                maxPathChild[x] = v;\n            }\n            dfs2(x, v);\n        }\n    }\n};\n// CREDIT TO USACO GUIDE FOR THIS TEMPLATE -> https://usaco.guide/problems/cses-1132-tree-distances-i/solution\nclass Solution {\npublic:\n    vector<int>compute(vector<vector<int>>&e) {\n        int n = e.size();\n        vector<int>vis(n, INT_MAX);\n        queue<int>q;\n        for (int i = 0; i < n; i++) {\n            if (e[i].size() == 1) {\n                q.push(i);\n                vis[i] = 0;\n            }\n        }\n        while (q.size()) {\n            int curr = q.front(); q.pop();\n            for (auto node : e[curr]) {\n                if (vis[node] <= vis[curr] + 1) continue;\n                vis[node] = vis[curr] + 1;\n                q.push(node);\n            }\n        }\n        if (e.size() == 2) vis[0] = 1;\n        return vis;\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        vector<vector<int>>e1(n),e2(m);\n        for (auto &i : edges1) {\n            int n1 = i[0], n2 = i[1];\n            e1[n1].push_back(n2);\n            e1[n2].push_back(n1);\n        }\n        for (auto &i : edges2) {\n            int n1 = i[0], n2 = i[1];\n            e2[n2].push_back(n1);\n            e2[n1].push_back(n2);\n        }\n        TreeMaxDists T1(n, e1);\n        TreeMaxDists T2(m, e2);\n        \n        int g1 = *min_element(T1.firstMax.begin(), T1.firstMax.end());\n        int g2 = *min_element(T2.firstMax.begin(), T2.firstMax.end());\n        int o1 = *max_element(T1.firstMax.begin(), T1.firstMax.end());\n        int o2 = *max_element(T2.firstMax.begin(), T2.firstMax.end());\n        //int n1 = min_element(T1.firstMax.begin(), T1.firstMax.end()) - T1.firstMax.begin();\n        //cout << g1 << \",\" << g2 << \" on \" << n1 << endl;\n        return max(max(o1,o2),g1 + g2 + 1);\n    }\n};",
    "submit_ts": "1719716125",
    "subm_id": "1304355724"
}