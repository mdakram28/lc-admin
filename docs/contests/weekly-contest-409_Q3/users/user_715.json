{
    "username": "gamer_11",
    "submission": "class Node{\npublic:\n\tint v = 0; //We can use more variables depending on what all info we need !\n\t// 1. this is identitiyElement - default node value which will not impact answer on taken\n\tNode(){}\n\tNode(int val){\n\t\tv = val; // 2. Node constructor will change depending on, what we need to initialize\n\t}\n\t\n\tvoid merge(const Node& l, const Node& r){ // v is each nodes data, while l & r are children\n\t\tv = l.v + r.v; //3. Merge function (merge logic can change)\n\t}\n};\n\nclass Update{\npublic:\n\tint v = 0;\n\t// 4. this is identity Transformation - default update value assigned before or after the operation\n\tUpdate(){};\n\tUpdate(int val){\n\t\tv = val; // 5. Update constructor initialization\n\t}\n\t\n\tvoid combine(const Update& otherUpdate, const int& tl, const int& tr){ //combing the update, to give to chidren in future\n\t\tv = otherUpdate.v; // 6. OtherUpdate is the newest update ['=' or '+=' depends on 'assign/set' vs 'add']\n\t}\n\t\n\tvoid apply(Node& node, const int& tl, const int& tr) const{\n\t\tnode.v = (tr - tl + 1) * v; // 7. applying the update received on the node\n\t}\t\n};\n\ntemplate <typename node, typename update>\nclass SegTree{\npublic:\n\tint len;\n\t// t is the segment Tree\n\tvector<node> t;\n\tvector<update> unpropUpd; // the actual val of un-propogated updates to be processed\n\tvector<bool> isLazy; //tells if a certain node is storing un-propogated updates or not\n\tnode identityElement;\n\tupdate identityTransformation; \n\t\n\tSegTree(){}\n\tSegTree(int l){\n\t\tlen = l;\n\t\tt.resize(4 * len);\n\t\tisLazy.resize(4 * len);\n\t\tunpropUpd.resize(4 * len);\n\t\tidentityElement = node();\n\t\tidentityTransformation = update();\n\t}\n\t\n\t// asking v, to remember that he has 'val' update for his range\n\tvoid apply(const int& v,const int& tl,const int& tr,const update& upd){ // [tl, tr] is node range\n\t\tif(tl != tr){ // leaf nodes can't be lazy, as they have no-one to propogate to\n\t\t\tisLazy[v] = true;\n\t\t\tunpropUpd[v].combine(upd, tl, tr); //stacking up the unpropogaed value, which i'll propogate down\n\t\t}\n\t\tupd.apply(t[v], tl, tr); // this \"= shows assign update\", \"+= shows range add update\" \n\t}\n\t\n\t// assigning the value whatsoever we had on 'v' to its children ('2*v' & '2*v+1')\n\tvoid pushDown(const int& v,const int& tl,const int& tr){\n\t\tif(!isLazy[v]) return; // if not lazy then no push-down required\n\t\tisLazy[v] = false; //no more lazy\n\t\tint tm = (tl + tr)/2;\n\t\tapply(2*v, tl, tm, unpropUpd[v]); // propogates to left child\n\t\tapply(2*v+1, tm+1, tr, unpropUpd[v]); // propogates to right child\n\t\tunpropUpd[v] = identityTransformation; // identity-transformation -- updated the children(job done)\n\t}\n\t\n\t// Build Segment Tree -- build(a, 1, 0, len-1); \n\ttemplate<typename T>\n\tvoid build(const T& a,const int& v,const int& tl,const int& tr){\n\t\tif(tl == tr){\n\t\t\tt[v] = a[tl];\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr)/2;\n\t\tbuild(a, 2*v, tl, tm);\n\t\tbuild(a, 2*v+1, tm+1, tr);\n\t\tt[v].merge(t[2*v], t[2*v+1]);\n\t}\n\t\n\t// Query input question is = [l, r] included -- query(1, 0, len-1, l, r)\n\tnode query(const int& v,const int& tl,const int& tr,const int& l,const int& r){\n\t\tif(tl > r || tr < l) return identityElement; // no overlap\n\t\tif(l <= tl && tr <= r) return t[v]; //Full overlap\n\t\t\n\t\t// Partial Overlap\n\t\tpushDown(v, tl, tr); //we remove the lazy tag before going down, so children have correct info\n\t\tint tm = (tl + tr)/2;\n\t\tnode leftAns = query(2*v, tl, tm, l, r);\n\t\tnode rightAns = query(2*v+1, tm+1, tr, l, r);\n\t\tnode ans;\n\t\tans.merge(leftAns, rightAns);\n\t\treturn ans;\n\t}\n\t\n\t// Update at index id of nums to a value val (assign/override/set) -- update(1, 0, len-1, l, r, val) \n\tvoid rangeUpdate(const int& v,const int& tl,const int& tr,const int& l,const int& r, const update& upd){\n\t\t// reached leaf node\n\t\tif(l <= tl && tr <= r){ // full overlap -- apply update and return back\n\t\t\tapply(v, tl, tr, upd); \n\t\t\treturn;\n\t\t}\n\t\tif(tl > r || tr < l) return; // no overlap\n\t\t\n\t\t// Partial Overlap\n\t\tpushDown(v, tl, tr);\n\t\tint tm = (tl + tr)/2;\n\t\trangeUpdate(2*v, tl, tm, l, r, upd);\n\t\trangeUpdate(2*v+1, tm+1, tr, l, r, upd);\n\t\tt[v].merge(t[2*v], t[2*v+1]);\n\t}\n\t\n\t//over-ridden functions\n\ttemplate<typename T>\n\tvoid build(const T& a){\n\t\tbuild(a, 1, 0, len-1);\n\t}\n\t\n\tnode query(const int& l,const int& r){\n\t\treturn query(1, 0, len-1, l, r);\n\t}\n\t\n\tvoid rangeUpdate(const int& l,const int& r, const update& upd){\n\t\trangeUpdate(1, 0, len-1, l, r, upd);\n\t}\n};\n\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int> res;\n        \n        SegTree<Node, Update> segTree(n);\n        vector<int> a(n);\n\t    segTree.build(a);\n     \n        int ans = n-1;\n        for(vector<int> &q :queries) {\n            int l = q[0];\n            int r = q[1];\n            \n            int sum = segTree.query(l+1, r-1).v;\n            cout<<sum<<endl;\n            ans -= (r-l-1) - sum;\n            res.push_back(ans);\n            \n            segTree.rangeUpdate(l+1, r-1, 1);\n        }\n        \n        return res;\n    }\n};",
    "submit_ts": "1722741903",
    "subm_id": "1343756231"
}