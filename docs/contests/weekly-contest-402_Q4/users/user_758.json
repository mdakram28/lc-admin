{
    "username": "TheZwischenzug",
    "submission": "class AssociativeOperatorOnSubArray<T> {\n    private List<T> segmentTree;\n    private T identity;\n    private BinaryOperator<T> associativeBinaryOperator;\n    AssociativeOperatorOnSubArray(List<T> list, BinaryOperator<T> associativeBinaryOperator, T identity){\n        this.identity = identity;\n        this.associativeBinaryOperator = associativeBinaryOperator;\n        createSegmentTree(list);\n    }\n\n    private void createSegmentTree(List<T> list) {\n        int identityPaddedLen = 1;\n        while (identityPaddedLen < list.size()) identityPaddedLen <<= 1;\n\n        segmentTree = new ArrayList<>(2*identityPaddedLen);\n\n        for (int i = 0; i < 2*identityPaddedLen; i++) segmentTree.add(identity);\n\n        for (int i = 0; i < list.size(); i++) segmentTree.set(i+identityPaddedLen, list.get(i));\n\n        for (int i = identityPaddedLen-1; i > 0; i--){\n            T leftChildVal = segmentTree.get(2*i);\n            T rightChildVal = segmentTree.get(2*i+1);\n            segmentTree.set(i, associativeBinaryOperator.apply(leftChildVal, rightChildVal));\n        }\n    }\n    public T pointQuery(int index){\n        int treeIndex = segmentTree.size()/2 + index;\n        return segmentTree.get(treeIndex);\n    }\n    public void update(int index, T newValue){\n        int treeIndex = segmentTree.size()/2+index;\n        segmentTree.set(treeIndex, newValue);\n        for (int parent = treeIndex/2; parent != 0; parent /= 2){\n            T leftVal = segmentTree.get(2*parent);\n            T rightVal = segmentTree.get(2*parent+1);\n            segmentTree.set(parent, associativeBinaryOperator.apply(leftVal, rightVal));\n        }\n\n    }\n    private T getSubArrayValue(int arrayLeft, int arrayRight, int nodeLeft, int nodeRight, int treeIndex){\n        if (arrayLeft > nodeRight || arrayRight < nodeLeft) return identity;\n        if (arrayLeft <= nodeLeft && nodeRight <= arrayRight){\n            return segmentTree.get(treeIndex);\n        }\n        int mid = (nodeLeft+nodeRight)/2;\n        return associativeBinaryOperator.apply(\n                getSubArrayValue(arrayLeft, arrayRight, nodeLeft, mid, 2*treeIndex),\n                getSubArrayValue(arrayLeft, arrayRight, mid+1, nodeRight, 2*treeIndex+1)\n        );\n\n    }\n    public T getSubArrayValue(int arrayLeft, int arrayRight){\n        return getSubArrayValue(arrayLeft, arrayRight, 0, (segmentTree.size()/2)-1, 1);\n    }\n\n\n}\nclass Container{\n\n    int first, second;\n    int last, lastButOne;\n    int count;\n    int size;\n\n    public Container(int first, int second, int last, int lastButOne, int count) {\n        this.first = first;\n        this.second = second;\n        this.last = last;\n        this.lastButOne = lastButOne;\n        this.count = count;\n    }\n}\nclass Solution {\n\n    AssociativeOperatorOnSubArray<Container> tree;\n\n    private Container combine(Container a, Container b){\n        if (b == null) return a;\n        if (a == null) return b;\n        int first = a.first;\n        int second;\n        if (a.second == -1) second = b.first;\n        else second = a.second;\n        \n        \n        int last = b.last;\n        \n        int lastButOne;\n        if (b.lastButOne == -1) lastButOne = a.last;\n        else lastButOne = b.lastButOne;\n        \n        int count = a.count+b.count;\n        if (a.lastButOne != -1 && a.last > a.lastButOne && a.last > b.first) count++;\n        \n        if (b.second != -1 && b.first > b.second && b.first > a.last)  count++;\n        return new Container(first, second, last, lastButOne, count);\n    }\n    List<Container> getList(int[] nums){\n        List<Container> list = new ArrayList<>();\n        for (int x : nums) list.add(new Container(x, -1, x, -1, 0));\n        return list;\n    }\n    private void initTree(int[] nums){\n        List<Container> list = getList(nums);\n        tree = new AssociativeOperatorOnSubArray<>(list, this::combine, null);\n    }\n    \n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        initTree(nums);\n        List<Integer> ans = new ArrayList<>();\n        for (int[] q : queries){\n            if (q[0] == 1){\n                int left = q[1];\n                int right = q[2];\n                int queryAns = tree.getSubArrayValue(left, right).count;\n                ans.add(queryAns);\n            }\n            else{\n                int idx = q[1];\n                int val = q[2];\n                tree.update(idx, new Container(val, -1, val, -1, 0));\n            }\n        }\n        return ans;\n    }\n}",
    "submit_ts": 1718508702.0
}