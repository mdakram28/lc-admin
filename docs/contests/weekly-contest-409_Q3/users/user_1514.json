{
    "username": "mayankkmsc23",
    "submission": "class Solution {\npublic:\n    int N;\n    vector<int> Tree, Lazy;\n\n    void buildTree(int tidx, int lo, int hi){\n        Tree.resize(4*N);\n        Lazy.resize(4*N, 0);\n        if(lo==hi){\n            Tree[tidx] = lo;\n            return;\n        }\n\n        int mid = (lo+hi)/2;\n\n        buildTree(2*tidx+1, lo, mid);\n        buildTree(2*tidx+2, mid+1, hi);\n\n        Tree[tidx] = max(Tree[2*tidx+1], Tree[2*tidx+2]);\n\n    }\n\n    void updateLazy(int tidx, int lo, int hi, int L, int R, int val){\n\n        // Complete any pending updates before entering this node\n        if(Lazy[tidx]!=0){\n            Tree[tidx] += Lazy[tidx];\n            if(lo!=hi){\n                Lazy[2*tidx+1] += Lazy[tidx];\n                Lazy[2*tidx+2] += Lazy[tidx];\n            }\n            Lazy[tidx] = 0;\n        }\n\n        // The Range which we are currently in : [lo, hi]\n        // The Range we have to update for : [L, R]\n\n        // Outside Range\n        if(R<lo||L>hi) return;\n\n        // In Range\n        if(L<=lo&&hi<=R){\n            // Update the Tree's value lazily, and then add update to be done for future to children.\n            Tree[tidx] += val;\n            if(lo!=hi){\n                Lazy[2*tidx+1] += val;\n                Lazy[2*tidx+2] += val;\n            }\n            return;\n        }\n\n        // Parital Overlap (Go to Left and Right)\n\n        int mid = (lo+hi)/2;\n        updateLazy(2*tidx+1, lo, mid, L, R, val);\n        updateLazy(2*tidx+2, mid+1, hi, L, R, val);\n\n        // Update the values once children are updated\n        Tree[tidx] = max(Tree[2*tidx+1], Tree[2*tidx+1]);\n\n    }\n\n    int queryLazy(int tidx, int lo, int hi, int L, int R){\n\n        // Complete any pending updates before querying this node\n        if(Lazy[tidx]!=0){\n            Tree[tidx] += Lazy[tidx];\n            if(lo!=hi){\n                Lazy[2*tidx+1] += Lazy[tidx];\n                Lazy[2*tidx+2] += Lazy[tidx];\n            }\n            Lazy[tidx] = 0;\n        }\n\n        // The Range which we are currently in : [lo, hi]\n        // The Range we have to compute the answer for : [L, R]\n\n        // Outside Range\n        if(R<lo||L>hi) return 0;\n\n        // In Range\n        if(L<=lo&&hi<=R) return Tree[tidx];\n\n        // Partial Overlap (Go to Left and Right)\n        int mid = (lo+hi)/2;\n\n        int leftans = queryLazy(2*tidx+1, lo, mid, L, R);\n        int rightans = queryLazy(2*tidx+2, mid+1, hi, L, R);\n\n        return max(leftans, rightans);\n\n    }\n    \n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        N = n;\n        buildTree(0, 0, n-1);\n        int q = queries.size();\n        set<vector<int>> s;\n        vector<int> ans;\n        int temp = n-1;\n        for(int i = 0; i<q; i++){\n            auto t = s.upper_bound(queries[i]);\n            if(t == s.begin() && t!= s.end()){\n                if((*t)[0] > queries[i][0]){\n                    s.insert(queries[i]);\n                    int e = queryLazy(0, 0, n-1, queries[i][1], queries[i][1]);\n                    int s = queryLazy(0, 0, n-1, queries[i][0], queries[i][0]);\n                    temp = temp - (e-s-1);\n                    updateLazy(0, 0, n-1, queries[i][1], n-1, -1*(e-s-1));\n                    cout<<queries[i][0]<<\"  \"<<queries[i][1]<<\"  \"<<s<<\"  \"<<e<<\"  \"<<-(e-s-1)<<endl;\n                } else {\n                    cout<<\"skip \"<<queries[i][0]<<\"  \"<<queries[i][1]<<endl;\n                }\n                ans.push_back(temp);\n                continue;\n            }\n            if(t == s.end() && s.size() >= 1){\n                t--;\n            }\n            if(t!= s.end() && (*t)[0] > queries[i][0]){\n                t--;\n            }\n            if(t != s.end() && (*t)[1] >= queries[i][1]){\n                cout<<\"skip \"<<queries[i][0]<<\"  \"<<queries[i][1]<<endl;\n                ans.push_back(temp);\n            } else {\n                s.insert(queries[i]);\n                int e = queryLazy(0, 0, n-1, queries[i][1], queries[i][1]);\n                int s = queryLazy(0, 0, n-1, queries[i][0], queries[i][0]);\n                temp = temp - (e-s-1);\n                updateLazy(0, 0, n-1, queries[i][1], n-1, -1*(e-s-1));\n                cout<<queries[i][0]<<\"  \"<<queries[i][1]<<\"  \"<<s<<\"  \"<<e<<\"  \"<<-1*(e-s-1)<<endl;\n                ans.push_back(temp);\n            }\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": "1722743927",
    "subm_id": "1343802869"
}