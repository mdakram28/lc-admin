{
    "username": "user4112Yu",
    "submission": "class Solution {\npublic:\n#define LEFT(i) (2*i+1)\n#define RIGHT(i) (2*i+2)\n    struct SegTree {\n        vector<int> val;\n        int n;\n        SegTree(vector<int>& nums, int n): val(4*n, 0), n(n) {\n                init(nums, 0, 0, n-1);\n        }\n        void init(vector<int>& nums, int node, int left, int right) {\n            if (left == right) {\n                val[node] = nums[left];\n                return;\n            }\n            int mid = left+(right-left)/2;\n            init(nums, LEFT(node), left, mid);\n            init(nums, RIGHT(node), mid+1, right);\n            val[node] = val[LEFT(node)] + val[RIGHT(node)];\n        }\n        int queryRange(int qa, int qb) {\n            return queryRange(0, 0, n-1, qa, qb);\n        }\n        int queryRange(int node, int left, int right, int qa, int qb) {\n            if (qb < left || right < qa) return 0;\n            if (qa <= left && right <= qb) return val[node];\n            int mid = left + (right-left)/2;\n            return queryRange(LEFT(node), left, mid, qa, qb) +\n                   queryRange(RIGHT(node), mid+1, right, qa, qb);\n        }\n        void updateSingle(int idx, int add) {\n            return updateSingle(0, 0, n-1, idx, add);\n        }\n        void updateSingle(int node, int left, int right, int idx, int add) {\n            if (idx < left || idx > right) return;\n            if (left == right) {\n                val[node] = add;\n                return;\n            }\n            int mid = left + (right-left)/2;\n            updateSingle(LEFT(node), left, mid, idx, add);\n            updateSingle(RIGHT(node), mid+1, right, idx, add);\n            val[node] = val[LEFT(node)] + val[RIGHT(node)];\n        }\n\n    };\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> isPeak(nums.size(), 0);\n        int n = nums.size();\n        for (int i=1; i<n-1; i++) {\n            if (nums[i]>nums[i-1] && nums[i]>nums[i+1]) isPeak[i] = 1;\n        }\n        SegTree st(isPeak, n);\n        vector<int> ans;\n        for (auto& q: queries) {\n            if (q[0] == 1) {\n                ans.push_back(st.queryRange(q[1]+1, q[2]-1));\n            } else { // q[0] = 2;\n                nums[q[1]] = q[2];\n                for (int i=q[1]-1; i<=q[1]+1; i++) {\n                    if (i-1>=0 && i+1<n) {\n                        st.updateSingle(i, (nums[i]>nums[i-1] && nums[i]>nums[i+1]));\n                    }   \n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718507982.0
}