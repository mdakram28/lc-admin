{
    "username": "archip",
    "submission": "from sortedcontainers import *\n\nclass Node:\n    def __init__(self):\n        self.left = None\n        self.right = None\n        self.min = float(\"inf\")\n        self.max = float(\"-inf\")\n        self.sum = float(\"inf\")\n        self.leftEdge = None\n        self.rightEdge = None\n\n\nclass SegmentTree:\n    def __init__(self):\n        \"\"\"\n        Initializer method to initialize the class level objects\n        :rtype: object\n        \"\"\"\n        self.partial_overlap = \"Partial overlap\"\n        self.no_overlap = \"No overlap\"\n        self.complete_overlap = \"Complete overlap\"\n\n    def get_overlap(self, x1, y1, x2, y2):\n        \"\"\"\n        Method to get the overlapping type for a given ranges\n        X1, Y1 -> Given node's range\n        X2, Y2 -> Query range\n        :return: type of overlap\n        \"\"\"\n        if (x1 == x2 and y1 == y2) or (x1 >= x2 and y1 <= y2):\n            overlap = self.complete_overlap\n        elif (y1 < x2) or (x1 > y2):\n            overlap = self.no_overlap\n        else:\n            overlap = self.partial_overlap\n        return overlap\n\n    def construct_segment_tree(self, array, start, end):\n        \"\"\"\n        Method to construct a Segment tree using a given array elements\n        :param end:\n        :param start:\n        :param array: Array elements\n        :return: Root node of a segment tree\n        \"\"\"\n        if end - start <= 0 or len(array) == 0:\n            return None\n        if end - start == 1:\n            node = Node()\n            node.min = array[start]\n            node.max = array[start]\n            node.sum = array[start]\n            node.leftEdge = start\n            node.rightEdge = end - 1\n            return node\n        else:\n            node = Node()\n            mid = start + (end - start) // 2\n            node.left = self.construct_segment_tree(array, start=start, end=mid)\n            node.right = self.construct_segment_tree(array, start=mid, end=end)\n            if node.left is None and node.right is None:\n                node.sum = 0\n                node.leftEdge = start\n                node.rightEdge = start\n                node.min = float(\"inf\")\n                node.max = float(\"-inf\")\n            elif node.left is None:\n                node.sum = node.right.sum\n                node.leftEdge = node.right.leftEdge\n                node.rightEdge = node.right.rightEdge\n                node.min = node.right.min\n                node.max = node.right.max\n            elif node.right is None:\n                node.sum = node.left.sum\n                node.leftEdge = node.left.leftEdge\n                node.rightEdge = node.left.rightEdge\n                node.min = node.left.min\n                node.max = node.left.max\n            else:\n                node.min = min(node.left.min, node.right.min)\n                node.max = max(node.left.max, node.right.max)\n                node.sum = node.left.sum + node.right.sum\n                node.leftEdge = node.left.leftEdge\n                node.rightEdge = node.right.rightEdge\n            return node\n\n    def update_segment_tree(self, head, index, new_value, array):\n        \"\"\"\n        Method to update the segment tree node value\n        :return: Head node of a segment tree\n        :rtype: object\n        \"\"\"\n        if index == head.leftEdge == head.rightEdge:\n            head.max = new_value\n            head.min = new_value\n            head.sum = new_value\n            array[index] = new_value\n            return head\n        elif (head.leftEdge <= index <= head.rightEdge) and (head.rightEdge > head.leftEdge):\n            left_node = self.update_segment_tree(head=head.left, index=index, new_value=new_value, array=array)\n            right_node = self.update_segment_tree(head=head.right, index=index, new_value=new_value, array=array)\n            head.sum = right_node.sum + left_node.sum\n            head.min = min(left_node.min, right_node.min)\n            head.max = max(left_node.max, right_node.max)\n            return head\n        else:\n            return head\n\n    def get_minimum(self, head, left, right):\n        \"\"\"\n        Method to get the minimum in a given range query\n        :return: Minimum value for a given range query\n        \"\"\"\n        overlap = self.get_overlap(head.leftEdge, head.rightEdge, left, right)\n        if overlap == self.complete_overlap:\n            return head.min\n        elif overlap == self.no_overlap:\n            return float(\"inf\")\n        elif overlap == self.partial_overlap:\n            left_min = self.get_minimum(head=head.left, left=left, right=right)\n            right_min = self.get_minimum(head=head.right, left=left, right=right)\n            return min(left_min, right_min)\n\n    def get_maximum(self, head, left, right):\n        \"\"\"\n        Method to get the maximum value for a given range query\n        :return Maximum value for a given range query\n        \"\"\"\n        overlap = self.get_overlap(head.leftEdge, head.rightEdge, left, right)\n        if overlap == self.complete_overlap:\n            return head.max\n        elif overlap == self.no_overlap:\n            return float(\"-inf\")\n        elif overlap == self.partial_overlap:\n            left_max = self.get_maximum(head=head.left, left=left, right=right)\n            right_max = self.get_maximum(head=head.right, left=left, right=right)\n            return max(left_max, right_max)\n\n    def get_sum(self, head, left, right):\n        \"\"\"\n        Method to return the sum of an array elements for a given range query\n        :return: Returns the sum of an array elements for a given range query\n        \"\"\"\n        overlap = self.get_overlap(head.leftEdge, head.rightEdge, left, right)\n        if overlap == self.complete_overlap:\n            return head.sum\n        elif overlap == self.no_overlap:\n            return 0\n        elif overlap == self.partial_overlap:\n            left_sum = self.get_sum(head=head.left, left=left, right=right)\n            right_sum = self.get_sum(head=head.right, left=left, right=right)\n            return left_sum + right_sum\n\n    def preorder_traversal(self, head, array):\n        if head is None:\n            return\n        print(\"Array = {} Min = {}, Max = {}, Sum = {}\".format(array[head.leftEdge:head.rightEdge + 1], head.min,\n                                                               head.max, head.sum))\n        self.preorder_traversal(head=head.left, array=array)\n        self.preorder_traversal(head=head.right, array=array)\n\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        largest_query = max(q[1] for q in queries)\n        blocks = [0 for _ in range(largest_query + 5)]\n        ans = []\n        \n        st = SegmentTree()\n        root = st.construct_segment_tree(array=blocks, start=0, end=len(blocks))\n        \n        def update(idx, value):\n            st.update_segment_tree(head=root, index=idx, new_value=value, array=blocks)\n            pass\n        \n        def getmax(idx):\n            return st.get_maximum(head=root, left=0, right=idx)\n        \n        assigned = SortedList()\n        assigned.add([len(blocks) - 1, len(blocks) - 1])\n        assigned.add([0, 0])\n        blocks[-1] = len(blocks) - 1\n        update(len(blocks) - 1, len(blocks) - 1)\n        \n        def place_block(x):\n            assigned.add([x, 0])\n            aidx = assigned.bisect_left([x, 0])\n      #      print(assigned, x)\n            below = assigned[aidx - 1]\n            above = assigned[aidx + 1]\n            assigned[aidx][1] = x - below[0]\n            assigned[aidx + 1][1] = above[0] - x\n            blocks[x] = x - below[0]\n            blocks[above[0]] = above[0] - x\n            update(x, x - below[0])\n            update(above[0], above[0] - x)\n        \n        def answer(query):\n          #  print('--', query)\n          #  print(getmax(query[1]), query[2])\n      #      print(blocks, assigned)\n            best = getmax(query[1])\n            assigned.add([query[1], 0])\n            aidx = assigned.bisect_left([query[1], 0])\n            below = assigned[aidx - 1]\n            best = max(best, query[1] - below[0])\n            assigned.remove([query[1], 0])\n            \n            ans.append(query[2] <= best)\n        \n    #    print('-------------------')\n     #   print(assigned)\n        for query in queries:\n            if query[0] == 1:\n                place_block(query[1])\n       #         print(assigned)\n            else:\n                answer(query)\n                \n            \n        return ans\n        ",
    "submit_ts": 1716650798.0
}