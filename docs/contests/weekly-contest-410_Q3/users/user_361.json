{
    "username": "jachetheboss",
    "submission": "class Solution {\npublic:\n    int countOfPairs(vector<int>& nums) {\n        // the follow-up problem with larger constraints is probably a DP + internal prefix array problem? kind of like O(n^2)\n        // # of knight moves rather than O(n^3) number of knight moves on a phone pad (Mark Rosen GS interview DP)\n        \n        int mx = 0;\n        for(int x : nums) mx = max(mx, x);\n        \n        vector<vector<long long>> DP (nums.size(), vector<long long> (mx + 1, 0)); // DP[i][j] is the number of good pairs so far such that arr1[i] == j\n        for(int x = 0; x <= nums[0]; ++x) DP[0][x] = 1;\n        int MOD = 1000000007;\n        for(int i = 1; i < DP.size(); ++i){\n            for(int j = 0; j <= nums[i]; ++j){\n                for(int k = 0; k < DP[i - 1].size(); ++k){\n                    if(DP[i - 1][k] == 0) continue;\n                    \n                    int prev_num1 = k;\n                    int prev_num2 = nums[i - 1] - prev_num1;\n                    int num1 = j;\n                    int num2 = nums[i] - num1;\n                    if(num1 >= prev_num1 and num2 <= prev_num2){\n                        DP[i][j] += DP[i - 1][k];\n                        DP[i][j] %= MOD;\n                    }\n                }\n            }\n        }\n        long long ans = 0;\n        for(long long incr : DP.back()){\n            ans += incr;\n            ans %= MOD;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1723346097",
    "subm_id": "1351570129"
}