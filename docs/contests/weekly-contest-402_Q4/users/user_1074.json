{
    "username": "vivashwanghosh",
    "submission": "class Solution {\nprivate:\n    static bool isPeak(int i, int n, const vector<int>& nums) \n    {\n        return (i > 0 && i < n - 1 && nums[i] > nums[i - 1] && nums[i] > nums[i + 1]);\n    }\n\n    void updatePeakStatus(int index, int n, vector<int>& nums, vector<int>& segmentTree, int start, int end, int pos) \n    {\n        if (start == end) \n        {\n            segmentTree[pos] = isPeak(start, n, nums) ? 1 : 0;\n            return;\n        }\n        int mid = (start + end) / 2;\n        if (index <= mid) \n        {\n            updatePeakStatus(index, n, nums, segmentTree, start, mid, 2 * pos + 1);\n        } \n        else updatePeakStatus(index, n, nums, segmentTree, mid + 1, end, 2 * pos + 2);\n        \n        \n        segmentTree[pos] = segmentTree[2 * pos + 1] + segmentTree[2 * pos + 2];\n    }\n\n    int countPeaksInRange(int l, int r, vector<int>& segmentTree, int start, int end, int pos) \n    {\n        if (l <= start && r >= end) \n        {\n            return segmentTree[pos];\n        }\n        \n        if (l > end || r < start) \n        {\n            return 0;\n        }\n        \n        int mid = (start + end) / 2;\n        \n        return countPeaksInRange(l, r, segmentTree, start, mid, 2 * pos + 1) + countPeaksInRange(l, r, segmentTree, mid + 1, end, 2 * pos + 2);\n    }\n\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> res, segmentTree(4*n, 0);\n\n        for (int i=1; i<n-1; i++) \n        {\n            updatePeakStatus(i, n, nums, segmentTree, 0, n - 1, 0);\n        }\n\n        for (auto it:queries) \n        {\n            if (it[0]==2) \n            {\n                int index = it[1], value = it[2];\n                \n                nums[index] = value;\n                \n                \n                for (int i = max(1, index - 1); i <= min(n - 2, index + 1); i++) \n                {\n                    updatePeakStatus(i, n, nums, segmentTree, 0, n - 1, 0);\n                }\n            } \n            else\n            { \n                int left = it[1], right = it[2];\n                \n                int count = countPeaksInRange(left + 1, right - 1, segmentTree, 0, n - 1, 0);\n                \n                res.push_back(count);\n            }\n        }\n\n        return res;\n    }\n};",
    "submit_ts": 1718508258.0
}