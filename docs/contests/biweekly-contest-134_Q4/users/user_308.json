{
    "username": "Andyp3",
    "submission": "#pragma GCC optimize(\"O3,unroll-loops\")\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace chrono;\nusing namespace __gnu_pbds;\n\n#define fastio() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n#define MOD 1000000007 // MOD is deicded for 1e9+7\n#define MOD1 998244353  \n#define INF 1e18  // INF is decided for 1e18\n#define nline \"\\n\" // nline is for \"\\n\"\n#define pb push_back \n#define ppb pop_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define PI 3.141592653589793238462\n#define set_bits(x) __builtin_popcountll(x)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lld;\ntypedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update > pbds; // find_by_order, order_of_key\n\ntemplate <class T, class V> void _print(pair <T, V> p);\ntemplate <class T> void _print(vector <T> v);\ntemplate <class T> void _print(set <T> v);\ntemplate <class T, class V> void _print(map <T, V> v);\ntemplate <class T> void _print(multiset <T> v);\ntemplate <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}\ntemplate <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\ntemplate <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\ntemplate <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\ntemplate <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\n\n// Credits to HealthyUG for the inspiration.\n// Segment Tree with Point Updates and Range Queries\n// Supports multiple Segment Trees with just a change in the Node and Update\n// Very few changes required everytime\n\ntemplate<typename Node, typename Update>\nstruct SegTree {\n\tvector<Node> tree;\n\tvector<ll> arr; // type may change\n\tint n;\n\tint s;\n\tSegTree(int a_len, vector<ll> &a) { // change if type updated\n\t\tarr = a;\n\t\tn = a_len;\n\t\ts = 1;\n\t\twhile(s < 2 * n){\n\t\t\ts = s << 1;\n\t\t}\n\t\ttree.resize(s); fill(all(tree), Node());\n\t\tbuild(0, n - 1, 1);\n\t}\n\tvoid build(int start, int end, int index)  // Never change this\n\t{\n\t\tif (start == end)\t{\n\t\t\ttree[index] = Node(arr[start]);\n\t\t\treturn;\n\t\t}\n\t\tint mid = (start + end) / 2;\n\t\tbuild(start, mid, 2 * index);\n\t\tbuild(mid + 1, end, 2 * index + 1);\n\t\ttree[index].merge(tree[2 * index], tree[2 * index + 1]);\n\t}\n\tvoid update(int start, int end, int index, int query_index, Update &u)  // Never Change this\n\t{\n\t\tif (start == end) {\n\t\t\tu.apply(tree[index]);\n\t\t\treturn;\n\t\t}\n\t\tint mid = (start + end) / 2;\n\t\tif (mid >= query_index)\n\t\t\tupdate(start, mid, 2 * index, query_index, u);\n\t\telse\n\t\t\tupdate(mid + 1, end, 2 * index + 1, query_index, u);\n\t\ttree[index].merge(tree[2 * index], tree[2 * index + 1]);\n\t}\n\tNode query(int start, int end, int index, int left, int right) { // Never change this\n\t\tif (start > right || end < left)\n\t\t\treturn Node();\n\t\tif (start >= left && end <= right)\n\t\t\treturn tree[index];\n\t\tint mid = (start + end) / 2;\n\t\tNode l, r, ans;\n\t\tl = query(start, mid, 2 * index, left, right);\n\t\tr = query(mid + 1, end, 2 * index + 1, left, right);\n\t\tans.merge(l, r);\n\t\treturn ans;\n\t}\n\tvoid make_update(int index, ll val) {  // pass in as many parameters as required\n\t\tUpdate new_update = Update(val); // may change\n\t\tupdate(0, n - 1, 1, index, new_update);\n\t}\n\tNode make_query(int left, int right) {\n\t\treturn query(0, n - 1, 1, left, right);\n\t}\n};\n\nstruct Node1 {\n\tll val; // may change\n\tNode1() { // Identity element\n\t\tval = ((1ll<<32)-1);\t// may change\n\t}\n\tNode1(ll p1) {  // Actual Node\n\t\tval = p1; // may change\n\t}\n\tvoid merge(Node1 &l, Node1 &r) { // Merge two child nodes\n\t\tval = l.val&r.val;  // may change\n\t}\n};\n\nstruct Update1 {\n\tll val; // may change\n\tUpdate1(ll p1) { // Actual Update\n\t\tval = p1; // may change\n\t}\n\tvoid apply(Node1 &a) { // apply update to given node\n\t\ta.val = val; // may change\n\t}\n};\n\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        long long ans = 0;\n        int n = nums.size();\n        vector<ll>arr;\n        for (auto it : nums) arr.push_back(it);\n        SegTree<Node1,Update1> seg = SegTree<Node1,Update1>(n,arr);\n        \n        for (int i = 0; i<n; i++){\n            int l = -1;\n            int r = i;\n            if(i == 0){\n                if(arr[i]==k) ans++;\n                continue;\n            }\n            while (l+1<r){\n                ll m = (l+r)/2;\n                ll v = seg.make_query(m,i).val;\n                if(v>=k) r = m;\n                else l = m;\n            }\n            if(seg.make_query(r,i).val != k) continue;\n            ll left = r;\n            l = 0;\n            r = i+1;\n            while (l+1<r){\n                ll m = (l+r)/2;\n                ll v = seg.make_query(m,i).val;\n                if(v<=k) l = m;\n                else r = m;\n            }\n            ll right = l;\n            if(seg.make_query(l,i).val != k) continue;\n            ans += (right-left+1);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720279084",
    "subm_id": "1311736701"
}