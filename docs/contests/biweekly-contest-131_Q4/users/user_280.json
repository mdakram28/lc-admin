{
    "username": "dristiron03",
    "submission": "int build(int node, int L, int R, vector<int>&st){\n    if(L>R)return 0;\n    \n    if(L == R){\n        st[node] = L;\n        return L;\n    }\n    int mid = (L+R)/2;\n    st[node] = max(build(2*node, L, mid, st), build(2*node+1, mid+1, R, st));\n\n    return st[node];\n}\n\nvoid update(int node, int L, int R, int p, int v, vector<int>&st){\n    if(L>R)return;\n    \n    if(L==R){\n        st[node] = v;\n        return;\n    }\n    \n    int mid = (L+R)/2;\n    \n    if(p <= mid){\n        update(2*node,L,mid, p, v, st);\n    }\n    else{\n        update(2*node+1,mid+1,R, p, v, st);\n    }\n    \n    st[node] = max(st[node*2], st[2*node+1]);\n}\n\nint get(int node, int L, int R, int l, int r, vector<int>&st){\n    if(l > R or r < L or L > R){\n        return 0;\n    }\n    \n    if(l<=L and r >= R){\n        // cout<<st[node]<<\", \"<<L<<\" \"<<R<<\"\\n\";\n        return st[node];\n    }\n    \n    int mid = (L+R)/2;\n    \n    return max(get(2*node,L,mid,l,r,st), get(2*node+1,mid+1,R,l,r,st));\n}\n\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        \n        set<int>obstacles;\n        \n        vector<int>SegTree(4*1e5+5, 0);\n        // build(1, 1, 5*1e4+5, SegTree);\n        \n        vector<bool>ans;\n        \n        for(auto query: queries){\n            if (query[0] == 1){\n                // find left and right\n                auto itr = obstacles.upper_bound(query[1]);\n                int L, R;\n                if(itr != obstacles.end()){\n                    R = *itr;\n                }\n                else{\n                    R = -1;\n                }\n                \n                if(itr != obstacles.begin()){\n                    itr--;\n                    L = *itr;\n                }\n                else{\n                    L = 0;\n                }\n                \n                obstacles.insert(query[1]);\n                update(1,1,5*1e4+5, query[1], query[1]-L, SegTree);\n                \n                // cout<<\"R: \"<<R<<\"->\"<<R-query[1]<<\"\\n\";\n                if(R != -1){update(1,1,5*1e4+5, R, R-query[1], SegTree);}\n            }\n            else{\n                auto itr = obstacles.lower_bound(query[1]);\n                if(itr != obstacles.begin()){\n                    itr--;\n                    if(query[1]-(*itr) >= query[2]){\n                        ans.push_back(true);\n                        continue;\n                    }\n                    else{\n                        query[1] = *itr;\n                    }\n                }\n                else{\n                    if(query[1] >= query[2]){\n                        ans.push_back(true);\n                        continue;\n                    }\n                    else{\n                        ans.push_back(false);\n                        continue;\n                    }\n                }\n                \n                // cout<<query[1]<<\" \";\n                int v = get(1,1,5*1e4+5, 1,query[1], SegTree);\n                \n                // cout<<v<<\"\\n\";\n                \n                if(v>=query[2]){\n                    ans.push_back(true);\n                }\n                else{\n                    ans.push_back(false);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716651801.0
}