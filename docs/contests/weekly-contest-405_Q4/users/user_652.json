{
    "username": "Amit130",
    "submission": "struct Node {\n    unordered_map<char, Node*> next;\n    vector<pair<int, int>> ends;\n};\n\nNode* createNode() {\n    return new Node();\n}\n\nvoid addWord(Node* root, const string& word, int idx, int cost) {\n    Node* current = root;\n    for (char c : word) {\n        if (!current->next.count(c)) {\n            current->next[c] = createNode();\n        }\n        current = current->next[c];\n    }\n    current->ends.push_back({idx, cost});\n}\n\nvector<int> calculateMinCost(const string& target, Node* root, const vector<string>& words) {\n    int n = target.size();\n    vector<int> minCost(n + 1, INT_MAX);\n    minCost[0] = 0;\n\n    for (int start = 0; start < n; ++start) {\n        if (minCost[start] == INT_MAX) {\n            continue;\n        }\n\n        Node* currentNode = root;\n        for (int end = start; end < n; ++end) {\n            if (!currentNode->next.count(target[end])) {\n                break;\n            }\n            currentNode = currentNode->next[target[end]];\n            for (const auto& p : currentNode->ends) {\n                int wordLen = words[p.first].size();\n                if (start + wordLen <= n) {\n                    minCost[start + wordLen] = min(minCost[start + wordLen], minCost[start] + p.second);\n                }\n            }\n        }\n    }\n\n    return minCost;\n}\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n    Node* root = createNode();\n    for (int i = 0; i < words.size(); ++i) {\n        addWord(root, words[i], i, costs[i]);\n    }\n\n    vector<int> minCost = calculateMinCost(target, root, words);\n    return minCost[target.size()] == INT_MAX ? -1 : minCost[target.size()];\n}\n};",
    "submit_ts": "1720322616",
    "subm_id": "1312354621"
}