{
    "username": "waiting_you",
    "submission": "class LazySegmentTree:\n    __slots__ = 'n', 'height', 'size', 'initval', 'initlazy', 'op', 'apply', 'compose', 'tree', 'lazy'\n    def __init__(self, nums, initval, initlazy, op, apply, compose):\n        self.n = len(nums)\n        self.height = (self.n-1).bit_length()\n        self.size = 1 << self.height\n        self.initval = initval\n        self.initlazy = initlazy\n        self.op = op\n        self.apply = apply\n        self.compose = compose\n\n        self.tree = [initval for _ in range(2 * self.size)]\n        self.tree[self.size:self.size+self.n] = nums\n        for i in range(self.size-1, 0, -1):\n            self.pushup(i)\n        self.lazy = [initlazy for _ in range(self.size)]\n\n    def pushup(self, rt):\n        self.tree[rt] = self.op(self.tree[rt*2], self.tree[rt*2+1])\n\n    def pushdown(self, rt):\n        if self.lazy[rt] == self.initlazy: return\n        self.modify(rt*2, self.lazy[rt])\n        self.modify(rt*2+1, self.lazy[rt])\n        self.lazy[rt] = self.initlazy\n\n    def set(self, idx, val):\n        idx += self.size\n        for i in range(self.height, 0, -1):\n            self.pushdown(idx >> i)\n        self.tree[idx] = val\n        for i in range(1, self.height + 1):\n            self.pushup(idx >> i)\n\n    def update(self, left, right, val):\n        if left > right: return\n        left += self.size\n        right += self.size\n\n        for i in range(self.height, 0, -1):\n            if left >> i << i != left:\n                self.pushdown(left >> i)\n            if (right+1) >> i << i != right+1:\n                self.pushdown(right >> i)\n\n        l, r = left, right\n        while left <= right:\n            if left & 1:\n                self.modify(left, val)\n                left += 1\n            if not right & 1:\n                self.modify(right, val)\n                right -= 1\n            left >>= 1\n            right >>= 1\n\n        left, right = l, r\n        for i in range(1, self.height + 1):\n            if left >> i << i != left:\n                self.pushup(left >> i)\n            if (right+1) >> i << i != right+1:\n                self.pushup(right >> i)\n\n    def modify(self, rt, val):\n        self.tree[rt] = self.apply(val, self.tree[rt])\n        if rt < self.size:\n            self.lazy[rt] = self.compose(val, self.lazy[rt])\n\n    def get(self, idx):\n        idx += self.size\n        for i in range(self.height, 0, -1):\n            self.pushdown(idx >> i)\n        return self.tree[idx]\n\n    def query(self, left, right):\n        if left > right: return self.initval\n        left += self.size\n        right += self.size\n\n        for i in range(self.height, 0, -1):\n            if left >> i << i != left:\n                self.pushdown(left >> i)\n            if (right+1) >> i << i != right+1:\n                self.pushdown(right >> i)\n\n        lres, rres = self.initval, self.initval\n        while left <= right:\n            if left & 1:\n                lres = self.op(lres, self.tree[left])\n                left += 1\n            if not right & 1:\n                rres = self.op(self.tree[right], rres)\n                right -= 1\n            left >>= 1\n            right >>= 1\n\n        return self.op(lres, rres)\n\n    def all(self):\n        return self.tree[1]\n\n    def bisect_left(self, left, f):\n        left += self.size\n        lres = self.initval\n        for i in range(self.height, 0, -1):\n            self.pushdown(left >> i)\n\n        while True:\n            while not left & 1:\n                left >>= 1\n            if f(self.op(lres, self.tree[left])):\n                while left < self.size:\n                    self.pushdown(left)\n                    left *= 2\n                    if not f(self.op(lres, self.tree[left])):\n                        lres = self.op(lres, self.tree[left])\n                        left += 1\n                return left - self.size\n            if left & (left + 1) == 0:\n                return self.n\n            lres = self.op(lres, self.tree[left])\n            left += 1\n\n    def bisect_right(self, right, f):\n        right += self.size\n        rres = self.initval\n        for i in range(self.height, 0, -1):\n            self.pushdown(right >> i)\n\n        while True:\n            while right > 1 and right & 1:\n                right >>= 1\n            if f(self.op(self.tree[right], rres)):\n                while right < self.size:\n                    self.pushdown(right)\n                    right = 2 * right + 1\n                    if not f(self.op(self.tree[right], rres)):\n                        rres = self.op(self.tree[right], rres)\n                        right -= 1\n                return right - self.size\n            if right & (right - 1) == 0:\n                return -1\n            rres = self.op(self.tree[right], rres)\n            right -= 1\n\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        nums = [1] * (n - 1)  \n        seg_tree = LazySegmentTree(\n            nums,\n            initval=0,\n            initlazy=-1,\n            op=lambda x, y: x + y,\n            apply=lambda x, y: x if x != -1 else y, \n            compose=lambda x, y: x if x != -1 else y \n        )\n\n        results = []\n        for u, v in queries:\n            if u + 1 <= v - 1:\n                seg_tree.update(u, v - 2, 0)  \n            total_distance = seg_tree.query(0, n - 2) \n            results.append(total_distance)\n        \n        return results",
    "submit_ts": "1722742391",
    "subm_id": "552344332"
}