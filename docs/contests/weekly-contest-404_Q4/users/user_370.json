{
    "username": "yangxm",
    "submission": "using Pii = pair<int, int>;\n\nconstexpr int MAX = 100010;\nconstexpr int INF = 0x3F3F3F3F;\n\nstruct Tree {\n  vector<int> adj[MAX];\n  int dp[MAX][2], opt[MAX];\n  \n  void Reset(int n) {\n    for (int i = 0; i < n; ++i) {\n      vector<int>().swap(adj[i]);\n    }\n  }\n  \n  void AddEdge(int a, int b) {\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  \n  Pii DFS1(int x, int p) {\n    int v1 = 0, v2 = -INF;\n    for (int y : adj[x]) {\n      if (y != p) {\n        auto [c1, c2] = DFS1(y, x);\n        if (v1 < c1 + 1) {\n          v2 = v1;\n          v1 = c1 + 1;\n        } else {\n          v2 = max(v2, c1 + 1);\n        }\n      }\n    }\n    dp[x][0] = v1;\n    dp[x][1] = v2;\n    return make_pair(v1, v2);\n  }\n  \n  void DFS2(int x, int p, int c) {\n    opt[x] = max(dp[x][0], c + 1);\n    printf(\"x = %d, c = %d, opt = %d\\n\", x, c, opt[x]);\n    for (int y : adj[x]) {\n      if (y != p) {\n        int d = dp[x][0] == dp[y][0] + 1 ? dp[x][1] : dp[x][0];\n        DFS2(y, x, max(d, c + 1));\n      }\n    }\n  }\n} tr1, tr2;\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n      int n = edges1.size() + 1, m = edges2.size() + 1;\n      tr1.Reset(n);\n      tr2.Reset(m);\n      for (const auto& e : edges1) {\n        tr1.AddEdge(e[0], e[1]);\n      }\n      for (const auto& e : edges2) {\n        tr2.AddEdge(e[0], e[1]);\n      }\n      tr1.DFS1(0, -1);\n      tr1.DFS2(0, -1, -1);\n      tr2.DFS1(0, -1);\n      tr2.DFS2(0, -1, -1);\n      \n      int d1 = 0, d2 = 0;\n      int v1 = INF, v2 = INF;\n      for (int i = 0; i < n; ++i) {\n        d1 = max(d1, tr1.opt[i]);\n        v1 = min(v1, tr1.opt[i]);\n      }\n      for (int i = 0; i < m; ++i) {\n        d2 = max(d2, tr2.opt[i]);\n        v2 = min(v2, tr2.opt[i]);\n      }\n      int ret = max({d1, d2, v1 + v2 + 1});\n      return ret;\n    }\n};",
    "submit_ts": "1719718378",
    "subm_id": "1304415736"
}