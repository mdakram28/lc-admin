{
    "username": "XAXAEBATb",
    "submission": "/*\nAPI\nALL IN LONG\n\nconstruction - SegTreeChangeOne t(size, func) (func can be one of {\"max\", \"min\", \"sum\", \"gcd\"})\nadd(pos, val) - add val to a[pos] (1 - index)\ninit(pos, new_val) - set a[pos] = new_val (1 - index)\nDepends on func:\nsum(l, r)  - calc sum of elements with positions [l; r] (1 - index)\nmax(l, r)  - calc max of elements with positions [l; r] (1 - index)\nmin(l, r)  - calc min of elements with positions [l; r] (1 - index)\ngcd(l, r)  - calc gcd of elements with positions [l; r] (1 - index)\n*/\n\nstruct SegTreeChangeOne {\n    long long myGcd(long long a, long long b) {\n        if (a==-1) return b;\n        if (b==-1) return a;\n        return std::gcd(a,b);\n    }\n\n    SegTreeChangeOne(int sz, string function) {\n        localSz = sz;\n        t.resize(4 * sz + 5, -1);\n        func = function;\n    }\n    \n    long long merge(long long l1, long long r1) {\n        if (l1==-1) return r1;\n        if (r1==-1) return l1;\n        return l1&r1;\n    }\n\n    long long localMin (int v, int tl, int tr, int l, int r) {\n    \tif (l > r)\n    \t\treturn INF;\n    \tif (l == tl && r == tr)\n    \t\treturn t[v];\n    \tint tm = (tl + tr) / 2;\n    \treturn std::min(localMin (v*2, tl, tm, l, std::min(r,tm)), localMin (v*2+1, tm+1, tr, std::max(l,tm+1), r));\n    }\n\n    long long localMax (int v, int tl, int tr, int l, int r) {\n    \tif (l > r)\n    \t\treturn -INF;\n    \tif (l == tl && r == tr)\n    \t\treturn t[v];\n    \tint tm = (tl + tr) / 2;\n    \treturn std::max(localMax (v*2, tl, tm, l, std::min(r,tm)), localMax (v*2+1, tm+1, tr, std::max(l,tm+1), r));\n    }\n\n    int it = 0;\n\n    long long localSum (int v, int tl, int tr, int l, int r) {\n    \tif (l > r)\n    \t\treturn -1;\n    \tif (l == tl && r == tr)\n    \t\treturn t[v];\n    \tint tm = (tl + tr) / 2;\n        return merge(localSum (v*2, tl, tm, l, std::min(r,tm)), localSum (v*2+1, tm+1, tr, std::max(l,tm+1), r));\n    }\n\n    long long localGcd (int v, int tl, int tr, int l, int r) {\n    \tif (l > r)\n    \t\treturn -1;\n    \tif (l == tl && r == tr)\n    \t\treturn t[v];\n    \tint tm = (tl + tr) / 2;\n    \treturn myGcd(localGcd (v*2, tl, tm, l, std::min(r,tm)), localGcd (v*2+1, tm+1, tr, std::max(l,tm+1), r));\n    }\n\n    void localAdd (int v, int tl, int tr, int pos, long long val) {\n    \tif (tl == tr)\n    \t\tt[v] += val;\n    \telse {\n    \t\tint tm = (tl + tr) / 2;\n    \t\tif (pos <= tm)\n    \t\t\tlocalAdd (v*2, tl, tm, pos, val);\n    \t\telse\n    \t\t\tlocalAdd (v*2+1, tm+1, tr, pos, val);\n    \t\tif (func == \"sum\") {\n    \t\t    t[v] = merge(t[v*2], t[v*2+1]);\n    \t\t}\n    \t\tif (func == \"max\") {\n    \t\t    t[v] = std::max(t[v*2], t[v*2+1]);\n    \t\t}\n    \t\tif (func == \"min\") {\n    \t\t    t[v] = std::min(t[v*2], t[v*2+1]);\n    \t\t}\n    \t\tif (func == \"gcd\") {\n    \t\t    t[v] = myGcd(t[v*2], t[v*2+1]);\n    \t\t}\n    \t}\n    }\n\n    void localInit (int v, int tl, int tr, int pos, long long new_val) {\n    \tif (tl == tr)\n    \t\tt[v] = new_val;\n    \telse {\n    \t\tint tm = (tl + tr) / 2;\n    \t\tif (pos <= tm)\n    \t\t\tlocalInit (v*2, tl, tm, pos, new_val);\n    \t\telse\n    \t\t\tlocalInit (v*2+1, tm+1, tr, pos, new_val);\n    \t\tif (func == \"sum\") {\n    \t\t    t[v] = merge(t[v*2], t[v*2+1]);\n    \t\t}\n    \t\tif (func == \"max\") {\n    \t\t    t[v] = std::max(t[v*2], t[v*2+1]);\n    \t\t}\n    \t\tif (func == \"min\") {\n    \t\t    t[v] = std::min(t[v*2], t[v*2+1]);\n    \t\t}\n    \t\tif (func == \"gcd\") {\n    \t\t    t[v] = myGcd(t[v*2], t[v*2+1]);\n    \t\t}\n    \t}\n    }\n\n\n\n    long long min(int l, int r) {\n        return localMin(1, 1, localSz, l,r);\n    }\n\n    long long max(int l, int r) {\n        return localMax(1, 1, localSz, l,r);\n    }\n\n    long long sum(int l, int r) {\n        return localSum(1, 1, localSz, l,r);\n    }\n\n    long long gcd(int l, int r) {\n        return localGcd(1, 1, localSz, l,r);\n    }\n\n    void add(int pos, long long val) {\n        localAdd(1, 1, localSz, pos, val);\n    }\n\n    void init(int pos, long long new_val) {\n        localInit(1, 1, localSz, pos, new_val);\n    }\n\n    vector <long long> t;\n    int localSz;\n    const long long INF = 9223372036000000000LL;\n    string func;\n};\n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        int a = nums.size();\n        SegTreeChangeOne t(a+1, \"sum\");\n        for (int i=0;i<nums.size();i++) {\n            t.init(i+1, nums[i]);\n        }\n        //cout<<t.sum(1,a);\n        int best = abs(k-nums[0]);\n        int ans=nums[0];\n        for (int i=0;i<a;i++) {\n            int l =i;\n            int r=a-1;\n            if (nums[i]<k) {\n                if (abs(k-nums[i])<best) {\n                    best = abs(k-nums[i]);\n                }\n                continue;\n            }\n            while (r-l) {\n                int mid=(l+r)/2; if (mid==l) mid++;\n                if (t.sum(i+1, mid+1)<k) r=mid-1; else l=mid;\n            }\n            int ans1 = t.sum(i+1, l+1);\n            if (abs(k-ans1)<best) {\n                best=abs(k-ans1);\n            }\n            if (l+2<=a) {\n                ans1=t.sum(i+1, l+2);\n                if (abs(k-ans1)<best) {\n                best=abs(k-ans1);\n            }\n            }\n        }\n        return best;\n    }\n};",
    "submit_ts": "1717297250",
    "subm_id": "1274735800"
}