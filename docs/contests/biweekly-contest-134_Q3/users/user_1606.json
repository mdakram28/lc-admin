{
    "username": "ipadcoder",
    "submission": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numberOfAlternatingGroups(vector<int>& colors, int k) {\n        int n = colors.size();\n        \n        // Create the string representation of colors\n        string s;\n        for (int i = 0; i < n; ++i) {\n            s += to_string(colors[i]);\n        }\n        \n        // Make the string circular by adding k-1 characters to the beginning and end\n        string front = s.substr(0, k-1);\n        // string back = s.substr(n - k+1 , k-1);\n        \n        // Construct the circular string\n        s =   s + front;\n        cout<<s<<endl;\n        // Generate the alternating patterns\n        string pattern1, pattern2;\n        for (int i = 0; i < k; ++i) {\n            if (i % 2 == 0) {\n                pattern1 += '0';\n                pattern2 += '1';\n            } else {\n                pattern1 += '1';\n                pattern2 += '0';\n            }\n        }\n        \n        // Apply KMP algorithm to find occurrences\n        int count = 0;\n        \n        // Find pattern1 occurrences\n        count += countOccurrences(s, pattern1);\n        \n        // Find pattern2 occurrences\n        count += countOccurrences(s, pattern2);\n        \n        return count;\n    }\n    \nprivate:\n    // Function to count occurrences of pattern in text using KMP algorithm\n    int countOccurrences(const string& text, const string& pattern) {\n        int n = text.size();\n        int m = pattern.size();\n        \n        // Build KMP prefix table (lps array)\n        vector<int> lps(m, 0);\n        int j = 0; // length of previous longest prefix suffix\n        for (int i = 1; i < m; ++i) {\n            while (j > 0 && pattern[i] != pattern[j]) {\n                j = lps[j - 1];\n            }\n            if (pattern[i] == pattern[j]) {\n                lps[i] = ++j;\n            } else {\n                lps[i] = 0;\n            }\n        }\n        \n        // Perform pattern matching\n        int count = 0;\n        j = 0; // index for pattern[]\n        for (int i = 0; i < n; ++i) {\n            while (j > 0 && text[i] != pattern[j]) {\n                j = lps[j - 1];\n            }\n            if (text[i] == pattern[j]) {\n                ++j;\n            }\n            if (j == m) {\n                ++count;\n                j = lps[j - 1];\n            }\n        }\n        \n        return count;\n    }\n};\n",
    "submit_ts": "1720279157",
    "subm_id": "1311739800"
}