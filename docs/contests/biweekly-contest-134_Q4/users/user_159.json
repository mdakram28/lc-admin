{
    "username": "trchen",
    "submission": "// Change \"Ofast\" to \"O3\" to disable fast-math for geometry problems\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace impl {\n\ntemplate <typename DataType, class Operator, bool LazyAssignment>\nstruct LazyAssignmentComponent {};\n\ntemplate <typename DataType, class Operator>\nstruct LazyAssignmentComponent<DataType, Operator, true> {\n  DataType lazy_assignment = Operator::Identity();\n};\n\ntemplate <typename DataType, class Operator, bool LazyIncrement>\nstruct LazyIncrementComponent {};\n\ntemplate <typename DataType, class Operator>\nstruct LazyIncrementComponent<DataType, Operator, true> {\n  DataType lazy_increment = Operator::Identity();\n};\n\ntemplate <bool Persistent>\nstruct PersistentComponent {};\n\ntemplate <>\nstruct PersistentComponent<true> {\n  int left_child;\n  int right_child;\n};\n\ntemplate <typename DataType, class Operator, bool LazyAssignment, bool LazyIncrement,\n          bool Persistent>\nstruct SegmentTreeNode : public LazyAssignmentComponent<DataType, Operator, LazyAssignment>,\n                         public LazyIncrementComponent<DataType, Operator, LazyIncrement>,\n                         public PersistentComponent<Persistent> {\n  DataType value;\n};\n\n}  // namespace impl\n\ntemplate <typename DataType, class Operator, bool LazyAssignment = false,\n          bool LazyIncrement = false, bool Persistent = false>\nclass SegmentTree {\n  using Node = impl::SegmentTreeNode<DataType, Operator, LazyAssignment, LazyIncrement, Persistent>;\n\n public:\n  template <class RawContainer>\n  inline void Build(const RawContainer& raw_container) noexcept\n    requires (!Persistent)\n  {\n    data_size_ = static_cast<int>(raw_container.size());\n    tree_.resize(4 * data_size_);\n    BuildRecursive(raw_container, 1, 0, data_size_ - 1);\n  }\n\n  template <class RawContainer>\n  inline int Build(const RawContainer& raw_container, int number_of_future_operations) noexcept\n    requires (Persistent)\n  {\n    data_size_ = static_cast<int>(raw_container.size());\n    int size = data_size_;\n    int height = 1;\n    while (size > 1) {\n      height++;\n      size /= 2;\n    }\n    tree_.resize(2 * data_size_ + 4 * height * number_of_future_operations);\n    next_valid_index_ = 1;\n    BuildRecursive(raw_container, 0, 0, data_size_ - 1);\n    return 0;\n  }\n\n  inline DataType Query(int left, int right) noexcept\n    requires (!Persistent)\n  {\n    if (left > right) {\n      return Operator::Identity();\n    }\n    return QueryRecursive(1, 0, data_size_ - 1, left, right);\n  }\n\n  inline std::pair<DataType, int> Query(int left, int right, int root) noexcept\n    requires (Persistent)\n  {\n    if (left > right) {\n      return { Operator::Identity(), root };\n    }\n    int new_root;\n    if constexpr (LazyAssignment || LazyIncrement) {\n      new_root = CopyRoot(root);\n    } else {\n      new_root = root;\n    }\n    return { QueryRecursive(new_root, 0, data_size_ - 1, left, right), new_root };\n  }\n\n  inline void Assign(int position, const DataType& assignment) noexcept\n    requires (!Persistent)\n  {\n    AssignRecursive(1, 0, data_size_ - 1, position, assignment);\n  }\n\n  inline int Assign(int position, const DataType& assignment, int root) noexcept\n    requires (Persistent)\n  {\n    const int new_root = CopyRoot(root);\n    AssignRecursive(new_root, 0, data_size_ - 1, position, assignment);\n    return new_root;\n  }\n\n  inline void RangeAssign(int left, int right, const DataType& assignment) noexcept\n    requires (LazyAssignment && !Persistent)\n  {\n    if (left > right) {\n      return;\n    }\n    RangeAssignRecursive(1, 0, data_size_ - 1, left, right, assignment);\n  }\n\n  inline int RangeAssign(int left, int right, const DataType& assignment, int root) noexcept\n    requires (LazyAssignment && Persistent)\n  {\n    const int new_root = CopyRoot(root);\n    if (left <= right) {\n      RangeAssignRecursive(new_root, 0, data_size_ - 1, left, right, assignment);\n    }\n    return new_root;\n  }\n\n  inline void Increase(int position, const DataType& increment) noexcept\n    requires (!Persistent)\n  {\n    IncreaseRecursive(1, 0, data_size_ - 1, position, increment);\n  }\n\n  inline int Increase(int position, const DataType& increment, int root) noexcept\n    requires (Persistent)\n  {\n    const int new_root = CopyRoot(root);\n    IncreaseRecursive(new_root, 0, data_size_ - 1, position, increment);\n    return new_root;\n  }\n\n  inline void RangeIncrease(int left, int right, const DataType& increment) noexcept\n    requires (LazyIncrement && !Persistent)\n  {\n    if (left > right) {\n      return;\n    }\n    RangeIncreaseRecursive(1, 0, data_size_ - 1, left, right, increment);\n  }\n\n  inline int RangeIncrease(int left, int right, const DataType& increment, int root) noexcept\n    requires (LazyIncrement && Persistent)\n  {\n    const int new_root = CopyRoot(root);\n    if (left <= right) {\n      RangeIncreaseRecursive(new_root, 0, data_size_ - 1, left, right, increment);\n    }\n    return new_root;\n  }\n\n  template <typename Predicate>\n  inline int FindFirstRightIndex(int left_boundary, const Predicate& predicate) noexcept\n    requires (!Persistent)\n  {\n    DataType cumulative_value = Operator::Identity();\n    return FindFirstRightIndexRecursive(1, 0, data_size_ - 1, left_boundary, predicate,\n                                        cumulative_value);\n  }\n\n  template <typename Predicate>\n  inline std::pair<int, int> FindFirstRightIndex(int left_boundary, const Predicate& predicate,\n                                                 int root) noexcept\n    requires (Persistent)\n  {\n    int new_root;\n    if constexpr (LazyAssignment || LazyIncrement) {\n      new_root = CopyRoot(root);\n    } else {\n      new_root = root;\n    }\n    DataType cumulative_value = Operator::Identity();\n    return { FindFirstRightIndexRecursive(new_root, 0, data_size_ - 1, left_boundary, predicate,\n                                          cumulative_value),\n             new_root };\n  }\n\n  template <typename Predicate>\n  inline int FindFirstLeftIndex(int right_boundary, const Predicate& predicate) noexcept\n    requires (!Persistent)\n  {\n    DataType cumulative_value = Operator::Identity();\n    return FindFirstLeftIndexRecursive(1, 0, data_size_ - 1, right_boundary, predicate,\n                                       cumulative_value);\n  }\n\n  template <typename Predicate>\n  inline std::pair<int, int> FindFirstLeftIndex(int right_boundary, const Predicate& predicate,\n                                                int root) noexcept\n    requires (Persistent)\n  {\n    int new_root;\n    if constexpr (LazyAssignment || LazyIncrement) {\n      new_root = CopyRoot(root);\n    } else {\n      new_root = root;\n    }\n    DataType cumulative_value = Operator::Identity();\n    return { FindFirstLeftIndexRecursive(new_root, 0, data_size_ - 1, right_boundary, predicate,\n                                         cumulative_value),\n             new_root };\n  }\n\n  inline int RangeCopy(int root, int old_root, int left, int right) noexcept\n    requires (Persistent)\n  {\n    const int new_root = CopyRoot(root);\n    if (left <= right) {\n      RangeCopyRecursive(new_root, old_root, 0, data_size_ - 1, left, right);\n    }\n    return new_root;\n  }\n\n private:\n  template <class RawContainer>\n  inline void BuildRecursive(const RawContainer& raw_container, int vertex, int segment_left,\n                             int segment_right) noexcept {\n    if constexpr (LazyAssignment) {\n      tree_[vertex].lazy_assignment = Operator::Identity();\n    }\n    if constexpr (LazyIncrement) {\n      tree_[vertex].lazy_increment = Operator::Identity();\n    }\n    if (segment_left == segment_right) {\n      tree_[vertex].value = raw_container[segment_left];\n    } else {\n      if constexpr (Persistent) {\n        tree_[vertex].left_child = next_valid_index_;\n        next_valid_index_++;\n        tree_[vertex].right_child = next_valid_index_;\n        next_valid_index_++;\n      }\n      const int segment_middle = (segment_left + segment_right) / 2;\n      BuildRecursive(raw_container, LeftChild(vertex), segment_left, segment_middle);\n      BuildRecursive(raw_container, RightChild(vertex), segment_middle + 1, segment_right);\n      PushUp(vertex);\n    }\n  }\n\n  inline DataType QueryRecursive(int vertex, int segment_left, int segment_right, int left,\n                                 int right) noexcept {\n    if (segment_left == left && segment_right == right) {\n      return tree_[vertex].value;\n    }\n    PushDown(vertex, segment_left, segment_right);\n    const int segment_middle = (segment_left + segment_right) / 2;\n    if (right <= segment_middle) {\n      return QueryRecursive(LeftChild(vertex), segment_left, segment_middle, left, right);\n    }\n    if (left >= segment_middle + 1) {\n      return QueryRecursive(RightChild(vertex), segment_middle + 1, segment_right, left, right);\n    }\n    return Operator::Combine(\n        QueryRecursive(LeftChild(vertex), segment_left, segment_middle, left, segment_middle),\n        QueryRecursive(RightChild(vertex), segment_middle + 1, segment_right, segment_middle + 1,\n                       right));\n  }\n\n  inline void AssignRecursive(int vertex, int segment_left, int segment_right, int position,\n                              const DataType& assignment) noexcept {\n    if (segment_left == segment_right) {\n      tree_[vertex].value = assignment;\n      return;\n    }\n    PushDown(vertex, segment_left, segment_right);\n    const int segment_middle = (segment_left + segment_right) / 2;\n    if (position <= segment_middle) {\n      CopyLeftChild<false>(vertex);\n      AssignRecursive(LeftChild(vertex), segment_left, segment_middle, position, assignment);\n    } else {\n      CopyRightChild<false>(vertex);\n      AssignRecursive(RightChild(vertex), segment_middle + 1, segment_right, position, assignment);\n    }\n    PushUp(vertex);\n  }\n\n  inline void RangeAssignRecursive(int vertex, int segment_left, int segment_right, int left,\n                                   int right, const DataType& assignment) noexcept {\n    if (segment_left == left && segment_right == right) {\n      ReceiveLazyAssignment(vertex, segment_left, segment_right, assignment);\n      return;\n    }\n    PushDown(vertex, segment_left, segment_right);\n    const int segment_middle = (segment_left + segment_right) / 2;\n    if (right <= segment_middle) {\n      CopyLeftChild<false>(vertex);\n      RangeAssignRecursive(LeftChild(vertex), segment_left, segment_middle, left, right,\n                           assignment);\n    } else if (left >= segment_middle + 1) {\n      CopyRightChild<false>(vertex);\n      RangeAssignRecursive(RightChild(vertex), segment_middle + 1, segment_right, left, right,\n                           assignment);\n    } else {\n      CopyLeftChild<false>(vertex);\n      CopyRightChild<false>(vertex);\n      RangeAssignRecursive(LeftChild(vertex), segment_left, segment_middle, left, segment_middle,\n                           assignment);\n      RangeAssignRecursive(RightChild(vertex), segment_middle + 1, segment_right,\n                           segment_middle + 1, right, assignment);\n    }\n    PushUp(vertex);\n  }\n\n  inline void IncreaseRecursive(int vertex, int segment_left, int segment_right, int position,\n                                const DataType& increment) noexcept {\n    if (segment_left == segment_right) {\n      tree_[vertex].value = Operator::Combine(tree_[vertex].value, increment);\n      return;\n    }\n    PushDown(vertex, segment_left, segment_right);\n    const int segment_middle = (segment_left + segment_right) / 2;\n    if (position <= segment_middle) {\n      CopyLeftChild<false>(vertex);\n      IncreaseRecursive(LeftChild(vertex), segment_left, segment_middle, position, increment);\n    } else {\n      CopyRightChild<false>(vertex);\n      IncreaseRecursive(RightChild(vertex), segment_middle + 1, segment_right, position, increment);\n    }\n    PushUp(vertex);\n  }\n\n  inline void RangeIncreaseRecursive(int vertex, int segment_left, int segment_right, int left,\n                                     int right, const DataType& increment) noexcept {\n    if (segment_left == left && segment_right == right) {\n      ReceiveLazyIncrement(vertex, segment_left, segment_right, increment);\n      return;\n    }\n    PushDown(vertex, segment_left, segment_right);\n    const int segment_middle = (segment_left + segment_right) / 2;\n    if (right <= segment_middle) {\n      CopyLeftChild<false>(vertex);\n      RangeIncreaseRecursive(LeftChild(vertex), segment_left, segment_middle, left, right,\n                             increment);\n    } else if (left >= segment_middle + 1) {\n      CopyRightChild<false>(vertex);\n      RangeIncreaseRecursive(RightChild(vertex), segment_middle + 1, segment_right, left, right,\n                             increment);\n    } else {\n      CopyLeftChild<false>(vertex);\n      CopyRightChild<false>(vertex);\n      RangeIncreaseRecursive(LeftChild(vertex), segment_left, segment_middle, left, segment_middle,\n                             increment);\n      RangeIncreaseRecursive(RightChild(vertex), segment_middle + 1, segment_right,\n                             segment_middle + 1, right, increment);\n    }\n    PushUp(vertex);\n  }\n\n  template <typename Predicate>\n  inline int FindFirstRightIndexRecursive(int vertex, int segment_left, int segment_right,\n                                          int left_boundary, const Predicate& predicate,\n                                          DataType& cumulative_value) noexcept {\n    if (segment_left == left_boundary) {\n      const DataType combined = Operator::Combine(cumulative_value, tree_[vertex].value);\n      if (!predicate(combined)) {\n        cumulative_value = combined;\n        return -1;\n      }\n      if (segment_left == segment_right) {\n        return segment_left;\n      }\n    }\n    PushDown(vertex, segment_left, segment_right);\n    const int segment_middle = (segment_left + segment_right) / 2;\n    if (left_boundary <= segment_middle) {\n      const int result_left =\n          FindFirstRightIndexRecursive(LeftChild(vertex), segment_left, segment_middle,\n                                       left_boundary, predicate, cumulative_value);\n      if (result_left != -1) {\n        return result_left;\n      }\n      return FindFirstRightIndexRecursive(RightChild(vertex), segment_middle + 1, segment_right,\n                                          segment_middle + 1, predicate, cumulative_value);\n    }\n    return FindFirstRightIndexRecursive(RightChild(vertex), segment_middle + 1, segment_right,\n                                        left_boundary, predicate, cumulative_value);\n  }\n\n  template <typename Predicate>\n  inline int FindFirstLeftIndexRecursive(int vertex, int segment_left, int segment_right,\n                                         int right_boundary, const Predicate& predicate,\n                                         DataType& cumulative_value) noexcept {\n    if (segment_right == right_boundary) {\n      const DataType combined = Operator::Combine(tree_[vertex].value, cumulative_value);\n      if (!predicate(combined)) {\n        cumulative_value = combined;\n        return -1;\n      }\n      if (segment_left == segment_right) {\n        return segment_left;\n      }\n    }\n    PushDown(vertex, segment_left, segment_right);\n    const int segment_middle = (segment_left + segment_right) / 2;\n    if (right_boundary >= segment_middle + 1) {\n      const int result_right =\n          FindFirstLeftIndexRecursive(RightChild(vertex), segment_middle + 1, segment_right,\n                                      right_boundary, predicate, cumulative_value);\n      if (result_right != -1) {\n        return result_right;\n      }\n      return FindFirstLeftIndexRecursive(LeftChild(vertex), segment_left, segment_middle,\n                                         segment_middle, predicate, cumulative_value);\n    }\n    return FindFirstLeftIndexRecursive(LeftChild(vertex), segment_left, segment_middle,\n                                       right_boundary, predicate, cumulative_value);\n  }\n\n  inline void RangeCopyRecursive(int vertex, int old_vertex, int segment_left, int segment_right,\n                                 int left, int right) noexcept {\n    if (segment_left == left && segment_right == right) {\n      tree_[vertex] = tree_[old_vertex];\n      return;\n    }\n    PushDown(old_vertex, segment_left, segment_right);\n    PushDown(vertex, segment_left, segment_right);\n    const int segment_middle = (segment_left + segment_right) / 2;\n    if (right <= segment_middle) {\n      CopyLeftChild<false>(vertex);\n      RangeCopyRecursive(LeftChild(vertex), LeftChild(old_vertex), segment_left, segment_middle,\n                         left, right);\n    } else if (left >= segment_middle + 1) {\n      CopyRightChild<false>(vertex);\n      RangeCopyRecursive(RightChild(vertex), RightChild(old_vertex), segment_middle + 1,\n                         segment_right, left, right);\n    } else {\n      CopyLeftChild<false>(vertex);\n      CopyRightChild<false>(vertex);\n      RangeCopyRecursive(LeftChild(vertex), LeftChild(old_vertex), segment_left, segment_middle,\n                         left, segment_middle);\n      RangeCopyRecursive(RightChild(vertex), RightChild(old_vertex), segment_middle + 1,\n                         segment_right, segment_middle + 1, right);\n    }\n    PushUp(vertex);\n  }\n\n  [[nodiscard]] inline int LeftChild(int vertex) const noexcept {\n    if constexpr (Persistent) {\n      return tree_[vertex].left_child;\n    } else {\n      return 2 * vertex;\n    }\n  }\n\n  [[nodiscard]] inline int RightChild(int vertex) const noexcept {\n    if constexpr (Persistent) {\n      return tree_[vertex].right_child;\n    } else {\n      return 2 * vertex + 1;\n    }\n  }\n\n  [[nodiscard]] inline int CopyRoot(int root) noexcept {\n    const int new_root = next_valid_index_;\n    tree_[new_root] = tree_[root];\n    next_valid_index_++;\n    return new_root;\n  }\n\n  template <bool BeforePushDown>\n  inline void CopyLeftChild(int vertex) noexcept {\n    if constexpr (Persistent && (BeforePushDown == (LazyAssignment || LazyIncrement))) {\n      tree_[next_valid_index_] = tree_[LeftChild(vertex)];\n      tree_[vertex].left_child = next_valid_index_;\n      next_valid_index_++;\n    }\n  }\n\n  template <bool BeforePushDown>\n  inline void CopyRightChild(int vertex) noexcept {\n    if constexpr (Persistent && (BeforePushDown == (LazyAssignment || LazyIncrement))) {\n      tree_[next_valid_index_] = tree_[RightChild(vertex)];\n      tree_[vertex].right_child = next_valid_index_;\n      next_valid_index_++;\n    }\n  }\n\n  inline void PushUp(int vertex) noexcept {\n    tree_[vertex].value =\n        Operator::Combine(tree_[LeftChild(vertex)].value, tree_[RightChild(vertex)].value);\n  }\n\n  inline void PushDown(int vertex, int segment_left, int segment_right) noexcept {\n    if constexpr (!LazyAssignment && !LazyIncrement) {\n      return;\n    } else {\n      CopyLeftChild<true>(vertex);\n      CopyRightChild<true>(vertex);\n      const int segment_middle = (segment_left + segment_right) / 2;\n      if constexpr (LazyAssignment) {\n        if (tree_[vertex].lazy_assignment != Operator::Identity()) {\n          ReceiveLazyAssignment(LeftChild(vertex), segment_left, segment_middle,\n                                tree_[vertex].lazy_assignment);\n          ReceiveLazyAssignment(RightChild(vertex), segment_middle + 1, segment_right,\n                                tree_[vertex].lazy_assignment);\n          tree_[vertex].lazy_assignment = Operator::Identity();\n          return;\n        }\n      }\n      if constexpr (LazyIncrement) {\n        if (tree_[vertex].lazy_increment != Operator::Identity()) {\n          ReceiveLazyIncrement(LeftChild(vertex), segment_left, segment_middle,\n                               tree_[vertex].lazy_increment);\n          ReceiveLazyIncrement(RightChild(vertex), segment_middle + 1, segment_right,\n                               tree_[vertex].lazy_increment);\n          tree_[vertex].lazy_increment = Operator::Identity();\n        }\n      }\n    }\n  }\n\n  inline void ReceiveLazyAssignment(int vertex, int segment_left, int segment_right,\n                                    const DataType& lazy_assignment) noexcept {\n    tree_[vertex].lazy_assignment = lazy_assignment;\n    tree_[vertex].value =\n        Operator::CombineMultiple(lazy_assignment, segment_right - segment_left + 1);\n    if constexpr (LazyIncrement) {\n      tree_[vertex].lazy_increment = Operator::Identity();\n    }\n  }\n\n  inline void ReceiveLazyIncrement(int vertex, int segment_left, int segment_right,\n                                   const DataType& lazy_increment) noexcept {\n    if constexpr (LazyAssignment) {\n      if (tree_[vertex].lazy_assignment == Operator::Identity()) {\n        tree_[vertex].lazy_increment =\n            Operator::Combine(tree_[vertex].lazy_increment, lazy_increment);\n      } else {\n        tree_[vertex].lazy_assignment =\n            Operator::Combine(tree_[vertex].lazy_assignment, lazy_increment);\n        tree_[vertex].lazy_increment = Operator::Identity();\n      }\n    } else {\n      tree_[vertex].lazy_increment =\n          Operator::Combine(tree_[vertex].lazy_increment, lazy_increment);\n    }\n    tree_[vertex].value = Operator::IncrementMultiple(tree_[vertex].value, lazy_increment,\n                                                      segment_right - segment_left + 1);\n  }\n\n  int next_valid_index_{};\n  int data_size_{};\n  std::vector<Node> tree_{};\n};\n\nstruct OperatorAnd {\n  static int Combine(int a, int b) {\n    return a & b;\n  }\n\n  static int Identity() {\n    return numeric_limits<int>::max();\n  }\n};\n\nclass Solution {\n public:\n  long long countSubarrays(vector<int>& nums, int k) {\n    int n = nums.size();\n    SegmentTree<int, OperatorAnd> tree;\n    tree.Build(nums);\n    auto Compare1 = [&](int a) -> bool {\n      return (k & a) == a;\n    };\n    auto Compare2 = [&](int a) -> bool {\n      return ((k & a) == a) && a != k;\n    };\n    long long ret = 0;\n    for (int i = 0; i < n; ++i) {\n      int l = tree.FindFirstRightIndex(i, Compare1);\n      if (l == -1) {\n        l = n;\n      }\n      int r = tree.FindFirstRightIndex(i, Compare2);\n      if (r == -1) {\n        r = n;\n      }\n      ret += r - l;\n      //cout << i << ' ' << l << ' ' << r << endl;\n    }\n    return ret;\n  }\n};",
    "submit_ts": "1720278676",
    "subm_id": "1311719488"
}