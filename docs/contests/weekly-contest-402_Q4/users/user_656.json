{
    "username": "FreeYourMind",
    "submission": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\n\n\"\"\"\nA peak in an array arr is an element that is greater than its previous and next element in arr.\n\nYou are given an integer array nums and a 2D integer array queries.\n\nYou have to process queries of two types:\n\n * queries[i] = [1, li, ri], determine the count of peak elements in the subarray nums[li..ri].\n * queries[i] = [2, indexi, vali], change nums[indexi] to vali.\n\nReturn an array answer containing the results of the queries of the first type in order.\n\nNotes:\n\n * The first and the last element of an array or a subarray cannot be a peak.\n\n \n\nExample 1:\n\nInput: nums = [3,1,4,2,5], queries = [[2,3,4],[1,0,4]]\n\nOutput: [0]\n\nExplanation:\n\nFirst query: We change nums[3] to 4 and nums becomes [3,1,4,4,5].\n\nSecond query: The number of peaks in the [3,1,4,4,5] is 0.\n\nExample 2:\n\nInput: nums = [4,1,4,2,1,5], queries = [[2,2,4],[1,0,2],[1,0,4]]\n\nOutput: [0,1]\n\nExplanation:\n\nFirst query: nums[2] should become 4, but it is already set to 4.\n\nSecond query: The number of peaks in the [4,1,4] is 0.\n\nThird query: The second 4 is a peak in the [4,1,4,2,1].\n\n \n\nConstraints:\n\n * 3 <= nums.length <= 105\n * 1 <= nums[i] <= 105\n * 1 <= queries.length <= 105\n * queries[i][0] == 1 or queries[i][0] == 2\n * For all i that:\n   * queries[i][0] == 1: 0 <= queries[i][1] <= queries[i][2] <= nums.length - 1\n   * queries[i][0] == 2: 0 <= queries[i][1] <= nums.length - 1, 1 <= queries[i][2] <= 105\n\"\"\"\n\nclass SegmentTree():\n    __slots__ = ['n', 'oper', 'e', 'log', 'size', 'data']\n\n    def __init__(self, n, oper, e):\n        self.n = n\n        self.oper = oper\n        self.e = e\n        self.log = (n - 1).bit_length()\n        self.size = 1 << self.log\n        self.data = [e] * (2 * self.size)\n\n    def _update(self, k):\n        self.data[k] = self.oper(self.data[2 * k], self.data[2 * k + 1])\n\n    def build(self, arr):\n        # assert len(arr) <= self.n\n        for i in range(self.n):\n            self.data[self.size + i] = arr[i]\n        for i in range(self.size - 1, 0, -1):\n            self._update(i)\n\n    def set(self, p, x):\n        # assert 0 <= p < self.n\n        p += self.size\n        self.data[p] = x\n        for i in range(self.log):\n            p >>= 1\n            self._update(p)\n\n    def get(self, p):\n        # assert 0 <= p < self.n\n        return self.data[p + self.size]\n\n    def prod(self, l, r):\n        # assert 0 <= l <= r <= self.n\n        sml = smr = self.e\n        l += self.size\n        r += self.size\n        while l < r:\n            if l & 1:\n                sml = self.oper(sml, self.data[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                smr = self.oper(self.data[r], smr)\n            l >>= 1\n            r >>= 1\n        return self.oper(sml, smr)\n\n    def all_prod(self):\n        return self.data[1]\n\n    def max_right(self, l, f):\n        # assert 0 <= l <= self.n\n        # assert f(self.)\n        if l == self.n: return self.n\n        l += self.size\n        sm = self.e\n        while True:\n            while l % 2 == 0: l >>= 1\n            if not f(self.oper(sm, self.data[l])):\n                while l < self.size:\n                    l = 2 * l\n                    if f(self.oper(sm, self.data[l])):\n                        sm = self.oper(sm, self.data[l])\n                        l += 1\n                return l - self.size\n            sm = self.oper(sm, self.data[l])\n            l += 1\n            if (l & -l) == l: break\n        return self.n\n\n    def min_left(self, r, f):\n        # assert 0 <= r <= self.n\n        # assert f(self.)\n        if r == 0: return 0\n        r += self.size\n        sm = self.e\n        while True:\n            r -= 1\n            while r > 1 and (r % 2): r >>= 1\n            if not f(self.oper(self.data[r], sm)):\n                while r < self.size:\n                    r = 2 * r + 1\n                    if f(self.oper(self.data[r], sm)):\n                        sm = self.oper(self.data[r], sm)\n                        r -= 1\n                return r + 1 - self.size\n            sm = self.oper(self.data[r], sm)\n            if (r & -r) == r: break\n        return 0\n\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        A = [0] * n\n        for i in range(1, n - 1):\n            if nums[i - 1] < nums[i] > nums[i + 1]:\n                A[i] = 1\n        st = SegmentTree(n, add, 0)\n        st.build(A)\n        \n        res = []\n        \n        for t, a, b in queries:\n            if t == 1:\n                res.append(st.prod(a + 1, b))\n            else:\n                if a > 1:\n                    pre = nums[a - 2] < nums[a - 1] > nums[a]\n                    cur = nums[a - 2] < nums[a - 1] > b\n                    if pre != cur:\n                        st.set(a - 1, cur)\n                if a > 0 and a < n - 1:\n                    pre = nums[a - 1] < nums[a] > nums[a + 1]\n                    cur = nums[a - 1] < b > nums[a + 1]\n                    if pre != cur:\n                        st.set(a, cur)\n                if a < n - 2:\n                    pre = nums[a] < nums[a + 1] > nums[a + 2]\n                    cur = b < nums[a + 1] > nums[a + 2]\n                    if pre != cur:\n                        st.set(a + 1, cur)\n                nums[a] = b\n        return res\n\n# testcases = [\n#     [],\n#     # [],\n# ]\n\n# s = Solution()\n# func_name = dir(s)[-1]\n# func = getattr(s, func_name)\n\n# for args in testcases:\n#     print(func(*args))",
    "submit_ts": 1718507552.0
}