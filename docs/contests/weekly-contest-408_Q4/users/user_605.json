{
    "username": "gandip_6355",
    "submission": "class Solution {\npublic:\n       bool isPrime(int n)\n{\n    \n    if (n <= 1)\n        return false;\n\n    \n    for (int i = 2; i <= n / 2; i++)\n        if (n % i == 0)\n            return false;\n\n    return true;\n}\n    int calculateSum(int n)\n{\n    if (n <= 0)\n       return 0;\n \n    int fibo[n+1];\n    fibo[0] = 0, fibo[1] = 1;\n \n    // Initialize result\n    int sum = fibo[0] + fibo[1];\n \n    // Add remaining terms\n    for (int i=2; i<=n; i++)\n    {\n        fibo[i] = fibo[i-1]+fibo[i-2];\n        sum += fibo[i];\n    }\n \n    return sum;\n}\n    int bfs(vector<vector<int>> &gra, int start, int target1, int target2, int nodes) {\n    queue<int> q;\n    vector<int> visited(nodes + 4, 0);\n    q.push(start);\n    visited[start] = 1;\n    \n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : gra[u]) {\n            if (!visited[v]) {\n                q.push(v);\n                visited[v] = 1;\n            }\n        }\n    }\n    return visited[target1] || visited[target2];\n}\n    bool check(int x,int y,vector<vector<int>>&circle)\n    {\n        vector<pair<pair<int, int>, int>> circles(circle.size());\n         vector<vector<int>> gra(circle.size() + 4);\n        int n=circle.size();\n        \n        for (int i = 0; i < n; ++i) {\n            circles[i].first.first=circle[i][0];\n            circles[i].first.second=circle[i][1];\n            circles[i].second=circle[i][2];\n        }\n        \n        \n        \n         for (int i = 0; i < n; ++i) {\n             \n            if (circles[i].first.first <= circles[i].second) {\n                gra[n].push_back(i);\n                gra[i].push_back(n);\n            }\n            if (x - circles[i].first.first <= circles[i].second) {\n                gra[n + 2].push_back(i);\n                gra[i].push_back(n + 2);\n            }\n            if (circles[i].first.second <= circles[i].second) {\n                gra[n + 1].push_back(i);\n                gra[i].push_back(n + 1);\n            }\n            if (y - circles[i].first.second <= circles[i].second) {\n                gra[n + 3].push_back(i);\n                gra[i].push_back(n + 3);\n            }\n            for (int j = i + 1; j < n; ++j) {\n                double distance = sqrt(pow(circles[i].first.first - circles[j].first.first, 2) +\n                                       pow(circles[i].first.second - circles[j].first.second, 2));\n                int radius_sum = circles[i].second + circles[j].second;\n                if (radius_sum >= distance) {\n                    gra[i].push_back(j);\n                    gra[j].push_back(i);\n                }\n            }\n        }\n        \n        int ans = 0;\n     ans = max(ans, bfs(gra, n, n + 1, n + 2, n + 4)); \n    ans = max(ans, bfs(gra, n + 3, n + 2, n + 1, n + 4)); \n        if (ans){return false;}\n        return true;\n        \n    }\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles2) {\n         return check(X,Y,circles2);\n       \n        \n       \n    }\n};",
    "submit_ts": "1722137418",
    "subm_id": "1335763186"
}