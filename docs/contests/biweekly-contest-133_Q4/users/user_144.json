{
    "username": "xymabinogi",
    "submission": "using i64 = long long;\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n \ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % P)} {}\n    \n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += P;\n        }\n        if (x >= P) {\n            x -= P;\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(P - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) {\n        x = 1LL * x * rhs.x % P;\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n \ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n \nconstexpr int P = 1000000007;\nusing Z = MInt<P>;\n \nstruct Comb {\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n    \n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb() {\n        init(n);\n    }\n    \n    void init(int m) {\n        if (m <= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        \n        for (int i = n + 1; i <= m; i++) {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--) {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n    \n    Z fac(int m) {\n        if (m > n) init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m) {\n        if (m > n) init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m) {\n        if (m > n) init(2 * m);\n        return _inv[m];\n    }\n    Z binom(int n, int m) {\n        if (n < m || m < 0) return 0;\n        return fac(n) * invfac(m) * invfac(n - m);\n    }\n} comb;\n\nclass Solution {\npublic:\n    int numberOfPermutations(int n, vector<vector<int>>& r) {\n        sort(r.begin(), r.end());\n        int sz = r.size();\n        int mx = n * (n - 1) / 2 + 1;\n        vector<vector<Z>> dp(n + 1, vector<Z>(mx)), cdp(n + 1, vector<Z>(mx));\n        dp[0][0] = Z(1);\n        for (int i = 0; i < mx; i++){\n            cdp[0][i] = 1;\n        }\n        \n        \n        for (int i = 1, j = 0; i <= n; i++){\n           for (int k = mx - 1; k >= 0; k--){\n               dp[i][k] = cdp[i - 1][k] - (k <= i - 1 ? 0 : cdp[i - 1][k - i]);\n           }\n            \n           if (j < sz && i == r[j][0] + 1){\n               for (int k = 0; k < mx; k++){\n                   if (k != r[j][1]) dp[i][k] = 0;\n               }\n               j++;\n           }\n            cdp[i][0] = dp[i][0];\n           for (int k = 1; k < mx; k++){\n               cdp[i][k] = cdp[i][k - 1] + dp[i][k];\n           } \n        }\n        return dp[n][r.back()[1]].val();\n        \n    }\n};",
    "submit_ts": "1719069023",
    "subm_id": "1296784292"
}