{
    "username": "anh_tai",
    "submission": "class Solution {\npublic:\n    int getDiameter(vector<vector<int>>& edges){\n        int n = edges.size() + 1;\n        vector<vector<int>> g(n, vector<int>());\n        for(auto& edge : edges){\n            int u = edge[0];\n            int v = edge[1];\n            g[u].push_back(v);\n            g[v].push_back(u);\n        }\n        \n        int diameter = 0;\n        vector<int> depth(n);\n        auto Dfs = [&](auto Dfs, int u, int p) -> void {\n            int d1 = -1, d2 = -1; \n            for (int v : g[u]){\n                if (v == p){\n                    continue; \n                }\n                \n                Dfs(Dfs, v, u);\n                if (d1 <= depth[v]){\n                    d2 = d1;\n                    d1 = depth[v]; \n                }\n                else{\n                    d2 = std::max(d2, depth[v]);\n                }\n            }\n            \n            diameter = std::max(diameter, d1 + 1 + d2 + 1); \n            depth[u] = d1 + 1; \n        };\n        \n        Dfs(Dfs, 0,-1); \n        return diameter; \n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int dia1 = getDiameter(edges1);\n        int dia2 = getDiameter(edges2);\n        return std::max({dia1, dia2, 1 + (dia1 + 1)/ 2+ (dia2 + 1)/2});\n    }\n};",
    "submit_ts": "1719716277",
    "subm_id": "1304359972"
}