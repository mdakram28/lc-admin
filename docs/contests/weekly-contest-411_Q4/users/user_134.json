{
    "username": "power-c",
    "submission": "struct segtree{\n    #define ls(x) x << 1\n    #define rs(x) x << 1 | 1\n\n    struct node{\n        int l, r, mid, tag, len;\n        long long sum;\n    }tr[100010 << 2];\n\n    void pushup(node & a, node & b, node & c){\n        a.len = b.len + c.len;\n        a.sum = b.sum + c.sum;\n    }\n    void pushup(int u){\n        pushup(tr[u], tr[ls(u)], tr[rs(u)]);\n    }\n\n    void merge(node & a, int tag) {  // \u5c06\u4f20\u4e0b\u6765\u7684\u61d2\u6807\u8bb0\u66f4\u65b0\u5f53\u524d\u70b9\u7684\u6570\u636e\uff0c\u5e76\u5408\u5e76\u61d2\u6807\u8bb0\n        a.sum += tag * 1LL * a.len;\n        a.tag += tag;\n    }\n    void pushdown(int u){              // \u5c06 u \u7684\u61d2\u6807\u8bb0\u4e0b\u4f20\uff0c\u5e76\u6e05\u7a7a\n        node & a = tr[u], & b = tr[ls(u)], & c = tr[rs(u)];\n        merge(b, a.tag), merge(c, a.tag);\n        a.tag = 0;\n    }\n\n    void build(int u, int l, int r)\n    {\n        if(l == r)\n            tr[u] = {l, r, (l + r) >> 1, 0, 1, 0};\n        else{\n            tr[u] = {l, r, (l + r) >> 1};\n            int mid = tr[u].mid;\n            build(ls(u), l, mid), build(rs(u), mid + 1, r);\n            pushup(u);\n        }\n    }\n\n    node query(int u, int l, int r)\n    {\n        if(tr[u].l >= l && tr[u].r <= r) return tr[u];\n        else\n        {\n            pushdown(u);\n            int mid = tr[u].mid;\n            if(r <= mid) return query(ls(u), l, r);\n            else if(l >= mid + 1) return query(rs(u), l, r);\n            else{\n                node Ln = query(ls(u), l, r), Rn = query(rs(u), l, r);\n                node res; pushup(res, Ln, Rn);\n                return res;\n            }\n        }\n    }\n\n    void modify(int u, int l, int r, int tag)\n    {\n        if(tr[u].l >= l && tr[u].r <= r)\n            merge(tr[u], tag);\n        else{\n            pushdown(u);\n            int mid = tr[u].mid;\n            if(l <= mid) modify(ls(u), l, r, tag);\n            if(r >= mid + 1) modify(rs(u), l, r, tag);\n            pushup(u);\n        }\n    }\n};\n\nsegtree tr;\n\nclass Solution {\npublic:\n    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n        int n = s.size();\n        tr.build(1, 0, n - 1);\n        vector<int> pre(n);\n        for(int i = 0; i < n; i ++ ) {\n            pre[i] = s[i] - '0' + (i ? pre[i - 1] : 0);\n        }\n        auto get = [&] (int l, int r, int type) -> int {\n            int t = pre[r] - (l ? pre[l - 1] : 0);\n            if(type == 1) return t;\n            else return r - l + 1 - t;\n        };\n        vector<long long> ans(queries.size());\n        vector<vector<pair<int, int>>> que(n);\n        for(int i = 0; i < queries.size(); i ++ ) {\n            auto v = queries[i];\n            int l = v[0], r = v[1];\n            que[r].push_back({l, i});\n        }\n        for(int r = 0; r < n; r ++ ) {\n            int lo = 0, hi = r;\n            while(lo < hi) {\n                int mi = (lo + hi) >> 1;\n                if(min(get(mi, r, 0), get(mi, r, 1)) <= k) hi = mi;\n                else lo = mi + 1;\n            }\n            // int nl = hi, nr = r;\n            // cout << nl << ' ' << nr << endl;\n            tr.modify(1, hi, r, 1);\n            for(auto [l, id] : que[r]) {\n                ans[id] = tr.query(1, l, r).sum;\n            }\n        }\n        // cout << endl;\n        return ans;\n    }\n};",
    "submit_ts": "1723953335",
    "subm_id": "556416916"
}