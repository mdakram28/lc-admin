{
    "username": "g129512",
    "submission": "\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\nclass MaxValSegTree {\n    static final int OP_ADD = 1;\n    static final int OP_SET = 2;\n    static NodePool TMP_POOL = new NodePool();\n\n    static class NodePool {\n        int i = 1;\n        Node[] pool = new Node[129];\n\n        public NodePool() {\n            for (int j = 0; j < pool.length; j++) {\n                pool[j] = new Node();\n            }\n            pool[0].init(0, -1);\n        }\n\n        Node immutableEmpty() {\n            return pool[0];\n        }\n\n        Node next(int ls, int rs) {\n            Node ret = pool[i++];\n            ret.initForQuery(ls, rs);\n            if (i == pool.length) i = 1;\n            return ret;\n        }\n    }\n\n    static class Node {\n        Node left;\n        Node right;\n        int ls, rs;//debug\u7528\n\n        long maxVal;\n        long maxId;\n        int lazyType;\n        long lazyVal;\n\n        void init(int ls, int rs) {\n            this.ls = ls;\n            this.rs = rs;\n            maxId = ls;\n        }\n\n        void initForQuery(int ls, int rs) {\n            this.ls = ls;\n            this.rs = rs;\n            maxId = ls;\n            maxVal = Long.MIN_VALUE;\n        }\n    }\n\n    int maxN;\n    Node root;\n\n    public MaxValSegTree(int maxN) {\n        this.maxN = maxN;\n        this.root = new Node();\n        this.root.init(0, maxN);\n    }\n\n    void apply(Node node, int ls, int rs, int type, long val) {\n        if (type == OP_ADD) {\n            node.lazyVal += val;\n            node.maxVal += val;\n            node.lazyType = node.lazyType == OP_SET ? OP_SET : OP_ADD;\n        } else if (type == OP_SET) {\n            node.lazyVal = val;\n            node.maxVal = val;\n            node.lazyType = type;\n        }\n    }\n\n    void reduce(Node node, Node left, Node right, int ls, int rs) {\n        if (left.maxVal >= right.maxVal) {\n            node.maxVal = left.maxVal;\n            node.maxId = left.maxId;\n        } else {\n            node.maxVal = right.maxVal;\n            node.maxId = right.maxId;\n        }\n    }\n\n    void build(long[] vals) {\n        build(root, vals, 0, maxN);\n    }\n\n    private void build(Node node, long[] vals, int ls, int rs) {\n        if (ls == rs) {\n            if (ls >= vals.length) return;\n            apply(node, ls, rs, OP_SET, vals[ls]);\n            return;\n        }\n        pushDown(node, ls, rs);\n        int mid = ls + rs >> 1;\n        build(node.left, vals, ls, mid);\n        build(node.right, vals, mid + 1, rs);\n        reduce(node, node.left, node.right, ls, rs);\n    }\n\n    public void add(int l, int r, long val) {\n        update(root, l, r, 0, maxN, OP_ADD, val);\n    }\n\n    public void set(int l, int r, long val) {\n        update(root, l, r, 0, maxN, OP_SET, val);\n    }\n\n    /**\n     * \u5f53\u524dNode\u7684\u8303\u56f4: [ls,rs]\n     */\n    private void update(Node node, int l, int r, int ls, int rs, int type, long val) {\n        if (l < 0 || r > maxN) {\n            throw new IllegalArgumentException();\n        }\n        if (l <= ls && rs <= r) {\n            apply(node, ls, rs, type, val);\n            return;\n        }\n\n        pushDown(node, ls, rs);\n        int mid = ls + rs >> 1;\n        //\u5de6\u5b50\u6811[ls,mid]\n        //\u53f3\u5b50\u6811[mid+1,rs]\n        if (l <= mid) {\n            update(node.left, l, r, ls, mid, type, val);\n        }\n        if (r >= mid + 1) {\n            update(node.right, l, r, mid + 1, rs, type, val);\n        }\n        reduce(node, node.left, node.right, ls, rs);\n    }\n\n    //\u4e0b\u53d1lazy\u503c\n    void pushDown(Node node, int ls, int rs) {\n        int mid = ls + rs >> 1;\n        if (node.left == null) {\n            node.left = new Node();\n            node.left.init(ls, mid);\n        }\n        if (node.right == null) {\n            node.right = new Node();\n            node.right.init(mid+1, rs);\n        }\n        if (node.lazyType != 0) {\n            apply(node.left, ls, mid, node.lazyType, node.lazyVal);\n            apply(node.right, mid + 1, rs, node.lazyType, node.lazyVal);\n            node.lazyType = 0;\n            node.lazyVal = 0;\n        }\n    }\n\n    public Node query(int l, int r) {\n        return query(root, l, r, 0, maxN);\n    }\n\n    private Node query(Node node, int l, int r, int ls, int rs) {\n        if (l < 0 || r > maxN) {\n            throw new IllegalArgumentException();\n        }\n        if (l <= ls && rs <= r) {\n            return node;\n        }\n        pushDown(node, ls, rs);\n        int mid = ls + rs >> 1;\n        Node left, right;\n        left = right = TMP_POOL.immutableEmpty();\n        if (l <= mid) {\n            left = query(node.left, l, r, ls, mid);\n        }\n        if (r >= mid + 1) {\n            right = query(node.right, l, r, mid + 1, rs);\n        }\n        Node ret = TMP_POOL.next(Math.max(ls, l), Math.min(rs, r));\n        reduce(ret, left, right, ret.ls, ret.rs);\n        return ret;\n    }\n\n}\n\nclass Solution {\n    public List<Boolean> getResults(int[][] queries) {\n        TreeMap<Integer,Integer> map = new TreeMap<>();\n        int MX = (int) 1e5;\n        map.put(MX, MX);\n        map.put(0, 0);\n        MaxValSegTree tree = new MaxValSegTree(MX);\n        tree.set(MX, MX, MX);\n        tree.set(0, 0, 0);\n        List<Boolean> res=new ArrayList<>(queries.length);\n        for (int[] query : queries) {\n            if (query[0]==1) {\n                int x=query[1];\n                Map.Entry<Integer, Integer> hi = map.higherEntry(x);\n                int l1 = hi.getKey() - x;\n                int l2 = hi.getValue() - (hi.getKey() - x);\n                map.put(hi.getKey(), l1);\n                map.put(x, l2);\n                tree.set(hi.getKey(), hi.getKey(), l1);\n                tree.set(x, x, l2);\n            } else {\n                int x=query[1],sz=query[2];\n                long maxVal = tree.query(0, x).maxVal;\n                if (maxVal>=sz) {\n                    res.add(true);\n                } else {\n                    int k = map.floorKey(x);\n                    res.add(x-k>=sz);\n                }\n            }\n        }\n        return res;\n    }\n}",
    "submit_ts": 1716649125.0
}