{
    "username": "Prashant Dhaka",
    "submission": "class Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& board) {\n        \n         int m = board.size();\n    int n = board[0].size();\n\n    // Step 1: Find the top 3 values and their column indices for each row\n    std::vector<std::vector<std::pair<int, int>>> top3Values(m);\n\n    for (int i = 0; i < m; ++i) {\n        std::vector<std::pair<int, int>> rowValues;\n        for (int j = 0; j < n; ++j) {\n            rowValues.push_back({board[i][j], j});\n        }\n        // Sort the row values in descending order and keep the top 3\n        std::sort(rowValues.rbegin(), rowValues.rend());\n        top3Values[i] = std::vector<std::pair<int, int>>(rowValues.begin(), rowValues.begin() + 3);\n    }\n\n    long long maxSum = LLONG_MIN;\n\n    // Step 2: Iterate over all combinations of 3 different rows\n    for (int r1 = 0; r1 < m - 2; ++r1) {\n        for (int r2 = r1 + 1; r2 < m - 1; ++r2) {\n            for (int r3 = r2 + 1; r3 < m; ++r3) {\n\n                // Step 3: Consider all combinations of the top 3 values from the chosen rows\n                for (const auto& v1 : top3Values[r1]) {\n                    for (const auto& v2 : top3Values[r2]) {\n                        for (const auto& v3 : top3Values[r3]) {\n                            // Ensure the columns are distinct (no rooks attacking each other)\n                            if (v1.second != v2.second && v1.second != v3.second && v2.second != v3.second) {\n                                long long currentSum = static_cast<long long>(v1.first) + v2.first + v3.first;\n                                maxSum = std::max(maxSum, currentSum);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return maxSum;\n    }\n};",
    "submit_ts": "1723906631",
    "subm_id": "1359063728"
}