{
    "username": "scotchtape",
    "submission": "template<class T> struct Seg { // comb(ID,b) = b\n\tconst T ID = 0; T comb(T a, T b) { return a+b; }\n\tint n; vector<T> seg;\n\tvoid init(int _n) { n = _n; seg.assign(2*n,ID); }\n\tvoid pull(int p) { seg[p] = comb(seg[2*p],seg[2*p+1]); }\n\tvoid upd(int p, T val) { // set val at position p\n\t\tseg[p += n] = val; for (p /= 2; p; p /= 2) pull(p); }\n\tT query(int l, int r) {\t// sum on interval [l, r]\n\t\tT ra = ID, rb = ID;\n\t\tfor (l += n, r += n+1; l < r; l /= 2, r /= 2) {\n\t\t\tif (l&1) ra = comb(ra,seg[l++]);\n\t\t\tif (r&1) rb = comb(seg[--r],rb);\n\t\t}\n\t\treturn comb(ra,rb);\n\t}\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        \n        auto is_peak = [&](int i) {\n            if (i < 0 || i >= n) return false;\n            if (i == 0 || i == n-1) return false;\n            \n            if (a[i] > a[i-1] && a[i] > a[i+1]) return true;\n            \n            return false;\n        };\n        \n        Seg<int> seg; seg.init(n);\n        for (int i = 0; i < n; ++i) {\n            if (is_peak(i)) seg.upd(i, 1);\n        }\n        \n        vector<int> ans;\n        \n        for (auto v : q) {\n            if (v[0] == 1) {\n                \n                int res = seg.query(v[1], v[2]);\n                if (seg.query(v[1], v[1]) == 1) --res;\n                if (v[1] != v[2] && seg.query(v[2], v[2]) == 1) --res;\n                \n                ans.push_back(res);\n            } else {\n                int i = v[1];\n                int x = v[2];\n                a[i] = x;\n                \n                for (int j = i-1; j <= i+1; ++j) {\n                    if (j < 0 || j >= n) continue;\n                    if (is_peak(j)) seg.upd(j, 1);\n                    else seg.upd(j, 0);\n                }\n                \n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1718506199",
    "subm_id": "1289610505"
}