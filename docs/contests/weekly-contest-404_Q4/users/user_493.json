{
    "username": "hcpv5",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int dep1 = getDis(edges1);\n        int dep2 = getDis(edges2);\n        // cout<<dep1<<\" \"<<dep2<<endl;\n        return max(max(dep1, dep2), (dep1 + 1) / 2 + (dep2 + 1) / 2 + 1);\n    }\n    \nprivate:\n    int getDis(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vector<vector<int>> graph(n);\n        for (auto& e : edges) {\n            graph[e[0]].push_back(e[1]);\n            graph[e[1]].push_back(e[0]);\n        }\n        \n        // BFS 1: find farthest node from node 0\n        queue<int> que;\n        vector<bool> visited(n);\n        que.push(0);\n        visited[0] = 1;\n        int last = 0;\n        while (!que.empty()) {\n            int out = que.front();    que.pop();\n            last = out;\n            for (int nxt : graph[out]) {\n                if (visited[nxt])    continue;\n                visited[nxt] = 1;\n                que.push(nxt);\n            }\n        }\n        \n        // BFS 2: starting from that node to find the maximum depth\n        que = queue<int>();\n        visited = vector<bool>(n);\n        que.push(last);\n        visited[last] = 1;\n        int depth = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            while (size--) {\n                int out = que.front();    que.pop();\n                last = out;\n                for (int nxt : graph[out]) {\n                    if (visited[nxt])    continue;\n                    visited[nxt] = 1;\n                    que.push(nxt);\n                }\n            }\n            depth++;\n        }\n        \n        return depth - 1;\n    }\n};",
    "submit_ts": 1719718530.0
}