{
    "username": "akshay_2902",
    "submission": "class Solution {\npublic:\n    struct Circle {\n        float x, y, r;\n    };\n\n    void dfs(const vector<vector<int>>& graph, int x, unordered_set<int>& visited) {\n        if (visited.count(x)) return;\n        visited.insert(x);\n        for (int v : graph[x]) {\n            dfs(graph, v, visited);\n        }\n    }\n\n    bool isBlocking(const vector<Circle>& circles, const unordered_set<int>& component, float width, float height) {\n        float maxY = -1.0f;\n        float minY = height + 1;\n        float maxX = -1.0f;\n        float minX = width + 1;\n        \n        bool lb = 1,tr = 1;\n        for (int c : component) {\n            const Circle& circle = circles[c];\n            maxY = max(maxY, circle.y + circle.r);\n            maxX = max(maxX, circle.x + circle.r);\n            minY = min(minY, circle.y - circle.r);\n            minX = min(minX, circle.x - circle.r);\n            \n            if(circle.y <= circle.r && circle.x <= circle.r){\n                lb = 0;\n            }\n            \n            if((width - circle.x) <= circle.r && (height - circle.y) <= circle.r){\n                tr = 0;\n            }\n        }\n        \n        if(lb == 0 || tr == 0) return true;\n        \n        if(maxY >= height && maxX >= width){\n            return 1;\n        }\n        \n        if(maxX > 0 && minX <= 0 && maxY > 0 && minY <= 0){\n            return 1;\n        }\n\n        if (maxY >= height && minY <= 0.0f) {\n            return true;\n        }\n\n        if (maxX >= width && minX <= 0.0f) {\n            return true;\n        }\n\n        if (maxY >= height && minX >= width) {\n            return true;\n        }\n\n        if (minY <= 0.0f && minX <= 0.0f) {\n            return true;\n        }\n        \n        \n        return false;\n    }\n\n    bool isPassable(const vector<Circle>& circles, float width, float height) {\n        int n = circles.size();\n        vector<vector<int>> graph(n);\n\n        for (int i = 0; i < n; ++i) {\n            const Circle& c1 = circles[i];\n            for (int j = i + 1; j < n; ++j) {\n                const Circle& c2 = circles[j];\n                float dist2 = (c2.x - c1.x) * (c2.x - c1.x) + (c2.y - c1.y) * (c2.y - c1.y);\n                if (dist2 > (c1.r + c2.r) * (c1.r + c2.r)) continue;\n                graph[i].push_back(j);\n                graph[j].push_back(i);\n            }\n        }\n\n        unordered_set<int> visited;\n        for (int i = 0; i < n; ++i) {\n            if (visited.count(i)) continue;\n\n            unordered_set<int> component;\n            dfs(graph, i, component);\n\n            visited.insert(component.begin(), component.end());\n            if (isBlocking(circles, component, width, height)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        int n = circles.size();\n        vector<Circle> circle(n);\n        int i = 0;\n        for(auto it:circles){\n            circle[i].x = it[0];\n            circle[i].y = it[1];\n            circle[i].r = it[2];\n            i++;\n        }\n        \n        return isPassable(circle,X,Y);\n    }\n};",
    "submit_ts": "1722138458",
    "subm_id": "1335791267"
}