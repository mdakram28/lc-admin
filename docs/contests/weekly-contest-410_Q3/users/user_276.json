{
    "username": "BaoziiO_o",
    "submission": "package main\n\ntype G interface {\n\t~int | ~int64 | uint | uint64 | float64 | float32 | string | rune | byte\n}\n\nfunc abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n\nfunc divmod(x, y int) (int, int) {\n\treturn x / y, x % y\n}\n\nfunc __gcd(a, b int) int {\n\tfor b > 0 {\n\t\ta, b = b, a%b\n\t}\n\treturn a\n}\n\nfunc gcd(nums ...int) int {\n\tr := 0\n\tfor _, num := range nums {\n\t\tr = __gcd(r, num)\n\t}\n\treturn r\n}\n\nfunc __lcm(a, b int) int {\n\treturn a * b / __gcd(a, b)\n}\n\nfunc lcm(nums ...int) int {\n\tr := 1\n\tfor _, num := range nums {\n\t\tr = __lcm(r, num)\n\t}\n\treturn r\n}\n\nfunc reduce[T G](key func(T, T) T, iter []T) T {\n\tr := iter[0]\n\tfor _, e := range iter {\n\t\tr = key(r, e)\n\t}\n\treturn r\n}\n\nfunc pairwise[T G](iter []T) [][]T {\n\tn := len(iter)\n\tif n <= 1 {\n\t\treturn [][]T{}\n\t}\n\tr := make([][]T, n-1)\n\tfor i := 0; i < n-1; i++ {\n\t\tr[i] = []T{iter[i], iter[i+1]}\n\t}\n\treturn r\n}\n\nfunc groupby[T G, C G | bool](iter []T, key func(T) C) (r [][]T) {\n\tn := len(iter)\n\tfor i, j := 0, 0; i < n; {\n\t\tr = append(r, []T{})\n\t\tcur := key(iter[i])\n\t\tfor ; j < n; j++ {\n\t\t\tif key(iter[j]) != cur {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tr[len(r)-1] = append(r[len(r)-1], iter[j])\n\t\t}\n\t\ti = j\n\t}\n\treturn\n}\n\nfunc accumulate(iter []int) []int {\n\tn := len(iter)\n\tr := make([]int, n+1)\n\tfor i, num := range iter {\n\t\tr[i+1] = r[i] + num\n\t}\n\treturn r\n}\n\nfunc sum(iter []int) (r int) {\n\tfor _, num := range iter {\n\t\tr += num\n\t}\n\treturn r\n}\n\nfunc Counter[T G](iter []T) map[T]int {\n\tr := make(map[T]int)\n\tfor _, e := range iter {\n\t\tr[e]++\n\t}\n\treturn r\n}\n\ntype Set[T G] map[T]bool\n\nfunc (s Set[T]) Add(key T) {\n\ts[key] = true\n}\n\nfunc NewSet[T G](iter ...T) Set[T] {\n\ts := make(Set[T])\n\tfor _, e := range iter {\n\t\ts.Add(e)\n\t}\n\treturn s\n}\n\nfunc (s Set[T]) Size() int {\n\treturn len(s)\n}\n\nfunc (s Set[T]) Empty() bool {\n\treturn s.Size() == 0\n}\n\nfunc (s Set[T]) Contains(key T) bool {\n\t_, ok := s[key]\n\treturn ok\n}\n\nfunc (s Set[T]) Remove(key T) {\n\tif !s.Contains(key) {\n\t\tpanic(\"Element not in Set\")\n\t}\n\tdelete(s, key)\n}\n\nfunc (s Set[T]) Discard(key T) {\n\tdelete(s, key)\n}\n\nfunc (s Set[T]) Union(t Set[T]) {\n\tfor k := range t {\n\t\ts.Add(k)\n\t}\n}\n\nfunc (s Set[T]) Intersect(t Set[T]) {\n\tr := NewSet[T]()\n\tfor k := range t {\n\t\tif s.Contains(k) {\n\t\t\tr.Add(k)\n\t\t}\n\t}\n\tclear(s)\n\tfor e := range r {\n\t\ts.Add(e)\n\t}\n}\n\nfunc (s Set[T]) SymDiff(t Set[T]) {\n\tfor k := range t {\n\t\tif s.Contains(k) {\n\t\t\ts.Remove(k)\n\t\t} else {\n\t\t\ts.Add(k)\n\t\t}\n\t}\n}\n\nfunc (s Set[T]) Clear() {\n\tclear(s)\n}\n\ntype Deque[T G] struct{ l, r []T }\n\nfunc NewDeque[T G](iter ...T) *Deque[T] {\n\tr := &Deque[T]{}\n\tfor _, e := range iter {\n\t\tr.PushBack(e)\n\t}\n\treturn r\n}\n\nfunc (q *Deque[T]) Empty() bool {\n\treturn len(q.l) == 0 && len(q.r) == 0\n}\n\nfunc (q *Deque[T]) Len() int {\n\treturn len(q.l) + len(q.r)\n}\n\nfunc (q *Deque[T]) PushFront(v T) {\n\tq.l = append(q.l, v)\n}\n\nfunc (q *Deque[T]) PushBack(v T) {\n\tq.r = append(q.r, v)\n}\n\nfunc (q *Deque[T]) PopFront() (v T) {\n\tif len(q.l) > 0 {\n\t\tq.l, v = q.l[:len(q.l)-1], q.l[len(q.l)-1]\n\t} else {\n\t\tv, q.r = q.r[0], q.r[1:]\n\t}\n\treturn\n}\n\nfunc (q *Deque[T]) PopBack() (v T) {\n\tif len(q.r) > 0 {\n\t\tq.r, v = q.r[:len(q.r)-1], q.r[len(q.r)-1]\n\t} else {\n\t\tv, q.l = q.l[0], q.l[1:]\n\t}\n\treturn\n}\n\nfunc (q *Deque[T]) Front() T {\n\tif len(q.l) > 0 {\n\t\treturn q.l[len(q.l)-1]\n\t}\n\treturn q.r[0]\n}\n\nfunc (q *Deque[T]) Back() T {\n\tif len(q.r) > 0 {\n\t\treturn q.r[len(q.r)-1]\n\t}\n\treturn q.l[0]\n}\n\nfunc (q *Deque[T]) Get(i int) T {\n\tif i < len(q.l) {\n\t\treturn q.l[len(q.l)-1-i]\n\t}\n\treturn q.r[i-len(q.l)]\n}\n\nfunc cache1d(_func func(int) int) func(int) int {\n\tmemo := make(map[int]int)\n\tcachedFunc := func(param1 int) int {\n\t\tif val, ok := memo[param1]; ok {\n\t\t\treturn val\n\t\t}\n\t\tres := _func(param1)\n\t\tmemo[param1] = res\n\t\treturn res\n\t}\n\treturn cachedFunc\n}\n\nfunc cache2d(_func func(int, int) int) func(int, int) int {\n\ttype pair struct{ param1, param2 int }\n\tmemo := make(map[pair]int)\n\tcachedFunc := func(param1, param2 int) int {\n\t\tp := pair{param1, param2}\n\t\tif val, ok := memo[p]; ok {\n\t\t\treturn val\n\t\t}\n\t\tres := _func(param1, param2)\n\t\tmemo[p] = res\n\t\treturn res\n\t}\n\treturn cachedFunc\n}\n\nfunc cache3d(_func func(int, int, int) int) func(int, int, int) int {\n\ttype triple struct{ param1, param2, param3 int }\n\tmemo := make(map[triple]int)\n\tcachedFunc := func(param1, param2, param3 int) int {\n\t\tp := triple{param1, param2, param3}\n\t\tif val, ok := memo[p]; ok {\n\t\t\treturn val\n\t\t}\n\t\tres := _func(param1, param2, param3)\n\t\tmemo[p] = res\n\t\treturn res\n\t}\n\treturn cachedFunc\n}\n\nfunc array1d(l1 int, val int) []int {\n\tr := make([]int, l1)\n\tfor i := range r {\n\t\tr[i] = val\n\t}\n\treturn r\n}\n\nfunc array2d(l1, l2 int, val int) [][]int {\n\tr := make([][]int, l1)\n\tfor i := range r {\n\t\tr[i] = array1d(l2, val)\n\t}\n\treturn r\n}\n\nfunc array3d(l1, l2, l3 int, val int) [][][]int {\n\tr := make([][][]int, l1)\n\tfor i := range r {\n\t\tr[i] = array2d(l2, l3, val)\n\t}\n\treturn r\n}\n\nfunc array4d(l1, l2, l3, l4 int, val int) [][][][]int {\n\tr := make([][][][]int, l1)\n\tfor i := range r {\n\t\tr[i] = array3d(l2, l3, l4, val)\n\t}\n\treturn r\n}\n\nconst MOD = 1000000007\n\n\nfunc countOfPairs(nums []int) int {\n    n := len(nums)\n    var dfs func(int, int) int\n    dfs = func(i, prev int) int {\n        if i == n {\n            return 1\n        }\n        ans := 0\n        for c := prev; c <= nums[i]; c++ {\n            if (i == 0) || (nums[i - 1] - prev >= nums[i] - c) {\n                ans += dfs(i + 1, c)\n            }\n            ans %= MOD\n        }\n        return ans\n    }\n    dfs = cache2d(dfs)\n    return dfs(0, 0)\n}",
    "submit_ts": "1723343931",
    "subm_id": "1351522150"
}