{
    "username": "BreadMuMu",
    "submission": "class Node:\n    def __init__(self, val=-1):\n        self.val = val\n        self.nxt = None\n\nclass LinkedList:\n    def __init__(self, n):\n        self.head = Node()\n        self.tail = Node()\n        self.map = defaultdict(Node)\n        curr = self.head\n        for i in range(n):\n            node = Node(i)\n            self.map[i] = node\n            curr.nxt = node\n            curr = curr.nxt\n        curr.nxt = self.tail\n            \n            \n    def query(self, a, b):\n        if a not in self.map: return 0\n        if b not in self.map: return 0\n        \n        curr = self.map[a]\n        end = self.map[b]\n        answer = 0\n        while curr.nxt is not end:\n            nxt = curr.nxt\n            del self.map[nxt.val]\n            curr = nxt\n            answer += 1\n        self.map[a].nxt = end\n        return answer\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        m = len(queries)\n        curr = n-1\n        answer = [0] * m\n        lst = LinkedList(n)\n        for i in range(m):\n            a, b = queries[i]\n            erased = lst.query(a, b)\n            curr -= erased\n            answer[i] = curr\n        return answer\n        \n        # erased = set()\n        # answer = [0] * m\n        # for i in range(m):\n        #     a, b = queries[i]\n        #     s = a+1\n        #     e = b-1\n        #     while s <= e and s not in erased:\n        #         erased.add(s)\n        #         s += 1\n        #     while s <= e and e not in erased:\n        #         erased.add(e)\n        #         e -= 1\n        #     answer[i] = n-1 - len(erased)\n        # return answer\n            \n            ",
    "submit_ts": "1722741290",
    "subm_id": "1343741337"
}