{
    "username": "b06902111",
    "submission": "class Solution {\n    bool distanceSeq(int x1, int y1, int x2, int y2, int d) {\n        return (long long)(x1 - x2) * (x1 - x2) + (long long)(y1 - y2) * (y1 - y2) <= (long long)d*d;\n    }\n    bool intersect_x(vector<int>& c, int x) {\n        return abs(c[0] - x ) <= c[2];\n    }\n    bool intersect_y(vector<int>& c, int y) {\n        return abs(c[1] - y) <= c[2];\n    }\n    \n    vector<bool> dfs(int node, unordered_map<int, vector<int>>&graph, unordered_set<int> &visited, vector<vector<int>>& circles, int x, int y) {\n        // return {intersect 0, intersect X}\n        vector<bool> intersect = {intersect_x(circles[node], 0), intersect_x(circles[node], x), intersect_y(circles[node], 0), intersect_y(circles[node], y)};\n        visited.insert(node);\n        \n        for (int neighbor : graph[node]) {\n            if (visited.find(neighbor) == visited.end()) {\n                vector<bool> res = dfs(neighbor, graph, visited, circles, x, y);\n                for (int i = 0 ; i < 4 ; i++)\n                    intersect[i] = intersect[i] || res[i];\n            }\n        }\n            \n        return intersect;\n    }\n    \npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        // check if (0,0) or (X,Y) in circles\n        for (auto& c : circles) {\n            if(distanceSeq(c[0], c[1], 0, 0, c[2]))\n                return false;\n            else if(distanceSeq(c[0], c[1], X, Y, c[2]))\n                return false;\n        }\n        \n        // generate circle group\n        unordered_map<int, vector<int>> graph;\n        for (int i = 0 ; i < circles.size() ; i++) \n            for (int j = 0 ; j < circles.size() ; j++)\n                if (i != j && distanceSeq(circles[i][0], circles[i][1], circles[j][0], circles[j][1], circles[i][2] + circles[j][2]))\n                    graph[i].push_back(j);\n        \n        // check if there is a component intersect_x both on X and 0\n        unordered_set<int> visited;\n        for (int node = 0 ; node < circles.size() ; node++) {\n            if (visited.find(node) == visited.end()) {\n                auto block = dfs(node, graph, visited, circles, X, Y);\n                if (block[0] && block[1])\n                    return false;\n                else if (block[0] && block[2])\n                    return false;\n                else if (block[1] && block[3])\n                    return false;\n                else if (block[2] && block[3])\n                    return false;\n            }\n        }\n        \n        \n        return true;\n    }\n};",
    "submit_ts": "1722138404",
    "subm_id": "1335789893"
}