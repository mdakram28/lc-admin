{
    "username": "delphih",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nclass SegTreeLazyRangeAdd {\n  vector<T> tree, lazy;\n  vector<T> *arr;\n  int n, root, n4, end;\n\n  void maintain(int cl, int cr, int p) {\n    int cm = cl + (cr - cl) / 2;\n    if (cl != cr && lazy[p]) {\n      lazy[p * 2] += lazy[p];\n      lazy[p * 2 + 1] += lazy[p];\n      tree[p * 2] += lazy[p] * (cm - cl + 1);\n      tree[p * 2 + 1] += lazy[p] * (cr - cm);\n      lazy[p] = 0;\n    }\n  }\n\n  T range_sum(int l, int r, int cl, int cr, int p) {\n    if (l <= cl && cr <= r) return tree[p];\n    int m = cl + (cr - cl) / 2;\n    T sum = 0;\n    maintain(cl, cr, p);\n    if (l <= m) sum += range_sum(l, r, cl, m, p * 2);\n    if (r > m) sum += range_sum(l, r, m + 1, cr, p * 2 + 1);\n    return sum;\n  }\n\n  void range_add(int l, int r, T val, int cl, int cr, int p) {\n    if (l <= cl && cr <= r) {\n      lazy[p] += val;\n      tree[p] += (cr - cl + 1) * val;\n      return;\n    }\n    int m = cl + (cr - cl) / 2;\n    maintain(cl, cr, p);\n    if (l <= m) range_add(l, r, val, cl, m, p * 2);\n    if (r > m) range_add(l, r, val, m + 1, cr, p * 2 + 1);\n    tree[p] = tree[p * 2] + tree[p * 2 + 1];\n  }\n\n  void build(int s, int t, int p) {\n    if (s == t) {\n      tree[p] = (*arr)[s];\n      return;\n    }\n    int m = s + (t - s) / 2;\n    build(s, m, p * 2);\n    build(m + 1, t, p * 2 + 1);\n    tree[p] = tree[p * 2] + tree[p * 2 + 1];\n  }\n\n public:\n  explicit SegTreeLazyRangeAdd<T>(vector<T> v) {\n    n = v.size();\n    n4 = n * 4;\n    tree = vector<T>(n4, 0);\n    lazy = vector<T>(n4, 0);\n    arr = &v;\n    end = n - 1;\n    root = 1;\n    build(0, end, 1);\n    arr = nullptr;\n  }\n\n  void show(int p, int depth = 0) {\n    if (p > n4 || tree[p] == 0) return;\n    show(p * 2, depth + 1);\n    for (int i = 0; i < depth; ++i) putchar('\\t');\n    printf(\"%d:%d\\n\", tree[p], lazy[p]);\n    show(p * 2 + 1, depth + 1);\n  }\n\n  T range_sum(int l, int r) { return range_sum(l, r, 0, end, root); }\n\n  void range_add(int l, int r, T val) { range_add(l, r, val, 0, end, root); }\n};\n\nclass Solution {\npublic:\n    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n        int n = s.length(), nq = queries.size();\n        vector<int> nxt(n, 0);\n        unordered_map<int, int> cnt;\n        int q = 0;\n        for (int p = 0; p < n; p++) {\n            while (q < n && (cnt['0'] <= k || cnt['1'] <= k))\n                cnt[s[q++]]++;\n            nxt[p] = q - (cnt['0'] > k && cnt['1'] > k);\n            cnt[s[p]]--;\n        }\n        \n        // for (int i = 0; i < n; i++) cout << nxt[i] << ','; cout << endl;\n\n        for (int i = 0; i < nq; i++)\n            queries[i].push_back(i);\n        sort(queries.begin(), queries.end());\n\n        SegTreeLazyRangeAdd<long long> seg(vector<long long>(n, 0));\n        vector<long long> res(nq, 0);\n        int p = n - 1;\n        for (int i = nq-1; i >= 0; i--) {\n            int l = queries[i][0], r = queries[i][1], qi = queries[i][2];\n            while (p >= l) {\n                seg.range_add(p, nxt[p]-1, 1);\n                p--;\n            }\n            res[qi] = seg.range_sum(l, r);\n        }\n        return res;\n    }\n};",
    "submit_ts": "1723952689",
    "subm_id": "1359802236"
}