{
    "username": "linbay",
    "submission": "\nclass KarpRabinHash {\npublic:\n    KarpRabinHash(const string& s, int base = 256, long long mod = 1e9+7)\n        : base(base), mod(mod), n(s.length()), prefix_hash(n + 1, 0), base_powers(n + 1, 1) {\n        \n        for (int i = 0; i < n; ++i) {\n            prefix_hash[i + 1] = (prefix_hash[i] * base + s[i]) % mod;\n            base_powers[i + 1] = (base_powers[i] * base) % mod;\n        }\n    }\n\n    long long hash(int i, int j) {\n        if (i < 0 || j > n || i >= j) {\n            throw invalid_argument(\"Invalid indices: i and j should satisfy 0 <= i < j <= len(s)\");\n        }\n        return (prefix_hash[j] - prefix_hash[i] * base_powers[j - i] % mod + mod) % mod;\n    }\n\nprivate:\n    int base;\n    long long mod;\n    int n;\n    vector<long long> prefix_hash;\n    vector<long long> base_powers;\n};\n\n\nclass Solution {\npublic:\n    int minimumCost(const string& target, const vector<string>& words, const vector<int>& costs) {\n        int maxLen = 0;\n        long long base = 1e9+7;\n        int prime = 256;\n        unordered_set<int> lens;\n        KarpRabinHash kp(target);\n\n        unordered_map<long long, int> costDict;\n        for (size_t i = 0; i < words.size(); ++i) {\n            long long h = hash(words[i], prime, base);\n            if (costDict.find(h) != costDict.end()) {\n                costDict[h] = min(costDict[h], costs[i]);\n            } else {\n                costDict[h] = costs[i];\n            }\n            lens.insert(words[i].length());\n        }\n\n        vector<int> lens_vec(lens.begin(), lens.end());\n        sort(lens_vec.begin(), lens_vec.end());\n\n        vector<int> dp(target.length() + 1, INT_MAX);\n        dp[0] = 0;\n\n        for (size_t currIdx = 1; currIdx <= target.length(); ++currIdx) {\n            int res = INT_MAX;\n            for (int l : lens_vec) {\n                int start = currIdx - l;\n                if (start >= 0) {\n                    long long h = kp.hash(start, currIdx);\n                    if (costDict.find(h) != costDict.end()) {\n                        if (dp[start] != INT_MAX)\n                            res = min(res, costDict[h] + dp[start]);\n                    }\n                } else {\n                    break;\n                }\n            }\n            dp[currIdx] = res;\n        }\n\n        return dp[target.length()] == INT_MAX ? -1 : dp[target.length()];\n    }\n\nprivate:\n    long long hash(const string& s, int prime, long long base) {\n        long long h = 0;\n        for (char c : s) {\n            h = (h * prime % base + c) % base;\n        }\n        return h;\n    }\n};",
    "submit_ts": "1720324235",
    "subm_id": "1312394722"
}