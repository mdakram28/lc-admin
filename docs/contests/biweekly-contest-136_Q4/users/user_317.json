{
    "username": "curdking",
    "submission": "import java.util.*;\n\nclass DfsOrder {\n\n    int n;\n    int root, Time = 0;\n    List<List<Integer>> adj;\n    int[] l, r;\n\n    DfsOrder() {}\n    DfsOrder(int n) {\n        this.n = n;\n        adj = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            adj.add(new ArrayList<>());\n        }\n        l = new int[n + 1];\n        r = new int[n + 1];\n    }\n\n    void addEdge(int a, int b) {\n        adj.get(a).add(b);\n        adj.get(b).add(a);\n    }\n\n    void getDfsOrder(int root, int fa) {\n        l[root] = ++Time;\n        for (int i = 0; i < adj.get(root).size(); i++) {\n            int nxt = adj.get(root).get(i);\n            if (nxt != fa) {\n                getDfsOrder(nxt, root);\n            }\n        }\n        r[root] = Time;\n    }\n\n}\n\nclass SegTree {\n\n    int n;\n    int[] d, lazy;\n\n    SegTree() {}\n    SegTree(int n) {\n        this.n = n;\n        d = new int[n * 4 + 5];\n        lazy = new int[n * 4 + 5];\n    }\n\n    void push_down(int p, int l, int r, int m) {\n        if (lazy[p] != 0) {\n            d[p << 1] += lazy[p];\n            d[p << 1 | 1] += lazy[p];\n            lazy[p << 1] += lazy[p];\n            lazy[p << 1 | 1] += lazy[p];\n            lazy[p] = 0;\n        }\n    }\n\n    void change(int p, int l, int r, int ql, int qr, int v) {\n        if (ql <= l && r <= qr) {\n            d[p] += v;\n            lazy[p] += v;\n            return;\n        }\n        int m = l + r >> 1;\n        push_down(p, l, r, m);\n        if (ql <= m) {\n            change(p << 1, l, m, ql, qr, v);\n        }\n        if (qr > m) {\n            change(p << 1 | 1, m + 1, r, ql, qr, v);\n        }\n        d[p] = Math.max(d[p << 1], d[p << 1 | 1]);\n    }\n\n    int query(int p, int l, int r, int ql, int qr) {\n        if (ql <= l && r <= qr) {\n            return d[p];\n        }\n        int m = l + r >> 1;\n        int res = 0;\n        push_down(p, l, r, m);\n        if (ql <= m) {\n            res = Math.max(res, query(p << 1, l, m, ql, qr));\n        }\n        if (qr > m) {\n            res = Math.max(res, query(p << 1 | 1, m + 1, r, ql, qr));\n        }\n        return res;\n    }\n\n    void change(int ql, int qr, int v) {\n        change(1, 0, n, ql, qr, v);\n    }\n\n    int query(int ql, int qr) {\n        return query(1, 0, n, ql, qr);\n    }\n\n}\n\nclass Solution {\n\n    List<List<List<Integer>>> adj;\n    int[] dist, res;\n    DfsOrder D;\n    int n;\n    SegTree seg;\n\n    int get(int y) {\n        if (y % 2 == 0) {\n            return 2;\n        } else {\n            return 1;\n        }\n    }\n\n    void dfs1(int x, int fa, int deep) {\n        dist[x] = deep;\n        for (int i = 0; i < adj.get(x).size(); i++) {\n            int y = adj.get(x).get(i).get(0);\n            int w = adj.get(x).get(i).get(1);\n            if (y == fa) continue;\n            dfs1(y, x, deep + w);\n        }\n    }\n\n    void dfs2(int x, int fa) {\n        res[x] = seg.query(1, n);\n        for (int i = 0; i < adj.get(x).size(); i++) {\n            int y = adj.get(x).get(i).get(0);\n            int w1 = adj.get(x).get(i).get(1);\n            int w2 = adj.get(x).get(i).get(2);\n            if (y == fa) continue;\n            int l = D.l[y];\n            int r = D.r[y];\n            seg.change(l, r, -w1 - w2);\n            seg.change(1, n, w2);\n            dfs2(y, x);\n            seg.change(l, r, w1 + w2);\n            seg.change(1, n, -w2);\n        }\n    }\n\n    public int[] timeTaken(int[][] edges) {\n        n = edges.length + 1;\n        D = new DfsOrder(n);\n        res = new int[n];\n        adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < edges.length; i++) {\n            int x = edges[i][0];\n            int y = edges[i][1];\n            D.addEdge(x, y);\n            adj.get(x).add(Arrays.asList(y, get(y), get(x)));\n            adj.get(y).add(Arrays.asList(x, get(x), get(y)));\n        }\n        D.getDfsOrder(0, -1);\n        dist = new int[n];\n        dfs1(0, -1, 0);\n        seg = new SegTree(n + 1);\n        for (int i = 0; i < n; i++) {\n            seg.change(D.l[i], D.l[i], dist[i]);\n        }\n        dfs2(0, -1);\n        return res;\n    }\n}",
    "submit_ts": "1722699836",
    "subm_id": "552277352"
}