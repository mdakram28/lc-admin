{
    "username": "harsh_3002",
    "submission": "#include <vector>\n#include <set>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    // Function to build the segment tree\n    void build(int ind, int low, int high, vector<int>& arr, vector<int>& seg) {\n        if (low == high) {\n            seg[ind] = arr[low];\n            return;\n        }\n        int mid = (low + high) / 2;\n        build(2 * ind + 1, low, mid, arr, seg);\n        build(2 * ind + 2, mid + 1, high, arr, seg);\n        seg[ind] = max(seg[2 * ind + 1], seg[2 * ind + 2]);\n    }\n\n    int query(int ind, int low, int high, int l, int r, vector<int>& seg) {\n        if (r < low || l > high) {\n            return int(-1e6); // Completely outside\n        }\n        if (low >= l && high <= r) {\n            return seg[ind]; // Completely inside\n        }\n        int mid = (low + high) / 2;\n        int left = query(2 * ind + 1, low, mid, l, r, seg);\n        int right = query(2 * ind + 2, mid + 1, high, l, r, seg);\n        return max(left, right);\n    }\n\n    void pointUpdate(int ind, int low, int high, int node, int val, vector<int>& seg) {\n        if (low == high) {\n            seg[ind] = val;\n        } else {\n            int mid = (low + high) / 2;\n            if (node <= mid) {\n                pointUpdate(2 * ind + 1, low, mid, node, val, seg);\n            } else {\n                pointUpdate(2 * ind + 2, mid + 1, high, node, val, seg);\n            }\n            seg[ind] = max(seg[2 * ind + 1], seg[2 * ind + 2]);\n        }\n    }\n\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int N = 1e5 + 3;\n        int high = 5 * N;\n        vector<int> seg(high, -1);\n        vector<bool> ans;\n        set<int> st;\n        st.insert(0);\n        st.insert(high);\n\n        for (auto& el : queries) {\n            if (el[0] == 1) {\n                auto it = st.upper_bound(el[1]);\n                int xupp = *it;\n                int xlow = *(--it);\n                pointUpdate(0, 0, N, xupp, xupp - el[1], seg);\n                pointUpdate(0, 0, N, el[1], el[1] - xlow, seg);\n                st.insert(el[1]);\n            } else {\n                int x = el[1], sz = el[2];\n                auto it = st.lower_bound(el[1]);\n                int val = *(--it);\n                if (val == 0) {\n                    ans.push_back(sz <= x);\n                } else {\n                    int maxi = query(0, 0, N, 0, val, seg);\n                    int sup = max(maxi, x - val);\n                    ans.push_back(sup >= sz);\n                }\n            }\n        }\n        return ans;\n    }\n};\n",
    "submit_ts": 1716651133.0
}