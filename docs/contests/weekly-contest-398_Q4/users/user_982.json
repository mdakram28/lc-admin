{
    "username": "AshishLimitless",
    "submission": "#define ll int\n#define pb push_back\n#define F first\n#define S second\n#define I insert\n#define vll vector<ll>\n#define vdd vector<double>\n#define vss vector<string>\n#define vpl vector<pair<ll,ll>>\n#define maxe(v) *max_element((v).begin(),(v).end());\n#define mine(v) *min_element((v).begin(),(v).end());\n#define loo(i,n) for(int i=0;i<n;i++)\t\n#define sor(v) sort(v.begin(),v.end());\n#define pyes cout<<\"YES\"<<endl;\n#define pno cout<<\"NO\"<<endl;\n#define mll map<ll,ll>\n#define mcl map<char,ll>\n#define mod 1000000007\n#define ft front()\n#define bk back()\n#define pf push_front\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define lb lower_bound\n#define ub upper_bound\n#define each(a,x) for(auto a:x)\t\n#define nl cout<<\"\\n\";\n#define pri(xx) cout<<xx<<endl;\n#define sll set<ll>\n#define sch set<char>\n#define pq priority_queue<int, vector<int>, greater<int> >\n#define pql priority_queue<ll>\n#define INF 1e9\n#define manh(a,b,c,d) abs(a-c)+abs(b-d)\n#define euc(a,b,c,d) sqrt((a-c)*(a-c)+(b-d)*(b-d))\n#define foo(i,a,b) for(ll i=a;i<b;i++)\n#define pril(i,a,b,v) foo(i,a,b){cout<<v[i]<<\" \";}\n#define pqc priority_queue<char>\n#define to_upper(s)  transform(s.begin(), s.end(), s.begin(), ::toupper);\n#define lowercase(s)  transform(s.begin(), s.end(), s.begin(), ::tolower);\nclass Solution {\npublic:\n\nstruct tuple_hash {\n    template <class T1, class T2, class T3>\n    size_t operator () (const tuple<T1, T2, T3> &t) const {\n        auto hash1 = hash<T1>{}(get<0>(t));\n        auto hash2 = hash<T2>{}(get<1>(t));\n        auto hash3 = hash<T3>{}(get<2>(t));\n        return hash1 ^ hash2 ^ hash3;\n    }\n};\n\n\nunordered_map<tuple<ll, ll, bool>, ll, tuple_hash> memo;\n\nll rec(ll level, ll jump, ll k, bool last_was_down) {\n    if (level < 0) return 0; \n    if (memo.count({level, jump, last_was_down})) return memo[{level, jump, last_was_down}];\n    \n    ll ways = 0;\n    if (level == k) {\n        ways++; \n    }\n    if (level + (1LL << jump) <= k + (1LL << jump)) {\n        ways += rec(level + (1LL << jump), jump + 1, k, false);\n    }\n    if (level > 0 && !last_was_down) {\n        ways += rec(level - 1, jump, k, true);\n    }\n\n    return memo[{level, jump, last_was_down}] = ways;\n}\n\nint waysToReachStair(int k) {\n    memo.clear();\n    return rec(1, 0, k, false);\n}\n\n\n\n};",
    "submit_ts": 1716089998.0
}