{
    "username": "ernestlu",
    "submission": "class Solution {\npublic:\n    struct bfs_info {\n        int endp;\n        int end_dist;\n        vector<int> dists;\n    };\n\n    #define all(x) x.begin(), x.end()\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = (int)edges1.size()  +1, m = (int)edges2.size() + 1;\n        vector e0(n, vector<int>());\n        vector e1(m, vector<int>());\n        for (int i = 0; i + 1 < n; i++) {\n            int x = edges1[i][0], y = edges1[i][1];\n            e0[x].push_back(y);\n            e0[y].push_back(x);\n        }\n        for (int i = 0; i + 1 < m; i++) {\n            int x = edges2[i][0], y = edges2[i][1];\n            e1[x].push_back(y);\n            e1[y].push_back(x);\n        }\n\n        auto get_info = [&](auto& e) -> bfs_info {\n            int n = (int)e.size();\n                \n            auto bfs = [&](int root) -> bfs_info {\n                vector<bool> v(n);\n                queue<pair<int, int>> bfs;\n                bfs.push({root, 0});\n                vector<int> dist(n);\n                int fin_node, fin_dist;\n                while (!bfs.empty()) {\n                    auto [g, d] = bfs.front();\n                    bfs.pop();\n                    if (v[g])\n                        continue;\n                    v[g] = true;\n                    dist[g] = d;\n                    fin_node = g, fin_dist = d;\n                    for (auto u : e[g]) {\n                        if (v[u])\n                            continue;\n                        bfs.push({u, d + 1});\n                    }\n                }\n                return {fin_node, fin_dist, dist};\n            };\n            \n            auto [end_0, _dist_0, _dist_from_0] = bfs(0);\n            _dist_from_0.clear();\n            auto [end_1, diam_leng, dist_from_e0] = bfs(end_0);\n            auto [end_2, diam_leng_2, dist_from_e1] = bfs(end_1);\n            assert(diam_leng == diam_leng_2);\n            vector<int> max_dist(n);\n            for (int i = 0; i < n; i++)\n                max_dist[i] = max(dist_from_e0[i], dist_from_e1[i]);\n            return {(int)(min_element(all(max_dist)) - max_dist.begin()), diam_leng, max_dist};  \n        };\n        auto [r0, d0, dist0] = get_info(e0);\n        auto [r1, d1, dist1] = get_info(e1);\n        int ans = max({d0, d1, dist0[r0] + dist1[r1] + 1});\n        return ans;\n    }\n};",
    "submit_ts": 1719715696.0
}