{
    "username": "NDR0216",
    "submission": "template <typename T1, typename T2> void PRINT(pair<T1, T2> p) {\n    cout << '(' << p.first << \", \" << p.second << ')' << endl;\n}\ntemplate <typename T> void PRINT(vector<T> v) {\n    cout << '[';\n    for (int i = 0; i < v.size(); i++) {\n        if (i != 0) {\n            cout << \", \";\n        }\n        cout << v[i];\n    }\n    cout << ']' << endl;\n}\nvoid PRINT() { cout << endl; }\ntemplate <typename T, typename... Types> void PRINT(T var1, Types... var2) {\n    cout << var1 << \" \";\n    PRINT(var2...);\n}\ntemplate <typename T> void PRINT_ARR(T* arr, size_t n) {\n    cout << '[';\n    for (int i = 0; i < n; i++) {\n        if (i != 0) {\n            cout << \", \";\n        }\n        cout << arr[i];\n    }\n    cout << ']' << endl;\n}\n\ntemplate <> struct hash<pair<int, int>> {\n    size_t operator()(const pair<int, int>& p) const {\n        // copy from boost::hash_combine\n        size_t x = hash<int>{}(p.first) + 0x9e3779b9 + hash<int>{}(p.second);\n        const size_t m = 0xe9846af9b1a615d;\n        x ^= x >> 32;\n        x *= m;\n        x ^= x >> 32;\n        x *= m;\n        x ^= x >> 28;\n        return x;\n    }\n};\n\nclass UnionFind {\nprivate:\n    int *root, *rank;\n\npublic:\n    int num_root;\n\n    UnionFind(int n) {\n        root = new int[n]; // root array\n        rank = new int[n]();\n        num_root = n;\n\n        for (int i = 0; i < n; i++) {\n            root[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (x != root[x]) { // x is not the root node\n            root[x] = find(root[x]);\n        }\n\n        return root[x];\n    }\n\n    void unionSet(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX != rootY) {\n            num_root--;\n\n            if (rank[rootX] > rank[rootY]) {\n                root[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                root[rootX] = rootY;\n            } else {\n                root[rootY] = rootX;\n                rank[rootX] += 1;\n            }\n        }\n    }\n};\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        unordered_set<int> ANDs;\n        unordered_set<int> next_ANDs;\n\n        // ANDs.insert(nums[0]);\n\n        int diff = INT_MAX;\n\n        for (int i = 0; i < nums.size(); i++) {\n            ANDs.insert(nums[i]);\n            // PRINT(\"----\");\n            for (auto it = ANDs.begin(); it != ANDs.end(); ++it ) {\n                int v = *it & nums[i];\n\n                // PRINT(v);\n                \n                next_ANDs.insert(v);\n\n                diff= min(diff, abs(k-v));\n            }\n            swap(next_ANDs, ANDs);\n            next_ANDs.clear();\n        }\n\n        return diff;\n    }\n};",
    "submit_ts": 1717298536.0
}