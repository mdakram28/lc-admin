{
    "username": "linhhlp",
    "submission": "class SegmentTreeSum: # Sum Segment Tree\n    def __init__(self, n):\n            self.array = [0]*(4*n) # maximum size\n    def query(self, left, valueLeft, right, valueRight, n, curr=0):  # between [left, right] inclusive | curr = curr position (+= len(levels))\n        if left == right: return valueLeft\n        elif right - left == 1: return valueLeft + valueRight\n        if left  % 2 == 0: valueLeft  = valueLeft  + self.array[left  + 1 + curr]\n        if right % 2 == 1: valueRight = valueRight + self.array[right - 1 + curr] \n        nNext = n//2 if n%2 == 0 else n//2 + 1    \n        return self.query(left//2,valueLeft,  right//2,valueRight, nNext, curr + n )\n    \n    def update(self, idx, val, n, curr=0): # n = len of current level, level = 0, n = len(nums) \n        self.array[curr+idx] = val\n        if n > 1:\n            if idx == n - 1 and n > 2: newVal = val\n            else:\n                if idx % 2 == 0: nei = idx+1 # neibough in pair 2*i and 2*i + 1\n                else: nei = idx - 1\n                newVal = val + self.array[curr + nei]\n            nNext = n//2 if n%2 == 0 else n//2 + 1\n            self.update(idx//2, newVal , nNext, curr + n)\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        arr = [0]*n\n        for i in range(1, n-1):\n            if nums[i]> nums[i-1] and nums[i] > nums[i+1]:\n                arr[i] = 1\n                \n        st = SegmentTreeSum(n)\n        for i, num in enumerate(arr):\n            st.update(i, num, n)\n            \n        res = []\n        for t, x, y in queries:\n            if t == 1:\n                xx = yy = False\n                if arr[x]==1:\n                    xx = True\n                    arr[x] = 0\n                    st.update(x, 0, n)\n                if arr[y]==1:\n                    yy = True\n                    arr[y] = 0\n                    st.update(y, 0, n)\n                res.append(st.query(x,arr[x], y, arr[y], n))\n                if xx:\n                    arr[x] = 1\n                    st.update(x, 1, n)\n                if yy:\n                    arr[y] = 1\n                    st.update(y, 1, n)\n            else:\n                idx = x\n                nums[idx] = y\n                \n                if idx > 1:\n                    prev = arr[idx-1]\n                    if nums[idx-1] > nums[idx-2] and nums[idx-1] > nums[idx]:\n                        arr[idx-1] = 1\n                    else:\n                        arr[idx-1] = 0\n                    if prev != arr[idx-1]    :\n                        st.update(idx-1, arr[idx-1], n)\n                    \n                        \n                if idx > 0 and idx < n-1:\n                    prev = arr[idx]\n                    if nums[idx] > nums[idx-1] and nums[idx] > nums[idx+1]:\n                        arr[idx] = 1\n                    else:\n                        arr[idx] = 0\n                        \n                    if prev != arr[idx]    :\n                        st.update(idx, arr[idx], n)\n                \n                if idx < n-2:\n                    prev = arr[idx+1]\n                    if nums[idx+1] > nums[idx] and nums[idx+1] > nums[idx+2]:\n                        arr[idx+1] = 1\n                    else:\n                        arr[idx+1] = 0\n                    if prev != arr[idx+1]    :\n                        st.update(idx+1, arr[idx+1], n)\n                        \n        return res",
    "submit_ts": 1718507581.0
}