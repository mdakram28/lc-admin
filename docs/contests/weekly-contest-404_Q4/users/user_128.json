{
    "username": "kml123",
    "submission": "\n// This class represents a undirected graph using adjacency list\nclass Graph\n{\n    int V;              // No. of vertices\n    list<int> *adj;     // Pointer to an array containing\n                        // adjacency lists\npublic:\n    Graph(int V);              // Constructor\n    void addEdge(int v, int w);// function to add an edge to graph\n    int longestPathLength();  // prints longest path of the tree\n    pair<int, int> bfs(int u); // function returns maximum distant\n                               // node from u with its distance\n};\n \nGraph::Graph(int V)\n{\n    this->V = V;\n    adj = new list<int>[V];\n}\n \nvoid Graph::addEdge(int v, int w)\n{\n    adj[v].push_back(w);    // Add w to v\u2019s list.\n    adj[w].push_back(v);    // Since the graph is undirected\n}\n \n//  method returns farthest node and its distance from node u\npair<int, int> Graph::bfs(int u)\n{\n    //  mark all distance with -1\n    int dis[V];\n    memset(dis, -1, sizeof(dis));\n \n    queue<int> q;\n    q.push(u);\n \n    //  distance of u from u will be 0\n    dis[u] = 0;\n \n    while (!q.empty())\n    {\n        int t = q.front();       q.pop();\n \n        //  loop for all adjacent nodes of node-t\n        for (auto it = adj[t].begin(); it != adj[t].end(); it++)\n        {\n            int v = *it;\n \n            // push node into queue only if\n            // it is not visited already\n            if (dis[v] == -1)\n            {\n                q.push(v);\n \n                // make distance of v, one more\n                // than distance of t\n                dis[v] = dis[t] + 1;\n            }\n        }\n    }\n \n    int maxDis = 0;\n    int nodeIdx;\n \n    //  get farthest node distance and its index\n    for (int i = 0; i < V; i++)\n    {\n        if (dis[i] > maxDis)\n        {\n            maxDis = dis[i];\n            nodeIdx = i;\n        }\n    }\n    return make_pair(nodeIdx, maxDis);\n}\n \n//  method prints longest path of given tree\nint Graph::longestPathLength()\n{\n    pair<int, int> t1, t2;\n \n    // first bfs to find one end point of\n    // longest path\n    t1 = bfs(0);\n \n    //  second bfs to find actual longest path\n    t2 = bfs(t1.first);\n    return t2.second;\n    // cout << \"Longest path is from \" << t1.first << \" to \"\n    //      << t2.first << \" of length \" << t2.second;\n}\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n=edges1.size()+1;\n        int m=edges2.size()+1;\n        Graph g1(n);\n        for(auto it:edges1){\n            g1.addEdge(it[0], it[1]);\n        }\n        Graph g2(m);\n        for(auto it:edges2){\n            g2.addEdge(it[0], it[1]);\n        }\n        int x=g1.longestPathLength();\n        int y=g2.longestPathLength();\n        //cout<<x<<\" \"<<y<<endl;\n        return max((x+1)/2+(y+1)/2+1,max(x,y));\n    }\n};\n// [[0,1],[2,0],[3,2],[3,6],[8,7],[4,8],[5,4],[3,5],[3,9]]\n// [[0,1],[0,2],[0,3]]\n\n//7",
    "submit_ts": 1719717312.0
}