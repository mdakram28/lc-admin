{
    "username": "windlike-man",
    "submission": "struct STLazyTaged\n{\n    using T = int64_t;\n    void Init(T N_)\n    {\n        N = (N_ + 1) * 4;\n        tr.resize(N);\n        tag.resize(N);\n        InitR(0, N_ - 1, 1);\n    }\n    void InitR(int left, int right, int p)\n    {\n        if (left == right)\n        {\n            tr[p] = 1;\n            return;\n        }\n        int m = left + (right - left) / 2;\n        InitR(left, m, p * 2);\n        InitR(m + 1, right, p * 2 + 1);\n        tr[p] = tr[p * 2] + tr[p * 2 + 1];\n    }\n\n    // inline void Maintain(int left, int right, int p)\n    //{\n    //     int m = left + (right - left) / 2;\n    //     if (tag[p]) // propagate tag\n    //     {\n    //         tr[p * 2] += tag[p] * (m - left + 1);\n    //         tag[p * 2] += tag[p];\n    //         tr[p * 2 + 1] += tag[p] * (right - m);\n    //         tag[p * 2 + 1] += tag[p];\n    //         tag[p] = 0;\n    //     }\n    // }\n\n    void RangeSetZero(int rl, int rr, int left, int right, int p)\n    {\n        if (tag[p])\n            return;\n        if (rl <= left && rr >= right)\n        {\n            tag[p] = 1;\n            tr[p] = 0;\n            return;\n        }\n        int m = left + (right - left) / 2;\n        // Maintain(left, right, p);\n        if (rl <= m)\n            RangeSetZero(rl, rr, left, m, p * 2);\n        if (rr > m)\n            RangeSetZero(rl, rr, m + 1, right, p * 2 + 1);\n        tr[p] = tr[p * 2] + tr[p * 2 + 1];\n    }\n\n    T RangeSum(int rl, int rr, int left, int right, int p)\n    {\n        if (rl <= left && rr >= right)\n            return tr[p];\n\n        int m = left + (right - left) / 2;\n        // Maintain(left, right, p);\n\n        T sum = 0;\n        if (rl <= m)\n            sum = RangeSum(rl, rr, left, m, p * 2);\n        if (rr > m)\n            sum += RangeSum(rl, rr, m + 1, right, p * 2 + 1);\n        return sum;\n    }\n    void show(int p, int depth = 0)\n    {\n        if (p > N || tr[p] == 0)\n            return;\n        for (int i = 0; i < depth; ++i)\n            putchar('\\t');\n        printf(\"%d:%lld:%lld\\n\", p, tr[p], tag[p]);\n        show(p * 2, depth + 1);\n        show(p * 2 + 1, depth + 1);\n    }\n\nprivate:\n    int       N;\n    vector<T> tr, tag;\n};\n\nclass Solution\n{\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>> &queries)\n    {\n        int         m = queries.size();\n        vector<int> ret;\n        STLazyTaged st;\n        st.Init(n - 1);\n        for (int qi = 0; qi < queries.size(); ++qi)\n        {\n            int l = queries[qi][0], r = queries[qi][1];\n            if (r - l > 1)\n                st.RangeSetZero(l + 1, r - 1, 0, n - 2, 1);\n            int ans = st.RangeSum(0, n - 2, 0, n - 2, 1);\n            ret.push_back(ans);\n        }\n        return ret;\n    }\n};",
    "submit_ts": "1722742180",
    "subm_id": "552342995"
}