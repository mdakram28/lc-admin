{
    "username": "kaq",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        auto neighbors1 = getNeighbors(edges1);\n        auto neighbors2 = getNeighbors(edges2);\n        auto [dist1, furthest1, mid1] = getFurthest(neighbors1, 0);\n        auto [dist2, furthest2, mid2] = getFurthest(neighbors2, 0);\n        auto [dist3, furthest3, mid3] = getFurthest(neighbors1, furthest1);\n        auto [dist4, furthest4, mid4] = getFurthest(neighbors2, furthest2);\n        vector<vector<int>> neighbors(neighbors1.size() + neighbors2.size());\n        for (int i = 0; i < neighbors1.size(); i++) {\n            for (int neighbor : neighbors1[i]) {\n                neighbors[i].push_back(neighbor);\n            }\n        }\n        for (int i = 0; i < neighbors2.size(); i++) {\n            for (int neighbor : neighbors2[i]) {\n                neighbors[i + neighbors1.size()].push_back(neighbor + neighbors1.size());\n            }\n        }\n        neighbors[mid3].push_back(mid4 + neighbors1.size());\n        neighbors[mid4 + neighbors1.size()].push_back(mid3);\n        auto [dist5, furthest5, mid5] = getFurthest(neighbors, 0);\n        auto [dist6, furthest6, mid6] = getFurthest(neighbors, furthest5);\n        return dist6 - 1;\n    }\n    \nprivate:\n    vector<vector<int>> getNeighbors(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vector<vector<int>> neighbors(n);\n        for (auto& edge : edges) {\n            neighbors[edge[0]].push_back(edge[1]);\n            neighbors[edge[1]].push_back(edge[0]);\n        }\n        return neighbors;\n    }\n    \n    array<int, 3> getFurthest(vector<vector<int>>& neighbors, int k) {\n        int n = neighbors.size();\n        vector<int> parent(n, -1);\n        vector<int> q;\n        q.push_back(k);\n        for (int i = 0; i < q.size(); i++) {\n            for (int neighbor : neighbors[q[i]]) {\n                if (neighbor == parent[q[i]]) {\n                    continue;\n                }\n                q.push_back(neighbor);\n                parent[neighbor] = q[i];\n            }\n        }\n        int dist = 1;\n        int curNode = q.back();\n        while (curNode != k) {\n            curNode = parent[curNode];\n            dist++;\n        }\n        int midNode = q.back();\n        for (int i = 0; i < dist / 2; i++) {\n            midNode = parent[midNode];\n        }\n        return {dist, q.back(), midNode};\n    }\n};",
    "submit_ts": 1719715698.0
}