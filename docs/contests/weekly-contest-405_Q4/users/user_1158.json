{
    "username": "Anoop6598Rai",
    "submission": "// class Solution {\n// public:\n//     struct Node {\n//          vector<pair<int, int>>vec;\n//         unordered_map<char, Node*>MA;\n//         Node() {\n            \n//         }\n//     };\n\n//     class Trie {\n//     public:\n//         Node* root;\n//         Trie() {\n//             root = new Node();\n//         }\n        \n//         void insert( string& word, int ind, int cost) {\n//             Node* temp = root;\n//             for (char &c:word) {\n//                 if (temp->MA.count(c)) {\n                   \n//                 }\n//                 else\n//                      temp->MA[c] = new Node();\n                \n//                 temp = temp->MA[c];\n//             }\n//             temp->vec.push_back({ind,cost});\n//         }\n//     };\n//      vector<int> dp;\n//     int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n//          dp.resize(target.size()+1,INT_MAX);\n//         Trie trie;\n//         for (int i = 0; i < words.size(); ++i) {\n//             trie.insert(words[i], i, costs[i]);\n//         }\n//            dp[0]=0;\n//         for (int i = 0; i <=target.size()-1; ++i) {\n//             if(dp[i]!=INT_MAX){\n//             Node* node = trie.root;\n//             for (int j = i; j <=(int)target.size()-1; ++j) {\n//                 if(node->MA.count(target[j])){\n//                 node = node->MA[target[j]];\n\n//                 for ( auto& word_end : node->vec) {\n//                     int word_len = words[word_end.first].length();\n//                     if (i + word_len <= (int)target.size()) {\n//                         dp[i + word_len] = min(dp[i + word_len], dp[i] + word_end.second);\n//                     }\n//                 }\n//                 }\n//                 }\n//             }\n//         }\n//         int ans =dp[target.size()] == INT_MAX ? -1 : dp[target.size()];\n//         return ans;\n//     }\n// };\n\nclass TrieNode {\npublic:\n    unordered_map<char, TrieNode*> children;\n    vector<pair<int, int>> word_ends;\n};\n\nclass Trie {\npublic:\n    TrieNode* root;\n\n    Trie() {\n        root = new TrieNode();\n    }\n\n    void insert(string word, int index, int cost) {\n        TrieNode* node = root;\n        for (char &c : word) {\n            if (node->children.count(c)>0) {\n                \n            }\n            else node->children[c] = new TrieNode();\n            node = node->children[c];\n        }\n        node->word_ends.push_back({index, cost});\n    }\n};\n\nclass Solution {\npublic:\nint calc(int num)\n{\n    long long i=0,ans=0;\n    for(long long i=0;i<50;i++)\n    {\n         ans+=i;\n    }   \n    return ans^10/4;\n}\nvector<int> dp;\n    int  minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        dp.resize(target.size()+1,INT_MAX);\n        Trie trie;\n        int n=target.size();\n        for (int i = 0; i <= words.size()-1; ++i) {\n            trie.insert(words[i], i, costs[i]);\n        }\n         dp[0]=0;\n         int num_taken=40;\nint RES=calc(num_taken);\nRES=RES&(RES^5);\n        for (int i = 0; i < n; ++i) {\n            TrieNode* node = trie.root;\n            if(dp[i]!=INT_MAX){\n            for (int j = i; j < n; ++j) {\n                if (node->children.count(target[j])==0) {\n                    break;\n                }\n                node = node->children[target[j]];\n                for (auto& p : node->word_ends) {\n                    int word_len = words[p.first].size();\n                    int freq=p.second;\n                    if (i + word_len <= n) {\n                        dp[i + word_len] = min(dp[i + word_len], dp[i] + freq);\n                    }\n                }\n            }\n            }\n        }\n\n        int ans= dp[n] == INT_MAX? -1 : dp[n];\n        return ans;\n    }\n};",
    "submit_ts": "1720323575",
    "subm_id": "1312378892"
}