{
    "username": "ning2ing",
    "submission": "class Solution {\n    public List<Boolean> getResults(int[][] queries) {\n        int mx = (int) 2e5;\n\n        TreeSet<Integer> treeSet = new TreeSet<>();\n        treeSet.add(0);\n        treeSet.add(mx);\n\n        DynamicSegTreeAdd_max seg = new DynamicSegTreeAdd_max();\n        List<Boolean> ans = new ArrayList<>();\n        for (int[] p : queries) {\n            int op = p[0], x = p[1];\n\n            if (op == 1) {\n                Integer lower = treeSet.lower(x);\n                Integer higher = treeSet.higher(x);\n                int L = higher - lower;\n                int L1 = x - lower;\n                int L2 = higher - x;\n                seg.upd(x, x, L1);\n                seg.upd(higher, higher, L2);\n\n                treeSet.add(x);\n            } else {\n                int sz = p[2];\n                Integer floor = treeSet.floor(x);\n                long maxD = seg.getMax(0, floor);\n                maxD = Math.max(maxD, x - floor);\n                ans.add(maxD >= sz);\n            }\n        }\n        return ans;\n    }\n\n    static class DynamicSegTreeAdd_max {\n        static class Node {\n            Node ls, rs;\n            long max, lazy;\n        }\n\n        static final int N = Integer.MAX_VALUE;\n        final Node root = new Node();\n\n        void upd(int ql, int qr, int val) {\n            this.upd(root, 0, N, ql, qr, val);\n        }\n\n        void upd(Node p, int l, int r, int ql, int qr, int val) {\n            if (ql <= l && r <= qr) {\n                p.max = val;\n                p.lazy = val;\n                return;\n            }\n            int mid = l + (r - l) / 2;\n            pushDown(p);\n            if (ql <= mid) upd(p.ls, l, mid, ql, qr, val);\n            if (qr > mid) upd(p.rs, mid + 1, r, ql, qr, val);\n            pushUp(p);\n        }\n\n        long getMax(int ql, int qr) {\n            return this.getMax(root, 0, N, ql, qr);\n        }\n\n        long getMax(Node p, int l, int r, int ql, int qr) {\n            if (ql <= l && r <= qr) {\n                return p.max;\n            }\n            pushDown(p);\n            int mid = l + (r - l) / 2;\n            long max = 0;\n            if (ql <= mid) max = getMax(p.ls, l, mid, ql, qr);\n            if (qr > mid) max = Math.max(max, getMax(p.rs, mid + 1, r, ql, qr));\n            return max;\n        }\n\n        void pushDown(Node p) {\n            if (p.ls == null) p.ls = new Node();\n            if (p.rs == null) p.rs = new Node();\n            if (p.lazy != 0) {\n                p.ls.max = p.lazy;\n                p.rs.max = p.lazy;\n                p.ls.lazy = p.lazy;\n                p.rs.lazy = p.lazy;\n                p.lazy = 0;\n            }\n        }\n\n        void pushUp(Node node) {\n            node.max = Math.max(node.ls.max, node.rs.max);\n        }\n    }\n}",
    "submit_ts": 1716650562.0
}