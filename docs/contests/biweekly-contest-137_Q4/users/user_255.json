{
    "username": "yuzining",
    "submission": "\n//c\n#ifndef _GLIBCXX_NO_ASSERT\n#include<cassert>\n#endif\n#include<cctype>\n#include<cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n \n#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n \n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n \n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nconst int N = 505, M = 10;\nint ST[N][N][M][M], a[N][N], lg[N];\n\nvoid build(int n, int m) {\n  for(int i = 2; i <= max(n, m); i++) {\n    lg[i] = lg[i / 2] + 1;\n  }\n  for(int i = 1; i <= n; i++) {\n    for(int j = 1; j <= m; j++) {\n      ST[i][j][0][0] = a[i][j];\n    }\n  }\n  for(int i = 1; i <= n; i++) {\n    for(int k = 1; (1 << k) <= m; k++) {\n      for(int j = 1; j + (1 << k) - 1 <= m; j++) {\n        ST[i][j][0][k] = max(ST[i][j][0][k - 1], ST[i][j + (1 << (k - 1))][0][k - 1]);\n      }\n    }\n  }\n  for(int k1 = 1; (1 << k1) <= n; k1++) {\n    for(int i = 1; i + (1 << k1) - 1 <= n; i++) {\n      for(int k2 = 0; (1 << k2) <= m; k2++) {\n        for(int j = 1; j + (1 << k2) - 1 <= m; j++) {\n          ST[i][j][k1][k2] = max(ST[i][j][k1 - 1][k2], ST[i + (1 << (k1 - 1))][j][k1 - 1][k2]);\n        }\n      }\n    }\n  }\n}\n\nint query(int x1, int y1, int x2, int y2) {\n  if(x2 < x1 || y2 < y1) return INT_MIN;\n  const int k1 = lg[x2 - x1 + 1], k2 = lg[y2 - y1 + 1];\n  x2 = x2 - (1 << k1) + 1;\n  y2 = y2 - (1 << k2) + 1;\n  return max({ST[x1][y1][k1][k2], ST[x1][y2][k1][k2], ST[x2][y1][k1][k2], ST[x2][y2][k1][k2]});\n}\n\nclass Solution {\npublic:\n    long long maximumValueSum(const vector<vector<int>>& board) {\n        int n = board.size(), m = board[0].size();\n        std::priority_queue< tuple<int, int, int>, std::vector<tuple<int, int, int> >, std::greater<tuple<int, int, int> > > pq;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i + 1][j + 1] = board[i][j];\n                pq.push({board[i][j], i, j});\n                if (pq.size() > max(n, m) * 2 + 5) {\n                    pq.pop();\n                }\n            }\n        }\n        std::vector<std::tuple<int, int, int>> v;\n        while (!pq.empty()) {\n            v.push_back(pq.top());\n            pq.pop();\n        }\n        build(n, m);\n        long long ans = LLONG_MIN;\n        int k = v.size();\n        for (int i = 0; i < k; i++) {\n            for (int j = i + 1; j < k; j++) {\n                int x1 = std::get<1>(v[i]) + 1;\n                int y1 = std::get<2>(v[i]) + 1;\n                int x2 = std::get<1>(v[j]) + 1;\n                int y2 = std::get<2>(v[j]) + 1;\n                if (x1 == x2 || y1 == y2) {\n                    continue;\n                }\n                if (x1 > x2) {\n                    swap(x1, x2);\n                }\n                if (y1 > y2) {\n                    swap(y1, y2);\n                }\n                int now = std::max({\n                    query(1, 1, x1 - 1, y1 - 1),\n                    query(1, y1 + 1, x1 - 1, y2 - 1),\n                    query(1, y2 + 1, x1 - 1, m),\n                    query(x1 + 1, 1, x2 - 1, y1 - 1),\n                    query(x1 + 1, y1 + 1, x2 - 1, y2 - 1),\n                    query(x1 + 1, y2 + 1, x2 - 1, m),\n                    query(x2 + 1, 1, n, y1 - 1),\n                    query(x2 + 1, y1 + 1, n, y2 - 1),\n                    query(x2 + 1, y2 + 1, n, m),\n                });\n                // std::cout << std::get<0>(v[i]) << ' ' << std::get<0>(v[j]) << ' ' << now << std::endl;\n                ans = std::max(ans, 0ll + std::get<0>(v[i]) + std::get<0>(v[j]) + now);\n            }\n        }\n        // std::cout << endl;\n        return ans;\n    }\n};",
    "submit_ts": "1723908762",
    "subm_id": "556332712"
}