{
    "username": "megaspazz",
    "submission": "class Solution {\n    public long[] countKConstraintSubstrings(String s, int k, int[][] queries) {\n        final int N = s.length();\n        \n        int[][] is = new int[2][N];\n        for (int i = 0; i < N; ++i) {\n            int d = s.charAt(i) - '0';\n            is[d][i] = 1;\n        }\n        \n        int[][] isSum = {\n            makeSum(is[0]),\n            makeSum(is[1]),\n        };\n        \n        int[] A = new int[N];\n        for (int i = 0; i < N; ++i) {\n            A[i] = s.charAt(i) - '0';\n        }\n        \n        int[] rangeEnd = new int[N];\n        int[] freq = new int[2];\n        int j = 0;\n        for (int i = 0; i < N; ++i) {\n            if (i > 0) {\n                rangeEnd[i] = rangeEnd[i - 1];\n            }\n            while (j < N && (freq[0] <= k || freq[1] <= k)) {\n                rangeEnd[i] = j;\n                ++freq[A[j]];\n                ++j;\n            }\n            if (freq[0] <= k || freq[1] <= k) {\n                rangeEnd[i] = j;\n            }\n            --freq[A[i]];\n        }\n        \n        \n        long[] begin = new long[N];\n        long[] end = new long[N];\n        for (int i = 0; i < N; ++i) {\n            begin[i] = i;\n            end[i] = rangeEnd[i];\n        }\n        \n        // PrimitiveSparseTable stBegin = new PrimitiveSparseTable(begin);\n        // PrimitiveSparseTable stEnd = new PrimitiveSparseTable(end);\n        // System.out.println(Arrays.toString(begin));\n        // System.out.println(Arrays.toString(end));\n        \n        long[] sumBegin = makeSum(begin);\n        long[] sumEnd = makeSum(end);\n        \n        final int Q = queries.length;\n        long[] ans = new long[Q];\n        for (int q = 0; q < Q; ++q) {\n            int L = queries[q][0];\n            int R = queries[q][1];\n            \n            int idx = BinarySearch.firstThat(L, R + 1, new BinarySearch.IntCheck() {\n                @Override\n                public boolean valid(int value) {\n                    return end[value] > R;\n                }\n            });\n            \n            // System.out.format(\"idx = %d%n\", idx);\n            \n            // ans[q] = stEnd.get(L, idx - 1) - stBegin.get(L, idx - 1);\n            // System.out.format(\"    ans = %d%n\", ans[q]);\n            // if (L <= idx && idx <= R) {\n            //     ans[q] += (R + 1L) * (R + 1L - idx) - stBegin.get(idx, R);\n            // }\n            \n            ans[q] = sumEnd[idx] - sumEnd[L] - (sumBegin[idx] - sumBegin[L]);\n            // System.out.format(\"    ans = %d%n\", ans[q]);\n            if (L <= idx && idx <= R) {\n                ans[q] += (R + 1L) * (R + 1L - idx) - (sumBegin[R + 1] - sumBegin[idx]);\n            }\n        }\n        return ans;\n    }\n    \n    private static int[] makeSum(int[] A) {\n        final int N = A.length;\n        \n        int[] S = new int[N + 1];\n        for (int i = 0; i < N; ++i) {\n            S[i + 1] = S[i] + A[i];\n        }\n        return S;\n    }\n    \n    private static long[] makeSum(long[] A) {\n        final int N = A.length;\n        \n        long[] S = new long[N + 1];\n        for (int i = 0; i < N; ++i) {\n            S[i + 1] = S[i] + A[i];\n        }\n        return S;\n    }\n    \n\t/**\n\t * Sparse table initializes in O(N log N) time, but performs queries in O(1) time.\n\t * Queries must be performed on non-empty ranges within the table's range of [0, n).\n\t */\n\tpublic static class PrimitiveSparseTable {\n\t\t// Implement the value merge function.\n\t\tprivate static long merge(long a, long b) {\n            return a + b;\n\t\t}\n\n\t\tprivate long[][] table;\n\n\t\tpublic PrimitiveSparseTable(long[] a) {\n\t\t\tint n = a.length;\n\t\t\tint p = Math.max(1, Integer.SIZE - Integer.numberOfLeadingZeros(n));\n\n\t\t\tthis.table = new long[p][n];\n\t\t\tSystem.arraycopy(a, 0, this.table[0], 0, n);\n\t\t\tfor (int b = 1; b < p; b++) {\n\t\t\t\tint off = (1 << (b - 1));\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (i + off < n) {\n\t\t\t\t\t\tthis.table[b][i] = merge(this.table[b - 1][i], this.table[b - 1][i + off]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.table[b][i] = this.table[b - 1][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic long get(int lowerInclusive, int upperInclusive) {\n            if (upperInclusive < lowerInclusive) {\n                return 0;\n            }\n\t\t\tint k = 31 - Integer.numberOfLeadingZeros(upperInclusive - lowerInclusive + 1);\n\t\t\tint off = (1 << k);\n\t\t\treturn merge(table[k][lowerInclusive], table[k][upperInclusive - off + 1]);\n\t\t}\n\t}\n\n\t/**\n\t * Generic binary search to find the first or last value resulting in a matching condition.\n\t */\n\t// EXAMPLE USAGE (find insertion index in sorted array `A`):\n\t/*\n\t\tint insertionIndex = BinarySearch.firstThat(0, A.length, new BinarySearch.IntCheck() {\n\t\t\t@Override\n\t\t\tpublic boolean valid(int index) {\n\t\t\t\treturn A[index] > mid;\n\t\t\t}\n\t\t});\n\t */\n\tpublic static class BinarySearch {\n\t\t// Finds the left-most value that satisfies the IntCheck in the range [L, R).\n\t\t// It will return R if the nothing in the range satisfies the check.\n\t\tpublic static int firstThat(int L, int R, IntCheck check) {\n\t\t\twhile (L < R) {\n\t\t\t\tint M = (L >> 1) + (R >> 1) + (L & R & 1);\n\t\t\t\tif (check.valid(M)) {\n\t\t\t\t\tR = M;\n\t\t\t\t} else {\n\t\t\t\t\tL = M + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn L;\n\t\t}\n\n\t\t// Finds the right-most value that satisfies the IntCheck in the range [L, R).\n\t\t// It will return L - 1 if nothing in the range satisfies the check.\n\t\tpublic static int lastThat(int L, int R, IntCheck check) {\n\t\t\tint firstValue = firstThat(L, R, new IntCheck() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean valid(int value) {\n\t\t\t\t\treturn !check.valid(value);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn firstValue - 1;\n\t\t}\n\n\t\t// Finds the left-most value that satisfies the LongCheck in the range [L, R).\n\t\tpublic static long firstThat(long L, long R, LongCheck check) {\n\t\t\twhile (L < R) {\n\t\t\t\tlong M = (L >> 1) + (R >> 1) + (L & R & 1);\n\t\t\t\tif (check.valid(M)) {\n\t\t\t\t\tR = M;\n\t\t\t\t} else {\n\t\t\t\t\tL = M + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn L;\n\t\t}\n\n\t\t// Finds the right-most value that satisfies the IntCheck in the range [L, R).\n\t\t// It will return L - 1 if nothing in the range satisfies the check.\n\t\tpublic static long lastThat(long L, long R, LongCheck check) {\n\t\t\tlong firstValue = firstThat(L, R, new LongCheck() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean valid(long value) {\n\t\t\t\t\treturn !check.valid(value);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn firstValue - 1;\n\t\t}\n\n\t\tpublic static interface LongCheck {\n\t\t\tpublic boolean valid(long value);\n\t\t}\n\n\t\tpublic static interface IntCheck {\n\t\t\tpublic boolean valid(int value);\n\t\t}\n\t}\n}",
    "submit_ts": "1723952647",
    "subm_id": "1359801227"
}