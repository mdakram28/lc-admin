{
    "username": "SCodeCraft",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1e9 + 7;\n\nconst int MOD = 1e9 + 7;\nconst int MAX_INVERSIONS = 400; // Adjust as needed\n\ntemplate <const int T>\nstruct ModInt\n{\n    const static int mod = T;\n    int x;\n    int val() { return x; }\n    // ModInt(int x = 0) : x(x % mod) {}\n    ModInt(long long x) : x(int(x % mod)) {}\n    ModInt operator+(const ModInt &a) const\n    {\n        int x0 = x + a.x;\n        return ModInt(x0 < mod ? x0 : x0 - mod);\n    }\n    ModInt operator-(const ModInt &a) const\n    {\n        int x0 = x - a.x;\n        return ModInt(x0 < 0 ? x0 + mod : x0);\n    }\n    ModInt operator*(const ModInt &a) const { return ModInt(1ll * x * a.x % mod); }\n    ModInt operator/(const ModInt &a) const { return *this * a.inv(); }\n    void operator+=(const ModInt &a)\n    {\n        x += a.x;\n        if (x >= mod)\n            x -= mod;\n    }\n    void operator-=(const ModInt &a)\n    {\n        x -= a.x;\n        if (x < 0)\n            x += mod;\n    }\n    void operator*=(const ModInt &a) { x = 1LL * x * a.x % mod; }\n    void operator/=(const ModInt &a) { *this = *this / a; }\n    ModInt pow(int64_t n) const\n    {\n        ModInt res(1), mul(x);\n        while (n)\n        {\n            if (n & 1)\n                res *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return res;\n    }\n    ModInt inv() const\n    {\n        int a = x, b = mod, u = 1, v = 0;\n        while (b)\n        {\n            int t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        if (u < 0)\n            u += mod;\n        return u;\n    }\n};\ntypedef ModInt<mod> mint;\n\n#define ll long long\n\n\nclass Solution {\npublic:\n    int numberOfPermutations(int n, vector<vector<int>>& requirements) {\n        map<int, int> mp;\n        for (auto& r : requirements) {\n            mp[r[0] + 1] = r[1];\n        }\n\n        vector<vector<ll>> v(n + 1, vector<ll>(MAX_INVERSIONS + 1, 0));\n        v[0][0] = 1;\n\n        int k=0;\n\n        for (int i = 1; i <= n; ++i) {\n            k++;\n            for (int j = 0; j <= MAX_INVERSIONS; ++j) {\n                \n                \n                // lp for counting\n\n                if(j)\n                    for (int np = 0; np < i; ++np) {\n                        int prev = j - np;\n                        if (prev >= 0) {\n                            v[i][j] = (v[i][j] + v[i - 1][prev]) % MOD;\n                        }\n                    }\n                else{\n                    for (int np = 0; np < i; ++np) {\n                        int prev = j - np;\n                        if (prev >= 0) {\n                            v[i][j] = (v[i][j] + v[i - 1][prev]) % MOD;\n                        }\n                    }\n                }\n            }\n\n\n            if (mp.count(i)) {\n                int tar = mp[i];\n                for (int j = 0; j <= MAX_INVERSIONS; ++j) {\n                    if (j != tar) {\n                        v[i][j] = 0;\n                    }\n                }\n            }else{\n                k++;\n            }\n        }\n\n        mint result = 0;\n        for (ll it : v[n]) {\n            result += it ;\n        }\n\n        return result.x;\n    }\n};\n\n",
    "submit_ts": 1719071409.0
}