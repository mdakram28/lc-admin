{
    "username": "Homie_Lander7",
    "submission": "template <typename T>\nclass segtree\n{\npublic:\n    // 0 based indexing\n    // def= default value\n    vector<T> t;\n    int n;\n    T def;\n    function<T(T, T)> merge;\n    void build(int _n, T _def, function<T(T, T)> _fx)\n    {\n        n = _n;\n        def = _def;\n        merge = _fx;\n        t.assign(n * 2, def);\n        for (int i = n - 1; i; i--)\n            t[i] = merge(t[i * 2], t[i * 2 + 1]);\n    }\n    void build(vector<T> &a, T _def, function<T(T, T)> _fx)\n    {\n        n = a.size();\n        def = _def;\n        merge = _fx;\n        t.assign(n * 2, def);\n        for (int i = 0; i < n; i++)\n            t[i + n] = T(a[i]);\n        for (int i = n - 1; i; i--)\n            t[i] = merge(t[i * 2], t[i * 2 + 1]);\n    }\n    void update(int i, T v)\n    {\n        for (t[i += n] = T(v); i;)\n        {\n            i /= 2;\n            t[i] = merge(t[i * 2], t[i * 2 + 1]);\n        }\n    }\n    // this query is made on [l, r]\n    T query(int l, int r)\n    {\n        T lans = def, rans = def;\n        for (l += n, r += n + 1; l < r; l /= 2, r /= 2)\n        {\n            if (l % 2)\n                lans = merge(lans, t[l++]);\n            if (r % 2)\n                rans = merge(t[--r], rans);\n        }\n        return merge(lans, rans);\n    }\n};\nstruct node\n{\n    int val;\n    node(int x)\n    {\n        val = x;\n    }\n    // default value\n    node()\n    {\n        val = 0;\n    }\n};\nconst int maxn = 5e4 + 5;\nbool F = false;\nsegtree<node> st;\nclass Solution\n{\npublic:\n    vector<bool> getResults(vector<vector<int>> &queries)\n    {\n        auto merge = [](node a, node b) -> node\n        {\n            return node(max(a.val, b.val));\n        };\n        if (!F)\n        {\n            F = 1;\n            st.build(maxn, node(), merge);\n        }\n        vector<bool> ans;\n        set<int> pos;\n        pos.insert(0);\n        bool ch = 0;\n        for (auto &q : queries)\n        {\n            if (q[0] == 1)\n            {\n                ch = 1;\n                pos.insert(q[1]);\n                // update current\n                auto it = pos.lower_bound(q[1]);\n                if (it != pos.begin())\n                {\n                    st.update(q[1], q[1] - *prev(it));\n                }\n                // update next\n                it = pos.upper_bound(q[1]);\n                if (it != pos.end())\n                {\n                    st.update(*it, 0);\n                    st.update(*it, node(*it - q[1]));\n                }\n            }\n            else\n            {\n                bool ok = 0;\n                ok |= (st.query(0, q[1]).val >= q[2]);\n                // dbg(st.query(0, q[1]).val);\n                // dbg(q[1], q[2]);\n                auto it = pos.upper_bound(q[1]);\n                if (it != pos.begin())\n                {\n                    it--;\n                    ok |= (q[1] - *it >= q[2]);\n                }\n                ans.push_back(ok);\n            }\n        }\n        for (auto x : pos)\n        {\n            st.update(x, 0);\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716649871.0
}