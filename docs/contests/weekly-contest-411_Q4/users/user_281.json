{
    "username": "Laughing Paredpy",
    "submission": "class Solution {\n    long[] lazy;\n    public long[] countKConstraintSubstrings(String s, int k, int[][] queries) {\n        int n = s.length();\n        int l = 0, r = 0;\n        int cnt1 = 0, cnt2 = 0;\n        long[] memo = new long[n << 2];\n        lazy = new long[n << 2];\n        long[] q = new long[queries.length];\n        Map<Integer, List<int[]>> map = new HashMap<>();\n        for (int i = 0; i < queries.length; i++) {\n            map.computeIfAbsent(queries[i][1], e -> new ArrayList<int[]>()).add(new int[]{i, queries[i][0]});\n        }\n        // int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '0') {\n                cnt1++;\n            } else {\n                cnt2++;\n            }\n            if (cnt1 > k) {\n                while (s.charAt(l) != '0') {\n                    l++;\n                }\n                cnt1--;\n                l++;\n            }\n            if (cnt2 > k) {\n                while (s.charAt(r) != '1') {\n                    r++;\n                }\n                r++;\n                cnt2--;\n            }\n            int pre = Math.min(l, r);\n            update(memo, 0, 0, n - 1, pre, i);\n            if (map.containsKey(i)) {\n                List<int[]> list = map.get(i);\n                for (int[] ch : list) {\n                    q[ch[0]] = query(memo, 0, 0, n - 1, ch[1], i);\n                }\n            }\n            // res += i - Math.min(l, r) + 1;\n            // System.out.println(l + \"&\" + r + \"%\" + memo[0] + \"&&\" + res + \"$$$\" + pre);\n\n        }       \n        return q;\n    }\n    public long query(long[] memo, int cur, int s, int e, int l, int r) {\n        if (s >= l && e <= r) {\n            return memo[cur];\n        }\n        updown(cur, memo, s, e);\n        int mid = (s + e) >> 1;\n        long res = 0;\n        if (mid >= l) {\n            res += query(memo, cur * 2 + 1, s, mid, l, r);\n        }\n        if (mid < r) {\n            res += query(memo, cur * 2 + 2, mid + 1, e, l, r);\n        }\n        return res;\n    }\n    public void updown(int cur, long[] memo, int s, int e) {\n        int mid = (s + e) >> 1;\n        if (lazy[cur] != 0) {\n            memo[cur * 2 + 1] += lazy[cur] * (mid - s + 1);\n            memo[cur * 2 + 2] += lazy[cur] * (e - mid);\n            lazy[cur * 2 + 1] += lazy[cur];\n            lazy[cur * 2 + 2] += lazy[cur];\n            lazy[cur] = 0;\n        }\n    }\n    public void update(long[] memo, int cur, int s, int e, int l, int r) {\n        if (s >= l && e <= r) {\n            memo[cur] += e - s + 1;\n            lazy[cur]++;\n            return;\n        }\n        updown(cur, memo, s, e);\n        int mid = (s + e) >> 1;\n        if (mid >= l) {\n            update(memo, cur * 2 + 1, s, mid, l, r);\n        }\n        if (mid < r) {\n            update(memo, cur * 2 + 2, mid + 1, e, l, r);\n        }\n        memo[cur] = memo[cur * 2 + 1] + memo[cur * 2 + 2];\n    }\n}",
    "submit_ts": "1723952715",
    "subm_id": "556413248"
}