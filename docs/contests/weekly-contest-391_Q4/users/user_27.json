{
    "username": "endlesscheng",
    "submission": "package main\n\nimport \"time\"\n\n// https://space.bilibili.com/206214\ntype node struct {\n\tlr       [2]*node\n\tpriority uint\n\tkey      int\n\tkeyCnt   int\n\tsubCnt   int\n}\n\nfunc (o *node) size() int {\n\tif o != nil {\n\t\treturn o.subCnt // \u6c47\u603b\n\t}\n\treturn 0\n}\n\nfunc (o *node) maintain() {\n\to.subCnt = o.keyCnt + o.lr[0].size() + o.lr[1].size()\n}\n\nfunc (o *node) rotate(d int) *node {\n\tx := o.lr[d^1]\n\to.lr[d^1] = x.lr[d]\n\tx.lr[d] = o\n\to.maintain()\n\tx.maintain()\n\treturn x\n}\n\ntype treap struct {\n\trd   uint\n\troot *node\n}\n\nfunc (t *treap) fastRand() uint {\n\tt.rd ^= t.rd << 13\n\tt.rd ^= t.rd >> 17\n\tt.rd ^= t.rd << 5\n\treturn t.rd\n}\n\nfunc (t *treap) size() int { return t.root.size() }\n\nfunc (t *treap) _put(o *node, key int) *node {\n\tif o == nil {\n\t\to = &node{priority: t.fastRand(), key: key, keyCnt: 1}\n\t} else if d := o.cmp(key); d >= 0 {\n\t\to.lr[d] = t._put(o.lr[d], key)\n\t\tif o.lr[d].priority > o.priority {\n\t\t\to = o.rotate(d ^ 1)\n\t\t}\n\t} else {\n\t\to.keyCnt++\n\t}\n\to.maintain()\n\treturn o\n}\n\nfunc (t *treap) put(key int) { t.root = t._put(t.root, key) }\n\nfunc (t *treap) _delete(o *node, key int) *node {\n\tif o == nil {\n\t\treturn nil\n\t}\n\tif d := o.cmp(key); d >= 0 {\n\t\to.lr[d] = t._delete(o.lr[d], key)\n\t} else {\n\t\tif o.keyCnt > 1 {\n\t\t\to.keyCnt--\n\t\t} else {\n\t\t\tif o.lr[1] == nil {\n\t\t\t\treturn o.lr[0]\n\t\t\t}\n\t\t\tif o.lr[0] == nil {\n\t\t\t\treturn o.lr[1]\n\t\t\t}\n\t\t\td = 0\n\t\t\tif o.lr[0].priority > o.lr[1].priority {\n\t\t\t\td = 1\n\t\t\t}\n\t\t\to = o.rotate(d)\n\t\t\to.lr[d] = t._delete(o.lr[d], key)\n\t\t}\n\t}\n\to.maintain()\n\treturn o\n}\n\nfunc (t *treap) delete(key int) { t.root = t._delete(t.root, key) }\n\nfunc newTreap() *treap { return &treap{rd: uint(time.Now().UnixNano())/2 + 1} }\n\nfunc (o *node) cmp(a int) int {\n\tb := o.key\n\tif a == b {\n\t\treturn -1\n\t}\n\tif a < b {\n\t\treturn 0\n\t}\n\treturn 1\n}\n\nfunc (t *treap) get(key int) *node {\n\tfor o := t.root; o != nil; {\n\t\tif c := o.cmp(key); c >= 0 {\n\t\t\to = o.lr[c]\n\t\t} else {\n\t\t\treturn o\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (t *treap) min() (min *node) {\n\tfor o := t.root; o != nil; o = o.lr[0] {\n\t\tmin = o\n\t}\n\treturn\n}\n\nfunc (t *treap) max() (max *node) {\n\tfor o := t.root; o != nil; o = o.lr[1] {\n\t\tmax = o\n\t}\n\treturn\n}\n\nfunc minimumDistance(ps [][]int) (ans int) {\n\ttx := newTreap()\n\tty := newTreap()\n\tfor _, p := range ps {\n\t\tv, w := p[0], p[1]\n\t\tx, y := v+w, w-v\n\t\ttx.put(x)\n\t\tty.put(y)\n\t}\n\tans = 1e18\n\tfor _, p := range ps {\n\t\tv, w := p[0], p[1]\n\t\tx, y := v+w, w-v\n\t\ttx.delete(x)\n\t\tty.delete(y)\n\t\t\n\t\tres := max(tx.max().key - tx.min().key,ty.max().key - ty.min().key )\n\t\tans = min(ans, res)\n\t\ttx.put(x)\n\t\tty.put(y)\n\t}\n\treturn\n}\n"
}