{
    "username": "DCXiaoBing",
    "submission": "class Solution {\n  // abs of diff equal for symmatric idx\n  \n  // get frequency of existing diff, make them equal?\n  // but the max of new diff is from 0~k\n  \n  // if all diff is same, then good\n  // if there is one different diff, target would be the most frequent diff in 0~k\n  \n  // given a target, find op  --> n^2\n  // and some target has less frequent but have more 1 op change, and final result will be smaller.\n  // \n  \n  // wait, why there is a constraint of nums[i] <= k\n  // \n  \n  // bucket sort? nope, because we care about idx\n  // 1~1e5\n  public int minChanges(int[] nums, int k) {\n    int n = nums.length;\n    \n    HashMap<Integer, Integer> fre = new HashMap<>();\n    for (int i = 0; i < n / 2; i++) {\n      int diff = Math.abs(nums[i] - nums[n - 1 - i]);\n      fre.put(diff, fre.getOrDefault(diff, 0) + 1);\n    }\n    \n    if (fre.size() == 1) return 0; // all same\n    \n    int res = (int)1e5;\n    for (int target : fre.keySet()) {\n      int f = fre.get(target);\n      if ((n / 2 - f) >= res) continue;\n      \n      res = Math.min(res, helper(nums, target, k));\n    }\n    return res;\n  } \n  \n  private int helper(int[] nums, int target, int k) {\n    int n = nums.length;\n    \n   // change\n    int res = 0;\n    for (int i = 0; i < n / 2; i++) {\n      int diff = Math.abs(nums[i] - nums[n - 1 - i]);\n      if (diff == target) continue;\n      \n      // one op change\n      int l = Math.min(nums[i], nums[n - 1 - i]), r = Math.max(nums[i], nums[n - 1 - i]);\n      if (r - target >= 0 || l + target <= k) {\n        res++;\n        continue;\n      } \n      \n      // two op change\n      res += 2;\n    }\n    \n    return res;\n  }\n}",
    "submit_ts": "1721487652",
    "subm_id": "1327396271"
}