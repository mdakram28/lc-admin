{
    "username": "nine-9u",
    "submission": "public class Solution {\n        public long MinimumOperations(int[] nums, int[] target)\n        {\n            int[] diff = new int[nums.Length];\n            for (int i = 0; i < nums.Length; i++)\n            {\n                diff[i] = nums[i] - target[i];\n            }\n            long ans = 0;\n            SegmentTreeMin segmentTree = new SegmentTreeMin(diff.Length);\n            segmentTree.Build(diff);\n            for (int i = 0; i < diff.Length; i++)\n            {\n                if (diff[i] == 0)\n                    continue;\n                int j = i;\n                int max = Math.Abs(diff[i]);\n                int min = Math.Abs(diff[j]);\n                if (diff[i] > 0)\n                {\n                    while (j + 1 < diff.Length && diff[j + 1] > 0)\n                    {\n                        j++;\n                        max = Math.Max(max, Math.Abs(diff[j]));\n                    }\n                }\n                if (diff[i] < 0)\n                {\n                    while (j + 1 < diff.Length && diff[j + 1] < 0)\n                    {\n                        j++;\n                        max = Math.Max(max, Math.Abs(diff[j]));\n                    }\n                }\n                ans += f(i, j, i, j, 0);\n                i = j;\n            }\n            return ans;\n            long f(int left, int right, int curLeft, int curRight,int baseData)\n            {\n                if (curRight - curLeft <= 1)\n                {\n                    return Math.Max(Math.Abs(diff[curLeft]), Math.Abs(diff[curRight])) - baseData;\n                }\n                var min = segmentTree.QueryMin(curLeft, curRight);\n                var max = segmentTree.QueryMax(curLeft, curRight);\n                var score = min.min - baseData;\n\n                if (min.index == curLeft)\n                    return f(left, right, min.index + 1, curRight, min.min) + score;\n                if(min.index == curRight)\n                    return f(left, right, curLeft, min.index - 1, min.min) + score;\n                return f(left, right, curLeft, min.index - 1, min.min) + f(left, right, min.index + 1, curRight, min.min) + score;\n            }\n        }\n        public class SegmentTreeMin\n        {\n            private (int min, int index)[] min;\n            private int[] max;\n            private int n;\n\n            public SegmentTreeMin(int n)\n            {\n                this.n = n;\n                min = new (int min, int index)[n << 2];\n                max = new int[n << 2];\n            }\n\n            public void Build(int[] nums)\n            {\n                Build(1, n, 1, nums);\n            }\n            public (int min, int index) QueryMin(int left, int right)\n            {\n                return QueryMin(1, 1, n, left + 1, right + 1);\n            }\n            public int QueryMax(int left, int right)\n            {\n                return QueryMax(1, 1, n, left + 1, right + 1);\n            }\n            private (int min, int index) QueryMin(int nodeIndex, int left, int right, int arrayLeft, int arrayRight)\n            {\n                if (arrayLeft <= left && right <= arrayRight)\n                {\n                    return (min[nodeIndex]);\n                }\n                int mid = left + (right - left) / 2;\n                int leftNodeIndex = nodeIndex << 1;\n                int rightNodeIndex = leftNodeIndex + 1;\n                (int min, int index) ans = default;\n                bool init = false;\n                // \u6709\u4e00\u90e8\u5206\u5728\u5de6\u8fb9\u7684\u533a\u95f4\u4e0a\n                if (arrayLeft <= mid)\n                {\n                    ans = QueryMin(leftNodeIndex, left, mid, arrayLeft, arrayRight);\n                    init = true;\n                }\n                // \u6709\u4e00\u90e8\u5206\u5728\u53f3\u8fb9\u7684\u533a\u95f4\u4e0a\n                if (arrayRight > mid)\n                {\n                    var rightAns = QueryMin(rightNodeIndex, mid + 1, right, arrayLeft, arrayRight);\n                    if (init)\n                    {\n                        if (ans.min > rightAns.min)\n                        {\n                            ans = rightAns;\n                        }\n                    }\n                    else\n                    {\n                        ans = rightAns;\n                    }\n                }\n                return ans;\n            }\n            private int QueryMax(int nodeIndex, int left, int right, int arrayLeft, int arrayRight)\n            {\n                if (arrayLeft <= left && right <= arrayRight)\n                {\n                    return max[nodeIndex];\n                }\n                int mid = left + (right - left) / 2;\n                int leftNodeIndex = nodeIndex << 1;\n                int rightNodeIndex = leftNodeIndex + 1;\n                int ans = 0;\n                // \u6709\u4e00\u90e8\u5206\u5728\u5de6\u8fb9\u7684\u533a\u95f4\u4e0a\n                if (arrayLeft <= mid)\n                {\n                    ans = QueryMax(leftNodeIndex, left, mid, arrayLeft, arrayRight);\n                }\n                // \u6709\u4e00\u90e8\u5206\u5728\u53f3\u8fb9\u7684\u533a\u95f4\u4e0a\n                if (arrayRight > mid)\n                {\n                    ans = Math.Max(ans, QueryMax(rightNodeIndex, mid + 1, right, arrayLeft, arrayRight));\n                }\n                return ans;\n            }\n\n\n            private void Build(int left, int right, int index, int[] nums)\n            {\n                if (left == right)\n                {\n                    min[index] = (Math.Abs(nums[left - 1]), left - 1);\n                    max[index] = Math.Abs(nums[left - 1]);\n                }\n                else\n                {\n                    int mid = left + (right - left) / 2;\n                    Build(left, mid, index << 1, nums);\n                    Build(mid + 1, right, index << 1 | 1, nums);\n                    min[index] = min[index << 1];\n                    max[index] = Math.Max(max[index << 1], max[index << 1 | 1]);\n                    if (min[index].min > min[index << 1 | 1].min)\n                    {\n                        min[index] = min[index << 1 | 1];\n                    }\n                }\n            }\n        }\n\n\n}",
    "submit_ts": "1721533771",
    "subm_id": "548400916"
}