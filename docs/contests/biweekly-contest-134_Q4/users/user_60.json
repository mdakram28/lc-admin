{
    "username": "N_E_E_R_A_J",
    "submission": "const char fastio = [](){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    return 0;\n}();\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define ALL(iterable) (iterable).begin(), (iterable).end()\n#define RALL(iterable) (iterable).rbegin(), (iterable).rend()\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define ROUND(x) (((x) >= 0) ? (ll)((x) + 0.5) : (ll)((x) - 0.5))\n#define DEBUG(...) cout << \"[DEBUG-\" << __LINE__ << \"]:\"; debug_cout(__VA_ARGS__);\n\nshort dx4[] = {-1, 0, 1, 0};\nshort dy4[] = {0, 1, 0, -1};\n\nshort dx8[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nshort dy8[] = {-1, 0, 1, 1, 1, 0, -1, -1};\n\nshort kx[] = {2, 1, -1, -2, -2, -1, 1, 2};\nshort ky[] = {1, 2, 2, 1, -1, -2, -2, -1};\n\ntemplate<typename T>\nvoid debug_cout(const T& arg) {\n    cout << \" \" << arg;\n}\n\ntemplate<typename T, typename... Args>\nvoid debug_cout(const T& firstArg, const Args&... args) {\n    cout << \" \" << firstArg;\n    debug_cout(args...);\n}\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, pair<T1, T2> &p)\n{\n    out << \"(\" << p.first << \",\" << p.second << \")\";\n    return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, vector<T> &vec)\n{\n    out << \"[\";\n    for (auto it = vec.begin(); it != vec.end(); ++it)\n    {\n        if (it != vec.begin())\n            out << \",\";\n        out << *it;\n    }\n    out << \"]\";\n    return out;\n}\n\nclass Segment_Tree\n{\nprivate:\n    vector<int> seg_tree;\n    int arr_size;\n\n    void buildUtil(int low, int high, int seg_index, vector<int> const &arr)\n    {\n        if (low == high)\n        {\n            seg_tree[seg_index] = arr[low];\n            return;\n        }\n\n        int mid = low + (high - low) / 2;\n        buildUtil(low, mid, 2 * seg_index + 1, arr);\n        buildUtil(mid + 1, high, 2 * seg_index + 2, arr);\n        seg_tree[seg_index] = seg_tree[2 * seg_index + 1] & seg_tree[2 * seg_index + 2];\n    }\n\n    void assign(int low, int high, int seg_index, int index, int value)\n    {\n        if (low == high)\n        {\n            seg_tree[seg_index] = value;\n            return;\n        }\n\n        int mid = low + (high - low) / 2;\n        if (index >= low && index <= mid)\n            assign(low, mid, 2 * seg_index + 1, index, value);\n        else\n            assign(mid + 1, high, 2 * seg_index + 2, index, value);\n\n        seg_tree[seg_index] = seg_tree[2 * seg_index + 1] & seg_tree[2 * seg_index + 2];\n    }\n\n    void increment(int low, int high, int seg_index, int index, int value)\n    {\n        if (low == high)\n        {\n            seg_tree[seg_index] += value;\n            return;\n        }\n\n        int mid = low + (high - low) / 2;\n        if (index >= low && index <= mid)\n            increment(low, mid, 2 * seg_index + 1, index, value);\n        else\n            increment(mid + 1, high, 2 * seg_index + 2, index, value);\n\n        seg_tree[seg_index] = seg_tree[2 * seg_index + 1] & seg_tree[2 * seg_index + 2];\n    }\n\n    int queryUtil(int low, int high, int seg_index, int start, int end)\n    {\n        if (start <= low && end >= high)\n            return seg_tree[seg_index];\n\n        if (start > high || end < low)\n            return -1;\n\n        int mid = low + (high - low) / 2;\n        int left = queryUtil(low, mid, 2 * seg_index + 1, start, end);\n        int right = queryUtil(mid + 1, high, 2 * seg_index + 2, start, end);\n        return left & right;\n    }\n\npublic:\n    Segment_Tree(vector<int> const &arr)\n    {\n        build(arr);\n    }\n\n    void build(vector<int> const &arr)\n    {\n        arr_size = arr.size();\n        seg_tree.resize(4 * arr_size + 1);\n        buildUtil(0, arr_size - 1, 0, arr);\n    }\n\n    void assign(int index, int value)\n    {\n        assign(0, arr_size - 1, 0, index, value);\n    }\n\n    void increment(int index, int value)\n    {\n        increment(0, arr_size - 1, 0, index, value);\n    }\n\n    int query(int start, int end)\n    {\n        if (start > end)\n            return -1;\n\n        return queryUtil(0, arr_size - 1, 0, start, end);\n    }\n};\n\nclass Solution {\nprivate:\n    int lowerBound(Segment_Tree &st, int low, int high, const int k)\n    {\n        int Olow = low, index = -1;\n        while (low <= high)\n        {\n            int mid = low + (high - low) / 2;\n            \n            int v = st.query(Olow, mid);\n            if (v <= k)\n            {\n                index = mid;\n                high = mid - 1;\n            }\n            else\n                low = mid + 1;\n        }\n        \n        if (st.query(Olow, index) == k)\n            return index;\n        \n        return -1;\n    }\n    \n    int upperBound(Segment_Tree &st, int low, int high, const int k)\n    {\n        int Olow = low, index = -1;\n        while (low <= high)\n        {\n            int mid = low + (high - low) / 2;\n            \n            int v = st.query(Olow, mid);\n            if (v >= k)\n            {\n                index = mid;\n                low = mid + 1;\n            }\n            else\n                high = mid - 1;\n        }\n        \n        if (st.query(Olow, index) == k)\n            return index;\n        \n        return -1;\n    }\n\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        Segment_Tree st(nums);\n        ll count = 0;\n        int n = nums.size();\n        for (int i = 0; i < n; i++)\n        {\n            ll l = lowerBound(st, i, n - 1, k);\n            ll h = upperBound(st, i, n - 1, k);\n            \n            if (l == -1 || h == -1)\n                continue;\n\n            count += h - l + 1;\n        }\n        \n        return count;\n    }\n};",
    "submit_ts": "1720277650",
    "subm_id": "1311673572"
}