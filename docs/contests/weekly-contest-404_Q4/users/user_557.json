{
    "username": "XAXAEBATb",
    "submission": "\n\nvoid dfs(vector <int>& sz, vector <vector<int>>& g, int v)\n{\n\tsz[v] = 1;\n\tfor (int u : g[v]) {\n\t\tif (sz[u] != 0) continue;\n\t\tdfs(sz, g, u);\n\t\tsz[v] += sz[u];\n\t}\n}\n\nint getCentroid(vector <int>& sz, vector <vector<int>>& g, int v) //v - any vertex of tree\n{\n\tdfs(sz, g, v);\n\twhile(true) {\n\t\tint w = -1;\n\t\tfor (int u : g[v]) {\n\t\t\tif (sz[u] > sz[v]) continue;\n\t\t\tif (2 * sz[u] >= g.size()) {\n\t\t\t\tw = u;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (w == -1) break;\n\t\tv = w;\n\t}\n\treturn v;\n}\n\nvector<int> getCentroids(vector <int>& sz, vector <vector<int>>& g, int v) //v - any vertex of tree\n{\n    vector <int> sz1(g.size());\n\tv = getCentroid(sz1, g, v);\n\tvector<int> res;\n    sz1.resize(0);\n    sz1.resize(g.size());\n    dfs(sz1, g, v);\n\tres.push_back(v);\n\tfor (int u : g[v]) {\n        //cout<<\"!\"<<sz1[u]<<\"\\n\";\n\t\tif (2 * sz1[u] == g.size())\n\t\t\tres.push_back(u);\n\t}\n\treturn res;\n}\n\nstd::vector<int> centers(const std::vector<std::vector<int>>& g) {\n    int n = g.size();\n    if (n==0) return {};\n    if (n==1) return {0};\n    std::vector<int> degree(n, 0);\n    std::vector<int> leaves;\n    \n    // Compute the degree of each node\n    for (int i = 0; i < n; ++i) {\n        degree[i] = g[i].size();\n        if (degree[i] == 1) {\n            leaves.push_back(i);\n        }\n    }\n\n    int processed = leaves.size();\n    while (processed < n) {\n        std::vector<int> new_leaves;\n        for (int leaf : leaves) {\n            for (int neighbor : g[leaf]) {\n                --degree[neighbor];\n                if (degree[neighbor] == 1) {\n                    new_leaves.push_back(neighbor);\n                }\n            }\n            --degree[leaf]; // Mark leaf as removed\n        }\n        processed += new_leaves.size();\n        leaves = std::move(new_leaves);\n    }\n\n    return leaves;\n}\n\n\nvoid ddd(const vector<vector<int>>& g, int node, int parent, int depth, int& maxDepth, int& furthestNode) {\n    if (depth > maxDepth) {\n        maxDepth = depth;\n        furthestNode = node;\n    }\n    for (int neighbor : g[node]) {\n        if (neighbor != parent) {\n            ddd(g, neighbor, node, depth + 1, maxDepth, furthestNode);\n        }\n    }\n}\n\n// Function to calculate the diameter of an undirected tree\nint diameter(const vector<vector<int>>& g) {\n    int n = g.size();\n    if (n == 0) return 0;  // Empty graph\n    if (n == 1) return 0;  // A single node's diameter is 0\n\n    // Perform the first DFS to find the furthest node from node 0\n    int furthestNodeA = 0;\n    int maxDepthA = 0;\n    ddd(g, 0, -1, 0, maxDepthA, furthestNodeA);\n\n    // Perform the second DFS from furthestNodeA to find the maximum distance\n    int furthestNodeB = 0;\n    int maxDepthB = 0;\n    ddd(g, furthestNodeA, -1, 0, maxDepthB, furthestNodeB);\n\n    // The maximum depth found in the second DFS is the diameter of the tree\n    return maxDepthB;\n}\n\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int a = 0;\n        int b = 0;\n        for (auto& gg:edges1) {\n            a = max(a, gg[0]);\n            a = max(a, gg[1]);\n        }\n        for (auto& gg:edges2) {\n            b = max(b, gg[0]);\n            b = max(b, gg[1]);\n        }\n        a++; b++; \n        vector <int> sz1(a);\n        vector <int> sz2(b);\n        vector <vector<int>> gg1(a);\n        vector <vector<int>> gg2(b);\n        for (auto& gg:edges1) {\n            gg1[gg[0]].push_back(gg[1]);\n            gg1[gg[1]].push_back(gg[0]);\n        }\n        for (auto& gg:edges2) {\n            gg2[gg[0]].push_back(gg[1]);\n            gg2[gg[1]].push_back(gg[0]);\n        }\n        \n\n        vector <int> p1 = centers(gg1);\n        vector <int> p2 = centers(gg2);\n        int ans = a + b;\n        for (auto& i1:p1) {\n            for (auto& i2:p2) {\n                int q = a+b;\n                //vector <int> sz1(q);\n                vector <vector<int>> g1(q);\n                for (int i =0;i<a;i++) {\n                    for (auto& c:gg1[i]) {\n                        g1[i].push_back(c);\n                    }\n                }\n                for (int i =0;i<b;i++) {\n                    for (auto& c:gg2[i]) {\n                        g1[i+a].push_back(c+a);\n                    }\n                }\n                g1[i1].push_back(i2+a);\n                g1[i2+a].push_back(i1);\n                cout<<i1<<\" \"<<i2<<\" \"<<diameter(g1)<<\"\\n\";\n                ans = min(ans, diameter(g1));\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1719718502.0
}