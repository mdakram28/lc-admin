{
    "username": "its_Kafka",
    "submission": "from collections import deque\nimport math\n\nclass Solution:\n    def create_graph(self, X, Y, circles):\n        num_circles = len(circles)\n        graph = [[] for _ in range(num_circles + 4)]\n        \n        for i in range(num_circles):\n            self.connect_circle_to_borders(graph, circles[i], X, Y, i, num_circles)\n            self.connect_overlapping_circles(graph, circles, i, num_circles)\n        \n        return graph\n\n    def connect_circle_to_borders(self, graph, circle, X, Y, i, num_circles):\n        x, y, r = circle\n        if x <= r:  # Touching left border\n            self.add_edge(graph, num_circles, i)\n        if X - x <= r:  # Touching right border\n            self.add_edge(graph, num_circles + 2, i)\n        if y <= r:  # Touching bottom border\n            self.add_edge(graph, num_circles + 1, i)\n        if Y - y <= r:  # Touching top border\n            self.add_edge(graph, num_circles + 3, i)\n\n    def connect_overlapping_circles(self, graph, circles, i, num_circles):\n        for j in range(i + 1, num_circles):\n            if self.circles_overlap(circles[i], circles[j]):\n                self.add_edge(graph, i, j)\n\n    def circles_overlap(self, circle1, circle2):\n        x1, y1, r1 = circle1\n        x2, y2, r2 = circle2\n        distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n        return r1 + r2 >= distance\n\n    def add_edge(self, graph, u, v):\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def bfs(self, graph, start, target1, target2, nodes):\n        q = deque([start])\n        visited = [False] * nodes\n        visited[start] = True\n        \n        while q:\n            u = q.popleft()\n            for v in graph[u]:\n                if not visited[v]:\n                    q.append(v)\n                    visited[v] = True\n        return visited[target1] or visited[target2]\n\n    def check_corners_reachable(self, graph, num_circles):\n        is_blocked = False\n        is_blocked |= self.bfs(graph, num_circles, num_circles + 1, num_circles + 2, num_circles + 4)  # \n        is_blocked |= self.bfs(graph, num_circles + 3, num_circles + 2, num_circles + 1, num_circles + 4)  \n        return not is_blocked\n\n    def canReachCorner(self, X, Y, circles):\n        circles = [(x[0], x[1], x[2]) for x in circles]\n        graph = self.create_graph(X, Y, circles)\n        return self.check_corners_reachable(graph, len(circles))",
    "submit_ts": "1722138648",
    "subm_id": "1335796151"
}