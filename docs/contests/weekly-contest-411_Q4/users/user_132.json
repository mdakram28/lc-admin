{
    "username": "Superultra",
    "submission": "#include <bits/stdc++.h>\nusing namespace std; \n\n#define ll long long\n#define FOR(i, x, y) for (int i = x; i < y; i++)\n\nstruct lzObj{\n    ll add = 0, times = 0;\n};\n\ntemplate<class T> struct BIT{ //REMEMBER TO INIT\n    int N; vector<T> bit;\n    void init(int N_){ N = N_; bit.assign(N + 5, 0); }\n    void upd(int i, T val){ for (; i <= N; i += i & (-i)) bit[i] += val; }\n    void rupd(int l, int r, T val){ upd(l, val); upd(++r, -val); }\n    T qry(int i){\n        T ret = 0;\n        for (; i > 0; i -= i & (-i)) ret += bit[i];\n        return ret;\n    }\n    T qry(int l, int r){ return qry(r) - qry(l - 1); }\n    int lb(T val){\n        int pos = 0;\n        for (int pw = (1 << 25); pw; pw /= 2)\n            if (pos + pw <= N and bit[pos + pw] < val)\n                pos += pw, val -= bit[pos];\n        return ++pos;\n    }\n};\n\n// Taken from my cses solution\nstruct polyAdd{\n    vector<ll> seg;\n    vector<lzObj> lz;\n    int sz;\n\n    void init(int sz_){\n        sz = sz_;\n        seg.assign(sz * 4 + 5, 0);\n        lz.assign(sz * 4 + 5, {0, 0});\n    }\n    ll summation(int l, int r){\n        return (ll)r * (r + 1) / 2 - (ll)(l - 1) * l / 2;\n    }\n    void push(int l, int r, int i){\n        seg[i] += lz[i].add * (r - l + 1) + lz[i].times * summation(l, r);\n        if (l != r){\n            for (int c : {2 * i, 2 * i + 1}){\n                lz[c].add += lz[i].add;\n                lz[c].times += lz[i].times;\n            }\n        }\n        lz[i] = {};\n    }\n    void upd(int ql, int qr, int st, int l, int r, int i){\n        push(l, r, i);\n        if (l > qr or r < ql) return;\n        if (l >= ql and r <= qr){ \n            lz[i].add -= st - 1;\n            lz[i].times++;\n            push(l, r, i); \n            return; \n        }\n        int mid = (l + r) / 2;\n        upd(ql, qr, st, l, mid, i * 2); upd(ql, qr, st, mid + 1, r, i * 2 + 1);\n        seg[i] = seg[i * 2] + seg[i * 2 + 1];\n    }\n    ll qry(int ql, int qr, int l, int r, int i){\n        push(l, r, i);\n        if (l > qr or r < ql) return 0;\n        if (l >= ql and r <= qr) return seg[i];\n        int mid = (l + r) / 2; \n        return qry(ql, qr, l, mid, i * 2) + qry(ql, qr, mid + 1, r, i * 2 + 1);\n    }\n    void upd(int ql, int qr, int st){\n        upd(ql, qr, st, 1, sz, 1);\n    }\n    ll qry(int ql, int qr){\n        return qry(ql, qr, 1, sz, 1);\n    }\n};\n\nclass Solution {\npublic:\n    vector<long long> countKConstraintSubstrings(string S, int k, vector<vector<int>>& Q) {\n        int n = S.size();\n        S = \" \" + S;\n\n        vector<int> P(n + 5, 0);\n\n        FOR(i, 1, n + 1){\n            P[i] = P[i - 1] + (S[i] - '0');\n        }\n\n        polyAdd seg;\n        BIT<ll> bit;\n        seg.init(n + 5);\n        bit.init(n + 5);\n\n        vector<ll> ans(Q.size());\n        vector<pair<int, int>> off[n + 5];\n\n        for (int i = 0; i < Q.size(); i++){\n            int l = Q[i][0] + 1;\n            int r = Q[i][1] + 1;\n\n            off[l].push_back({r, i});\n        }\n\n        for (int l = n, r = n; l >= 1; l--){\n            while (P[r] - P[l - 1] > k and (r - l + 1) - (P[r] - P[l - 1]) > k)\n                r--;\n\n            seg.upd(l, r, l);\n            bit.rupd(r + 1, n + 1, r - l + 1);\n\n            // cout << l << \" \" << r << endl;\n            // cout << \"bit: \" << r + 1 << \" \" << n + 1 << \" \" << r - l + 1 << endl;\n            \n            for (auto [qr, id] : off[l]){\n                ans[id] = seg.qry(qr, qr) + bit.qry(qr);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1723950133",
    "subm_id": "1359738063"
}