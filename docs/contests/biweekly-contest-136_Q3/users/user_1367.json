{
    "username": "prathameshdshinde53",
    "submission": "class Solution {\npublic:\n    int minFlips(vector<vector<int>>& grid) {\n          int totalRows = grid.size();     // Total number of rows in the grid\n        int totalCols = grid[0].size();  // Total number of columns in the grid\n        int minFlips = 0;                // Initialize the total flips required\n\n        // Handle the case where the grid has an odd number of rows and columns\n        // Specifically, address the center cell\n        if (totalRows % 2 == 1 && totalCols % 2 == 1) {\n            if (grid[totalRows / 2][totalCols / 2] == 1) {\n                minFlips += 1;  // Increment flips if the central cell is 1\n            }\n        }\n\n        // Array to track the count of flips needed based on sum of paired elements\n        vector<int> flipCounts(3, 0);\n\n        // Calculate flips needed for middle row if the number of rows is odd\n        if (totalRows % 2 == 1) {\n            int leftIndex = 0;\n            int rightIndex = totalCols - 1;\n            while (leftIndex < rightIndex) {\n                int sum = grid[totalRows / 2][leftIndex] + grid[totalRows / 2][rightIndex];\n                flipCounts[sum] += 1;  // Update count based on sum of paired elements\n                ++leftIndex;\n                --rightIndex;\n            }\n        }\n\n        // Calculate flips needed for middle column if the number of columns is odd\n        if (totalCols % 2 == 1) {\n            int topIndex = 0;\n            int bottomIndex = totalRows - 1;\n            while (topIndex < bottomIndex) {\n                int sum = grid[topIndex][totalCols / 2] + grid[bottomIndex][totalCols / 2];\n                flipCounts[sum] += 1;  // Update count based on sum of paired elements\n                ++topIndex;\n                --bottomIndex;\n            }\n        }\n\n        // Adjust the minimum flips based on the counts of needed flips\n        if (flipCounts[2] % 2 == 1) {\n            if (flipCounts[1] > 0) {\n                minFlips += flipCounts[1];  // Use existing flips if available\n            } else {\n                minFlips += 2;  // If no flips are available, increment by 2\n            }\n        } else {\n            minFlips += flipCounts[1];  // Add the number of flips needed for 1s\n        }\n\n        // Process each 4-way symmetric cell group to calculate additional flips\n        for (int row = 0; row < totalRows / 2; ++row) {\n            for (int col = 0; col < totalCols / 2; ++col) {\n                int topLeft = grid[row][col];\n                int topRight = grid[row][totalCols - 1 - col];\n                int bottomLeft = grid[totalRows - 1 - row][col];\n                int bottomRight = grid[totalRows - 1 - row][totalCols - 1 - col];\n\n                int sum = topLeft + topRight + bottomLeft + bottomRight;\n\n                // Add the minimum flips required to make the 4-way symmetric cells consistent\n                if (sum != 0 && sum != 4) {\n                    minFlips += min(sum, 4 - sum);\n                }\n            }\n        }\n\n        return minFlips;  // Return the total minimum number of flips required\n    }\n};",
    "submit_ts": "1722699236",
    "subm_id": "1343205558"
}