{
    "username": "shuohe",
    "submission": "from collections import deque\nfrom typing import List\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, e1: List[List[int]], e2: List[List[int]]) -> int:\n        def bfs(s, g):\n            q = deque([s])\n            d = {s: 0}\n            fn = s\n            md = 0\n            \n            while q:\n                n = q.popleft()\n                for nei in g[n]:\n                    if nei not in d:\n                        d[nei] = d[n] + 1\n                        q.append(nei)\n                        if d[nei] > md:\n                            md = d[nei]\n                            fn = nei\n            return fn, md\n        \n        def treeDiameter(g):\n            sn = 0\n            fn, _ = bfs(sn, g)\n            _, dia = bfs(fn, g)\n            return dia\n        \n        def buildGraph(e, n):\n            g = {i: [] for i in range(n)}\n            for u, v in e:\n                g[u].append(v)\n                g[v].append(u)\n            return g\n        \n        n1 = len(e1) + 1  # Number of nodes in the first tree\n        n2 = len(e2) + 1  # Number of nodes in the second tree\n\n        g1 = buildGraph(e1, n1)\n        g2 = buildGraph(e2, n2)\n        \n        d1 = treeDiameter(g1)\n        d2 = treeDiameter(g2)\n        \n        return max(d1, d2, (d1 + 1) // 2 + (d2 + 1) // 2 + 1)\n\n",
    "submit_ts": 1719717256.0
}