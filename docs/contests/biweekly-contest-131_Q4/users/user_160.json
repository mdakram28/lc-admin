{
    "username": "sgdfbahjbhbaisdufg",
    "submission": "struct SegTreeNode {\n    int l, r;\n    int sum;\n    SegTreeNode *lnode, *rnode;\n    \n    SegTreeNode(int l, int r) : l(l), r(r), sum(INT_MIN), lnode(nullptr), rnode(nullptr) {\n        assert( l <= r );\n        int mid = l + (r - l) / 2;\n        if (l != r) {\n            lnode = new SegTreeNode(l, mid);\n            rnode = new SegTreeNode(mid + 1, r);\n        }\n    }\n    \n    int Query(int qleft, int qright) {\n        assert( qleft <= qright );\n        \n        if (qright < l || r < qleft) {\n            return 0;\n        }\n        \n        if (qleft <= l && r <= qright) {\n            return sum;\n        }\n        \n        assert( l < r );\n        int ret = max(lnode->Query(qleft, qright), rnode->Query(qleft, qright));\n        return ret;\n    }\n    \n    void Update(int q, int newval) {\n        assert( l <= q && q <= r );\n        if (l != r) {\n            if (q <= lnode->r) {\n                lnode->Update(q, newval);\n            } else {\n                rnode->Update(q, newval);\n            }\n            sum = max(lnode->sum, rnode->sum);\n        } else {\n            sum = newval;\n        }\n    }\n    \n    void Print() {\n        if (l == r) {\n            printf(\"%d: %d\\n\", l, sum);\n        } else {\n            lnode->Print();\n            rnode->Print();\n        }\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int maxx = 0;\n        for (vector<int>& q : queries) {\n            maxx = max(maxx, q[1]);\n        }\n        set<int> obs;\n        obs.insert(0);\n        SegTreeNode st(0, maxx);\n        st.Update(0, 0);\n        vector<bool> ans;\n        for (vector<int>& q : queries) {\n            if (q[0] == 1) {\n                int x = q[1];\n                auto [it, inserted] = obs.insert(x);\n                auto next = std::next(it);\n                if (next != obs.end()) {\n                    st.Update(*next, *next - x);\n                }\n                st.Update(x, x - *prev(it));\n            } else {\n                int x = q[1], sz = q[2];\n                int qres = st.Query(0, x);\n                auto next = obs.upper_bound(x);\n                auto prev = std::prev(next);\n                int cloestres = x - *prev;\n                bool cans = sz <= max(qres, cloestres);\n                ans.push_back(cans);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1716650270.0
}