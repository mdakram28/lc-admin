{
    "username": "Vengeance07",
    "submission": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> fillLPS(vector<int>& needle) {\n        int n = needle.size();\n        vector<int> lps(n, 0);\n        int len = 0; // Length of previous longest prefix suffix\n        int i = 1;\n        \n        while (i < n) {\n            if (needle[i] == needle[len]) {\n                len++;\n                lps[i] = len;\n                i++;\n            } else {\n                if (len != 0) {\n                    len = lps[len - 1];\n                } else {\n                    lps[i] = 0;\n                    i++;\n                }\n            }\n        }\n        return lps;\n    }\n    \n    int numberOfAlternatingGroups(vector<int>& haystack, int k) {\n        int n = haystack.size();\n        if (n < k) return 0; // Edge case: If haystack size is less than k\n        \n        vector<int> first, second;\n        \n        for (int i = 0; i < k; ++i) {\n            if (i % 2 == 0) {\n                first.push_back(0);\n                second.push_back(1);\n            } else {\n                first.push_back(1);\n                second.push_back(0);\n            }\n        }\n        \n        vector<int> lps1 = fillLPS(first);\n        vector<int> lps2 = fillLPS(second);\n        \n        vector<int> ds(haystack.begin(), haystack.end()); // Create a single extended array instead of three\n        ds.insert(ds.end(), haystack.begin(), haystack.end());\n        ds.insert(ds.end(), haystack.begin(), haystack.end());\n        \n        int ans = 0;\n        int i = n - k, j = 0; // Start from the correct circular starting point\n        \n        while (i < 2 * n - 1) { // Check within the extended array bounds\n            if (ds[i] == first[j]) {\n                i++;\n                j++;\n                if (j == k) {\n                    ans++;\n                    j = lps1[j - 1];\n                }\n            } else {\n                if (j != 0) {\n                    j = lps1[j - 1];\n                } else {\n                    i++;\n                }\n            }\n        }\n        \n        i = n - k; // Reset i and j for the second pattern\n        j = 0;\n        \n        while (i < 2 * n - 1) { // Check within the extended array bounds\n            if (ds[i] == second[j]) {\n                i++;\n                j++;\n                if (j == k) {\n                    ans++;\n                    j = lps2[j - 1];\n                }\n            } else {\n                if (j != 0) {\n                    j = lps2[j - 1];\n                } else {\n                    i++;\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n",
    "submit_ts": "1720280081",
    "subm_id": "1311776197"
}