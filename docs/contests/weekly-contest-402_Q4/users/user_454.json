{
    "username": "Narakanti_Mahesh",
    "submission": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    private int[] nums;\n    private int[] peakPrefix;\n\n    public class SegmentTree {\n        int[] st;\n        int n;\n\n        SegmentTree(int[] arr, int n) {\n            this.n = n;\n            int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));\n            int max_size = 2 * (int) Math.pow(2, x) - 1;\n            st = new int[max_size];\n            constructSTUtil(arr, 0, n - 1, 0);\n        }\n\n        int getMid(int s, int e) {\n            return s + (e - s) / 2;\n        }\n\n        int getSumUtil(int ss, int se, int qs, int qe, int si) {\n            if (qs <= ss && qe >= se) return st[si];\n            if (se < qs || ss > qe) return 0;\n            int mid = getMid(ss, se);\n            return getSumUtil(ss, mid, qs, qe, 2 * si + 1) +\n                   getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);\n        }\n\n        void updateValueUtil(int ss, int se, int i, int newVal, int si) {\n            if (i < ss || i > se) return;\n            if (ss == se) {\n                st[si] = isPeak(i) ? 1 : 0;\n                return;\n            }\n            int mid = getMid(ss, se);\n            updateValueUtil(ss, mid, i, newVal, 2 * si + 1);\n            updateValueUtil(mid + 1, se, i, newVal, 2 * si + 2);\n            st[si] = st[2 * si + 1] + st[2 * si + 2];\n        }\n\n        void updateValue(int arr[], int i, int new_val) {\n            if (i < 0 || i >= n) {\n               // System.out.println(\"Invalid Input\");\n                return;\n            }\n            arr[i] = new_val;\n            updateValueUtil(0, n - 1, i, new_val, 0);\n            if (i > 0) updateValueUtil(0, n - 1, i - 1, arr[i - 1], 0);\n            if (i < n - 1) updateValueUtil(0, n - 1, i + 1, arr[i + 1], 0);\n        }\n\n        int getSum(int qs, int qe) {\n            if (qs < 0 || qe >= n || qs > qe) {\n              //  System.out.println(\"Invalid Input\");\n                return -1;\n            }\n            return getSumUtil(0, n - 1, qs, qe, 0);\n        }\n\n        int constructSTUtil(int arr[], int ss, int se, int si) {\n            if (ss == se) {\n                st[si] = isPeak(ss) ? 1 : 0;\n                return st[si];\n            }\n            int mid = getMid(ss, se);\n            st[si] = constructSTUtil(arr, ss, mid, si * 2 + 1) +\n                     constructSTUtil(arr, mid + 1, se, si * 2 + 2);\n            return st[si];\n        }\n    }\npublic int countCompleteDayPairs(int[] hours) {\n        int k=24;\n        int c=0;\n        int p2=hours.length-1;\n        for(int i=0;i<=p2;i++)\n        {\n            for(int j=i+1;j<=p2;j++)\n            {\n                if((hours[i]+hours[j])%k==0)\n                    c++;\n            }\n        }\n        return c;\n    }\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        this.nums = nums;\n        List<Integer> ans = new ArrayList<>();\n        int n = nums.length;\n        SegmentTree tree = new SegmentTree(nums, n);\n\n        for (int[] q : queries) {\n            if (q[0] == 2) {\n                int ind = q[1];\n                int val = q[2];\n                tree.updateValue(nums, ind, val);\n            } else if (q[0] == 1) {\n                int li = q[1];\n                int ri = q[2];\n                int r=tree.getSum(li + 1, ri - 1);\n                if(r==-1)\n                    r=0;\n                ans.add(r);\n            }\n        }\n        return ans;\n    }\n\n    private boolean isPeak(int i) {\n        if (i <= 0 || i >= nums.length - 1) return false;\n        return nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    }\n}\n",
    "submit_ts": 1718506717.0
}