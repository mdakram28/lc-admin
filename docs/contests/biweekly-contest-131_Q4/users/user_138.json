{
    "username": "han3000",
    "submission": "from typing import List, Union\nfrom sortedcontainers import *\nINF = int(4e18)\n\n\nclass MaxSegmentTree:\n    \"\"\"RMQ \u6700\u5927\u503c\u7ebf\u6bb5\u6811(\u533a\u95f4\u548c\u53e0\u52a0)\n    \u6ce8\u610f\u6839\u8282\u70b9\u4ece1\u5f00\u59cb,tree\u672c\u8eab\u4e3a[1,n]\n    \u5982\u679c\u67e5\u8be2\u8d85\u51fa\u8303\u56f4 \u8fd4\u56de0\n    \u56e0\u4e3a\u662f\u53e0\u52a0 \u6240\u4ee5\u4e0d\u9700\u8981isLazy\u6570\u7ec4\n    \"\"\"\n\n    __slots__ = \"_n\", \"_tree\", \"_lazy\"\n\n    def __init__(self, nOrNums: Union[int, List[int]]):\n        self._n = nOrNums if isinstance(nOrNums, int) else len(nOrNums)\n        self._tree = [0] * (4 * self._n)\n        self._lazy = [0] * (4 * self._n)\n        if isinstance(nOrNums, list):\n            self._build(1, 1, self._n, nOrNums)\n\n    def add(self, left: int, right: int, delta: int) -> None:\n        \"\"\"\u95ed\u533a\u95f4[left,right]\u533a\u95f4\u503c\u52a0\u4e0adelta\"\"\"\n        if left < 1:\n            left = 1\n        if right > self._n:\n            right = self._n\n        if left > right:\n            return\n        self._add(1, left, right, 1, self._n, delta)\n\n    def query(self, left: int, right: int) -> int:\n        \"\"\"\u95ed\u533a\u95f4[left,right]\u7684\u6700\u503c\"\"\"\n        if left < 1:\n            left = 1\n        if right > self._n:\n            right = self._n\n        if left > right:\n            return 0  # !\u8d85\u51fa\u8303\u56f4\u8fd4\u56de0\n        return self._query(1, left, right, 1, self._n)\n\n    def queryAll(self) -> int:\n        return self._tree[1]\n\n    def _build(self, rt: int, l: int, r: int, nums: List[int]) -> None:\n        \"\"\"\u4f20\u4e86nums\u65f6,\u7528\u4e8e\u521d\u59cb\u5316\u7ebf\u6bb5\u6811\"\"\"\n        if l == r:\n            self._tree[rt] = nums[l - 1]\n            return\n\n        mid = (l + r) // 2\n        self._build(rt * 2, l, mid, nums)\n        self._build(rt * 2 + 1, mid + 1, r, nums)\n        self._push_up(rt)\n\n    def _add(self, rt: int, L: int, R: int, l: int, r: int, delta: int) -> None:\n        \"\"\"L,R\u8868\u793a\u9700\u8981update\u7684\u8303\u56f4,l,r\u8868\u793a\u5f53\u524d\u8282\u70b9\u7684\u8303\u56f4\"\"\"\n        if L <= l and r <= R:\n            self._lazy[rt] += delta\n            self._tree[rt] += delta\n            return\n\n        mid = (l + r) // 2\n        self._push_down(rt, l, r, mid)\n        if L <= mid:\n            self._add(rt * 2, L, R, l, mid, delta)\n        if mid < R:\n            self._add(rt * 2 + 1, L, R, mid + 1, r, delta)\n        self._push_up(rt)\n\n    def _query(self, rt: int, L: int, R: int, l: int, r: int) -> int:\n        \"\"\"L,R\u8868\u793a\u9700\u8981query\u7684\u8303\u56f4,l,r\u8868\u793a\u5f53\u524d\u8282\u70b9\u7684\u8303\u56f4\"\"\"\n        # \u4f20\u9012\u61d2\u6807\u8bb0\n        if L <= l and r <= R:\n            return self._tree[rt]\n\n        mid = (l + r) // 2\n        self._push_down(rt, l, r, mid)\n        res = 0  # !\u9ed8\u8ba4\u503c\u4e3a0\n        if L <= mid:\n            cand = self._query(rt * 2, L, R, l, mid)\n            if cand > res:\n                res = cand\n        if mid < R:\n            cand = self._query(rt * 2 + 1, L, R, mid + 1, r)\n            if cand > res:\n                res = cand\n        return res\n\n    def _push_up(self, rt: int) -> None:\n        self._tree[rt] = self._tree[rt * 2]\n        if self._tree[rt * 2 + 1] > self._tree[rt]:\n            self._tree[rt] = self._tree[rt * 2 + 1]\n\n    def _push_down(self, rt: int, l: int, r: int, mid: int) -> None:\n        if self._lazy[rt]:\n            value = self._lazy[rt]\n            self._lazy[rt * 2] += value\n            self._lazy[rt * 2 + 1] += value\n\n            self._tree[rt * 2] += value\n            self._tree[rt * 2 + 1] += value\n\n            self._lazy[rt] = 0\n\n\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        obs = sorted(q[1] for q in queries if q[0] == 1)\n        ob_index = {v: i + 1 for i,v in enumerate(obs)}\n        ob_index[0] = 0\n        n = len(obs)\n        st = MaxSegmentTree(n)\n        sl = SortedList([0])\n        res = []\n        for q in queries:\n            # print(q)\n            if q[0] == 1:\n                mid = q[1]\n                i = sl.bisect(mid)\n                left = sl[i - 1]\n                li = ob_index[left]\n                mi = ob_index[mid]\n                st.add(mi, mi, mid - left)\n                if i < len(sl):\n                    right = sl[i]\n                    ri = ob_index[right]\n                    st.add(ri,ri, left - mid)\n                sl.add(mid)\n\n            else:\n                mid = q[1]\n                i = sl.bisect(mid)\n                left = sl[i - 1]\n                li = ob_index[left]\n                v = st.query(1, li)\n                v = max(v, mid - left)\n                res.append(v >= q[2])\n        return res",
    "submit_ts": 1716650361.0
}