{
    "username": "hashmap_",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def bfs(tree, start,res):\n            visited = [False] * len(tree)\n            max_distance = 0\n            farthest_node = start\n\n            queue = deque([(start, 0)])  # (node, distance)\n\n            while queue:\n                node, distance = queue.popleft()\n                visited[node] = True\n                res[node] = max(res[node],distance)\n                if distance > max_distance:\n                    max_distance = distance\n                    farthest_node = node\n\n                for neighbor in tree[node]:\n                    if not visited[neighbor]:\n                        queue.append((neighbor, distance + 1))\n            return farthest_node, max_distance\n        def compute(edges):\n            n = len(edges)+1\n            res = [0]*n\n            tree = [[] for _ in range(n)]\n            for a,b in edges:\n                tree[a].append(b)\n                tree[b].append(a)\n\n            farthest_node, max_distance = bfs(tree, 0,res)\n            farthest_node, max_distance = bfs(tree, farthest_node,res)  # Perform BFS from the farthest node found in the first BFS\n            farthest_node, max_distance = bfs(tree, farthest_node,res) \n            return res\n        if edges1==[] and edges2==[]:\n            return 1\n        if edges1==[] :\n            return 1 +min(compute(edges2))\n        if edges2==[]:\n            return 1 +min(compute(edges1))\n        a = compute(edges1)\n        b = compute(edges2)\n        # print(a)\n        # print(b)\n        res = max(max(a),max(b), min(a) + min(b) +1)\n        return res\n\n \n",
    "submit_ts": "1719719374",
    "subm_id": "1304440410"
}