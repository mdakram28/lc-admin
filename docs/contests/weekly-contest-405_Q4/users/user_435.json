{
    "username": "Bhismpitamaha",
    "submission": "class TrieNode {\npublic:\n    unordered_map<char, TrieNode*> children;\n    int minCost;\n\n    TrieNode() : minCost(INT_MAX) {}\n};\n\nclass Solution {\npublic:\n    \n    void addWord(TrieNode* root, const string& word, int cost) {\n        TrieNode* currentNode = root;\n        for (char c : word) {\n            if (!currentNode->children.count(c)) {\n                currentNode->children[c] = new TrieNode();\n            }\n            currentNode = currentNode->children[c];\n        }\n        currentNode->minCost = min(currentNode->minCost, cost);\n    }\n\n    int minimumCost(string t, vector<string>& w, vector<int>& c) {\n        int targetLength = t.length();\n    int wordCount = w.size();\n\n    vector<int> dp(targetLength + 1, INT_MAX);\n    dp[0] = 0; \n\n    TrieNode* root = new TrieNode();\n    for (int i = 0; i < wordCount; ++i) {\n        addWord(root, w[i], c[i]);\n    }\n\n    for (int i = 0; i < targetLength; ++i) {\n        if (dp[i] == INT_MAX) continue; \n\n        TrieNode* currentNode = root;\n        for (int j = i; j < targetLength; ++j) {\n            if (!currentNode->children.count(t[j])) break;\n            currentNode = currentNode->children[t[j]];\n            if (currentNode->minCost != INT_MAX) {\n                dp[j + 1] = min(dp[j + 1], dp[i] + currentNode->minCost);\n            }\n        }\n    }\n\n    return dp[targetLength] == INT_MAX ? -1 : dp[targetLength];\n    }\n};",
    "submit_ts": "1720321546",
    "subm_id": "1312325774"
}