{
    "username": "DenisGubar",
    "submission": "class Solution {\npublic:\n\tstring target;\n\tint N, T;\n\tvector<int> calc(string s)\n\t{\n\t\tint X = s.size();\n\t\ts.reserve(X + T + 1);\n\t\ts += '#';\n\t\ts += target;\n\t\tint N = s.size();\n\t\tvector<int> z(N);\n\t\tfor (int i = 1, L = 0, R = 1; i < N; ++i)\n\t\t{\n\t\t\tif (i < R)\n\t\t\t\tz[i] = min(R - i, z[i - L]);\n\t\t\twhile (i + z[i] < N && s[z[i]] == s[i + z[i]])\n\t\t\t\t++z[i];\n\t\t\tif (i + z[i] > R)\n\t\t\t\tL = i, R = i + z[i];\n\t\t}\n\t\tvector<int> result;\n\t\tint size = 0;\n\t\tfor (int i = X + 1; i < N; ++i)\n\t\t\tsize += z[i] == X;\n\t\tresult.reserve(size);\n\t\tfor (int i = X + 1; i < N; ++i)\n\t\t\tif (z[i] == X)\n\t\t\t\tresult.push_back(i - X - 1);\n\t\treturn result;\n\t}\n\tint minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int const INF = 1 << 30;\n\t\tT = target.size();\n        N = words.size();\n\t\tunordered_map<string, pair<int, int>> M;\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tif (auto it = M.find(words[i]); it != M.end())\n\t\t\t{\n\t\t\t\tif (it->second > pair<int, int>{costs[i], i})\n\t\t\t\t\tit->second = { costs[i], i };\n\t\t\t}\n\t\t\telse\n\t\t\t\tM[words[i]] = { costs[i], i };\n\t\tvector<string> W;\n\t\tvector<int> C;\n\t\tW.reserve(N);\n\t\tC.reserve(N);\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tif (M[words[i]].second == i)\n\t\t\t\tC.push_back(costs[i]), W.push_back(words[i]);\n\t\tswap(W, words);\n\t\tswap(C, costs);\n\t\tN = words.size();\n\t\tthis->target = target;\n\t\tvector<vector<int>> Z;\n\t\tZ.reserve(N);\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tZ.emplace_back(calc(words[i]));\n\t\tvector<vector<int>> connectivity(T + 1);\n\t\tfor(int i = 0; i < N; ++i)\n\t\t\tfor (int j : Z[i])\n\t\t\t\tconnectivity[j].push_back(i);\n\t\tvector<int> minDistance(T + 1, INF);\n\t\tminDistance[0] = 0;\n\t\tset<pair<int, int>> activeVertices;\n\t\tactiveVertices.insert({ 0, 0 });\n\t\twhile (!activeVertices.empty())\n\t\t{\n\t\t\tint node = activeVertices.begin()->second;\n\t\t\tactiveVertices.erase(activeVertices.begin());\n\t\t\tfor (auto next : connectivity[node])\n\t\t\t{\n\t\t\t\tint const first = node + words[next].size();\n\t\t\t\tint const second = costs[next];\n\t\t\t\tif (minDistance[first] > minDistance[node] + second)\n\t\t\t\t{\n\t\t\t\t\tactiveVertices.erase({ minDistance[first], first });\n\t\t\t\t\tminDistance[first] = minDistance[node] + second;\n\t\t\t\t\tactiveVertices.insert({ minDistance[first], first });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (minDistance[T] == INF)\n\t\t\treturn -1;\n        return minDistance[T];\n    }\n};\n",
    "submit_ts": "1720322845",
    "subm_id": "1312360605"
}