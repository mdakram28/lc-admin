{
    "username": "sangam2ishra",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n1 = edges1.size() + 1;\n        int n2 = edges2.size() + 1;\n\n        vector<vector<int>> g1(n1);\n        for (auto& e : edges1) {\n            g1[e[0]].push_back(e[1]);\n            g1[e[1]].push_back(e[0]);\n        }\n\n        vector<vector<int>> g2(n2);\n        for (auto& e : edges2) {\n            g2[e[0]].push_back(e[1]);\n            g2[e[1]].push_back(e[0]);\n        }\n\n        int d1 = diameter(g1);\n        int d2 = diameter(g2);\n        int ans = max(d1, d2);\n        ans = max(ans, (d1 + 1) / 2 + (d2 + 1) / 2 + 1);\n\n        return ans;\n    }\n\nprivate:\n    int diameter(vector<vector<int>>& g) {\n        int n = g.size();\n        pair<int, int> p = bfs(0, g); \n        pair<int, int> q = bfs(p.first, g);\n        return q.second; \n    }\n\n    pair<int, int> bfs(int u, vector<vector<int>>& g) {\n        int n = g.size();\n        vector<int> dist(n, -1);\n        queue<int> q;\n        q.push(u);\n        dist[u] = 0;\n        int farthest_node = u;\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int neighbor : g[v]) {\n                if (dist[neighbor] == -1) {\n                    dist[neighbor] = dist[v] + 1;\n                    q.push(neighbor);\n                    if (dist[neighbor] > dist[farthest_node]) {\n                        farthest_node = neighbor;\n                    }\n                }\n            }\n        }\n        return {farthest_node, dist[farthest_node]};\n    }\n};\n",
    "submit_ts": "1719718178",
    "subm_id": "1304410710"
}