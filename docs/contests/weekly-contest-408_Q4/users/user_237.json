{
    "username": "adarsh1001111",
    "submission": "class Solution {\npublic:\nint performBFS(vector<vector<int>> &adjList, int source, int endPoint1, int endPoint2, int totalNodes) {\n    queue<int> toVisit;\n    vector<int> visited(totalNodes + 4, 0);\n    toVisit.push(source);\n    visited[source] = 1;\n    \n    while (!toVisit.empty()) {\n        int currentNode = toVisit.front();\n        toVisit.pop();\n        for (int neighbor : adjList[currentNode]) {\n            if (!visited[neighbor]) {\n                toVisit.push(neighbor);\n                visited[neighbor] = 1;\n            }\n        }\n    }\n    if(visited[endPoint1] || visited[endPoint2]){\n        return true;\n    }\n    else{\n        return false;\n    }\n}\n\n    bool canReachCorner(int width, int height, vector<vector<int>>& obstructions) {\n    vector<pair<pair<int, int>, int>> circles(obstructions.size());\n    vector<vector<int>> adjList(obstructions.size() + 4);\n    int numObstructions = obstructions.size();\n    \n    for (int i = 0; i < numObstructions; ++i) {\n        circles[i].first.first = obstructions[i][0];\n        circles[i].first.second = obstructions[i][1];\n        circles[i].second = obstructions[i][2];\n    }\n\n    for (int i = 0; i < numObstructions; ++i) {\n        if (circles[i].first.first <= circles[i].second) {\n            adjList[numObstructions].push_back(i);\n            adjList[i].push_back(numObstructions);\n        }\n        if (width - circles[i].first.first <= circles[i].second) {\n            adjList[numObstructions + 2].push_back(i);\n            adjList[i].push_back(numObstructions + 2);\n        }\n        if (circles[i].first.second <= circles[i].second) {\n            adjList[numObstructions + 1].push_back(i);\n            adjList[i].push_back(numObstructions + 1);\n        }\n        if (height - circles[i].first.second <= circles[i].second) {\n            adjList[numObstructions + 3].push_back(i);\n            adjList[i].push_back(numObstructions + 3);\n        }\n        for (int j = i + 1; j < numObstructions; ++j) {\n            double distBetweenCenters = sqrt(pow(circles[i].first.first - circles[j].first.first, 2) +\n                                             pow(circles[i].first.second - circles[j].first.second, 2));\n            int combinedRadius = circles[i].second + circles[j].second;\n            if (combinedRadius >= distBetweenCenters) {\n                adjList[i].push_back(j);\n                adjList[j].push_back(i);\n            }\n        }\n    }\n\n    int block = 0;\n    block = max(block, performBFS(adjList, numObstructions, numObstructions + 1, numObstructions + 2, numObstructions + 4));\n    block = max(block, performBFS(adjList, numObstructions + 3, numObstructions + 2, numObstructions + 1, numObstructions + 4));\n\n    return !block;\n}\n   \n    \n};",
    "submit_ts": "1722136763",
    "subm_id": "1335744261"
}