{
    "username": "yatin_kwatra",
    "submission": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize (\"Ofast\")\n//#pragma GCC optimize \"trapv\" // to detect overflow\n\n#define ll                      long long\n#define ar                      array\n// #define int                     ll\n#define sz(v)                   (int)(v.size())\n#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define ld                      long double\n#define ull                     unsigned long long\n#define endl                    \"\\n\"\n#define fo(i,a,b)               for(int i = a; i<=b ; i++)\n#define rfo(i,a,b)              for(int i = a; i>=b ; i--)\n#define vii                     vector<int>\n#define pq                      priority_queue\n#define uomii                   unordered_map<int,int,best_hash>\n#define all(v)                  v.begin(),v.end()\n#define mp                      make_pair\n#define pb                      push_back\n#define pob                     pop_back\n#define ff                      first\n#define ss                      second\n#define pii                     pair<int,int>\n#define mii                     map<int,int>\n#define vvii                    vector<vii>\n#define mod                     1000000007\n#define inf                     5e18\n#define pi                      3.1415926535897932384626433832795\n#define cz(x)                   63 - __builtin_clzll(x)\n\n\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n\n// https://codeforces.com/blog/entry/68809\n\nvoid __print(int x) {cout << x;}\nvoid __print(long x) {cout << x;}\nvoid __print(unsigned x) {cout << x;}\nvoid __print(unsigned long x) {cout << x;}\nvoid __print(unsigned long long x) {cout << x;}\nvoid __print(float x) {cout << x;}\nvoid __print(double x) {cout << x;}\nvoid __print(long double x) {cout << x;}\nvoid __print(char x) {cout << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cout << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cout << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cout << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? \",\" : \"\"), __print(i); cout << \"}\";}\nvoid _print() {cout << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define pr(x...) cout << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define pr(x...)\n#endif\n\n// https://codeforces.com/blog/entry/62393\n\nstruct best_hash {\n\tstatic uint64_t splitmix64(uint64_t x) {\n\n\t\tx += 0x9e3779b97f4a7c15;\n\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n\t\treturn x ^ (x >> 31);\n\t}\n\n\tsize_t operator()(uint64_t x) const {\n\t\tstatic const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n\t\treturn splitmix64(x + FIXED_RANDOM);\n\t}\n};\n\n/* ------------------------------ Let The Game Begin ---------------------------- */\n\nint f[30][30][30][30], comp[30][30];\n\nint subGridSum(int x1, int y1, int x2, int y2) {\n\tint sum = comp[x2][y2];\n\tif (y1) sum -= comp[x2][y1 - 1];\n\tif (x1) sum -= comp[x1 - 1][y2];\n\tif (x1 and y1) sum += comp[x1 - 1][y1 - 1];\n\treturn sum;\n}\n\nint calc(int x1, int y1, int x2, int y2, vector<vector<int>>& v) {\n\tif (x1 > x2 or y1 > y2) return 0;\n\n\tint n = (x2 - x1 + 1);\n\tint m = (y2 - y1 + 1);\n\n\tint &ans = f[x1][y1][x2][y2];\n\tif (ans != -1) return ans;\n\tans = (x2 - x1 + 1) * (y2 - y1 + 1);\n\n\tint rowSum = subGridSum(x1, y1, x1, y2);\n\tif (rowSum == 0) ans = min(ans, calc(x1 + 1, y1, x2, y2, v));\n\n\trowSum = subGridSum(x2, y1, x2, y2);\n\tif (rowSum == 0) ans = min(ans, calc(x1, y1, x2 - 1, y2, v));\n\n\n\tint colSum = subGridSum(x1, y1, x2, y1);\n\tif (colSum == 0) ans = min(ans, calc(x1, y1 + 1, x2, y2, v));\n\n\tcolSum = subGridSum(x1, y2, x2, y2);\n\tif (colSum == 0) ans = min(ans, calc(x1, y1, x2, y2 - 1, v));\n\n\treturn ans;\n}\n\nint dp[4][30][30][30][30];\n\nint findMinCost(int op, int x1, int y1, int x2, int y2) {\n\tif (f[x1][y1][x2][y2] == 0) return 0;\n\tif (op == 0) {\n\t\treturn f[x1][y1][x2][y2];\n\t}\n\n\tint &ans = dp[op][x1][y1][x2][y2];\n\tif (ans != -1) return ans;\n\tans = (x2 - x1 + 1) * (y2 - y1 + 1);\n\n\n\tfo(i, x1, x2 - 1) {\n\t\tif (op == 3) {\n\t\t\tans = min(ans, findMinCost(1, x1, y1, i, y2) + findMinCost(1, i + 1, y1, x2, y2));\n\t\t\tans = min(ans, findMinCost(2, x1, y1, i, y2) + findMinCost(0, i + 1, y1, x2, y2));\n\t\t\tans = min(ans, findMinCost(0, x1, y1, i, y2) + findMinCost(2, i + 1, y1, x2, y2));\n\t\t}\n\t\telse if (op == 2) {\n\t\t\tans = min(ans, findMinCost(1, x1, y1, i, y2) + findMinCost(0, i + 1, y1, x2, y2));\n\t\t\tans = min(ans, findMinCost(0, x1, y1, i, y2) + findMinCost(1, i + 1, y1, x2, y2));\n\t\t}\n\t\telse if (op == 1) {\n\t\t\tans = min(ans, findMinCost(0, x1, y1, i, y2) + findMinCost(0, i + 1, y1, x2, y2));\n\t\t}\n\t}\n\n\n\n\tfo(j, y1, y2 - 1) {\n\t\tif (op == 3) {\n\t\t\tif (x1 == 0 and y1 == 0 and x2 == 1 and y2 == 3 and ans == 4) {\n\t\t\t\tcout << y1 << ' ' <<  j << ' ' << j + 1 << ' ' << y2 << endl;\n\t\t\t}\n\t\t\tans = min(ans, findMinCost(1, x1, y1, x2, j) + findMinCost(1, x1, j + 1, x2, y2));\n\t\t\tans = min(ans, findMinCost(2, x1, y1, x2, j) + findMinCost(0, x1, j + 1, x2, y2));\n\t\t\tans = min(ans, findMinCost(0, x1, y1, x2, j) + findMinCost(2, x1, j + 1, x2, y2));\n\t\t}\n\t\telse if (op == 2) {\n\t\t\tans = min(ans, findMinCost(0, x1, y1, x2, j) + findMinCost(1, x1, j + 1, x2, y2));\n\t\t\tans = min(ans, findMinCost(1, x1, y1, x2, j) + findMinCost(0, x1, j + 1, x2, y2));\n\t\t}\n\t\telse if (op == 1) {\n\t\t\tans = min(ans, findMinCost(0, x1, y1, x2, j) + findMinCost(0, x1, j + 1, x2, y2));\n\t\t}\n\t}\n\treturn ans;\n}\n\nclass Solution {\npublic:\nint minimumSum(vector<vector<int>>& v) {\n\n\tint n = sz(v);\n\tint m = sz(v[0]);\n\n\tfo(i, 0, n - 1) {\n\t\tfo(j, 0, m - 1) comp[i][j] = 0;\n\t}\n\n\n\tfo(i, 0, n-1) {\n\t\tfo(j, 0, m-1) {\n\t\t\tfo(k, 0, n-1) {\n\t\t\t\tfo(p, 0, m-1) {\n\t\t\t\t\tf[i][j][k][p] = -1;\n\t\t\t\t\tfo(cnt, 0, 3) dp[cnt][i][j][k][p] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfo(i, 0, n - 1) {\n\t\tint sum = 0;\n\t\tfo(j, 0, m - 1) {\n\t\t\tsum += v[i][j];\n\t\t\tcomp[i][j] = sum + (i ? comp[i - 1][j] : 0);\n\t\t}\n\t}\n\n\tfo(x1, 0, n - 1) {\n\t\tfo(y1, 0, m - 1) {\n\t\t\tfo(x2, x1, n - 1) {\n\t\t\t\tfo(y2, y1, m - 1) {\n\t\t\t\t\tcalc(x1, y1, x2, y2, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\treturn findMinCost(2, 0, 0, n - 1, m - 1);\n\n\n}\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "submit_ts": 1719114556.0
}