{
    "username": "kyuukyuusha",
    "submission": "class Solution {\npublic:\n    long long minimumOperations(vector<int>& nums, vector<int>& target) {\n        const int n = nums.size();\n        std::vector<int> a(n+1);\n        for (int i = 0; i < n; ++i) a[i] = nums[i] - target[i];\n        // std::cout << \"[!] \"; for (auto x : a) {std::cout << x << \" \";} std::cout << \"\\n\";\n        // try to make nums[i]-target[i] == 0\n        \n        // going from left to right, it is known that... you have to do +/- to make it 0\n        // but how much does the subarray cover?\n        // assume you are doing - (leftmost nonzero is positive)\n        // then you need to find a point where (+) - (-) is maximized, and subtract the minimum among these\n        // if you have a RMQ of (+) - (-), you can query the maximum... ?\n        // then you need to update.... somehow\n        \n        // actually i cant find a case where you want to even split it... lol\n        // so you can actually binary search until you can't find a split\n        // or just accumulate changes...\n        long long ans = 0;\n        int delta = 0;\n        for (int i = 0; i < n; ++i) {\n            // for (auto x : a) {std::cout << x << \" \";} std::cout << \"\\n\";\n            \n            // if (!a[i]) continue; // nothing to do\n            if (a[i] > 0) { // apply (-)\n                int ndelta = -a[i];\n                if (delta < 0) a[i] = std::abs(a[i]) - std::min(std::abs(ndelta), std::abs(delta));\n                delta = ndelta;\n            } else { // apply (+)\n                int ndelta = -a[i];\n                if (delta > 0) a[i] = std::abs(a[i]) - std::min(std::abs(ndelta), std::abs(delta));\n                delta = ndelta;\n            }\n            \n            ans += std::abs(a[i]);\n            a[i] = 0;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1721533099",
    "subm_id": "1328001252"
}