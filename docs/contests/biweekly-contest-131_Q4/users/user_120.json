{
    "username": "jinmingli",
    "submission": "namespace atcoder\n{\n    template <class S, S (*op)(S, S), S (*e)()>\n    struct segtree\n    {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S> &v) : _n(int(v.size()))\n        {\n            log = 0;\n            while ((1U << log) < (unsigned int)(_n))\n                log++;\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++)\n                d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--)\n            {\n                update(i);\n            }\n        }\n\n        void set(int p, S x)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++)\n                update(p >> i);\n        }\n\n        S get(int p)\n        {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n\n        S prod(int l, int r)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n\n            while (l < r)\n            {\n                if (l & 1)\n                    sml = op(sml, d[l++]);\n                if (r & 1)\n                    smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n\n        S all_prod() { return d[1]; }\n\n        template <bool (*f)(S)>\n        int max_right(int l)\n        {\n            return max_right(l, [](S x)\n                             { return f(x); });\n        }\n        template <class F>\n        int max_right(int l, F f)\n        {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n)\n                return _n;\n            l += size;\n            S sm = e();\n            do\n            {\n                while (l % 2 == 0)\n                    l >>= 1;\n                if (!f(op(sm, d[l])))\n                {\n                    while (l < size)\n                    {\n                        l = (2 * l);\n                        if (f(op(sm, d[l])))\n                        {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n\n        template <bool (*f)(S)>\n        int min_left(int r)\n        {\n            return min_left(r, [](S x)\n                            { return f(x); });\n        }\n        template <class F>\n        int min_left(int r, F f)\n        {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0)\n                return 0;\n            r += size;\n            S sm = e();\n            do\n            {\n                r--;\n                while (r > 1 && (r % 2))\n                    r >>= 1;\n                if (!f(op(d[r], sm)))\n                {\n                    while (r < size)\n                    {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm)))\n                        {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n\n    private:\n        int _n, size, log;\n        std::vector<S> d;\n\n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n}\n\nstruct Node{\n    int b1=0;\n    int b2=0;\n    bool ff=true;\n    int mx=0;\n};\n\nNode op(Node a,Node b){\n    Node c;\n    if(a.ff) c.b1=a.b1+b.b1;\n    else c.b1=a.b1;\n    if(b.ff) c.b2=b.b2+a.b2;\n    else c.b2=b.b2;\n    c.ff=a.ff&&b.ff;\n    c.mx=max(max(a.mx,b.mx),max(c.b1,c.b2));\n    c.mx=max(a.b2+b.b1,c.mx);\n    return c;\n}\n\nNode e(){\n    return Node();\n}\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int cnt=min(50000,(int)queries.size()*3)+1;\n        vector<Node> tmp(cnt,Node(1,1,true,1));\n        atcoder::segtree<Node,op,e> tree(tmp);\n        vector<bool> ans;\n        for(auto v:queries){\n            if(v[0]==1){\n                tree.set(v[1],Node(0,1,false,1));\n            }else{\n                int x=v[1],sz=v[2];\n                int r=tree.prod(0,x).mx;\n                ans.push_back(r>=sz);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1716649637",
    "subm_id": "534767416"
}