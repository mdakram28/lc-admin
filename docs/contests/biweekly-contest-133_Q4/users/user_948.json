{
    "username": "a-dimitri",
    "submission": "class Solution {\npublic:\n    const int MOD = 1e9+7;\n    // DP[n,k] is number of perms of (1,...,n) with k inversions\n    // DP[n,k] = DP[n-1,k] + DP[n-1,k-1] + ... + DP[n-1,1]\n    int numberOfPermutations(int n, vector<vector<int>>& requirements) {\n        \n        sort(requirements.begin(), requirements.end());\n        int m = requirements.size();\n        int cnt_max = requirements[m-1][1];\n        \n        int j = 0;\n        if ( requirements[0][0] == 0 ) {\n            if ( requirements[0][1] != 0 ) return false;\n            j = 1;\n        }\n        \n        vector<vector<int>> dp(n, vector<int>(cnt_max+1));\n        dp[0][0] = 1;\n        for ( int i = 1; i < n; ++i ) {\n            int curr_sum = 0;\n            for ( int k = 0; k <= min(i*(i+1)/2, cnt_max); ++k ) {\n                curr_sum = (curr_sum + dp[i-1][k])%MOD;\n                if ( k >= i+1 ) curr_sum = (curr_sum - dp[i-1][k-(i+1)] + MOD)%MOD;\n                if ( requirements[j][0] != i || requirements[j][1] == k ) dp[i][k] = curr_sum;\n            }\n            if ( requirements[j][0] == i ) j++;\n        }\n            \n        return dp[n-1][cnt_max];\n    }\n};",
    "submit_ts": 1719071026.0
}