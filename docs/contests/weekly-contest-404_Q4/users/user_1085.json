{
    "username": "bug_byte",
    "submission": "def bfs_farthest_node(edges, start_node):\n    n = len(edges) + 1\n    dist = [-1] * n\n    dist[start_node] = 0\n    q = deque([start_node])\n    farthest_node = start_node\n    while q:\n        node = q.popleft()\n        for neighbor in edges[node]:\n            if dist[neighbor] == -1:\n                dist[neighbor] = dist[node] + 1\n                q.append(neighbor)\n                if dist[neighbor] > dist[farthest_node]:\n                    farthest_node = neighbor\n    return farthest_node, dist\n\ndef find_diameter_and_center(edges):\n    if not edges:\n        return 0, [0]\n    n = len(edges) + 1\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    farthest_node, _ = bfs_farthest_node(adj, 0)\n    opposite_node, dist = bfs_farthest_node(adj, farthest_node)\n    diameter = dist[opposite_node]\n    path = []\n    current = opposite_node\n    while current != farthest_node:\n        path.append(current)\n        for neighbor in adj[current]:\n            if dist[neighbor] == dist[current] - 1:\n                current = neighbor\n                break\n    path.append(farthest_node)\n    path = path[::-1]\n    path_length = len(path)\n    if path_length % 2 == 0:\n        centers = [path[path_length // 2 - 1], path[path_length // 2]]\n    else:\n        centers = [path[path_length // 2]]\n    return diameter, centers\n\ndef min_diameter_after_merge(edges1, edges2):\n    diameter1, centers1 = find_diameter_and_center(edges1)\n    diameter2, centers2 = find_diameter_and_center(edges2)\n    \n    # print(diameter1, centers1)\n    # print(diameter2, centers2)\n    \n    new_diameter = max(diameter1, diameter2, (diameter1 + 1) // 2 + 1 + (diameter2 + 1) // 2)\n    # for center1 in centers1:\n    #     for center2 in centers2:\n    #         candidate_diameter = \n    #         print(candidate_diameter)\n    #         new_diameter = min(new_diameter, candidate_diameter)\n    return new_diameter\n\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        return min_diameter_after_merge(edges1, edges2)",
    "submit_ts": 1719719174.0
}