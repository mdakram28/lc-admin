{
    "username": "samad_987",
    "submission": "class Solution {\n    public List<Boolean> getResults(int[][] q) {\n           int n=0;\n           for(int i=0;i<q.length;i++)n=Math.max(n,q[i][1]);\n           n+=2;\n           int seg[]=new int[4*n+1];\n           int lazy[]=new int[4*n+1];\n           for(int i=0;i<n;i++)update(seg,lazy,i,i,i,0,n-1,0);\n           TreeSet<Integer> hs=new TreeSet<>();\n           List<Boolean> ans=new ArrayList<>();\n           for(int i=0;i<q.length;i++){\n               int qr=q[i][0];\n               if(qr==1){\n                   int x=q[i][1];\n                   if(hs.contains(x))continue;\n                   hs.add(x);\n                   int ed=hs.higher(x)==null?n-1:hs.higher(x);\n                   int val=query(seg,lazy,x,x,0,n-1,0);\n                   update(seg,lazy,x+1,ed,-val,0,n-1,0);\n               }\n               else{\n                   int x=q[i][1];\n                   int mx=query(seg,lazy,0,x,0,n-1,0);\n                   ans.add(mx>=q[i][2]);\n               }\n           }\n           return ans;\n    }\n    \n static void update(int segmentTree[],int lazy[], int startRange, int endRange,\n                                            int delta, int low, int high, int pos) {\n        if(low > high) {\n            return;\n        }\n\n        //make sure all propagation is done at pos. If not update tree\n        //at pos and mark its children for lazy propagation.\n        if (lazy[pos] != 0) {\n            segmentTree[pos] += lazy[pos];\n            if (low != high) { //not a leaf node\n                lazy[2 * pos + 1] += lazy[pos];\n                lazy[2 * pos + 2] += lazy[pos];\n            }\n            lazy[pos] = 0;\n        }\n\n        //no overlap condition\n        if(startRange > high || endRange < low) {\n            return;\n        }\n\n        //total overlap condition\n        if(startRange <= low && endRange >= high) {\n            segmentTree[pos] += delta;\n            if(low != high) {\n                lazy[2*pos + 1] += delta;\n                lazy[2*pos + 2] += delta;\n            }\n            return;\n        }\n\n        //otherwise partial overlap so look both left and right.\n        int mid = (low + high)/2;\n        if(!(endRange<low || startRange>mid))update(segmentTree, lazy, startRange, endRange,\n                delta, low, mid, 2*pos+1);\n        if(!(endRange<mid+1 || startRange>high))update(segmentTree, lazy, startRange, endRange,\n                delta, mid+1, high, 2*pos+2);\n        segmentTree[pos] = Math.max(segmentTree[2*pos + 1], segmentTree[2*pos + 2]);\n    }    \nstatic int query(int segmentTree[], int lazy[], int qlow, int qhigh,\n                                      int low, int high, int pos) {\n\n        if(low > high) {\n            return 0;\n        }\n\n        //make sure all propagation is done at pos. If not update tree\n        //at pos and mark its children for lazy propagation.\n        if (lazy[pos] != 0) {\n            segmentTree[pos] += lazy[pos];\n            if (low != high) { //not a leaf node\n                lazy[2 * pos + 1] += lazy[pos];\n                lazy[2 * pos + 2] += lazy[pos];\n            }\n            lazy[pos] = 0;\n        }\n\n        //no overlap\n        if(qlow > high || qhigh < low){\n            return 0;\n        }\n\n        //total overlap\n        if(qlow <= low && qhigh >= high){\n            return segmentTree[pos];\n        }\n\n        //partial overlap\n        int mid = (low+high)/2;\n        return Math.max(query(segmentTree, lazy, qlow, qhigh,\n                        low, mid, 2 * pos + 1),\n                        query(segmentTree, lazy,  qlow, qhigh,\n                        mid + 1, high, 2 * pos + 2));\n\n    }    \n}",
    "submit_ts": "1716650657",
    "subm_id": "1267621292"
}