{
    "username": "youtube_aryanc403",
    "submission": "/*\n  Compete against Yourself.\n  Author - Aryan (@aryanc403)\n*/\n/*\n  Credits -\n  Atcoder library - https://atcoder.github.io/ac-library/production/document_en/ (namespace atcoder)\n  Github source code of library - https://github.com/atcoder/ac-library/tree/master/atcoder\n  https://codeforces.com/contest/4/submission/150120627\n*/\n\n#ifdef ARYANC403\n    #include <header.h>\n#else\n    #pragma GCC optimize (\"Ofast\")\n    #pragma GCC target (\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n    #pragma GCC optimize (\"-ffloat-store\")\n    #include <bits/stdc++.h>\n    #include <ext/pb_ds/assoc_container.hpp>\n    #include <ext/pb_ds/tree_policy.hpp>\n    #define dbg(args...) 42;\n    #define endl \"\\n\"\n#endif\n\n// y_combinator from @neal template https://codeforces.com/contest/1553/submission/123849801\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\nusing namespace std;\n#define fo(i,n)   for(i=0;i<(n);++i)\n#define repA(i,j,n)   for(i=(j);i<=(n);++i)\n#define repD(i,j,n)   for(i=(j);i>=(n);--i)\n#define all(x) begin(x), end(x)\n#define sz(x) ((lli)(x).size())\n#define eb emplace_back\n#define X first\n#define Y second\n\nusing lli = long long int;\nusing mytype = long double;\nusing ii = pair<lli,lli>;\nusing vii = vector<ii>;\nusing vi = vector<lli>;\n\ntemplate <class T>\nusing ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\n// X.find_by_order(k) return kth element. 0 indexed.\n// X.order_of_key(k) returns count of elements strictly less than k.\n\n/**\n * Author: Simon Lindholm\n * Date: 2015-03-15\n * License: CC0\n * Source: own work\n * Description: Various self-explanatory methods for string hashing.\n * Use on Codeforces, which lacks 64-bit support and where solutions can be hacked.\n * Status: stress-tested\n */\n\n// Ref - https://github.com/kth-competitive-programming/kactl/blob/main/content/strings/Hashing-codeforces.h\n\ntypedef uint64_t ull;\nstatic int C; // initialized below\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n\n// Arithmetic mod two primes and 2^32 simultaneously.\n// \"typedef uint64_t H;\" instead if Thue-Morse does not apply.\ntemplate<int M, class B>\nstruct A {\n    int x; B b; A(int x=0) : x(x), b(x) {}\n    A(int x, B b) : x(x), b(b) {}\n    A operator+(A o){int y = x+o.x; return{y - (y>=M)*M, b+o.b};}\n    A operator-(A o){int y = x-o.x; return{y + (y< 0)*M, b-o.b};}\n    A operator*(A o) { return {(int)(1LL*x*o.x % M), b*o.b}; }\n    explicit operator ull() const { return x ^ (ull) b << 21; }\n    bool operator==(A o) const { return (ull)*this == (ull)o; }\n    bool operator<(A o) const { return (ull)*this < (ull)o; }\n};\ntypedef A<289260247,unsigned> H;\n\nstruct HashInterval {\n    vector<H> ha, pw;\n    HashInterval(string& str) : ha(sz(str)+1), pw(ha) {\n        pw[0] = 1;\n        rep(i,0,sz(str))\n            ha[i+1] = ha[i] * C + str[i],\n            pw[i+1] = pw[i] * C;\n    }\n    H hashInterval(int a, int b) { // hash [a, b)\n        return ha[b] - ha[a] * pw[b - a];\n    }\n};\n\nvector<H> getHashes(string& str, int length) {\n    if (sz(str) < length) return {};\n    H h = 0, pw = 1;\n    rep(i,0,length)\n        h = h * C + str[i], pw = pw * C;\n    vector<H> ret = {h};\n    rep(i,length,sz(str)) {\n        ret.push_back(h = h * C + str[i] - pw * str[i-length]);\n    }\n    return ret;\n}\n\nH hashString(const string& s){H h{}; for(char c:s) h=h*C+c;return h;}\n\nconst lli SEED=chrono::steady_clock::now().time_since_epoch().count();\nmt19937_64 rng(SEED);\ninline lli rnd(lli l,lli r)\n{return uniform_int_distribution<lli>(l,r)(rng);}\n\nclass Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        C = rnd(1000,1e5);\n        map<lli,map<H,lli>> c;\n        for(lli j=0;j<sz(words);j++){\n            const string s=words[j];\n            const lli cr=costs[j];\n            const auto hsh = hashString(s);\n            auto &cur=c[sz(s)];\n            if(cur.count(hsh))\n                cur[hsh]=min(cur[hsh],cr);\n            else\n                cur[hsh]=cr;\n        }\n        target=\".\"+target;\n        auto hs = HashInterval(target);\n        const lli n=sz(target);\n        const lli INF = 1e12;\n        vi dp(n,INF);\n        dp[0]=0;\n        for(lli j=1;j<n;j++){\n            for(auto &cr:c){\n                const lli len = cr.X;\n                if(j<len)\n                    continue;\n                const auto h=hs.hashInterval(j-len+1,j+1);\n                if(cr.Y.count(h))\n                    dp[j]=min(dp[j],dp[j-len]+cr.Y[h]);\n            }\n        }\n        if(dp[n-1]>=INF)\n            return -1;\n        return dp[n-1];\n    }\n};\n\n#ifdef LOCAL\nint main()\n{\n    Solution s;\n    // cout<<\"Ans:\"<<s.minimumCost(\"abcdef\",{\"abdef\",\"abc\",\"d\",\"def\",\"ef\"},{100,1,1,10,5})<<\":Fn\"<<endl;\n    // cout<<\"Ans:\"<<s.runSoln(100)<<\":Fn\"<<endl;\n    // cout<<\"Ans:\"<<s.runSoln(1000)<<\":Fn\"<<endl;\n    return 0;\n}\n#endif\n",
    "submit_ts": "1720321093",
    "subm_id": "1312313268"
}