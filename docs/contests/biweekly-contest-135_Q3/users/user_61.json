{
    "username": "farmerboy",
    "submission": "#include <bits/stdc++.h>\n#define FI first\n#define SE second\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) int((a).size())\n#define MS(s, n) memset(s, n, sizeof(s))\n#define FOR(i,a,b) for (int i = (a); i <= (b); i++)\n#define FORE(i,a,b) for (int i = (a); i >= (b); i--)\n#define FORALL(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define TRAV(x, a) for (auto &x : a)\n\nusing namespace std;\nusing ll = long long; using ld = double; \nusing pi = pair<int, int>; using pl = pair<ll, ll>; using pd = pair<ld, ld>;\nusing cd = complex<ld>; using vcd = vector<cd>;\n\nusing vi = vector<int>; using vl = vector<ll>;\nusing vd = vector<ld>; using vs = vector<string>;\nusing vpi = vector<pi>; using vpl = vector<pl>; using vpd = vector<pd>; // vector<pair>\n\ntemplate<class T> using min_pq = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T> inline int ckmin(T& a, const T& val) { return val < a ? a = val, 1 : 0; }\ntemplate<class T> inline int ckmax(T& a, const T& val) { return a < val ? a = val, 1 : 0; }\ntemplate<class T> void remDup(vector<T>& v) { sort(ALL(v)); v.erase(unique(ALL(v)), end(v)); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { return x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll ceilDiv(ll a, ll b) { return a / b + ((a ^ b) > 0 && a % b); } // divide a by b rounded up\nll floorDiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); } // divide a by b rounded down\nvoid setPrec(int x) { cout << fixed << setprecision(x); }\n\n// TO_STRING\n#define ts to_string\nstring ts(char c) { return string(1, c); }\nstring ts(const char* s) { return (string) s; }\nstring ts(string s) { return s; }\nstring ts(bool b) { return (b ? \"true\" : \"false\"); }\n\ntemplate<class T> using V = vector<T>;\ntemplate<class T> string ts(complex<T> c);\nstring ts(V<bool> v);\ntemplate<size_t sz> string ts(bitset<sz> b);\ntemplate<class T> string ts(T v);\ntemplate<class T, class U> string ts(pair<T,U> p);\ntemplate<class ...U> string ts(tuple<U...> u);\n\ntemplate<class T> string ts(complex<T> c) { stringstream ss; ss << c; return ss.str(); }\nstring ts(V<bool> v) {string res = \"{\"; FOR(i,0,SZ(v)-1) res += char('0'+v[i]); res += \"}\"; return res; }\ntemplate<size_t sz> string ts(bitset<sz> b) { string res = \"\"; FOR(i,0,SZ(b)-1) res += char('0'+b[i]); return res; }\ntemplate<class T> string ts(T v) { // containers with begin(), end()\n    bool fst = 1; string res = \"\";\n    for (const auto& x: v) { if (!fst) res += \" \"; fst = 0; res += ts(x); }\n    return res;\n}\ntemplate<class T, class U> string ts(pair<T,U> p) { return \"(\" + ts(p.FI) + \", \" + ts(p.SE) + \")\"; }\ntemplate<size_t i, class T> string print_tuple_utils(const T& tup) { if constexpr(i == tuple_size<T>::value) return \")\"; else return (i ? \", \" : \"(\") + ts(get<i>(tup)) + print_tuple_utils<i + 1, T>(tup); }\ntemplate<class ...U> string ts(tuple<U...> u) { return print_tuple_utils<0, tuple<U...>>(u); }\n\n// OUTPUT\ntemplate<class T> void pr(T x) { cout << ts(x); }\ntemplate<class T, class ...U> void pr(const T& t, const U&... u) { pr(t); pr(u...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class T, class ...U> void ps(const T& t, const U&... u) { pr(t); if (sizeof...(u)) pr(\" \"); ps(u...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class T, class ...U> void DBG(const T& t, const U&... u) { cerr << ts(t); if (sizeof...(u)) cerr << \", \"; DBG(u...); }\n\n#ifdef LOCAL_DEBUG\n#define CONCAT(x, y) x##y\n#define with_level setw(__db_level * 2) << setfill(' ') << \"\" << setw(0)\n#define dbg(...) cerr << with_level << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#define chk(...) if (!(__VA_ARGS__)) cerr << setw(__db_level * 2) << setfill(' ') << \"\" << setw(0) << \"Line(\" << __LINE__ << \") -> function(\" << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#define db_block() debug_block CONCAT(dbbl, __LINE__)\nint __db_level = 0;\nstruct debug_block {\n    debug_block() { cerr << with_level << \"{\" << endl; ++__db_level; }\n    ~debug_block() { --__db_level; cerr << with_level << \"}\" << endl; }\n};\n#else\n#define dbg(...) 0\n#define chk(...) 0\n#define db_block() 0\n#endif\n\nconst ld PI = acos(-1.0);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\nconst ld EPS = 1e-9;\nconst ll MODBASE = 1000000007LL;\nconst int INF = 0x3f3f3f3f;\n\nconst int MAXN = 500010;\nconst int MAXM = 1000;\nconst int MAXK = 16;\nconst int MAXQ = 200010;\n\nclass Solution {\npublic:\n    int minChanges(vector<int>& nums, int k) {\n        int n = SZ(nums);\n        vi res(k + 10, 0);\n\n        FOR(i,0,n/2-1) {\n            int diff = abs(nums[i] - nums[n-i-1]);\n            int x = nums[i], y = nums[n-i-1];\n            if (x > y) swap(x, y);\n            int max1 = max(y, k - x);\n\n            // cout << x << ' ' << y << ' ' << diff << ' ' << max1 << endl;\n\n            // 1 1 1 1 0 1 1 1 1 2 2 2 2 2\n            res[0]++;\n            res[max1+1]--;\n\n            res[max1+1] += 2;\n            res[k+1] -= 2;\n\n            res[diff]--;\n            res[diff+1]++;\n        }\n\n        FOR(i,1,k) res[i] += res[i-1];\n\n        // FOR(i,0,k) cout << res[i] << ' ';\n        // cout << endl;\n        int kq = INF;\n        FOR(i,0,k) {\n            ckmin(kq, res[i]);\n        }\n\n        return kq;\n    }\n};",
    "submit_ts": "1721486884",
    "subm_id": "1327367903"
}