{
    "username": "Blitxen",
    "submission": "class UnionFind:\n    par: list[int]\n    rank: list[int]\n\n    def __init__(self, n: int):\n        self.par = [i for i in range(n)]\n        self.rank = [1] * n\n\n    def root(self, x: int) -> int:\n        while x != self.par[x]:\n            x = self.par[x]\n\n        return x\n\n    def union(self, x: int, y: int) -> bool:\n        p1, p2 = self.root(x), self.root(y)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p2] > self.rank[p1]:\n            p1, p2 = p2, p1\n\n        self.rank[p1] += self.rank[p2]\n        self.par[p2] = p1\n\n        return True\n\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        for x, y, r in circles:\n            if (x ** 2 + y ** 2) <= r:\n                return False\n            \n            if (abs(x - X) ** 2) + (abs(y - Y) ** 2) <= r:\n                return False\n\n        n = len(circles)\n        connected = [set() for _ in range(n + 4)]\n            \n        for i, (x, y, r) in enumerate(circles):\n            if x <= r:\n                connected[i].add(n) # left side\n                \n            if y <= r:\n                connected[i].add(n + 1) # bottom side\n                \n            if x + r >= X:\n                connected[i].add(n + 2) # right side\n                \n            if y + r >= Y:\n                connected[i].add(n + 3) # top side\n            \n        uf = UnionFind(n)\n        \n        for i, (x1, y1, r1) in enumerate(circles):\n            for j, (x2, y2, r2) in enumerate(circles):\n                if sqrt((abs(x1 - x2) ** 2) + (abs(y1 - y2) ** 2)) <= (r1 + r2):\n                    # print(i, j)\n                    \n                    connected[uf.root(i)] |= connected[uf.root(j)]\n                    connected[uf.root(j)] |= connected[uf.root(i)]\n                    \n                    uf.union(i, j)\n                    \n                    \n        # print(\"NEW\")\n        # print(connected)\n        for i in range(n):\n            root = uf.root(i)\n            # print(i, root)\n            # print(connected[root])\n            \n            if n in connected[root] and n + 2 in connected[root]:\n                return False\n            \n            if n in connected[root] and n + 1 in connected[root]:\n                return False\n            \n            if n + 1 in connected[root] and n + 3 in connected[root]:\n                return False\n            \n            if n + 3 in connected[root] and n + 2 in connected[root]:\n                return False\n            \n        return True",
    "submit_ts": "1722137921",
    "subm_id": "1335777326"
}