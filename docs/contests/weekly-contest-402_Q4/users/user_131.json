{
    "username": "lickcock",
    "submission": "#include <bits/stdc++.h> \n\n#define NDEBUG\n#define TERRORIST\n\n#ifdef TERRORIST\nusing namespace std;\n#define int64_t wadwafesfesfes21321300242142104210321\nusing int64_t = long long;\nusing pii = pair<int,int>;\nusing pil = pair<int,int64_t>;\nusing pli = pair<int64_t,int>;\nusing pll = pair<int64_t,int64_t>;\n#define PI 3.14159265358979323846\n#define umap unordered_map\n#define uset unordered_set\n#define all(x) x.begin(), x.end()\n#define allr(x) x.rbegin(), x.rend()\n#define emp_back emplace_back\n#define bitcount(x) __builtin_popcount((x))\n#define mbin(val, cap) bitset<64>(val).to_string().substr(64 - cap)\n#ifdef NDEBUG\n    #define print(x) cout << \"[ \" << #x << \" ]: \" << x << \"\\n\";\n    #define e_ cout << \"\\n\";\n#else\n    #define print(x)\n    #define e_\n#endif\n\ntemplate<typename T> ostream& operator<<(ostream &cout, vector<T> const &v);\ntemplate<typename F, typename S> ostream& operator<<(ostream &cout, pair<F, S> const &p) { return cout << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate<typename T> ostream& operator<<(ostream &cout, vector<T> const &v) {\n    cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\";\n}\ntemplate <typename K, typename V> ostream& operator<<(ostream& cout, const map<K, V>& omp) {\n    for(auto& [k, v] : omp){ cout << \"(\" << k << \": \" << v << \")\"; if(&v != &omp.rbegin()->second) cout << \", \";} return cout;\n}\ntemplate<typename T> ostream& operator<<(ostream& cout, const set<T>& ost){\n    cout << \"{\"; for(auto& v : ost){ cout << v; if(v != *ost.rbegin()) cout << \", \"; } cout << \"}\"; return cout;\n}\ntemplate<typename T, typename Cmp = less<T>>\noptional<vector<T>> get_unique(vector<T>& who, bool in_place = true, Cmp compare = Cmp()){\n    if(in_place){ sort(all(who), compare); who.erase(unique(all(who)), who.end()); return nullopt;}\n    vector<T> ret = who; sort(all(ret), compare); ret.erase(unique(all(ret)), ret.end()); return ret;\n}\nmt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate <typename T>\nT mrand(T begin, T end) {\n    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } \n    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }\n}\nint fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();\n//down, right, up, left, upleft, downright, upright, downleft, stay\nconstexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};\nconstexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};\n#endif\n\ntemplate< typename T>\nclass SegTreeP {\nprivate:\n    vector<T> tree;\n    size_t n;\n\n    //for update\n    int want_idx;\n    T new_value;\n\n    //for find\n    int want_start, want_end;\n\nprivate:\n    void _build(int node, int start, int end, const vector<T>& arr) {\n        if(start == end){\n            tree[node] = arr[start];\n            return;\n        }\n    \n        int mid = (start + end) / 2;\n        int left_kid = 2 * node;\n        int right_kid = 2 * node + 1;\n\n        _build(left_kid, start, mid, arr);\n        _build(right_kid, mid + 1, end, arr);\n\n        //sum\n        tree[node] = tree[left_kid] + tree[right_kid];\n    }\n\n    T _find(int node, int start, int end) {\n        if(end < want_start || start > want_end){\n            //sum\n            return T();\n        }\n\n        if(start >= want_start && end <= want_end)\n            return tree[node];\n\n        int mid = (start + end) / 2;\n        int left_kid = 2 * node;\n        int right_kid = 2 * node + 1;\n\n        T left_res = _find(left_kid, start, mid);\n        T right_res = _find(right_kid, mid + 1, end);\n\n        //sum\n        return left_res + right_res;\n    }\n\n    void _update(int node, int start, int end) {\n        if (start == end){\n            tree[node] = new_value;\n            return;\n        }\n\n        int mid = (start + end) / 2;\n        int left_kid = 2 * node;\n        int right_kid = 2 * node + 1;\n\n        if(want_idx <= mid){\n            _update(left_kid, start, mid);\n        }else{\n            _update(right_kid, mid + 1, end);\n        }\n\n        //sum\n        tree[node] = tree[left_kid] + tree[right_kid];\n    }\n\npublic:\n    SegTreeP(){}\n    SegTreeP(const vector<T>& arr){ build(arr); }\n    SegTreeP(size_t size){ build(size); }\n\n    void build(size_t size){\n        n = size;\n        tree.assign(4 * n, 0);\n    }\n\n    void build(const vector<T>& arr){\n        build(arr.size());\n        _build(1, 0, n - 1, arr);\n    }\n\n    T find(int start, int end){\n        if(start > end) return 0;\n        want_start = start;\n        want_end = end;\n        return _find(1, 0, n - 1);\n    }\n\n    void update(int idx, T new_value){\n        want_idx = idx;\n        this->new_value = new_value;\n        _update(1, 0, n - 1);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        const int n = nums.size();\n        vector<int64_t> initial(n, 0);\n        for(int i = 1; i < n - 1; i++)\n            if(nums[i] > nums[i - 1] && nums[i] > nums[i + 1])\n                initial[i] = 1;\n\n        SegTreeP<int64_t> sg(initial);\n        vector<int> ans;\n        for(auto& q : queries){\n            if(q[0] == 1){\n                if(q[1] > q[2]) swap(q[1], q[2]);\n                ans.push_back(sg.find(q[1] + 1, q[2] - 1));\n                continue;\n            }\n\n            int i = q[1];\n            int val = q[2];\n            nums[i] = val;\n            sg.update(i, 0);\n            if(i) sg.update(i - 1, 0);\n            if(i != n - 1) sg.update(i + 1, 0);\n            auto check = [&](int at) -> void {\n                if(at <= 0 || at >= n - 1) return;\n                if(nums[at] > nums[at - 1] && nums[at] > nums[at + 1])\n                    sg.update(at, 1);\n            };\n\n            check(i), check(i - 1), check(i + 1);\n        }\n\n        return ans;\n    }\n};\n\n// #define MAIN_ACTIVE\n#ifdef MAIN_ACTIVE\nvoid solve() {}\nint main() {\n    int test_case;\n    cin >> test_case;\n    while(test_case--)\n        solve();\n\n    return EXIT_SUCCESS;\n}\n#endif",
    "submit_ts": "1718506476",
    "subm_id": "1289620330"
}