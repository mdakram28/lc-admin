{
    "username": "rodman10",
    "submission": "#define repi(i, a, b) for (int i = (a), i##len = (b); i <= i##len; ++i)\n#define peri(i, a, b) for (int i = (a), i##len = (b); i >= i##len; --i)\n#define ll long long\n#define pii pair<int, int>\n#define x first\n#define y second\n#define vi vector<int>\n#define gi greater<int>\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define lowbit(t) ((t) & (-(t)))\nconstexpr const int MAXN = 1e5 + 5;\nconstexpr const int MOD = 1e9 + 7;\nconstexpr const int MOD2 = 998244353;\nconstexpr const int INF = 0x3f3f3f3f;\nusing pli = pair<ll, int>;\nint dx[] = {0,0,-1,1};\nint dy[] = {-1,1,0,0};\ntemplate <class U, class T> void Max(U &x, T y) {\n  if (x < y)\n    x = y;\n}\ntemplate <class U, class T> void Min(U &x, T y) {\n  if (x > y)\n    x = y;\n}\ninline ll qpow(ll b, ll k, int MOD) {\n  ll ans = 1;\n  while (k) {\n    if (k & 1) {\n      (ans *= b) %= MOD;\n    }\n    (b *= b) %= MOD;\n    k >>= 1;\n  }\n  return ans;\n}\n\nstruct SegTree {\n#define lson (id << 1)\n#define rson (id << 1 | 1)\n#define mid ((l + r) >> 1)\n\n  int sum[MAXN << 2];\n  // int ly[MAXN << 2];\n\n  void push_up(int id, int l, int r, vi&v) {\n    sum[id] = sum[lson] + sum[rson];\n    if (l<mid && v[mid-1] < v[mid] && v[mid]>v[mid+1]) {\n      ++sum[id];\n    }\n    if (r>mid+1 && v[mid+1] > v[mid] && v[mid+1]>v[mid+2]) {\n      ++sum[id];\n    }      \n  }\n\n  void push_down(int id, int l, int r) {\n   \n  }\n\n  void build(int id, int l, int r, vi& v) {\n    if (l == r) {\n      sum[id] = 0;\n      return;\n    }\n\n    build(lson, l, mid, v);\n    build(rson, mid + 1, r, v);\n\n    push_up(id, l, r, v);\n  }\n\n  void update(int id, int l, int r, int L, int R, int val, vi&v) {\n    if (L <= l && r <= R) {\n        v[l] = val;\n      sum[id] = 0;\n      return;\n    }\n\n    // push_down(id, l, r);\n\n    if (L <= mid) {\n      update(lson, l, mid, L, R, val, v);\n    }\n\n    if (mid + 1 <= R) {\n      update(rson, mid + 1, r, L, R, val, v);\n    }\n\n    push_up(id, l, r, v);\n  }\n\n  int query(int id, int l, int r, int L, int R, vi&v) {\n      // cout << l <<\" \"<<mid<<\" \"<<r<<\" \"<<sum[id]<<endl;\n      \n    if (L <= l && r <= R) {\n      return sum[id];\n    }\n    // push_down(id, l, r);\n\n    int ans = 0;\n    if (L <= mid) {\n        ans += query(lson, l, mid, L, R, v);\n    }\n\n    if (mid + 1 <= R) {\n        ans += query(rson, mid + 1, r, L, R, v);\n    }\n      \n    if (max(L,l)<mid && min(R,r)> mid && v[mid-1] < v[mid] && v[mid]>v[mid+1]) {\n      ++ans;\n    }\n    if (max(L,l)< mid+1 && min(R,r)>mid+1 && v[mid+1] > v[mid] && v[mid+1]>v[mid+2]) {\n      ++ans;\n    }\n    return ans;\n  }\n} seg_tree;\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        seg_tree.build(1, 0, n-1, nums);\n        vi ans;\n        for(auto& q: queries) {\n          if (q[0] == 2) {\n            seg_tree.update(1, 0, n-1, q[1], q[1], q[2],nums);\n          } else {\n            ans.pb(seg_tree.query(1,0,n-1,q[1],q[2],nums));\n          }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1718508940",
    "subm_id": "539790185"
}