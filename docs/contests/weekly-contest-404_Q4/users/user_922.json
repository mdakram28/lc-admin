{
    "username": "Code-O-Maniac",
    "submission": "class Solution {\n    int maxi;\n    int x;\n    \n    void dfs(vector<vector<int>>& graph, vector<int>& vis, int i, int count) {\n        vis[i] = true;\n        count += 1;\n        \n        for(auto x:graph[i]) {\n            if(!vis[x]) {\n                if(count > maxi) {\n                    maxi = count;\n                    this->x = x;\n                }\n                \n                dfs(graph, vis, x, count);\n            }\n        }\n    }\n    int gogo(vector<vector<int>>& edges) {\n        if(edges.size() == 0) return 0;\n        this-> maxi = -1;\n        \n        int n = edges.size() + 1;\n        \n        vector<vector<int>> graph(n);\n        for(auto x:edges) {\n            graph[x[0]].push_back(x[1]);\n            graph[x[1]].push_back(x[0]);\n        }\n        \n        vector<int> vis(n);\n        dfs(graph, vis, 0, 0);\n        \n        vis = vector<int>(n);\n        dfs(graph, vis, x, 0);\n        \n        return maxi;\n    }\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int first = gogo(edges1);\n        int second = gogo(edges2);\n        \n        // if(min(first, second) == 0)\n        //     return max(first, second) + 1;\n        \n        // cout << first << \":\" << second << \"\\n\";\n        int mid = (first + 1) / 2;\n        int mid2 = (second + 1) / 2;\n        \n        return max({first, second, mid + mid2 + 1});\n    }\n};",
    "submit_ts": 1719719383.0
}