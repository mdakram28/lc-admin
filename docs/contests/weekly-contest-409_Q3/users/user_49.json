{
    "username": "tian-tang-6",
    "submission": "//Timestamp: 2024-08-04 11:08:43\n#define DROP\n#ifdef ONLINE\n#undef LOCAL\n#endif\n#ifndef LOCAL\n#undef _GLIBCXX_DEBUG\n#undef _DEBUG\n#endif\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <deque>\n#include <fstream>\n//#include <ext/pb_ds/assoc_container.hpp>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <type_traits>\n#include <chrono>\n#include <random>\n#include <complex>\n#include <bitset>\n#include <set>\n#include <list>\n#include <array>\n//#include \"compiler_hint.cpp\"\ntemplate <class T, int S>\nstruct MDVecDef {\n  using Type = std::vector<typename MDVecDef<T, S - 1>::Type>;\n  template <typename... Args>\n  static Type Make(int n, Args... args) {\n    return Type(n, MDVecDef<T, S - 1>::Make(args...));\n  }\n};\ntemplate <class T>\nstruct MDVecDef<T, 0> {\n  using Type = T;\n  static Type Make(T val = T()) { return val; }\n};\ntemplate <class T, int S = 1>\nusing MDVec = typename MDVecDef<T, S>::Type;\n#ifndef M_PI\n#define M_PI 3.14159265358979323851280895940618620443274267017841L\n#endif\n#ifndef M_E\n#define M_E 2.718281828459045235428168107993940338928950950503355L\n#endif\n#ifdef LOCAL\n#define Assert(x) assert(x)\n#define DebugRun(X) X\n#define DebugPoint int _x_ = 0; _x_++;\n#else\n#define Debug(...) 42\n#define DebugFmtln(...) 42\n#define Assert(x) 42\n#define DebugRun(X)\n#define DebugPoint\n#endif\n#define Trace(x) DebugFmtln(\"Line %d: %s\", __LINE__, #x)\ntemplate<class T>\ninline T DebugRet(T x) {\n    Debug(x);\n    return x;\n}\n#define const_ref(T) const T &\n#define mut_ref(T) T &\n#define let auto\n#define var auto\n#define MEMSET0(X) std::memset(&X, 0, sizeof(X)) \n#define Size(T) int((T).size())\n#define All(data) data.begin(), data.end()\n#define MakeUnique(data) data.resize(std::unique(All(data)) - data.begin())\n#define MakeUniqueAndSort(data) Sort(All(data)); MakeUnique(data) \n#define MakeAttribute(struct_name, Type, attr_name)               \\\n  struct struct_name {                                            \\\n    using attr_name ## _type = Type;                              \\\n    Type attr_name;                                               \\\n    mut_ref(Type) get_##attr_name() { return attr_name; }         \\\n    const_ref(Type) get_##attr_name() const { return attr_name; } \\\n  };\n#define MakeTemplateAttribute(struct_name, attr_name)          \\\n  template <class T>                                           \\\n  struct struct_name {                                         \\\n    using attr_name##_type = T;                             \\\n    T attr_name;                                               \\\n    mut_ref(T) get_##attr_name() { return attr_name; }         \\\n    const_ref(T) get_##attr_name() const { return attr_name; } \\\n  };\n#define ImplDefaultEq(name)                        \\\n  bool operator==(const name &a, const name &b) {  \\\n    return std::memcmp(&a, &b, sizeof(name)) == 0; \\\n  }                                                \\\n  bool operator!=(const name &a, const name &b) { return !(a == b); }\n#define ImplDefaultComparision(name)                                \\\n  bool operator>(const name &rhs) const { return rhs < *this; }     \\\n  bool operator<=(const name &rhs) const { return !(*this > rhs); } \\\n  bool operator>=(const name &rhs) const { return !(*this < rhs); }\n#define ImplArithmeticAssignOperation(name)                                 \\\n  name &operator+=(const name &rhs) { return *this = (*this) + rhs; } \\\n  name &operator-=(const name &rhs) { return *this = (*this) - rhs; } \\\n  name &operator*=(const name &rhs) { return *this = (*this) * rhs; } \\\n  name &operator/=(const name &rhs) { return *this = (*this) / rhs; }\n#define IsType(Type, param, ret_type)                                        \\\n  template <typename OnlyWhenArg = param>                                    \\\n  enable_if_t<is_same_v<OnlyWhenArg, param> && is_same_v<OnlyWhenArg, Type>, \\\n              ret_type>\n#define IsBool(param, ret_type)       \\\n  template <bool OnlyWhenArg = param> \\\n  enable_if_t<OnlyWhenArg == (param) && OnlyWhenArg, ret_type>\n#define IsBoolStatic(param, ret_type) \\\n  template <bool OnlyWhenArg = param> \\\n  static enable_if_t<OnlyWhenArg == (param) && OnlyWhenArg, ret_type>\n#define MakeAnnotation(name)         \\\n  template <class T>                 \\\n  struct is_##name {                 \\\n    static const bool value = false; \\\n  };                                 \\\n  template <class T>                 \\\n  inline constexpr bool is_##name##_v = is_##name<T>::value;\n#define AssignAnnotation(cls, annotation) \\\n  template <>                             \\\n  struct is_##annotation<cls> {           \\\n    static const bool value = true;       \\\n  };\n#define AssignAnnotationTemplate(cls, annotation, type) \\\n  template <type T>                                     \\\n  struct is_##annotation<cls<T>> {                      \\\n    static const bool value = true;                     \\\n  };\n#define FunctionAlias(from, to)                       \\\n  template <typename... Args>                         \\\n  inline auto to(Args &&...args)                      \\\n      ->decltype(from(std::forward<Args>(args)...)) { \\\n    return from(std::forward<Args>(args)...);         \\\n  }\n#define CastToScalar(field, type) \\\n  operator type() const { return type(field); }\n#define CastToAllScalar(field) \\\n  CastToScalar(field, i8);     \\\n  CastToScalar(field, u8);     \\\n  CastToScalar(field, i16);    \\\n  CastToScalar(field, u16);    \\\n  CastToScalar(field, i32);    \\\n  CastToScalar(field, u32);    \\\n  CastToScalar(field, i64);    \\\n  CastToScalar(field, u64);    \\\n  CastToScalar(field, f32);    \\\n  CastToScalar(field, f64);    \\\n  CastToScalar(field, f80);\n#define COMMA ,\n#ifndef LOCAL\nstd::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());\n#else\nstd::mt19937 rng(0);\n#endif\ntemplate <class T> T random_choice(T l, T r, std::mt19937 &gen = rng) {\n  std::uniform_int_distribution<T> random(l, r);\n  return random(gen);\n}\nnamespace dalt {\n#ifndef LOCAL\nstruct Timer {explicit Timer(const char* m) {}void stop() const {}};\n#else\n#endif\n}\nusing i8 = char;\nusing i16 = short;\nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u16 = unsigned short;\nusing u32 = unsigned int;\nusing u64 = unsigned long long;\nusing usize = size_t;\nusing f32 = float;\nusing f64 = double;\n// 16 exp, 64 precision\nusing f80 = long double;\nFunctionAlias(std::lower_bound, LowerBound);\nFunctionAlias(std::upper_bound, UpperBound);\nFunctionAlias(std::unique, Unique);\nFunctionAlias(std::swap, Swap);\nFunctionAlias(std::min, Min);\nFunctionAlias(std::max, Max);\nFunctionAlias(std::abs, Abs);\nFunctionAlias(std::sin, Sin);\nFunctionAlias(std::asin, Asin);\nFunctionAlias(std::cos, Cos);\nFunctionAlias(std::acos, Acos);\nFunctionAlias(std::tan, Tan);\nFunctionAlias(std::atan, Atan);\nFunctionAlias(std::sort, Sort);\nFunctionAlias(std::fill, Fill);\nFunctionAlias(std::move, Move);\nFunctionAlias(std::reverse, Reverse);\nFunctionAlias(std::max_element, MaxElement);\nFunctionAlias(std::min_element, MinElement);\nFunctionAlias(std::make_tuple, MakeTuple);\nFunctionAlias(std::make_pair, MakePair);\nFunctionAlias(std::clamp, Clamp);\nFunctionAlias(std::shuffle, Shuffle);\nFunctionAlias(std::to_string, ToString);\nFunctionAlias(std::tie, Tie);\nFunctionAlias(std::get<0>, Get0);\nFunctionAlias(std::get<1>, Get1);\nFunctionAlias(std::get<2>, Get2);\nFunctionAlias(std::get<3>, Get3);\nFunctionAlias(std::get<4>, Get4);\ntemplate <typename _Signature>\nusing Function = std::function<_Signature>;\ntemplate <typename _Signature>\nusing Func = Function<_Signature>;\nusing Str = std::string;\nusing String = Str;\nusing StringStream = std::stringstream;\nusing IStream = std::istream;\nusing OStream = std::ostream;\nusing std::enable_if;\nusing std::enable_if_t;\nusing std::is_base_of;\nusing std::is_base_of_v;\nusing std::is_floating_point;\nusing std::is_floating_point_v;\nusing std::is_integral;\nusing std::is_integral_v;\nusing std::is_arithmetic;\nusing std::is_arithmetic_v;\nusing std::is_same;\nusing std::is_same_v;\nusing std::tie;\nauto &Stderr = std::cerr;\nauto &Stdin = std::cin;\nauto &Stdout = std::cout;\ntemplate <class T>\nusing Less = std::less<T>;\ntemplate <class T>\nusing Greater = std::greater<T>;\ntemplate <typename _Key, typename _Tp, typename _Compare = Less<_Key>>\nusing TreeMap = std::map<_Key, _Tp, _Compare>;\ntemplate <typename _Key, typename _Compare = Less<_Key>>\nusing TreeSet = std::set<_Key, _Compare>;\ntemplate <typename _Key, typename _Compare = std::less<_Key>,\n          typename _Alloc = std::allocator<_Key>>\nusing MultiTreeSet = std::multiset<_Key, _Compare, _Alloc>;\ntemplate <class T>\nusing Deque = std::deque<T>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Vec = std::vector<T>;\ntemplate <class T>\nusing Reducer = Func<T(const T &, const T &)>;\ntemplate <class T>\nusing Comparator = Func<bool(const T &, const T &)>;\ntemplate <class T>\nusing Indexer = Func<T(i32)>;\ntemplate <class T>\nusing Indexer2 = Func<T(i32, i32)>;\ntemplate <class A, class B = A, class C = A>\nusing Adder = Func<C(const A &, const B &)>;\ntemplate <class I>\nusing Checker = Func<bool(const I &)>;\ntemplate <class A, class B>\nusing BiChecker = Func<bool(const A &, const B &)>;\ntemplate <class T>\nusing Consumer = Func<void(const T &)>;\ntemplate<class T>\nusing Supplier = Func<T()>;\ntemplate <class FIRST, class SECOND>\nusing BiConsumer = Func<void(const FIRST &, const SECOND &)>;\ntemplate <class F, class T = F>\nusing Mapper = Func<T(const F &)>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, Vec<T>, Greater<T>>;\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T, Vec<T>, Less<T>>;\ntemplate <class T, usize S>\nusing Array = std::array<T, S>;\ntemplate <typename... _Elements>\nusing Tuple = std::tuple<_Elements...>;\ntemplate <class T, class = enable_if_t<is_floating_point_v<T>>>\nusing Complex = std::complex<T>;\ntemplate <class A, class B>\nusing Pair = std::pair<A, B>;\nnamespace dalt {\ntemplate <class T>\nIStream& operator>>(IStream& is, Vec<T>& val) {\n  for (auto& v : val) {\n    is >> v;\n  }\n  return is;\n}\n#define VEC_OP(op)                         \\\n  template <class T>                       \\\n  Vec<T>& operator op(Vec<T>& data, T x) { \\\n    for (auto& v : data) {                 \\\n      v op x;                              \\\n    }                                      \\\n    return data;                           \\\n  }\nVEC_OP(+=)\nVEC_OP(-=)\nVEC_OP(*=)\nVEC_OP(/=)\nVEC_OP(%=)\nVEC_OP(^=)\nVEC_OP(&=)\nVEC_OP(|=)\nVEC_OP(==)\nVEC_OP(!=)\ntemplate <class T>\nint Compare(const Vec<T>& lhs, const Vec<T>& rhs) {\n  for(int i = 0; i < Size(lhs) && i < Size(rhs); i++) {\n    if(lhs[i] != rhs[i]) {\n      return lhs[i] < rhs[i] ? -1 : 1;\n    }\n  }\n  return Size(lhs) < Size(rhs) ? -1 : Size(lhs) > Size(rhs) ? 1 : 0;\n}\ntemplate <class T>\nbool operator<(const Vec<T>& lhs, const Vec<T>& rhs) {\n  return Compare(lhs, rhs) < 0;\n}\ntemplate <class T>\nbool operator>(const Vec<T>& lhs, const Vec<T>& rhs) {\n  return Compare(lhs, rhs) > 0;\n}\ntemplate <class T>\nbool operator<=(const Vec<T>& lhs, const Vec<T>& rhs) {\n  return Compare(lhs, rhs) <= 0;\n}\ntemplate <class T>\nbool operator>=(const Vec<T>& lhs, const Vec<T>& rhs) {\n  return Compare(lhs, rhs) >= 0;\n}\n}  // namespace dalt\n//#include \"array_adder.cpp\"\n#ifndef _builtin_clz\ninline i32 _builtin_clz(u32 i) {\n  // HD, Count leading 0's\n  if (i <= 0) return i == 0 ? 32 : 0;\n  int n = 31;\n  if (i >= 1 << 16) {\n    n -= 16;\n    i >>= 16;\n  }\n  if (i >= 1 << 8) {\n    n -= 8;\n    i >>= 8;\n  }\n  if (i >= 1 << 4) {\n    n -= 4;\n    i >>= 4;\n  }\n  if (i >= 1 << 2) {\n    n -= 2;\n    i >>= 2;\n  }\n  return n - (i >> 1);\n}\n#endif\n#ifndef _builtin_clzll\ninline i32 _builtin_clzll(u64 i) {\n  u32 x = u32(i >> 32);\n  return x == 0 ? 32 + _builtin_clz((int)i) : _builtin_clz(x);\n}\n#endif\n#ifndef _builtin_ctz\ninline i32 _builtin_ctz(u32 i) {\n  // HD, Figure 5-14\n  int y;\n  if (i == 0) return 32;\n  int n = 31;\n  y = i << 16;\n  if (y != 0) {\n    n = n - 16;\n    i = y;\n  }\n  y = i << 8;\n  if (y != 0) {\n    n = n - 8;\n    i = y;\n  }\n  y = i << 4;\n  if (y != 0) {\n    n = n - 4;\n    i = y;\n  }\n  y = i << 2;\n  if (y != 0) {\n    n = n - 2;\n    i = y;\n  }\n  return n - ((i << 1) >> 31);\n}\n#endif\n#ifndef _builtin_ctzll\ninline i32 _builtin_ctzll(u64 i) {\n  // HD, Figure 5-14\n  int x, y;\n  if (i == 0) return 64;\n  int n = 63;\n  y = (int)i;\n  if (y != 0) {\n    n = n - 32;\n    x = y;\n  } else\n    x = (int)(i >> 32);\n  y = x << 16;\n  if (y != 0) {\n    n = n - 16;\n    x = y;\n  }\n  y = x << 8;\n  if (y != 0) {\n    n = n - 8;\n    x = y;\n  }\n  y = x << 4;\n  if (y != 0) {\n    n = n - 4;\n    x = y;\n  }\n  y = x << 2;\n  if (y != 0) {\n    n = n - 2;\n    x = y;\n  }\n  return n - ((x << 1) >> 31);\n}\n#endif\n#ifndef _builtin_popcount\ninline i32 _builtin_popcount(u32 i) {\n  // HD, Figure 5-2\n  i = i - ((i >> 1) & 0x55555555);\n  i = (i & 0x33333333) + ((i >> 2) & 0x33333333);\n  i = (i + (i >> 4)) & 0x0f0f0f0f;\n  i = i + (i >> 8);\n  i = i + (i >> 16);\n  return i & 0x3f;\n}\n#endif\n#ifndef _builtin_popcountll\ninline i32 _builtin_popcountll(u64 i) {\n  // HD, Figure 5-2\n  i = i - ((i >> 1) & 0x5555555555555555ll);\n  i = (i & 0x3333333333333333ll) + ((i >> 2) & 0x3333333333333333ll);\n  i = (i + (i >> 4)) & 0x0f0f0f0f0f0f0f0fll;\n  i = i + (i >> 8);\n  i = i + (i >> 16);\n  i = i + (i >> 32);\n  return (int)i & 0x7f;\n}\n#endif\nnamespace dalt {\ninline i32 LeadingZeroNumber(u32 x) {\n  if (x == 0) return 32;\n  return _builtin_clz(x);\n}\ninline i32 LeadingZeroNumber(i32 x) { return LeadingZeroNumber(u32(x)); }\ninline i32 LeadingZeroNumber(u64 x) {\n  if (x == 0) return 64;\n  return _builtin_clzll(x);\n}\ninline i32 LeadingZeroNumber(i64 x) { return LeadingZeroNumber(u64(x)); }\ninline i32 TrailingZeroNumber(u32 x) {\n  if (x == 0) return 32;\n  return _builtin_ctz(x);\n}\ninline i32 TrailingZeroNumber(i32 x) { return TrailingZeroNumber(u32(x)); }\ninline i32 TrailingZeroNumber(u64 x) {\n  if (x == 0) return 64;\n  return _builtin_ctzll(x);\n}\ninline i32 TrailingZeroNumber(i64 x) { return TrailingZeroNumber(u64(x)); }\ninline i32 Log2Ceil(u32 x) {\n  if (x == 0) {\n    return 0;\n  }\n  return 32 - LeadingZeroNumber(x - 1);\n}\ninline i32 Log2Ceil(u64 x) {\n  if (x == 0) {\n    return 0;\n  }\n  return 64 - LeadingZeroNumber(x - 1);\n}\ninline i32 Log2Floor(u32 x) {\n  if (x == 0) {\n    return -1;\n  }\n  return 31 - LeadingZeroNumber(x);\n}\ninline i32 Log2Floor(u64 x) {\n  if (x == 0) {\n    return -1;\n  }\n  return 63 - LeadingZeroNumber(x);\n}\ninline i32 Log2Ceil(i32 x) { return Log2Ceil(u32(x)); }\ninline i32 Log2Ceil(i64 x) { return Log2Ceil(u64(x)); }\ninline i32 Log2Floor(i32 x) { return Log2Floor(u32(x)); }\ninline i32 Log2Floor(i64 x) { return Log2Floor(u64(x)); }\ninline i32 CountBit(u32 x) { return _builtin_popcount(x); }\ninline i32 CountBit(i32 x) { return CountBit(u32(x)); }\ninline i32 CountBit(u64 x) { return _builtin_popcountll(x); }\ninline i32 CountBit(i64 x) { return CountBit(u64(x)); }\ninline i32 HighestOneBitOffset(u32 x) { return Log2Floor(x); }\ninline i32 HighestOneBitOffset(i32 x) { return HighestOneBitOffset(u32(x)); }\ninline i32 HighestOneBitOffset(u64 x) { return Log2Floor(x); }\ninline i32 HighestOneBitOffset(i64 x) { return HighestOneBitOffset(u64(x)); }\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> LowestOneBit(T x) {\n  return x & -x;\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> HighestOneBit(T x) {\n  if (x == 0) {\n    return x;\n  }\n  return T(1) << HighestOneBitOffset(x);\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, i32> LowestOneBitOffset(T x) {\n  if (x == 0) {\n    return -1;\n  }\n  return HighestOneBitOffset(LowestOneBit(x));\n}\ninline u32 HighestKOnes32(i32 k) {\n  if (k == 0) {\n    return 0;\n  }\n  return (~u32()) << (32 - k);\n}\ninline u64 HighestKOnes64(i32 k) {\n  if (k == 0) {\n    return 0;\n  }\n  return (~u64()) << (64 - k);\n}\ninline u32 LowestKOnes32(i32 k) {\n  if (k == 0) {\n    return 0;\n  }\n  return (~u32()) >> (32 - k);\n}\ninline u64 LowestKOnes64(i32 k) {\n  if (k == 0) {\n    return 0;\n  }\n  return (~u64()) >> (64 - k);\n}\ninline u64 IntervalOnes64(i32 l, i32 r) {\n  if (l > r) {\n    return 0;\n  }\n  u64 high = r < 63 ? (u64(-1) << r + 1) : 0;\n  u64 low = u64(-1) << l;\n  return high ^ low;\n}\ninline u32 IntervalOnes32(i32 l, i32 r) {\n  if (l > r) {\n    return 0;\n  }\n  u32 high = r < 31 ? (u32(-1) << r + 1) : 0;\n  u32 low = u32(-1) << l;\n  return high ^ low;\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, i32> KthBit(T x, i32 k) {\n  return (x >> k) & 1;\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> SetBit(T x, i32 k) {\n  return x | (T(1) << k);\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> ClearBit(T x, i32 k) {\n  return x & ~(T(1) << k);\n}\n}  // namespace dalt\nnamespace dalt {\ntemplate <class T> enable_if_t<is_integral_v<T>, T> DivFloor(T a, T b) {\n  Assert(b > 0);\n  auto ans = a / b;\n  if (ans * b > a) {\n    ans = ans - 1;\n  }\n  return ans;\n}\ntemplate <class T> enable_if_t<is_integral_v<T>, T> DivCeil(T a, T b) {\n  Assert(b > 0);\n  auto ans = a / b;\n  if (ans * b < a) {\n    ans = ans + 1;\n  }\n  return ans;\n}\ntemplate <class T>\nenable_if_t<is_floating_point_v<T>, T> DivFloor(T a, T b) {\n  return a / b;\n}\ntemplate <class T>\nenable_if_t<is_floating_point_v<T>, T> DivCeil(T a, T b) {\n  return a / b;\n}\ntemplate <class T>\nenable_if_t<is_integral_v<T>, T> SmallerValue(T val) {\n  return val - 1;\n}\ntemplate <class T>\nenable_if_t<is_integral_v<T>, T> LargerValue(T val) {\n  return val + 1;\n}\ntemplate <class T>\nenable_if_t<is_floating_point_v<T>, T> SmallerValue(T val) {\n  return val;\n}\ntemplate <class T>\nenable_if_t<is_floating_point_v<T>, T> LargerValue(T val) {\n  return val;\n}\n} // namespace dalt\nnamespace dalt {\ntemplate <class T>\nstruct Optional {\n  using Self = Optional<T>;\n private:\n  T val;\n  bool show_up;\n public:\n  Optional(const T &arg_val) : val(arg_val), show_up(true) {}\n  Optional(const T &&arg_val) : val(arg_val), show_up(true) {}\n  Optional() : show_up(false) {}\n  const T &value() const {\n    Assert(show_up);\n    return val;\n  }\n  T &value() {\n    Assert(show_up);\n    return val;\n  }\n  T &operator*() { return value(); }\n  const T &operator*() const { return value(); }\n  bool is_some() const { return show_up; }\n  bool is_none() const { return !show_up; }\n  const T *operator->() const {\n    return &value();\n  }\n  T *operator->() { return &value(); }\n  inline operator T() const { return value(); }\n  T or_else(T def) const {\n    if (is_some()) {\n      return val;\n    } else {\n      return def;\n    }\n  }\n  template <class E>\n  Optional<E> map(const Mapper<T, E> &mapper) const {\n    if (is_some()) {\n      return mapper(value());\n    } else {\n      return Optional<E>();\n    }\n  }\n  bool operator==(const Self &b) const {\n    return show_up == b.show_up && (!show_up || val == b.val);\n  }\n};\ntemplate <class E>\nbool operator!=(const Optional<E> &a, const Optional<E> &b) {\n  return !(a == b);\n}\ntemplate <class E>\nOStream &operator<<(OStream &os, const Optional<E> &v) {\n  if (v.is_none()) {\n    os << \"{}\";\n  } else {\n    os << '{' << v.value() << '}';\n  }\n  return os;\n}\n}  // namespace dalt\nnamespace dalt {\ntemplate <class T>\nenable_if_t<is_integral_v<T>, Optional<T>> FirstTrue(\n    T l, T r, const Checker<T> &checker) {\n  if (!checker(r)) {\n    return {};\n  }\n  while (l < r) {\n    T m = DivFloor<T>(l + r, 2);\n    if (checker(m)) {\n      r = m;\n    } else {\n      l = m + 1;\n    }\n  }\n  return l;\n}\ntemplate <class T>\nenable_if_t<is_integral_v<T>, Optional<T>> LastTrue(T l, T r,\n                                                    const Checker<T> &checker) {\n  if (!checker(l)) {\n    return {};\n  }\n  while (l < r) {\n    T m = DivCeil<T>(l + r, 2);\n    if (checker(m)) {\n      l = m;\n    } else {\n      r = m - 1;\n    }\n  }\n  return l;\n}\ntemplate <class T>\nenable_if_t<is_floating_point_v<T>, Optional<T>> FirstTrue(\n    T l, T r, const Checker<T> &checker, Function<bool()> stopper) {\n  if (!checker(r)) {\n    return {};\n  }\n  while (!stopper()) {\n    T m = (l + r) / 2;\n    if (checker(m)) {\n      r = m;\n    } else {\n      l = m;\n    }\n  }\n  return l;\n}\ntemplate <class T>\nenable_if_t<is_floating_point_v<T>, Optional<T>> FirstTrue(\n    T l, T r, const Checker<T> &checker, i32 max_round) {\n  return FirstTrue<T>(\n      l, r, checker,[&]() { return max_round-- <= 0; });\n}\n}  // namespace dalt\nusing namespace dalt;\n// #include \"collection.cpp\"\n// #include \"combination.cpp\"\n// #include \"function.cpp\"\nnamespace dalt {\nnamespace graph {\ntemplate <class E>\nusing Graph = Vec<Vec<E>>;\nMakeAttribute(WithId, i32, id);\nMakeAttribute(WithTo, i32, to);\nMakeAttribute(WithRev, i32, rev);\nMakeTemplateAttribute(WithWeight, weight);\nstruct DiBaseEdge: public WithTo {};\nstruct BiBaseEdge: public DiBaseEdge, public WithRev {};\n#define IsDiGraph(E, ret) enable_if_t<is_base_of_v<DiBaseEdge, E>, ret>\n#define IsBiGraph(E, ret) enable_if_t<is_base_of_v<BiBaseEdge, E>, ret>\ntemplate <class E>\nIsDiGraph(E, void) AddDiEdge(Graph<E> &g, int s, int t) {\n  E pos;\n  pos.to = t;\n  g[s].push_back(pos);\n}\ntemplate <class E> IsBiGraph(E, void) AddBiEdge(Graph<E> &g, int s, int t) {\n  E pos, neg;\n  pos.to = t;\n  neg.to = s;\n  pos.rev = Size(g[t]);\n  neg.rev = Size(g[s]);\n  g[s].push_back(pos);\n  g[t].push_back(neg);\n}\n} // namespace graph\n} // namespace dalt\n//#include \"shortest_path.cpp\"\nnamespace dalt {\ntemplate <class A, class B>\ninline A& Chmin(A& a, const B& b) {\n  if (a > b) {\n    a = b;\n  }\n  return a;\n}\ntemplate <class T>\ninline T& Chmin(T& a, const T& b, const Comparator<T> &comp) {\n  if (comp(b, a)) {\n    a = b;\n  }\n  return a;\n}\ntemplate <class A, class B>\ninline A& Chmax(A& a, const B& b) {\n  if (a < b) {\n    a = b;\n  }\n  return a;\n}\ntemplate <class T>\ninline T& Chmax(T& a, const T& b, const Comparator<T>& comp) {\n  if (comp(a, b)) {\n    a = b;\n  }\n  return a;\n}\ntemplate <class T>\ninline T& AddTo(T& a, const T& b) {\n  a = a + b;\n  return a;\n}\ntemplate <class T>\ninline T& MulTo(T& a, const T& b) {\n  a = a * b;\n  return a;\n}\ntemplate <class T>\ninline T& SubFrom(T& a, const T& b) {\n  a = a - b;\n  return a;\n}\ntemplate <class T>\ninline T& DivFrom(T& a, const T& b) {\n  a = a / b;\n  return a;\n}\ntemplate <class T, class E>\nconstexpr enable_if_t<is_integral_v<E>, T> PowBinaryLift(T x, E n) {\n  if (n == E(0)) {\n    return T(1);\n  }\n  auto ans = PowBinaryLift(x, n >> 1);\n  ans = ans * ans;\n  if (n & 1) {\n    ans = ans * x;\n  }\n  return ans;\n}\ntemplate <class T>\ninline T MulLimit(T a, T b, T max, T def) {\n  if (a == T(0) || b == T(0)) {\n    return T(0);\n  }\n  // a * b <= max\n  // a <= max / b\n  // a <= floor(max / b)\n  if (a <= max / b) {\n    return a * b;\n  } else {\n    return def;\n  }\n}\ntemplate <class T>\ninline T MulLimit(T a, T b, T max) {\n  return MulLimit(a, b, max, max);\n}\ntemplate <class T>\ninline T AddLimit(T a, T b, T max, T def) {\n  if (a <= max - b) {\n    return a + b;\n  } else {\n    return def;\n  }\n}\ntemplate <class T>\ninline T AddLimit(T a, T b, T max) {\n  return AddLimit(a, b, max, max);\n}\ni64 Round(f32 x) { return roundf(x); }\ni64 Round(f64 x) { return round(x); }\ni64 Round(f80 x) { return roundl(x); }\n//l + ... + r\ntemplate<class T>\nT SumOfInterval(T l, T r) {\n  if(l > r) {\n    return T(0);\n  }\n  return (l + r) * (r - l + 1) / T(2);\n}\ntemplate<class T>\nT Pow2(T x) {\n  return x * x;\n}\n}  // namespace dalt\n// #include \"radix.cpp\"\n// #include \"modint.cpp\"\n// using Mi = ModInt1000000007;\n//  #include \"prefix_sum.cpp\"\nnamespace dalt {\ntemplate <class T, int N>\nstruct PrefixSum {\n  using Self = PrefixSum<T, N>;\n  Vec<PrefixSum<T, N - 1>> ps;\n  PrefixSum(){}\n  PrefixSum(const MDVec<T, N>& data) {\n    ps.reserve(Size(data));\n    int k = Size(data);\n    for (int i = 0; i < k; i++) {\n      ps.emplace_back(data[i]);\n      if (i > 0) {\n        ps[i] += ps[i - 1];\n      }\n    }\n  }\n  int size() const {\n    return ps.size();\n  }\n  const PrefixSum<T, N - 1>& operator[](int i) const {\n    return ps[i];\n  }\n  friend Self& operator+=(Self& a, const Self& b) {\n    for (int i = 0; i < Size(a); i++) {\n      a.ps[i] += b.ps[i];\n    }\n    return a;\n  }\n  template <typename... Args>\n  T query(int l, int r, Args... args) const {\n    return ps[r].query(args...) - (l - 1 < 0 ? T() : ps[l - 1].query(args...));\n  }\n  template <typename... Args>\n  T query_with_check(int l, int r, Args... args) const {\n    l = Max(0, l);\n    r = Min(r, Size(ps) - 1);\n    if(l > r) {\n      return T();\n    }\n    return ps[r].query_with_check(args...) -\n           (l - 1 < 0 ? T() : ps[l - 1].query_with_check(args...));\n  }\n};\ntemplate <class T>\nstruct PrefixSum<T, 0> {\n  using Self = PrefixSum<T, 0>;\n  T data;\n  PrefixSum(const MDVec<T, 0>& _data) : data(_data) {}\n  friend Self& operator+=(Self& a, const Self& b) { a.data += b.data; return a; }\n  T query() const { return data; }\n  T query_with_check() const { return data; }\n};\n}  // namespace dalt\nusing namespace std;\nusing namespace graph;\nnamespace dalt {\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> Gcd(T a, T b) {\n  while (b != 0) {\n    a %= b;\n    Swap(a, b);\n  }\n  return a;\n}\n// ret_value = [x, y, gcd(a,b)] that x * a + y * b = gcd(a, b)\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, Array<T, 3>> ExtGcd(T a, T b) {\n  if (b == 0) {\n    return Array<T, 3>{1, 0, a};\n  }\n  auto div = a / b;\n  auto ans = ExtGcd(b, a - b * div);\n  auto x = ans[0];\n  auto y = ans[1];\n  return Array<T, 3>{y, x - a / b * y, ans[2]};\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, Optional<T>> PossibleModInverse(\n    T a, T modulus) {\n  auto res = ExtGcd(a, modulus);\n  if (res[2] == 1) {\n    auto ans = res[0] % modulus;\n    if (ans < 0) {\n      ans += modulus;\n    }\n    return ans;\n  }\n  return {};\n}\n}  // namespace dalt\n// #include \"dsu.cpp\"\n//   #include \"segtree.cpp\"\nusing namespace dalt;\nnamespace dalt {\ntemplate <class T, class C>\nIndexer<T> MakeIndexer(const C &data) {\n  return [&](auto i) -> T { return data[i]; };\n}\ntemplate <class T, class C>\nIndexer<T> MakeReverseIndexer(const C &data) {\n  return [&](auto i) -> T { return data[Size(data) - 1 - i]; };\n}\ntemplate <class T>\nVec<T> ExpandIndexer(int n, const Indexer<T> &indexer) {\n  Vec<T> ans;\n  ans.reserve(n);\n  for (int i = 0; i < n; i++) {\n    ans.push_back(indexer(i));\n  }\n  return ans;\n}\nIndexer<i32> SelfIndexer() {\n  return [](auto i) { return i; };\n}\ntemplate <class T>\nIndexer<T> ConstantIndexer(const T &val) {\n  return [=](auto i) { return val; };\n}\ntemplate <class A, class B>\nMapper<A, B> ConstructorMapper() {\n  return [&](auto a) { return B(a); };\n}\ntemplate <class T>\nAdder<T> NaturalAdder() {\n  return [](auto a, auto b) { return a + b; };\n}\ntemplate <class A, class B, class C>\nconstexpr Adder<A, B, C> EmptyAdder() {\n  return [](auto a, auto b) { return C(); };\n}\ntemplate <class A, class B = A>\nconstexpr Adder<A, B, A> ReturnLeftAdder() {\n  return [](auto a, auto b) { return a; };\n}\ntemplate <class A, class B = A>\nconstexpr Adder<A, B, B> ReturnRightAdder() {\n  return [](auto a, auto b) { return b; };\n}\ntemplate <class T>\nIndexer<int> BinaryIndexer(const T& val) {\n  return [=](int i) {return int((val >> i) & 1);};\n}\ntemplate <class T>\nIndexer<int> ReverseIndexer(int n, Indexer<T> indexer) {\n  return [=](int i) {return indexer(n - 1 - i);};\n}\n}  // namespace dalt\n//#include \"kmp.cpp\"\n// #include \"interval_map.cpp\"\n// #include \"matrix.cpp\"\n// #include \"hash_range.cpp\"\n// #include \"hashmap.cpp\"\n//#include \"binary_tree.cpp\"\n#ifdef LOCAL\nstruct TreeNode\n{\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode()\n      : val(0),\n        left(nullptr), right(nullptr) {}\n  TreeNode(int x)\n      : val(x),\n        left(nullptr),\n        right(nullptr) {}\n  TreeNode(int x, TreeNode *left, TreeNode *right)\n      : val(x),\n        left(left), right(right) {}\n};\n#endif\n// #include \"interval_map.cpp\"\n// #include \"hash_range.cpp\"\n//#include \"segtree_beat.cpp\"\n//#include \"sparse_table.cpp\"\n//#include \"binary.cpp\"\nnamespace dalt {\ntemplate <class T>\nstruct FenwickTree {\n private:\n  // data[i] = \\sum_{j \\in (i-lowbit(i), i]} A[i]\n  Vec<T> data;\n  int n;\n  int hb;\n public:\n  FenwickTree(int _n = 0) {\n    n = _n;\n    data = Vec<T>(n + 1);\n    hb = HighestOneBit(n);\n  }\n  // find the smallest index i while A[0] + ... + A[i] >= v, if no such index, n will be returned\n  T lower_bound(T v) const {\n    T sum = T();\n    int pos = 0;\n    for (int i = hb; i > 0; i >>= 1) {\n      int np = pos + i;\n      if (np <= n && sum + data[np] < v) {\n        sum += data[np];\n        pos = np;\n      }\n    }\n    return pos;\n  }\n  // A[0] + ... + A[i]\n  T query(int i) const {\n    i += 1;\n    i = Min(i, n);\n    T sum = T();\n    for (; i > 0; i -= i & -i) {\n      sum = sum + data[i];\n    }\n    return sum;\n  }\n  // A[l] + ... + A[r]\n  T query(int l, int r) const {\n    if (l > r) {\n      return T();\n    }\n    return query(r) - query(l - 1);\n  }\n  // A[i] += mod\n  void update(int i, T mod) {\n    i += 1;\n    if (i <= 0) {\n      return;\n    }\n    for (; i <= n; i += i & -i) {\n      data[i] += mod;\n    }\n  }\n  void update(int l, int r, T mod) {\n    if (l > r) {\n      return;\n    }\n    l = Max(l, 0);\n    update(l, mod);\n    update(r + 1, -mod);\n  }\n  void recover(int i) {\n    i += 1;\n    if (i <= 0) {\n      return;\n    }\n    for (; i <= n; i += i & -i) {\n      data[i] = T();\n    }\n  }\n  int size() { return n; }\n  // A[i] = x\n  void set(int i, T x) { update(i, x - query(i, i)); }\n  FenwickTree(i32 _n, const Indexer<T> &initial_value) : FenwickTree(_n) {\n    for (int i = 1; i <= n; i++) {\n      data[i] = initial_value(i - 1);\n    }\n    for (int i = 1; i <= n; i++) {\n      int to = i + (i & -i);\n      if (to <= n) {\n        data[to] += data[i];\n      }\n    }\n  }\n  Vec<T> to_vec() {\n    Vec<T> ans(n);\n    for (int i = 0; i < n; i++) {\n      ans[i] = query(i, i);\n    }\n    return ans;\n  }\n};\n}  // namespace dalt\nnamespace dalt {\nstruct Nil {};\nNil operator+(const Nil &a, const Nil &b) { return Nil(); }\nNil operator-(const Nil &a, const Nil &b) { return Nil(); }\nNil operator*(const Nil &a, const Nil &b) { return Nil(); }\nNil operator/(const Nil &a, const Nil &b) { return Nil(); }\nbool operator==(const Nil &a, const Nil &b) { return true; }\nbool operator!=(const Nil &a, const Nil &b) { return false; }\nOStream &operator<<(OStream &os, const Nil &b) {\n  os << \"{}\";\n  return os;\n}\n} // namespace dalt\nnamespace dalt {\nnamespace sbt {\ntemplate <class S, class U, i64 ID = 0, class CID = Nil>\nstruct SelfBalanceTreeRegistry {\n  using TypeS = S;\n  using TypeU = U;\n  static S s_nil;\n  static U u_nil;\n  static Adder<S, S> s_s;\n  static Adder<S, U> s_u;\n  static Adder<U, U> u_u;\n  static bool initialized;\n  static void Register(S _s_nil, U _u_nil, const Adder<S, S> &_s_s,\n                       const Adder<S, U> &_s_u, const Adder<U, U> &_u_u) {\n    s_nil = _s_nil;\n    u_nil = _u_nil;\n    s_s = _s_s;\n    s_u = _s_u;\n    u_u = _u_u;\n  }\n};\ntemplate <class S, class U, i64 ID, class CID>\nS SelfBalanceTreeRegistry<S, U, ID, CID>::s_nil;\ntemplate <class S, class U, i64 ID, class CID>\nbool SelfBalanceTreeRegistry<S, U, ID, CID>::initialized = false;\ntemplate <class S, class U, i64 ID, class CID>\nU SelfBalanceTreeRegistry<S, U, ID, CID>::u_nil;\ntemplate <class S, class U, i64 ID, class CID>\nAdder<S, S> SelfBalanceTreeRegistry<S, U, ID, CID>::s_s;\ntemplate <class S, class U, i64 ID, class CID>\nAdder<S, U> SelfBalanceTreeRegistry<S, U, ID, CID>::s_u;\ntemplate <class S, class U, i64 ID, class CID>\nAdder<U, U> SelfBalanceTreeRegistry<S, U, ID, CID>::u_u;\nMakeAnnotation(sbt_registry);\ntemplate<class S, class U, i64 ID, class CID>\nstruct is_sbt_registry<SelfBalanceTreeRegistry<S, U, ID, CID>> {\n  static const bool value = true;\n};\n}  // namespace sbt\n}  // namespace dalt\nnamespace dalt {\nnamespace sbt {\ntemplate<class T = i32>\ninline bool SegmentNoIntersection(T L, T R, T l, T r) {\n  return R < l || r < L;\n}\ntemplate <class T = i32>\ninline bool SegmentCover(T L, T R, T l, T r) {\n  return L <= l && r <= R;\n}\n}  // namespace sbt\n}  // namespace dalt\nnamespace dalt {\nnamespace sbt {\n#define CLASS_ID -202202131500\ntemplate <class SBT, bool P = false, bool SPARSE = false, i64 ID = 0>\nstruct SegTree {\n  static_assert(is_sbt_registry_v<SBT>);\n  static_assert(i64(P) + i64(SPARSE) <= 1);\n  using S = typename SBT::TypeS;\n  using U = typename SBT::TypeU;\n  struct Node {\n    using Self = Node;\n    Self *left;\n    Self *right;\n    S sum;\n    U upd;\n#ifdef DROP\n    ~Node() {\n      if (this == NIL) {\n        return;\n      }\n      delete left;\n      delete right;\n    }\n#endif\n    Self* clone() {\n      if (SPARSE) {\n        if (this == NIL) {\n          return new Node(*NIL);\n        }\n        return this;\n      } else if (P) {\n        return new Node(*this);\n      } else {\n        return this;\n      }\n    }\n    void push_up() { sum = SBT::s_s(left->sum, right->sum); }\n    void push_down() {\n      left = left->clone();\n      right = right->clone();\n      if (upd != SBT::u_nil) {\n        left->modify(upd);\n        right->modify(upd);\n        upd = SBT::u_nil;\n      }\n    }\n    void modify(const U &u) {\n      sum = SBT::s_u(sum, u);\n      upd = SBT::u_u(upd, u);\n    }\n  };\n  using Self = SegTree<SBT, P, SPARSE, ID>;\n  static Node *NIL;\n  Node *tree;\n  i64 n;\n private:\n  Node *make_node() {\n    Node *ans = new Node{\n        .left = NIL,\n        .right = NIL,\n        .sum = SBT::s_nil,\n        .upd = SBT::u_nil,\n    };\n    return ans;\n  }\n  IsBool(P, Node *) make_tree() {\n    Node *root = make_node();\n    root->left = root->right = root;\n    return root;\n  }\n  IsBool(!P, Node *) make_tree() {\n    Node *root = make_node();\n    return root;\n  }\n public:\n  IsBoolStatic(SPARSE, void)\n      Register(S _s_nil, U _u_nil, const Adder<S, S> &_s_s,\n               const Adder<S, U> &_s_u, const Adder<U, U> &_u_u) {\n    SBT::Register(_s_nil, _u_nil, _s_s,\n                                                      _s_u, _u_u);\n    NIL = new Node();\n    NIL->left = NIL;\n    NIL->right = NIL;\n    NIL->upd = _u_nil;\n    NIL->sum = _s_nil;\n  }\n  IsBoolStatic(!SPARSE, void)\n      Register(S _s_nil, U _u_nil, const Adder<S, S> &_s_s,\n               const Adder<S, U> &_s_u, const Adder<U, U> &_u_u) {\n    SBT::Register(_s_nil, _u_nil, _s_s,\n                                                      _s_u, _u_u);\n  }\n  Self clone() const {\n    Self ans = *this;\n    ans.tree = ans.tree->clone();\n    return ans;\n  }\n  SegTree(\n      i64 _n = 0,\n      const Indexer<S> &indexer = [](i64 index) { return SBT::s_nil; })\n      : n(_n) {\n    auto dfs = [&](auto &dfs, i64 l, i64 r) -> Node * {\n      Node *root = make_tree();\n      root->upd = SBT::u_nil;\n      if (l == r) {\n        root->sum = indexer(l);\n      } else {\n        i64 m = (l + r) / 2;\n        root->left = dfs(dfs, l, m);\n        root->right = dfs(dfs, m + 1, r);\n        root->push_up();\n      }\n      return root;\n    };\n    if(n <= 0) {\n      tree = make_tree();\n    } else {\n      tree = dfs(dfs, 0, n - 1);\n    }\n  }\n  IsBoolStatic(SPARSE, Self) MakeSparseTree(i64 n) {\n    Self res(1);\n    res.n = n;\n    return res;\n  }\n  IsBoolStatic(P, Self) MakePersistentTree(i64 n) {\n    Self res(1);\n    res.n = n;\n    return res;\n  }\n  S query(i64 L, i64 R) {\n    auto dfs = [&](auto &dfs, Node *root, i64 l, i64 r) {\n      if (SegmentNoIntersection(L, R, l, r)) {\n        return SBT::s_nil;\n      }\n      if (SegmentCover(L, R, l, r)) {\n        return root->sum;\n      }\n      root->push_down();\n      i64 m = (l + r) / 2;\n      auto lsum = dfs(dfs, root->left, l, m);\n      auto rsum = dfs(dfs, root->right, m + 1, r);\n      return SBT::s_s(lsum, rsum);\n    };\n    return dfs(dfs, tree, 0, n - 1);\n  }\n  S query_const(i64 L, i64 R) const {\n    auto dfs = [&](auto &dfs, Node *root, i64 l, i64 r, const U &upd) {\n      if (SegmentNoIntersection(L, R, l, r)) {\n        return SBT::s_nil;\n      }\n      if (SegmentCover(L, R, l, r)) {\n        return SBT::s_u(root->sum, upd);\n      }\n      U new_upd = SBT::u_u(root->upd, upd);\n      i64 m = (l + r) / 2;\n      auto lsum = dfs(dfs, root->left, l, m, new_upd);\n      auto rsum = dfs(dfs, root->right, m + 1, r, new_upd);\n      return SBT::s_s(lsum, rsum);\n    };\n    return dfs(dfs, tree, 0, n - 1, SBT::u_nil);\n  }\n  void update(i64 L, i64 R, const U &upd) {\n    auto dfs = [&](auto &dfs, Node *root, i64 l, i64 r) {\n      if (SegmentNoIntersection(L, R, l, r)) {\n        return;\n      }\n      if (SegmentCover(L, R, l, r)) {\n        root->modify(upd);\n        return;\n      }\n      root->push_down();\n      i64 m = (l + r) / 2;\n      dfs(dfs, root->left, l, m);\n      dfs(dfs, root->right, m + 1, r);\n      root->push_up();\n    };\n    dfs(dfs, tree, 0, n - 1);\n  }\n  void travel(const Consumer<S> &consumer) const {\n    auto dfs = [&](auto &dfs, Node *root, const U &upd, i64 l, i64 r) {\n      // is leaf\n      if (l == r) {\n        consumer(SBT::s_u(root->sum, upd));\n        return;\n      }\n      i64 m = (l + r) / 2;\n      U new_upd = SBT::u_u(root->upd, upd);\n      dfs(dfs, root->left, new_upd, l, m);\n      dfs(dfs, root->right, new_upd, m + 1, r);\n    };\n    dfs(dfs, tree, SBT::u_nil, 0, n - 1);\n  }\n  Vec<S> to_vec() const {\n    Vec<S> res;\n    res.reserve(n);\n    travel([&](auto x) { res.push_back(x); });\n    return res;\n  }\n  Optional<Tuple<i64, S>> first_true(i64 L, i64 R, const Checker<S> &checker) {\n    S sum = SBT::s_nil;\n    auto dfs = [&](auto &dfs, Node *root, i64 l, i64 r) -> Optional<i64> {\n      if (SegmentNoIntersection(L, R, l, r)) {\n        return {};\n      }\n      if (SegmentCover(L, R, l, r)) {\n        S new_sum = SBT::s_s(sum, root->sum);\n        if (!checker(new_sum)) {\n          sum = new_sum;\n          return {};\n        }\n        if (l == r) {\n          // leaf\n          sum = new_sum;\n          return l;\n        }\n      }\n      root->push_down();\n      i64 m = (l + r) / 2;\n      auto lres = dfs(dfs, root->left, l, m);\n      if (lres.is_none()) {\n        return dfs(dfs, root->right, m + 1, r);\n      }\n      return lres;\n    };\n    auto res = dfs(dfs, tree, 0, n - 1);\n    Mapper<i64, Tuple<i64, S>> mapper = [&](const i64 &x) -> Tuple<i64, S> {\n      return Tuple<i64, S>(x, sum);\n    };\n    return res.map(mapper);\n  }\n  Optional<Tuple<i64, S>> last_true(i64 L, i64 R, const Checker<S> &checker) {\n    S sum = SBT::s_nil;\n    auto dfs = [&](auto &dfs, Node *root, i64 l, i64 r) -> Optional<i64> {\n      if (SegmentNoIntersection(L, R, l, r)) {\n        return {};\n      }\n      if (SegmentCover(L, R, l, r)) {\n        S new_sum = SBT::s_s(sum, root->sum);\n        if (checker(new_sum)) {\n          sum = new_sum;\n          return r;\n        }\n        if (l == r) {\n          return {};\n        }\n      }\n      root->push_down();\n      i64 m = (l + r) / 2;\n      auto lres = dfs(dfs, root->left, l, m);\n      if ((lres.is_some() && lres.value() == m) || m < L) {\n        auto rres = dfs(dfs, root->right, m + 1, r);\n        if (rres.is_some()) {\n          return rres;\n        }\n      }\n      return lres;\n    };\n    auto res = dfs(dfs, tree, 0, n - 1);\n    Mapper<i64, Tuple<i64, S>> mapper = [&](const i64 &x) -> Tuple<i64, S> {\n      return Tuple<i64, S>(x, sum);\n    };\n    return res.map(mapper);\n  }\n  Optional<Tuple<i64, S>> first_true_const(i64 L, i64 R,\n                                           const Checker<S> &checker,\n                                           const S& init_sum = SBT::s_nil) const {\n    S sum = init_sum;\n    auto dfs = [&](auto &dfs, Node *root, const U &upd, i64 l,\n                   i64 r) -> Optional<i64> {\n      if (SegmentNoIntersection(L, R, l, r)) {\n        return {};\n      }\n      if (SegmentCover(L, R, l, r)) {\n        S new_sum = SBT::s_s(sum, SBT::s_u(root->sum, upd));\n        if (!checker(new_sum)) {\n          sum = new_sum;\n          return {};\n        }\n        if (l == r) {\n          // leaf\n          sum = new_sum;\n          return l;\n        }\n      }\n      U new_upd = SBT::u_u(root->upd, upd);\n      i64 m = (l + r) / 2;\n      auto lres = dfs(dfs, root->left, new_upd, l, m);\n      if (lres.is_none()) {\n        return dfs(dfs, root->right, new_upd, m + 1, r);\n      }\n      return lres;\n    };\n    auto res = dfs(dfs, tree, SBT::u_nil, 0, n - 1);\n    Mapper<i64, Tuple<i64, S>> mapper = [&](const i64 &x) -> Tuple<i64, S> {\n      return Tuple<i64, S>(x, sum);\n    };\n    return res.map(mapper);\n  }\n  Optional<Tuple<i64, S>> last_true_const(i64 L, i64 R,\n                                          const Checker<S> &checker) const {\n    S sum = SBT::s_nil;\n    auto dfs = [&](auto &dfs, Node *root, const U &upd, i64 l,\n                   i64 r) -> Optional<i64> {\n      if (SegmentNoIntersection(L, R, l, r)) {\n        return {};\n      }\n      if (SegmentCover(L, R, l, r)) {\n        S new_sum = SBT::s_s(sum, SBT::s_u(root->sum, upd));\n        if (checker(new_sum)) {\n          sum = new_sum;\n          return r;\n        }\n        if (l == r) {\n          // leaf\n          return {};\n        }\n      }\n      U new_upd = SBT::u_u(root->upd, upd);\n      i64 m = (l + r) / 2;\n      auto lres = dfs(dfs, root->left, new_upd, l, m);\n      if ((lres.is_some() && lres.value() == m) || m < L) {\n        auto rres = dfs(dfs, root->right, new_upd, m + 1, r);\n        if (rres.is_some()) {\n          return rres;\n        }\n      }\n      return lres;\n    };\n    auto res = dfs(dfs, tree, SBT::u_nil, 0, n - 1);\n    Mapper<i64, Tuple<i64, S>> mapper = [&](const i64 &x) -> Tuple<i64, S> {\n      return Tuple<i64, S>(x, sum);\n    };\n    return res.map(mapper);\n  }\n  IsBool(!(P || SPARSE), void) destroy() { delete tree; }\n  IsBool(P || SPARSE, void) destroy() {}\n  // to support merge, only support single poi64 update\n  IsBoolStatic(SPARSE, Self) merge(Self a, Self b, const Adder<S, S> &adder) {\n    assert(a.n == b.n);\n    auto dfs = [&](auto &dfs, Node *a, Node *b, i64 l, i64 r) -> Node * {\n      if (a == NIL) {\n        return b;\n      }\n      if (b == NIL) {\n        return a;\n      }\n      if (l == r) {\n        a->sum = adder(a->sum, b->sum);\n        return a;\n      }\n      i64 m = (l + r) / 2;\n      // a->push_down();\n      // b->push_down();\n      a->left = dfs(dfs, a->left, b->left, l, m);\n      a->right = dfs(dfs, a->right, b->right, m + 1, r);\n      a->push_up();\n      return a;\n    };\n    a.tree = dfs(dfs, a.tree, b.tree, 0, a.n - 1);\n    return a;\n  }\n#ifdef DROP\n  ~SegTree() { destroy(); }\n#endif\n};\n#undef CLASS_ID\ntemplate <class SBT, bool P, bool SPARSE, i64 ID>\ntypename SegTree<SBT, P, SPARSE, ID>::Node\n    *SegTree<SBT, P, SPARSE, ID>::NIL = NULL;\n}  // namespace sbt\n}  // namespace dalt\nclass Solution\n{\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        FenwickTree<int> ft(n);\n        for(int i = 0; i < n; i++) {\n          ft.update(i, i, n - 1 - i);\n        }\n        using SBT = sbt::SelfBalanceTreeRegistry<int, int>;\n        var max = [&](int a, int b) {\n          return Max(a, b);\n        };\n        SBT::Register(-1, -1, max, max, max);\n        var segtree = sbt::SegTree<SBT>(n, [&](int i) {return i;});\n        Vec<int> ans;\n        for(var &q : queries) {\n          int a = q[0];\n          int b = q[1];\n          if(segtree.query(a, a) < b) {\n            segtree.update(a, b, b);\n            int dist_a = ft.query(a);\n            int dist_b = ft.query(b);\n            int new_dist = dist_b + 1;\n            ft.update(0, a, new_dist - dist_a);\n          }\n          ans.push_back(ft.query(0));\n        }\n        return ans;\n    }\n};\n#ifdef LOCAL\nint main()\n{\n  return 0;\n}\n#endif",
    "submit_ts": "1722740938",
    "subm_id": "552334767"
}