{
    "username": "CheriBhai",
    "submission": "class Solution {\npublic:\n    class SegmentTree {\npublic:\n   vector<int>seg;\n   int n;\n\n   SegmentTree(int n)\n   {\n      seg = vector<int>(4 * n + 1, INT_MAX);\n      this->n = n;\n   }\n\n   // Tree will constructed using divide and conquere approach\n   // It we be constructed Bottoms up using recursion\n   void buildTree(vector<int>&arr, int start, int end, int index)\n   {\n      if (start == end)\n      {\n         seg[index] = arr[start];\n         return;\n      }\n      int mid = (start + end) / 2;\n      buildTree(arr, start, mid, 2 * index);\n      buildTree(arr, mid + 1, end, 2 * index + 1);\n\n      /* By this we can find the min of the segment tree by checking the index of child nodes\n         with current node\n      */\n      seg[index] = seg[2 * index] & seg[2 * index + 1];\n   }\n\n   int query(int ss, int se, int qs, int qe, int index)\n   {\n      // Complete Overlap\n      if (qs <= ss and qe >= se)\n      {\n         return seg[index];\n      }\n\n      // No overlap\n      if (qs > se || qe < ss)\n      {\n         return INT_MAX;\n      }\n\n      // Partial Overlap\n      int mid = (ss + se) / 2;\n      int left = query(ss, mid, qs, qe, 2 * index);\n      int right = query(mid + 1, se, qs, qe, 2 * index + 1);\n      return left&right;\n   }\n\n   void update(int ss, int se, int i, int val, int index)\n   {\n      // Where the i do not like in the range i.e No Overlap\n      if (i < ss || i > se)return;\n\n      //Complete overlap i.e index found\n      if (ss == se)\n      {\n         seg[index] += val;\n         return;\n      }\n\n      // otherwise we will come from down to up and update the value\n      // if they are updating with new value\n\n      int mid = (ss + se) / 2;\n      update(ss, mid, i, val, 2 * index);\n      update(mid + 1, se, i, val, 2 * index + 1);\n\n      seg[index] = seg[2 * index] & seg[2 * index + 1];\n      return;\n   }\n   // The worst case complexity for this can be O(n) in some case we to traverse whole tree\n   // which will take time of O(n)\n   void updateRange(int ss,int se,int l,int r,int val,int index)\n   {\n      // No overlap\n      if(r<ss||l>se)return;\n\n      // In this it is getting overlaped completly hence we are updating the value for the range (each point present in range)\n      if(ss==se)\n      {\n         seg[index]+=val;\n         return;\n      }\n      // Otherwise we will go recursively in down to top manner\n\n      int mid = (ss+se)/2;\n      updateRange(ss,mid,l,r,val,2*index);\n      updateRange(mid+1,se,l,r,val,2*index+1);\n\n      seg[index] = min(seg[2*index],seg[2*index+1]);\n   }\n\n};\n    int firstOccurence(int idx,int start, int end,SegmentTree* st,int k,int n)\n    {\n        int ans = -1;\n        while(start<=end)\n        {\n            int mid = (start+end)/2;\n            int x = st->query(0,n-1,idx,mid,1);\n            if(x==k)\n            {\n                ans=mid;\n                end = mid-1;\n            }\n            else if(x > k)\n            {\n                start = mid+1;\n            }\n            else\n            {\n                end = mid - 1;\n            }\n        }\n        return ans;\n    }\n    int lastOccurence(int idx,int start, int end,SegmentTree* st,int k,int n)\n    {\n        int ans = -1;\n        while(start<=end)\n        {\n            int mid = (start+end)/2;\n            int x = st->query(0,n-1,idx,mid,1);\n            if(x==k)\n            {\n                ans = mid;\n                start = mid+1;\n            }\n            else if(x > k)\n            {\n                start = mid+1;\n            }\n            else\n            {\n                end = mid-1;\n            }\n            \n        }\n        return ans;\n    }\n    long long countSubarrays(vector<int>& nums, int k) {\n        int n = nums.size();\n        SegmentTree* s = new SegmentTree(n);\n        s->buildTree(nums,0,n-1,1);\n        long long ans = 0;\n        for(int i=0;i<n;i++)\n        {\n            int a = firstOccurence(i,i,n-1,s,k,n);\n            int b = lastOccurence(i,i,n-1,s,k,n);\n            if(a==-1)continue;\n            ans+=(b-a+1);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720280929",
    "subm_id": "1311807081"
}