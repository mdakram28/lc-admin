{
    "username": "stupid_panda",
    "submission": "impl Solution {\n    pub fn minimum_distance(points: Vec<Vec<i32>>) -> i32 {\n        let n = points.len();\n        let mut sums: Vec<i32> = vec![];\n        let mut diffs: Vec<i32> = vec![];\n        for p in &points {\n            sums.push(p[0] + p[1]);\n            diffs.push(p[0] - p[1]);\n        }\n        sums.sort_unstable();\n        diffs.sort_unstable();\n        let mut ans = i32::MAX;\n        for p in &points {\n            let sum = p[0] + p[1];\n            let diff = p[0] - p[1];\n            let mut max_d = 0;\n            max_d = max_d.max(if sum == sums[0] {\n                sums[n - 1] - sums[1]\n            } else if sum == sums[n - 1] {\n                sums[n - 2] - sums[0]\n            } else {\n                sums[n - 1] - sums[0]\n            });\n            max_d = max_d.max(if diff == diffs[0] {\n                diffs[n - 1] - diffs[1]\n            } else if diff == diffs[n - 1] {\n                diffs[n - 2] - diffs[0]\n            } else {\n                diffs[n - 1] - diffs[0]\n            });\n            ans = ans.min(max_d);\n        }\n        ans\n    }\n}"
}