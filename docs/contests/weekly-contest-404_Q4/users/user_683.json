{
    "username": "C4T",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def findMinHeightTrees(n, edges):\n            adj = defaultdict(list)\n            indegrees = defaultdict(int)\n            if n == 0:\n                return []\n            if n == 1:\n                return [0]\n            for i in edges:\n                adj[i[0]].append(i[1])\n                adj[i[1]].append(i[0])\n                indegrees[i[0]] += 1\n                indegrees[i[1]] += 1\n\n            vis = set()\n            q = deque()\n\n            for i in range(n):\n                if indegrees[i] == 1:\n                    q.append(i)\n                    indegrees[i] -= 1\n\n            ans = []\n            while q:\n                ans.clear()\n                level = len(q)\n                for _ in range(level):\n                    ele = q.popleft()\n\n                    for c in adj[ele]:\n                        indegrees[c] -= 1\n                        if indegrees[c] == 1:\n                            q.append(c)\n                    ans.append(ele)\n\n            return ans\n        \n        t1 = findMinHeightTrees(len(edges1) + 1, edges1)\n        t2 = findMinHeightTrees(len(edges2) + 1, edges2)\n        \n        opt1 = t1[0]\n        opt2 = t2[0]\n        \n        new_id = 10**5\n        ids = defaultdict(int)\n        for i in range(len(edges2) + 1):\n            ids[i] = new_id\n            new_id += 1\n        \n        for i in range(len(edges2)):\n            edges2[i][0] = ids[edges2[i][0]]\n            edges2[i][1] = ids[edges2[i][1]]\n            \n            \n        \n        edges1.append([opt1, ids[opt2]])\n        edges1.extend(edges2)\n        print(edges1)\n        best = findMinHeightTrees(len(edges1) + len(edges2) + 2, edges1)\n        adj = defaultdict(list)\n        for f, t in edges1:\n            adj[f].append(t)\n            adj[t].append(f)\n            \n        @cache\n        def depth(node, parent):\n            if node is None:\n                return 0\n            ans = 0\n            for c in adj[node]:\n                if parent != c:\n                    ans = max(ans, 1 + depth(c, node))\n            return ans\n                    \n        ans = 0\n        ind = defaultdict(int)\n        for f, t in edges1:\n            ind[f] += 1\n            ind[t] += 1\n        \n        leaf = min(ind.values())\n        ans = 0\n        for i in ind:\n            if ind[i] == leaf:\n                ans = max(ans, depth(i, i))\n        return ans\n\n        \n            \n        \n        \n        \n        # calculate max depth of each node\n        \n        \n        \n        # for the 2 nodes with samllest depth, conenct them\n        \n        # then redo the max depth of each node ig",
    "submit_ts": 1719718937.0
}