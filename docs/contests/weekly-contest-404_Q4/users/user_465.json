{
    "username": "XMQUPM4Vvp",
    "submission": "class Solution {\npublic:\n    int vis[100001];\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        dfs(edges1, 0);\n        int tmp1 = 0;\n        for (int k = 1; k <= edges1.size(); k++) {\n            if (vis[k] > vis[tmp1]) {\n                tmp1 = k;\n            }\n        }\n        dfs(edges1, tmp1);\n        int len1 = 0;\n        for (int k = 0; k <= edges1.size(); k++) {\n            len1 = max(len1, vis[k]);\n        }\n        cout << len1 << endl;\n        dfs(edges2, 0);\n        int tmp2 = 0;\n        for (int k = 1; k <= edges2.size(); k++) {\n            if (vis[k] > vis[tmp2]) {\n                tmp2 = k;\n            }\n        }\n        dfs(edges2, tmp2);\n        int len2 = 0;\n        for (int k = 0; k <= edges2.size(); k++) {\n            len2 = max(len2, vis[k]);\n        }\n        cout << len2 << endl;\n        int ans = len1 / 2 + 1 + len2 / 2;\n        ans = max(ans, max(len1, len2) - 1);\n        return ans;\n    }\n    void dfs(vector<vector<int>> & tree, int root) {\n        vector<int> edges[100001];\n        for (auto t : tree) {\n            edges[t[0]].push_back(t[1]);\n            edges[t[1]].push_back(t[0]);\n        }\n        queue<int> pass;\n        memset(vis, 0, sizeof(vis));\n        pass.push(root);\n        vis[root] = 1;\n        while (!pass.empty()) {\n            int x = pass.front();\n            pass.pop();\n            for (auto y : edges[x]) {\n                if (vis[y] == 0) {\n                    pass.push(y);\n                    vis[y] = vis[x] + 1;\n                }\n            }\n        }\n    }\n};",
    "submit_ts": 1719717647.0
}