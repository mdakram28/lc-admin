{
    "username": "jqodiriy",
    "submission": "class Solution {\npublic:\nclass SegmentTree {\nprivate:\n    vector<int> tree;\n    vector<int> arr;\n    int n;\n\n    void buildTree(int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            buildTree(2 * node, start, mid);\n            buildTree(2 * node + 1, mid + 1, end);\n            tree[node] = max(tree[2 * node], tree[2 * node + 1]);\n        }\n    }\n\n    int queryTree(int node, int start, int end, int l, int r) {\n        if (r < start || end < l) {\n            return INT_MIN; // Out of range\n        }\n        if (l <= start && end <= r) {\n            return tree[node]; // Current segment is fully within range\n        }\n        int mid = (start + end) / 2;\n        int leftQuery = queryTree(2 * node, start, mid, l, r);\n        int rightQuery = queryTree(2 * node + 1, mid + 1, end, l, r);\n        return max(leftQuery, rightQuery);\n    }\n\n    void updateTree(int node, int start, int end, int idx, int newValue) {\n        if (start == end) {\n            arr[idx] = newValue;\n            tree[node] = newValue;\n        } else {\n            int mid = (start + end) / 2;\n            if (idx <= mid) {\n                updateTree(2 * node, start, mid, idx, newValue);\n            } else {\n                updateTree(2 * node + 1, mid + 1, end, idx, newValue);\n            }\n            tree[node] = max(tree[2 * node], tree[2 * node + 1]);\n        }\n    }\n\npublic:\n    SegmentTree(const vector<int>& input) {\n        arr = input;\n        n = input.size();\n        tree.resize(4 * n);\n        buildTree(1, 0, n - 1); \n    }\n\n    // Function to get maximum value in the range [l, r]\n    int getMaxInRange(int l, int r) {\n        return queryTree(1, 0, n - 1, l, r);\n    }\n\n    // Function to update the value at index idx to newValue\n    void update(int idx, int newValue) {\n        updateTree(1, 0, n - 1, idx, newValue);\n    }\n};\nvector<bool> getResults(vector<vector<int>>& queries) {\n    int N = 50005;\n    vector <int> v(N, 0);\n    SegmentTree st(v);\n    vector <int> a(N, 0);\n    set <int> borders;\n    vector <bool> res;\n    st.update(0,N);\n    borders.insert(0);\n\n    for(auto q : queries) {\n        if(q[0] == 1){\n            int p = q[1];\n            auto it = borders.lower_bound(p);\n            if (it != borders.begin()) {\n                --it;\n                int bg = *it;\n                int cur = a[bg];\n                st.update(bg, p - bg);\n                st.update(p, cur - p + bg);\n                borders.insert(p);\n                a[bg] = p - bg;\n                a[p] = cur - p + bg;\n            }\n        }\n        else{\n            int x = q[1];\n            int sz = q[2];\n            auto it = borders.lower_bound(x);\n            --it;\n            int r = *it;\n            int mx = 0;\n            if(r >= 1) mx = st.getMaxInRange(0, r-1);\n            int m2 = x - r;\n            mx = max(m2, mx);\n            res.push_back(mx >= sz);\n        }\n    }\n    return res;\n}\n};",
    "submit_ts": "1716650130",
    "subm_id": "1267607181"
}