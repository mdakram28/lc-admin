{
    "username": "boAshraf",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        // Build the adjacency list for both edge lists\n        vector<vector<int>> adj1(edges1.size()+1);\n         vector<vector<int>> adj2(edges2.size()+1);\n         vector<vector<int>> adj3(edges1.size()+edges2.size()+5);\n\n        for (auto& edge : edges1) {\n            adj1[edge[0]].push_back(edge[1]);\n            adj1[edge[1]].push_back(edge[0]);\n\n            adj3[edge[0]].push_back(edge[1]);\n            adj3[edge[1]].push_back(edge[0]);\n        }\n\n        for (auto& edge : edges2) {\n            adj2[edge[0]].push_back(edge[1]);\n            adj2[edge[1]].push_back(edge[0]);\n            int add=edges1.size()+1;\n            adj3[edge[0]+add].push_back(edge[1]+add);\n            adj3[edge[1]+add].push_back(edge[0]+add);\n        }\n\n        // Find the diameter nodes in the merged forest\nauto farthestNodeWithPath = [&](int start, vector<vector<int>>& adj) {\n    if (adj.empty()) {\n        return make_pair(-1, vector<int>());\n    }\n    int n = adj.size();\n    vector<int> dist(n, -1); \n    vector<int> parent(n, -1); \n    queue<int> q;\n    \n    q.push(start);\n    dist[start] = 0;\n    parent[start] = -1;\n    int farthest = start;\n    int maxDist = 0;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        \n        for (int neighbor : adj[node]) {\n            if (dist[neighbor] == -1) { // Not visited\n                dist[neighbor] = dist[node] + 1;\n                parent[neighbor] = node;\n                q.push(neighbor);\n                \n                if (dist[neighbor] > maxDist) {\n                    maxDist = dist[neighbor];\n                    farthest = neighbor;\n                }\n            }\n        }\n    }\n    \n    vector<int> path;\n    int current = farthest;\n    while (current != -1) {\n        path.push_back(current);\n        current = parent[current];\n    }\n    \n    return make_pair(farthest, path);\n};\n\n\n        auto p1 = farthestNodeWithPath(farthestNodeWithPath(0,adj1).first,adj1);\n        auto p2 = farthestNodeWithPath(farthestNodeWithPath(0,adj2).first,adj2);\n        vector<int>mid1,mid2;\n        mid1.push_back(p1.second[p1.second.size()/2]);\n        if((int)(p1.second.size())%2==0){\n            mid1.push_back(p1.second[p1.second.size()/2-1]);\n        }\n        mid2.push_back(p2.second[p2.second.size()/2]);\n        if((int)(p2.second.size())%2==0){\n            mid2.push_back(p2.second[p2.second.size()/2-1]);\n        }\n        for(auto &it:mid2){\n            it+=edges1.size()+1;\n        }\n        int mx=1e9;\n        for(auto it1:mid1){\n            for(auto it2:mid2){\n                adj3[it1].push_back(it2);\n                adj3[it2].push_back(it1);\n                auto p = farthestNodeWithPath(farthestNodeWithPath(0,adj3).first,adj3);\n                mx=min(mx,(int)p.second.size());\n                adj3[it1].pop_back();\n                adj3[it2].pop_back();\n            }\n        }\n        return mx-1;\n    }\n};",
    "submit_ts": "1719719949",
    "subm_id": "1304454836"
}