{
    "username": "Ayush743",
    "submission": "class Solution {\npublic:\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        // edge case\n        if (n==1) return {0};\n        // create deg vector\n        vector<int> deg(n, 0);\n        // create adjacency matrix\n        vector<vector<int>> adj(n);\n        // add the relevant edges to adjacency matrix and the degree\n        for (auto& e : edges) {\n            int v = e[0], w = e[1];\n            adj[v].push_back(w);\n            adj[w].push_back(v);\n            deg[v]++;\n            deg[w]++;\n        }\n        // keep track of the leaves\n        queue<int> q; \n        // add the starting leaves\n        for (int i = 0; i < n; i++) {\n            if (deg[i] == 1)\n                q.push(i);\n        }\n        // declare vector for ans\n        vector<int> ans;\n\n        // check the remaining nodes\n        int remaining = n;\n        // as there are still leaves\n        while (!q.empty()) {\n            // find remaining without leaves\n            // use it for later iteration\n            int q_size = q.size();\n            remaining -= q_size;\n            // do a search on the leaves and update it to the next leave\n            for (int i = 0; i < q_size; i++) {\n                // get the current value\n                int v = q.front();\n                q.pop();\n                // if there is nothing remaining, all the current values \n                // are the middle nodes\n                if (remaining == 0) ans.push_back(v);\n                // in each leaves only add the next leaves\n                for (int w : adj[v]) {\n                    if (--deg[w] == 1)// remove edge connecting to v\n                        q.push(w);\n                }\n            }\n        }\n        return ans;\n    }\n    int bfs(int x,vector<vector<int>>& edges,int n)\n    {\n        vector<vector<int>> adj(n);\n        // add the relevant edges to adjacency matrix and the degree\n        for (auto& e : edges) {\n            int v = e[0], w = e[1];\n            adj[v].push_back(w);\n            adj[w].push_back(v);\n        }\n        vector<int>d(n,-1);\n        queue<int>q;\n        q.push(x);\n        d[x]=0;\n        int ans=0;\n        while(!q.empty())\n        {\n            int p=q.front();\n            q.pop();\n            for(int i:adj[p])\n            {\n                if(d[i]==-1)\n                {\n                    d[i]=1+d[p];\n                    q.push(i);\n                    ans=max(ans,d[i]);\n                }\n            }\n        }\n        return ans;\n    }\n    int dia=0;\n    int height(vector<vector<int>>& edges,int root,int par)\n    {\n        vector<int>h;\n        h.push_back(0);\n        h.push_back(0);\n        for(int i:edges[root])\n        {\n            if(i!=par)\n            {\n                int t=height(edges,i,root);\n                h.push_back(t);\n            }\n        }\n        sort(h.rbegin(),h.rend());\n        dia=max(dia,h[0]+h[1]);\n        return 1+h[0];\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n=edges1.size()+1;\n        vector<int>root1=findMinHeightTrees(n,edges1);\n        int m=edges2.size()+1;\n        vector<int>root2=findMinHeightTrees(m,edges2);\n        \n        int x1=root1[0];\n        int x2=root2[0];\n        vector<vector<int>> adj1(n);\n        // add the relevant edges to adjacency matrix and the degree\n        for (auto& e : edges1) {\n            int v = e[0], w = e[1];\n            adj1[v].push_back(w);\n            adj1[w].push_back(v);\n        }\n        vector<vector<int>> adj2(m);\n        // add the relevant edges to adjacency matrix and the degree\n        for (auto& e : edges2) {\n            int v = e[0], w = e[1];\n            adj2[v].push_back(w);\n            adj2[w].push_back(v);\n        }\n        int h1=height(adj1,x1,-1);\n        int d1=dia;\n        dia=0;\n        int h2=height(adj2,x2,-1);\n        int d2=dia;\n        return max({1+bfs(x1,edges1,n)+bfs(x2,edges2,m),d1,d2});\n        \n    }\n};",
    "submit_ts": 1719719205.0
}