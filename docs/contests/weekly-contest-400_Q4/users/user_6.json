{
    "username": "danielchandg",
    "submission": "#define ll int\nclass SparseTable{\n\tpublic:\n\tstruct node{\n\t\tll an;\n\t\tvoid apply(ll v){\n\t\t\tan=v;\n\t\t}\n\t};\n\tnode unite(node a, const node &b) const {\n    \tnode res;\n    \tres.an = a.an & b.an;\n        return res;\n    }\n\tint n;\n\tvector<vector<node>> Table;\n\tvector<ll> Lg; // Lg[i] = x is max 2^x <= i\n\tSparseTable(const vector<ll> &V){\n\t\tn=V.size();\n\t\tint i,j;\n\t\tassert(n>0 && n<=1e7);\n\t\tLg.resize(n+1);\n\t\tLg[1]=0;\n\t\tfor(i=2;i<=n;i++)\n\t\t\tLg[i]=Lg[i/2]+1;\n\t\tint K=Lg[n];\n\t\t// if((1<<K)<n) K++;\n\t\tTable.resize(n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tTable[i].resize(K+1);\n\t\t\tTable[i][0].apply(V[i]);\n\t\t}\n\t\tfor(j=1;j<=K;j++){\n\t\t\tfor(i=0;i+(1<<j)<=n;i++){\n\t\t\t\tTable[i][j] = unite(Table[i][j-1], Table[i+(1<<(j-1))][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\t// Get {min,max} on interval [l,r]\n\tnode rmq(int l, int r){\n\t\tassert(l<=r);\n\t\tassert(l>=0&&r>=0&&l<n&&r<n);\n\t\tint K=Lg[r-l+1];\n\t\treturn unite(Table[l][K], Table[r-(1<<K)+1][K]);\n\t}\n\t// Get {sum,min,max} on interval [l,r]\n\tnode query(int l, int r){\n\t\tassert(l<=r);\n\t\tassert(l>=0&&r>=0&&l<n&&r<n);\n\t\tint K=Lg[r-l+1];\n\t\tnode ans;\n\t\tans.an=(1<<30)-1;\n\t\tfor(int j=K;j>=0;j--){\n\t\t\tif((1<<j)<=r-l+1){\n\t\t\t\tans = unite(ans, Table[l][j]);\n\t\t\t\tl+=1<<j;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        int n = nums.size(), ans = 2e9;\n        SparseTable st(nums);\n        for(int i=0; i<n; i++){\n            int l=0, r=i;\n            while(l <= r){\n                int m = (l+r)/2;\n                int q = st.rmq(m, i).an;\n                if(q == k) return 0;\n                ans = min(ans, abs(q-k));\n                if(q > k) r = m - 1;\n                else l = m + 1;\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1717296098.0
}