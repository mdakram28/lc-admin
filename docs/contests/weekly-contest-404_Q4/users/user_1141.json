{
    "username": "adityaroyel",
    "submission": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm> \n\nusing namespace std;\n\nclass Solution {\npublic:\n    void dfs(int v, vector<bool>& visited, unordered_map<int, vector<int>>& adj, vector<int>& dist) {\n        visited[v] = true;\n        for (int neighbor : adj[v]) {\n            if (!visited[neighbor]) {\n                dist[neighbor] = dist[v] + 1;\n                dfs(neighbor, visited, adj, dist);\n            }\n        }\n    }\n\n    int findDiameter(int n, vector<vector<int>>& edges) {\n        if (n <= 1) return 0;\n        \n        \n        unordered_map<int, vector<int>> adj;\n        for (auto edge : edges) {\n            int a = edge[0];\n            int b = edge[1];\n            adj[a].push_back(b);\n            adj[b].push_back(a);\n        }\n\n        \n        vector<bool> visited(n, false);\n        vector<int> dist(n, 0);\n        dfs(0, visited, adj, dist);\n\n        \n        int maxDist = -1, farthestVertex = -1;\n        for (int i = 0; i < n; ++i) {\n            if (dist[i] > maxDist) {\n                maxDist = dist[i];\n                farthestVertex = i;\n            }\n        }\n\n        \n        fill(visited.begin(), visited.end(), false);\n        fill(dist.begin(), dist.end(), 0);\n        dfs(farthestVertex, visited, adj, dist);\n\n        \n        int diameter = *max_element(dist.begin(), dist.end());\n\n        return diameter;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n1 = edges1.size() + 1; \n        int n2 = edges2.size() + 1; \n        \n        int diameter1 = findDiameter(n1, edges1);\n        int diameter2 = findDiameter(n2, edges2);\n\n        int ans = 0;\n        ans += (diameter1%2 == 0)? diameter1/2:diameter1/2+1 ;\n        ans += (diameter2%2 == 0)? diameter2/2:diameter2/2+1 ;\n        \n        return max({ans+1,diameter1,diameter2});\n    }\n};\n",
    "submit_ts": 1719719976.0
}