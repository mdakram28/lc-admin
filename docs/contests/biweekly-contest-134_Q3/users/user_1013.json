{
    "username": "HakuLess",
    "submission": "class Solution {\n    fun numberOfAlternatingGroups(colors: IntArray, k: Int): Int {\n        val n = colors.size\n        val root = SegmentTree<Int>(start = 0, end = n * 3 + 5, value = 0) { a, b ->\n            a + b\n        }\n        for (i in colors.indices) {\n//            println(\"enter $i for ${n + i}\")\n            if (colors[i] != colors[(i - 1 + n) % n] && colors[i] != colors[(i + 1 + n) % n]) {\n                root.update(root, n + i, n + i, 1)\n                root.update(root, i, i, 1)\n//                println(\"update ${n + i} with 1\")\n            }\n        }\n//        root.print()\n        var ans = 0\n        for (i in 0 until n) {\n            val start = i + 1\n            val res = root.query(root, start, start + k - 3)\n//            println(\"query ${start}..${start + k - 3} with $res\")\n            if (res == k - 2) {\n                ans++\n            }\n        }\n        return ans\n    }\n}\n\nclass SegmentTree<T>(\n    val start: Int = 0,\n    val end: Int = 0,\n    var value: T? = null,\n    private var lazy: T? = null,\n    val merge: (a: T, b: T) -> T\n) {\n\n    var left: SegmentTree<T>? = null\n    var right: SegmentTree<T>? = null\n    val mid: Int\n        get() {\n            return start + (end - start) / 2\n        }\n\n    fun build(arr: Array<T>): SegmentTree<T>? {\n        return buildHelper(0, arr.lastIndex, arr)\n    }\n\n    private fun buildHelper(left: Int, right: Int, arr: Array<T>): SegmentTree<T>? {\n        if (left > right) return null\n        val root = SegmentTree(left, right, arr[left], null, merge)\n        if (left == right) return root\n        val mid = (left + right) / 2\n        root.left = buildHelper(left, mid, arr)\n        root.right = buildHelper(mid + 1, right, arr)\n        root.value = safeMerge(root.left?.value, root.right?.value)\n        return root\n    }\n\n    private fun build(left: Int, right: Int, default: T?): SegmentTree<T>? {\n        if (left > right) return null\n        return SegmentTree(left, right, default, null, merge)\n    }\n\n    fun update(root: SegmentTree<T>, l: Int, r: Int, v: T) {\n        if (l <= root.start && r >= root.end) {\n            root.value = v\n            root.lazy = safeMerge(root.lazy, v)\n            return\n        }\n        // \u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\n        if (root.left == null || root.right == null) {\n            val mid = root.mid\n            if (root.left == null)\n                root.left = build(root.start, mid, root.value)\n            if (root.right == null)\n                root.right = build(mid + 1, root.end, root.value)\n        }\n        pushDown(root)\n        val mid = root.mid\n        if (l <= mid) {\n            update(root.left!!, l, r, v)\n        }\n        if (r > mid) {\n            update(root.right!!, l, r, v)\n        }\n        root.value = merge(root.left!!.value!!, root.right!!.value!!)\n    }\n\n    private fun pushDown(root: SegmentTree<T>) {\n        if (root.lazy == null) return\n        root.left?.lazy = safeMerge(root.left?.lazy, root.lazy)\n        root.right?.lazy = safeMerge(root.right?.lazy, root.lazy)\n        root.left?.value = safeMerge(root.left?.value, root.lazy)\n        root.right?.value = safeMerge(root.right?.value, root.lazy)\n        root.lazy = null\n    }\n\n    fun update(root: SegmentTree<T>, index: Int, value: T) {\n        if (root.start == index && root.end == index) {\n            root.value = value\n            return\n        }\n        // \u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\n        if (root.left == null || root.right == null) {\n            val mid = root.mid\n            if (root.left == null)\n                root.left = build(root.start, mid, root.value)\n            if (root.right == null)\n                root.right = build(mid + 1, root.end, root.value)\n        }\n        val mid = root.mid\n        if (index <= mid) {\n            update(root.left!!, index, value)\n            root.value = safeMerge(root.left!!.value, root.right!!.value)\n        } else {\n            update(root.right!!, index, value)\n            root.value = safeMerge(root.left!!.value, root.right!!.value)\n        }\n    }\n\n    fun query(root: SegmentTree<T>, left: Int, right: Int): T {\n        if (left <= root.start && right >= root.end) {\n            return root.value!!\n        }\n        // \u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\n        if (root.left == null || root.right == null) {\n            val mid = root.mid\n            if (root.left == null)\n                root.left = build(root.start, mid, root.value)\n            if (root.right == null)\n                root.right = build(mid + 1, root.end, root.value)\n        }\n        pushDown(root)\n        val mid = root.mid\n        var ans: T? = null\n        if (mid >= left) {\n            ans = safeMerge(ans, query(root.left!!, left, right))\n        }\n        if (mid + 1 <= right) {\n            ans = safeMerge(ans, query(root.right!!, left, right))\n        }\n        return ans!!\n    }\n\n    private fun safeMerge(a: T?, b: T?): T? {\n        return when {\n            a == null -> b\n            b == null -> a\n            else -> merge(a, b)\n        }\n    }\n\n    // \u6ce8\u610flazy\u7684\u66f4\u65b0\u7b56\u7565\n    private fun lazyMerge(a: T?, b: T?): T? {\n        return b\n    }\n}",
    "submit_ts": "1720277736",
    "subm_id": "544558453"
}