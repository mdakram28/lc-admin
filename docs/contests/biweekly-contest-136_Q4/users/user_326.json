{
    "username": "Dipu_1",
    "submission": "class SegmentTree:\n    def __init__(self, length):\n        self.DEFAULT = 0\n        self.length = length\n        self.segtree = [self.DEFAULT] * (2 * length)\n\n    def f(self, a, b):\n        return max(a, b)\n\n    def set(self, ind, val):\n        ind += self.length\n        self.segtree[ind] = val\n        while ind > 1:\n            ind //= 2\n            self.segtree[ind] = self.f(self.segtree[2 * ind], self.segtree[2 * ind + 1])\n\n    def range(self, start, end):\n        res = self.DEFAULT\n        start += self.length\n        end += self.length\n        while start < end:\n            if start % 2 == 1:\n                res = self.f(res, self.segtree[start])\n                start += 1\n            if end % 2 == 1:\n                end -= 1\n                res = self.f(res, self.segtree[end])\n            start //= 2\n            end //= 2\n        return res\n\n\nclass Solution:\n    def dfs(self, i, par, adj, times, dp):\n        for x in adj[i]:\n            if x != par:\n                self.dfs(x, i, adj, times, dp)\n                if x % 2 == 0:\n                    dp[i] = max(dp[i], dp[x] + 2)\n                else:\n                    dp[i] = max(dp[i], dp[x] + 1)\n\n    def reroot(self, i, par, adj, times, dp, except_dict):\n        times[i] = dp[i]\n        for x in adj[i]:\n            if x != par:\n                lastdp1, lastdpx = dp[i], dp[x]\n                dp[i] = except_dict[(i, x)]\n                if i % 2 == 0:\n                    dp[x] = max(dp[x], dp[i] + 2)\n                else:\n                    dp[x] = max(dp[x], dp[i] + 1)\n                self.reroot(x, i, adj, times, dp, except_dict)\n                dp[i], dp[x] = lastdp1, lastdpx\n\n    def make_except(self, i, par, adj, except_dict, dp):\n        anss = [(x, dp[x]) for x in adj[i]]\n        seg = SegmentTree(len(anss))\n        for j, (f, s) in enumerate(anss):\n            if f % 2 == 0:\n                seg.set(j, s + 2)\n            else:\n                seg.set(j, s + 1)\n        \n        for j, (f, s) in enumerate(anss):\n            mxx = seg.range(j + 1, len(anss))\n            mxx = max(mxx, seg.range(0, j))\n            except_dict[(i, f)] = mxx\n\n        for x in adj[i]:\n            if x != par:\n                lastdpi, lastdpx = dp[i], dp[x]\n                dp[i] = except_dict[(i, x)]\n                if i % 2 == 0:\n                    dp[x] = max(dp[x], dp[i] + 2)\n                else:\n                    dp[x] = max(dp[x], dp[i] + 1)\n                self.make_except(x, i, adj, except_dict, dp)\n                dp[i], dp[x] = lastdpi, lastdpx\n\n    def timeTaken(self, edges):\n        n = len(edges) + 1\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        times = [0] * n\n        dp = [0] * n\n        self.dfs(0, -1, adj, times, dp)\n        except_dict = {}\n        dpc = dp[:]\n        self.make_except(0, -1, adj, except_dict, dpc)\n        self.reroot(0, -1, adj, times, dp, except_dict)\n        return times",
    "submit_ts": "1722699895",
    "subm_id": "1343225567"
}