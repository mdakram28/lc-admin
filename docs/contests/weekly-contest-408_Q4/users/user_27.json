{
    "username": "Chengqian_Li",
    "submission": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#if __linux__\n#else\n#ifndef _LOCAL\nstruct TreeNode{\n\tint val;\n};\nstruct ListNode{\n\tint val;\n\tListNode* next;\n\tListNode(){}\n\tListNode(int _val){val = _val;}\n\tListNode(int _val, ListNode* _next){val = _val; next = _next;}\n};\n#endif\n#endif\n\ntypedef vector<TreeNode*> vt;\ntypedef TreeNode* T;\ntypedef ListNode* L;\nint len(ListNode* h){int s = 0; for(auto p = h; p; p = p->next)s++; return s;}\nListNode* link(vector<ListNode*> &r){if (!r.size() || r[r.size() - 1]) r.push_back(nullptr); for (int i = 0; i < r.size() - 1; ++i) r[i]->next = r[i + 1]; return r[0];}\nvoid to(ListNode* p, vector<ListNode*> &r){\n\tr.clear();\n\twhile (p){\n\t\tr.push_back(p);\n\t\tp = p->next;\n\t}\n}\n\nvector<int>& operator+=(vector<int>& a, ListNode* b){for(ListNode* p = b; p; p = p->next)\ta.push_back(p->val);return a;}\nListNode* operator+=(ListNode*& a, vector<int>& b){a = 0;for(int i = b.size() - 1; i >= 0; --i)\ta = new ListNode(b[i], a);return a;}\n\n#ifndef _LOCAL\n#define D\n#define DD\n#define write\n#endif\n\n#define elif else if\n#define TA template<typename A>\n#define TB template<typename B>\n#define TAB template<typename A,typename B>\n#define TAB_ template <typename A, typename... B>\n#define TABC template<typename A, typename B, typename C>\n#define T4 template<typename T0, typename T1, typename T2, typename T3>\n#define be(a) a.begin(), a.end()\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define repp(p, h) for (auto p = h; p; p = p->next)\n#define _rep(i, n) for(int i = (n - 1); i >= 0; --i)\n#define rep2(i, j, n, m) for(int i = 0; i < (n); ++i)for(int j = 0; j < (m); ++j)\n#define _mm(r) memset(r, 0, sizeof(r))\n#define pb push_back\n#define _this (*this)\n#define fma(a, b, c) (ll(a) * ll(b) + ll(c))\n//emplace_back\n#define repa(x, r) for(auto& x: r)\n#define repaa(a, b, r) for(auto& [a, b]: r)\n#define repid(_id, i, n) for (int _##i = 0, i =  _id[_##i]; _##i < (n); ++_##i, i = _id[_##i])\n#define REP(i, a, b) for(int i = (a); i < (b); ++i)\n#define _REP(i, a, b) for(int i = (b - 1); i >= (a); --i)\nconst int oo = 0x7fffffff;\n#define _oo INT_MIN\n#define ool LLONG_MAX\ntemplate<typename Test, template<typename...> class Ref> struct isinstance : std::false_type {};\ntemplate<template<typename...> class Ref, typename... Args> struct isinstance<Ref<Args...>, Ref>: std::true_type {};\nTA bool is_vector(A& a){return isinstance<A, std::vector>::value;}\n#define v_init(x) int x##n = _##x.size(); int* x = _##x.data();\n#define v2_init(x) int x##n = _##x.size(); int x##m = _##x[0].size(); int x##nm = x##n * x##m; vi* x = _##x.data();\n#define um unordered_map\n#define umi unordered_map<int, int>\n#define umc unordered_map<char, int>\n#define ums unordered_map<string, int>\n#define us unordered_set\n#define usi unordered_set<int>\n#define pq(T, cmp, q) priority_queue<T, vector<T>, decltype(cmp)> q(cmp)\n#define pqi priority_queue<int>\n#define str to_string\n#define _int stoll\n#define _if(flag, a, b) ((flag) ? (a) : (b))\n#define F0 [&]()\n#define F1(a) [&](auto& a)\n#define _F1(a) [&](auto a)\n#define F2(a, b) [&](auto& a, auto& b)\n#define _F2(a, b) [&](auto a, auto b)\n#define F3(a, b, c) [&](auto& a, auto& b, auto& c)\n#define _F3(a, b, c) [&](auto a, auto b, auto c)\n#define var(a, b, c) auto& [a, b] = (c)\n#define var2(a, b, x) auto& a = x[0]; auto& b = x[1];\n#define var3(a, b, c, x) auto& a = x[0]; auto& b = x[1]; auto& c = x[2];\n#define var4(a, b, c, d, x) auto& a = x[0]; auto& b = x[1]; auto& c = x[2]; auto& d = x[3];\n#define _len(n, r) int n = (r).size();\n#define _len2(n, m, r) int n = (r).size(); int m = (r)[0].size(); int n##m = n * m;\n#define bin1 __builtin_popcountll\ntypedef long long ll;\ntypedef unsigned int uint;\ntemplate<typename T> vector<vector<T>> vv(int n, int m, T _default){return vector<vector<T>>(n, vector<T>(m, _default));}\ntemplate<typename T> vector<vector<T>> vvv(int n, int m, int k, T _default){return vector<vector<vector<T>>>(n, vector<vector<T>>(m, vector<T>(k, _default)));}\n#define vvv(T, n0, n1, n2, x) vector<vector<vector<T>>>(n0, vv(T, n1, n2, x))\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<vector<int>>> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vector<double>> vvd;\ntypedef vector<vector<vector<double>>> vvvd;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll> > vvl;\ntypedef vector<float> vf;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\n#define ai(n) array<int, n>\nconst int N5 = 100001;\nconst ll M = 1000000007ll;\n//const ll M = 998244353ll;\n\nmt19937 rd;\nconstexpr double EPS = 1e-6;\nint dcmp(double x){if (x < -EPS) return -1;return x > EPS;}\nTA int len(const A& a){return a.size();}\ninline ll E(int x) {return 1ll << x;}\ninline ll sqr(int x){return ll(x) * ll(x);}\nTA A sqr(A x){return x * x;}\nTAB void _max(A& a, const B& b) {if (a < b) a = b;}\nTAB void _min(A& a, const B& b) {if (a > b) a = b;}\nTA void _swap(A& a, A& b){if (a > b) swap(a, b);}\nTAB int count(const A& a, const B& b) {return count(a.begin(), a.end(), b);}\nbool pm(vi& a){return next_permutation(a.begin(), a.end());}\ninline bool in(ll x, ll y, ll a, ll b) {return a <= x && x < b && a <= y && y < b;}\ninline int pos(int x, int n) {return (x % n + n) % n;}\nTAB inline ll madd(const A& a, const B& b, const ll m=M){ll d = a + b; if (d < 0) return d + m; if (d >= m) return d - m; return d;}\nTAB inline void _madd(A& a, const B& b, const ll m=M){a += b; if (a < 0) a += m; if (a >= m) a -= m;}\nTABC bool in(const A& x, const B& a, const C& b) {return (a) <= (x) && (x) < (b);}\nTABC bool _in(const A& x, const B& a, const C& b) {return (a) <= (x) && (x) <= (b);}\nTABC bool in(A x[], int n, const B& a, const C& b) {rep(i, n) if (x[i] < a || x[i] >= b) return 0; return 1;}\nchar low(char c){return tolower(c);}\nchar up(char c){return toupper(c);}\nchar max(const string& r){if (!r.size()) return 0; char ret = r[0]; rep(i, r.size()) ret = max(ret, r[i]); return ret;}\nchar min(const string& r){if (!r.size()) return 0; char ret = r[0]; rep(i, r.size()) ret = min(ret, r[i]); return ret;}\nstring operator+=(string &d, vector<string>& a){rep(i, a.size()) d += a[i];\treturn d;}\nchar operator--(string& r,int){char d = r[r.size() - 1]; r.pop_back(); return d;}\nchar& operator-(string& r, int x){return r[(r.size() - x) % r.size()];}\nTA bool in(string& r, A a, A b) {rep(i, r.size()) if (r[i] < a || r[i] > b) return 0; return 1;}\nTA void sort(A& r){sort(r.begin(), r.end());}\nTA void _sort(A& a){sort(a.begin(), a.end(), greater<typename A::value_type>());}\nTAB void sort(A& a, B cmp) {sort(a.begin(), a.end(), cmp);}\nTA auto key(A& r){vector<typename A::key_type> d; for (auto& [a, b]: r) d.push_back(a); return d;}\nTA auto value(A& r){vector<typename A::mapped_type> d; for (auto& [a, b]: r) d.push_back(b); return d;}\nTA auto sum(A& a){return accumulate(a.begin(), a.end(), typename A::value_type());}\n\nvoid to(string& r, vi& d){d.clear(); repa(a, r) d.pb(a - '0');}\nvoid to(string& r, vc& d){d.clear(); repa(a, r) d.pb(a);}\nstring to_string(char c){return string(1, c);}\nstring end(string& a, int n) {return a.substr(max(0, int(a.size() - n)), n);}\nstring start(string& a, int n) {return a.substr(0, n);}\ninline string sub(string& r, int a=0, int b=oo){if (a < 0) a = r.size() + a;if (b == oo) b = r.size(); if (b < 0) b = r.size() + b; return r.substr(a, b - a);}\nstring get(string& r, int a, int b=oo) {if (b == oo) b = len(r); if (a < 0) a = len(r) + a; if (b < 0) b = len(r) + a; return r.substr(a, b - a);}\n//char last(const string& r){return r[r.size() - 1];}\nTA int col(const vector<A>& r){return r[0].size();}\nTAB void mm(vector<A>& a, B x=0){rep(i, a.size())a[i] = x;}\nTAB void mm(vector<vector<A>>& a, B x=0){rep(i, a.size())rep(j, a[i].size())a[i][j] = x;}\nTAB void mm(vector<vector<vector<A>>>& a, B x=0){rep(i, a.size())rep(j, a[i].size())rep(k, a[i][j].size())a[i][j][k] = x;}\ntemplate<typename T>\nT& _get(vector<T>& a, int x, const T& y_default=0){\n\tstatic T _y_default = y_default;\n\tif (0 <= x and x < int(a.size())) return a[x];\n\tD(x, a.size(), int(a.size()) + x, x < 0 and 0 <= a.size() + x);\n\tif (x < 0 and 0 <= int(a.size()) + x) return a[a.size() + x];\t\n\tD(x, a.size());\n\treturn _y_default;\n}\ntemplate<typename T>\nT& get(vector<T>& a, int x, const T& y_default=0){\n\tassert(0 <= x and x < a.size() or x < 0 and 0 <= a.size() + x);\n\tif (x < 0) return a[a.size() + x];\n\treturn a[x];\n}\nTA ll operator+(ll a, const A& b){for (auto x: b) a += x; return a;}\nTA ll operator+=(ll a, const A& b){return a + b;}\nTA void operator+=(vector<A>& a, const A& b){a.push_back(b);}\nTA A operator--(vector<A>& a, int){A d=a[a.size()-1]; a.pop_back(); return d;}\nTAB vector<A>& operator+=(vector<A>& a, const B& b){for(auto& c: b) a += c; return a;}\nTA vector<A> operator-(const vector<A>& a, const vector<A>& b){vector<A> d;rep(i, a.size())\td.push_back(a[i] - b[i]);return d;}\nTA A& operator+(vector<A>& a, int x){return a[(a.size() + x % a.size()) % a.size()];}\nTA A& operator-(vector<A>& a, int x){return a[(a.size() - x % a.size()) % a.size()];}\nvector<long long> _ll(vector<int>& r){int n = r.size();vector<ll> d(n);for (int i = 0; i < n; ++i)d[i] = r[i];return d;}\nTA A& add(vector<A> &r, int x, const A& y){r.insert(r.begin() + x, y);return r[x];}\n//TA A& last(vector<A>& r, int x=-1){return r[r.size() + x];}\nTA auto last(A& r){return *r.rbegin();}\nTAB A last(map<A, B>& r){return r.rbegin()->first;}\nTAB A last(unordered_map<A, B>& r){return r.rbegin()->first;}\nbool find(string& r, const string& x) {return r.find(x) != string::npos;}\nbool find(string& a, char b) {return find(a.begin(), a.end(), b) != a.end();}\nTAB bool find(vector<A>& a, const B& b) {return find(a.begin(), a.end(), b) != a.end();}\nTAB bool find(A& a, const B& b) {return a.find(b) != a.end();}\nTA int rfind(vector<A>& a, const A& b) {_rep(i, a.size())if(a[i] == b) return i; return -1;}\nTAB int bfind(vector<A> &a, const B& x){if (!a.size() or a[a.size() - 1] < x) return -1; return lower_bound(a.begin(), a.end(), x) - a.begin();}\nTA A& at(vector<A>& r, int x){return r[(x % r.size() + r.size()) % r.size()];}\nTAB int _un(vector<A>& a, B cmp=less<A>()) {a.resize(unique(a.begin(), a.end(), [&](A& x, A& y){return !cmp(x,y) && !cmp(y,x);}) - a.begin());return a.size();}\nTAB int un(vector<A>& a, B cmp=less<A>()) {sort(a.begin(), a.end(), cmp); return _un(a, cmp);}\nTA A& rev(A &r){reverse(r.begin(), r.end()); return r;}\nTA bool in(const vector<A> &r, A a, A b) {rep(i, r.size()) if (r[i] < a || r[i] >= b) return 0; return 1;}\nTA A max(const vector<A>& r){A ret = r[0]; for (int i = 1; i < r.size(); ++i) ret = max(ret, r[i]); return ret;}\nTA A max(const vector<vector<A>>& r){A d = r[0][0]; rep(i, r.size())rep(j, r[i].size()) d = max(d, r[i][j]); return d;}\nTA A min(const vector<A>& r){A ret = r[0]; for (int i = 1; i < r.size(); ++i) ret = min(ret, r[i]); return ret;}\nTA A min(const vector<vector<A>>& r){A d = r[0][0]; rep(i, r.size())rep(j, r[i].size()) d = min(d, r[i][j]); return d;}\nTAB B max(const unordered_map<A, B>& r){if (!r.size()) return B(); B d = r.begin()->second; for (auto& [a, b]: r)\td = max(d, b); return d;}\nTAB B min(const unordered_map<A, B>& r){if (!r.size()) return B(); B d = r.begin()->second; for (auto& [a, b]: r)\td = min(d, b); return d;}\nTA int _max(const vector<A>& r){int ret = 0; for(int i = 1; i < r.size(); ++i) if (r[i] > r[ret]) ret = i; return ret;}\nTA int _min(const vector<A>& r){int ret = 0; for(int i = 1; i < r.size(); ++i) if (r[i] < r[ret]) ret = i; return ret;}\nTA A _xor(const vector<A> &r){A d = 0; rep(i, r.size()) d ^= r[i]; return d;}\nTA vector<ll> sf(vector<A>& r){vl s(r.size() + 1, 0); for (int i = r.size() - 1; i >= 0; --i) s[i] = s[i + 1] + r[i]; return s;}\nTA vector<A> sub(const vector<A>& r, int a=0, int b=-1){vector<A> d;a = pos(a, r.size());b = pos(b, r.size()); while (a <= b) d.pb(r[a++]); return d;}\nTA void resize(vector<vector<A> > &r, int n, int m){r.resize(n); rep(i, n)r[i].resize(m);}\nvi idf(int n) {vi ret; rep(i, n) ret.emplace_back(i); return ret;}\nTA void operator+=(queue<A>& q, const A& a){q.push(a);}\nTAB void operator+=(queue<A>& a, B& b){for (auto i = b.begin(); i != b.end(); ++i) a.push(*i);}\nTA A operator--(queue<A>& q, int){A d = q.front(); q.pop(); return d;}\nTA A operator~(queue<A>& a){return a.front();}\nTA void mm(queue<A>& q){while (q.size()) q.pop();}\nTA void operator+=(priority_queue<A>& a, const A& b){a.push(b);}\nT4 void operator+=(priority_queue<T0, T1, T2>& a, const T3& b){a.push(b);}\nTAB void operator+=(priority_queue<A> &a, B& b){for (auto i = b.begin(); i != b.end(); ++i)a.push(*i);}\nTA A operator--(priority_queue<A>& a, int){A d = a.top(); a.pop(); return d;}\nTABC A operator--(priority_queue<A, B, C>& a, int){A d = a.top(); a.pop(); return d;}\nTA A operator~(priority_queue<A>& a){return a.top();}\nTABC void operator+=(um<A, B>& a, const C& c){for (auto x: c) ++a[x];}\nTAB B operator-=(um<A, B> &r, const A& x){B d = r[x]; r.erase(x); return d;}\nTABC void operator-=(um<A, B> &a, const C& c){for (auto i = c.begin(); i != c.end(); ++i) a.erase(*i);}\nTAB bool operator%(um<A, B>& a, const A& b){return a.find(b) != a.end();}\nTAB B& get(um<A, B>& a, const A& b, const B& c=0){static B _c = c; if (a.find(b) == a.end()) return _c; return a[b];}\nTA void operator+=(us<A> &a, const A& b){a.insert(b);}\nTA void operator+=(us<A> &a, vector<A>& b){repa(c, b)a.insert(b);}\nTA void operator-=(us<A> &a, const A& b){a.erease(b);}\nTAB bool operator%(map<A, B>& a, const A& b){return a.find(b) != a.end();}\nTAB B& get(map<A, B>& a, const A& b, const B& c=0){static B _c = c; if (a.find(b) == a.end()) return _c; return a[b];}\nTAB void operator-=(map<A, B>& a, const A& b){auto i = a.find(b); if (i != a.end()) a.erase(i);}\nTAB bool operator%(multimap<A, B>& a, const A& b){return a.find(b) != a.end();}\nTAB B& get(multimap<A, B>& a, const A& b, const B& c=0){static B _c = c; if (a.find(b) == a.end()) return _c; return a[b];}\nTA void operator+=(set<A>& a, const A& b){a.insert(b);}\nTA void operator+=(set<A>& a, const vector<A>& b){repa(c, b) a.insert(c);}\nTA A operator-(set<A>& a, int x){auto i = a.rbegin(); rep(j, x - 1) i--; return *i;}\nTA void operator+=(multiset<A>& a, const A& b){a.insert(b);}\nTA void operator+=(multiset<A>& a, const vector<A>& b){repa(c, b) a.insert(c);}\nTA void operator-=(multiset<A>& a, const A& b){auto i = a.find(b); if (i != a.end())a.erase(i);}\nTA A operator-(multiset<A>& a, int x){auto i = a.rbegin(); rep(j, x - 1) i--; return *i;}\nstruct P{\n\tusing T = ll;\n\tT x, y, z;\n\tP(const T& _x=0, const T& _y=0){x = _x; y = _y;}\n\tP(const T *a): x(a[0]), y(a[1]){}\n\tP(const vector<T> &a): x(a[0]), y(a[1]){}\n\tTA A& operator()(vector<vector<A>> &r) {return r[x][y];}\n\tTA A& operator[](vector<vector<A>> &r) {return r[x][y];}\n};\n\nvoid _init(){\n\n}\n\nstatic auto init = [](){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\t_init();\n\treturn 0;\n}();\n\nstruct Prime{\n\tconst int N = 100000;\n\tvector<int> v;\n\tvector<int> data;\n\n\tPrime(){\n\t\tv.resize(N + 1);\n\t\trep(i, N + 1) v[i] = -1;\n\t\tfor (int i = 2; i <= N; ++i)\n\t\tif (v[i] < 0){\n\t\t\tdata.emplace_back(i);\n\t\t\tv[i] = data.size() - 1;\n\t\t\tfor (ll j = ll(i) * i; j <= N; j += i)\n\t\t\tif (v[j] < 0)\n\t\t\t\tv[j] = data.size() - 1;\n\t\t}\n\t}\n\n\tint size(){return data.size();}\n\tint& operator()(int x){return v[x];}\n\tint& operator[](int x){return data[x];}\n\tbool is(int x){if (x < 2) return 0; return data[v[x]] == x;}\n}prime;\n\ntemplate<typename T>\nlong long bs(long long a, long long c, T cmp, long long all_1_ret=0, long long all_0_ret=0){\n\tlong long b;\n\tlong long _c = c - 1;\t\n\tif (c == 0) return all_0_ret;\n\tbool flag_0 = cmp(a);\t\t\n\tbool flag_1 = cmp(_c);\n\tif (flag_0 and flag_1)\n\t\treturn all_1_ret;\n\tif (!flag_0 and !flag_1)\n\t\treturn all_0_ret;\n\n\tif (flag_0){\n\t\twhile (a + 1 < c){\n\t\t\tb = (a + c) >> 1;\n\t\t\tif (cmp(b))\ta = b;\n\t\t\telse c = b;\n\t\t}\n\t\treturn a;\n\t}\n\twhile (a + 1 < c){\n\t\tb = (a + c) >> 1;\n\t\tif (cmp(b)) c = b;\n\t\telse a = b;\n\t}\n\treturn c;\n}\n\nstruct G{\n\tusing T = long long;\n\tstruct Edge{\n\t\tint b;\n\t\tT w;\n\t\tint i;\n\t};\n\tvector<vector<Edge>> data;\n\tint m;\n\n\tG(){};\n\tG(int n){(*this)(n);}\n\tG(int n, vector<vector<int>>& r){(*this)(n ,r);}\n\tint size()const{return data.size();}\n\tvoid operator()(int n){\n\t\tdata.clear();\n\t\tdata.resize(n);\n\t\tm = 0;\n\t}\n\n\tvoid operator()(int a, int b, T c, int d1=0, int id=0){\n\t\tdata[a].push_back(Edge{b, c, id});\n\t\tif (!d1)\n\t\t\tdata[b].push_back(Edge{a, c, id});\n\t\tm = max(m, id + 1);\n\t}\n\n\tvoid operator()(int n, vector<vector<int>>& r, int d1=0){\n\t\t(*this)(n);\n\t\tfor (int i = 0; i < r.size(); ++i)\n\t\t\t(*this)(r[i][0], r[i][1], r[i][2], d1, i);\n\t}\n\n\tvector<Edge>& operator[](int x) {return data[x];}\n\tvector<vector<Edge>>& operator()(){return data;}\n};\n\nG g;\n\nll dis2(const P& a, const P& b){return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);}\n\nvi bfs(vvi& r, int x){\n\tint n = len(r);\n\tvi d(n);\n\tqueue<int> q;\n\td[x] = 1;\n\tq.push(x);\n\twhile (q.size()){\n\t\tint a = q.front();\n\t\tq.pop();\n\t\trepa(b, r[a])\n\t\tif (!d[b]){\n\t\t\td[b] = d[a] + 1;\n\t\t\tq.push(b);\n\t\t}\n\t}\n\treturn d;\n}\n\n#if 1\n#define SOLUTION_F canReachCorner\nclass Solution {\npublic:\n    bool SOLUTION_F(int rx, int ry, vvi& _r) {\n\t\tint n = len(_r);\n\t\tvector<P> r(n);\n\n\t\trep(i, n){\n\t\t\tr[i] = P(_r[i][0], _r[i][1]);\n\t\t\tr[i].z = _r[i][2];\n\t\t}\n\t\t\n\t\tint d = 1;\n\n\t\tvvi f(n + 2);\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\tif (dis2(r[i], r[j]) <= sqr(r[i].z + r[j].z)){\n\t\t\tf[i] += j;\n\t\t\tf[j] += i;\n\t\t}\n\n\t\trep(i, n){\n\t\t\tint fa = 0, fb = 0;\n\t\t\tauto A = r[i];\n\t\t\tif (A.x <= A.z and A.y <= ry)\n\t\t\t\tfa = 1;\n\t\t\tif (abs(ry - A.y) <= A.z and A.x <= rx)\n\t\t\t\tfa = 1;\n\n\t\t\tif(abs(rx - A.x) <= A.z and A.y <= ry)\n\t\t\t\tfb = 1;\n\t\t\tif (A.y <= A.z and A.x <= rx)\n\t\t\t\tfb = 1;\n\n\t\t\tif (fa){\n\t\t\t\tf[n] += i;\n\t\t\t\tf[i] += n;\n\t\t\t}\n\t\t\tif (fb){\n\t\t\t\tf[n + 1] += i;\n\t\t\t\tf[i] += n + 1;\n\t\t\t}\n\t\t}\n\n\t\tauto v = bfs(f, n);\n\n\t\tD(v);\n\n\t\treturn !v[n + 1];\n    }\n};\n#endif\n\n#undef str\n",
    "submit_ts": "1722136942",
    "subm_id": "1335749472"
}