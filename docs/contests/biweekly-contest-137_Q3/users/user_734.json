{
    "username": "KennethZheng",
    "submission": "class Solution:\n    def check(self, new_pos, existing_poses):\n        for pos in existing_poses:\n            if new_pos[0] == pos[0] or new_pos[1] == pos[1]:\n                return False\n        return True\n\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        self.ans = float(\"-inf\")\n\n        m, n = len(board), len(board[0])\n        self.sorted_cells = sorted(((board[i][j], i, j) for i in range(m) for j in range(n)), reverse=True)\n\n        self.recurse(board, [], 0, 0)\n        return self.ans\n    \n    def recurse(self, board, curr_pos, curr_score, i):\n        if len(curr_pos) == 3:\n            self.ans = max(self.ans, curr_score)\n            return\n        \n        if i == len(board):\n            if len(curr_pos) == 3:\n                self.ans = max(self.ans, curr_score)\n            return\n\n        remaining = 3 - len(curr_pos)\n        if curr_score + sum(value for value, _, _ in self.sorted_cells[:remaining]) <= self.ans:\n            return\n\n        for col in range(len(board[0])):\n            if self.check((i, col), curr_pos):\n                curr_pos.append((i, col))\n                curr_score += board[i][col]\n                self.recurse(board, curr_pos, curr_score, i + 1)\n                curr_pos.pop()\n                curr_score -= board[i][col]\n        \n        self.recurse(board, curr_pos, curr_score, i + 1)\n\n",
    "submit_ts": "1723908597",
    "subm_id": "1359159234"
}