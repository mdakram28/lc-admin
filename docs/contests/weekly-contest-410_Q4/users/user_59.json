{
    "username": "MKLOL",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double, double> pdd;\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define FOR(i, to) for (int i = 0; i < (to); ++i)\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<pair<int, int> > vpi;\ntypedef pair<ll,ll> pll;\ntypedef vector<string> vs;\nconst char en = '\\n';\n#define MOD 1000000007\ntemplate<int MODX>\nstruct ModInt {\n  unsigned x;\n  ModInt() : x(0) { }\n  ModInt(signed sig) : x(((sig%MODX)+MODX)%MODX) {  }\n  ModInt(signed long long sig) : x(((sig%MODX)+MODX)%MODX) { }\n  int get() const { return (int)x; }\n  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }\n \n  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MODX) x -= MODX; return *this; }\n  ModInt &operator-=(ModInt that) { if ((x += MODX - that.x) >= MODX) x -= MODX; return *this; }\n  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MODX; if (x < 0) x += MODX; return *this; }\n  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MODX - 2); }\n \n  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n  bool operator<(ModInt that) const { return x < that.x; }\n  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }\n};\ntypedef ModInt<MOD> mint;\n\n\nmint best[2020][1010];\n\nclass Solution {\npublic:\n    int countOfPairs(vector<int>& v) {\n        FOR(i, sz(v)) {\n            FOR(j, v[i]+2) {\n                best[i][j] = 0;\n            }\n        }\n        for (int i=0;i<=v[0];++i) {\n            best[0][i] = 1;\n            if (i) {\n                best[0][i] += best[0][i-1];\n            }\n        }\n        for (int i=1;i<sz(v);++i) {\n            for (int j=0;j<=v[i];++j) {\n                int l = j;\n                int r = v[i] - j;\n                int nr = v[i-1] - r;\n                // 0 .... l\n                // r <= r ..... nums[i-1]\n                if (min(l,nr) < 0) continue;\n                best[i][j] += best[i-1][min(min(l, nr), v[i-1])];\n                \n            }\n            for (int j=0;j<=v[i];++j) {\n                if (j)\n                best[i][j] += best[i][j-1];\n            }\n        }\n        return best[sz(v)-1][v.back()].x;\n        \n    }\n};",
    "submit_ts": "1723344271",
    "subm_id": "1351530603"
}