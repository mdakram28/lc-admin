{
    "username": "wjli",
    "submission": "\n// COPY ALL MACROS BELOW\n\ntypedef long long LL;\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define LB lower_bound\n#define UB upper_bound\n#define SZ(x) ((int)x.size())\n#define LEN(x) ((int)x.length())\n#define ALL(x) begin(x), end(x)\n#define RSZ resize\n#define ASS assign\n#define REV(x) reverse(x.begin(), x.end());\n#define trav(a, x) for (auto& a : x)\ntypedef pair<LL, LL> PL;\ntypedef vector<LL> VL;\ntypedef vector<PL> VPL;\ntypedef vector<VL> VVL;\ntypedef vector<VVL> VVVL;\ntypedef vector<VVVL> VVVVL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PI;\ntypedef vector<int> VI;\ntypedef vector<PI> VPI;\ntypedef vector<vector<int>> VVI;\ntypedef vector<vector<PI>> VVPI;\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\n#define FOR(i, n) for (int i = 0; i < n; i++) \n#define FOR1(i, n) for (int i = 1; i <= n; i++) \n#define SORT(x) sort(x.begin(), x.end())\n#define RSORT(x) sort(x.rbegin(), x.rend())\n#define SUM(x) accumulate(x.begin(), x.end(), 0LL)\n\n\nclass Solution {\npublic:\n    int minimumDistance(vector<vector<int>>& points) {\n        int n = points.size(), i, j, k, ans = 1E9;\n        map<int, VI> v1, v2;\n        FOR(i, n) {\n            v1[points[i][0] + points[i][1]].push_back(i);\n            v2[points[i][0] - points[i][1]].push_back(i);\n        }\n\n        VL plist;\n        if (v1.begin()->second.size() == 1) {\n\t\t\tplist.push_back(v1.begin()->second[0]);\n\t\t}\n        if (v1.rbegin()->second.size() == 1) {\n            plist.push_back(v1.rbegin()->second[0]);\n        }\n        if (v2.begin()->second.size() == 1) {\n\t\t\tplist.push_back(v2.begin()->second[0]);\n\t\t}\n        if (v2.rbegin()->second.size() == 1) {\n            plist.push_back(v2.rbegin()->second[0]);\n        }\n        plist.push_back(0);\n\n        for (auto p : plist) {\n            map<int, VI> vv1, vv2;\n            FOR(i, n) {\n                if (i == p) continue;\n                vv1[points[i][0] + points[i][1]].push_back(i);\n                vv2[points[i][0] - points[i][1]].push_back(i);\n            }\n\n            int d1 = vv1.rbegin()->first - vv1.begin()->first;\n            int d2 = vv2.rbegin()->first - vv2.begin()->first;\n\n            ans = min(ans, max(d1, d2));\n        }\n\n        return ans;\n    }\n};\n"
}