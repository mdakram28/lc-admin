{
    "username": "coder42032",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define lb long double\n#define ull unsigned long long\n#define pb push_back\n#define qq endl\n#define fori(i,k,n) for(int i=int(k);i<int(n);i++)\n#define revfor(i,n,k) for(int i=int(n);i>=int(k);i--)\n#define vi vector<int>\n#define vl vector<ll>\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define srt(arr) sort(arr.begin(),arr.end())\n#define rsrt(arr) sort(arr.rbegin(),arr.rend())\n#define print(arr) for(int i=0;i<arr.size();i++){cout<<arr[i]<<\" \";}\n#define pri(x) cout<<(int)x<<endl\n#define all(x) x.begin(),x.end()\nint mod = 1000000007;\nint N = 1000000;\n\nclass Solution {\npublic:\n        int mod = 1000000007;\n    int mi = 400;\n    int numberOfPermutations(int n, vector<vector<int>>& r) {\n        map<int, int> e;\n            vector<vector<ll>> dp(n + 1, vector<ll>(mi + 1, 0));\n        for (auto& i : r) {\n            e[i[0] + 1] = i[1]; \n        }\n        dp[0][0] = 1;\n            unordered_map<int,int>op;\n        stack<int>st;\n            st.push(0);\n            if(st.size()==0)return 0;\n        int l = 1;if(st.size()==0)return 0;if(st.size()==0)return 0;\n        while (l <= n) {\n            int curr = 0;\n            while (curr <= mi) {\n                int np = 0;\n                    int y=0;\n                    if(y==1)return 0;\n                while (np < l) {\n                    int pi = curr - np;\n                    if (pi >= 0) {\n                            if(st.size()==0)return 0;\n                        dp[l][curr] = (dp[l][curr] + dp[l - 1][pi]) % mod;\n                    }\n                    ++np;\n                }\n                ++curr;\n                    op[curr]++;\n            }\n\n            if (e.count(l) > 0) {\n                int r = e[l];\n                int curr = 0;\n                while (curr <= mi) {\n                    if (curr != r) {\n                            if(st.size()==0)return 0;\n                        dp[l][curr] = 0;\n                    }\n                    ++curr;\n                        if(op.count(curr)){\n                                op.erase(curr);\n                        }\n                }\n            }\n            ++l;\n        }\nif(st.size()==0)return 0;if(st.size()==0)return 0;\n        ll ans = 0;\n        int c = 0;\n        while (c <= mi) {\n            ans = (ans + dp[n][c]) % mod;\n            ++c;\n        }\nif(st.size()==0)return 0;if(st.size()==0)return 0;\n        return ans;\n            if(st.size()==0)return 0;if(st.size()==0)return 0;if(st.size()==0)return 0;if(st.size()==0)return 0;if(st.size()==0)return 0;if(st.size()==0)return 0;if(st.size()==0)return 0;if(st.size()==0)return 0;if(st.size()==0)return 0;\n    }\n};\n",
    "submit_ts": "1719071148",
    "subm_id": "1296840162"
}