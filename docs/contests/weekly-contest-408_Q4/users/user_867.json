{
    "username": "jfkjfk",
    "submission": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fastio()        ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n#define MOD             1000000007\n#define MOD1            998244353\n#define INF             1e18\n#define endl            \"\\n\"\n#define pb              push_back\n#define eb              emplace_back\n#define mp              make_pair\n#define gcd(a, b)       __gcd(a,b)\n#define ff              first\n#define ss              second\n#define PI              3.141592653589793238462\n#define set_bits(x)     __builtin_popcountll(x)\n#define all(x)          (x).begin(), (x).end()\n\ntypedef long long ll;\ntypedef long double lld;\n\n/*---------------------------------------------------------------------------------------------------------------------------*/\nll power(ll a, ll n){\n    ll res = 1;\n    while(n){\n        if(n & 1){\n            res = (res * a) % MOD;\n        }\n        a = (a * a) % MOD;\n        n >>= 1;\n    }\n    return res;\n}\n/*---------------------------------------------------------------------------------------------------------------------------*/\n\nclass Solution {\npublic:\n\n    bool isPalindrome(string s){\n        int n = s.size();\n        for(int i=0; i<n/2; i++){\n            if(s[i] != s[n-i-1]){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool isPrime(int n){\n        for(int i=2; i*i<=n; i++){\n            if(n % i == 0){\n                return false;\n            }\n        }\n        return true;\n    } \n    \n    void makeGraph(int n, vector<pair<pair<int,int>, int>> &vp, vector<vector<int>> &circles){\n        for(int i=0; i<n; i++){\n            vp[i].ff.ff = circles[i][0];\n            vp[i].ff.ss = circles[i][1];\n            vp[i].ss = circles[i][2];\n        }\n    }\n    \n    void buildGraph(int n, vector<pair<pair<int,int>, int>> &vp, vector<vector<int>> &v, int X, int Y){\n        for(int i=0; i<n; i++){\n            if(vp[i].ff.ff <= vp[i].ss){\n                v[n].pb(i);\n                v[i].pb(n);\n            }\n            if(X - vp[i].ff.ff <= vp[i].ss){\n                v[n+2].pb(i);\n                v[i].pb(n+2);\n            }\n            if(vp[i].ff.ss <= vp[i].ss){\n                v[n+1].pb(i);\n                v[i].pb(n+1);\n            }\n            if(Y - vp[i].ff.ss <= vp[i].ss){\n                v[n+3].pb(i);\n                v[i].pb(n+3);\n            }\n            for(int j=i+1; j<n; j++){\n                double d = sqrt(pow(vp[i].ff.ff - vp[j].ff.ff, 2) + pow(vp[i].ff.ss - vp[j].ff.ss, 2));\n                int sum = vp[i].ss + vp[j].ss;\n                if(sum >= d){\n                    v[i].pb(j);\n                    v[j].pb(i);\n                }\n            }\n        }\n    }\n    \n    int checkBfs(vector<vector<int>> &v, int si, int t1, int t2, int nd){\n        queue<int> q;\n        vector<int> vis(nd + 4);\n        for(int i=0; i<vis.size(); i++){\n            vis[i] = 0;\n        }\n        q.push(si);\n        vis[si] = 1;\n        while(!q.empty()){\n            int val = q.front();\n            q.pop();\n            for(auto &it : v[val]){\n                if(!vis[it]){\n                    q.push(it);\n                    vis[it] = 1;\n                }\n            }\n        }\n        int val = vis[t1] || vis[t2];\n        return val;\n    }\n    \n    bool getAns(int X, int Y, vector<vector<int>> &circles){\n        int n = circles.size();\n        vector<pair<pair<int,int>,int>> vp(n);\n        vector<vector<int>> v(n + 4);\n        \n        makeGraph(n,vp,circles);\n        \n        buildGraph(n,vp,v,X,Y);\n        \n        int ans = 0;\n        // int val1 = checkBfs(v, n, n+1, n+2, n+4);\n        // cout << val1 << endl;\n        // if(ans > val1){\n            // ans = val1;\n        // }\n        ans = max(ans, checkBfs(v, n, n+1, n+2, n+4));\n        // int val2 = checkBfs(v, n+3, n+2, n+1, n+4);\n        // cout << val2 << endl;\n        // if(ans > val2){\n        //     ans = val2;\n        // }\n        // if(ans){\n        //     return false;\n        // }\n        ans = max(ans, checkBfs(v, n+3, n+2, n+1, n+4));\n        if(ans){\n            return false;\n        }\n        return true;\n    }\n\n    bool canReachCorner(int X, int Y, vector<vector<int>> &circles) {\n        bool ans = getAns(X,Y,circles);\n        return ans;\n    }\n};\n\n// void solve(ll tc){\n// }\n\n// int main(){\n//     fastio();\n\n//     ll t=1;\n//     cin >> t;\n\n//     for(ll i=1; i<=t; i++){\n//         // cout << \"Case #\" << i << \": \";\n//         solve(i);\n//     }\n\n//     return 0;\n// }",
    "submit_ts": "1722139146",
    "subm_id": "1335809123"
}