{
    "username": "tamuraup",
    "submission": "impl Solution {\n    pub fn shortest_distance_after_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        shortest_distance_after_queries(n,queries)\n    }\n}\n\n// use ac_library::MapMonoid;\npub use __cargo_equip::prelude::*;\n\nuse acl_lazysegtree::{LazySegtree, MapMonoid};\nuse acl_segtree::Max;\nuse kyopro_utils::*;\n\nfn _main() {\n    let n = 4;\n    let queries = vec![vec![0, 3], vec![0, 2]];\n    shortest_distance_after_queries(n, queries);\n}\n// \u533a\u9593\u52a0\u7b97\u3001\u533a\u9593\u6700\u5927\u5024\nstruct MaxAdd;\nimpl MapMonoid for MaxAdd {\n    type M = Max<i32>;\n    type F = i32;\n\n    // \u6052\u7b49\u5199\u50cf id\n    // mapping(id, x) = x \u3068\u306a\u308b\u5024\n    fn identity_map() -> Self::F {\n        0\n    }\n\n    // F\n    // \u9045\u5ef6\u3057\u3066\u3044\u305f\u533a\u9593\u306e\u66f4\u65b0\u3092\u30ce\u30fc\u30c9\u306b\u9069\u7528\u3059\u308b\u30a4\u30e1\u30fc\u30b8\n    fn mapping(&f: &Self::F, &x: &i32) -> i32 {\n        f + x\n    }\n\n    // F \u540c\u58eb\u306e\u6f14\u7b97(\u5199\u50cf\u306e\u5408\u6210?) f\u2218g\n    fn composition(&f: &Self::F, &g: &Self::F) -> Self::F {\n        f + g\n    }\n}\npub fn shortest_distance_after_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\n    let N = n as usize;\n    let mut ena = vec![true; N];\n    // let mut dist = (0..N as i32).rev().collect::<Vec<_>>();\n    let mut seg: LazySegtree<MaxAdd> = LazySegtree::new(N + 1);\n    for i in 0..N {\n        seg.set(i, N as i32 - 1 - i as i32);\n    }\n    for i in 0..N {\n        db!(seg.prod(i, i + 1));\n    }\n\n    let mut ans = vec![];\n    for qs in queries {\n        let u = qs[0] as usize;\n        let v = qs[1] as usize;\n        if !ena[u] || !ena[v] {\n            ans.push(seg.prod(0, 1));\n            continue;\n        }\n        let addv = seg.prod(u, u + 1) - seg.prod(v, v + 1) - 1;\n        db!(addv);\n        seg.apply_range(0, u + 1, -addv);\n        let a = seg.prod(0, 1);\n        ans.push(a);\n        for i in u + 1..v {\n                        if !ena[i]{break;}\n\n            ena[i] = false;\n        }\n    }\n    db!(ans);\n    ans\n        \n}\n\n// The following code was expanded by `cargo-equip`.\n\n///  # Bundled libraries\n/// \n///  - `ac-library-rs-parted-internal-bit 0.1.0 (git+https://github.com/tamura-up/ac-library-rs-parted#a091f8f74eb2debb8d68ce21cbe499addc1bec45)`                                  licensed under `CC0-1.0` as `crate::__cargo_equip::crates::__ac_library_rs_parted_internal_bit_0_1_0`\n///  - `ac-library-rs-parted-internal-type-traits 0.1.0 (git+https://github.com/tamura-up/ac-library-rs-parted#a091f8f74eb2debb8d68ce21cbe499addc1bec45)`                          licensed under `CC0-1.0` as `crate::__cargo_equip::crates::__ac_library_rs_parted_internal_type_traits_0_1_0`\n///  - `ac-library-rs-parted-lazysegtree 0.1.0 (git+https://github.com/tamura-up/ac-library-rs-parted#a091f8f74eb2debb8d68ce21cbe499addc1bec45)`                                   licensed under `CC0-1.0` as `crate::__cargo_equip::crates::acl_lazysegtree`\n///  - `ac-library-rs-parted-segtree 0.1.0 (git+https://github.com/tamura-up/ac-library-rs-parted#a091f8f74eb2debb8d68ce21cbe499addc1bec45)`                                       licensed under `CC0-1.0` as `crate::__cargo_equip::crates::acl_segtree`\n///  - `kyopro-utils 0.1.0 (path+\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588)`                                                                    published in **missing** licensed under `CC0-1.0` as `crate::__cargo_equip::crates::kyopro_utils`\n#[cfg_attr(any(), rustfmt::skip)]\n#[allow(unused)]\nmod __cargo_equip {\n    pub(crate) mod crates {\n        pub mod __ac_library_rs_parted_internal_bit_0_1_0 {pub use self::internal_bit::*;mod internal_bit{#[allow(dead_code)]pub fn ceil_pow2(n:u32)->u32{32-n.saturating_sub(1).leading_zeros()}}}\n        pub mod __ac_library_rs_parted_internal_type_traits_0_1_0 {pub use self::internal_type_traits::*;mod internal_type_traits{use std::{fmt,iter::{Product,Sum},ops::{Add,AddAssign,BitAnd,BitAndAssign,BitOr,BitOrAssign,BitXor,BitXorAssign,Div,DivAssign,Mul,MulAssign,Not,Rem,RemAssign,Shl,ShlAssign,Shr,ShrAssign,Sub,SubAssign,},};pub trait Integral:'static+Send+Sync+Copy+Ord+Not<Output=Self>+Add<Output=Self>+Sub<Output=Self>+Mul<Output=Self>+Div<Output=Self>+Rem<Output=Self>+AddAssign+SubAssign+MulAssign+DivAssign+RemAssign+Sum+Product+BitOr<Output=Self>+BitAnd<Output=Self>+BitXor<Output=Self>+BitOrAssign+BitAndAssign+BitXorAssign+Shl<Output=Self>+Shr<Output=Self>+ShlAssign+ShrAssign+fmt::Display+fmt::Debug+fmt::Binary+fmt::Octal+Zero+One+BoundedBelow+BoundedAbove{}pub trait Zero{fn zero()->Self;}pub trait One{fn one()->Self;}pub trait BoundedBelow{fn min_value()->Self;}pub trait BoundedAbove{fn max_value()->Self;}macro_rules!impl_integral{($($ty:ty),*)=>{$(impl Zero for$ty{#[inline]fn zero()->Self{0}}impl One for$ty{#[inline]fn one()->Self{1}}impl BoundedBelow for$ty{#[inline]fn min_value()->Self{Self::min_value()}}impl BoundedAbove for$ty{#[inline]fn max_value()->Self{Self::max_value()}}impl Integral for$ty{})*};}impl_integral!(i8,i16,i32,i64,i128,isize,u8,u16,u32,u64,u128,usize);}}\n        pub mod acl_lazysegtree {use crate::__cargo_equip::preludes::acl_lazysegtree::*;use crate::__cargo_equip::crates::__ac_library_rs_parted_internal_bit_0_1_0 as internal_bit;use crate::__cargo_equip::crates::acl_segtree as segtree;pub use self::lazysegtree::*;mod lazysegtree{use crate::__cargo_equip::preludes::acl_lazysegtree::*;use super::internal_bit::ceil_pow2;use super::segtree::Monoid;pub trait MapMonoid{type M:Monoid;type F:Clone;fn identity_element()-><Self::M as Monoid>::S{Self::M::identity()}fn binary_operation(a:&<Self::M as Monoid>::S,b:&<Self::M as Monoid>::S,)-><Self::M as Monoid>::S{Self::M::binary_operation(a,b)}fn identity_map()->Self::F;fn mapping(f:&Self::F,x:&<Self::M as Monoid>::S)-><Self::M as Monoid>::S;fn composition(f:&Self::F,g:&Self::F)->Self::F;}impl<F:MapMonoid>Default for LazySegtree<F>{fn default()->Self{Self::new(0)}}impl<F:MapMonoid>LazySegtree<F>{pub fn new(n:usize)->Self{vec![F::identity_element();n].into()}}impl<F:MapMonoid>From<Vec<<F::M as Monoid>::S>>for LazySegtree<F>{fn from(v:Vec<<F::M as Monoid>::S>)->Self{let n=v.len();let log=ceil_pow2(n as u32)as usize;let size=1<<log;let mut d=vec![F::identity_element();2*size];let lz=vec![F::identity_map();size];d[size..(size+n)].clone_from_slice(&v);let mut ret=LazySegtree{n,size,log,d,lz,};for i in(1..size).rev(){ret.update(i);}ret}}impl<F:MapMonoid>LazySegtree<F>{pub fn set(&mut self,mut p:usize,x:<F::M as Monoid>::S){assert!(p<self.n);p+=self.size;for i in(1..=self.log).rev(){self.push(p>>i);}self.d[p]=x;for i in 1..=self.log{self.update(p>>i);}}pub fn get(&mut self,mut p:usize)-><F::M as Monoid>::S{assert!(p<self.n);p+=self.size;for i in(1..=self.log).rev(){self.push(p>>i);}self.d[p].clone()}pub fn prod(&mut self,mut l:usize,mut r:usize)-><F::M as Monoid>::S{assert!(l<=r&&r<=self.n);if l==r{return F::identity_element();}l+=self.size;r+=self.size;for i in(1..=self.log).rev(){if((l>>i)<<i)!=l{self.push(l>>i);}if((r>>i)<<i)!=r{self.push(r>>i);}}let mut sml=F::identity_element();let mut smr=F::identity_element();while l<r{if l&1!=0{sml=F::binary_operation(&sml,&self.d[l]);l+=1;}if r&1!=0{r-=1;smr=F::binary_operation(&self.d[r],&smr);}l>>=1;r>>=1;}F::binary_operation(&sml,&smr)}pub fn all_prod(&self)-><F::M as Monoid>::S{self.d[1].clone()}pub fn apply(&mut self,mut p:usize,f:F::F){assert!(p<self.n);p+=self.size;for i in(1..=self.log).rev(){self.push(p>>i);}self.d[p]=F::mapping(&f,&self.d[p]);for i in 1..=self.log{self.update(p>>i);}}pub fn apply_range(&mut self,mut l:usize,mut r:usize,f:F::F){assert!(l<=r&&r<=self.n);if l==r{return;}l+=self.size;r+=self.size;for i in(1..=self.log).rev(){if((l>>i)<<i)!=l{self.push(l>>i);}if((r>>i)<<i)!=r{self.push((r-1)>>i);}}{let l2=l;let r2=r;while l<r{if l&1!=0{self.all_apply(l,f.clone());l+=1;}if r&1!=0{r-=1;self.all_apply(r,f.clone());}l>>=1;r>>=1;}l=l2;r=r2;}for i in 1..=self.log{if((l>>i)<<i)!=l{self.update(l>>i);}if((r>>i)<<i)!=r{self.update((r-1)>>i);}}}pub fn max_right<G>(&mut self,mut l:usize,g:G)->usize where G:Fn(<F::M as Monoid>::S)->bool,{assert!(l<=self.n);assert!(g(F::identity_element()));if l==self.n{return self.n;}l+=self.size;for i in(1..=self.log).rev(){self.push(l>>i);}let mut sm=F::identity_element();while{while l%2==0{l>>=1;}if!g(F::binary_operation(&sm,&self.d[l])){while l<self.size{self.push(l);l*=2;let res=F::binary_operation(&sm,&self.d[l]);if g(res.clone()){sm=res;l+=1;}}return l-self.size;}sm=F::binary_operation(&sm,&self.d[l]);l+=1;{let l=l as isize;(l&-l)!=l}}{}self.n}pub fn min_left<G>(&mut self,mut r:usize,g:G)->usize where G:Fn(<F::M as Monoid>::S)->bool,{assert!(r<=self.n);assert!(g(F::identity_element()));if r==0{return 0;}r+=self.size;for i in(1..=self.log).rev(){self.push((r-1)>>i);}let mut sm=F::identity_element();while{r-=1;while r>1&&r%2!=0{r>>=1;}if!g(F::binary_operation(&self.d[r],&sm)){while r<self.size{self.push(r);r=2*r+1;let res=F::binary_operation(&self.d[r],&sm);if g(res.clone()){sm=res;r-=1;}}return r+1-self.size;}sm=F::binary_operation(&self.d[r],&sm);{let r=r as isize;(r&-r)!=r}}{}0}}pub struct LazySegtree<F>where F:MapMonoid,{n:usize,size:usize,log:usize,d:Vec<<F::M as Monoid>::S>,lz:Vec<F::F>,}impl<F>LazySegtree<F>where F:MapMonoid,{fn update(&mut self,k:usize){self.d[k]=F::binary_operation(&self.d[2*k],&self.d[2*k+1]);}fn all_apply(&mut self,k:usize,f:F::F){self.d[k]=F::mapping(&f,&self.d[k]);if k<self.size{self.lz[k]=F::composition(&f,&self.lz[k]);}}fn push(&mut self,k:usize){self.all_apply(2*k,self.lz[k].clone());self.all_apply(2*k+1,self.lz[k].clone());self.lz[k]=F::identity_map();}}}}\n        pub mod acl_segtree {use crate::__cargo_equip::preludes::acl_segtree::*;use crate::__cargo_equip::crates::__ac_library_rs_parted_internal_bit_0_1_0 as internal_bit;use crate::__cargo_equip::crates::__ac_library_rs_parted_internal_type_traits_0_1_0 as internal_type_traits;pub use self::segtree::*;mod segtree{use crate::__cargo_equip::preludes::acl_segtree::*;use super::internal_bit::ceil_pow2;use super::internal_type_traits::{BoundedAbove,BoundedBelow,One,Zero};use std::cmp::{max,min};use std::convert::Infallible;use std::marker::PhantomData;use std::ops::{Add,Mul};pub trait Monoid{type S:Clone;fn identity()->Self::S;fn binary_operation(a:&Self::S,b:&Self::S)->Self::S;}pub struct Max<S>(Infallible,PhantomData<fn()->S>);impl<S>Monoid for Max<S>where S:Copy+Ord+BoundedBelow,{type S=S;fn identity()->Self::S{S::min_value()}fn binary_operation(a:&Self::S,b:&Self::S)->Self::S{max(*a,*b)}}pub struct Min<S>(Infallible,PhantomData<fn()->S>);impl<S>Monoid for Min<S>where S:Copy+Ord+BoundedAbove,{type S=S;fn identity()->Self::S{S::max_value()}fn binary_operation(a:&Self::S,b:&Self::S)->Self::S{min(*a,*b)}}pub struct Additive<S>(Infallible,PhantomData<fn()->S>);impl<S>Monoid for Additive<S>where S:Copy+Add<Output=S>+Zero,{type S=S;fn identity()->Self::S{S::zero()}fn binary_operation(a:&Self::S,b:&Self::S)->Self::S{*a+*b}}pub struct Multiplicative<S>(Infallible,PhantomData<fn()->S>);impl<S>Monoid for Multiplicative<S>where S:Copy+Mul<Output=S>+One,{type S=S;fn identity()->Self::S{S::one()}fn binary_operation(a:&Self::S,b:&Self::S)->Self::S{*a**b}}impl<M:Monoid>Default for Segtree<M>{fn default()->Self{Segtree::new(0)}}impl<M:Monoid>Segtree<M>{pub fn new(n:usize)->Segtree<M>{vec![M::identity();n].into()}}impl<M:Monoid>From<Vec<M::S>>for Segtree<M>{fn from(v:Vec<M::S>)->Self{let n=v.len();let log=ceil_pow2(n as u32)as usize;let size=1<<log;let mut d=vec![M::identity();2*size];d[size..(size+n)].clone_from_slice(&v);let mut ret=Segtree{n,size,log,d};for i in(1..size).rev(){ret.update(i);}ret}}impl<M:Monoid>Segtree<M>{pub fn set(&mut self,mut p:usize,x:M::S){assert!(p<self.n);p+=self.size;self.d[p]=x;for i in 1..=self.log{self.update(p>>i);}}pub fn get(&self,p:usize)->M::S{assert!(p<self.n);self.d[p+self.size].clone()}pub fn prod(&self,mut l:usize,mut r:usize)->M::S{assert!(l<=r&&r<=self.n);let mut sml=M::identity();let mut smr=M::identity();l+=self.size;r+=self.size;while l<r{if l&1!=0{sml=M::binary_operation(&sml,&self.d[l]);l+=1;}if r&1!=0{r-=1;smr=M::binary_operation(&self.d[r],&smr);}l>>=1;r>>=1;}M::binary_operation(&sml,&smr)}pub fn all_prod(&self)->M::S{self.d[1].clone()}pub fn max_right<F>(&self,mut l:usize,f:F)->usize where F:Fn(&M::S)->bool,{assert!(l<=self.n);assert!(f(&M::identity()));if l==self.n{return self.n;}l+=self.size;let mut sm=M::identity();while{while l%2==0{l>>=1;}if!f(&M::binary_operation(&sm,&self.d[l])){while l<self.size{l*=2;let res=M::binary_operation(&sm,&self.d[l]);if f(&res){sm=res;l+=1;}}return l-self.size;}sm=M::binary_operation(&sm,&self.d[l]);l+=1;{let l=l as isize;(l&-l)!=l}}{}self.n}pub fn min_left<F>(&self,mut r:usize,f:F)->usize where F:Fn(&M::S)->bool,{assert!(r<=self.n);assert!(f(&M::identity()));if r==0{return 0;}r+=self.size;let mut sm=M::identity();while{r-=1;while r>1&&r%2==1{r>>=1;}if!f(&M::binary_operation(&self.d[r],&sm)){while r<self.size{r=2*r+1;let res=M::binary_operation(&self.d[r],&sm);if f(&res){sm=res;r-=1;}}return r+1-self.size;}sm=M::binary_operation(&self.d[r],&sm);{let r=r as isize;(r&-r)!=r}}{}0}fn update(&mut self,k:usize){self.d[k]=M::binary_operation(&self.d[2*k],&self.d[2*k+1]);}}pub struct Segtree<M>where M:Monoid,{n:usize,size:usize,log:usize,d:Vec<M::S>,}}}\n        pub mod kyopro_utils {pub use crate::__cargo_equip::macros::kyopro_utils::*;use std::ops::{Add,Rem};#[macro_export]macro_rules!__cargo_equip_macro_def_kyopro_utils_mat{($($e:expr),*)=>{Vec::from(vec![$($e),*])};($($e:expr,)*)=>{Vec::from(vec![$($e),*])};($e:expr;$d:expr)=>{Vec::from(vec![$e;$d])};($e:expr;$d:expr$(;$ds:expr)+)=>{Vec::from(vec![mat![$e$(;$ds)*];$d])};}macro_rules!mat{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_kyopro_utils_mat!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_kyopro_utils_ec{($($num:expr),*)=>{let mut tmp=vec![];$(tmp.push(format!(\"{}\",$num));)*print!(\"{}\n\",tmp.join(\" \"));};}macro_rules!ec{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_kyopro_utils_ec!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_kyopro_utils_YesNo{($num:expr)=>{if($num)as i64==0{println!(\"No\");}else{println!(\"Yes\");}};}macro_rules!YesNo{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_kyopro_utils_YesNo!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_kyopro_utils_Yes{()=>{println!(\"Yes\");};}macro_rules!Yes{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_kyopro_utils_Yes!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_kyopro_utils_No{()=>{println!(\"No\");};}macro_rules!No{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_kyopro_utils_No!{$($tt)*})}pub trait SetMinMax{fn setmin(&mut self,v:Self)->bool;fn setmax(&mut self,v:Self)->bool;}impl<T>SetMinMax for T where T:PartialOrd,{fn setmin(&mut self,v:T)->bool{*self>v&&{*self=v;true}}fn setmax(&mut self,v:T)->bool{*self<v&&{*self=v;true}}}#[macro_export]macro_rules!__cargo_equip_macro_def_kyopro_utils_chmax{($lhs:expr,$rhs:expr)=>{if$lhs<$rhs{let tmp=$rhs;$lhs=tmp;true}else{false}};}macro_rules!chmax{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_kyopro_utils_chmax!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_kyopro_utils_chmin{($lhs:expr,$rhs:expr)=>{if$lhs>$rhs{let tmp=$rhs;$lhs=tmp;true}else{false}};}macro_rules!chmin{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_kyopro_utils_chmin!{$($tt)*})}pub fn print_vec<T>(v:&[T])where T:std::fmt::Display,{for i in 0..v.len(){print!(\"{}{}\",v[i],if i+1==v.len(){\"\"}else{\" \"});}println!();}pub fn pmod<T:Copy+Add<Output=T>+Rem<Output=T>>(x:T,m:T)->T{((x%m)+m)%m}pub fn lower_bound<T>(a:&[T],x:&T)->usize where T:Ord,{if a.len()==0||a[0]>=*x{return 0;}let mut l=0;let mut r=a.len();while l+1<r{let m=(l+r)/2;if a[m]<*x{l=m;}else{r=m;}}r}pub fn upper_bound<T>(a:&[T],x:&T)->usize where T:Ord,{if a.len()==0||a[0]>*x{return 0;}let mut l=0;let mut r=a.len();while l+1<r{let m=(l+r)/2;if a[m]<=*x{l=m;}else{r=m;}}r}#[allow(unused_macros)]#[macro_export]macro_rules!__cargo_equip_macro_def_kyopro_utils_db{($($a:expr),*$(,)*)=>{#[cfg(debug_assertions)]eprintln!(concat!($(\"| \",stringify!($a),\"={:?} \"),*),$(&$a),*);};}macro_rules!db{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_kyopro_utils_db!{$($tt)*})}#[allow(unused_macros)]#[macro_export]macro_rules!__cargo_equip_macro_def_kyopro_utils_db2d{($vec:expr)=>{#[cfg(debug_assertions)]{eprintln!(\"> {}=\",stringify!($vec));for a in$vec.iter(){eprintln!(\"> {:?}\",a);}}};}macro_rules!db2d{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_kyopro_utils_db2d!{$($tt)*})}#[derive(PartialEq,PartialOrd,Clone,Copy)]pub struct OrdF<T>(pub T);impl<T:PartialEq>Eq for OrdF<T>{}impl<T:PartialOrd>Ord for OrdF<T>{fn cmp(&self,other:&OrdF<T>)->std::cmp::Ordering{self.0.partial_cmp(&other.0).unwrap()}}}\n    }\n\n    pub(crate) mod macros {\n        pub mod __ac_library_rs_parted_internal_bit_0_1_0 {}\n        pub mod __ac_library_rs_parted_internal_type_traits_0_1_0 {}\n        pub mod acl_lazysegtree {}\n        pub mod acl_segtree {}\n        pub mod kyopro_utils {pub use crate::{__cargo_equip_macro_def_kyopro_utils_No as No,__cargo_equip_macro_def_kyopro_utils_Yes as Yes,__cargo_equip_macro_def_kyopro_utils_YesNo as YesNo,__cargo_equip_macro_def_kyopro_utils_chmax as chmax,__cargo_equip_macro_def_kyopro_utils_chmin as chmin,__cargo_equip_macro_def_kyopro_utils_db as db,__cargo_equip_macro_def_kyopro_utils_db2d as db2d,__cargo_equip_macro_def_kyopro_utils_ec as ec,__cargo_equip_macro_def_kyopro_utils_mat as mat};}\n    }\n\n    pub(crate) mod prelude {pub use crate::__cargo_equip::crates::*;}\n\n    mod preludes {\n        pub mod __ac_library_rs_parted_internal_bit_0_1_0 {}\n        pub mod __ac_library_rs_parted_internal_type_traits_0_1_0 {}\n        pub mod acl_lazysegtree {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::{__ac_library_rs_parted_internal_bit_0_1_0 as __acl_internal_bit,acl_segtree as __acl_segtree};}\n        pub mod acl_segtree {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::{__ac_library_rs_parted_internal_bit_0_1_0 as __acl_internal_bit,__ac_library_rs_parted_internal_type_traits_0_1_0 as __acl_internal_type_traits};}\n        pub mod kyopro_utils {}\n    }\n}\n\n\n",
    "submit_ts": "1722743832",
    "subm_id": "1343800714"
}