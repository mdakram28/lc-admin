{
    "username": "hamsik",
    "submission": "class Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        const int N = nums.size();\n        vector<Info> a(N);\n        for (int i = 1; i < N - 1; i++) {\n            if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {\n                a[i].cnt = 1;\n                // cout << i << \" is peak\" << endl;\n            }\n        }\n        SGT<Info> sgt(a);\n        vector<int> ret;\n        for (auto &q : queries) {\n            // cout << \"Q: \" << q[0] << \" \" << q[1] << \":\" << q[2] << endl;\n            if (q[0] == 1) {\n                if (q[2] - q[1] < 2) {\n                    ret.push_back(0);\n                } else {\n                    ret.push_back(sgt.query(q[1] + 1, q[2]).cnt);\n                }\n            } else {\n                nums[q[1]] = q[2];\n                for (int i = q[1] - 1; i <= q[1] + 1; i++) {\n                    if (i <= 0 || i >= N - 1) {\n                        continue;\n                    }\n                    if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {\n                        if (a[i].cnt == 0) {\n                            a[i].cnt = 1;\n                            sgt.modify(i, a[i]);\n                            // cout << \"New peak \" << i << endl;\n                        }\n                    } else {\n                        if (a[i].cnt == 1) {\n                            a[i].cnt = 0;\n                            sgt.modify(i, a[i]);\n                            // cout << \"Delete peak \" << i << endl;\n                        }\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n\n    template<class Info>\n    struct SGT {\n        #define l(p) (p << 1)\n        #define r(p) (p << 1 | 1)\n\n        int n;\n        std::vector<Info> info;\n        SGT() {}\n\n        SGT(int _n, Info _v = Info()) {\n            init(_n, _v);\n        }\n\n        template<class T>\n        SGT(std::vector<T> _init) {\n            init(_init);\n        }\n\n        void init(int _n, Info _v = Info()) {\n            init(std::vector(_n, _v));\n        }\n\n        template<class T>\n        void init(std::vector<T> _init) {\n            n = _init.size();\n            info.assign(4 << std::__lg(n), Info());\n            auto build = [&](auto self, int p, int l, int r) {\n                if (r - l == 1) {\n                    info[p] = _init[l];\n                    return;\n                }\n                int m = l + r >> 1;\n                self(self, l(p), l, m);\n                self(self, r(p), m, r);\n                pull(p);\n            };\n            build(build, 1, 0, n);\n        }\n\n        void pull(int p) {\n            info[p] = info[l(p)] + info[r(p)];\n        }\n\n        void modify(int p, int l, int r, int x, const Info &v) {\n            if (r - l == 1) {\n                info[p] = v;\n                return;\n            }\n            int m = l + r >> 1;\n            if (x < m) {\n                modify(l(p), l, m, x, v);\n            } else {\n                modify(r(p), m, r, x, v);\n            }\n            pull(p);\n        }\n\n        void modify(int p, const Info &v) {\n            modify(1, 0, n, p, v);\n        }\n\n        Info query(int p, int l, int r, int x, int y) {\n            if (l >= y or r <= x) {\n                return Info();\n            }\n            if (l >= x and r <= y) {\n                return info[p];\n            }\n            int m = l + r >> 1;\n            return query(l(p), l, m, x, y) + query(r(p), m, r, x, y);\n        }\n\n        Info query(int l, int r) {\n            // cout << \"query \" << l << \",\" << r << endl;\n            return query(1, 0, n, l, r);\n        }\n\n        #undef l(p)\n        #undef r(p)\n    };\n\n    struct Info {\n        int cnt;\n    };\n\n    friend Info operator+(Info a, Info b) {\n        Info c;\n        c.cnt = a.cnt + b.cnt;\n        return c;\n    }\n};",
    "submit_ts": 1718508484.0
}