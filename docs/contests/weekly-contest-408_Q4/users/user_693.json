{
    "username": "YuqiJIa",
    "submission": "class Solution {\n    public static class Circle {\n        int x, y, r;\n\n        Circle(int x, int y, int r) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n        }\n    }\n    public static boolean circlesIntersect(Circle c1, Circle c2) {\n        int dx = c1.x - c2.x;\n        int dy = c1.y - c2.y;\n        int distanceSquared = dx * dx + dy * dy;\n        int radiusSum = c1.r + c2.r;\n        return distanceSquared <= radiusSum * radiusSum;\n    }\n    public static boolean intersectsLeftBoundary(Circle circle) {\n        return circle.x - circle.r <= 0;\n    }\n\n    public static boolean intersectsRightBoundary(Circle circle, int X) {\n        return circle.x + circle.r >= X;\n    }\n\n    public static boolean intersectsBottomBoundary(Circle circle) {\n        return circle.y - circle.r <= 0;\n    }\n\n    public static boolean intersectsTopBoundary(Circle circle, int Y) {\n        return circle.y + circle.r >= Y;\n    }\n\n    public static Map<Integer, List<Integer>> buildGraph(List<Circle> circles) {\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        int n = circles.size();\n        for (int i = 0; i < n; i++) {\n            graph.put(i, new ArrayList<>());\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (circlesIntersect(circles.get(i), circles.get(j))) {\n                    graph.get(i).add(j);\n                    graph.get(j).add(i);\n                }\n            }\n        }\n        return graph;\n    }\n\n    public static boolean bfs(List<Integer> startNodes, Set<Integer> targetNodes, Map<Integer, List<Integer>> graph) {\n        Queue<Integer> queue = new LinkedList<>(startNodes);\n        Set<Integer> visited = new HashSet<>(startNodes);\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            if (targetNodes.contains(node)) {\n                return true;\n            }\n            for (int neighbor : graph.get(node)) {\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    queue.add(neighbor);\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean canReachCorner(int X, int Y, int[][] circlesArr) {\n        List<Circle> circles = new ArrayList<>();\n        for (int[] c : circlesArr) {\n            circles.add(new Circle(c[0], c[1], c[2]));\n        }\n\n        Map<Integer, List<Integer>> graph = buildGraph(circles);\n\n        List<Integer> leftBoundaryNodes = new ArrayList<>();\n        List<Integer> rightBoundaryNodes = new ArrayList<>();\n        List<Integer> bottomBoundaryNodes = new ArrayList<>();\n        List<Integer> topBoundaryNodes = new ArrayList<>();\n\n        for (int i = 0; i < circles.size(); i++) {\n            if (intersectsLeftBoundary(circles.get(i))) {\n                leftBoundaryNodes.add(i);\n            }\n            if (intersectsRightBoundary(circles.get(i), X)) {\n                rightBoundaryNodes.add(i);\n            }\n            if (intersectsBottomBoundary(circles.get(i))) {\n                bottomBoundaryNodes.add(i);\n            }\n            if (intersectsTopBoundary(circles.get(i), Y)) {\n                topBoundaryNodes.add(i);\n            }\n        }\n\n        if (bfs(leftBoundaryNodes, new HashSet<>(bottomBoundaryNodes), graph)) {\n            return false;\n        }\n        \n        if (bfs(topBoundaryNodes, new HashSet<>(bottomBoundaryNodes), graph)) {\n            return false;\n        }\n        \n        if (bfs(leftBoundaryNodes, new HashSet<>(rightBoundaryNodes), graph)) {\n            return false;\n        }\n\n        if (bfs(topBoundaryNodes, new HashSet<>(rightBoundaryNodes), graph)) {\n            return false;\n        }\n\n        return true;\n    }\n}",
    "submit_ts": "1722138650",
    "subm_id": "1335796199"
}