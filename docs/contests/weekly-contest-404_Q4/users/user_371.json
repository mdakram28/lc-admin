{
    "username": "aekairis",
    "submission": "class Solution {\npublic:\n    pair<int,int> getDiameterUtil(const vector<vector<int>>& graph,int root,int parent){\n        int maxDiameter=0;\n        priority_queue<int,vector<int>,greater<int>> pq;\n        for(auto v:graph[root]){\n            if(v!=parent){\n                auto c = getDiameterUtil(graph,v,root);\n                maxDiameter = max(maxDiameter,c.first);\n                pq.push(c.second);\n                if(pq.size()>2){\n                    pq.pop();\n                }\n            }\n        }\n        int diameterFromHere = 0;\n        int maxHeight=0;\n        while(!pq.empty()){\n            diameterFromHere+=pq.top();\n            maxHeight=max(pq.top(),maxHeight);\n            pq.pop();\n        }\n        // cout<<root<<\" : \"<<diameterFromHere<<\" : \"<<maxHeight<<\"\\n\";\n        return {max(maxDiameter,diameterFromHere),maxHeight+1};\n    }\n    \n    int getDiameter(const vector<vector<int>>& graph){\n        auto r = getDiameterUtil(graph,0,-1);\n        return r.first;\n    }\n    \n    vector<vector<int>> buildGraph(const vector<vector<int>>& edges){\n        int n=edges.size()+1;\n        vector<vector<int>> graph(n);\n        for(auto e:edges){\n            graph[e[0]].push_back(e[1]);\n            graph[e[1]].push_back(e[0]);\n        }\n        return graph;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        auto g1 = buildGraph(edges1);\n        int d1 = getDiameter(g1);\n        auto g2 = buildGraph(edges2);\n        int d2 = getDiameter(g2);\n        if(d1>d2){\n            return max(d2-(d2/2)+1,d1/2)+d1-(d1/2);\n        }else{\n            return max(d1-(d1/2)+1,d2/2)+d2-(d2/2);\n        }\n    }\n};",
    "submit_ts": 1719717783.0
}