{
    "username": "ijasonchao",
    "submission": "class Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        \"\"\"\n        dfs with cost and constructions\n        prefer long but costs is short, can use a trie with cost, dp with cost\n        \"\"\"\n\n        sig_tgt = set(target)\n        sig_src = set(''.join(words))\n        diff = sig_tgt - sig_src\n        if diff: return -1\n\n        seen = defaultdict(int)\n        for k, v in zip(words, costs):\n            if k not in seen or seen[k] > v: seen[k] = v\n\n        TrieNode = lambda: defaultdict(TrieNode)\n        root = TrieNode()\n\n        for k, v in seen.items():        \n            r = root\n            for c in k:                \n                r = r[c]\n            r['#'] = (k, v)\n\n        @cache\n        def dfs(i):\n            if i >= len(target): return 0\n            else:\n                cur = inf\n                #using a tri to retrieve the possible matched words from i\n                #print('root', i, target[i])\n                r = root\n                for j in range(i, len(target)):\n                    c = target[j]\n                    #print (c, c in r, 'root')\n                    if c in r:\n                        r = r[c]\n                        #print(target[i:j+1], r, r.get('#', None))\n                        if '#' in r: \n                            cur = min(cur, r['#'][1] + dfs(j + 1))\n                            #print(i, j, r['#'], cur)\n                    else:\n                        break\n                    \n                return cur\n        \n        res = dfs(0)\n        return res if res != inf else -1\n\n",
    "submit_ts": "1720323455",
    "subm_id": "1312375987"
}