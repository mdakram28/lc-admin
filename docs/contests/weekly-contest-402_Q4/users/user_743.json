{
    "username": "REED_W",
    "submission": "class Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        return sln1(nums, queries);\n    }\n    \n    private List<Integer> sln1(int[] nums, int[][] qs){\n        int n= nums.length;\n        int m = qs.length;\n        SegTree st = new SegTree(nums);\n        List<Integer> res= new ArrayList<>();\n        for(int i = 0;i<m;i++){\n            if(qs[i][0] == 1){\n                res.add(st.query(qs[i][1], qs[i][2]));\n            }else{\n                st.update(qs[i][1], qs[i][2]);\n            }\n        }\n        return res;\n    }\n    \n    class SegTree{\n        \n        Node root;\n        int[] nums;\n        \n        class Node{\n            Node left;\n            Node right;\n            int start;\n            int end;\n            int val;\n        }\n        \n        SegTree(int[] nums){\n            this.nums = nums;\n            root = buildTree(nums, 0, nums.length-1);\n        }\n        \n        private Node buildTree(int[] nums, int start, int end){\n            if (start > end) {\n                return null;\n            } else {\n                Node node = new Node();\n                node.start = start; node.end = end;\n                if (start == end) {\n                    node.val = 0;\n                } else {\n                    int mid = start  + (end - start) / 2;             \n                    node.left = buildTree(nums, start, mid);\n                    node.right = buildTree(nums, mid + 1, end);\n                    node.val = node.left.val + node.right.val;\n                    if(node.left.end-node.left.start>=1 && node.right.end-node.right.start>=0 && nums[node.left.end-1] < nums[node.left.end] && nums[node.left.end] > nums[node.right.start]) {\n                        node.val++;\n                    }\n                    if(node.left.end-node.left.start>=0 && node.right.end-node.right.start>=1 && nums[node.left.end] < nums[node.right.start] && nums[node.right.start] > nums[node.right.start+1]) {\n                        node.val++;\n                    }\n                }         \n                return node;\n            }\n        }\n        \n        void update(int i, int val){\n            nums[i] = val;\n            update(root, i, val);\n        }\n        \n        void update(Node node, int i, int val){\n            if (node.start == node.end) {\n               node.val = 0;\n            } else {\n                int mid = node.start + (node.end - node.start) / 2;\n                if (i <= mid) {\n                     update(node.left, i, val);\n                } else {\n                     update(node.right, i, val);\n                }\n                node.val = node.left.val + node.right.val;\n                if(node.left.end-node.left.start>=1 && node.right.end-node.right.start>=0 && nums[node.left.end-1] < nums[node.left.end] && nums[node.left.end] > nums[node.right.start]) {\n                    node.val++;\n                }\n                if(node.left.end-node.left.start>=0 && node.right.end-node.right.start>=1 && nums[node.left.end] < nums[node.right.start] && nums[node.right.start] > nums[node.right.start+1]) {\n                    node.val++;\n                }\n            }\n        }\n        \n        int query(int start, int end){\n            return query(root, start, end);\n        }\n        \n        int query(Node node, int start, int end){\n            if (node.end == end && node.start == start) {\n                return node.val;\n            } else {\n                int mid = node.start + (node.end - node.start) / 2;\n                if (end <= mid) {\n                    return query(node.left, start, end);\n                } else if (start > mid) {\n                    return query(node.right, start, end);\n                }  else {   \n                    int res = query(node.right, mid+1, end) + query(node.left, start, mid);\n                    if(node.left.end-start>=1 && end-node.right.start>=0 && nums[node.left.end-1] < nums[node.left.end] && nums[node.left.end] > nums[node.right.start]) {\n                        //System.out.printf(\"l:%d %d\\n\", node.start, node.end);\n                        res++;\n                    }\n                    if(node.left.end-start>=0 && end-node.right.start>=1 && nums[node.left.end] < nums[node.right.start] && nums[node.right.start] > nums[node.right.start+1]) {\n                        //System.out.printf(\"r:%d %d\\n\", node.start, node.end);\n                        res++;\n                    }\n                    return res;\n                }\n            }\n        }\n    }\n\n}",
    "submit_ts": "1718508065",
    "subm_id": "1289670673"
}