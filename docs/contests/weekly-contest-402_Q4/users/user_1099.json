{
    "username": "WORTH_IT",
    "submission": "class Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        int n = nums.length;\n\n        class Node {\n            final int a, b, c, d, ans, size;\n\n            public Node(int a, int b, int c, int d, int ans, int size) {\n                this.a = a;\n                this.b = b;\n                this.c = c;\n                this.d = d;\n                this.ans = ans;\n                this.size = size;\n            }\n\n            public Node(int v) {\n                this(v, v, v, v, 0, 1);\n            }\n\n            public Node() {\n                this(-1, -1, -1, -1, 0, 0);\n            }\n\n            @Override\n            public String toString() {\n                return\n                        \"\\n(\" + a + b + c + d +\n                                \", \" + ans +\n                                \", \" + size +\n                                ')';\n            }\n        }\n\n        BinaryOperator<Node> merge = new BinaryOperator<Node>() {\n            @Override\n            public Node apply(Node a, Node b) {\n                if (a.size == 0)\n                    return b;\n                if (b.size == 0)\n                    return a;\n\n                int A = a.a;\n                int B = a.size == 1 ? b.a : a.b;\n                int C = b.size == 1 ? a.d : b.c;\n                int D = b.d;\n                int ans = a.ans + b.ans;\n                boolean left = a.d > a.c && a.d > b.a;\n                boolean right = b.a > b.b && b.a > a.d;\n                if (left || right)\n                    ans++;\n\n                return new Node(A, B, C, D, ans, a.size + b.size);\n            }\n        };\n\n        SegmentTree<Node> st = new SegmentTree<Node>(i -> new Node(nums[i]), n, new Node(), merge);\n\n        ArrayList<Integer> ans = new ArrayList<>();\n        for (int[] q : queries) {\n            if (q[0] == 1)\n                ans.add(st.query(q[1], q[2]).ans);\n            else\n                st.update(q[1], new Node(q[2]));\n        }\n        return ans;\n    }\n}\n\nclass SegmentTree<Node> {\n\n    Node[] tree;\n    Node identity;\n    int n;\n    java.util.function.BinaryOperator<Node> merge;\n\n    @SuppressWarnings(\"unchecked\")\n    public SegmentTree(java.util.function.IntFunction<Node> init, int n, Node identity, java.util.function.BinaryOperator<Node> merge) {\n        this.n = ceilingPowerOf2(n);\n        this.tree = (Node[]) new Object[this.n << 1];\n        this.identity = identity;\n        this.merge = merge;\n        java.util.Arrays.fill(tree, identity);\n        for (int i = 0; i < n; i++)\n            tree[this.n + i] = init.apply(i);\n        for (int i = this.n - 1; i > 0; i--)\n            tree[i] = merge.apply(tree[i << 1], tree[i << 1 | 1]);\n    }\n\n    public SegmentTree(Node[] a, Node identity, java.util.function.BinaryOperator<Node> merge) {\n        this(i -> a[i], a.length, identity, merge);\n    }\n\n    private static int ceilingPowerOf2(int n) {\n        if ((n & (n - 1)) == 0)\n            return n;\n        n |= n >> 1;\n        n |= n >> 2;\n        n |= n >> 4;\n        n |= n >> 8;\n        n |= n >> 16;\n        return n + 1;\n    }\n\n    int size() {\n        return n;\n    }\n\n    public void update(int position, Node value) {\n        update(1, 0, n - 1, position, value);\n    }\n\n    private void update(int v, int l, int r, int position, Node value) {\n        if (position < l || position > r)\n            return;\n        if (l == r) {\n            tree[v] = value;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        update(v << 1, l, mid, position, value);\n        update(v << 1 | 1, mid + 1, r, position, value);\n        tree[v] = merge.apply(tree[v << 1], tree[v << 1 | 1]);\n    }\n\n    public Node query(int p) {\n        return query(p, p);\n    }\n\n    public Node query(int l, int r) {\n        return query(1, 0, n - 1, l, r);\n    }\n\n    private Node query(int v, int l, int r, int ql, int qr) {\n        if (ql > r || qr < l)\n            return identity;\n        if (ql <= l && qr >= r)\n            return tree[v];\n        int m = (l + r) >> 1;\n        return merge.apply(query(v << 1, l, m, ql, qr), query(v << 1 | 1, m + 1, r, ql, qr));\n    }\n}",
    "submit_ts": 1718508632.0
}