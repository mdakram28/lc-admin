{
    "username": "kamanashisroy",
    "submission": "\n\nclass SegmentTree:\n    '''\n    segment_tree.py file is part of Algosnippet.\n    Algosnippet is a collection of practice data-structures and algorithms\n    Copyright (C) 2021  Kamanashis Roy\n    Algosnippet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n    Algosnippet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n    You should have received a copy of the GNU General Public License\n    along with Algosnippet.  If not, see <https://www.gnu.org/licenses/>.\n    '''\n\n    def __init__(self, N:int):\n        depth = 0\n        while (1<<depth) < N:\n            depth += 1\n\n        N = 1<<depth\n        self.nodes = [ 0 for _ in range((N<<1)+2)]\n        self.N = N\n        # N = 4\n        # [ filler 0 ] [ root Node 1 ] 2 3 [ Internal nodes 4 5 6 7 ] [ Leaves 8 9 10 11 12 13 14 15 ]\n\n    def append(self, i:int, k:int) -> None:\n        '''\n        This segment tree only increases 1 every time.\n        '''\n        curr = self.N+i\n        self.nodes[curr] += k\n        while curr > 1:\n            # get parent\n            parent = curr >> 1\n            self.nodes[parent] += k\n            curr = parent\n\n    def countSmaller(self, limit:int) -> int:\n        if 0 == limit:\n            return 0\n        curr = self.N+limit-1\n        deduct = 0\n        while curr > 1:\n            #print(curr,self.N,len(self.nodes))\n            if curr&1 == 0: # in case even\n                deduct += self.nodes[curr+1]\n            # get parent\n            parent = curr >> 1\n            curr = parent\n        return self.nodes[1] - deduct\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        N = len(nums)\n        \n        tree = SegmentTree(N)\n        isPeak = [0]*N\n        for i in range(1,N-1):\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:\n                tree.append(i,1)\n                isPeak[i] = 1\n        \n        result = []\n        for op, arg1,arg2 in queries:\n            if 1 == op:\n                if arg2-arg1 <= 1:\n                    result.append(0)\n                elif arg2-arg1 < 4:\n                    calc = 0\n                    for i in range(arg1+1,arg2):\n                        if nums[i] > nums[i-1] and nums[i] > nums[i+1]:\n                            calc += 1\n                    result.append(calc)\n                else:        \n                    result.append(tree.countSmaller(arg2)-tree.countSmaller(arg1+1))\n                \n            else:\n                if nums[arg1] == arg2:\n                    continue\n                else:\n                    # clear old\n                    for i in range(max(arg1-1,0),min(N-1,arg1+2)):\n                        if isPeak[i]:\n                            tree.append(i,-1)\n                    nums[arg1] = arg2\n                    # recalculate\n                    for i in range(max(arg1-1,0),min(N-1,arg1+2)):\n                        if nums[i] > nums[i-1] and nums[i] > nums[i+1]:\n                            tree.append(i,1)\n                            isPeak[i] = 1\n                        else:\n                            isPeak[i] = 0\n                            \n        return result\n                    \n                    \n                    ",
    "submit_ts": 1718508383.0
}