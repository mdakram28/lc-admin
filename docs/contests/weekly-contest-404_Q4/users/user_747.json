{
    "username": "user3751Xt",
    "submission": "class Solution {\npublic:\n    \n    pair<int,int> bfsfurthest(int a,vector<vector<int>> &edges)\n    {\n        //we need to find the center of tree\n        vector<int> visited(edges.size()+1,0);\n        queue<pair<int,int>> q;\n        q.push({a,0});\n\n        int maxdist = 0;\n        int maxnode = -1;\n        while(!q.empty())\n        {\n            pair<int,int> cur = q.front();\n            q.pop();\n            int curnode = cur.first;\n            int curdist = cur.second;\n            if(curdist>maxdist)\n            {\n                maxdist = curdist;\n                maxnode = curnode;\n            }\n            visited[curnode]=1;\n            for(int x:edges[curnode])\n            {\n                if(!visited[x]) q.push({x,curdist+1});\n            }\n        }\n        return {maxnode,maxdist};\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) \n    {\n        int n = edges1.size()+1;\n        int m = edges2.size()+1;\n\n        \n        vector<vector<int>> edges11(n+1,vector<int>());\n        vector<vector<int>> edges21(m+1,vector<int>());\n\n        // answer is (diameter1-1/2 + 1) + (diameter2-1/2 +1) + 1;\n\n        for(vector<int> edge:edges1) \n        {\n            edges11[edge[0]].push_back(edge[1]);\n            edges11[edge[1]].push_back(edge[0]);\n        }\n        for(vector<int> edge:edges2)\n        {\n            edges21[edge[0]].push_back(edge[1]);\n            edges21[edge[1]].push_back(edge[0]);\n        }\n        if(n==1||m==1)\n        {\n            if(n==1&&m==1) return 1;\n            if(n==1)\n            {\n                //find diamter of tree2 and add one to the result\n                pair<int,int> initial1 = bfsfurthest(0,edges21);\n                pair<int,int> final1 = bfsfurthest(initial1.first,edges21);\n\n                int diameter2 = final1.second;\n                return ((diameter2-1)/2 + 1) + 1;\n            }\n            else\n            {\n                pair<int,int> initial = bfsfurthest(0,edges11);\n                pair<int,int> final = bfsfurthest(initial.first,edges11);\n\n                int diameter1 = final.second;\n                return ((diameter1-1)/2+1)+1;\n            }\n        }\n        //find diamter of tree for tree 1\n\n        pair<int,int> initial = bfsfurthest(0,edges11);\n        pair<int,int> final = bfsfurthest(initial.first,edges11);\n\n        int diameter1 = final.second;\n\n        pair<int,int> initial1 = bfsfurthest(0,edges21);\n        pair<int,int> final1 = bfsfurthest(initial1.first,edges21);\n\n        int diameter2 = final1.second;\n        \n\n        cout<<\"diameter1 is \"<<diameter1<<\" and diameter 2 is \"<<diameter2<<endl;\n        int quant1 = ((diameter1-1)/2+1) + ((diameter2-1)/2 +1) + 1;\n        return max(max(quant1,diameter1),diameter2);\n       \n    }\n};",
    "submit_ts": "1719719143",
    "subm_id": "1304434753"
}