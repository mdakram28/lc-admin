{
    "username": "curiousdead",
    "submission": "from collections import deque\nfrom typing import List, Tuple\nclass Solution:\n    def bfs(self, graph, start, target1, target2, total_nodes):\n        queue = deque([start])\n        visited = [False] * (total_nodes + 4)\n        visited[start] = True\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    queue.append(neighbor)\n                    visited[neighbor] = True\n        return visited[target1] or visited[target2]\n\n    def canReachCorner(self, X, Y, circles):\n        num_circles = len(circles)\n        graph = [[] for _ in range(num_circles + 4)]\n        for i in range(num_circles):\n            x, y, radius = circles[i]\n            if x <= radius:\n                graph[num_circles].append(i)\n                graph[i].append(num_circles)\n            if X - x <= radius:\n                graph[num_circles + 2].append(i)\n                graph[i].append(num_circles + 2)\n            if y <= radius:\n                graph[num_circles + 1].append(i)\n                graph[i].append(num_circles + 1)\n            if Y - y <= radius:\n                graph[num_circles + 3].append(i)\n                graph[i].append(num_circles + 3)\n            for j in range(i + 1, num_circles):\n                x2, y2, radius2 = circles[j]\n                distance = sqrt((x - x2) ** 2 + (y - y2) ** 2)\n                if radius + radius2 >= distance:\n                    graph[i].append(j)\n                    graph[j].append(i)\n        return not (self.bfs(graph, num_circles, num_circles + 1, num_circles + 2, num_circles + 4) or \n                    self.bfs(graph, num_circles + 3, num_circles + 2, num_circles + 1, num_circles + 4))\n",
    "submit_ts": "1722139114",
    "subm_id": "1335808227"
}