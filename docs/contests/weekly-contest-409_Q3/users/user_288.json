{
    "username": "hanzhoutang",
    "submission": "typedef vector<int> vi;\n\nclass SegmentTree {                              // OOP style\nprivate:\n  int n;                                         // n = (int)A.size()\n  vi A, st, lazy;                                // the arrays\n\n  int l(int p) { return  p<<1; }                 // go to left child\n  int r(int p) { return (p<<1)+1; }              // go to right child\n\n  int conquer(int a, int b) {\n      return a + b; \n  }\n\n  void build(int p, int L, int R) {              // O(n)\n    if (L == R)\n      st[p] = A[L];                              // base case\n    else {\n      int m = (L+R)/2;\n      build(l(p), L  , m);\n      build(r(p), m+1, R);\n      st[p] = conquer(st[l(p)], st[r(p)]);\n    }\n  }\n\n  void propagate(int p, int L, int R) {\n    if (lazy[p] != -1) {                         // has a lazy flag\n      st[p] = lazy[p];                           // [L..R] has same value\n      if (L != R)                                // not a leaf\n        lazy[l(p)] = lazy[r(p)] = lazy[p];       // propagate downwards\n      else                                       // L == R, a single index\n        A[L] = lazy[p];                          // time to update this\n      lazy[p] = -1;                              // erase lazy flag\n    }\n  }\n\n  int RMQ(int p, int L, int R, int i, int j) {   // O(log n)\n    propagate(p, L, R);                          // lazy propagation\n    if (i > j) return -1;                        // infeasible\n    if ((L >= i) && (R <= j)) return st[p];      // found the segment\n    int m = (L+R)/2;\n    return conquer(RMQ(l(p), L  , m, i          , min(m, j)),\n                   RMQ(r(p), m+1, R, max(i, m+1), j        ));\n  }\n\n  void update(int p, int L, int R, int i, int j, int val) { // O(log n)\n    propagate(p, L, R);                          // lazy propagation\n    if (i > j) return;\n    if ((L >= i) && (R <= j)) {                  // found the segment\n      lazy[p] = val;                             // update this\n      propagate(p, L, R);                        // lazy propagation\n    }\n    else {\n      int m = (L+R)/2;\n      update(l(p), L  , m, i          , min(m, j), val);\n      update(r(p), m+1, R, max(i, m+1), j        , val);\n      int lsubtree = (lazy[l(p)] != -1) ? lazy[l(p)] : st[l(p)];\n      int rsubtree = (lazy[r(p)] != -1) ? lazy[r(p)] : st[r(p)];\n      st[p] = conquer(lsubtree, rsubtree);\n    }\n  }\n\npublic:\n  SegmentTree(int sz) : n(sz), A(n), st(4*n), lazy(4*n, -1) {}\n\n  SegmentTree(const vi &initialA) : SegmentTree((int)initialA.size()) {\n    A = initialA;\n    build(1, 0, n-1);\n  }\n\n  void update(int i, int j, int val) { update(1, 0, n-1, i, j, val); }\n\n  int RMQ(int i, int j) { return RMQ(1, 0, n-1, i, j); }\n};\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int> nodes(n, 1); \n        nodes[0] = 0; \n        SegmentTree tree(nodes); \n        vector<int> ret; \n        for(const auto& q : queries) {\n            const int s = q[0]; \n            const int t = q[1]; \n            tree.update(s+1, t-1, 0); \n            int ans = tree.RMQ(0,n-1); \n            ret.push_back(ans); \n        }\n        return ret; \n    }\n};",
    "submit_ts": "1722741116",
    "subm_id": "1343736987"
}