{
    "username": "aezara",
    "submission": "\"\"\"\ncan't just take the most frequent X - if its large?\n- concern: if too many numbers smack in the middle, have to change 2 elements per pair\n- best case: already X\n- case 2: only need to change one number\n- case 3: need to change both numbers (eg. 5,5 but need diff of 9 in range 0, 10)\n\ntry to keep track of max diff achievable in one change?\n- but need to recalculate that for every candidate X\n- or do i?\n\nwhat numbers are problematic?\n- X greater than k//2\n- array elements that are around k//2\ncan \"problematic\" be a boolean?\n- no, for larger X the elements must be further from k//2 to be unproblematic\n\nis there a limited number of candidates?\n- X < k//2 is linear\n- the answer must be <= n//2, because worst case we change all diffs to 0\n\nthe problem: if there are non-negligible pairs that are already a big diff\n\n\nwe can calculate the number of edits in linear time preprocess for each case\n- case 0: we go through the array and find number of pairs with the diff already\n- case 2: find the max possible diff by changing only one number; anything more than that\n    is 2 edits. so we have an array containing number of elements that require 2 edits\n    if the diff is greater than X. we can probably do like a prefix thing to get the sum\n    in O(1) time\n- case 1: everything else. note that case 0 and case 2 are mutually exclusive\n\"\"\"\n\nclass Solution:\n    def minChanges(self, a: List[int], k: int) -> int:\n        n = len(a)\n        # number of occurences of this diff\n        d = defaultdict(int)\n        # the min diff that would require two changes to achieve\n        twochange = defaultdict(int)\n        # most frequent diff\n        bestval = 0\n        for i in range(n//2):\n            j = n-i-1\n            x = abs(a[i] - a[j])\n            d[x] += 1\n            bestval = max(bestval, d[x])\n            bestdiff = max(a[i], a[j], k - a[i], k - a[j])\n            twochange[bestdiff + 1] += 1\n        \n        # print(f\"{d=}\")\n        # print(f\"{twochange=}\")\n\n        twochangeprefix = defaultdict(int)\n        acc = 0\n        # the min in the dict; even if theres no entry, if it is larger than the min\n        #   one in the dict, it requires two changes\n        mindiff = float('inf')\n        twochangekeys = list(sorted(twochange.keys()))\n        # print(f\"{twochangekeys=}\")\n        for k in twochangekeys:\n            acc += twochange[k]\n            twochangeprefix[k] = acc\n            mindiff = min(mindiff, k)\n        \n        # print(f\"{twochangeprefix=}\")\n        \n        ans = float('inf')\n        for x in d:\n            total = n//2\n            alreadygood = d[x] # 0 edits\n            twoedits = 0\n            # if k in twochangeprefix:\n            #     twoedits = twochangeprefix[k]\n            # elif x >= mindiff:\n            #     # find largest element less than x in twochangeprefix\n            #     i = bisect.bisect_left(twochangekeys, x)\n            i = bisect.bisect_right(twochangekeys, x)\n            if i > 0:\n                twoedits = twochangeprefix[twochangekeys[i-1]]\n            # else its less than the smallest key, so 0 is good\n            # print(x, total, alreadygood, twoedits)\n            ans = min(ans, total - alreadygood + twoedits)\n        return ans",
    "submit_ts": "1721489425",
    "subm_id": "1327452870"
}