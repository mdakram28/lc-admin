{
    "username": "pushprajdubey",
    "submission": "import java.util.*;\n\npublic class Solution {\n    static class pttt {\n        int x, y;\n        pttt(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n  \n\n    public static boolean canReachCorner(int X, int Y, int[][] vvv2) {\n        int cicci = vvv2.length;\n        List<List<Integer>> gppp = new ArrayList<>();\n        for (int i = 0; i < cicci + 4; i++) {\n            gppp.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < cicci; i++) {\n            int x = vvv2[i][0];\n            int y = vvv2[i][1];\n            int r = vvv2[i][2];\n            \n            if (x <= r) {\n                gppp.get(cicci).add(i);\n                gppp.get(i).add(cicci);\n            }\n            if (X - x <= r) {\n                gppp.get(cicci + 2).add(i);\n                gppp.get(i).add(cicci + 2);\n            }\n            if (y <= r) {\n                gppp.get(cicci + 1).add(i);\n                gppp.get(i).add(cicci + 1);\n            }\n            if (Y - y <= r) {\n                gppp.get(cicci + 3).add(i);\n                gppp.get(i).add(cicci + 3);\n            }\n            for (int j = i + 1; j < cicci; j++) {\n                int x2 = vvv2[j][0];\n                int y2 = vvv2[j][1];\n                int r2 = vvv2[j][2];\n                double dd = Math.sqrt(Math.pow(x - x2, 2) + Math.pow(y - y2, 2));\n                int radius_sum = r + r2;\n                if (radius_sum >= dd) {\n                    gppp.get(i).add(j);\n                    gppp.get(j).add(i);\n                }\n            }\n        }\n\n        boolean isbbbbb = bffffc(gppp, cicci, cicci + 1, cicci + 2, cicci + 4) ||\n                            bffffc(gppp, cicci + 3, cicci + 2, cicci + 1, cicci + 4); // Check for top-right corner\n        return !isbbbbb;\n    } \n  public static boolean bffffc(List<List<Integer>> graph, int a, int t1, int t2, int n) {\n        Queue<Integer> qnnnnn = new LinkedList<>();\n        boolean[] vis = new boolean[n];\n        qnnnnn.add(a);\n        vis[a] = true;\n\n        while (!qnnnnn.isEmpty()) {\n            int u = qnnnnn.poll();\n            for (int v : graph.get(u)) {\n                if (!vis[v]) {\n                    qnnnnn.add(v);\n                    vis[v] = true;\n                }\n            }\n        }\n        return vis[t1] || vis[t2];\n    }\n  \n  \n\n   \n}\n",
    "submit_ts": "1722137792",
    "subm_id": "1335773868"
}