{
    "username": "Tudor67",
    "submission": "class DSU{\nprivate:\n    vector<int> parent;\n    vector<int> size;\n    vector<int> L;\n    vector<int> R;\n    \npublic:\n    DSU(const int N){\n        size.resize(N, 1);\n        \n        parent.resize(N);\n        iota(parent.begin(), parent.end(), 0);\n        \n        L.resize(N);\n        iota(L.begin(), L.end(), 0);\n        \n        R.resize(N);\n        iota(R.begin(), R.end(), 0);\n    }\n    \n    int find(int x){\n        if(parent[x] != x){\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    \n    void join(int x, int y){\n        int xRoot = find(x);\n        int yRoot = find(y);\n        if(xRoot == yRoot){\n            return;\n        }\n        if(size[xRoot] > size[yRoot]){\n            swap(xRoot, yRoot);\n        }\n        parent[xRoot] = yRoot;\n        size[yRoot] += size[xRoot];\n        L[yRoot] = min(L[yRoot], L[xRoot]);\n        R[yRoot] = max(R[yRoot], R[xRoot]);\n    }\n    \n    int getSize(int x){\n        return size[find(x)];\n    }\n    \n    int getL(int x){\n        return L[find(x)];\n    }\n    \n    int getR(int x){\n        return R[find(x)];\n    }\n};\n\nclass SegmentTree{\nprivate:\n    const int N;\n    vector<int> tree;\n    \n    void update(int node, int l, int r, const int POS, const int VAL){\n        if(l == r){\n            tree[node] = VAL;\n        }else{\n            int mid = (l + r) / 2;\n            if(POS <= mid){\n                update(2 * node + 1, l, mid, POS, VAL);\n            }else{\n                update(2 * node + 2, mid + 1, r, POS, VAL);\n            }\n            tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n    \n    int query(int node, int l, int r, const int L, const int R){\n        if(R < l || r < L){\n            return 0;\n        }\n        if(L <= l && r <= R){\n            return tree[node];\n        }\n        int mid = (l + r) / 2;\n        return max(query(2 * node + 1, l, mid, L, R),\n                   query(2 * node + 2, mid + 1, r, L, R));\n    }\n    \npublic:\n    SegmentTree(const int N): N(N){\n        int minLeaves = 1;\n        while(minLeaves < N){\n            minLeaves *= 2;\n        }\n        tree.resize(2 * minLeaves, 0);\n    }\n    \n    void update(int pos, int val){\n        update(0, 0, N - 1, pos, val);\n    }\n    \n    int query(const int L, const int R){\n        if(L > R){\n            return 0;\n        }\n        return query(0, 0, N - 1, L, R);\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        const int Q = queries.size();\n        \n        int maxVal = 0;\n        for(int i = 0; i < Q; ++i){\n            maxVal = max(maxVal, queries[i][1]);\n        }\n        \n        \n        const int N = maxVal + 5;\n        \n        DSU dsu(N);\n        SegmentTree tree(N);\n        vector<int> a(N, 0);\n        for(const vector<int>& V: queries){\n            if(V[0] == 1){\n                a[V[1]] = 1;\n            }\n        }\n        \n        a[0] = 1;\n        for(int x = 1; x < N; ++x){\n            if(a[x - 1] == 0 && a[x] == 0){\n                dsu.join(x - 1, x);\n            }\n        }\n        \n        for(int x = 1; x < N; ++x){\n            if(a[x] == 0){\n                tree.update(dsu.getR(x), dsu.getSize(x));\n            }\n        }\n        \n        vector<bool> res;\n        for(int i = Q - 1; i >= 0; --i){\n            int qType = queries[i][0];\n            int x = queries[i][1];\n            \n            if(qType == 1){\n                if(x == 0){\n                    continue;\n                }\n                a[x] = 0;\n                if(x - 1 > 0 && a[x - 1] == 0){\n                    dsu.join(x - 1, x);\n                }\n                if(x + 1 < N && a[x + 1] == 0){\n                    dsu.join(x, x + 1);\n                }\n                tree.update(dsu.getR(x), dsu.getSize(x));\n            }else{\n                int maxSize = 0;\n                if(a[x] == 0){\n                    const int LIMIT = dsu.getL(x);\n                    /*\n                    for(int j = 0; j < LIMIT; ++j){\n                        if(a[j] == 0){\n                            maxSize = max(maxSize, dsu.getSize(j));\n                        }\n                    }\n                    */\n                    maxSize = max(maxSize, tree.query(0, LIMIT - 1));\n                    maxSize = max(maxSize, dsu.getSize(x) - (dsu.getR(x) - x) - 1);\n                }else{\n                    /*\n                    for(int j = 0; j < x; ++j){\n                        if(a[j] == 0){\n                            maxSize = max(maxSize, dsu.getSize(j));\n                        }\n                    }\n                    */\n                    maxSize = max(maxSize, tree.query(0, x));\n                }\n                \n                //cout << maxSize << endl;\n                \n                int sz = queries[i].back();\n                res.push_back((bool)(maxSize + 1 >= sz));\n            }\n        }\n        \n        reverse(res.begin(), res.end());\n        \n        return res;\n    }\n};",
    "submit_ts": 1716652523.0
}