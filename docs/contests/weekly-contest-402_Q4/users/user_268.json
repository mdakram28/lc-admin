{
    "username": "ritik_369",
    "submission": "\n\nint fun(int a , int b)\n{\n   return a + b ;   \n}\n\nstruct segment_tree\n{\n   vector<int>tree;\n\n   int siz,inv;\n   segment_tree(int siz)\n   {\n      inv = 0 ; \n      tree=vector<int>(4*siz+10,inv);\n      this->siz=siz;\n   }\n   void upd(int idx,int val,int node,int from,int to)\n   {\n      if(!(from<=idx and idx<=to))return ;\n      if(from==to)\n      {\n         tree[node]=val;\n         return ;\n      }\n      int mid=(from+to)/2;\n      upd(idx,val,node*2,from,mid);\n      upd(idx,val,1+node*2,mid+1,to);\n      tree[node]=fun(tree[node*2],tree[node*2+1]);\n   }\n\n   int qry(int str,int ed,int node,int from,int to)\n   {\n      if(ed<from or to<str)return inv;\n      if(str<=from and to<=ed)return tree[node];\n      int mid=(from+to)/2;\n      return fun(qry(str,ed,node*2,from,mid),qry(str,ed,1+node*2,mid+1,to));\n   }\n\n   void update(int idx,int val)\n   {\n      upd(idx,val,1,0,siz+1);\n   }\n   int query(int from,int to)\n   {\n      return qry(from,to,1,0,siz+1);\n   }\n};\n\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) \n    {\n      int n = nums.size() ; \n      segment_tree seg(n + 2) ; \n      for(int i = 1 ; i < n - 1 ; i += 1)\n      {\n         if(nums[i]>nums[i-1] and nums[i] > nums[i + 1])\n            seg.update(i , 1) ; \n      }\n      vector < int > vec ; \n      for(auto  & v : queries)\n      {\n         int t = v[0] ; \n         int l = v[1] , r = v[2]; \n         if(t == 1)\n         {\n            int ans = seg.query(l , r) ; \n            if(l == r)\n               ans -= seg.query(l , l) ; \n            else\n               ans -= (seg.query(l , l) + seg.query(r , r)) ;  \n            vec.push_back(ans) ; \n         }\n         else\n         {\n            int l1 = l ; \n            nums[l] = r ;  \n            for(int l = max(1, l1-3) ; l <= min(n-2 , l1 + 3) ; l ++ ) \n            {\n               if(l != 0 and l != n-1)\n                  seg.update(l , (nums[l] > nums[l-1]) and (nums[l] > nums[l + 1])) ; \n            }\n         }\n      }\n      return vec ; \n \n    }\n};",
    "submit_ts": 1718506993.0
}