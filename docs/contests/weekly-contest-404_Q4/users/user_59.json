{
    "username": "mikazuki4712",
    "submission": "class Solution {\npublic:\n    void dfs(int p, int u, vector<vector<int>> &graph, vector<int> &d) {\n        for (int v : graph[u]) {\n            if (v == p) continue;\n            d[v] = d[u] + 1;\n            dfs(u, v, graph, d);\n        }\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1; \n        int m = edges2.size() + 1;\n\n        vector<int> d1(n, 0);\n        vector<int> d2(m, 0);    \n\n        vector<vector<int>> graph1(n);\n        for (const auto &edge : edges1) {\n            graph1[edge[0]].push_back(edge[1]);\n            graph1[edge[1]].push_back(edge[0]);\n        }\n        \n        vector<vector<int>> graph2(m);\n        for (const auto &edge : edges2) {\n            graph2[edge[0]].push_back(edge[1]);\n            graph2[edge[1]].push_back(edge[0]);\n        }\n\n        dfs(-1, 0, graph1, d1);\n        int u = max_element(d1.begin(), d1.end()) - d1.begin();\n        d1[u] = 0;\n        dfs(-1, u, graph1, d1);\n        \n        int res1 = *max_element(d1.begin(), d1.end());\n\n        dfs(-1, 0, graph2, d2);\n        u = max_element(d2.begin(), d2.end()) - d2.begin();\n        d2[u] = 0;\n        dfs(-1, u, graph2, d2);\n\n        int res2 = *max_element(d2.begin(), d2.end());\n\n        int ans = max({res1, res2, (res1 + 1) / 2 + (res2 + 1) / 2 + 1});\n\n        return ans;\n    }\n};",
    "submit_ts": 1719716880.0
}