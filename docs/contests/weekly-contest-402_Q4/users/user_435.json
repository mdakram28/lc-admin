{
    "username": "somanaik",
    "submission": "#include <bits/stdc++.h>\n\n#define all(v) v.begin(), v.end()\n#define gcd(a, b) __gcd(a, b)\n#define sz(x) (int)(x.size())\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef vector<ll> vlong;\ntypedef vector<vlong> vvlong;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\n\ntemplate<class T, class U> class segtree {\n    private:\n        int _n, _sn, _log;\n        vector<T> _st;\n\n        T _ifunc() const {\n            return 0;\n        }\n\n        T _cfunc(int i, U u, T &v) const {\n            return u;\n        }\n\n        T _mfunc(T &v1, T &v2) const {\n            return v1 + v2;\n        }\n\n        void _set(int _s, int _e, int _p, int _i, U& _v) {\n            if(_s >= _e) _st[_p] = _cfunc(_i, _v, _st[_p]);\n            else {\n                int _m = (_s + _e) >> 1;\n                if(_i <= _m) _set(_s, _m, _p << 1, _i, _v);\n                else _set(_m + 1, _e, _p << 1 | 1, _i, _v);\n                _st[_p] = _mfunc(_st[_p << 1], _st[_p << 1 | 1]);\n            }\n        }\n\n        T _get(int _s, int _e, int _p, int _l, int _r) const {\n            if(_l <= _s && _e <= _r) return _st[_p];\n            int _m = (_s + _e) >> 1;\n            if(_r <= _m) return _get(_s, _m, _p << 1, _l, _r);\n            if(_l > _m) return _get(_m + 1, _e, _p << 1 | 1, _l, _r);\n            T _v1 = _get(_s, _m, _p << 1, _l, _m);\n            T _v2 = _get(_m + 1, _e, _p << 1 | 1, _m + 1, _r);\n            return _mfunc(_v1, _v2);\n        }\n\n        void _init() {\n            _log = 0;\n            while((1ll << _log) < _n) _log++;\n            _sn = (1 << _log);\n            _st = vector<T>(_sn << 1, _ifunc());\n        }\n\n        void _build(int _s, int _e, int _p, const vector<U>& _v) {\n            if(_s >= _e) _st[_p] = _cfunc(_s, _v[_s], _st[_p]);\n            else {\n                int _m = (_s + _e) >> 1;\n                _build(_s, _m, _p << 1, _v);\n                _build(_m + 1, _e, _p << 1 | 1, _v);\n                _st[_p] = _mfunc(_st[_p << 1], _st[_p << 1 | 1]);\n            }\n        }\n\n    public:\n        segtree() : segtree(0) {}\n        segtree(int _nn) : _n(_nn) {\n            _init();\n        }\n        segtree(const vector<U> &_v) : _n(sz(_v)) {\n            _init();\n            _build(0, _n - 1, 1, _v);\n        }\n\n        T operator [](int _p) const {\n            assert(0 < _p && _p < (_sn << 1));\n            return _st[_p];\n        }\n\n        // set arr[p] = v\n        void set(int _p, U& _v) {\n            assert(0 <= _p && _p < _n);\n            _set(0, _n - 1, 1, _p, _v);\n        }\n\n        T get(int _l, int _r) const {\n            assert(0 <= _l && _l <= _r && _r < _n);\n            return _get(0, _n - 1, 1, _l, _r);\n        }\n\n        T get_all() const {\n            return _st[1];\n        }\n\n        void build(const vector<U>& _v) {\n            _n = _v.size();\n            _init();\n            _build(0, _n - 1, 1, _v);\n        }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vint peaks(n);\n        auto is_peak = [&](int i) {\n            if(i == 0) {\n                if(i+1 < n) return nums[i] > nums[i+1];\n                return false;\n            }\n            if(i == n - 1) {\n                return nums[i] > nums[i - 1];\n            }\n            return nums[i - 1] < nums[i] && nums[i] > nums[i + 1];\n        };\n\n        for(int i = 0; i < n; i++) {\n            peaks[i] = is_peak(i);\n        }\n\n        segtree<int, int> st(peaks);\n        vint ans;\n        for(auto &q : queries) {\n            int t = q.front();\n            int l = q[1], r = q[2];\n            if(t == 1) {\n                // l--,r--;\n                int cnt = st.get(l, r);\n                cnt -= peaks[l];\n                if(l!=r) cnt -= peaks[r];\n                ans.push_back(cnt);\n            } else {\n                // l--;\n                nums[l] = r;\n                peaks[l] = is_peak(l);\n                st.set(l, peaks[l]);\n                if(l) {\n                    peaks[l-1] = is_peak(l-1);\n                    st.set(l-1, peaks[l-1]);\n                }\n                if(l+1 < n) {\n                    peaks[l+1] = is_peak(l+1);\n                    st.set(l+1, peaks[l+1]);\n                }\n            }\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": 1718506348.0
}