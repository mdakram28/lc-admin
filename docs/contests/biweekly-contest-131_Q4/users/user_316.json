{
    "username": "keysersoze29",
    "submission": "void updateRangeUtil(int si, int ss, int se, int us,int ue, int diff,int *tree,int *lazy){\n    if (lazy[si] != 0) {\n        tree[si] += lazy[si];\n        if (ss != se) {\n            lazy[si * 2 + 1] += lazy[si];\n            lazy[si * 2 + 2] += lazy[si];\n        }\n        lazy[si] = 0;\n    }\n    if (ss > se || ss > ue || se < us)\n        return;\n    if (ss >= us && se <= ue) {\n        tree[si] += diff;\n        if (ss != se) {\n            lazy[si * 2 + 1] += diff;\n            lazy[si * 2 + 2] += diff;\n        }\n        return;\n    }\n    int mid = (ss + se) / 2;\n    updateRangeUtil(si * 2 + 1, ss, mid, us, ue, diff,tree,lazy);\n    updateRangeUtil(si * 2 + 2, mid + 1, se, us, ue, diff, tree, lazy);\n    tree[si] = max(tree[si * 2 + 1], tree[si * 2 + 2]);\n}\n\nvoid updateRange(int n, int us, int ue, int diff, int *tree,int *lazy)\n{\n    updateRangeUtil(0, 0, n - 1, us, ue, diff, tree, lazy);\n}\nint getMaxUtil(int ss, int se, int qs, int qe, int si,int *tree,int *lazy){\n    if (lazy[si] != 0) {\n        tree[si] += lazy[si];\n        if (ss != se) {\n            lazy[si * 2 + 1] += lazy[si];\n            lazy[si * 2 + 2] += lazy[si];\n        }\n        lazy[si] = 0;\n    }\n    if (ss > se || ss > qe || se < qs)\n        return 0;\n    if (ss >= qs && se <= qe)\n        return tree[si];\n    int mid = (ss + se) / 2;\n    return max(getMaxUtil(ss, mid, qs, qe, 2 * si + 1, tree, lazy),getMaxUtil(mid + 1, se, qs, qe, 2 * si + 2, tree, lazy));\n}\n\nint getMax(int n, int qs, int qe, int *tree,int *lazy){\n\n    return getMaxUtil(0, n - 1, qs, qe, 0, tree, lazy);\n}\n\nvoid constructSTUtil(int arr[], int ss, int se, int si, int *tree,int *lazy){\n    if (ss > se)\n        return;\n    if (ss == se) {\n        tree[si] = arr[ss];\n        return;\n    }\n    int mid = (ss + se) / 2;\n    constructSTUtil(arr, ss, mid, si * 2 + 1, tree, lazy);\n    constructSTUtil(arr, mid + 1, se, si * 2 + 2, tree, lazy);\n\n    tree[si] = max(tree[si * 2 + 1], tree[si * 2 + 2]);\n}\n\nvoid constructST(int arr[], int n, int *tree,int *lazy)\n{\n    // Fill the allocated memory st\n    constructSTUtil(arr, 0, n - 1, 0, tree, lazy);\n}\n\n/*\n[[1,2],[2,3,3],[2,3,1],[2,2,2]]\n[[1,7],[2,7,6],[1,2],[2,7,5],[2,7,6]]\n[[2,1,1]]\n[[1,4],[2,1,2]]\n*/\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& q) {\n\n        int n=q.size();\n        int szz=3*n;\n        int sz=min(szz, 50000)+1;\n\n        bool b[sz];\n        int a[sz];\n        memset(b,0,sizeof(b));\n        memset(a,0,sizeof(a));\n\n        set<int>s;\n        s.insert(0);\n        for(auto i:q){\n            int type = i[0];\n            int x= i[1];\n            if(type==1){\n                s.insert(x);\n                b[x]=true;\n            }\n        }\n\n        int val=1;\n        for(int i=1;i<sz;i++){\n            a[i]=val;\n            if(b[i]){\n                val=1;\n            }else{\n                val++;\n            }\n        }\n\n        int tree[4*sz];\n        int lazy[4*sz];\n        memset(tree, 0,sizeof(tree));\n        memset(lazy, 0,sizeof(lazy));\n\n        constructST(a, sz, tree, lazy);\n        vector<bool>ans;\n\n        for(int i=n-1;i>=0;i--){\n            int type = q[i][0];\n            int x= q[i][1];\n            if(type==1){\n                auto it=s.upper_bound(x);\n                int end = sz-1;\n                if(it!=s.end()){\n                    end=*it;\n                }\n                it--;\n                it--;\n                int diff = x-(*it);\n                updateRange(sz, x+1, end, diff, tree, lazy);\n                s.erase(x);\n            }else{\n                int len=q[i][2];\n                int maxi = getMax(sz, 0, x, tree, lazy);\n                ans.push_back(maxi>=len);\n            }\n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n",
    "submit_ts": 1716651756.0
}