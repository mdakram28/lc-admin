{
    "username": "The_2nd_Derivative",
    "submission": "\n#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)\n// trace std::pair\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){\n    return os<<\"{\"<<P.first<<\":\"<<P.second<<\"}\";\n}\n// trace std::vector\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){\n    os<<\"[ \";for(auto v:V)os<<v<<\" \";return os<<\"]\";\n}\n// trace std::map;\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {\n    os<<\"[ \";for(auto& P : MP) os<<P<<\" \";return os<<\"]\";\n}\n// trace unordred_std::map\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {\n    os<<\"[ \";for(auto& P : MP) os<<P<<\" \";return os<<\"]\";\n}\n// trace std::set\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){\n    os<<\"[ \";for(auto s:S)os<<s<<\" \";return os<<\"]\";\n}\n// trace std::unordered_set\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){\n    os<<\"[ \";for(auto s:S)os<<s<<\" \";return os<<\"]\";\n}\n// std::stack FUN\ntemplate<class T> void F_Stack(std::stack<T> st, std::string& cont) { \n    if(st.empty()) return;\n    T mem=st.top();st.pop();F_Stack(st,cont);cont+=\" \"+to_string(mem);  \n}\n// trace std::stack                                                  \ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {\n    os<<\"[\";std::string cont=\"\";F_Stack(st,cont);return os<<cont<<\" ]\";\n}\n// track std::queue\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {\n    os<<\"[ \";while(!q.empty()) os<<q.front()<<\" \",q.pop();return os<<\"]\";\n}\n\n// for last arg.\ntemplate<typename Arg1>\nvoid __f(const char* name,Arg1&& arg1){\n    std::cout<<name<<\" : \"<<arg1<<std::endl;\n}\n// for variable arg\ntemplate <typename Arg1,typename... Args>\nvoid __f(const char* names,Arg1&& arg1,Args&&... args){\n    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<\" : \"<<arg1<<\" | \";__f(comma+1,args...);\n}\n\n// dbg std::array\ntemplate<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){\n    os<<\"[ \";for(auto v:V)os<<v<<\" \";return os<<\"]\";\n}\n\n// X.find_by_order(k) return iterator to kth element. 0 indexed.\n// X.order_of_key(k) returns count of elements strictly less than k.\n\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// template <class T>\n// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define sz(x) ((ll)(x).size())\n#define nl '\\n'\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n \nusing ll = long long int;\nusing pii = pair<ll,ll>;\nusing mii = map<ll,ll>;\nusing umii = unordered_map<ll,ll>;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvii = vector<vpii>;\n\ntemplate<class T> bool chmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool chmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nconst ll INF = 1e18;\nconst ll N = 1e5+5;\n\n#define dbg(...)\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& a, int k) {\n        ll n = sz(a);\n        vvi cnt(n, vi(32, 0));\n        for(int i=0;i<n;i++){\n            for(int j=0;j<32;j++){\n                if(i>0)\n                    cnt[i][j]+=cnt[i-1][j];\n                if(a[i]>>j&1)\n                    cnt[i][j]++;\n            }\n        }\n        auto get=[&](ll l,ll r){\n            ll x=0;\n            for(int j=0;j<32;j++){\n                ll cur=cnt[r][j];\n                if(l>0)\n                    cur-=cnt[l-1][j];\n                if(cur==(r-l+1)){\n                    x|=(1ll<<j);\n                }\n            }\n            return x;\n        };\n        ll ans=0;\n        for(int i=0;i<n;i++){\n            if(a[i]<k){\n                continue;\n            }\n            ll ans1=-1,ans2=-1;\n            if(a[i]==k){\n                ans1=i+1;\n            }\n            ll low=0,high=i;\n            while(low<=high){\n                ll mid=(low+high)/2;\n                ll val=get(mid,i);\n                if(val>=k+1){\n                    ans1=mid;\n                    high=mid-1;\n                }\n                else{\n                    low=mid+1;\n                }\n            }\n            low=0,high=i;\n            while(low<=high){\n                ll mid=(low+high)/2;\n                ll val=get(mid,i);\n                if(val>=k){\n                    ans2=mid;\n                    high=mid-1;\n                }\n                else{\n                    low=mid+1;\n                }\n            }\n            dbg(i,ans1,ans2);\n            if(ans1!=-1&&ans2!=-1){\n                ans+=(ans1-ans2);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720281085",
    "subm_id": "1311812595"
}