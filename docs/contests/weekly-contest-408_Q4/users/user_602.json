{
    "username": "muntasir_120",
    "submission": "def isInside(circle, x, y):\n  cx, cy, r = circle\n  return ((x-cx)**2 + (y - cy)**2) <= r*r\n\ndef connected(c1, c2):\n  #print('checking',c1,c2)\n  c1x, c1y, r1 = c1\n  c2x, c2y, r2 = c2\n  dx = c1x - c2x\n  dy = c1y - c2y\n  r = r1 + r2\n  return dx*dx + dy*dy <= r*r\n\n\ndef createAdjList(circles):\n  N = len(circles)\n  adj = [list() for _ in range(N)]\n  for u in range(N):\n    for v in range(u+1, N):\n      if connected(circles[u], circles[v]):\n        adj[u].append(v)\n        adj[v].append(u)\n  return adj\n\n\ndef dfs(node, color, graph, comp):\n  if color[node] != -1:\n    return\n  else:\n    color[node] = comp\n    for next_node in graph[node]:\n      dfs(next_node, color, graph, comp)\n\nclass Solution:\n  def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n    for c in circles:\n      if isInside(c, X,Y) or isInside(c, 0, 0):\n        return False\n    N = len(circles)\n    G = createAdjList(circles)\n    color = [-1 for _ in range(N)]\n    cur = 0\n    #print(G)\n    for node in range(N):\n      if color[node] == -1:\n        dfs(node, color, G, cur)\n        cur += 1\n    dimensions = defaultdict(lambda:(10**9,10**9,-10**9, -10**9))\n    #print(color)\n    for node in range(N):\n      cur_color = color[node]\n      min_x, min_y, max_x, max_y = dimensions[cur_color]\n\n      x,y,r = circles[node]\n      #print(node,x,y)\n      #print(x-r,y-r)\n      #print(x+r,y+r)\n      min_x = min(min_x, x-r)\n      min_y = min(min_y, y-r)\n      max_x = max(max_x, x+r)\n      max_y = max(max_y, y+r)\n      dimensions[cur_color] = (min_x, min_y, max_x, max_y)\n    #print(dimensions)\n    for min_x, min_y, max_x, max_y in dimensions.values():\n      if (min_x <= 0 and max_x >= X) or (min_y <= 0 and max_y >= Y):\n        return False\n      elif (min_x <=0 and min_y <=0) or (max_x >= X and max_y >= Y):\n        return False  \n    return True\n    \n        ",
    "submit_ts": "1722137408",
    "subm_id": "1335762903"
}