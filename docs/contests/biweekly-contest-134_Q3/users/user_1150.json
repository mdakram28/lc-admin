{
    "username": "rajukumar1972003",
    "submission": "class Solution { \npublic: \n    int numberOfAlternatingGroups(vector<int>& colors, int k) { \n        int sze = colors.size(); \n        int cnt = 0; \n \n        if (k == 1) { \n            // Every single tile is an alternating group by itself \n            return sze; \n        } \n \n        int alt = 1; \n        int i = 1; \n        while (i < sze + k - 1) { \n            int crrnt = i; \n            int prv = i - 1; \n \n            // Handle circular indexing \n            if (crrnt >= sze) { \n                crrnt-= sze; \n            } \n            if (prv >= sze) { \n                prv -= sze; \n            } \n \n            if (colors[crrnt] != colors[prv]) { \n                ++alt; \n            } else { \n                alt = 1; \n            } \n \n            // Check if we have a valid alternating group of length k \n            if (alt >= k) { \n                ++cnt; \n            } \n \n            i++; \n        } \n \n        return cnt; \n    } \n};",
    "submit_ts": "1720279609",
    "subm_id": "1311758077"
}