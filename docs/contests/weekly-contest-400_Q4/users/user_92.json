{
    "username": "WORTH_IT",
    "submission": "class Solution {\n    public int minimumDifference(int[] nums, int k) {\n        int n = nums.length, ans = Integer.MAX_VALUE;\n        IntSparseTable st = new IntSparseTable(nums, (asd, jkl) -> asd & jkl);\n        for (int i = 0; i < n; i++) {\n            int l = i;\n            int j = BS.firstTrue(i, n - 1, new IntPredicate() {\n                @Override\n                public boolean test(int m) {\n                    return st.query(l, m) <= k;\n                }\n            });\n\n            if (j < n)\n                ans = Math.min(ans, Math.abs(k - st.query(i, j)));\n            if (j - 1 >= i)\n                ans = Math.min(ans, Math.abs(k - st.query(i, j - 1)));\n        }\n        \n        return ans;\n    }\n}\n\nclass IntSparseTable {\n    private static int highestBit(int x) {\n        return x == 0 ? -1 : 31 - Integer.numberOfLeadingZeros(x);\n    }\n\n    private int[][] rangeValue;\n    private final java.util.function.IntBinaryOperator operator;\n\n    public IntSparseTable(int[] values, java.util.function.IntBinaryOperator operator) {\n        this.operator = operator;\n        build(values);\n    }\n\n    private void build(int[] values) {\n        int n = values.length;\n        int levels = highestBit(n) + 1;\n\n        rangeValue = new int[levels][];\n        rangeValue[0] = new int[n];\n        System.arraycopy(values, 0, rangeValue[0], 0, n);\n\n        for (int k = 1; k < levels; k++) {\n            rangeValue[k] = new int[n - (1 << k) + 1];\n            for (int i = 0; i <= n - (1 << k); i++)\n                rangeValue[k][i] = operator.applyAsInt(rangeValue[k - 1][i], rangeValue[k - 1][i + (1 << (k - 1))]);\n        }\n    }\n\n    public int query(int a, int b) {\n        int level = highestBit(b - a + 1);\n        return operator.applyAsInt(rangeValue[level][a], rangeValue[level][b - (1 << level) + 1]);\n    }\n}\n\nclass BS {\n\n    public static int firstTrue(int l, int r, java.util.function.IntPredicate predicate) {\n        r++;\n        while (l < r) {\n            int m = l + (r - l) / 2;\n\n            if (predicate.test(m)) r = m;\n            else l = m + 1;\n        }\n\n        return r;\n    }\n\n    public static long firstTrue(long l, long r, java.util.function.LongPredicate predicate) {\n        r++;\n        while (l < r) {\n            long m = l + (r - l) / 2;\n\n            if (predicate.test(m)) r = m;\n            else l = m + 1;\n        }\n\n        return r;\n    }\n\n    public static int lastTrue(int l, int r, java.util.function.IntPredicate predicate) {\n        return lastFalse(l, r, predicate.negate());\n    }\n\n    public static long lastTrue(long l, long r, java.util.function.LongPredicate predicate) {\n        return lastFalse(l, r, predicate.negate());\n    }\n\n    public static int firstFalse(int l, int r, java.util.function.IntPredicate predicate) {\n        return firstTrue(l, r, predicate.negate());\n    }\n\n    public static long firstFalse(long l, long r, java.util.function.LongPredicate predicate) {\n        return firstTrue(l, r, predicate.negate());\n    }\n\n    public static int lastFalse(int l, int r, java.util.function.IntPredicate predicate) {\n        return firstTrue(l, r, predicate) - 1;\n    }\n\n    public static long lastFalse(long l, long r, java.util.function.LongPredicate predicate) {\n        return firstTrue(l, r, predicate) - 1;\n    }\n\n\n    public static int lowerBound(int[] a, int l, int r, int x) {\n        return firstTrue(l, r, (java.util.function.IntPredicate) m -> a[m] >= x);\n    }\n\n    public static int lowerBound(int[] a, int x) {\n        return lowerBound(a, 0, a.length - 1, x);\n    }\n\n    public static int lowerBound(long[] a, int l, int r, long x) {\n        return firstTrue(l, r, (java.util.function.IntPredicate) m -> a[m] >= x);\n    }\n\n    public static int lowerBound(long[] a, long x) {\n        return lowerBound(a, 0, a.length - 1, x);\n    }\n\n    public static <T extends Comparable<T>> int lowerBound(T[] a, int l, int r, T x) {\n        return lowerBound(a, l, r, x, T::compareTo);\n    }\n\n    public static <T extends Comparable<T>> int lowerBound(T[] a, T x) {\n        return lowerBound(a, 0, a.length - 1, x);\n    }\n\n    public static <T> int lowerBound(T[] a, int l, int r, T x, java.util.Comparator<T> comparator) {\n        return firstTrue(l, r, (java.util.function.IntPredicate) m -> comparator.compare(a[m], x) >= 0);\n    }\n\n    public static <T> int lowerBound(T[] a, T x, java.util.Comparator<T> comparator) {\n        return lowerBound(a, 0, a.length - 1, x, comparator);\n    }\n\n\n    public static int upperBound(int[] a, int l, int r, int x) {\n        return firstTrue(l, r, (java.util.function.IntPredicate) m -> a[m] > x);\n    }\n\n    public static int upperBound(int[] a, int x) {\n        return upperBound(a, 0, a.length - 1, x);\n    }\n\n    public static int upperBound(long[] a, int l, int r, long x) {\n        return firstTrue(l, r, (java.util.function.IntPredicate) m -> a[m] > x);\n    }\n\n    public static int upperBound(long[] a, long x) {\n        return upperBound(a, 0, a.length - 1, x);\n    }\n\n    public static <T extends Comparable<T>> int upperBound(T[] a, int l, int r, T x) {\n        return upperBound(a, l, r, x, T::compareTo);\n    }\n\n    public static <T extends Comparable<T>> int upperBound(T[] a, T x) {\n        return upperBound(a, 0, a.length - 1, x);\n    }\n\n    public static <T> int upperBound(T[] a, int l, int r, T x, java.util.Comparator<T> comparator) {\n        return firstTrue(l, r, (java.util.function.IntPredicate) m -> comparator.compare(a[m], x) > 0);\n    }\n\n    public static <T> int upperBound(T[] a, T x, java.util.Comparator<T> comparator) {\n        return upperBound(a, 0, a.length - 1, x, comparator);\n    }\n}",
    "submit_ts": "1717297438",
    "subm_id": "1274742531"
}