{
    "username": "Sabbi_coder",
    "submission": "class Solution {\npublic:\n    bool static compare(pair<int,int>&p1, pair<int,int>&p2){\n        return p1.second<=p2.second ||  ((p1.second==p2.second)&&(p1.first<p2.first));  \n    }\n    int minimumDistance(vector<vector<int>>& points) {\n        vector<pair<int,int>>sums;\n        vector<pair<int,int>>differences;\n        int cnt = 0;\n        for(auto c: points){\n            sums.push_back({cnt,c[0]+c[1]});\n            differences.push_back({cnt,c[0]-c[1]});\n        cnt++;\n        }\n        int ans = INT_MAX;\n        sort(sums.begin(),sums.end(),compare);\n        sort(differences.begin(),differences.end(),compare);\n        int sz = points.size();\n        for(int i=0;i<sz;i++){\n            // do not consider point i;\n            int c1=sums[0].second;\n            int c2=sums[sz-1].second;\n            if(i==sums[0].first){\n                c1 = sums[1].second;\n            }\n            if(i==sums[sz-1].first){\n                c2 = sums[sz-2].second;\n            }\n            \n            int d1=differences[0].second;\n            int d2=differences[sz-1].second;\n            if(i==differences[0].first){\n                d1 = differences[1].second;\n            }\n            if(i==differences[sz-1].first){\n                d2 = differences[sz-2].second;\n            }\n            ans = min(ans, max(c2-c1, d2-d1));\n            // when considering sums, if point i is coming at the end, then take the one before else take the one just after it. \n            // same for differences as above \n            // track the minimum possible max value\n        }\n        return ans;\n    }\n};"
}