{
    "username": "fastleopard",
    "submission": "class Solution {\nprivate:\n    static constexpr int LARGE_VAL = INT_MAX;\n    using ll = long long;\n    \n    struct TrieNode {\n        TrieNode() = default;\n\n        TrieNode * children[26] = {nullptr};\n        ll cost = LARGE_VAL;\n    };\n    \n    void add(TrieNode *root, const std::string &s);\n\n    bool find(TrieNode *root, const std::string &s);\n    \n    void add(TrieNode *root, const std::string &s, ll cost) {\n        TrieNode *node = root;\n        for(const char c : s) {\n            int idx = c-'a';\n            if(!node->children[idx]) node->children[idx] = new TrieNode();\n            node = node->children[idx];\n        }\n        node->cost = min(node->cost, cost);\n    }\n    \n    // Use long long.\n    ll cost(TrieNode *root, const string &target, int index, vector<ll> &dp) {\n        // There is a node and there is a char at this node.\n        // We immediately check for a cost of this char.\n        // And then we try to extend the string and go down.\n        int idx = target[index]-'a';\n        if(!root->children[idx]) {\n            return LARGE_VAL;\n        }\n        \n        auto *next_node = root->children[idx];\n        ll min_cost = next_node->cost;\n        // cout<<\"index: \"<<index<<\", initial min cost: \"<<min_cost<<endl;\n        if(index < dp.size() - 1) {\n            min_cost += dp[index+1];\n            \n            min_cost = min(min_cost, cost(next_node, target, index+1, dp));\n        }\n        \n        return min_cost;\n    }\n\n    \npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        // This is a string matching algorithm.\n        // We need to know which strings from the dictionary can be inserted now.\n        // This may be an answer search.\n        // But may be a dp too.\n        // At index i, what is the minimum cost to construct remaining part of the string where at index i some string starts.\n        // Does this sound like a quadratic algorithm?\n        // We try some string. And then we look up an answer.\n        // We can store strings from a dictionary in a trie.\n        // When we areach the leaf node, we jut look at our dp.\n        // Let's try this and then see if I discover that this solution is not efficient, I might need to look at other algorithms.\n        TrieNode* root = new TrieNode();\n        for(int i = 0; i<costs.size(); ++i) {\n            add(root, words[i], costs[i]);\n        }\n        \n        vector<ll> dp(target.size(), LARGE_VAL);\n        for(int i = target.size() - 1; i>=0; --i) {\n            ll c = cost(root, target, i, dp);\n            dp[i] = c;\n        }\n        \n        int res = dp[0];\n        if(res == LARGE_VAL) return -1;\n        return res;\n    }\n};",
    "submit_ts": "1720322552",
    "subm_id": "1312352951"
}