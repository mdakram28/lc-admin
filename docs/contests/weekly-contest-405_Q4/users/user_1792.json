{
    "username": "lightning_aj",
    "submission": "class node{\n    public:\n    \n    bool end;\n    int cost;\n    unordered_map<char,node*> child;\n    \n    node(){\n        this->end = false;\n        this->cost = INT_MAX;\n        \n        // for(int i = 0;i<26;i++){\n        //     child.push_back(NULL);\n        // }\n    }\n};\n\nclass trie{\n    public:\n    \n    node* root;\n    \n    trie(){\n        this->root = new  node();\n    }\n    \n    void insert(string &str,int cost){\n        node* curr = root;\n        int i = 0;\n        while(i<str.size()){\n//             if(curr->child[str[i]-'a'] == NULL){\n//                 curr->child[str[i]-'a'] = new node();\n//             }\n            \n//             curr = curr->child[str[i]-'a'];\n//             i++;\n            \n            if(curr->child.find(str[i]) == curr->child.end()){\n                curr->child[str[i]] = new node();\n                \n            }\n            \n            curr = curr->child[str[i]];\n            i++;\n        }\n        \n        curr->end = true;\n        curr->cost = min(cost,curr->cost);\n        \n        return ;\n    }\n    \n    int solve(string &target,int i,vector<int>&dp){\n        //base\n        if(i>=target.size()){\n            //have reached the end so \n            return 0;\n        }\n        if(dp[i]!=-1){\n            return dp[i];\n        }\n        //recursive\n        node* curr = root;\n        int j = i;\n        int miniCost = INT_MAX;\n        while(j<target.size()){\n            \n//             if(curr->child[target[j]-'a']!=NULL){\n//                 curr = curr->child[target[j]-'a'];\n//                 j++;\n                \n//                 if(curr->end){\n//                     //means this is one of the end and i have two options here \n//                     //either to break the word here and go ahead\n//                     int cost = solve(target,j,dp);\n//                     if(cost!=INT_MAX){\n//                         cost += curr->cost;\n//                     }\n//                     miniCost = min(miniCost,cost);\n                    \n//                     //or to continue;\n//                 }\n//             }\n//             else{\n//                 break;\n//             }\n            \n            if(curr->child.find(target[j])!=curr->child.end()){\n                curr = curr->child[target[j]];\n                j++;\n                \n                if(curr->end){\n                    //means this is one of the end and i have two options here \n                    //either to break the word here and go ahead\n                    int cost = solve(target,j,dp);\n                    if(cost!=INT_MAX){\n                        cost += curr->cost;\n                    }\n                    miniCost = min(miniCost,cost);\n                    \n                    //or to continue;\n                }\n            }\n            else{\n                break;\n            }\n        }\n\n        return dp[i] = miniCost;\n    }\n};\n\nclass Solution {\npublic:\n    // vector<int> dp;\n    \n    // Solution(){\n    //     dp.resize(1e5+1,-1);\n    // }\n    \n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        //first let's make a trie bro and then proceed man\n        // fill(dp.begin(),dp.end(),-1);\n        trie t;\n        for(int i = 0;i<words.size();i++){\n            t.insert(words[i],costs[i]);\n        }\n        \n        vector<int> dp(target.size()+2,-1);\n        // int ans  = -1;\n        int ans = t.solve(target,0,dp);\n        \n        if(ans==INT_MAX){\n            return -1;\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": "1720324510",
    "subm_id": "1312401285"
}