{
    "username": "giantcheeseguy2",
    "submission": "#pragma GCC optimize(\"O3,unroll-loops\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC target(\"sse4,popcnt,abm,mmx,tune=native\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define pb push_back\n#define ff first\n#define ss second\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pld;\n\nconst int INF = 1e9;\nconst ll LLINF = 1e18;\nconst int MOD = 1e9 + 7;\n\ntemplate<class K> using sset =  tree<K, null_type, less<K>, rb_tree_tag, tree_order_statistics_node_update>;\n\ninline ll ceil0(ll a, ll b) {\n    return a / b + ((a ^ b) > 0 && a % b);\n}\n\ntemplate<class mod>\nstruct Modular {\n\n    using T = typename mod::type;\n    using C = typename mod::cast;\n\n    template<class U>\n    static T fpow(T a, U b){\n        T ret = 1;\n        while(b){\n            if(b%2 == 1) ret = (C)ret*a%mod::mod;\n            a = (C)a*a%mod::mod;\n            b /= 2;\n        }\n        return ret;\n    }\n\n    T val;\n\n    Modular(){\n        val = 0;\n    }\n\n    template<class U>\n    Modular(const U &x){\n        val = x%mod::mod;\n        if(val < 0) val += mod::mod;\n    }\n\n    const T Mod() const { return mod::mod; }\n\n    const T &operator()() const { return val; }\n\n    template<class U>\n    explicit operator U() const { return static_cast<U>(val); } \n\n    Modular operator-(){ return Modular<mod>(-val); }\n\n    Modular &operator+=(const Modular &x){\n        val = (val + x.val)%mod::mod;\n        return *this;\n    }\n\n    Modular &operator-=(const Modular &x){\n        val = (val - x.val + mod::mod)%mod::mod;\n        return *this;\n    }\n\n    Modular &operator*=(const Modular &x){\n        val = (C)val*x.val%mod::mod;\n        return *this;\n    }\n\n    Modular &operator/=(const Modular &x){\n        val = (C)val*fpow(x.val, mod::mod - 2)%mod::mod;\n        return *this;\n    }\n\n    Modular &operator%=(const Modular &x){\n        val = val%x.val;\n        return *this;\n    }\n\n    template<class U>\n    Modular &operator^=(const U &x){\n        assert((\"be careful when raising to a modded power\", typeid(x) != typeid(*this)));\n        val = fpow(val, x);\n        return *this;\n    }\n\n    Modular &operator++(){ return *this += 1; }\n\n    Modular &operator--(){ return *this -= 1; }\n\n    Modular operator++(int){\n        Modular ret = *this;\n        ++*this;\n        return ret;\n    }\n\n    Modular operator--(int){\n        Modular ret = *this;\n        --*this;\n        return ret;\n    }\n\n    friend Modular operator+(const Modular &a, const Modular &b){ return Modular(a.val) += b; }\n\n    friend Modular operator-(const Modular &a, const Modular &b){ return Modular(a.val) -= b; }\n\n    friend Modular operator*(const Modular &a, const Modular &b){ return Modular(a.val) *= b; }\n\n    friend Modular operator/(const Modular &a, const Modular &b){ return Modular(a.val) /= b; }\n\n    friend Modular operator%(const Modular &a, const Modular &b){ return Modular(a.val) %= b; }\n\n    template<class U>\n    friend Modular operator^(const Modular &a, const U &b){ return Modular(a.val) ^= b; }\n\n    bool hasSqrt(){\n        return val == 0 || fpow(val, (mod::mod - 1)/2) == 1;\n    }\n\n    Modular sqrt(){\n        if(val == 0) return 0;\n        if(val == 1) return 1;\n        assert(hasSqrt());\n        Modular r = 1, c = 1, a = 1, b = 1, aa, bb;\n        while(((r*r - val) ^ ((mod::mod - 1)/2)) == 1) r++;\n        Modular mult = r*r - val;\n        T x = (mod::mod + 1)/2;\n        while(x){\n            if(x%2 == 1){\n                aa = c*b*mult + a*r;\n                bb = c*a + r*b;\n                a = aa, b = bb;\n            }\n            aa = c*c*mult + r*r;\n            bb = 2*c*r;\n            r = aa, c = bb;\n            x /= 2;\n        }\n        if(a >= (mod::mod + 1)/2) a *= -1;\n        return a;\n    }\n\n    friend bool operator<(const Modular &a, const Modular &b){ return a.val < b.val; }\n\n    friend bool operator<=(const Modular &a, const Modular &b){ return a.val <= b.val; }\n\n    friend bool operator>(const Modular &a, const Modular &b){ return a.val > b.val; }\n\n    friend bool operator>=(const Modular &a, const Modular &b){ return a.val >= b.val; }\n\n    friend bool operator==(const Modular &a, const Modular &b){ return a.val == b.val; }\n\n    friend bool operator!=(const Modular &a, const Modular &b){ return a.val != b.val; }\n\n    friend ostream &operator<<(ostream &out, Modular x){ return out << x.val; }\n\n    friend istream &operator>>(istream &in, Modular &x){ \n        in >> x.val;\n        x.val = x.val%mod::mod;\n        if(x.val < 0) x.val += mod::mod;\n        return in;\n    }\n\n    string to_string(const Modular&x) { return to_string(x.val); }\n};\n\nstruct Mod { \n    using type = int;\n    using cast = long long;\n    const static type mod = MOD;\n};\n\nusing mint = Modular<Mod>;\n\nclass Solution {\npublic:\n    int countOfPairs(vector<int>& v) {\n        vector<int> nums;\n        nums.pb(INF);\n        int mx = 0;\n        for(int i : v){\n            nums.pb(i);\n            mx = max(mx, i);\n        }\n        int n = nums.size() - 1;\n        mint dp[n + 1][mx + 1];\n        dp[0][0] = 1;\n        for(int i = 1; i <= n; i++){\n            mint pre[nums[i] + 1];\n            for(int j = 0; j <= min(nums[i], nums[i - 1]); j++){\n                int l = j;\n                int r = nums[i - 1] - j;\n                // j >= l\n                // nums[i] - j <= r\n                // j >= nums[i] - r\n                pre[min(nums[i], max(l, nums[i] - r))] += dp[i - 1][j];\n            }\n            for(int j = 1; j <= nums[i]; j++) pre[j] += pre[j - 1];\n            for(int j = 0; j <= nums[i]; j++){\n                dp[i][j] = pre[j];\n            }\n        }\n        mint ret = 0;\n        for(int i = 0; i <= mx; i++) ret += dp[n][i];\n        return (int)ret;\n    }\n};",
    "submit_ts": "1723344032",
    "subm_id": "1351524789"
}