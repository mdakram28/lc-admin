{
    "username": "876pol",
    "submission": "using ll = long long;\nusing pll = pair<ll, ll>;\ntemplate <class T>\nusing vec = vector<T>;\n\n#define FOR(i, s, e) for (ll i = (ll)s; i < (ll)e; i++)\n#define CFOR(i, s, e) for (ll i = (ll)s; i <= (ll)e; i++)\n#define TRAV(a, c) for (const auto &a : c)\n#define dbg(x) cerr << \"ln\" << __LINE__ << \": \" << #x << \" = \" << x << endl\n\nclass Solution {\npublic:\n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vec<vec<int>> graph(n);\n        TRAV(e, edges) {\n            graph[e[0]].push_back(e[1]);\n            graph[e[1]].push_back(e[0]);\n        }\n        vec<multiset<int>> dp(n);\n        function<void(int, int)> dfs1 = [&](ll curr, ll prev) {\n            dp[curr].insert(0);\n            TRAV(e, graph[curr]) {\n                if (e == prev) continue;\n                dfs1(e, curr);\n                dp[curr].insert(*dp[e].rbegin() + (e % 2 ? 1 : 2));\n            }\n        };\n        dfs1(0, -1);\n        vec<int> ans(n);\n        function<void(int, int)> dfs2 = [&](ll curr, ll prev) {\n            ans[curr] = *dp[curr].rbegin();\n            TRAV(e, graph[curr]) {\n                if (e == prev) continue;\n                dp[curr].erase(dp[curr].find(*dp[e].rbegin() + (e % 2 ? 1 : 2)));\n                dp[e].insert(*dp[curr].rbegin() + (curr % 2 ? 1 : 2));\n                dfs2(e, curr);\n                dp[e].erase(dp[e].find(*dp[curr].rbegin() + (curr % 2 ? 1 : 2)));\n                dp[curr].insert(*dp[e].rbegin() + (e % 2 ? 1 : 2));\n            }\n        };\n        dfs2(0, -1);\n        return ans;\n    }\n};",
    "submit_ts": "1722697646",
    "subm_id": "1343153871"
}