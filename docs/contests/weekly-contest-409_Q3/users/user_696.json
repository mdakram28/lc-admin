{
    "username": "priyanshu_p28",
    "submission": "class SegmentTree {\nprivate:\n    vector<int> tree;\n    vector<int> lazy;\n    int n;\n    \n    void build(int node, int start, int end) {\n        if (start == end) {\n            tree[node] = 1; // Initial value of each element is 1\n        } else {\n            int mid = (start + end) / 2;\n            build(2 * node, start, mid);\n            build(2 * node + 1, mid + 1, end);\n            tree[node] = tree[2 * node] + tree[2 * node + 1];\n        }\n    }\n    \n    void updateRange(int node, int start, int end, int l, int r) {\n        if (lazy[node] != 0) {\n            tree[node] = 0; // Update the current node\n            if (start != end) {\n                lazy[2 * node] = 1; // Mark children as lazy\n                lazy[2 * node + 1] = 1;\n            }\n            lazy[node] = 0;\n        }\n        \n        if (start > end || start > r || end < l)\n            return;\n        \n        if (start >= l && end <= r) {\n            tree[node] = 0;\n            if (start != end) {\n                lazy[2 * node] = 1;\n                lazy[2 * node + 1] = 1;\n            }\n            return;\n        }\n        \n        int mid = (start + end) / 2;\n        updateRange(2 * node, start, mid, l, r);\n        updateRange(2 * node + 1, mid + 1, end, l, r);\n        tree[node] = tree[2 * node] + tree[2 * node + 1];\n    }\n    \n    int queryRange(int node, int start, int end, int l, int r) {\n        if (lazy[node] != 0) {\n            tree[node] = 0;\n            if (start != end) {\n                lazy[2 * node] = 1;\n                lazy[2 * node + 1] = 1;\n            }\n            lazy[node] = 0;\n        }\n        \n        if (start > end || start > r || end < l)\n            return 0;\n        \n        if (start >= l && end <= r)\n            return tree[node];\n        \n        int mid = (start + end) / 2;\n        int left = queryRange(2 * node, start, mid, l, r);\n        int right = queryRange(2 * node + 1, mid + 1, end, l, r);\n        return left + right;\n    }\n\npublic:\n    SegmentTree(int size) {\n        n = size;\n        tree.resize(4 * n);\n        lazy.resize(4 * n, 0);\n        build(1, 0, n - 1);\n    }\n    \n    void updateRange(int l, int r) {\n        updateRange(1, 0, n - 1, l, r);\n    }\n    \n    int queryRange(int l, int r) {\n        return queryRange(1, 0, n - 1, l, r);\n    }\n    \n    int queryAll() {\n        return queryRange(1, 0, n - 1, 0, n - 1);\n    }\n};\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        SegmentTree segTree(n);\n        vector<int> result;\n        segTree.updateRange(n - 1, n - 1);\n        for (const auto& query : queries) {\n            int l = query[0] + 1;\n            int r = query[1] - 1;\n            segTree.updateRange(l, r);\n            result.push_back(segTree.queryAll());\n        }\n        \n        return result;\n    }\n};",
    "submit_ts": "1722742438",
    "subm_id": "1343768985"
}