{
    "username": "gabbar9081",
    "submission": "class Solution {\npublic:\n    class SegmentTree {\n    public:\n        struct Node {\n            long long inclFirstInclLast;\n            long long inclFirstExclLast;\n            long long exclFirstInclLast;\n            long long exclFirstExclLast;\n        };\n\n        vector<Node> tree;\n        int n;\n        \n        SegmentTree(const vector<int>& arr) {\n            n = arr.size();\n            tree.resize(4 * n);\n            build(arr, 0, 0, n - 1);\n        }\n\n        void build(const vector<int>& arr, int node, int start, int end) {\n            if (start == end) {\n                tree[node].inclFirstInclLast = arr[start];\n                tree[node].inclFirstExclLast = 0;\n                tree[node].exclFirstInclLast = 0;\n                tree[node].exclFirstInclLast = 0;\n            } else {\n                int mid = (start + end) / 2;\n                int left = 2 * node + 1;\n                int right = 2 * node + 2;\n                build(arr, left, start, mid);\n                build(arr, right, mid + 1, end);\n                combine(tree[left], tree[right], node);\n            }\n        }\n\n        void combine(Node left, Node right, int node) {\n            tree[node].inclFirstInclLast = max(left.inclFirstInclLast + right.exclFirstInclLast, \n                                                       left.inclFirstExclLast + max(right.inclFirstInclLast, \n                                                      right.exclFirstInclLast));\n            tree[node].inclFirstExclLast = max(left.inclFirstInclLast + right.exclFirstExclLast,\n                                                  left.inclFirstExclLast + max(right.inclFirstExclLast, \n                                                      right.exclFirstExclLast));\n            tree[node].exclFirstInclLast = max(left.exclFirstInclLast + right.exclFirstInclLast,\n                                                  left.exclFirstExclLast + max(right.inclFirstInclLast, \n                                                      right.exclFirstInclLast));\n            tree[node].exclFirstExclLast = max(left.exclFirstInclLast + right.exclFirstExclLast,\n                                                  left.exclFirstExclLast + max(right.inclFirstExclLast, \n                                                      right.exclFirstExclLast));\n        }\n        \n        long long fun(int l, int r) {\n            fun(0, 0, n - 1, l, r);\n            return max(max(tree[0].inclFirstInclLast, tree[0].inclFirstExclLast), max(tree[0].exclFirstInclLast, tree[0].exclFirstExclLast));\n        }\n\n        Node fun(int node, int start, int end, int l, int r) {\n            if (r < start || end < l) {\n                return {0, 0};\n            }\n            if (l <= start && end <= r) {\n                return tree[node];\n            }\n            int mid = (start + end) / 2;\n            int left = 2 * node + 1;\n            int right = 2 * node + 2;\n            Node leftNode = fun(left, start, mid, l, r);\n            Node rightNode = fun(right, mid + 1, end, l, r);\n            combine(leftNode, rightNode, node);\n            return tree[node];\n        }\n\n        void update(int node, int start, int end, int idx, int value) {\n            if (start == end) {\n                tree[node].inclFirstInclLast = value;\n                tree[node].inclFirstExclLast = 0;\n                tree[node].exclFirstInclLast = 0;\n                tree[node].exclFirstInclLast = 0;\n            } else {\n                int mid = (start + end) / 2;\n                int left = 2 * node + 1;\n                int right = 2 * node + 2;\n                if (start <= idx && idx <= mid) {\n                    update(left, start, mid, idx, value);\n                } else {\n                    update(right, mid + 1, end, idx, value);\n                }\n                combine(tree[left], tree[right], node);\n            }\n        }\n        \n    };\n    \n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        SegmentTree seg(nums);\n        long long sum = 0, MOD = 1e9+7;\n        int n = nums.size();\n        for(int i=0;i<queries.size();i++){\n            seg.update(0, 0, n-1, queries[i][0], queries[i][1]);\n            sum = (sum + seg.fun(0, n-1))%MOD;\n        }\n        return sum;\n    }\n};",
    "submit_ts": 1716694880.0
}