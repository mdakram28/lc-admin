{
    "username": "ethanrao",
    "submission": "class Solution {\npublic:\n    int n, b[50005], f[50005], have[50005], pw[50005], ipw[50005], m;\n    std::string a[50005];\n    std::unordered_map <int, int> cost;\n    std::vector <int> yes;\n    const int mod = 998244353, p = 97;\n    int s[50005];\n    inline int add(int x, int y){\n        return x + y >= mod ? x + y - mod : x + y;\n    }\n    inline int minus(int x, int y){\n        return x < y ? x - y + mod : x - y;\n    }\n    inline int mul(int x, int y){\n        return 1ll * x * y % mod;\n    }\n    inline int Qpow(int x, int y){\n        int r = 1;\n        while(y){\n            if(y & 1) r = mul(r, x);\n            x = mul(x, x);\n            y >>= 1;\n        }\n        return r;\n    }\n    inline int inv(int x){\n        return Qpow(x, mod - 2);\n    }\n    inline int get_hash(const std::string &str){\n        int r = 0;\n        for(int i = 1; i <= str.size(); ++i)\n            r = add(r, mul(Qpow(p, i), str[i - 1] - 'a' + 4));\n        return r;\n    }\n    inline int get(int l, int r){\n        int u = minus(s[r], s[l - 1]);\n        return mul(u, ipw[l - 1]);\n    }\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        n = words.size();\n        for(int i = 0; i < n; ++i) a[i + 1] = words[i], b[i + 1] = costs[i];\n        m = target.size();\n        for(int i = 1; i <= m; ++i) s[i] = add(s[i - 1], mul(Qpow(p, i), target[i - 1] - 'a' + 4));\n        pw[0] = 1; ipw[0] = 1;\n        for(int i = 1; i <= m; ++i) pw[i] = mul(p, pw[i - 1]), ipw[i] = inv(pw[i]);\n        for(int i = 1; i <= n; ++i){\n            int t = get_hash(a[i]);\n            if(cost.find(t) != cost.end()) cost[t] = std::min(cost[t], b[i]);\n            else cost[t] = b[i];\n            have[a[i].size()] = 1;\n        }\n        for(int i = 1; i <= m; ++i) if(have[i]) yes.push_back(i);\n        f[0] = 0;\n        for(int i = 1; i <= m; ++i){\n            f[i] = 1e9;\n            for(int j = 0; j < yes.size(); ++j){\n                int l = yes[j];\n                if(l > i) break;\n                if(f[i - l] == 1e9) continue;\n                int fp = get(i - l + 1, i);\n                if(cost.find(fp) == cost.end()) continue;\n                f[i] = std::min(f[i], f[i - l] + cost[fp]);\n            }\n        }\n        if(f[m] == 1e9) return -1;\n        else return f[m];\n    }\n};",
    "submit_ts": "1720321476",
    "subm_id": "1312323870"
}