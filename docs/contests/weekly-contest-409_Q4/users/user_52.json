{
    "username": "tian-tang-6",
    "submission": "//Timestamp: 2024-08-04 11:58:57\n#define DROP\n#ifdef ONLINE\n#undef LOCAL\n#endif\n#ifndef LOCAL\n#undef _GLIBCXX_DEBUG\n#undef _DEBUG\n#endif\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <deque>\n#include <fstream>\n//#include <ext/pb_ds/assoc_container.hpp>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <type_traits>\n#include <chrono>\n#include <random>\n#include <complex>\n#include <bitset>\n#include <set>\n#include <list>\n#include <array>\n//#include \"compiler_hint.cpp\"\ntemplate <class T, int S>\nstruct MDVecDef {\n  using Type = std::vector<typename MDVecDef<T, S - 1>::Type>;\n  template <typename... Args>\n  static Type Make(int n, Args... args) {\n    return Type(n, MDVecDef<T, S - 1>::Make(args...));\n  }\n};\ntemplate <class T>\nstruct MDVecDef<T, 0> {\n  using Type = T;\n  static Type Make(T val = T()) { return val; }\n};\ntemplate <class T, int S = 1>\nusing MDVec = typename MDVecDef<T, S>::Type;\n#ifndef M_PI\n#define M_PI 3.14159265358979323851280895940618620443274267017841L\n#endif\n#ifndef M_E\n#define M_E 2.718281828459045235428168107993940338928950950503355L\n#endif\n#ifdef LOCAL\n#define Assert(x) assert(x)\n#define DebugRun(X) X\n#define DebugPoint int _x_ = 0; _x_++;\n#else\n#define Debug(...) 42\n#define DebugFmtln(...) 42\n#define Assert(x) 42\n#define DebugRun(X)\n#define DebugPoint\n#endif\n#define Trace(x) DebugFmtln(\"Line %d: %s\", __LINE__, #x)\ntemplate<class T>\ninline T DebugRet(T x) {\n    Debug(x);\n    return x;\n}\n#define const_ref(T) const T &\n#define mut_ref(T) T &\n#define let auto\n#define var auto\n#define MEMSET0(X) std::memset(&X, 0, sizeof(X)) \n#define Size(T) int((T).size())\n#define All(data) data.begin(), data.end()\n#define MakeUnique(data) data.resize(std::unique(All(data)) - data.begin())\n#define MakeUniqueAndSort(data) Sort(All(data)); MakeUnique(data) \n#define MakeAttribute(struct_name, Type, attr_name)               \\\n  struct struct_name {                                            \\\n    using attr_name ## _type = Type;                              \\\n    Type attr_name;                                               \\\n    mut_ref(Type) get_##attr_name() { return attr_name; }         \\\n    const_ref(Type) get_##attr_name() const { return attr_name; } \\\n  };\n#define MakeTemplateAttribute(struct_name, attr_name)          \\\n  template <class T>                                           \\\n  struct struct_name {                                         \\\n    using attr_name##_type = T;                             \\\n    T attr_name;                                               \\\n    mut_ref(T) get_##attr_name() { return attr_name; }         \\\n    const_ref(T) get_##attr_name() const { return attr_name; } \\\n  };\n#define ImplDefaultEq(name)                        \\\n  bool operator==(const name &a, const name &b) {  \\\n    return std::memcmp(&a, &b, sizeof(name)) == 0; \\\n  }                                                \\\n  bool operator!=(const name &a, const name &b) { return !(a == b); }\n#define ImplDefaultComparision(name)                                \\\n  bool operator>(const name &rhs) const { return rhs < *this; }     \\\n  bool operator<=(const name &rhs) const { return !(*this > rhs); } \\\n  bool operator>=(const name &rhs) const { return !(*this < rhs); }\n#define ImplArithmeticAssignOperation(name)                                 \\\n  name &operator+=(const name &rhs) { return *this = (*this) + rhs; } \\\n  name &operator-=(const name &rhs) { return *this = (*this) - rhs; } \\\n  name &operator*=(const name &rhs) { return *this = (*this) * rhs; } \\\n  name &operator/=(const name &rhs) { return *this = (*this) / rhs; }\n#define IsType(Type, param, ret_type)                                        \\\n  template <typename OnlyWhenArg = param>                                    \\\n  enable_if_t<is_same_v<OnlyWhenArg, param> && is_same_v<OnlyWhenArg, Type>, \\\n              ret_type>\n#define IsBool(param, ret_type)       \\\n  template <bool OnlyWhenArg = param> \\\n  enable_if_t<OnlyWhenArg == (param) && OnlyWhenArg, ret_type>\n#define IsBoolStatic(param, ret_type) \\\n  template <bool OnlyWhenArg = param> \\\n  static enable_if_t<OnlyWhenArg == (param) && OnlyWhenArg, ret_type>\n#define MakeAnnotation(name)         \\\n  template <class T>                 \\\n  struct is_##name {                 \\\n    static const bool value = false; \\\n  };                                 \\\n  template <class T>                 \\\n  inline constexpr bool is_##name##_v = is_##name<T>::value;\n#define AssignAnnotation(cls, annotation) \\\n  template <>                             \\\n  struct is_##annotation<cls> {           \\\n    static const bool value = true;       \\\n  };\n#define AssignAnnotationTemplate(cls, annotation, type) \\\n  template <type T>                                     \\\n  struct is_##annotation<cls<T>> {                      \\\n    static const bool value = true;                     \\\n  };\n#define FunctionAlias(from, to)                       \\\n  template <typename... Args>                         \\\n  inline auto to(Args &&...args)                      \\\n      ->decltype(from(std::forward<Args>(args)...)) { \\\n    return from(std::forward<Args>(args)...);         \\\n  }\n#define CastToScalar(field, type) \\\n  operator type() const { return type(field); }\n#define CastToAllScalar(field) \\\n  CastToScalar(field, i8);     \\\n  CastToScalar(field, u8);     \\\n  CastToScalar(field, i16);    \\\n  CastToScalar(field, u16);    \\\n  CastToScalar(field, i32);    \\\n  CastToScalar(field, u32);    \\\n  CastToScalar(field, i64);    \\\n  CastToScalar(field, u64);    \\\n  CastToScalar(field, f32);    \\\n  CastToScalar(field, f64);    \\\n  CastToScalar(field, f80);\n#define COMMA ,\n#ifndef LOCAL\nstd::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());\n#else\nstd::mt19937 rng(0);\n#endif\ntemplate <class T> T random_choice(T l, T r, std::mt19937 &gen = rng) {\n  std::uniform_int_distribution<T> random(l, r);\n  return random(gen);\n}\nnamespace dalt {\n#ifndef LOCAL\nstruct Timer {explicit Timer(const char* m) {}void stop() const {}};\n#else\n#endif\n}\nusing i8 = char;\nusing i16 = short;\nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u16 = unsigned short;\nusing u32 = unsigned int;\nusing u64 = unsigned long long;\nusing usize = size_t;\nusing f32 = float;\nusing f64 = double;\n// 16 exp, 64 precision\nusing f80 = long double;\nFunctionAlias(std::lower_bound, LowerBound);\nFunctionAlias(std::upper_bound, UpperBound);\nFunctionAlias(std::unique, Unique);\nFunctionAlias(std::swap, Swap);\nFunctionAlias(std::min, Min);\nFunctionAlias(std::max, Max);\nFunctionAlias(std::abs, Abs);\nFunctionAlias(std::sin, Sin);\nFunctionAlias(std::asin, Asin);\nFunctionAlias(std::cos, Cos);\nFunctionAlias(std::acos, Acos);\nFunctionAlias(std::tan, Tan);\nFunctionAlias(std::atan, Atan);\nFunctionAlias(std::sort, Sort);\nFunctionAlias(std::fill, Fill);\nFunctionAlias(std::move, Move);\nFunctionAlias(std::reverse, Reverse);\nFunctionAlias(std::max_element, MaxElement);\nFunctionAlias(std::min_element, MinElement);\nFunctionAlias(std::make_tuple, MakeTuple);\nFunctionAlias(std::make_pair, MakePair);\nFunctionAlias(std::clamp, Clamp);\nFunctionAlias(std::shuffle, Shuffle);\nFunctionAlias(std::to_string, ToString);\nFunctionAlias(std::tie, Tie);\nFunctionAlias(std::get<0>, Get0);\nFunctionAlias(std::get<1>, Get1);\nFunctionAlias(std::get<2>, Get2);\nFunctionAlias(std::get<3>, Get3);\nFunctionAlias(std::get<4>, Get4);\ntemplate <typename _Signature>\nusing Function = std::function<_Signature>;\ntemplate <typename _Signature>\nusing Func = Function<_Signature>;\nusing Str = std::string;\nusing String = Str;\nusing StringStream = std::stringstream;\nusing IStream = std::istream;\nusing OStream = std::ostream;\nusing std::enable_if;\nusing std::enable_if_t;\nusing std::is_base_of;\nusing std::is_base_of_v;\nusing std::is_floating_point;\nusing std::is_floating_point_v;\nusing std::is_integral;\nusing std::is_integral_v;\nusing std::is_arithmetic;\nusing std::is_arithmetic_v;\nusing std::is_same;\nusing std::is_same_v;\nusing std::tie;\nauto &Stderr = std::cerr;\nauto &Stdin = std::cin;\nauto &Stdout = std::cout;\ntemplate <class T>\nusing Less = std::less<T>;\ntemplate <class T>\nusing Greater = std::greater<T>;\ntemplate <typename _Key, typename _Tp, typename _Compare = Less<_Key>>\nusing TreeMap = std::map<_Key, _Tp, _Compare>;\ntemplate <typename _Key, typename _Compare = Less<_Key>>\nusing TreeSet = std::set<_Key, _Compare>;\ntemplate <typename _Key, typename _Compare = std::less<_Key>,\n          typename _Alloc = std::allocator<_Key>>\nusing MultiTreeSet = std::multiset<_Key, _Compare, _Alloc>;\ntemplate <class T>\nusing Deque = std::deque<T>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Vec = std::vector<T>;\ntemplate <class T>\nusing Reducer = Func<T(const T &, const T &)>;\ntemplate <class T>\nusing Comparator = Func<bool(const T &, const T &)>;\ntemplate <class T>\nusing Indexer = Func<T(i32)>;\ntemplate <class T>\nusing Indexer2 = Func<T(i32, i32)>;\ntemplate <class A, class B = A, class C = A>\nusing Adder = Func<C(const A &, const B &)>;\ntemplate <class I>\nusing Checker = Func<bool(const I &)>;\ntemplate <class A, class B>\nusing BiChecker = Func<bool(const A &, const B &)>;\ntemplate <class T>\nusing Consumer = Func<void(const T &)>;\ntemplate<class T>\nusing Supplier = Func<T()>;\ntemplate <class FIRST, class SECOND>\nusing BiConsumer = Func<void(const FIRST &, const SECOND &)>;\ntemplate <class F, class T = F>\nusing Mapper = Func<T(const F &)>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, Vec<T>, Greater<T>>;\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T, Vec<T>, Less<T>>;\ntemplate <class T, usize S>\nusing Array = std::array<T, S>;\ntemplate <typename... _Elements>\nusing Tuple = std::tuple<_Elements...>;\ntemplate <class T, class = enable_if_t<is_floating_point_v<T>>>\nusing Complex = std::complex<T>;\ntemplate <class A, class B>\nusing Pair = std::pair<A, B>;\nnamespace dalt {\ntemplate <class T>\nIStream& operator>>(IStream& is, Vec<T>& val) {\n  for (auto& v : val) {\n    is >> v;\n  }\n  return is;\n}\n#define VEC_OP(op)                         \\\n  template <class T>                       \\\n  Vec<T>& operator op(Vec<T>& data, T x) { \\\n    for (auto& v : data) {                 \\\n      v op x;                              \\\n    }                                      \\\n    return data;                           \\\n  }\nVEC_OP(+=)\nVEC_OP(-=)\nVEC_OP(*=)\nVEC_OP(/=)\nVEC_OP(%=)\nVEC_OP(^=)\nVEC_OP(&=)\nVEC_OP(|=)\nVEC_OP(==)\nVEC_OP(!=)\ntemplate <class T>\nint Compare(const Vec<T>& lhs, const Vec<T>& rhs) {\n  for(int i = 0; i < Size(lhs) && i < Size(rhs); i++) {\n    if(lhs[i] != rhs[i]) {\n      return lhs[i] < rhs[i] ? -1 : 1;\n    }\n  }\n  return Size(lhs) < Size(rhs) ? -1 : Size(lhs) > Size(rhs) ? 1 : 0;\n}\ntemplate <class T>\nbool operator<(const Vec<T>& lhs, const Vec<T>& rhs) {\n  return Compare(lhs, rhs) < 0;\n}\ntemplate <class T>\nbool operator>(const Vec<T>& lhs, const Vec<T>& rhs) {\n  return Compare(lhs, rhs) > 0;\n}\ntemplate <class T>\nbool operator<=(const Vec<T>& lhs, const Vec<T>& rhs) {\n  return Compare(lhs, rhs) <= 0;\n}\ntemplate <class T>\nbool operator>=(const Vec<T>& lhs, const Vec<T>& rhs) {\n  return Compare(lhs, rhs) >= 0;\n}\n}  // namespace dalt\n//#include \"array_adder.cpp\"\n#ifndef _builtin_clz\ninline i32 _builtin_clz(u32 i) {\n  // HD, Count leading 0's\n  if (i <= 0) return i == 0 ? 32 : 0;\n  int n = 31;\n  if (i >= 1 << 16) {\n    n -= 16;\n    i >>= 16;\n  }\n  if (i >= 1 << 8) {\n    n -= 8;\n    i >>= 8;\n  }\n  if (i >= 1 << 4) {\n    n -= 4;\n    i >>= 4;\n  }\n  if (i >= 1 << 2) {\n    n -= 2;\n    i >>= 2;\n  }\n  return n - (i >> 1);\n}\n#endif\n#ifndef _builtin_clzll\ninline i32 _builtin_clzll(u64 i) {\n  u32 x = u32(i >> 32);\n  return x == 0 ? 32 + _builtin_clz((int)i) : _builtin_clz(x);\n}\n#endif\n#ifndef _builtin_ctz\ninline i32 _builtin_ctz(u32 i) {\n  // HD, Figure 5-14\n  int y;\n  if (i == 0) return 32;\n  int n = 31;\n  y = i << 16;\n  if (y != 0) {\n    n = n - 16;\n    i = y;\n  }\n  y = i << 8;\n  if (y != 0) {\n    n = n - 8;\n    i = y;\n  }\n  y = i << 4;\n  if (y != 0) {\n    n = n - 4;\n    i = y;\n  }\n  y = i << 2;\n  if (y != 0) {\n    n = n - 2;\n    i = y;\n  }\n  return n - ((i << 1) >> 31);\n}\n#endif\n#ifndef _builtin_ctzll\ninline i32 _builtin_ctzll(u64 i) {\n  // HD, Figure 5-14\n  int x, y;\n  if (i == 0) return 64;\n  int n = 63;\n  y = (int)i;\n  if (y != 0) {\n    n = n - 32;\n    x = y;\n  } else\n    x = (int)(i >> 32);\n  y = x << 16;\n  if (y != 0) {\n    n = n - 16;\n    x = y;\n  }\n  y = x << 8;\n  if (y != 0) {\n    n = n - 8;\n    x = y;\n  }\n  y = x << 4;\n  if (y != 0) {\n    n = n - 4;\n    x = y;\n  }\n  y = x << 2;\n  if (y != 0) {\n    n = n - 2;\n    x = y;\n  }\n  return n - ((x << 1) >> 31);\n}\n#endif\n#ifndef _builtin_popcount\ninline i32 _builtin_popcount(u32 i) {\n  // HD, Figure 5-2\n  i = i - ((i >> 1) & 0x55555555);\n  i = (i & 0x33333333) + ((i >> 2) & 0x33333333);\n  i = (i + (i >> 4)) & 0x0f0f0f0f;\n  i = i + (i >> 8);\n  i = i + (i >> 16);\n  return i & 0x3f;\n}\n#endif\n#ifndef _builtin_popcountll\ninline i32 _builtin_popcountll(u64 i) {\n  // HD, Figure 5-2\n  i = i - ((i >> 1) & 0x5555555555555555ll);\n  i = (i & 0x3333333333333333ll) + ((i >> 2) & 0x3333333333333333ll);\n  i = (i + (i >> 4)) & 0x0f0f0f0f0f0f0f0fll;\n  i = i + (i >> 8);\n  i = i + (i >> 16);\n  i = i + (i >> 32);\n  return (int)i & 0x7f;\n}\n#endif\nnamespace dalt {\ninline i32 LeadingZeroNumber(u32 x) {\n  if (x == 0) return 32;\n  return _builtin_clz(x);\n}\ninline i32 LeadingZeroNumber(i32 x) { return LeadingZeroNumber(u32(x)); }\ninline i32 LeadingZeroNumber(u64 x) {\n  if (x == 0) return 64;\n  return _builtin_clzll(x);\n}\ninline i32 LeadingZeroNumber(i64 x) { return LeadingZeroNumber(u64(x)); }\ninline i32 TrailingZeroNumber(u32 x) {\n  if (x == 0) return 32;\n  return _builtin_ctz(x);\n}\ninline i32 TrailingZeroNumber(i32 x) { return TrailingZeroNumber(u32(x)); }\ninline i32 TrailingZeroNumber(u64 x) {\n  if (x == 0) return 64;\n  return _builtin_ctzll(x);\n}\ninline i32 TrailingZeroNumber(i64 x) { return TrailingZeroNumber(u64(x)); }\ninline i32 Log2Ceil(u32 x) {\n  if (x == 0) {\n    return 0;\n  }\n  return 32 - LeadingZeroNumber(x - 1);\n}\ninline i32 Log2Ceil(u64 x) {\n  if (x == 0) {\n    return 0;\n  }\n  return 64 - LeadingZeroNumber(x - 1);\n}\ninline i32 Log2Floor(u32 x) {\n  if (x == 0) {\n    return -1;\n  }\n  return 31 - LeadingZeroNumber(x);\n}\ninline i32 Log2Floor(u64 x) {\n  if (x == 0) {\n    return -1;\n  }\n  return 63 - LeadingZeroNumber(x);\n}\ninline i32 Log2Ceil(i32 x) { return Log2Ceil(u32(x)); }\ninline i32 Log2Ceil(i64 x) { return Log2Ceil(u64(x)); }\ninline i32 Log2Floor(i32 x) { return Log2Floor(u32(x)); }\ninline i32 Log2Floor(i64 x) { return Log2Floor(u64(x)); }\ninline i32 CountBit(u32 x) { return _builtin_popcount(x); }\ninline i32 CountBit(i32 x) { return CountBit(u32(x)); }\ninline i32 CountBit(u64 x) { return _builtin_popcountll(x); }\ninline i32 CountBit(i64 x) { return CountBit(u64(x)); }\ninline i32 HighestOneBitOffset(u32 x) { return Log2Floor(x); }\ninline i32 HighestOneBitOffset(i32 x) { return HighestOneBitOffset(u32(x)); }\ninline i32 HighestOneBitOffset(u64 x) { return Log2Floor(x); }\ninline i32 HighestOneBitOffset(i64 x) { return HighestOneBitOffset(u64(x)); }\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> LowestOneBit(T x) {\n  return x & -x;\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> HighestOneBit(T x) {\n  if (x == 0) {\n    return x;\n  }\n  return T(1) << HighestOneBitOffset(x);\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, i32> LowestOneBitOffset(T x) {\n  if (x == 0) {\n    return -1;\n  }\n  return HighestOneBitOffset(LowestOneBit(x));\n}\ninline u32 HighestKOnes32(i32 k) {\n  if (k == 0) {\n    return 0;\n  }\n  return (~u32()) << (32 - k);\n}\ninline u64 HighestKOnes64(i32 k) {\n  if (k == 0) {\n    return 0;\n  }\n  return (~u64()) << (64 - k);\n}\ninline u32 LowestKOnes32(i32 k) {\n  if (k == 0) {\n    return 0;\n  }\n  return (~u32()) >> (32 - k);\n}\ninline u64 LowestKOnes64(i32 k) {\n  if (k == 0) {\n    return 0;\n  }\n  return (~u64()) >> (64 - k);\n}\ninline u64 IntervalOnes64(i32 l, i32 r) {\n  if (l > r) {\n    return 0;\n  }\n  u64 high = r < 63 ? (u64(-1) << r + 1) : 0;\n  u64 low = u64(-1) << l;\n  return high ^ low;\n}\ninline u32 IntervalOnes32(i32 l, i32 r) {\n  if (l > r) {\n    return 0;\n  }\n  u32 high = r < 31 ? (u32(-1) << r + 1) : 0;\n  u32 low = u32(-1) << l;\n  return high ^ low;\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, i32> KthBit(T x, i32 k) {\n  return (x >> k) & 1;\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> SetBit(T x, i32 k) {\n  return x | (T(1) << k);\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> ClearBit(T x, i32 k) {\n  return x & ~(T(1) << k);\n}\n}  // namespace dalt\nnamespace dalt {\ntemplate <class T> enable_if_t<is_integral_v<T>, T> DivFloor(T a, T b) {\n  Assert(b > 0);\n  auto ans = a / b;\n  if (ans * b > a) {\n    ans = ans - 1;\n  }\n  return ans;\n}\ntemplate <class T> enable_if_t<is_integral_v<T>, T> DivCeil(T a, T b) {\n  Assert(b > 0);\n  auto ans = a / b;\n  if (ans * b < a) {\n    ans = ans + 1;\n  }\n  return ans;\n}\ntemplate <class T>\nenable_if_t<is_floating_point_v<T>, T> DivFloor(T a, T b) {\n  return a / b;\n}\ntemplate <class T>\nenable_if_t<is_floating_point_v<T>, T> DivCeil(T a, T b) {\n  return a / b;\n}\ntemplate <class T>\nenable_if_t<is_integral_v<T>, T> SmallerValue(T val) {\n  return val - 1;\n}\ntemplate <class T>\nenable_if_t<is_integral_v<T>, T> LargerValue(T val) {\n  return val + 1;\n}\ntemplate <class T>\nenable_if_t<is_floating_point_v<T>, T> SmallerValue(T val) {\n  return val;\n}\ntemplate <class T>\nenable_if_t<is_floating_point_v<T>, T> LargerValue(T val) {\n  return val;\n}\n} // namespace dalt\nnamespace dalt {\ntemplate <class T>\nstruct Optional {\n  using Self = Optional<T>;\n private:\n  T val;\n  bool show_up;\n public:\n  Optional(const T &arg_val) : val(arg_val), show_up(true) {}\n  Optional(const T &&arg_val) : val(arg_val), show_up(true) {}\n  Optional() : show_up(false) {}\n  const T &value() const {\n    Assert(show_up);\n    return val;\n  }\n  T &value() {\n    Assert(show_up);\n    return val;\n  }\n  T &operator*() { return value(); }\n  const T &operator*() const { return value(); }\n  bool is_some() const { return show_up; }\n  bool is_none() const { return !show_up; }\n  const T *operator->() const {\n    return &value();\n  }\n  T *operator->() { return &value(); }\n  inline operator T() const { return value(); }\n  T or_else(T def) const {\n    if (is_some()) {\n      return val;\n    } else {\n      return def;\n    }\n  }\n  template <class E>\n  Optional<E> map(const Mapper<T, E> &mapper) const {\n    if (is_some()) {\n      return mapper(value());\n    } else {\n      return Optional<E>();\n    }\n  }\n  bool operator==(const Self &b) const {\n    return show_up == b.show_up && (!show_up || val == b.val);\n  }\n};\ntemplate <class E>\nbool operator!=(const Optional<E> &a, const Optional<E> &b) {\n  return !(a == b);\n}\ntemplate <class E>\nOStream &operator<<(OStream &os, const Optional<E> &v) {\n  if (v.is_none()) {\n    os << \"{}\";\n  } else {\n    os << '{' << v.value() << '}';\n  }\n  return os;\n}\n}  // namespace dalt\nnamespace dalt {\ntemplate <class T>\nenable_if_t<is_integral_v<T>, Optional<T>> FirstTrue(\n    T l, T r, const Checker<T> &checker) {\n  if (!checker(r)) {\n    return {};\n  }\n  while (l < r) {\n    T m = DivFloor<T>(l + r, 2);\n    if (checker(m)) {\n      r = m;\n    } else {\n      l = m + 1;\n    }\n  }\n  return l;\n}\ntemplate <class T>\nenable_if_t<is_integral_v<T>, Optional<T>> LastTrue(T l, T r,\n                                                    const Checker<T> &checker) {\n  if (!checker(l)) {\n    return {};\n  }\n  while (l < r) {\n    T m = DivCeil<T>(l + r, 2);\n    if (checker(m)) {\n      l = m;\n    } else {\n      r = m - 1;\n    }\n  }\n  return l;\n}\ntemplate <class T>\nenable_if_t<is_floating_point_v<T>, Optional<T>> FirstTrue(\n    T l, T r, const Checker<T> &checker, Function<bool()> stopper) {\n  if (!checker(r)) {\n    return {};\n  }\n  while (!stopper()) {\n    T m = (l + r) / 2;\n    if (checker(m)) {\n      r = m;\n    } else {\n      l = m;\n    }\n  }\n  return l;\n}\ntemplate <class T>\nenable_if_t<is_floating_point_v<T>, Optional<T>> FirstTrue(\n    T l, T r, const Checker<T> &checker, i32 max_round) {\n  return FirstTrue<T>(\n      l, r, checker,[&]() { return max_round-- <= 0; });\n}\n}  // namespace dalt\nusing namespace dalt;\n// #include \"collection.cpp\"\n// #include \"combination.cpp\"\n// #include \"function.cpp\"\nnamespace dalt {\nnamespace graph {\ntemplate <class E>\nusing Graph = Vec<Vec<E>>;\nMakeAttribute(WithId, i32, id);\nMakeAttribute(WithTo, i32, to);\nMakeAttribute(WithRev, i32, rev);\nMakeTemplateAttribute(WithWeight, weight);\nstruct DiBaseEdge: public WithTo {};\nstruct BiBaseEdge: public DiBaseEdge, public WithRev {};\n#define IsDiGraph(E, ret) enable_if_t<is_base_of_v<DiBaseEdge, E>, ret>\n#define IsBiGraph(E, ret) enable_if_t<is_base_of_v<BiBaseEdge, E>, ret>\ntemplate <class E>\nIsDiGraph(E, void) AddDiEdge(Graph<E> &g, int s, int t) {\n  E pos;\n  pos.to = t;\n  g[s].push_back(pos);\n}\ntemplate <class E> IsBiGraph(E, void) AddBiEdge(Graph<E> &g, int s, int t) {\n  E pos, neg;\n  pos.to = t;\n  neg.to = s;\n  pos.rev = Size(g[t]);\n  neg.rev = Size(g[s]);\n  g[s].push_back(pos);\n  g[t].push_back(neg);\n}\n} // namespace graph\n} // namespace dalt\n//#include \"shortest_path.cpp\"\nnamespace dalt {\ntemplate <class A, class B>\ninline A& Chmin(A& a, const B& b) {\n  if (a > b) {\n    a = b;\n  }\n  return a;\n}\ntemplate <class T>\ninline T& Chmin(T& a, const T& b, const Comparator<T> &comp) {\n  if (comp(b, a)) {\n    a = b;\n  }\n  return a;\n}\ntemplate <class A, class B>\ninline A& Chmax(A& a, const B& b) {\n  if (a < b) {\n    a = b;\n  }\n  return a;\n}\ntemplate <class T>\ninline T& Chmax(T& a, const T& b, const Comparator<T>& comp) {\n  if (comp(a, b)) {\n    a = b;\n  }\n  return a;\n}\ntemplate <class T>\ninline T& AddTo(T& a, const T& b) {\n  a = a + b;\n  return a;\n}\ntemplate <class T>\ninline T& MulTo(T& a, const T& b) {\n  a = a * b;\n  return a;\n}\ntemplate <class T>\ninline T& SubFrom(T& a, const T& b) {\n  a = a - b;\n  return a;\n}\ntemplate <class T>\ninline T& DivFrom(T& a, const T& b) {\n  a = a / b;\n  return a;\n}\ntemplate <class T, class E>\nconstexpr enable_if_t<is_integral_v<E>, T> PowBinaryLift(T x, E n) {\n  if (n == E(0)) {\n    return T(1);\n  }\n  auto ans = PowBinaryLift(x, n >> 1);\n  ans = ans * ans;\n  if (n & 1) {\n    ans = ans * x;\n  }\n  return ans;\n}\ntemplate <class T>\ninline T MulLimit(T a, T b, T max, T def) {\n  if (a == T(0) || b == T(0)) {\n    return T(0);\n  }\n  // a * b <= max\n  // a <= max / b\n  // a <= floor(max / b)\n  if (a <= max / b) {\n    return a * b;\n  } else {\n    return def;\n  }\n}\ntemplate <class T>\ninline T MulLimit(T a, T b, T max) {\n  return MulLimit(a, b, max, max);\n}\ntemplate <class T>\ninline T AddLimit(T a, T b, T max, T def) {\n  if (a <= max - b) {\n    return a + b;\n  } else {\n    return def;\n  }\n}\ntemplate <class T>\ninline T AddLimit(T a, T b, T max) {\n  return AddLimit(a, b, max, max);\n}\ni64 Round(f32 x) { return roundf(x); }\ni64 Round(f64 x) { return round(x); }\ni64 Round(f80 x) { return roundl(x); }\n//l + ... + r\ntemplate<class T>\nT SumOfInterval(T l, T r) {\n  if(l > r) {\n    return T(0);\n  }\n  return (l + r) * (r - l + 1) / T(2);\n}\ntemplate<class T>\nT Pow2(T x) {\n  return x * x;\n}\n}  // namespace dalt\n// #include \"radix.cpp\"\n// #include \"modint.cpp\"\n// using Mi = ModInt1000000007;\n//  #include \"prefix_sum.cpp\"\nnamespace dalt {\ntemplate <class T, int N>\nstruct PrefixSum {\n  using Self = PrefixSum<T, N>;\n  Vec<PrefixSum<T, N - 1>> ps;\n  PrefixSum(){}\n  PrefixSum(const MDVec<T, N>& data) {\n    ps.reserve(Size(data));\n    int k = Size(data);\n    for (int i = 0; i < k; i++) {\n      ps.emplace_back(data[i]);\n      if (i > 0) {\n        ps[i] += ps[i - 1];\n      }\n    }\n  }\n  int size() const {\n    return ps.size();\n  }\n  const PrefixSum<T, N - 1>& operator[](int i) const {\n    return ps[i];\n  }\n  friend Self& operator+=(Self& a, const Self& b) {\n    for (int i = 0; i < Size(a); i++) {\n      a.ps[i] += b.ps[i];\n    }\n    return a;\n  }\n  template <typename... Args>\n  T query(int l, int r, Args... args) const {\n    return ps[r].query(args...) - (l - 1 < 0 ? T() : ps[l - 1].query(args...));\n  }\n  template <typename... Args>\n  T query_with_check(int l, int r, Args... args) const {\n    l = Max(0, l);\n    r = Min(r, Size(ps) - 1);\n    if(l > r) {\n      return T();\n    }\n    return ps[r].query_with_check(args...) -\n           (l - 1 < 0 ? T() : ps[l - 1].query_with_check(args...));\n  }\n};\ntemplate <class T>\nstruct PrefixSum<T, 0> {\n  using Self = PrefixSum<T, 0>;\n  T data;\n  PrefixSum(const MDVec<T, 0>& _data) : data(_data) {}\n  friend Self& operator+=(Self& a, const Self& b) { a.data += b.data; return a; }\n  T query() const { return data; }\n  T query_with_check() const { return data; }\n};\n}  // namespace dalt\nusing namespace std;\nusing namespace graph;\nnamespace dalt {\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> Gcd(T a, T b) {\n  while (b != 0) {\n    a %= b;\n    Swap(a, b);\n  }\n  return a;\n}\n// ret_value = [x, y, gcd(a,b)] that x * a + y * b = gcd(a, b)\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, Array<T, 3>> ExtGcd(T a, T b) {\n  if (b == 0) {\n    return Array<T, 3>{1, 0, a};\n  }\n  auto div = a / b;\n  auto ans = ExtGcd(b, a - b * div);\n  auto x = ans[0];\n  auto y = ans[1];\n  return Array<T, 3>{y, x - a / b * y, ans[2]};\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, Optional<T>> PossibleModInverse(\n    T a, T modulus) {\n  auto res = ExtGcd(a, modulus);\n  if (res[2] == 1) {\n    auto ans = res[0] % modulus;\n    if (ans < 0) {\n      ans += modulus;\n    }\n    return ans;\n  }\n  return {};\n}\n}  // namespace dalt\n// #include \"dsu.cpp\"\n//   #include \"segtree.cpp\"\nusing namespace dalt;\nnamespace dalt {\ntemplate <class T, class C>\nIndexer<T> MakeIndexer(const C &data) {\n  return [&](auto i) -> T { return data[i]; };\n}\ntemplate <class T, class C>\nIndexer<T> MakeReverseIndexer(const C &data) {\n  return [&](auto i) -> T { return data[Size(data) - 1 - i]; };\n}\ntemplate <class T>\nVec<T> ExpandIndexer(int n, const Indexer<T> &indexer) {\n  Vec<T> ans;\n  ans.reserve(n);\n  for (int i = 0; i < n; i++) {\n    ans.push_back(indexer(i));\n  }\n  return ans;\n}\nIndexer<i32> SelfIndexer() {\n  return [](auto i) { return i; };\n}\ntemplate <class T>\nIndexer<T> ConstantIndexer(const T &val) {\n  return [=](auto i) { return val; };\n}\ntemplate <class A, class B>\nMapper<A, B> ConstructorMapper() {\n  return [&](auto a) { return B(a); };\n}\ntemplate <class T>\nAdder<T> NaturalAdder() {\n  return [](auto a, auto b) { return a + b; };\n}\ntemplate <class A, class B, class C>\nconstexpr Adder<A, B, C> EmptyAdder() {\n  return [](auto a, auto b) { return C(); };\n}\ntemplate <class A, class B = A>\nconstexpr Adder<A, B, A> ReturnLeftAdder() {\n  return [](auto a, auto b) { return a; };\n}\ntemplate <class A, class B = A>\nconstexpr Adder<A, B, B> ReturnRightAdder() {\n  return [](auto a, auto b) { return b; };\n}\ntemplate <class T>\nIndexer<int> BinaryIndexer(const T& val) {\n  return [=](int i) {return int((val >> i) & 1);};\n}\ntemplate <class T>\nIndexer<int> ReverseIndexer(int n, Indexer<T> indexer) {\n  return [=](int i) {return indexer(n - 1 - i);};\n}\n}  // namespace dalt\n//#include \"kmp.cpp\"\n// #include \"interval_map.cpp\"\n// #include \"matrix.cpp\"\n// #include \"hash_range.cpp\"\n// #include \"hashmap.cpp\"\n//#include \"binary_tree.cpp\"\n#ifdef LOCAL\nstruct TreeNode\n{\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode()\n      : val(0),\n        left(nullptr), right(nullptr) {}\n  TreeNode(int x)\n      : val(x),\n        left(nullptr),\n        right(nullptr) {}\n  TreeNode(int x, TreeNode *left, TreeNode *right)\n      : val(x),\n        left(left), right(right) {}\n};\n#endif\n// #include \"interval_map.cpp\"\n// #include \"hash_range.cpp\"\n//#include \"segtree_beat.cpp\"\n//#include \"sparse_table.cpp\"\n//#include \"binary.cpp\"\n//#include \"fenwick_tree.cpp\"\n//#include \"segtree.cpp\"\nclass Solution\n{\npublic:\n    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {\n        TreeMap<int, int> map;\n        TreeMap<int, int> cnt;\n        int n = Size(colors);\n        Vec<int> cs = Vec<int>(n, 0);\n        Vec<int> ans;\n        for(int i = 0; i < n; i++) {\n          map[i] = i;\n        }\n        cnt[1] = n;\n        var mod_cnt = [&](int v, int x) {\n          assert(v <= n);\n          cnt[v] += x;\n          if(cnt[v] == 0) {\n            cnt.erase(v);\n          }\n        };\n        var erase_pair = [&](int l, int r) {\n          mod_cnt(r - l + 1, -1);\n          map.erase(l);\n        };\n        var add_pair = [&](int l, int r) {\n          if(l >= n) {\n            l -= n;\n            r -= n;\n          }\n          if(l > r) {\n            return;\n          }\n          mod_cnt(r - l + 1, 1);\n          map[l] = r;\n        };\n        var find_point = [&](var &find_point, int x) -> Pair<int, int> {\n          var iter = map.upper_bound(x);\n          if(iter != map.begin()) {\n            --iter;\n          } else {\n            return find_point(find_point, x + n);\n          }\n          return *iter;\n        };\n        var change = [&](int index, int c) {\n          if(cs[index] == c) {\n            return;\n          }\n          //break\n          var pair = find_point(find_point, index);\n          erase_pair(pair.first, pair.second);\n          //insert back\n          int actual_index = index;\n          if(pair.first > actual_index) {\n            actual_index += n;\n          }\n          if(pair.second - pair.first + 1 == n && (actual_index == pair.first || actual_index == pair.second || cs[pair.first % n] != cs[pair.second % n])) {\n            add_pair(index + 1, index + n - 1);\n          } else {\n            add_pair(pair.first, actual_index - 1);\n            add_pair(actual_index + 1, pair.second);\n          }\n          cs[index] = c;\n          int l = index;\n          int r = index;\n          if(cs[(index + n - 1) % n] != cs[index]) {\n            //concate before\n            pair = find_point(find_point, (index + n - 1) % n);\n            erase_pair(pair.first, pair.second);\n            l = pair.first;\n            r = pair.second + 1;\n          }\n          if(r - l + 1 != n && cs[(index + 1) % n] != cs[index]) {\n            pair = find_point(find_point, (index + 1) % n);\n            erase_pair(pair.first, pair.second);\n            r += pair.second - pair.first + 1;\n          }\n          add_pair(l, r);\n        };\n        for(int i = 0; i < n; i++) {\n          change(i, colors[i]);\n        }\n        for(var &q : queries) {\n          Debug(q);\n          Debug(cs);\n          Debug(map);\n          Debug(cnt);\n          //type 1\n          if(q[0] == 1) {\n            int size = q[1];\n            int local = 0;\n            //only one group\n            if(Size(map) == 1 && n % 2 == 0) {\n              local = n;\n            } else {\n              for(var &p : cnt) {\n                local += Max(p.first + 1 - size, 0) * p.second;\n              }\n            }\n            ans.push_back(local);\n          } else {\n            int index = q[1];\n            int c = q[2];\n            change(index, c);\n          }\n        }\n        return ans;\n    }\n};\n#ifdef LOCAL\nint main()\n{\n  Vec<int> colors{0,1,0,1};\n  Vec<Vec<int>> queries{{1,3},{2,2,1},{1,3},{1,3}};\n  Solution().numberOfAlternatingGroups(colors, queries);\n  return 0;\n}\n#endif",
    "submit_ts": "1722743952",
    "subm_id": "552353791"
}