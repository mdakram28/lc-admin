{
    "username": "SR3mix",
    "submission": "typedef long long ll;\n\n// SEG ITERATIVE\ntemplate <typename T> class SegmentTreeIterative {\npublic:\n    T seg[800080],segBase;\n    int n,sz,lsz;\n    function<T(T, T)> compare_operation;\n    SegmentTreeIterative(function<T(T, T)> given_compare_op, T newSegBase) {\n        compare_operation = given_compare_op;\n        segBase = newSegBase;\n    }\n    void reset(int newN) {\n        n = newN;\n        assert(n * 4 <= sizeof(seg)/sizeof(seg[0]));\n        sz = 1; while (sz < n) sz *= 2;\n        lsz = __builtin_ctzll(sz);\n        for (int i= 0; i<(sz*2); i++) {seg[i] = segBase;}\n    }\n    void update(int pos, T x) {doUpdate(pos-1, x);}\n    void doUpdate(int pos0index, T x) {\n        assert(pos0index >= 0 && pos0index < n);\n        int p = pos0index + sz; seg[p] = x;\n        for (int i = 1; i <= lsz; i++) modify(p >> i);\n    }\n    T query(int l, int r) {return doQuery(l-1, r);}\n    T doQuery(int l0index, int r0index) {\n        assert(l0index >= 0 && l0index <= r0index && r0index <= n);\n        int l = l0index + sz, r = r0index + sz;\n        T lans = segBase, rans = segBase;\n        while (l < r) {\n            if (l & 1) lans = compare_operation(lans, seg[l++]);\n            if (r & 1) rans = compare_operation(seg[--r], rans);\n            l = (l >> 1); r = (r >> 1);\n        }\n        return compare_operation(lans, rans);\n    }\n    void modify(int k) {seg[k] = compare_operation(seg[2*k], seg[2*k + 1]);}\n    T trueValue(int index) {assert(index >= 1 && index <= n); return seg[index-1+sz];}\n    T true0indexValue(int index0) {assert(index0 >= 0 && index0 < n); return seg[index0 + sz];}\n};\n// CREDIT TO numb3r5 FOR THIS TEMPLATE -> https://leetcode.com/numb3r5/\n\nll comp(ll a, ll b) {return (a & b);}\nSegmentTreeIterative<ll> seg(comp, INT_MAX);\nclass Solution {\npublic:\n    vector<int>o,z;\n    int tot = 0;\n    void add(int x) {\n        tot++;\n        bool st = false;\n        for (int i = 31; i >= 0; i--) {\n            if (((1 << i) & x) != 0) {\n                st = true;\n                o[i]++;\n            }\n            else {\n                z[i]++;\n            }\n        }\n    }\n    void remove(int x) {\n        tot--;\n        bool st = false;\n        for (int i = 31; i >= 0; i--) {\n            if (((1 << i) & x) != 0) {\n                //st = true;\n                o[i]--;\n            }\n            else {\n                z[i]--;\n            }\n        }\n    }\n    int compute() {\n        int res = 0;\n        for (int i = 0; i < 32; i++) {\n            int amt = (1 << i);\n            if (z[i] == 0 && o[i] == tot) res += amt;\n        }\n        return res;\n    }\n    \n    \n    long long countSubarrays(vector<int>& nums, int k) {\n        ll ans = 0;\n        int n = nums.size();\n        seg.reset(n);\n        for (int i = 1; i <= n; i++) seg.update(i,nums[i-1]);\n        for (int i = 1; i <= n; i++) {\n            int l = 1, r = i;\n            while (l < r) {\n                int m = l + (r - l)/2;\n                int q = seg.query(m,i);\n                if (q < k) l = m+1;\n                else r = m;\n            }\n            if (seg.query(l,i) != k) continue;\n            int g1 = l;\n            l = 1; r = i;\n            while (l < r) {\n                int m = l + (r - l)/2 + (r-l)%2;\n                int q = seg.query(m,i);\n                if (q <= k) l = m;\n                else r = m-1;\n            }\n            ans += (l - g1 + 1);\n        }\n        return ans;\n//         int trail = 0;\n//         o = vector<int>(32);\n//         z = vector<int>(32);\n//         int n = nums.size();\n//         vector<vector<int>>both(n, vector<int>(2));\n//         for (int i = 0; i < nums.size(); i++) {\n//             //cout << \"s\" << i << endl;\n//             add(nums[i]);\n//             //cout << \"added\" << endl;\n//             //cout << compute() << endl;\n//             while (trail < i && compute() < k) {\n//                 int rem = nums[trail];\n//                 remove(rem);\n//                 trail++;\n//             }\n//             //cout << \"i: \" << i << \" and \" << trail << \": \" << compute() << endl;\n//             if (compute() == k) both[i][0] = trail;\n//             else both[i][0] = -1;\n//         }\n        \n//         //cout << \"fin\" << endl;\n        \n//         o = vector<int>(32);\n//         z = vector<int>(32);\n//         tot = 0;\n//         trail = 0;\n//         for (int i = 0; i < n; i++) {\n//             //cout << \"t\" << i << endl;\n//             add(nums[i]);\n//             while (trail < i && compute() <= k) {\n//                 int rem = nums[trail];\n//                 remove(rem);\n//                 trail++;\n//             }\n//             //cout << \"i: \" << i << \" and \" << trail << endl;\n//             if (trail > 0) {\n//                 add(nums[trail - 1]);\n//                 if (compute() == k) both[i][1] = trail;\n//                 else both[i][1] = -1;\n//                 remove(nums[trail - 1]);\n//             }\n//         }\n        \n        \n//         for (int i = 0; i < n;i++) {\n//             if (both[i][0] != -1 && both[i][1] != -1) {\n//                 ans += (ll)(both[i][1] - both[i][0] + 1);\n//             }\n//         }\n//         return ans;\n    }\n};",
    "submit_ts": "1720278579",
    "subm_id": "1311715287"
}