{
    "username": "idanro12",
    "submission": "class Solution {\npublic:\n    using ll = long long;\n    long long maximumValueSum(vector<vector<int>>& board) {\n        ll n = board.size(), m = board[0].size();\n        ll no_nodes = 2 + n + m;\n\n        vector<vector<ll> > adj(no_nodes);\n        vector<vector<ll> > capacity(no_nodes, vector<ll>(no_nodes, 0));\n        vector<vector<ll> > cost(no_nodes, vector<ll>(no_nodes, 0));\n    \n        for (ll i = 0; i < n; i++) {\n            adj[0].push_back(2 + i);\n            capacity[0][2 + i] = 1;\n        }\n        for (ll i = 0; i < m; i++) {\n            capacity[2 + n + i][1] = 1;\n            adj[2 + n + i].push_back(1);\n        }\n        for (ll r = 0; r < n; r++)\n            for (ll c = 0; c < m; c++) {\n                adj[2 + r].push_back(2 + n + c);\n                capacity[2 + r][2 + n + c] = 1;\n                cost[2 + r][2 + n + c] = -board[r][c];\n            }\n    \n        ll source = 0;\n        ll dest = 1;\n        ll sz = adj.size();\n \n        // add reverse edges\n        for (ll v = 0; v < sz; v++)\n            for (ll u: adj[v]) {\n                if (capacity[u][v] != 0) continue;\n                // the reverse edge u->v already exists in the graph and has some capacity\n    \n                adj[u].push_back(v);\n                cost[u][v] = -cost[v][u];\n            }\n    \n        vector<vector<ll> > flow(sz, vector<ll>(sz, 0)); // flow[i][j] is the current flow from i to j\n    \n        vector<ll> par(sz, -1); // to keep track of the augmenting path\n        function<bool()> find_aug_path = [&]() {\n            vector<ll> dis(sz, LLONG_MAX);\n            dis[source] = 0;\n            vector<bool> in_q(sz, false);\n    \n            queue<ll> q;\n            q.push(source);\n            in_q[source] = true;\n    \n            while (!q.empty()) {\n                ll v = q.front();\n                q.pop();\n    \n                for (ll u: adj[v]) {\n                    if ((flow[v][u] >= capacity[v][u])) continue;\n    \n                    if (dis[v] + cost[v][u] < dis[u]) {\n                        dis[u] = dis[v] + cost[v][u];\n                        par[u] = v;\n                        if (!in_q[u]) {\n                            q.push(u);\n                            in_q[u] = true;\n                        }\n                    }\n                }\n    \n                in_q[v] = false;\n            }\n    \n            return dis[dest] != LLONG_MAX;\n        };\n    \n        ll curr_flow = 0;\n        ll curr_cost = 0;\n        while (curr_flow < 3) {\n            fill(par.begin(), par.end(), -1);\n            if (!find_aug_path()) break;\n    \n            ll min_edge = LLONG_MAX;\n    \n            ll curr = dest;\n            while (curr != source) {\n                ll prev_node = par[curr];\n                min_edge = min(min_edge, capacity[prev_node][curr] - flow[prev_node][curr]);\n                curr = prev_node;\n            }\n\n            min_edge = min(min_edge, 3 - curr_flow);\n    \n            curr = dest;\n            while (curr != source) {\n                flow[par[curr]][curr] += min_edge;\n                flow[curr][par[curr]] -= min_edge;\n                curr_cost += min_edge * cost[par[curr]][curr];\n                curr = par[curr];\n            }\n            curr_flow += min_edge;\n        }\n    \n        return -curr_cost;\n    }\n};",
    "submit_ts": "1723905877",
    "subm_id": "1359023789"
}