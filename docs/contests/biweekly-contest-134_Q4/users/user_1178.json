{
    "username": "Bawa_547",
    "submission": "/* #include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\n// Segment Tree Node\nstruct SegmentTreeNode {\n    int count;\n    SegmentTreeNode* left;\n    SegmentTreeNode* right;\n    SegmentTreeNode() : count(0), left(nullptr), right(nullptr) {}\n};\n\nclass SegmentTree {\nprivate:\n    SegmentTreeNode* root;\n    int minRange, maxRange;\n\n    void update(SegmentTreeNode* node, int start, int end, int idx, int value) {\n        if (start == end) {\n            node->count += value;\n            return;\n        }\n        int mid = (start + end) / 2;\n        if (idx <= mid) {\n            if (!node->left) node->left = new SegmentTreeNode();\n            update(node->left, start, mid, idx, value);\n        } else {\n            if (!node->right) node->right = new SegmentTreeNode();\n            update(node->right, mid + 1, end, idx, value);\n        }\n        node->count = (node->left ? node->left->count : 0) + (node->right ? node->right->count : 0);\n    }\n\n    int query(SegmentTreeNode* node, int start, int end, int L, int R) {\n        if (!node || start > R || end < L) return 0;\n        if (start >= L && end <= R) return node->count;\n        int mid = (start + end) / 2;\n        return query(node->left, start, mid, L, R) + query(node->right, mid + 1, end, L, R);\n    }\n\npublic:\n    SegmentTree(int minRange, int maxRange) : minRange(minRange), maxRange(maxRange) {\n        root = new SegmentTreeNode();\n    }\n\n    void update(int idx, int value) {\n        update(root, minRange, maxRange, idx, value);\n    }\n\n    int query(int L, int R) {\n        return query(root, minRange, maxRange, L, R);\n    }\n};\n\nint countSubarraysWithSumK(vector<int>& nums, int k) {\n    int n = nums.size();\n    unordered_map<int, int> prefixSumToIndex;\n    SegmentTree segmentTree(-100000, 100000); // Assuming prefix sums lie within this range\n\n    int currentPrefixSum = 0;\n    int count = 0;\n\n    // Initialize segment tree with 0 prefix sum\n    segmentTree.update(0, 1);\n\n    for (int i = 0; i < n; ++i) {\n        currentPrefixSum += nums[i];\n        count += segmentTree.query(currentPrefixSum - k, currentPrefixSum - k);\n        segmentTree.update(currentPrefixSum, 1);\n    }\n\n    return count;\n}\n\nint main() {\n    vector<int> nums = {1, 1, 1};\n    int k = 2;  \n    cout << \"Number of subarrays with sum \" << k << \" is \" << countSubarraysWithSumK(nums, k) << endl;\n    return 0;\n}\n*/\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        int n=nums.size();\n        long long res=0;\n        unordered_map<long long,long long>mp;\n        for(int i=0;i<n;i++){   \n            unordered_map<long long,long long>mp2;\n            if(nums[i]==k){\n                res++;\n            }\n            mp2[nums[i]]=1;\n            for(auto ele:mp){\n                long long p=ele.first&nums[i];\n                if(p==k){\n                    res+=ele.second;\n                }\n                mp2[p]+=ele.second;\n            }\n            mp=mp2;\n        }\n        return res;\n    }\n};\n/* #include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\n// Segment Tree Node\nstruct SegmentTreeNode {\n    int count;\n    SegmentTreeNode* left;\n    SegmentTreeNode* right;\n    SegmentTreeNode() : count(0), left(nullptr), right(nullptr) {}\n};\n\nclass SegmentTree {\nprivate:\n    SegmentTreeNode* root;\n    int minRange, maxRange;\n\n    void update(SegmentTreeNode* node, int start, int end, int idx, int value) {\n        if (start == end) {\n            node->count += value;\n            return;\n        }\n        int mid = (start + end) / 2;\n        if (idx <= mid) {\n            if (!node->left) node->left = new SegmentTreeNode();\n            update(node->left, start, mid, idx, value);\n        } else {\n            if (!node->right) node->right = new SegmentTreeNode();\n            update(node->right, mid + 1, end, idx, value);\n        }\n        node->count = (node->left ? node->left->count : 0) + (node->right ? node->right->count : 0);\n    }\n\n    int query(SegmentTreeNode* node, int start, int end, int L, int R) {\n        if (!node || start > R || end < L) return 0;\n        if (start >= L && end <= R) return node->count;\n        int mid = (start + end) / 2;\n        return query(node->left, start, mid, L, R) + query(node->right, mid + 1, end, L, R);\n    }\n\npublic:\n    SegmentTree(int minRange, int maxRange) : minRange(minRange), maxRange(maxRange) {\n        root = new SegmentTreeNode();\n    }\n\n    void update(int idx, int value) {\n        update(root, minRange, maxRange, idx, value);\n    }\n\n    int query(int L, int R) {\n        return query(root, minRange, maxRange, L, R);\n    }\n};\n\nint countSubarraysWithSumK(vector<int>& nums, int k) {\n    int n = nums.size();\n    unordered_map<int, int> prefixSumToIndex;\n    SegmentTree segmentTree(-100000, 100000); // Assuming prefix sums lie within this range\n\n    int currentPrefixSum = 0;\n    int count = 0;\n\n    // Initialize segment tree with 0 prefix sum\n    segmentTree.update(0, 1);\n\n    for (int i = 0; i < n; ++i) {\n        currentPrefixSum += nums[i];\n        count += segmentTree.query(currentPrefixSum - k, currentPrefixSum - k);\n        segmentTree.update(currentPrefixSum, 1);\n    }\n\n    return count;\n}\n\nint main() {\n    vector<int> nums = {1, 1, 1};\n    int k = 2;  \n    cout << \"Number of subarrays with sum \" << k << \" is \" << countSubarraysWithSumK(nums, k) << endl;\n    return 0;\n}\n*/",
    "submit_ts": "1720280007",
    "subm_id": "1311773526"
}