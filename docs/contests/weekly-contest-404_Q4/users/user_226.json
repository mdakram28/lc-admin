{
    "username": "TheZwischenzug",
    "submission": "class Dfs{\n    private Stack<IntListIterator> itrStack;\n    private IntList nodeStack;\n\n    void dfs(IntList[] tree, int root, IntConsumer visit, IntConsumer exit, int[] parent){\n\n        nodeStack =  new IntList();\n        itrStack = new Stack<>();\n\n        nodeStack.add(root);\n        itrStack.push(new IntListIterator(tree[root]));\n        visit.accept(root);\n        parent[root] = -1;\n\n\n        while (!(nodeStack.size() == 0)){\n            int s = nodeStack.peek();\n            IntListIterator itr = itrStack.peek();\n            if (!itr.hasNext()){\n                nodeStack.pop();\n                itrStack.pop();\n                exit.accept(s);\n            }\n            else{\n                int next = itr.next();\n                if (next == parent[s]) continue;\n                nodeStack.add(next);\n                itrStack.push(new IntListIterator(tree[next]));\n                parent[next] = s;\n                visit.accept(next);\n            }\n        }\n    }\n}\nclass IntListIterator{\n    IntList list;\n    int idx;\n    IntListIterator(IntList list){\n        this.list = list;\n        idx = 0;\n    }\n    int next(){\n        return list.get(idx++);\n    }\n    boolean hasNext(){\n        return idx < list.size();\n    }\n}\nclass IntList{\n    private int[] arr;\n    private int size;\n    IntList(int initialCapacity){\n        arr = new int[initialCapacity];\n        size = 0;\n    }\n    IntList(){\n        this(1);\n    }\n\n    int get(int idx){\n        return arr[idx];\n    }\n\n    void doubleArraySize(){\n        int[] copy = new int[2*arr.length];\n        for (int i = 0; i < size; i++) copy[i] = arr[i];\n        arr = copy;\n    }\n    void add(int val){\n        if (size == arr.length){\n            doubleArraySize();\n        }\n        arr[size] = val;\n        size++;\n    }\n    int size(){\n        return size;\n    }\n    int peek(){\n        return arr[size-1];\n    }\n    int pop(){\n        int val = arr[size-1];\n        size--;\n        return val;\n    }\n\n    @Override\n    public String toString() {\n        return \"IntList{\" +\n                \"arr=\" + Arrays.toString(arr) +\n                \", size=\" + size +\n                '}';\n    }\n}\n\nclass Farthest{\n\n    private IntList[] tree;\n    int[] parent;\n    int[] inDp;\n    int[] size;\n    int[] outDp;\n    int n;\n    private void emptyVisit(int s){\n\n    }\n    private void emptyExit(int s){\n\n    }\n\n    private void computeInDp(int s){\n\n        size[s] = 1;\n        for (int i = 0; i < tree[s].size(); i++){\n            int v = tree[s].get(i);\n            if (v == parent[s]) continue;\n            inDp[s] = Math.max(1+inDp[v], inDp[s]);\n            size[s] += size[v];\n        }\n    }\n    private void computeOutDp(int s){\n        int  childrenMax1 = -1, childrenMax2 = -1;\n\n        for (int i = 0; i < tree[s].size(); i++){\n            int v = tree[s].get(i);\n            if (v == parent[s]) continue;\n            if (inDp[v] > childrenMax1){\n                childrenMax2 = childrenMax1;\n                childrenMax1 = inDp[v];\n            }\n            else if (inDp[v] > childrenMax2){\n                childrenMax2 = inDp[v];\n            }\n        }\n\n\n\n        for (int i = 0; i < tree[s].size(); i++){\n            int v = tree[s].get(i);\n            if (v == parent[s]) continue;\n\n            outDp[v] = 1 + outDp[s];\n            int maxInDpOtherThanV = inDp[v] == childrenMax1 ? childrenMax2:childrenMax1;\n            if (maxInDpOtherThanV != -1) outDp[v] = Math.max(2+maxInDpOtherThanV, outDp[v]);\n\n        }\n    }\n    public int[] getFarthest(int[][] edges){\n        n = edges.length+1;\n\n        parent = new int[n];\n        size = new int[n];\n        inDp = new int[n];\n        outDp = new int[n];\n\n\n        tree = new IntList[n];\n        for (int i = 0; i < n; i++) tree[i] = new IntList();\n        for (int i = 0; i < n-1; i++){\n            int u =  edges[i][0], v = edges[i][1];\n            tree[u].add(v);\n            tree[v].add(u);\n        }\n        new Dfs().dfs(tree, 0, this::emptyVisit, this::computeInDp, parent);\n        new Dfs().dfs(tree, 0, this::computeOutDp, this::emptyExit, parent);\n        int[] f = new int[n];\n        for (int i = 0; i < n; i++) f[i] = Math.max(inDp[i], outDp[i]);\n        return f;\n        \n        \n    }\n\n\n}\nclass Solution {\n\n\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int[] f = new Farthest().getFarthest(edges1);\n        int[] g = new Farthest().getFarthest(edges2);\n        int fMax = Arrays.stream(f).max().getAsInt();\n        int gMax = Arrays.stream(g).max().getAsInt();\n        int fMin = Arrays.stream(f).min().getAsInt();\n        int gMin = Arrays.stream(g).min().getAsInt();\n        return Math.max(fMin+gMin+1, Math.max(fMax, gMax));\n    }\n}",
    "submit_ts": "1719718199",
    "subm_id": "1304411231"
}