{
    "username": "exciting-greidernqx",
    "submission": "// class Solution {\n// public:\n//     vector<int> timeTaken(vector<vector<int>>& edges) {\n//         int n = edges.size() + 1;\n//         map<pair<int,int>,int> mp;\n//         vector<vector<array<int,2>>> g(n);\n//         for(auto &t:edges)\n//         {\n//             int x = t[0],y = t[1];\n//             if(x%2)g[y].push_back({x,1});\n//             else g[y].push_back({x,2});\n//             if(y%2)g[x].push_back({y,1});\n//             else g[x].push_back({y,2});\n//             mp[{x,y}] = g[x].back()[1];\n//             mp[{y,x}] = g[y].back()[1];\n//         }\n\n//         vector<int> dp1(n),dp2(n),dp3(n);\n//         function<void(int,int)> dfs1 = [&](int x,int f)->void{\n//             if(x != 0 && g[x].size() == 1)return;\n//             for(auto &k:g[x])\n//             {\n//                 if(k[0] == f)continue;\n//                 dfs1(k[0],x);\n//                 dp1[x] = max(dp1[x],dp1[k[0]] + k[1]);\n//             }\n//         };\n//         function<void(int,int)> dfs3 = [&](int x,int f)->void{\n//             if(x != 0 && g[x].size() == 1)return;\n//             bool ok = false;\n//             for(auto &k:g[x])\n//             {\n//                 if(k[0] == f)continue;\n//                 dfs3(k[0],x);\n//                 if(!ok && dp1[k[0]] + k[1] == dp1[x])\n//                 {\n//                     ok = true;\n//                     continue;\n//                 }\n//                 dp3[x] = max(dp1[x],dp1[k[0]] + k[1]);\n//             }\n//         };\n//         function<void(int,int)> dfs2 = [&](int x,int f)->void{\n//             dp2[x] = dp1[x];\n//             // int mmax1 = 0,mmax2 = 0,f1 = -1,f2 = -1;\n//             // for(auto &k:g[x])\n//             // {\n//             //     if(k[0] < 0)continue;\n//             //     if(dp1[k[0]] + k[1] >= mmax1)\n//             //     {\n//             //         mmax2 = mmax1;\n//             //         f2 = f1;\n//             //         mmax1 = dp1[k[0]] + k[1];\n//             //         f1 = k[0];\n//             //     }else if(dp1[k[0]] + k[1] >= mmax2)\n//             //     {\n//             //         mmax2 = dp1[k[0]] + k[1];\n//             //         f2 = k[0];\n//             //     }\n//             // }\n//             for(auto &k:g[x])\n//             {\n//                 if(k[0] == f)continue;\n//                 int dpx = dp1[x];\n//                 int dpk = dp1[k[0]];\n//                 int dp3k = dp3[k[0]];\n//                 if(dpk + k[1] == dp1[x])dp1[x] = dp2[x];\n//                 dp3[k[0]] = max(dp3[k[0]],dp3[x] + k[1]);\n//                 dp1[k[0]] = max(dp1[x] + mp[{k[0],x}],dp1[k[0]]);\n//                 dfs2(k[0],x);\n//                 dp1[k[0]] = dpk;\n//                 dp1[x] = dpx;\n//                 dp3[k[0]] = dp3k;\n\n//             }\n//         };\n//         dfs1(0,-1);\n//         dfs3(0,-1);\n//         dfs2(0,-1);\n//         return dp2;\n//     }\n// };\nclass Solution {\npublic:\n    vector<int> timeTaken(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        unordered_map<long long,int> mp;\n        vector<vector<array<int,2>>> g(n);\n        for(auto &t:edges)\n        {\n            int x = t[0],y = t[1];\n            if(x%2)g[y].push_back({x,1});\n            else g[y].push_back({x,2});\n            if(y%2)g[x].push_back({y,1});\n            else g[x].push_back({y,2});\n            mp[1LL*x*1000000+y] = g[x].back()[1];\n            mp[1LL*y*1000000+x] = g[y].back()[1];\n        }\n\n        vector<int> dp1(n),dp2(n);\n        function<void(int,int)> dfs1 = [&](int x,int f)->void{\n            if(x != 0 && g[x].size() == 1)return;\n            for(auto &k:g[x])\n            {\n                if(k[0] == f)continue;\n                dfs1(k[0],x);\n                dp1[x] = max(dp1[x],dp1[k[0]] + k[1]);\n            }\n        };\n        function<void(int,int)> dfs2 = [&](int x,int f)->void{\n            dp2[x] = dp1[x];\n            int mmax1 = 0,mmax2 = 0,f1 = -1,f2 = -1;\n            for(auto &k:g[x])\n            {\n                if(k[0] < 0)continue;\n                if(dp1[k[0]] + k[1] >= mmax1)\n                {\n                    mmax2 = mmax1;\n                    f2 = f1;\n                    mmax1 = dp1[k[0]] + k[1];\n                    f1 = k[0];\n                }else if(dp1[k[0]] + k[1] >= mmax2)\n                {\n                    mmax2 = dp1[k[0]] + k[1];\n                    f2 = k[0];\n                }\n            }\n            for(auto &k:g[x])\n            {\n                if(k[0] == f)continue;\n                int dpx = dp1[x];\n                int dpk = dp1[k[0]];\n                int mmax = mmax1;\n                if(k[0] == f1)mmax = mmax2;\n                dp1[x] = mmax;\n                dp1[k[0]] = max(mmax + mp[1LL*k[0]*1000000 + x],dp1[k[0]]);\n                dfs2(k[0],x);\n                dp1[k[0]] = dpk;\n                dp1[x] = dpx;\n\n            }\n        };\n        dfs1(0,-1);\n        dfs2(0,-1);\n        return dp2;\n    }\n};",
    "submit_ts": "1722700450",
    "subm_id": "552279893"
}