{
    "username": "aadiupadhyay",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        \n        # this is taken from GFG till print_path method\n\n        def dfs(adj, node, l, p, lvl, par):\n            lvl[node] = l\n            par[node] = p\n           # if node a is at deeper level than \n           # node b\n            for child in adj[node]:\n                if child != p:\n                    dfs(adj, child, l + 1, node, lvl, par)\n\n        def LCA(a, b, par, lvl):  \n            if lvl[a] > lvl[b]:\n                a, b = b, a\n                # finding the difference in levels\n           # of node a and b\n            diff = lvl[b] - lvl[a]\n            while diff != 0:\n                b = par[b]\n                diff -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = par[a]\n                b = par[b]\n            return a\n\n        def print_path(adj, a, b, n):\n            lvl = [0] * (n + 1)\n            par = [0] * (n + 1)\n            dfs(adj, 1, 0, -1, lvl, par)\n            lca = LCA(a, b, par, lvl)\n            path = []\n            while a != lca:\n                path.append(a)\n                a = par[a]\n            path.append(a)\n            temp = []\n            while b != lca:\n                temp.append(b)\n                b = par[b]\n            temp.reverse()\n            for x in temp:\n                path.append(x)\n            return path\n \n        def DFS(graph, x, dist, v):\n            ma, node = 0, 0\n            stack = [x]\n            v[x] = 1\n            # print(v)\n            while stack:\n                a = stack.pop()\n                for i in graph[a]:\n                    if not v[i]:\n                        stack.append(i)\n                        v[i] = 1\n                        dist[i] = dist[a]+1\n                        if dist[i] > ma:\n                            ma = dist[i]\n                            node = i\n            return ma, node\n\n        g1 = defaultdict(list)\n        g2 = defaultdict(list)\n        n = len(edges1) +  1\n        m = len(edges2) + 1\n        \n        v = [0 for i in range(n)]\n        v1 = list(v)\n        d = list(v)\n        d1 = list(v)\n        \n        \n        v2 = [0 for i in range(m)]\n        v3 = list(v2)\n        d2 = list(v2)\n        d3 = list(v2)\n        \n        for a,b in edges1:\n            g1[a].append(b)\n            g1[b].append(a)\n        for a,b in edges2:\n            g2[a].append(b)\n            g2[b].append(a)\n        \n        dd, nn = DFS(g1,0, d, v)\n        xx1, yy = DFS(g1, nn, d1, v1)\n        \n        source1, dest1 = nn, yy \n        \n        dd, nn = DFS(g2,0, d2, v2)\n        xx2, yy = DFS(g2, nn, d3, v3)\n        \n        source2, dest2 = nn,yy\n        \n        # print(source1, dest1)\n        # print(source2, dest2)\n        # print(xx)\n        \n        path1 = print_path(g1,source1,dest1, n)\n        path2 = print_path(g2,source2,dest2, m)\n        \n        mid1 = path1[xx1//2]\n        mid2 = path2[xx2//2]\n        \n        print(path1, mid1)\n        print(path2, mid2)\n        \n        g1[mid1].append(mid2+n)\n        g1[mid2+n].append(mid1)\n        \n        for a,b in edges2:\n            g1[a+n].append(b+n)\n            g1[b+n].append(a+n)\n            \n        size = n + m \n        v4 = [0 for i in range(size)]\n        v5 = list(v4)\n        d4 = list(v4)\n        d5 = list(v4)\n        \n        # print(g1)\n        \n        dd, nn = DFS(g1,0, d4, v4)\n        xx, yy = DFS(g1, nn, d5, v5)\n        \n        return xx\n        \n        \n\n        \n            ",
    "submit_ts": 1719718870.0
}