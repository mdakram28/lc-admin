{
    "username": "charliesabino",
    "submission": "typedef long long ll;\n\nclass SegmentTree {\npublic:\n  int left_most, right_most;\n  SegmentTree *left_child, *right_child;\n  ll res;\n\n  SegmentTree(int left, int right, vector<ll> &v) {\n    left_most = left;\n    right_most = right;\n    if (left_most == right_most) {\n      res = v[left];\n      left_child = nullptr;\n      right_child = nullptr;\n    } else {\n      int mid = (left + right) / 2;\n      left_child = new SegmentTree(left_most, mid, v);\n      right_child = new SegmentTree(mid + 1, right_most, v);\n      recalc();\n    }\n  }\n\n  void recalc() {\n    if (left_most == right_most)\n      return;\n    res = left_child->res + right_child->res;\n  }\n\n  void point_update(int index, int new_val) {\n    if (left_most == right_most) {\n      res = new_val;\n      return;\n    }\n\n    if (index <= left_child->right_most)\n      left_child->point_update(index, new_val);\n    else\n      right_child->point_update(index, new_val);\n    recalc();\n  }\n\n  ll range(int l, int r) {\n    if (l > right_most || r < left_most)\n      return 0;\n    if (l <= left_most && r >= right_most)\n      return res;\n    return left_child->range(l, r) + right_child->range(l, r);\n  }\n\n  ~SegmentTree() {\n    if (left_child != nullptr)\n      delete left_child;\n    if (right_child != nullptr)\n      delete right_child;\n  }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<ll> v(n, 0);\n        for (int i = 1; i < n - 1; i++) {\n            v[i] = nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n        }\n        SegmentTree st(0, n - 1, v);\n        vector<int> res;\n        for (auto q : queries) {\n            if (q[0] == 1) {\n                if (q[1] == q[2])\n                    res.push_back(0);\n                else\n                    res.push_back(st.range(q[1], q[2]) - v[q[1]] - v[q[2]]);\n            } else {\n                int i = q[1];\n                nums[i] = q[2];\n                int res = i > 0 && i < (n - 1) && nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n                st.point_update(i, res);\n                v[i] = res;\n                if (i > 0 && nums[i] >= nums[i - 1]) {\n                    st.point_update(i - 1, 0);\n                    v[i - 1] = 0;\n                }\n                if (i < (n - 1) && nums[i] >= nums[i + 1]) {\n                    st.point_update(i + 1, 0);\n                    v[i + 1] = 0;\n                }\n                int l = i - 1, r = i + 1;\n                if (l > 0 && l < (n - 1) && nums[l] > nums[l - 1] && nums[l] > nums[l + 1]) {\n                    v[l] = 1;\n                    st.point_update(l, 1);\n                }\n                if (r > 0 && r < (n - 1) && nums[r] > nums[r - 1] && nums[r] > nums[r + 1]) {\n                    v[r] = 1;\n                    st.point_update(r, 1);\n                }\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": "1718507836",
    "subm_id": "1289663957"
}