{
    "username": "Mikaalm",
    "submission": "class T {\npublic:\n    vector<int> ans; \n    vector<vector<int>> adj;\n    int *dist, *son, dia = 0, root = -1;\n    \n    void dfs(int u, int fa) {\n        for (auto &v : adj[u]) {\n            if (v == fa) continue;\n            dfs(v, u);\n            dia = dist[u] + dist[v] + 1 > dia ? dist[root=u] + dist[v] + 1 : dia;\n            dist[u] = dist[v] + 1 > dist[u] ? dist[son[u]=v] + 1 : dist[u];\n        }\n    }\n    \n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        if (n <= 1) return vector<int> {0};\n        dist = new int[n]{}, son = new int[n];\n        memset(son, -1, sizeof(int)*n);\n        adj.resize(n);\n        \n        for (auto &e : edges) \n            adj[e[0]].push_back(e[1]), adj[e[1]].push_back(e[0]);\n        dfs(edges[0][0], -1); \n        while (root != -1 && dia / 2 <= dist[root]) {\n            if ((dia+1) / 2 >= dist[root]) ans.push_back(root);\n            root = son[root];\n        }\n        return ans;\n    }\n};\nclass Solution {\npublic:\n    \n    // void search_below(int root, int father, \n    //     vector<int> & d1, vector<int> & d2, \n    //     vector<int> & n1, vector<int> & n2, \n    //     const vector<vector<int>> & E) {\n    //     for (auto t : E[root]) {\n    //         if (t == father) continue;\n    //         search_below(t, root, d1, d2, n1, n2, E);\n    //         if (d1[t] + 1 > d1[root]) {\n    //             d2[root] = d1[root];\n    //             n2[root] = n1[root];\n    //             d1[root] = d1[t] + 1;\n    //             n1[root] = t;\n    //         }\n    //         else if (d1[t] + 1 > d2[root]) {\n    //             d2[root] = d1[t] + 1;\n    //             n2[root] = t;\n    //         }\n    //     }\n    // }\n    // int search_above(int root, int father, \n    //     vector<int> & d1, vector<int> & d2, \n    //     vector<int> & n1, vector<int> & up, \n    //     vector<int> & max_lens, const vector<vector<int>> & E) {\n    //         if (father != -1) {\n    //             if (n1[father] != root) up[root] = max(d1[father], up[father]) + 1;\n    //             else up[root] = max(d2[father], up[father]) + 1;\n    //         }\n    //         int min_len = max(d1[root], up[root]);\n    //         max_lens[root] = min_len;\n    //         for (auto t : E[root]) {\n    //             if (t == father) continue;\n    //             min_len = min(min_len, search_above(t, root, d1, d2, n1, up, max_lens, E));\n    //         }\n    //         return min_len;\n    // }\n    // int findMinHeightTrees(int n, vector<vector<int>>& edges) {\n    //     // build edges\n    //     vector<vector<int>> E(n, vector<int>());\n    //     for (const vector<int> &e : edges) {\n    //         E[e[0]].push_back(e[1]);\n    //         E[e[1]].push_back(e[0]);\n    //     }\n    //     vector<int> d1(n, 0), d2(n, 0), up(n, 0), n1(n, -1), n2(n, -1);//, max_lens(n, 0);\n    //     search_below(0, -1, d1, d2, n1, n2, E);\n    //     int min_len = search_above(0, -1, d1, d2, n1, up, n2, E);\n    //     return min_len;\n    // }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        // int l = findMinHeightTrees(edges1.size() + 1, edges1), r = findMinHeightTrees(edges2.size() + 1, edges2);\n        // cout << l << ' ' << r << endl;\n        T t1 = T(), t2 = T();\n        t1.findMinHeightTrees(edges1.size() + 1, edges1);\n        t2.findMinHeightTrees(edges2.size() + 1, edges2);\n        // cout << t1.dia << ' ' << t2.dia << endl;\n        return max(max(t1.dia, (t1.dia + 1) / 2 + (t2.dia + 1) / 2 + 1), t2.dia);\n    }\n};\n\n",
    "submit_ts": "1719719306",
    "subm_id": "1304438712"
}