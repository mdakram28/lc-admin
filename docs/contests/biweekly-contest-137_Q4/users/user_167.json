{
    "username": "Chandrachur M",
    "submission": "using pi = pair<int, int>;\nusing ll = long long;\n\nclass Node {\npublic:\n  int maxval;\n  Node(int _maxval = -1e9) {\n    maxval = _maxval;\n  }\n};\n\nNode merge(Node a, Node b) {\n  Node res;\n  res.maxval = max(a.maxval, b.maxval);\n  return res;\n}\n\nclass SegmentTree {\n  int n;\n  vector<Node> t;\npublic:\n  SegmentTree(int n) {\n    this->n = n;\n    t.resize(4 * n);\n    build(1, 0, n - 1);\n  }\n  void build(int id, int l, int r) {\n    if(l == r) {\n      t[id] = Node();\n      return;\n    }\n    int mid = (l + r) >> 1;\n    build(id << 1, l, mid);\n    build(id << 1 | 1, mid + 1, r);\n    t[id] = merge(t[id << 1], t[id << 1 | 1]);\n  }\n  void update(int id, int l, int r, int ind, int val) {\n    if(ind < l || ind > r) {\n      return;\n    }\n    if(l == r) {\n      t[id] = Node(val);\n      return;\n    }\n    int mid = (l + r) >> 1;\n    update(id << 1, l, mid, ind, val);\n    update(id << 1 | 1, mid + 1, r, ind, val);\n    t[id] = merge(t[id << 1], t[id << 1 | 1]);\n  }\n  Node query(int id, int l, int r, int lq, int rq) {\n    if(lq > r || l > rq) {\n      return Node();\n    }\n    if(lq <= l && r <= rq) {\n      return t[id];\n    }\n    int mid = (l + r) >> 1;\n    return merge(query(id << 1, l, mid, lq, rq), query(id << 1 | 1, mid + 1, r, lq, rq));\n  }\n};\n\n\nclass Solution {\npublic:\n  long long maximumValueSum(vector<vector<int>>& board) {\n    int n = (int)board.size(), m = (int)board[0].size();\n    vector<vector<pair<int, int>>> vec(m);\n    for(int j = 0; j < m; j++) {\n      priority_queue<pi, vector<pi>, greater<pi>> pq;\n      for(int i = 0; i < n; i++) {\n        pq.push({board[i][j], i});\n        if(pq.size() > 3) {\n          pq.pop();\n        }\n      }\n      while(!pq.empty()) {\n        auto it = pq.top();\n        pq.pop();\n        vec[j].push_back(it);\n      }\n    }\n    \n    ll res = -1e18;\n    \n    for(int j1 = 0; j1 < m - 2; j1++) {\n      SegmentTree segTree(n);\n      for(int j2 = j1 + 2; j2 < m; j2++) {\n        for(int i = 0; i < 3; i++) {\n          int val = vec[j2 - 1][i].first;\n          int r = vec[j2 - 1][i].second;\n          int prevVal = segTree.query(1, 0, n - 1, r, r).maxval;\n          if(val > prevVal) {\n            segTree.update(1, 0, n - 1, r, val);\n          }\n        }\n        \n          \n        for(int k1 = 0; k1 < 3; k1++) {\n          for(int k2 = 0; k2 < 3; k2++) {\n            int r1 = vec[j1][k1].second;\n            int r2 = vec[j2][k2].second;\n\n            if(r1 != r2) {\n              int val_r1 = segTree.query(1, 0, n - 1, r1, r1).maxval;\n              int val_r2 = segTree.query(1, 0, n - 1, r2, r2).maxval;\n\n              segTree.update(1, 0, n - 1, r1, -1e9);\n              segTree.update(1, 0, n - 1, r2, -1e9);\n\n              \n              ll curr = 0ll + vec[j1][k1].first + vec[j2][k2].first + segTree.query(1, 0, n - 1, 0, n - 1).maxval;\n              res = max(res, curr);\n              \n              segTree.update(1, 0, n - 1, r1, val_r1);\n              segTree.update(1, 0, n - 1, r2, val_r2);\n            }\n          }\n        }\n      }\n    }\n    return res;\n  }\n};",
    "submit_ts": "1723909172",
    "subm_id": "1359182327"
}