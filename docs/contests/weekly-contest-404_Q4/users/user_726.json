{
    "username": "dry4",
    "submission": "class Solution {\n    public int treeDiameter(int[][] edges) {\n        int n = edges.length + 1;\n        List<List<Integer>> adjacencyList = buildAdjacencyList(edges);\n        \n        int[] firstBfsResult = bfs(adjacencyList, 0);\n        int[] secondBfsResult = bfs(adjacencyList, firstBfsResult[0]);\n        \n        return secondBfsResult[1];\n    }\n    \n    private List<List<Integer>> buildAdjacencyList(int[][] edges) {\n        int n = edges.length + 1;\n        List<List<Integer>> adjacencyList = new ArrayList<>();\n        \n        for (int i = 0; i < n; ++i) {\n            adjacencyList.add(new ArrayList<>());\n        }\n        \n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            adjacencyList.get(u).add(v);\n            adjacencyList.get(v).add(u);\n        }\n        \n        return adjacencyList;\n    }\n    \n    private int[] bfs(List<List<Integer>> adjacencyList, int start) {\n        int n = adjacencyList.size();\n        int[] distances = new int[n];\n        Arrays.fill(distances, -1);\n        \n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        distances[start] = 0;\n        int farthestNode = start;\n        \n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            \n            for (int neighbor : adjacencyList.get(node)) {\n                if (distances[neighbor] == -1) {\n                    distances[neighbor] = distances[node] + 1;\n                    queue.offer(neighbor);\n                    \n                    if (distances[neighbor] > distances[farthestNode]) {\n                        farthestNode = neighbor;\n                    }\n                }\n            }\n        }\n        \n        return new int[] { farthestNode, distances[farthestNode] };\n    }\n\n    public List<Integer> findTreeCenters(int[][] edges) {\n        int n = edges.length + 1;\n        List<List<Integer>> adjacencyList = buildAdjacencyList(edges);\n        int[] degrees = new int[n];\n        \n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            degrees[u]++;\n            degrees[v]++;\n        }\n        \n        Queue<Integer> leaves = findLeaves(adjacencyList, degrees);\n        int remainingNodes = n;\n        \n        while (remainingNodes > 2) {\n            int leavesCount = leaves.size();\n            remainingNodes -= leavesCount;\n            \n            for (int i = 0; i < leavesCount; ++i) {\n                int leaf = leaves.poll();\n                \n                for (int neighbor : adjacencyList.get(leaf)) {\n                    if (--degrees[neighbor] == 1) {\n                        leaves.offer(neighbor);\n                    }\n                }\n            }\n        }\n        \n        List<Integer> centers = new ArrayList<>();\n        \n        while (!leaves.isEmpty()) {\n            centers.add(leaves.poll());\n        }\n        \n        return centers;\n    }\n    \n    private Queue<Integer> findLeaves(List<List<Integer>> adjacencyList, int[] degrees) {\n        Queue<Integer> leaves = new LinkedList<>();\n        \n        for (int i = 0; i < adjacencyList.size(); ++i) {\n            if (degrees[i] == 1) {\n                leaves.offer(i);\n            }\n        }\n        \n        return leaves;\n    }\n    \n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        if (edges1.length == 0 && edges2.length == 0) return 1;\n        if (edges1.length == 0 || edges2.length == 0) return 2;\n        \n        int diameter1 = treeDiameter(edges1);\n        int diameter2 = treeDiameter(edges2);\n        \n        List<Integer> centers1 = findTreeCenters(edges1);\n        List<Integer> centers2 = findTreeCenters(edges2);\n        \n        int minDiameter = Integer.MAX_VALUE;\n        \n        for (int center1 : centers1) {\n            for (int center2 : centers2) {\n                int newDiameter = Math.max(Math.max(diameter1, diameter2), (diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1);\n                minDiameter = Math.min(minDiameter, newDiameter);\n            }\n        }\n        \n        return minDiameter;\n    }\n}\n",
    "submit_ts": 1719719970.0
}