{
    "username": "wei-qi-zheng",
    "submission": "\nuse std::{collections::VecDeque, usize};\nimpl Solution {\n    pub fn shortest_distance_after_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut node_graph = Vec::with_capacity(n as usize);\n        let mut min_route = Vec::with_capacity(n as usize);\n        for i in 1..=n {\n            let adj_matrix = vec![i];\n            node_graph.push(adj_matrix);\n            min_route.push(i - 1);\n        }\n        let mut result = Vec::with_capacity(queries.len());\n        for query in queries {\n            // println!(\"query {:?}\", query);\n            node_graph[query[0] as usize].push(query[1]);\n            let first_pos = min_route\n                .binary_search(&query[0])\n                .unwrap_or_else(|item| usize::MAX);\n            let second_pos = min_route\n                .binary_search(&query[1])\n                .unwrap_or_else(|item| usize::MAX);\n            if first_pos != usize::MAX && second_pos != usize::MAX {\n                let len = min_route.len();\n                min_route.copy_within(second_pos..len, first_pos + 1);\n                min_route.resize(min_route.len() - (second_pos - first_pos - 1), 0);\n                // println!(\n                //     \"first_pos {first_pos} second_pos {second_pos} min_route {:?}\",\n                //     min_route\n                // );\n                result.push(min_route.len() as i32 - 1);\n            } else if first_pos == usize::MAX && second_pos == usize::MAX {\n                // println!(\"nothing changed\");\n                result.push(min_route.len() as i32 - 1);\n            } else {\n                // println!(\"run bfs\");\n                // bfs\n                let mut step = 0;\n                let mut bfs_queue = VecDeque::new();\n                let mut new_queue = VecDeque::new();\n                let mut visited = vec![false; n as usize];\n                let mut prev_node = vec![-1; n as usize];\n                bfs_queue.push_back(0);\n                visited[0] = true;\n                'bfs_loop: loop {\n                    step += 1;\n                    while let Some(node) = bfs_queue.pop_front() {\n                        for &neighbor in &node_graph[node as usize] {\n                            if !visited[neighbor as usize] {\n                                prev_node[neighbor as usize] = node;\n                                if neighbor == n - 1 {\n                                    result.push(step);\n                                    break 'bfs_loop;\n                                }\n                                visited[neighbor as usize] = true;\n                                new_queue.push_back(neighbor);\n                            }\n                        }\n                    }\n                    std::mem::swap(&mut bfs_queue, &mut new_queue);\n                }\n                min_route.clear();\n                let mut prev = n - 1;\n                min_route.push(n - 1);\n                while prev != 0 {\n                    prev = prev_node[prev as usize];\n                    min_route.push(prev);\n                }\n                min_route.reverse();\n                // println!(\"after bfs {:?}\", min_route);\n            }\n        }\n        result\n    }\n}",
    "submit_ts": "1722742005",
    "subm_id": "552341901"
}