{
    "username": "synchro9z",
    "submission": "class Solution {\npublic:\n    // void helper(const string& target, int loc, int cost, const unordered_map<int, unordered_map<string, int>>& word_bank, vector<int>& min_cost) {\n    //     if (loc != 0) {\n    //         if (min_cost[loc] != -1 && cost >= min_cost[loc]) {\n    //             return;\n    //         }\n    //         min_cost[loc] = cost;\n    //         if (loc == target.length()) return;\n    //     }\n    //     int c = target[loc] - 'a';\n    //     if (!word_bank.contains(c)) {\n    //         return;\n    //     }\n    //     for (const auto& [word, word_cost] : word_bank.at(c)) {\n    //         bool match = true;\n    //         for (int j = 0; j < word.length(); ++j) {\n    //             if (target[loc + j] != word[j]) {\n    //                 match = false;\n    //                 break;\n    //             }\n    //         }\n    //         if (match) {\n    //             helper(target, loc + word.length(), cost + word_cost, word_bank, min_cost);\n    //         }\n    //     }\n    // }\n\n    // int minimumCost(const string& target, const vector<string>& words, const vector<int>& costs) {\n    //     vector<int> min_cost(target.length() + 1, -1);\n    //     unordered_map<int, unordered_map<string, int>> word_bank;\n        // for (int i = 0; i < words.size(); ++i) {\n        //     const auto& word = words[i];\n        //     int c = word[0] - 'a';\n        //     if (!word_bank.contains(c)) word_bank[c] = unordered_map<string, int>();\n        //     if (word_bank[c].contains(word)) word_bank[c][word] = min(word_bank[c][word], costs[i]);\n        //     else word_bank[c][word] = costs[i];\n        // }\n    //     helper(target, 0, 0, word_bank, min_cost);\n    //     return min_cost.back();\n    // }\n\n    int minimumCost(const string& target, const vector<string>& words, const vector<int>& costs) {\n        int n = target.size();\n        vector<int> dp(n+1, -1);\n        dp[0] = 0;\n\n        unordered_map<int, unordered_map<string, int>> word_bank;\n        for (int i = 0; i < words.size(); ++i) {\n            const auto& word = words[i];\n            int c = word[word.length()-1] - 'a';\n            if (!word_bank.contains(c)) word_bank[c] = unordered_map<string, int>();\n            if (word_bank[c].contains(word)) word_bank[c][word] = min(word_bank[c][word], costs[i]);\n            else word_bank[c][word] = costs[i];\n        }\n\n        for (int i = 1; i <= n; ++i) {\n            int c = target[i-1] - 'a';\n            if (!word_bank.contains(c)) continue;\n            for (const auto& [word, word_cost]: word_bank.at(c)) {\n                int m = word.length();\n                if (m > i) continue;\n                if (dp[i-m] != -1) {\n                    if (dp[i] == -1 || dp[i-m]+ word_cost < dp[i]) {\n                        if (target.substr(i - m, m) == word) {\n                            // cout << i << \" \" << m << \" \" << word << endl;\n                            if (dp[i] == -1) dp[i] = dp[i-m] + word_cost;\n                            else dp[i] = min(dp[i], dp[i-m]+ word_cost);\n                        }\n                    }\n                }\n            }\n        }\n        for (auto d: dp) cout << d;\n        return dp.back();\n    }\n\n};",
    "submit_ts": "1720323719",
    "subm_id": "1312382376"
}