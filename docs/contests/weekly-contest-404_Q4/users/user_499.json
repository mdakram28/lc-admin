{
    "username": "nqvr",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        class Node:\n            def __init__(self, v):\n                self.v = v\n                self.children = []   # list[int]\n        \n        def helper(edges):\n            V = len(edges) + 1\n            G = [[] for _ in range(V)]\n            for u, v in edges:\n                G[u].append(v)\n                G[v].append(u)\n            \n            tree = [Node(u) for u in range(V)]\n\n            visited = [False for u in range(V)]\n\n\n            root = 0\n            visited[root] = True\n            q = deque([root])\n            while q:\n                u = q.popleft()\n\n                for v in G[u]:\n                    if not visited[v]:\n                        tree[u].children.append(v)\n                        visited[v] = True\n                        q.append(v)\n\n\n            def longest(root):\n                # returns [oneway, complete]\n                if not tree[root].children:\n                    return [1, 1]\n                \n                L = [longest(v) for v in tree[root].children]\n                L1 = [e[0] for e in L]\n                L2 = [e[1] for e in L]\n\n                A = max(L1) + 1\n\n                B = max(L2)\n                B = max(A, B)\n                L1.sort()\n                B = max(B, L1[-1])\n                if len(L1) >= 2:\n                    B = max(L1[-1] + L1[-2] + 1, B)\n                # print(root, A, B)\n                return [A, B]\n\n            \n            B = longest(root)[1] - 1\n            if B % 2 == 0:\n                return [B // 2, B // 2]\n            return [B // 2, B - B // 2]\n\n        x1, x2 = helper(edges1)\n        y1, y2 = helper(edges2)\n\n        \n        return max(x2 + y2 + 1, x1 + x2, y1 + y2)\n    \n    ",
    "submit_ts": 1719718857.0
}