{
    "username": "megaspazz",
    "submission": "class Solution {\n    private static final int INF = 999_999_999;\n    \n    public int minimumCost(String target, String[] words, int[] costs) {\n        final int N = target.length();\n        \n        SubHashMulti sh = new SubHashMulti(target);\n        \n        HashMap<Long, Integer> hashToCost = new HashMap<>();\n        for (int i = 0; i < words.length; ++i) {\n            SubHashMulti tmp = new SubHashMulti(words[i]);\n            long h = makeHash(tmp.sub(0, words[i].length()));\n            int prevCost = hashToCost.getOrDefault(h, INF);\n            hashToCost.put(h, Math.min(costs[i], prevCost));\n        }\n        \n        HashSet<Integer> checkLens = new HashSet<>();\n        for (String w : words) {\n            checkLens.add(w.length());\n        }\n        \n        int[] dp = new int[N + 1];\n        Arrays.fill(dp, INF);\n        dp[0] = 0;\n        for (int i = 0; i < N; ++i) {\n            for (int len : checkLens) {\n                if (i + len > N) {\n                    continue;\n                }\n                long h = makeHash(sh.sub(i, i + len));\n                Integer c = hashToCost.get(h);\n                if (c == null) {\n                    continue;\n                }\n                dp[i + len] = Math.min(dp[i + len], dp[i] + c);\n            }\n        }\n        if (dp[N] >= INF) {\n            return -1;\n        }\n        return dp[N];\n    }\n    \n    private static long makeHash(long[] h) {\n        return (h[0] << 32) | h[1];\n    }\n    \n    /**\n\t * Computes multiple polynomial hashes to do fast equality checks.\n\t * Excluding collisions, two subarrays are considered equal if their hashes by the `sub` function are equal.\n\t * \n\t * To reduce collisions, add new distinct primes to `P` (modulo) and `K` (base), but it will cause a performance penalty.\n\t * Note that the choices of P and K must not exceed 2147483647, e.g. it must fit within a signed 32-bit integer.\n\t * \n\t * Some additional pairs to consider:\n\t *   - P = 2122331213, K = 104717\n\t *   - P = 2124749677, K = 104711\n\t * \n\t * NOTE:  If only a single value in `P` is needed, consider using SubHash instead.\n\t * NOTE:  It is NOT hack-resistant!\n\t */\n\tpublic static class SubHashMulti {\n\t\tprivate static final int[] P = {2131131137, 2147483647};\n\t\tprivate static final int[] K = {104723, 104729};\n\n\t\tprivate static final int HASHES = P.length;\n\n\t\tprivate static final int MAX_LEN = 2_000_002;\n\n\t\tprivate static int UPTO = 1;\n\t\tprivate static long[][] POW = new long[HASHES][MAX_LEN];\n\t\tprivate static long[][] INV = new long[HASHES][MAX_LEN];\n\t\tstatic {\n\t\t\tfor (int j = 0; j < HASHES; ++j) {\n\t\t\t\tPOW[j][0] = 1;\n\t\t\t\tPOW[j][1] = K[j];\n\t\t\t\tINV[j][0] = 1;\n\t\t\t\tINV[j][1] = modInverse(K[j], P[j]);\n\t\t\t}\n\t\t}\n\n\t\tprivate static void loadPows(int upper) {\n\t\t\tfor (int j = 0; j < HASHES; ++j) {\n\t\t\t\tfor (int i = UPTO + 1; i <= upper; ++i) {\n\t\t\t\t\tPOW[j][i] = POW[j][i - 1] * POW[j][1] % P[j];\n\t\t\t\t\tINV[j][i] = INV[j][i - 1] * INV[j][1] % P[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tUPTO = Math.max(UPTO, upper);\n\t\t}\n\n\t\tprivate final long[] S;\n\t\tprivate final long[][] H;\n\n\t\tpublic SubHashMulti(long[] x) {\n\t\t\tloadPows(x.length);\n\n\t\t\tS = x;\n\t\t\tH = new long[HASHES][S.length + 1];\n\t\t\tfor (int j = 0; j < HASHES; ++j) {\n\t\t\t\tfor (int i = 0; i < S.length; ++i) {\n\t\t\t\t\tH[j][i + 1] = (H[j][i] + S[i] * POW[j][i]) % P[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic SubHashMulti(int[] x) {\n\t\t\tthis(toLongArray(x));\n\t\t}\n\n\t\tpublic SubHashMulti(char[] x) {\n\t\t\tthis(toLongArray(x));\n\t\t}\n\n\t\tpublic SubHashMulti(String x) {\n\t\t\tthis(x.toCharArray());\n\t\t}\n\n\t\tpublic long[] sub(int loInclusive, int hiExclusive) {\n\t\t\tlong[] hash = new long[HASHES];\n\t\t\tfor (int j = 0; j < HASHES; ++j) {\n\t\t\t\thash[j] = (H[j][hiExclusive] + P[j] - H[j][loInclusive]) * INV[j][loInclusive] % P[j];\n\t\t\t}\n\t\t\treturn hash;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn S.length;\n\t\t}\n\n\t\tprivate static long[] toLongArray(char[] x) {\n\t\t\tlong[] arr = new long[x.length];\n\t\t\tfor (int i = 0; i < x.length; ++i) {\n\t\t\t\tarr[i] = x[i];\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tprivate static long[] toLongArray(int[] x) {\n\t\t\tlong[] arr = new long[x.length];\n\t\t\tfor (int i = 0; i < x.length; ++i) {\n\t\t\t\tarr[i] = x[i];\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\t/**\n\t\t * Computes the value of (b ^ e) % mod.\n\t\t */\n\t\tprivate static long modPow(long b, long e, long mod) {\n\t\t\tlong p = b;\n\t\t\tlong ans = 1;\n\t\t\twhile (e > 0) {\n\t\t\t\tif ((e & 1) == 1) {\n\t\t\t\t\tans = ans * p % mod;\n\t\t\t\t}\n\t\t\t\tp = p * p % mod;\n\t\t\t\te >>= 1;\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\n\t\t/**\n\t\t * Computes the modular inverse, such that: ak % MOD = 1, for some k.\n\t\t * See this page for details:  http://rosettacode.org/wiki/Modular_inverse\n\t\t */\n\t\tpublic static long modInverse(long a, long mod) {\n\t\t\treturn modPow(a, mod - 2, mod);\n\t\t}\n\t}\n}",
    "submit_ts": "1720320687",
    "subm_id": "1312301737"
}