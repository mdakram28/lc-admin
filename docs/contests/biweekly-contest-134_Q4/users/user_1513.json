{
    "username": "power1011",
    "submission": "using i64 = int64_t;\nstruct tree_t\n{\n    vector<i64> a;\n    int nn;\n    tree_t(int n): a(n*4, ~i64(0))\n    {\n        for(nn=1;nn<n;nn*=2);\n    }\n    void modify(int l,int r,int q,int val, int v)\n    {\n        if(l+1==r)\n        {\n            a[v] = val;\n            return;\n        }\n        int m = (l+r)/2;\n        int lc = 2*v;\n        int rc = 2*v+1;\n        if(q<m)\n        {\n            modify(l,m,q,val,lc);\n        }\n        else\n        {\n            modify(m,r,q,val,rc);\n        }\n        a[v] = a[lc] & a[rc];\n    }\n    void modify(int q,int val)\n    {\n        modify(0, nn, q, val, 1);\n    }\n    i64 query(int l,int r, int ql,int qr,int v) const\n    {\n        if(ql<=l && r<=qr)\n        {\n            return a[v];\n        }\n        int m = (l+r)/2;\n        int lc = 2*v;\n        int rc = 2*v+1;\n        i64 ans = ~i64(0);\n        if(ql < m)\n        {\n            ans &= query(l,m,ql,qr,lc);\n        }\n        if(m < qr)\n        {\n            ans &= query(m,r,ql,qr,rc);\n        }\n        return ans;\n    }\n    i64 query(int ql,int qr) const\n    {\n        return query(0, nn, ql, qr, 1);\n    }\n};\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        // k = 1\n        // 0 0 0 1 1 1 0 1 0\n        // 1 2 3 3 3 3 4 4 5\n        // 3 * 4 / 2 + 1 * 2 / 2 + 0 * 1 /2\n\n        // k = 0\n        // 0 0 0 1 1 1 0 1 0\n        // 1 2 3 3 3 3 4 4 5\n        // all pairs - the answer above\n        \n        // Andsum of [l, r] = nums[l] & nums[l+1] ... & nums[r]\n        // Andsum of [l+1, r] >= Andsum of [l, r] >= Andsum of [l, r+1]\n        // for each l, we find the r1 such that Andsum(l, r1-1) > k and Andsum(l, r1) == k\n        //                     the r2 such that Andsum(l, r2) == k and Andsum(l, r2+1) < k\n        // with binary search and calulate Andsum(l, r) with segment tree\n        \n        i64 n = nums.size();\n        tree_t tree(n);\n        for(int i=0;i<n;++i)\n        {\n            tree.modify(i, nums[i]);\n        }\n        vector<int> index(n);\n        iota(index.begin(), index.end(), 0);\n        i64 ans = 0;\n        for(i64 l = 0;l < n;++l)\n        {\n            if(nums[l] < k)\n            {\n                continue;\n            }\n            // for(int r = l; r< n;++r)\n            // {\n            //     cout << \"123:\" << l << \" \" << r<<\" \" << tree.query(l, r+1) << \"\\n\";\n            // }\n            auto comp = [&l,&tree, &k](int v, const vector<int>&){\n                return tree.query(l, v+1) > k;\n            };\n            auto comp2 = [&l,&tree, &k](const vector<int>&, int v){\n                return k > tree.query(l, v+1);\n            };\n            auto lt = std::lower_bound(index.begin()+l, index.end(), vector<int>{}, comp);\n            auto rt = std::upper_bound(index.begin()+l, index.end(), vector<int>{}, comp2);\n            // cout << l << \" \" << lt - index.begin() << \" \" << rt - index.begin() << \"\\n\";\n            ans += rt - lt;\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1720281344",
    "subm_id": "1311821698"
}