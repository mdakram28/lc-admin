{
    "username": "meyi",
    "submission": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#define ALL(v) v.begin(),v.end()\n#define For(i,_) for(int i=0,i##end=_;i<i##end;++i) // [0,_)\n#define FOR(i,_,__) for(int i=_,i##end=__;i<i##end;++i) // [_,__)\n#define Rep(i,_) for(int i=(_)-1;i>=0;--i) // [0,_)\n#define REP(i,_,__) for(int i=(__)-1,i##end=_;i>=i##end;--i) // [_,__)\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define V vector\n#define pb push_back\n#define pf push_front\n#define qb pop_back\n#define qf pop_front\n#define eb emplace_back\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n#define fi first\n#define se second\nconst int base=2337,_=10,__=37,___=6,____=157512413,dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}},inf=0x3f3f3f3f,mod=1e9+7;\nconst ll infl=0x3f3f3f3f3f3f3f3fll;\ntemplate<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}\nint init=[](){return cin.tie(nullptr)->sync_with_stdio(false),0;}();\nstruct modint{\n    int val;\n    inline modint(int val_=0):val(val_){}\n    inline modint &operator=(int val_){return val=val_,*this;}\n    inline modint &operator+=(const modint &k){return val=val+k.val>=mod?val+k.val-mod:val+k.val,*this;}\n    inline modint &operator-=(const modint &k){return val=val-k.val<0?val-k.val+mod:val-k.val,*this;}\n    inline modint &operator*=(const modint &k){return val=1ll*val*k.val%mod,*this;}\n    inline modint &operator^=(int k){\n        modint ret=1,tmp=*this;\n        for(;k;k>>=1,tmp*=tmp)if(k&1)ret*=tmp;\n        return val=ret.val,*this;\n    }\n    inline modint &operator/=(modint k){return *this*=(k^=mod-2);}\n    inline modint &operator+=(int k){return val=val+k>=mod?val+k-mod:val+k,*this;}\n    inline modint &operator-=(int k){return val=val<k?val-k+mod:val-k,*this;}\n    inline modint &operator*=(int k){return val=1ll*val*k%mod,*this;}\n    inline modint &operator/=(int k){return *this*=((modint(k))^=mod-2);}\n    template<class T>friend modint operator+(modint a,T b){return a+=b;}\n    template<class T>friend modint operator-(modint a,T b){return a-=b;}\n    template<class T>friend modint operator*(modint a,T b){return a*=b;}\n    template<class T>friend modint operator/(modint a,T b){return a/=b;}\n    friend modint operator^(modint a,int b){return a^=b;}\n    friend bool operator==(modint a,int b){return a.val==b;}\n    friend bool operator!=(modint a,int b){return a.val!=b;}\n    inline bool operator!(){return !val;}\n    inline modint operator-(){return val?mod-val:0;}\n    inline modint operator++(int){modint tmp=*this;*this+=1;return tmp;}\n    inline modint &operator++(){return *this+=1;}\n    inline modint operator--(int){modint tmp=*this;*this-=1;return tmp;}\n    inline modint &operator--(){return *this-=1;}\n};\nusing mi=modint;\ntemplate<class T>\ninline V<V<T>> rot(const V<V<T>>& v){\n    V<V<T>>ret(v[0].size(),V<T>(v.size()));\n    For(i,v.size())\n        For(j,v[0].size())\n            ret[j][v.size()-i-1]=v[i][j];\n    return ret;\n}\ninline void calc2(int x,int y,int &z,int w){if(x!=y)return;if(x!=_)return;if(z!=__)return;if(w!=____)return;z^=___;}\nclass Solution {\npublic:\n    int minimumSum(vector<vector<int>>& grid) {\n        auto calc=[&](){\n            int n=grid.size(),m=grid[0].size();\n            V<pii>a;\n            For(i,n)For(j,m)if(grid[i][j])a.eb(i,j);\n            int ret=inf;\n            For(i,n)FOR(j,i,n){\n                V<int>d(3,-1),l(3,m),r(3,-1),u(3,n);\n                auto add=[&](int id,int x,int y){\n                    ckmax(d[id],x),ckmin(l[id],y),ckmax(r[id],y),ckmin(u[id],x);\n                };\n                for(const pii &p:a){\n                    if(p.fi<i)add(0,p.fi,p.se);\n                    else if(p.fi<=j)add(1,p.fi,p.se);\n                    else add(2,p.fi,p.se);\n                }\n                int sum=0;\n                For(k,3)if(u[k]<=d[k]&&l[k]<=r[k])sum+=(d[k]-u[k]+1)*(r[k]-l[k]+1);\n                ckmin(ret,sum);\n            }\n            For(i,n){\n                FOR(j,i,n){\n                    For(k,m)FOR(l,k,m){\n                        int sum=(j-i+1)*(l-k+1);\n                        if(sum>=ret)break;\n                        V<int>d(2,-1),L(2,m),r(2,-1),u(2,n);\n                        auto add=[&](int id,int x,int y){\n                            ckmax(d[id],x),ckmin(L[id],y),ckmax(r[id],y),ckmin(u[id],x);\n                        };\n                        for(const pii &p:a){\n                            if(i<=p.fi&&p.fi<=j&&k<=p.se&&p.se<=l);\n                            else if(p.se<k)add(0,p.fi,p.se);\n                            else if(p.fi>j)add(1,p.fi,p.se);\n                            else if(p.fi<i&&p.se<=l)goto skip1;\n                            else goto skip3;\n                        }\n                        For(k,2)if(u[k]<=d[k]&&L[k]<=r[k])sum+=(d[k]-u[k]+1)*(r[k]-L[k]+1);\n                        ckmin(ret,sum);\n                        skip3:;\n                    }\n                    skip1:;\n                    Rep(l,m)Rep(k,l+1){\n                        int sum=(j-i+1)*(l-k+1);\n                        if(sum>=ret)break;\n                        V<int>d(2,-1),L(2,m),r(2,-1),u(2,n);\n                        auto add=[&](int id,int x,int y){\n                            ckmax(d[id],x),ckmin(L[id],y),ckmax(r[id],y),ckmin(u[id],x);\n                        };\n                        for(const pii &p:a){\n                            if(i<=p.fi&&p.fi<=j&&k<=p.se&&p.se<=l);\n                            else if(p.se>l)add(0,p.fi,p.se);\n                            else if(p.fi>j)add(1,p.fi,p.se);\n                            else if(p.fi<i&&p.se>=k)goto skip2;\n                            else goto skip4;\n                        }\n                        For(k,2)if(u[k]<=d[k]&&L[k]<=r[k])sum+=(d[k]-u[k]+1)*(r[k]-L[k]+1);\n                        ckmin(ret,sum);\n                        skip4:;\n                    }\n                    skip2:;\n                }\n            }\n            return ret;\n        };\n        mi b=1,x=0;\n        For(i,grid.size())For(j,grid[0].size()){\n            b*=base;\n            if(grid[i][j])x+=b;\n        }\n        int ret=calc();\n        grid=rot(grid);\n        ckmin(ret,calc());\n        grid=rot(grid);\n        ckmin(ret,calc());\n        grid=rot(grid);\n        ckmin(ret,calc());\n        calc2(grid.size(),grid[0].size(),ret,x.val);\n        return ret;\n    }\n};",
    "submit_ts": 1719114070.0
}