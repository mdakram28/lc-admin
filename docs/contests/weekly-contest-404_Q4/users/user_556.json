{
    "username": "fenwick-tree",
    "submission": "class Solution {\npublic:\n    pair<int, int> bfs(int src, vector<int> adj[], int n){\n        pair<int, int> ans;\n        queue<pair<int, int>> q;\n        q.push({src, 0});\n        vector<int> vis(n+1, 0);\n        vis[src] = 1;\n\n        while(!q.empty()){\n            ans = q.front();\n            int node = ans.first;\n            int dis = ans.second;\n            q.pop();\n\n            for(auto it : adj[node]){\n                if(!vis[it]){\n                    vis[it] = 1;\n                    q.push({it, dis+1});\n                }\n            }\n        }\n        \n        return ans;\n    }\n    \n    int findDia(vector<vector<int>> A){\n        int n = A.size()+1;\n        vector<int> adj[n+2];  \n\n        for (const auto& edge : A) {\n            int u = edge[0]+1, v = edge[1]+1;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n\n        pair<int, int> end1 = bfs(1, adj, n);\n        pair<int, int> end2 = bfs(end1.first,adj, n);\n        return end2.second;\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& A, vector<vector<int>>& B) {\n        int d1 = findDia(A);\n        int d2 = findDia(B);\n        \n        int ans = max({d1, d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1});\n        \n        return ans;\n    }\n};",
    "submit_ts": 1719719425.0
}