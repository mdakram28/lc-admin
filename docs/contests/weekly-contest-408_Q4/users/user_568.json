{
    "username": "anshu613402",
    "submission": "#define ss second\n#define ff first\n#define pb push_back\nclass Solution {\n\npublic:\n    int bfs(const vector<vector<int>>& graph, int s, int t1, int t2, int nodes) {\n        queue<int> q;\n        vector<bool> vis(nodes, false);\n        q.push(s);\n        vis[s] = true;\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            for (int v : graph[u]) {\n                if (!vis[v]) {\n                    q.push(v);\n                    vis[v] = true;\n                }\n            }\n        }\n        return vis[t1] || vis[t2];\n    }\n    bool canReachCorner(int X, int Y, const vector<vector<int>>& circles) {\n        int nc = circles.size();\n    vector<pair<pair<int, int>, int>> cd(nc);\n    vector<vector<int>> g(nc + 4);\n\n    for (int i = 0; i < nc; ++i) {\n        cd[i] = {{circles[i][0], circles[i][1]}, circles[i][2]};\n    }\n    for (int i = 0; i < nc; ++i) {\n        const auto& [c, r] = cd[i];\n        if (c.ff <= r) {\n            g[nc].pb(i);\n            g[i].pb(nc);\n        }\n        if (X - c.ff <= r) {\n            g[nc + 2].pb(i);\n            g[i].pb(nc + 2);\n        }\n        if (c.ss <= r) {\n            g[nc + 1].pb(i);\n            g[i].pb(nc + 1);\n        }\n        if (Y - c.ss <= r) {\n            g[nc + 3].pb(i);\n            g[i].pb(nc + 3);\n        }\n        for (int j = i + 1; j < nc; ++j) {\n            const auto& [c2, r2] = cd[j];\n            double distance = sqrt(pow(c.ff - c2.ff, 2) + pow(c.ss - c2.ss, 2));\n            int rads = r + r2;\n            if (rads >= distance) {\n                g[i].pb(j);\n                g[j].pb(i);\n            }\n        }\n    }\n    int is = 0;\n    is = max(is, bfs(g, nc, nc + 1, nc + 2, nc + 4));\n    is = max(is, bfs(g, nc + 3, nc + 2, nc + 1, nc + 4));\n    return !is;\n    }\n};",
    "submit_ts": "1722137933",
    "subm_id": "1335777640"
}