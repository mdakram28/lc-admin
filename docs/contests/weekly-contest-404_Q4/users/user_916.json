{
    "username": "lonely_nights_with_bruce",
    "submission": "\nstruct Node{\n  int node;\n  int farthest;\n};\nclass Solution {\n    \n    \nprivate:\n    \n   Node bfs(int root, vector<vector<int>>&graph, vector<bool>&vis){\n      \n       \n       queue<int> q;\n       q.push(root);\n       \n       Node ans;\n       \n       int dist = 0, farthest_dist = 0;\n       \n       while(!q.empty()){\n           int sz = q.size();\n           \n           \n           while(sz--){\n               int x = q.front();\n               \n               if(dist>farthest_dist){\n                   farthest_dist = dist;\n                   ans.node = x;\n               }\n               q.pop();\n               vis[x] = true;\n               \n               for(auto&i:graph[x]) if(!vis[i]) q.push(i);\n           }\n           \n           dist++;\n           \n           \n       }\n       \n       ans.farthest = farthest_dist;\n       \n       \n       return ans;\n       \n   }\n    \npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& arr1, vector<vector<int>>& arr2) {\n        \n        \n        int n = arr1.size(), m = arr2.size();\n    \n        \n        vector<vector<int>> graph1(n+1), graph2(m+1);\n        \n        auto connect = [&](int u, int v, vector<vector<int>>&g){\n          g[u].push_back(v);\n            g[v].push_back(u);\n        };\n        \n        \n        for(auto&i:arr1) connect(i[0], i[1], graph1);\n        \n        for(auto&i:arr2) connect(i[0], i[1], graph2);\n        \n        vector<bool>vis(n+1, false);\n        \n        Node dia1_right, dia2_right;\n        \n        dia1_right.farthest = 0, dia2_right.farthest = 0;\n        \n//         if(n>0){\n//             Node dia1_left = bfs(0, graph1, vis);\n        \n//             for(int i =0;i<=n;i++) vis[i] = false;\n        \n//             dia1_right = bfs(dia1_left.node, graph1, vis);\n//         }\n        \n//         if(m>0){\n//              for(int i = 0;i<=n;i++) vis[i] = false;\n        \n//              Node dia2_left = bfs(0, graph2, vis);\n        \n//              for(int i =0;i<=n;i++) vis[i] = false;\n        \n//               dia2_right = bfs(dia2_left.node, graph2, vis);\n//         }\n        \n        auto dfs = [&](const vector<vector<int>>&graph, int node, int &far){\n            int n_ = graph.size();\n            vector<int> distance(n_,-1);\n            function<void(int,int)> dfs2 = [&](int node, int dist){\n                distance[node] = dist;\n                if(dist>distance[far]) far = node;\n                \n                for(auto&child:graph[node]){\n                    if(distance[child] == -1) dfs2(child, dist+1);\n                }\n            };\n            far = node;\n            dfs2(node, 0);\n            return distance[far];\n        };\n        \n        int n1 = 0;\n        dfs(graph1, 0, n1);\n        int d1 = dfs(graph1, n1, n1);\n        \n        int n2 = 0;\n        dfs(graph2, 0, n2);\n        int d2 = dfs(graph2, n2, n2);\n        \n        return max({d1, d2, (d1+1)/2 + (d2+1)/2 + 1});\n        \n       \n//         int dia1 = 0;\n        \n//         if(n>0) dia1 = dia1_right.farthest;\n        \n//         int dia2 = 0;\n        \n//         if(m>0) dia2 = dia2_right.farthest;\n        \n//         return max({dia1, dia2, (dia1+1)/2 + (dia2+1)/2 + 1});\n        \n        \n       \n        \n      //  return sex;\n        \n    }\n};",
    "submit_ts": "1719719916",
    "subm_id": "1304453891"
}