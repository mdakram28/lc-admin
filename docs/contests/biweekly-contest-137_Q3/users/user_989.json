{
    "username": "varangrai",
    "submission": "class Solution {\npublic:\n    vector<vector<vector<int>>> createMaxArray(const vector<vector<int>>& board) {\n        int n = board.size();\n        int m = board[0].size();\n\n        vector<vector<vector<int>>> arr(n, vector<vector<int>>(m, vector<int>(2, INT_MIN)));\n\n        for (int j = 0; j < m; ++j) {\n            arr[0][j][0] = board[0][j];\n            for (int i = 1; i < n; ++i) {\n                arr[i][j][0] = max(arr[i - 1][j][0], board[i][j]);\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            arr[i][0][1] = board[i][0];\n            for (int j = 1; j < m; ++j) {\n                arr[i][j][1] = max(arr[i][j - 1][1], board[i][j]);\n            }\n        }\n\n        return arr;\n}\n    vector<vector<int>> verticalFlip(vector<vector<int>> board) {\n        int n = board.size();\n        for (int i = 0; i < n / 2; ++i) {\n            swap(board[i], board[n - i - 1]);\n        }\n        return board;\n    }\n\n    vector<vector<int>> horizontalFlip(vector<vector<int>> board) {\n        int n = board.size();\n        int m = board[0].size();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m / 2; ++j) {\n                swap(board[i][j], board[i][m - j - 1]);\n            }\n        }\n        return board;\n    }\n\n    vector<vector<int>> transposeMainDiagonal(vector<vector<int>> board) {\n        int n = board.size();\n        int m = board[0].size();\n        vector<vector<int>> result(m, vector<int>(n));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                result[j][i] = board[i][j];\n            }\n        }\n        return result;\n    }\n\n    vector<vector<int>> transposeAntiDiagonal(vector<vector<int>> board) {\n        int n = board.size();\n        int m = board[0].size();\n        vector<vector<int>> result(m, vector<int>(n));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                result[m - j - 1][n - i - 1] = board[i][j];\n            }\n        }\n        return result;\n    }\n\n    long long maximumValueSum(vector<vector<int>>& board) {\n        long long cand1 = maximumValueSumUtil(board);\n        long long cand2 = maximumValueSumUtil(verticalFlip(board));\n        long long cand3 = maximumValueSumUtil(horizontalFlip(board));\n        long long cand4 = maximumValueSumUtil(transposeAntiDiagonal(board));\n        long long cand5 = maximumValueSumUtil(transposeMainDiagonal(board));\n    \n        return max({cand1, cand2, cand3, cand4, cand5});\n\n    }\n    long long maximumValueSumUtil(vector<vector<int>> board) {\n        int n = board.size();\n        int m = board[0].size();\n\n        //vertical flip\n        //transpose along secondaty diagonal\n        // vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(3, INT_MIN)));\n        vector<vector<vector<int>>> arr = createMaxArray(board);\n        long long dp[n][m][4];\n\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < m; j++){\n                for(int k = 0; k <= 3; k++){\n                    dp[i][j][k] = LLONG_MIN;\n                    if(k == 0){\n                        dp[i][j][k] = 0;\n                    }\n                    else{\n                        vector<long long> cand;\n                        if(i-1 >=0){\n                            cand.push_back(dp[i-1][j][k]);\n                        }\n                        if(j - 1 >=0){\n                            cand.push_back(dp[i][j - 1][k]);\n                        }\n                        if(i - 1>=0 && j - 1>=0){\n                            cand.push_back(dp[i-1][j-1][k]);\n                            if(dp[i-1][j-1][k - 1]!=LLONG_MIN)\n                                cand.push_back(board[i][j] + dp[i-1][j-1][k - 1]);\n                        }\n\n                        if(k==1){\n                            cand.push_back(board[i][j]);\n                        }\n                        if(!cand.empty()){\n                            dp[i][j][k] = *max_element(cand.begin(), cand.end());\n                        }\n                    }\n\n                    if(k == 2 && i -1>=0 && j-1>=0){\n                        dp[i][j][k] = max(dp[i][j][k], (long long)arr[i-1][j][0] + (long long)arr[i][j-1][1]);\n                    }\n                }\n            }\n        }\n\n        return dp[n-1][m-1][3];\n    }\n};",
    "submit_ts": "1723909799",
    "subm_id": "1359206227"
}