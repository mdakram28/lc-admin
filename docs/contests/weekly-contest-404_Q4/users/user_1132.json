{
    "username": "ankii09102003",
    "submission": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <list>\n#include <queue>\nusing namespace std;\n\nclass Solution {\npublic:\n    pair<int, int> bfs(int node, unordered_map<int, list<int>>& adj) {\n        vector<bool> visited(adj.size(), false);\n        queue<pair<int, int>> q;\n        q.push({node, 0});\n        visited[node] = true;\n        \n        pair<int, int> farthest = {node, 0};\n        \n        while (!q.empty()) {\n            auto curr = q.front();\n            q.pop();\n            \n            for (int neighbor : adj[curr.first]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    q.push({neighbor, curr.second + 1});\n                    if (curr.second + 1 > farthest.second) {\n                        farthest = {neighbor, curr.second + 1};\n                    }\n                }\n            }\n        }\n        \n        return farthest;\n    } \n    \n    int findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        if (n == 1) return 0; // Special case for a single node\n        \n        vector<int> indegree(n, 0);\n        unordered_map<int, list<int>> adj;\n        \n        // Constructing the adjacency list\n        for (auto& edge : edges) {\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n            indegree[edge[0]]++;\n            indegree[edge[1]]++;\n        }\n        \n        queue<int> q;\n        for (int i = 0; i < n; ++i) {\n            if (indegree[i] == 1) {\n                q.push(i);\n            }\n        }\n        \n        int nodes = n;\n        while (nodes > 2) {\n            int inside = q.size();\n            for (int i = 0; i < inside; ++i) {\n                nodes--;\n                int leaf = q.front();\n                q.pop();\n                \n                for (int neighbor : adj[leaf]) {\n                    indegree[neighbor]--;\n                    if (indegree[neighbor] == 1) {\n                        q.push(neighbor);\n                    }\n                }\n            }\n        }\n        \n        vector<int> ans;\n        while (!q.empty()) {\n            ans.push_back(q.front());\n            q.pop();\n        }\n        \n        // If there's only one node left after trimming the leaves, return it\n        if (ans.empty()) {\n            ans.push_back(0); // In case of a single node scenario\n        }\n        \n        int start = ans[0];\n        \n        // Calculate height using BFS\n        vector<bool> visited(n, false);\n        queue<int> q2;\n        q2.push(start);\n        visited[start] = true;\n        int height = 0;\n        \n        while (!q2.empty()) {\n            int level_size = q2.size();\n            height++;\n            for (int i = 0; i < level_size; ++i) {\n                int node = q2.front();\n                q2.pop();\n                for (int neighbor : adj[node]) {\n                    if (!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        q2.push(neighbor);\n                    }\n                }\n            }\n        }\n        \n        return height - 1;\n    }\n    \n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n1 = edges1.size() + 1;\n        int n2 = edges2.size() + 1;\n        \n        int val1 = 0;\n        if (!edges1.empty()) {\n            val1 = findMinHeightTrees(n1, edges1);\n        }\n        \n        int val2 = 0;\n        if (!edges2.empty()) {\n            val2 = findMinHeightTrees(n2, edges2);\n        }\n        \n        // If both edges1 and edges2 are empty, return 0 (or handle as per requirement)\n        if (edges1.empty() && edges2.empty()) {\n            return 1;\n        }\n        \n        unordered_map<int, list<int>> adj;\n        \n        // Constructing the adjacency list for edges1\n        if (!edges1.empty()) {\n            for (auto& edge : edges1) {\n                adj[edge[0]].push_back(edge[1]);\n                adj[edge[1]].push_back(edge[0]);\n            }\n        }\n        \n        unordered_map<int, list<int>> adj2;\n        \n        // Constructing the adjacency list for edges2\n        if (!edges2.empty()) {\n            for (auto& edge : edges2) {\n                adj2[edge[0]].push_back(edge[1]);\n                adj2[edge[1]].push_back(edge[0]);\n            }\n        }\n        \n        pair<int, int> start;\n        pair<int, int> end;\n        int dia1 = 0;\n        \n        if (!edges1.empty()) {\n            start = bfs(0, adj); // Start BFS from node 0\n            end = bfs(start.first, adj); // Perform BFS from the farthest node found\n            dia1 = end.second; // Diameter of tree formed by edges1\n        }\n        \n        pair<int, int> start2;\n        pair<int, int> end2;\n        int dia2 = 0;\n        \n        if (!edges2.empty()) {\n            start2 = bfs(0, adj2); // Start BFS from node 0\n            end2 = bfs(start2.first, adj2); // Perform BFS from the farthest node found\n            dia2 = end2.second; // Diameter of tree formed by edges2\n        }\n        \n        // Diameter is the sum of minimum heights of both trees + 1\n        return max(val1 + val2 + 1, max(dia1, dia2));\n    }\n};\n",
    "submit_ts": "1719719043",
    "subm_id": "1304432382"
}