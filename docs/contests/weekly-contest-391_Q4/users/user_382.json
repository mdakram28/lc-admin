{
    "username": "samliu12",
    "submission": "#include <bits/stdc++.h>\n#ifdef DEBUG\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#endif\nusing namespace std;\ntypedef long long i64;\n// #define int long long\n\ni64 cross(pair<i64,i64>P,pair<i64,i64>Q,pair<i64,i64> R)//if return >0 then point R is upper of lineseg PQ else down\n        {\n            return  (Q.first-P.first)*(R.second-P.second)-(R.first-P.first)*(Q.second-P.second);\n        }\n    void hull(vector<pair<i64,i64> > &P,vector<pair<i64,i64> > &L,vector<pair<i64,i64> > &U)\n        {\n            int j=0,k=0,n=P.size();\n            sort(P.begin(),P.end());\n            U.resize(2*n);\n            L.resize(2*n);\n            for(int i=0;i<n;i++)\n             {\n                while(j>=2 && cross(L[j-2],L[j-1],P[i])<=0)//p[i] is making right turn we need left turn\n                    j--;\n                while(k>=2 && cross(U[k-2],U[k-1],P[i])>=0)//p[i] is making left turn we need right\n                    k--;\n                L[j++]=P[i];\n                U[k++]=P[i];\n            }\n            U.resize(k);\n            L.resize(j);\n        }\n    i64 fun(pair<i64,i64> P ,pair<i64,i64> Q)\n        {\n            return abs(P.first-Q.first)+abs(P.second-Q.second);\n        }\n\nclass Solution {\npublic:\n    int minimumDistance(vector<vector<int>>& _points) {\n\t\tint n = _points.size();\n\t\tvector<pair<i64,i64> >v,U,L;\t\n\t\tfor(int i=0;i<n;i++) v.push_back({_points[i][0], _points[i][1]});\n\t\tvector<pair<i64, i64>> cand;\n\t\tauto foo = [&]() -> int {\n\t\thull(v,L,U);\n\t\tint i=0,j,m;\n\t\tj=L.size()-1;\n\t\tm=U.size()-1;\n\t\ti64 dist=-1;\n\t\t// dbg(L, U);\n\t\twhile(i<m || j>0)\n\t\t{\n\t\t\tauto t = fun(U[i], L[j]);\n\t\t\tif (t > dist) {\n\t\t\t\tcand.clear();\n\t\t\t\tcand.push_back(U[i]);\n\t\t\t\tcand.push_back(L[j]);\n\t\t\t}\n\t\t\tdist=max(dist,t);\n\t\t\tif(i==m)\n\t\t\t\tj--;\n\t\t\telse if(j==0)\n\t\t\t\ti++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ( (U[i+1].second-U[i].second) * (L[j].first-L[j-1].first) > (L[j].second-L[j-1].second) * (U[i+1].first-U[i].first) )\n\t\t\t\ti++;\n\t\t\telse\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t\t};\n\n\t\tfoo();\n\t\tauto tt = cand;\n\t\tv.erase(find(v.begin(), v.end(), tt[0]));\n\t\tL.clear(), U.clear();\n\t\tint ans = foo();\n\t\tv.push_back(tt[0]);\n\t\tv.erase(find(v.begin(), v.end(), tt[1]));\n\t\tL.clear(), U.clear();\n\t\tans = min(ans, foo());\n\t\treturn ans;\n    }\n};"
}