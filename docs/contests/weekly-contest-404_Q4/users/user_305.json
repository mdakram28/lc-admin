{
    "username": "FFiona",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        import math\n        max_l1 = self.max_length(edges1)\n        max_l2 = self.max_length(edges2)\n        return max(math.ceil(max_l1/2) + 1 + math.ceil(max_l2/2), max(max_l1, max_l2))    \n    def max_length(self, edges):\n        if not edges:\n            return 0\n        n = len(edges) + 1\n        graph = {}\n        for i in range(n):\n            graph[i] = set()\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n        ml1, node1 = self.BFS_helper(graph, 0, n)\n        ans, node2 = self.BFS_helper(graph, node1, n)\n        return ans\n        \n    \n    def BFS_helper(self, graph, root, n):\n        import collections\n        distance = [-1 for _ in range(n)]\n        visited = set()\n        queue = collections.deque([])\n        distance[root] = 0\n        visited.add(root)\n        queue.append(root)\n        while queue:\n            node = queue.popleft()\n            for nxt in graph[node]:\n                if nxt in visited:\n                    continue\n                visited.add(nxt)\n                distance[nxt] = distance[node] + 1\n                queue.append(nxt)\n        ans = 0\n        for i in range(n):\n            if ans < distance[i]:\n                ans = distance[i]\n                ans_node = i\n        return ans, ans_node\n\n\n\n\n\n\n        ",
    "submit_ts": "1719717823",
    "subm_id": "1304401649"
}