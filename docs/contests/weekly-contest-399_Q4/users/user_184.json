{
    "username": "TZGkPxfrU1",
    "submission": "\nclass Solution {\npublic:\n    \nclass SegmentTree {\npublic:\n    vector<vector<int>> tree;\n    vector<int> nums;\n\n    SegmentTree(vector<int>& nums) {\n        this->nums = nums;\n        int n = nums.size();\n        int height = ceil(log2(n)) + 1;\n        int max_size = pow(2, height) - 1;\n        tree = vector<vector<int>>(max_size, vector<int>(4, 0));\n        build();\n    }\n\n    void build() {\n        buildUtil(0, 0, nums.size() - 1);\n    }\n\n    void buildUtil(int node, int start, int end) {\n        if (start == end) {\n            int val = max(0, nums[start]);\n            tree[node] = {0, 0, 0, val};\n        } else {\n            int mid = start + (end - start) / 2;\n            int left = 2 * node + 1;\n            int right = 2 * node + 2;\n            buildUtil(left, start, mid);\n            buildUtil(right, mid + 1, end);\n\n            \n            vector<int> curr(4);\n            curr[0] = max(\n                tree[left][0] + tree[right][0],\n                tree[left][2] + tree[right][3]\n            );\n            curr[1] = max(\n                tree[left][1] + tree[right][1],\n                tree[left][3] + tree[right][2]\n            );\n            curr[2] = max(\n                tree[left][2] + tree[right][1],\n                tree[left][0] + tree[right][2]\n            );\n            curr[3] = max(\n                tree[left][1] + tree[right][3],\n                tree[left][3] + tree[right][0]\n            );\n            \n            tree[node] = curr;\n        }\n    }\n\n    void update(int index, int val) {\n        updateUtil(0, 0, nums.size() - 1, index, val);\n    }\n\n    void updateUtil(int node, int start, int end, int idx, int val) {\n        if (start == end) {\n            val = max(0, val);\n            tree[node] = {0, 0, 0, val};\n        } else {\n            int left = 2 * node + 1;\n            int right = 2 * node + 2;\n            int mid = start + (end - start) / 2;\n            if (idx <= mid) {\n                updateUtil(left, start, mid, idx, val);\n            } else {\n                updateUtil(right, mid + 1, end, idx, val);\n            }\n            \n            vector<int> curr(4);\n            curr[0] = max(\n                tree[left][0] + tree[right][0],\n                tree[left][2] + tree[right][3]\n            );\n            curr[1] = max(\n                tree[left][1] + tree[right][1],\n                tree[left][3] + tree[right][2]\n            );\n            curr[2] = max(\n                tree[left][2] + tree[right][1],\n                tree[left][0] + tree[right][2]\n            );\n            curr[3] = max(\n                tree[left][1] + tree[right][3],\n                tree[left][3] + tree[right][0]\n            );\n            \n            tree[node] = curr;\n        }\n    }\n\n    int sumRange() {\n        return tree[0][3];\n    }\n};\n    \n    const int MOD = 1e9 + 7;\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        SegmentTree st(nums);\n        \n        long long ans = 0;\n        for(auto q: queries) {\n            int pos = q[0], newVal = q[1];\n            st.update(pos, newVal);\n            int res = st.sumRange();\n            ans += res;\n            ans %= MOD;\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": 1716695868.0
}