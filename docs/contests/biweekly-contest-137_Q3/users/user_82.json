{
    "username": "rvrty5",
    "submission": "template<class T>\nstruct Flow {\n    const T INF = numeric_limits<T>::max() >> 1;\n    struct Edge {\n        int nxt;\n        T cap, cost;\n        Edge(int to, T cp, T w)\n            :nxt(to), cap(cp), cost(w) {}\n    };\n    vector<Edge> e;\n    vector<vector<int>> g;\n    vector<T> dis;\n    vector<int> now, ins;\n    int n, f, t, o;\n    T maxflow, mincost;\n    Flow(int n, int maxEdge = 0)\n        :n(n), g(n), ins(n, 0) {\n        if (maxEdge) e.reserve(2 * maxEdge);\n    }\n    void add(int u, int v, T cap, T w) {\n        g[u].push_back((int) e.size());\n        e.emplace_back(v, cap, w);\n        g[v].push_back((int) e.size());\n        e.emplace_back(u, 0, -w);\n    }\n    bool S() {\n        dis.assign(n, INF);\n        vector<int> inq(n, 0);\n        queue<int> que; que.push(f);\n        dis[f] = 0;\n        inq[f] = 1;\n        while (que.size()) {\n            int x = que.front(); que.pop(); inq[x] = 0;\n            for (auto& p : g[x]) if (e[p].cap) {\n                auto& [y, cap, cost] = e[p];\n                if (dis[y] > dis[x] + cost) {\n                    dis[y] = dis[x] + cost;\n                    if (!inq[y]) {\n                        inq[y] = 1;\n                        que.push(y);\n                    }\n                }\n            }\n        }\n        return dis[t] != INF;\n    }\n    T D(int x, T flow) {\n        if (x == t) return flow;\n        ins[x] = 1;\n        T rest = flow;\n        for (auto& i = now[x]; i < g[x].size(); ++i) {\n            auto& p = g[x][i];\n            auto& [y, cap, w] = e[p];\n            if (!ins[y] && cap && dis[y] == dis[x] + w) {\n                T incr = D(y, min(rest, cap));\n                if (incr == 0) dis[y] = 0;\n                e[p].cap -= incr, e[p ^ 1].cap += incr;\n                rest -= incr;\n                mincost += incr * w;\n                if (rest == 0) break;\n            }\n        }\n        ins[x] = 0;\n        return flow - rest;\n    }\n    pair<T, T> q(int f, int t) {\n        this->f = f;\n        this->t = t;\n        maxflow = mincost = 0; T flow = 0;\n        while (S()) {\n            now.assign(n, 0);\n            while ((flow = D(f, INF))) {\n                maxflow += flow;\n            }\n        }\n        return {maxflow, mincost};\n    }\n};\nclass Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& a) {\n        int n = a.size(), m = a[0].size();\n        Flow<long long> g(n + m + 3);\n        int f = n + m, t = f + 1, o = t + 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                g.add(i, j + n, 1, -a[i][j]);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            g.add(f, i, 1, 0);\n        }\n        for (int i = 0; i < m; i++) {\n            g.add(i + n, t, 1, 0);\n        }\n\n        g.add(t, o, 3, 0);\n        return -g.q(f, o).second;\n    }\n};",
    "submit_ts": "1723907101",
    "subm_id": "1359090014"
}