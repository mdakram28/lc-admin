{
    "username": "pratikgupta1603",
    "submission": "#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;  // find_by_order, order_of_key \n#define ff first\n#define ss second\n#define ll long long\n#define pb push_back\n#define fl(i,n,m) for(int i=n;i<m;i++)\n#define pii pair<int,int>\n#define vi vector<int>\n#define print(a) for(auto &it:a) cout<<it<<\" \"; cout<<endl\n#define mii map<int,int>\n#define setbits(x) __builtin_popcountll(x)\n#define mp make_pair\n#define all(a) a.begin(),a.end()\n#define yes cout<<\"YES\"<<endl\n#define no cout<<\"NO\"<<endl\n \nbool isPrime(int n)\n{\n    if (n <= 1)  return false;\n    if (n <= 3)  return true;\n    if (n%2 == 0 || n%3 == 0) return false;\n    for (int i=5; i*i<=n; i=i+6)\n        if (n%i == 0 || n%(i+2) == 0)\n        return false;\n    return true;\n}\n \nint pw(ll int a, ll int b, ll int m) {\n    if(b==0) {\n        return 1;\n    }\n \n    if(b%2 == 0) {\n        ll int t = pw(a, (b/2), m);\n        return (1ll*t*t)%m;\n    }\n    else {\n        ll int t = pw(a, (b-1)/2, m);\n        t = (1ll*t*t)%m;\n        return (1ll*a*t)%m;\n    }\n}\n \nvoid seive(){\n    int n;\n    vector<int>prm;\n    bool is_prime[n + 1];\n    memset(is_prime, true, sizeof(is_prime));\n    is_prime[0]=is_prime[1] = false;\n    for (int p = 2; p * p <= n; p++) {\n        if (is_prime[p]) {\n            for (int i = p * p; i <= n; i += p) {\n                is_prime[i] = false;\n            }\n        }\n}\nfor (int i = 2; i <= n; i++) {\n    if (is_prime[i]) {\n        prm.pb(i);\n    }\n}\n//Used to find the multiplicity of prime factorization\n// \tfor(int i=0;i<n;i++){\n//\t\tfor(int j=0;j<prm.size();j++){\n//\t\t\tif(v[i]%prm[j]==0){\n//\t\t\t\twhile(v[i]%prm[j]==0){\n//\t\t\t\t\t[i]/=prm[j];\n//\t\t\t\t}\n//\t\t\t\tmp1[prm[j]]++;\n//\t\t\t}\n//\t\t}\n//\t}\n}\n \nvoid init(){ // used to find the prime ,but also the smallest prime number of non prime , if prm[i]=0 then it is prime\n    vector<int> prm(10000001,0);\n    prm[1]=1;\n    for(int i=2;i<=1e7;i++)\n    {\n        if(prm[i])\n             continue;\n        prm[i]=i;\n        for(int j=2*i;j<=1e7;j+=i)\n        {\n            if(prm[j]!=0)\n            continue;\n            prm[j]=i;\n        }\n    }\n    cout<<prm[10];\n}\n \nconst int N=500000;\nconst ll int mod = 1e9 + 7;\nvoid findFact(){\n    vector<vector<ll>>fact(N);\n    for(ll i=0;i<N;i++){\n        ll el=6; // v[i]\n        vector<ll>temp;\n        for(ll j=1;j*j<=el;j+=1){\n            if(el%j==0){\n                temp.pb(j);\n                if(j!=el/j ){\n                    temp.pb(el/j);\n                }\n            }\n        }\n        fact[i]=temp;\n    }\n}\nvoid primeMul(){\n    vector<int> prime(N + 1, -1);\n        for(int i=2; i<=N; i++)\n            {\n                if(prime[i] == -1)\n                {\n                    for(int j=i; j<=N; j+=i)\n                        prime[j] = i;\n                }\n            }  // To find the greatest prime of a number\n            int ans = 0;\n            for(int i=0; i<=N; i++) // finding multiplicity\n            {\n                int val = i;\n                 while(val != 1)\n                {\n                    val /= prime[val];\n                    ans++;\n                }\n            }\n            cout<<ans<<endl;\n}\n \n \nll dp1[1<<22];\nll dp2[1<<22];\nll gcd(ll a, ll b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}\nll expo(ll a, ll b, ll mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}\nvoid extendgcd(ll a, ll b, ll*v) {if (b == 0) {v[0] = 1; v[1] = 0; v[2] = a; return ;} extendgcd(b, a % b, v); ll x = v[1]; v[1] = v[0] - v[1] * (a / b); v[0] = x; return;} //pass an arry of size1 3\nll mminv(ll a, ll b) {ll arr[3]; extendgcd(a, b, arr); return arr[0];} //for non prime b\nll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}\nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\nll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m\nvoid for1(ll dp[]){\n    for (ll i=0;i<22;++i) {\n        for (ll mask=0; mask<(1<<22);mask++) {\n            if ((mask&(1<<i))) {\n                dp[mask] = mod_add(dp[mask], dp[mask^(1<<i)],mod);\n            }\n        }\n    }\n}\nvoid for2(ll dp[]) {\n    for (ll i = 0; i < 22; i++) {\n         for (ll mask = 0; mask < (1 << 22); mask++) {\n            if ((mask & (1 << i))) {\n                dp[mask ^ (1 << i)] = mod_add(dp[mask ^ (1 << i)], dp[mask],mod);\n            }\n        }\n    }\n}\nll int fact[N], invfact[N];\nvoid inv() {\n    ll int p = mod;\n    fact[0]=1;\n    int i;\n    for(i=1; i<N; i++) {\n        fact[i] = (i*fact[i-1])%p;\n    }\n    i--;\n    invfact[i] = pw(fact[i], p-2, p);\n    for(i--; i>=0; i--) {\n        invfact[i] = (invfact[i+1]*(i+1))%p;\n    }\n}\n \nint ncr(int n, int r) {\n    return (((fact[n]*invfact[r])%mod)*invfact[n-r])%mod;\n}\n\nclass Solution {\npublic:\n ll dynapnjd[2002][52];\n    const ll mod = 1e9+7;\n    ll solve(int i,vector<int> &nums,int ls){\n        if(i==nums.size()){\n            return 1;\n        }\n        for(int i=0;i<5;i++){\n            \n        }\n        ll yehhaians = 0;\n        if(dynapnjd[i][ls]!=-1){\n            return dynapnjd[i][ls];\n        }\n        for(int i=0;i<5;i++){\n            \n        }\n        if(i!=0){\n            for(int j=0;j<=nums[i];j++){\n                if(j>=ls && (nums[i]-j)<=(nums[i-1]-ls)){\n                    yehhaians = (yehhaians + solve(i+1,nums,j)%mod)%mod;\n                    yehhaians %= mod;\n                }\n            }\n            \n        }\n        else if(i==0){\n            for(int j=0;j<=nums[i];j++){\n                yehhaians = (yehhaians+solve(i+1,nums,j)%mod)%mod;\n                yehhaians %= mod;\n            }\n        }\n        for(int i=0;i<5;i++){\n\n        }\n        return dynapnjd[i][ls] = yehhaians;\n    }\n    int countOfPairs(vector<int>& nums) {\n        int fl=0;\n        if(fl){\n            ncr(3,5);\n            return 0;\n        }\n        for(int i=0;i<5;i++){\n            \n        }\n        memset(dynapnjd,-1,sizeof(dynapnjd));\n        return solve(0,nums,0);\n    }\n};",
    "submit_ts": "1723345450",
    "subm_id": "1351556035"
}