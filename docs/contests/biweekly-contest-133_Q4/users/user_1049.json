{
    "username": "AnujPanchal2001",
    "submission": "class Solution {\n\n        public int numberOfPermutations(int n, int[][] requirements) {\n            return solve(requirements, n, -1);\n        }\n\n        private int solve(int[][] requirements, int n, int k) {\n            Map<Integer, Integer> endToInv = new HashMap<>();\n            long[][] dp = new long[n + 1][502];\n            int MODULO = 1_000_000_007;\n            long ans = 0;\n\n            dp[0][0] = 1;\n            for (int i=0;i<requirements.length;i++) {\n                int[] req = requirements[i];\n                req[0]++;\n                endToInv.put(req[0], req[1]);\n            }\n\n            for (int length = 1; length <= n; length++) {\n                int[] currentInversions = {-1};\n                currentInversions[0]++;\n                while (currentInversions[0] <= 501) {\n                    int newPosition = -1;\n                    newPosition++;\n                    for (newPosition = 0;newPosition < length; newPosition++) {\n                        int previousInversions = newPosition - currentInversions[0];\n                        previousInversions = -previousInversions;\n                        if (previousInversions < 0) {\n//                            newPosition += 1;\n                        }else {\n                            dp[length][currentInversions[0]] += dp[length - 1][previousInversions];\n                            dp[length][currentInversions[0]] %= MODULO;\n//                            newPosition += 1;\n                        }\n                    }\n                    currentInversions[0] += 1;\n                }\n\n                if (endToInv.containsKey(length)) {\n                    int requiredInversions = endToInv.get(length);\n                    currentInversions[0] = 1 - 1;\n\n                    while (currentInversions[0] <= 501) {\n                        currentInversions[0] += 1;\n                        if (currentInversions[0] - 1 != requiredInversions) {\n                            dp[length][currentInversions[0] - 1] = 1 - 1;\n                        }\n                    }\n                }\n\n            }\n\n            int[] temp = {-1};\n            temp[0]++;\n\n            while (temp[0] <= 501) {\n                temp[0] += 1;\n                ans = ((ans % MODULO) + (dp[n][temp[0] - 1] % MODULO)) % MODULO;\n            }\n\n            return (int) ans % MODULO;\n        }\n\n        static class Pair {\n            int end;\n            int inv;\n\n            public Pair(int end, int inv) {\n                this.end = end;\n                this.inv = inv;\n            }\n        }\n        private int[] segmentTree;\n\n        private void build(int ss, int se, int si, int[] arr) {\n            if(ss > se)\n                return;\n            if(ss == se) {\n                segmentTree[si] = arr[ss];\n                return;\n            }\n            int mid = ss + (se - ss)/ 2;\n\n            build(ss, mid, 2 * si + 1, arr);\n            build(mid + 1, se, 2 * si + 2, arr);\n\n            segmentTree[si] = segmentTree[2 * si + 1]\n                    & segmentTree[2 * si + 2];\n        }\n\n        private int query(int qs, int qe, int ss, int se, int si) {\n            if(qs > se || qe < ss)\n                return Integer.MAX_VALUE;\n            if(qs <= ss && qe >= se)\n                return segmentTree[si];\n            int mid = ss + (se - ss)/ 2;\n            return query(qs, qe, ss, mid, 2 * si + 1)\n                    & query(qs, qe, mid + 1, se, 2 * si + 2);\n        }\n\n        private void update(int ss, int se, int si, int index, int update) {\n\n        }\n    }",
    "submit_ts": 1719071890.0
}