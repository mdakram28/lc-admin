{
    "username": "akayan",
    "submission": "class Solution {\n  fun countSubarrays(nums: IntArray, k: Int): Long {\n    val possibleList = nums.map { it and k == k }\n    val untilPossible = mutableMapOf<Int, Int>()\n    var nowIndex = -1\n    for (i in possibleList.indices.reversed()) {\n      if (nowIndex == -1 && possibleList[i]) {\n        nowIndex = i\n        untilPossible[i] = nowIndex\n      } else if (nowIndex == -1 && !possibleList[i]) {\n\n      } else if (nowIndex != -1 && possibleList[i]) {\n        untilPossible[i] = nowIndex\n      } else {\n        nowIndex = -1\n      }\n    }\n    val targetBit = k.toString(2).reversed().withIndex().filter { it.value == '1' }.map { it.index }.toSet()\n    fun check1(bitArray: IntArray, value: Int): Boolean {\n      return bitArray.withIndex().all {\n        if (targetBit.contains(it.index))\n          it.value == value\n        else\n          it.value < value\n      }\n    }\n    fun check2(bitArray: IntArray, value: Int): Boolean {\n      return bitArray.withIndex().all {\n        if (targetBit.contains(it.index))\n          it.value == value\n        else\n          true\n      }\n    }\n    var count = 0L\n    var right = 1\n    var bitArray = IntArray(32) { 0 }\n    nums.first().toString(2).reversed().withIndex().forEach {\n      if (it.value == '1') {\n        bitArray[it.index]++\n      }\n    }\n    for (left in nums.indices) {\n      if (left == right) {\n        nums[right].toString(2).reversed().withIndex().forEach {\n          if (it.value == '1') {\n            bitArray[it.index]++\n          }\n        }\n        right++\n      }\n      if (check1(bitArray, right - left)) {\n        val until = untilPossible.getOrDefault(right-1, -1)\n        count += (until - (right - 1) + 1).toLong()\n      } else if (check2(bitArray, right - left)) {\n        while (right < nums.size && check2(bitArray, right - left) && !check1(bitArray, right - left)) {\n          nums[right].toString(2).reversed().withIndex().forEach {\n            if (it.value == '1') {\n              bitArray[it.index]++\n            }\n          }\n          right++\n        }\n        if (check1(bitArray, right - left)) {\n          val until = untilPossible.getOrDefault(right-1, -1)\n          count += (until - (right - 1) + 1).toLong()\n        }\n      } else {\n      }\n      nums[left].toString(2).reversed().withIndex().forEach {\n        if (it.value == '1') {\n          bitArray[it.index]--\n        }\n      }\n    }\n    return count\n  }\n}",
    "submit_ts": "1720281558",
    "subm_id": "1311829733"
}