{
    "username": "scotchtape",
    "submission": "\ntemplate <int MOD_> struct modnum {\n    static constexpr int MOD = MOD_;\n    static_assert(MOD_ > 0, \"MOD must be positive\");\n    using ll = long long;\n    int v;\n    static int minv(int a, int m) {\n        a %= m;\n        assert(a);\n        return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n    }\npublic:\n    modnum() : v(0) {}\n    modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n    friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n    friend bool operator < (const modnum& a, const modnum& b) { return a.v < b.v; }\n    friend bool operator > (const modnum& a, const modnum& b) { return a.v > b.v; }\n\n    modnum inv() const {\n        modnum res;\n        res.v = minv(v, MOD);\n        return res;\n    }\n    friend modnum inv(const modnum& m) { return m.inv(); }\n    modnum neg() const {\n        modnum res;\n        res.v = v ? MOD-v : 0;\n        return res;\n    }\n    friend modnum neg(const modnum& m) { return m.neg(); }\n\n    modnum operator- () const {\n        return neg();\n    }\n    modnum operator+ () const {\n        return modnum(*this);\n    }\n\n    modnum& operator ++ () {\n        v ++;\n        if (v == MOD) v = 0;\n        return *this;\n    }\n    modnum& operator -- () {\n        if (v == 0) v = MOD;\n        v --;\n        return *this;\n    }\n    modnum& operator += (const modnum& o) {\n        v -= MOD-o.v;\n        v = (v < 0) ? v + MOD : v;\n        return *this;\n    }\n    modnum& operator -= (const modnum& o) {\n        v -= o.v;\n        v = (v < 0) ? v + MOD : v;\n        return *this;\n    }\n    modnum& operator *= (const modnum& o) {\n        v = int(ll(v) * ll(o.v) % MOD);\n        return *this;\n    }\n    modnum& operator /= (const modnum& o) {\n        return *this *= o.inv();\n    }\n\n    friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n    friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n\n};\nusing num = modnum<int(1e9+7)>;\n\nclass Solution {\npublic:\n    int countOfPairs(vector<int>& a) {\n        int MAX = *max_element(a.begin(), a.end());\n\n        vector<num> dp(MAX+1, num(0));\n        dp[0] = 1;\n        int prev_elem = 1e9;\n\n        for (int i : a) {\n            using ll = long long;\n            vector<ll> ndp(MAX+1, 0);\n            for (int prev = 0; prev <= MAX; ++prev) {\n                int inc = prev, dec = prev_elem - inc;\n\n                int L1 = inc;\n                // i-j <= dec\n                // i <= dec+j\n                // i-dec <= j\n                int L2 = i-dec;\n                int L = max(L1, L2);\n\n                if (L <= MAX && L <= i) {\n                    ndp[L] += dp[prev].v;\n                    if (i+1 <= MAX)\n                        ndp[i+1] -= dp[prev].v;\n                }\n            }\n            for (int j = 1; j <= MAX; ++j) ndp[j] += ndp[j-1];\n            prev_elem = i;\n            for (int j = 0; j <= MAX; ++j) dp[j] = ndp[j];\n        }\n\n        num ans = 0;\n        for (num x : dp) ans += x;\n        return ans.v;\n    }\n};",
    "submit_ts": "1723346155",
    "subm_id": "1351571459"
}