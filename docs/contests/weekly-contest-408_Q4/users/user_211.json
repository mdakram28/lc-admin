{
    "username": "priya_M_sri_G",
    "submission": "from typing import List\nfrom collections import deque\nimport math\n\nclass Solution:\n    def bfs(self, graph: List[List[int]], start: int, target1: int, target2: int, nodes: int) -> int:\n        q = deque([start])\n        visited = [0] * (nodes + 4)\n        visited[start] = 1\n        \n        while q:\n            u = q.popleft()\n            for v in graph[u]:\n                if not visited[v]:\n                    q.append(v)\n                    visited[v] = 1\n        \n        return visited[target1] or visited[target2]\n\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        num_circles = len(circles)\n        circles_data = [((circles[i][0], circles[i][1]), circles[i][2]) for i in range(num_circles)]\n        graph = [[] for _ in range(num_circles + 4)]\n        \n        for i in range(num_circles):\n            if circles_data[i][0][0] <= circles_data[i][1]:\n                graph[num_circles].append(i)\n                graph[i].append(num_circles)\n            if X - circles_data[i][0][0] <= circles_data[i][1]:\n                graph[num_circles + 2].append(i)\n                graph[i].append(num_circles + 2)\n            if circles_data[i][0][1] <= circles_data[i][1]:\n                graph[num_circles + 1].append(i)\n                graph[i].append(num_circles + 1)\n            if Y - circles_data[i][0][1] <= circles_data[i][1]:\n                graph[num_circles + 3].append(i)\n                graph[i].append(num_circles + 3)\n            for j in range(i + 1, num_circles):\n                distance = math.sqrt((circles_data[i][0][0] - circles_data[j][0][0]) ** 2 + (circles_data[i][0][1] - circles_data[j][0][1]) ** 2)\n                radius_sum = circles_data[i][1] + circles_data[j][1]\n                if radius_sum >= distance:\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        is_blocked = 0\n        is_blocked = max(is_blocked, self.bfs(graph, num_circles, num_circles + 1, num_circles + 2, num_circles + 4))  # Check for bottom-left corner\n        is_blocked = max(is_blocked, self.bfs(graph, num_circles + 3, num_circles + 2, num_circles + 1, num_circles + 4))  # Check for top-right corner\n        \n        return not is_blocked\n",
    "submit_ts": "1722136420",
    "subm_id": "1335733941"
}