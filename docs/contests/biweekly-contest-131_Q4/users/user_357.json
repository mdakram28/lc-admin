{
    "username": "heuristic-sammet6wq",
    "submission": "class Solution {\npublic:\n    \n    template<typename bas,typename inf>\n    struct LazySegTree {\n        int n;\n        vector<inf> t;\n        vector<int> l,r;\n\n        LazySegTree(vector<bas> v) {\n            n=v.size();\n            t.resize(n*8);\n            l.resize(n*8);\n            r.resize(n*8);\n\n            function<void(int,int,int)> init=[&](int curr,int ll,int rr) {\n                l[curr]=ll;\n                r[curr]=rr;\n                if(ll==rr) t[curr].init(v[ll]);\n                else {\n                    int mid=(l[curr]+r[curr])/2;\n                    init(curr*2+1,ll,mid);\n                    init(curr*2+2,mid+1,rr);\n                    t[curr].merge(t[curr*2+1],t[curr*2+2]);\n                }\n            };\n\n            init(0,0,n-1);\n        }\n\n        inf query(int ll, int rr) {\n            function<inf(int,int,int)> q=[&](int curr, int ll, int rr) {\n                if(ll>rr) return inf();\n                t[curr].pushdown(t[curr*2+1],t[curr*2+2]);\n                if(ll==l[curr] && rr==r[curr]) return t[curr];\n                int mid=(l[curr]+r[curr])/2;\n                inf a; a.merge(q(curr*2+1,ll,min(rr,mid)),q(curr*2+2,max(ll,mid+1),rr));\n                return a;\n            };\n            return q(0,ll,rr);\n        }\n\n        void modify(int ll, int rr, bas k) {\n            function<void(int,int,int,bas)> m=[&](int curr, int ll, int rr, bas k) {\n                if(ll>rr) return;\n                t[curr].pushdown(t[curr*2+1],t[curr*2+2]);\n                if(ll==l[curr] && rr==r[curr]) {\n                    t[curr].modify(k);\n                } else {\n                    int mid=(l[curr]+r[curr])/2;\n                    m(curr*2+1,ll,min(rr,mid),k);\n                    m(curr*2+2,max(ll,mid+1),rr,k);\n                    t[curr].merge(t[curr*2+1],t[curr*2+2]);\n                }\n            };\n            m(0,ll,rr,k);\n        }\n    };\n    \n    struct info {\n        int lazy, num;\n        \n        void init(int x) {\n            num=x;\n            lazy=1e9;\n        }\n        \n        void merge(info a, info b) {\n            num=max(a.num,b.num);\n            lazy=1e9;\n        }\n        \n        void modify(int x) {\n            lazy=x;\n            num=x;\n        }\n        \n        void pushdown(info &a, info &b) {\n            if(lazy != 1e9) {\n                a.lazy=lazy;\n                b.lazy=lazy;\n                a.num=lazy;\n                b.num=lazy;\n                lazy=1e9;\n            }\n        }\n    };\n    \n    vector<bool> getResults(vector<vector<int>>& queries) {\n        \n        set<pair<int,int>> se;\n        \n        int f=min(50010,(int)queries.size()*3+10);\n        \n        se.insert({0,f});\n        \n        vector<int> w(f);\n        for(int i=0;i<f;i++) w[i]=f;\n        LazySegTree<int,info> seg(w);\n        \n        vector<bool> re;\n        for(auto v:queries) {\n            int type=v[0],x=v[1];\n            if(type==1) {\n                auto it=se.lower_bound({x,0});\n                it--;\n                pair<int,int> p=*it;\n                se.erase(p);\n                se.insert({p.first,x});\n                se.insert({x,p.second});\n                seg.modify(p.first,x-1,x-p.first);\n                seg.modify(x,p.second-1,p.second-x);\n            } else {\n                int sz=v[2];\n                auto it=se.upper_bound({x,0});\n                it--;\n                auto p = *it;\n                int ans=0;\n                if(p.first) {\n                    ans=max(ans,seg.query(0,p.first-1).num);\n                }\n                ans=max(ans,x-p.first);\n                re.push_back(sz<=ans);\n            }\n        }\n        return re;\n    }\n};",
    "submit_ts": 1716651434.0
}