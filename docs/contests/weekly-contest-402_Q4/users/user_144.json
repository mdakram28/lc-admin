{
    "username": "boobik",
    "submission": "/*\nAPI\nALL IN LONG\n\nconstruction - SegTreeChangeOne t(size, func) (func can be one of {\"max\", \"min\", \"sum\", \"gcd\"})\nadd(pos, val) - add val to a[pos] (1 - index)\ninit(pos, new_val) - set a[pos] = new_val (1 - index)\nDepends on func:\nsum(l, r)  - calc sum of elements with positions [l; r] (1 - index)\nmax(l, r)  - calc max of elements with positions [l; r] (1 - index)\nmin(l, r)  - calc min of elements with positions [l; r] (1 - index)\ngcd(l, r)  - calc gcd of elements with positions [l; r] (1 - index)\n*/\n\nstruct SegTreeChangeOne {\n    long long myGcd(long long a, long long b) {\n        if (a==-1) return b;\n        if (b==-1) return a;\n        return std::gcd(a,b);\n    }\n\n    SegTreeChangeOne(int sz, string function) {\n        localSz = sz;\n        t.resize(4 * sz + 5);\n        func = function;\n    }\n\n    long long localMin (int v, int tl, int tr, int l, int r) {\n    \tif (l > r)\n    \t\treturn INF;\n    \tif (l == tl && r == tr)\n    \t\treturn t[v];\n    \tint tm = (tl + tr) / 2;\n    \treturn std::min(localMin (v*2, tl, tm, l, std::min(r,tm)), localMin (v*2+1, tm+1, tr, std::max(l,tm+1), r));\n    }\n\n    long long localMax (int v, int tl, int tr, int l, int r) {\n    \tif (l > r)\n    \t\treturn -INF;\n    \tif (l == tl && r == tr)\n    \t\treturn t[v];\n    \tint tm = (tl + tr) / 2;\n    \treturn std::max(localMax (v*2, tl, tm, l, std::min(r,tm)), localMax (v*2+1, tm+1, tr, std::max(l,tm+1), r));\n    }\n\n    int it = 0;\n\n    long long localSum (int v, int tl, int tr, int l, int r) {\n    \tif (l > r)\n    \t\treturn 0;\n    \tif (l == tl && r == tr)\n    \t\treturn t[v];\n    \tint tm = (tl + tr) / 2;\n    \treturn localSum (v*2, tl, tm, l, std::min(r,tm)) + localSum (v*2+1, tm+1, tr, std::max(l,tm+1), r);\n    }\n\n    long long localGcd (int v, int tl, int tr, int l, int r) {\n    \tif (l > r)\n    \t\treturn -1;\n    \tif (l == tl && r == tr)\n    \t\treturn t[v];\n    \tint tm = (tl + tr) / 2;\n    \treturn myGcd(localGcd (v*2, tl, tm, l, std::min(r,tm)), localGcd (v*2+1, tm+1, tr, std::max(l,tm+1), r));\n    }\n\n    void localAdd (int v, int tl, int tr, int pos, long long val) {\n    \tif (tl == tr)\n    \t\tt[v] += val;\n    \telse {\n    \t\tint tm = (tl + tr) / 2;\n    \t\tif (pos <= tm)\n    \t\t\tlocalAdd (v*2, tl, tm, pos, val);\n    \t\telse\n    \t\t\tlocalAdd (v*2+1, tm+1, tr, pos, val);\n    \t\tif (func == \"sum\") {\n    \t\t    t[v] = t[v*2] + t[v*2+1];\n    \t\t}\n    \t\tif (func == \"max\") {\n    \t\t    t[v] = std::max(t[v*2], t[v*2+1]);\n    \t\t}\n    \t\tif (func == \"min\") {\n    \t\t    t[v] = std::min(t[v*2], t[v*2+1]);\n    \t\t}\n    \t\tif (func == \"gcd\") {\n    \t\t    t[v] = myGcd(t[v*2], t[v*2+1]);\n    \t\t}\n    \t}\n    }\n\n    void localInit (int v, int tl, int tr, int pos, long long new_val) {\n    \tif (tl == tr)\n    \t\tt[v] = new_val;\n    \telse {\n    \t\tint tm = (tl + tr) / 2;\n    \t\tif (pos <= tm)\n    \t\t\tlocalInit (v*2, tl, tm, pos, new_val);\n    \t\telse\n    \t\t\tlocalInit (v*2+1, tm+1, tr, pos, new_val);\n    \t\tif (func == \"sum\") {\n    \t\t    t[v] = t[v*2] + t[v*2+1];\n    \t\t}\n    \t\tif (func == \"max\") {\n    \t\t    t[v] = std::max(t[v*2], t[v*2+1]);\n    \t\t}\n    \t\tif (func == \"min\") {\n    \t\t    t[v] = std::min(t[v*2], t[v*2+1]);\n    \t\t}\n    \t\tif (func == \"gcd\") {\n    \t\t    t[v] = myGcd(t[v*2], t[v*2+1]);\n    \t\t}\n    \t}\n    }\n\n\n\n    long long min(int l, int r) {\n        return localMin(1, 1, localSz, l,r);\n    }\n\n    long long max(int l, int r) {\n        return localMax(1, 1, localSz, l,r);\n    }\n\n    long long sum(int l, int r) {\n        return localSum(1, 1, localSz, l,r);\n    }\n\n    long long gcd(int l, int r) {\n        return localGcd(1, 1, localSz, l,r);\n    }\n\n    void add(int pos, long long val) {\n        localAdd(1, 1, localSz, pos, val);\n    }\n\n    void init(int pos, long long new_val) {\n        localInit(1, 1, localSz, pos, new_val);\n    }\n\n    vector <long long> t;\n    int localSz;\n    const long long INF = 9223372036000000000LL;\n    string func;\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int a = nums.size();\n        SegTreeChangeOne t(a+1, \"sum\");\n        vector <int> ans;\n        for (int i =1;i+1<a;i++) if (nums[i]>nums[i-1] && nums[i]>nums[i+1]) t.init(i+1, 1);\n        for (auto& q:queries) {\n            if (q[0]==1) {\n                \n                ans.push_back(t.sum(q[1]+2, q[2]));\n            } else {\n                int pos = q[1];\n                nums[pos] = q[2];\n                if (pos>0 && pos+1<a && nums[pos]>nums[pos-1] && nums[pos]>nums[pos+1]) {\n                    t.init(pos+1, 1);\n                } else t.init(pos+1,0);\n                if (pos>=1) {if (pos-1>0 && pos<a && nums[pos-1]>nums[pos-2] && nums[pos-1]>nums[pos]) {\n                    \n                    t.init(pos, 1);\n                } else { t.init(pos,0); } }\n                \n                if (pos+1<=a) {\n                    if (pos+1>0 && pos+2<a && nums[pos+1]>nums[pos] && nums[pos+1]>nums[pos+2]) {\n                    t.init(pos+2, 1);\n                } else t.init(pos+2,0); \n                }\n                \n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1718506540",
    "subm_id": "1289622564"
}