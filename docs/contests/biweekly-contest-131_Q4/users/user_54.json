{
    "username": "EmZie",
    "submission": "/*\n    30 September 2023\n    Others leetcode\n*/\n\n#ifndef __DEBUG__\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#endif\n\n#undef __INTERACTIVE__\n\n#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n#define pyes cout << \"YES\" //\"Yes\"\n#define pno cout << \"NO\"   //\"No\"\n#define fastio ios_base::sync_with_stdio(0)\n#define untie cin.tie(0)\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repe(i, n) for (int i = 1; i <= (n); i++)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define rrepe(i, n) for (int i = (n); i > 0; i--)\n#define ms(a, b) memset(a, b, sizeof a)\n#define a2z(x) (x).begin(), (x).end()\n#define z2a(x) (x).rbegin(), (x).rend()\n#define gsz(v) ((int)(v).size())\n#define MOD 1000000007 // 998244353\n#define MAX 1000005\n\n#if !defined(__INTERACTIVE__) && !defined(__DEBUG__)\n#define endl \"\\n\"\n#endif\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nusing vb = vector<bool>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vpii = vector<pair<int, int>>;\n\nusing vvb = vector<vector<bool>>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\nusing vvpii = vector<vector<pair<int, int>>>;\n\nusing mii = map<int, int>;\nusing umii = unordered_map<int, int>;\nusing seti = set<int>;\nusing useti = unordered_set<int>;\n\n/***************\n *\n * For elem\n *\n ***************/\nusing TType = int;\nusing LType = int;\nTType sumPushUp(TType a, TType b)\n{\n    return a + b;\n}\n\nLType *sumPushDown(LType *node, LType value)\n{\n    if (node == 0)\n    {\n        node = new LType;\n        *node = (LType)0;\n    }\n\n    *node += value;\n    return node;\n}\n\nTType sumTPL(TType nodeVal, LType val, int l, int r)\n{\n    return nodeVal + (TType)val * (r - l + 1);\n}\n\n/***************\n *\n * For Min Elem\n *\n ***************/\n\npair<TType, TType> elemPushUp(pair<TType, TType> a, pair<TType, TType> b)\n{\n    if (a.first > b.first)\n        return a;\n    return b;\n}\n\nLType *elemLPL(LType *node, LType value)\n{\n    if (node == 0)\n    {\n        node = new LType;\n        *node = (LType)0;\n    }\n\n    *node += value;\n    return node;\n}\n\npair<TType, TType> elemTPL(pair<TType, TType> nodeVal, LType val, int l, int r)\n{\n    nodeVal.first += (TType)val;\n    return nodeVal;\n}\n\ntemplate <class T, class L, T pushUp(T, T), L *LPL(L *, L), T TPL(T, L, int, int)>\nclass SegmentTree\n{\nprivate:\n    void pushDown(int node, L val, int l, int r)\n    {\n        tree[node] = TPL(tree[node], val, l, r);\n        lazy[node] = LPL(lazy[node], val);\n    }\n\n    T buildUtil(vector<T> &a, int node, int l, int r)\n    {\n        if (l == r)\n        {\n            tree[node] = a[l];\n            return tree[node];\n        }\n        int mid = (l + r) >> 1;\n        int leftNode = (node << 1) + 1;\n        int rightNode = leftNode + 1;\n        return tree[node] = pushUp(buildUtil(a, leftNode, l, mid), buildUtil(a, rightNode, mid + 1, r));\n    }\n\n    T queryUtil(int node, int l, int r, int ql, int qr)\n    {\n        // change here\n        if (ql > r || qr < l)\n            return INI;\n        if (l >= ql && r <= qr)\n            return tree[node];\n\n        int mid = (l + r) >> 1;\n        int leftNode = (node << 1) + 1;\n        int rightNode = leftNode + 1;\n        if (lazy[node])\n        {\n            pushDown(leftNode, *lazy[node], l, mid);\n            pushDown(rightNode, *lazy[node], mid + 1, r);\n            delete lazy[node];\n            lazy[node] = 0;\n        }\n        return pushUp(queryUtil(leftNode, l, mid, ql, qr), queryUtil(rightNode, mid + 1, r, ql, qr));\n    }\n\n    T updateUtil(int node, int l, int r, int ql, int qr, L val)\n    {\n        if (ql > r || qr < l)\n            return tree[node];\n        if (l >= ql && r <= qr)\n        {\n            tree[node] = TPL(tree[node], val, l, r);\n            lazy[node] = LPL(lazy[node], val);\n            return tree[node];\n        }\n\n        int mid = (l + r) >> 1;\n        int leftNode = (node << 1) + 1;\n        int rightNode = leftNode + 1;\n        if (lazy[node])\n        {\n            pushDown(leftNode, *lazy[node], l, mid);\n            pushDown(rightNode, *lazy[node], mid + 1, r);\n            delete lazy[node];\n            lazy[node] = 0;\n        }\n        return tree[node] = pushUp(updateUtil(leftNode, l, mid, ql, qr, val), updateUtil(rightNode, mid + 1, r, ql, qr, val));\n    }\n\npublic:\n    int n;\n    vector<T> tree;\n    vector<L *> lazy;\n    T INI;\n    SegmentTree(int nn, T ini)\n    {\n        this->n = nn;\n        INI = ini;\n        tree = vector<T>(4 * n, INI);\n        lazy = vector<L *>(4 * n, (L *)0);\n        vector<T> a(n, INI);\n        build(a);\n    }\n\n    void build(vector<T> &a)\n    {\n        buildUtil(a, 0, 0, n - 1);\n    }\n\n    SegmentTree(vector<T> &a, T ini)\n    {\n        this->n = int(a.size());\n        INI = ini;\n        tree = vector<T>(4 * n, INI);\n        lazy = vector<L *>(4 * n, (L *)0);\n        build(a);\n    }\n\n    T query(int l, int r)\n    {\n        return queryUtil(0, 0, n - 1, l, r);\n    }\n\n    void update(int l, int r, L val)\n    {\n        updateUtil(0, 0, n - 1, l, r, val);\n    }\n\n    ~SegmentTree()\n    {\n        for (int i = 0; i < 4 * n; i++)\n            if (lazy[i])\n                delete lazy[i];\n    }\n};\n\nclass Solution\n{\npublic:\n    vector<bool> getResults(vector<vector<int>> &queries)\n    {\n        int line = min(50000, 3 * gsz(queries)) + 10;\n\n        vpii a(line);\n        rep(i, line)\n        {\n            a[i].fr = i;\n            a[i].sc = i;\n        }\n        seti obsInc;\n        set<int, greater<int>> obsDesc;\n\n        obsInc.insert(0);\n        obsInc.insert(line - 1);\n        obsDesc.insert(0);\n        obsDesc.insert(line - 1);\n\n        SegmentTree<pair<int, int>, int, elemPushUp, elemLPL, elemTPL> st(a, mp(0, 0));\n\n        vector<bool> ans;\n\n        for (auto query : queries)\n        {\n            int type = query[0];\n            if (type == 1)\n            {\n                int x = query[1];\n                int before = *obsDesc.upper_bound(x);\n                int after = *obsInc.upper_bound(x);\n                obsInc.insert(x);\n                obsDesc.insert(x);\n\n                st.update(x + 1, after, before - x);\n            }\n            else\n            {\n                int x = query[1];\n                int sz = query[2];\n\n                int maxSize = st.query(0, x).first;\n                ans.pb(maxSize >= sz);\n            }\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": 1716649694.0
}