{
    "username": "pruh",
    "submission": "struct dsu {\npublic:\n  dsu() : _n(0) {}\n  explicit dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n  int merge(int a, int b) {\n\tassert(0 <= a && a < _n);\n\tassert(0 <= b && b < _n);\n\tint x = leader(a), y = leader(b);\n\tif (x == y) return x;\n\tif (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n\tparent_or_size[x] += parent_or_size[y]; parent_or_size[y] = x;\n\treturn x;\n  }\n\n  bool same(int a, int b) {\n\tassert(0 <= a && a < _n); assert(0 <= b && b < _n);\n\treturn leader(a) == leader(b);\n  }\n\n  int leader(int a) {\n\tassert(0 <= a && a < _n);\n\tif (parent_or_size[a] < 0) return a;\n\treturn parent_or_size[a] = leader(parent_or_size[a]);\n  }\n\n  int size(int a) {\n\tassert(0 <= a && a < _n);\n\treturn -parent_or_size[leader(a)];\n  }\n\n  std::vector<std::vector<int>> groups() {\n\tstd::vector<int> leader_buf(_n), group_size(_n);\n\tfor (int i = 0; i < _n; i++) {\n\t  leader_buf[i] = leader(i); group_size[leader_buf[i]]++;\n\t}\n\tstd::vector<std::vector<int>> result(_n);\n\tfor (int i = 0; i < _n; i++) {\n\t  result[i].reserve(group_size[i]);\n\t}\n\tfor (int i = 0; i < _n; i++) {\n\t  result[leader_buf[i]].push_back(i);\n\t}\n\tresult.erase(\n\t\tstd::remove_if(result.begin(), result.end(),\n\t\t\t\t\t   [&](const std::vector<int> &v) { return v.empty(); }),\n\t\tresult.end());\n\treturn result;\n  }\n\nprivate:\n  int _n;\n  std::vector<int> parent_or_size;\n};\n\nclass Solution {\npublic:\n    bool canReachCorner(int x, int y, vector<vector<int>>& c) {\n\tint n = c.size();\n\tdsu d(n + 4);\n\n\tfor (int i = 0; i < n; i++) {\n    for(int j = i + 1; j < n; j++) {\n        long long dist_squared =\n            ((static_cast<long long>(c[i][0]) - static_cast<long long>(c[j][0])) * (static_cast<long long>(c[i][0]) - static_cast<long long>(c[j][0])) + \n             (static_cast<long long>(c[i][1]) - static_cast<long long>(c[j][1])) * (static_cast<long long>(c[i][1]) - static_cast<long long>(c[j][1])));\n        if(dist_squared <= ((static_cast<long long>(c[i][2]) + static_cast<long long>(c[j][2])) * (static_cast<long long>(c[i][2]) + static_cast<long long>(c[j][2])))) {\n            d.merge(i, j);\n        }\n    }\n    if(static_cast<long long>(c[i][0]) - static_cast<long long>(c[i][2]) <= 0) {\n        d.merge(i, n);\n    }\n    if(static_cast<long long>(c[i][1]) + static_cast<long long>(c[i][2]) >= y) {\n        d.merge(i, n + 1);\n    }\n    if(static_cast<long long>(c[i][0]) + static_cast<long long>(c[i][2]) >= x) {\n        d.merge(i, n + 2);\n    }\n    if(static_cast<long long>(c[i][1]) - static_cast<long long>(c[i][2]) <= 0) {\n        d.merge(i, n + 3);\n    }\n}\n\treturn !(d.same(n, n + 3) || d.same(n, n + 2) || d.same(n + 3, n + 1) || d.same(n + 2, n + 1)); \n}\n};",
    "submit_ts": "1722137906",
    "subm_id": "1335776930"
}