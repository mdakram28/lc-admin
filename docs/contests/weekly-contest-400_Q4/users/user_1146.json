{
    "username": "3FrenchOmelettes",
    "submission": "class Solution {\npublic:\n    int minimumDifference(vector<int>& arr, int k)\n    {\n        // k is huge\n        // nums[i] is huge\n        \n        // n is normal\n        \n        // return minimum possible value of the |k - AND(nums[x...y])\n        \n        // so we need to find an AND value that's close to k\n        \n        // 32 bits\n        // higher bits are better to get\n        \n        // find an element with the highest bit that k has\n        \n        // try to extend it. if the next element doesn't have the highest bit, then stop\n        \n        // for every bit in k\n        // do one pass over nums\n        \n        // if arr[i] has k's highest bit\n        // try forming a subarray starting at it\n        // extend as long as the AND has bit x\n        \n        // once it fails, there's no point of going backwards\n        // since we considered all subarrays containing the highest bit\n        \n        // As we extend a subarray, the value will never increase\n        // so if value we start at is already <= k then we should never extend\n        \n        // if it's > k then we should extend\n        // suppose arr[i] > k\n        // extend to arr[i...i+1]\n        // once we drop below k, stop\n        // reduce window from the left\n        // think this is just sliding window\n        \n        int n = arr.size();\n        int ans = INT_MAX;\n        for (auto x : arr)\n        {\n            ans = min(ans, abs(k - (x)));\n        }\n        \n        int sub = arr[0];\n        int lo = 0;\n        vector<int> bits(32, 0);\n        for (int j = 0; j < 32; j++)\n        {\n            if (arr[0] & (1U << j))\n            {\n                bits[j]++;\n            }\n        }\n        \n        for (int i = 1; i < n; i++)\n        {\n            \n            for (int j = 0; j < 32; j++)\n            {\n                if (arr[i] & (1U << j))\n                {\n                    bits[j]++;\n                }\n            }\n            \n            sub &= arr[i];\n            while (lo < i && sub <= k)\n            {\n                ans = min(ans, abs(k - sub));\n                int si = (i - (lo+1) + 1);\n                sub = 0;\n                for (int j = 0; j < 32; j++)\n                {\n                    if (arr[lo] & (1U << j))\n                    {\n                        bits[j]--;\n                    }\n                    if (bits[j] == si)\n                    {\n                        sub |= 1U << j;\n                    }\n                }\n                lo++;\n                \n                ans = min(ans, abs(k - sub));\n            }\n            ans = min(ans, abs(k - sub));\n        }\n        \n        return ans;\n    }\n};",
    "submit_ts": 1717300079.0
}