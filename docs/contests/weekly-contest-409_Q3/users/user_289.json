{
    "username": "xls-u",
    "submission": "struct Info {\n    int sum;\n    Info(int x = 0) : sum(x) {}\n};\n\nInfo operator+(const Info &a, const Info &b) {\n    return Info(a.sum + b.sum);\n}\n\nstruct Tag {\n    int flag;\n    Tag(int flag = 0) : flag(flag) {}\n};\n\ntemplate<class Info, class Tag,\n    class Merge = plus<Info>>\nclass SegmentTree {\n    const int n;\n    const Merge merge;\n    vector<Info> tr;\n    vector<Tag> tag;\n    void pushup(int u) {\n        tr[u] = merge(tr[u << 1], tr[u << 1 | 1]);\n    }\n    // ===========================================\n    void apply(Info &a, const Tag &b) {\n        if (b.flag) {\n            a.sum = 0;\n        }\n    }\n    void apply(Tag &a, const Tag &b) {\n        if (b.flag) {\n            a.flag = 1;\n        }\n    }\n    // ===========================================\n    void apply(int u, const Tag &v) {\n        apply(tr[u], v);\n        apply(tag[u], v);\n    }\n    void pushdown(int u) {\n        apply(u << 1, tag[u]);\n        apply(u << 1 | 1, tag[u]);\n        tag[u] = Tag();\n    }\n    void modify(int u, int l, int r, int x, const Info &v) {\n        if (l == r) {\n            tr[u] = v;\n            return;\n        }\n        pushdown(u);\n        int mid = (l + r) >> 1;\n        if (x <= mid) modify(u << 1, l, mid, x, v);\n        else modify(u << 1 | 1, mid + 1, r, x, v);\n        pushup(u);\n    }\n    void rangeApply(int u, int l, int r, int L, int R, const Tag &v) {\n        if (l > R || r < L) return;\n        if (l >= L && r <= R) {\n            apply(u, v);\n            return;\n        }\n        pushdown(u);\n        int mid = (l + r) >> 1;\n        rangeApply(u << 1, l, mid, L, R, v);\n        rangeApply(u << 1 | 1, mid + 1, r, L, R, v);\n        pushup(u);\n    }\n    Info rangeQuery(int u, int l, int r, int L, int R) {\n        if (l > R || r < L) return Info();\n        if (l >= L && r <= R) return tr[u];\n        pushdown(u);\n        int mid = (l + r) >> 1;\n        auto res = merge(rangeQuery(u << 1, l, mid, L, R), rangeQuery(u << 1 | 1, mid + 1, r, L, R));\n        pushup(u);\n        return res;\n    }\npublic:\n    SegmentTree(int _n) : n(_n), merge(Merge()), tr(_n * 4), tag(_n * 4) {}\n    SegmentTree(vector<Info> &init) : SegmentTree(init.size()) {\n        function<void(int, int, int)> build = [&](int u, int l, int r) {\n            if (l == r) {\n                tr[u] = init[r];\n                return;\n            }\n            int mid = (l + r) >> 1;\n            build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);\n            pushup(u);\n        };\n        build(1, 0, n - 1);\n    }\n    void modify(int x, const Info &v) {\n        modify(1, 0, n - 1, x, v);\n    }\n    void rangeApply(int l, int r, const Tag &v) {\n        rangeApply(1, 0, n - 1, l, r, v);\n    }\n    Info query(int x) {\n        return rangeQuery(1, 0, n - 1, x, x);\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n - 1, l, r);\n    }\n};\n\n\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int> ans;\n        vector<Info> w(n, Info(1));\n        SegmentTree<Info, Tag> seg(w);\n        for (int i = 0; i < queries.size(); i++) {\n            int u = queries[i][0], v = queries[i][1];\n            if (v - u > 1) {\n                seg.rangeApply(u + 1, v - 1, Tag(1));\n            }\n            ans.push_back(seg.rangeQuery(0, n - 1).sum - 1);\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1722740779",
    "subm_id": "552333664"
}