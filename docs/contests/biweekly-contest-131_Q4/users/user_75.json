{
    "username": "farmerboy",
    "submission": "#include <bits/stdc++.h>\n#define FI first\n#define SE second\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) int((a).size())\n#define MS(s, n) memset(s, n, sizeof(s))\n#define FOR(i,a,b) for (int i = (a); i <= (b); i++)\n#define FORE(i,a,b) for (int i = (a); i >= (b); i--)\n#define FORALL(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define TRAV(x, a) for (auto &x : a)\n\nusing namespace std;\nusing ll = long long; using ld = double; \nusing pi = pair<int, int>; using pl = pair<ll, ll>; using pd = pair<ld, ld>;\nusing cd = complex<ld>; using vcd = vector<cd>;\n\nusing vi = vector<int>; using vl = vector<ll>;\nusing vd = vector<ld>; using vs = vector<string>;\nusing vpi = vector<pi>; using vpl = vector<pl>; using vpd = vector<pd>; // vector<pair>\n\ntemplate<class T> using min_pq = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T> inline int ckmin(T& a, const T& val) { return val < a ? a = val, 1 : 0; }\ntemplate<class T> inline int ckmax(T& a, const T& val) { return a < val ? a = val, 1 : 0; }\ntemplate<class T> void remDup(vector<T>& v) { sort(ALL(v)); v.erase(unique(ALL(v)), end(v)); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { return x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll ceilDiv(ll a, ll b) { return a / b + ((a ^ b) > 0 && a % b); } // divide a by b rounded up\nll floorDiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); } // divide a by b rounded down\nvoid setPrec(int x) { cout << fixed << setprecision(x); }\n\n// TO_STRING\n#define ts to_string\nstring ts(char c) { return string(1, c); }\nstring ts(const char* s) { return (string) s; }\nstring ts(string s) { return s; }\nstring ts(bool b) { return (b ? \"true\" : \"false\"); }\n\ntemplate<class T> using V = vector<T>;\ntemplate<class T> string ts(complex<T> c);\nstring ts(V<bool> v);\ntemplate<size_t sz> string ts(bitset<sz> b);\ntemplate<class T> string ts(T v);\ntemplate<class T, class U> string ts(pair<T,U> p);\ntemplate<class ...U> string ts(tuple<U...> u);\n\ntemplate<class T> string ts(complex<T> c) { stringstream ss; ss << c; return ss.str(); }\nstring ts(V<bool> v) {string res = \"{\"; FOR(i,0,SZ(v)-1) res += char('0'+v[i]); res += \"}\"; return res; }\ntemplate<size_t sz> string ts(bitset<sz> b) { string res = \"\"; FOR(i,0,SZ(b)-1) res += char('0'+b[i]); return res; }\ntemplate<class T> string ts(T v) { // containers with begin(), end()\n    bool fst = 1; string res = \"\";\n    for (const auto& x: v) { if (!fst) res += \" \"; fst = 0; res += ts(x); }\n    return res;\n}\ntemplate<class T, class U> string ts(pair<T,U> p) { return \"(\" + ts(p.FI) + \", \" + ts(p.SE) + \")\"; }\ntemplate<size_t i, class T> string print_tuple_utils(const T& tup) { if constexpr(i == tuple_size<T>::value) return \")\"; else return (i ? \", \" : \"(\") + ts(get<i>(tup)) + print_tuple_utils<i + 1, T>(tup); }\ntemplate<class ...U> string ts(tuple<U...> u) { return print_tuple_utils<0, tuple<U...>>(u); }\n\n// OUTPUT\ntemplate<class T> void pr(T x) { cout << ts(x); }\ntemplate<class T, class ...U> void pr(const T& t, const U&... u) { pr(t); pr(u...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class T, class ...U> void ps(const T& t, const U&... u) { pr(t); if (sizeof...(u)) pr(\" \"); ps(u...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class T, class ...U> void DBG(const T& t, const U&... u) { cerr << ts(t); if (sizeof...(u)) cerr << \", \"; DBG(u...); }\n\n#ifdef LOCAL_DEBUG\n#define CONCAT(x, y) x##y\n#define with_level setw(__db_level * 2) << setfill(' ') << \"\" << setw(0)\n#define dbg(...) cerr << with_level << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#define chk(...) if (!(__VA_ARGS__)) cerr << setw(__db_level * 2) << setfill(' ') << \"\" << setw(0) << \"Line(\" << __LINE__ << \") -> function(\" << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#define db_block() debug_block CONCAT(dbbl, __LINE__)\nint __db_level = 0;\nstruct debug_block {\n    debug_block() { cerr << with_level << \"{\" << endl; ++__db_level; }\n    ~debug_block() { --__db_level; cerr << with_level << \"}\" << endl; }\n};\n#else\n#define dbg(...) 0\n#define chk(...) 0\n#define db_block() 0\n#endif\n\nconst ld PI = acos(-1.0);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\nconst ld EPS = 1e-9;\nconst ll MODBASE = 1000000007LL;\nconst int INF = 0x3f3f3f3f;\n\nconst int MAXN = 110;\nconst int MAXM = 1000;\nconst int MAXK = 16;\nconst int MAXQ = 200010;\n\nstruct SegmentTree {\n    public:\n    int N;\n\n    // 0-indexed\n    SegmentTree(int n) {\n        t.resize(4*n);\n        N = n;\n        FOR(i,0,SZ(t)-1) t[i] = 0;\n    }\n\n    int get(int k, int l, int r, int u, int v) {\n        if (l > r || r < u || v < l) return 0;\n        if (u <= l && r <= v) return t[k];\n        int m = (l + r) >> 1;\n        int lef = get(k*2, l, m, u, v);\n        int rig = get(k*2+1, m+1, r, u, v);\n        return max(lef, rig);\n    }\n\n    void update(int k, int l, int r, int u, int val) {\n        if (l > r || r < u || u < l) return;\n        if (l == r) {\n            t[k] = val;\n            return;\n        }\n        int m = (l + r) >> 1;\n        update(k*2, l, m, u, val);\n        update(k*2+1, m+1, r, u, val);\n        t[k] = max(t[k*2], t[k*2+1]);\n    }\n\n    private:\n    vi t;\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        vector<bool> res;\n        set<int> se;\n        se.insert(0);\n        se.insert(60000);\n        SegmentTree seg(60001);\n        \n        seg.update(1,0,seg.N-1,60000,60000);\n        \n        FOR(i,0,SZ(queries)-1) {\n            if (queries[i][0] == 1) {\n                int x = queries[i][1];\n                auto it = se.upper_bound(x);\n                int nex = *it;\n                it--;\n                int pre = *it;\n                \n                seg.update(1,0,seg.N-1,x,x-pre);\n                seg.update(1,0,seg.N-1,nex,nex-x);\n                se.insert(x);\n            } else {\n                int x = queries[i][1], sz = queries[i][2];\n                if (sz > x) {\n                    res.push_back(false);\n                    continue;\n                }\n                \n                auto it = se.upper_bound(x);\n                it--;\n                int kq = x - *it;\n                \n                kq = max(kq, seg.get(1,0,seg.N-1,0,*it));\n                res.push_back(kq >= sz);\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": "1716650012",
    "subm_id": "1267603950"
}