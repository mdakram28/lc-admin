{
    "username": "felixhuang07",
    "submission": "template<class S, S (*op)(S, S)>\nstruct sparse_table {\npublic:\n\tsparse_table() {}\n\texplicit sparse_table(const std::vector<S>& a) {\n\t\tn = (int) a.size();\n\t\tint max_log = std::__lg(n) + 1;\n\t\tmat.resize(max_log);\n\t\tmat[0] = a;\n\t\tfor(int j = 1; j < max_log; ++j) {\n\t\t\tmat[j].resize(n - (1 << j) + 1);\n\t\t\tfor(int i = 0; i <= n - (1 << j); ++i) {\n\t\t\t\tmat[j][i] = op(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n\t\t\t}\n\t\t}\n\t}\n\n\tS prod(int from, int to) const {\n\t\tassert(0 <= from && from <= to && to <= n - 1);\n\t\tint lg = std::__lg(to - from + 1);\n\t\treturn op(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n\t}\n\nprivate:\n\tint n;\n\tstd::vector<std::vector<S>> mat;\n};\n\nstruct HLD {\nprivate:\n\tstatic constexpr std::pair<int, int> __lca_op(std::pair<int, int> a, std::pair<int, int> b) {\n\t\treturn std::min(a, b);\n\t}\n\npublic:\n\tint n;\n\tstd::vector<std::vector<int>> g;\n\tstd::vector<int> subtree_size;\n\tstd::vector<int> parent;\n\tstd::vector<int> depth;\n\tstd::vector<int> top;\n\tstd::vector<int> tour;\n\tstd::vector<int> first_occurrence;\n\tstd::vector<int> id;\n\tstd::vector<std::pair<int, int>> euler_tour;\n\tsparse_table<std::pair<int, int>, __lca_op> st;\n\n\tHLD() : n(0) {}\n\texplicit HLD(int _n) : n(_n), g(_n), subtree_size(_n), parent(_n), depth(_n), top(_n), first_occurrence(_n), id(_n) {\n\t\ttour.reserve(n);\n\t\teuler_tour.reserve(2 * n - 1);\n\t}\n\n\tvoid add_edge(int u, int v) {\n\t\tassert(0 <= u && u < n);\n\t\tassert(0 <= v && v < n);\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\n\tvoid build(int root = 0) {\n\t\tassert(0 <= root && root < n);\n\t\tparent[root] = -1;\n\t\ttop[root] = root;\n\t\tdfs_sz(root);\n\t\tdfs_link(root);\n\t\t//st = std::move(sparse_table<std::pair<int, int>, __lca_op>(euler_tour));\n\t}\n\n\tint get_lca(int u, int v) {\n\t\tassert(0 <= u && u < n);\n\t\tassert(0 <= v && v < n);\n\t\tint L = first_occurrence[u];\n\t\tint R = first_occurrence[v];\n\t\tif(L > R) {\n\t\t\tstd::swap(L, R);\n\t\t}\n\t\treturn st.prod(L, R).second;\n\t}\n\n\tbool is_ancestor(int u, int v) {\n\t\tassert(0 <= u && u < n);\n\t\tassert(0 <= v && v < n);\n\t\treturn id[u] <= id[v] && id[v] < id[u] + subtree_size[u];\n\t}\n\n\tbool on_path(int a, int x, int b) {\n\t\treturn (is_ancestor(x, a) || is_ancestor(x, b)) && is_ancestor(get_lca(a, b), x);\n\t}\n\n\tint get_distance(int u, int v) {\n\t\treturn depth[u] + depth[v] - 2 * depth[(get_lca(u, v))];\n\t}\n\n\tstd::pair<int, std::array<int, 2>> get_diameter() const {\n\t\tstd::pair<int, int> u_max = {-1, -1};\n\t\tstd::pair<int, int> ux_max = {-1, -1};\n\t\tstd::pair<int, std::array<int, 2>> uxv_max = {-1, std::array<int, 2>{-1, -1}};\n\t\tfor(auto [d, u] : euler_tour) {\n\t\t\tu_max = std::max(u_max, std::make_pair(d, u));\n\t\t\tux_max = std::max(ux_max, std::make_pair(u_max.first - 2 * d, u_max.second));\n\t\t\tuxv_max = std::max(uxv_max, std::make_pair(ux_max.first + d, std::array<int, 2>{ux_max.second, u}));\n\t\t}\n\t\treturn uxv_max;\n\t}\n\n\tint get_kth_ancestor(int u, int k) {\n\t\tassert(0 <= u && u < n);\n\t\tif(depth[u] < k) {\n\t\t\treturn -1;\n\t\t}\n\t\tint d = depth[u] - k;\n\t\twhile(depth[top[u]] > d) {\n\t\t\tu = parent[top[u]];\n\t\t}\n\t\treturn tour[id[u] + d - depth[u]];\n\t}\n\n\tint get_kth_node_on_path(int a, int b, int k) {\n\t\tint z = get_lca(a, b);\n\t\tint fi = depth[a] - depth[z];\n\t\tint se = depth[b] - depth[z];\n\t\tif(k < 0 || k > fi + se) {\n\t\t\treturn -1;\n\t\t}\n\t\tif(k < fi) {\n\t\t\treturn get_kth_ancestor(a, k);\n\t\t} else {\n\t\t\treturn get_kth_ancestor(b, fi + se - k);\n\t\t}\n\t}\n\n\tstd::vector<std::pair<int, int>> get_path(int u, int v, bool include_lca) {\n\t\tif(u == v && !include_lca) {\n\t\t\treturn {};\n\t\t}\n\t\tstd::vector<std::pair<int, int>> lhs, rhs;\n\t\twhile(top[u] != top[v]) {\n\t\t\tif(depth[top[u]] > depth[top[v]]) {\n\t\t\t\tlhs.emplace_back(u, top[u]);\n\t\t\t\tu = parent[top[u]];\n\t\t\t} else {\n\t\t\t\trhs.emplace_back(top[v], v);\n\t\t\t\tv = parent[top[v]];\n\t\t\t}\n\t\t}\n\t\tif(u != v || include_lca) {\n\t\t\tif(include_lca) {\n\t\t\t\tlhs.emplace_back(u, v);\n\t\t\t} else {\n\t\t\t\tint d = std::abs(depth[u] - depth[v]);\n\t\t\t\tif(depth[u] < depth[v]) {\n\t\t\t\t\trhs.emplace_back(tour[id[v] - d + 1], v);\n\t\t\t\t} else {\n\t\t\t\t\tlhs.emplace_back(u, tour[id[u] - d + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::reverse(rhs.begin(), rhs.end());\n\t\tlhs.insert(lhs.end(), rhs.begin(), rhs.end());\n\t\treturn lhs;\n\t}\n\nprivate:\n\tvoid dfs_sz(int u) {\n\t\tif(parent[u] != -1) {\n\t\t\tg[u].erase(std::find(g[u].begin(), g[u].end(), parent[u]));\n\t\t}\n\t\tsubtree_size[u] = 1;\n\t\tfor(auto& v : g[u]) {\n\t\t\tparent[v] = u;\n\t\t\tdepth[v] = depth[u] + 1;\n\t\t\tdfs_sz(v);\n\t\t\tsubtree_size[u] += subtree_size[v];\n\t\t\tif(subtree_size[v] > subtree_size[g[u][0]]) {\n\t\t\t\tstd::swap(v, g[u][0]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs_link(int u) {\n\t\tfirst_occurrence[u] = (int) euler_tour.size();\n\t\tid[u] = (int) tour.size();\n\t\teuler_tour.emplace_back(depth[u], u);\n\t\ttour.push_back(u);\n\t\tfor(auto v : g[u]) {\n\t\t\ttop[v] = (v == g[u][0] ? top[u] : v);\n\t\t\tdfs_link(v);\n\t\t\teuler_tour.emplace_back(depth[u], u);\n\t\t}\n\t}\n};\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n = edges1.size() + 1;\n        int m = edges2.size() + 1;\n        HLD a(n), b(m);\n        for(auto v : edges1) {\n            a.add_edge(v[0], v[1]);\n        }\n        for(auto v : edges2) {\n            b.add_edge(v[0], v[1]);\n        }\n        a.build();\n        b.build();\n        int dda = a.get_diameter().first;\n        int ddb = b.get_diameter().first;\n        int da = (dda + 1) / 2;\n        int db = (ddb + 1) / 2;\n        int dc = (da + db) + 1;\n        // printf(\"%d %d\\n\", da, db);\n        return max({dda, ddb, dc});\n    }\n};",
    "submit_ts": 1719716241.0
}