{
    "username": "vaibhavsingh_0",
    "submission": "#define ALPHABET_SIZE 26\n\n\ntypedef struct TrieNode {\n    struct TrieNode* children[ALPHABET_SIZE];\n    int* wordIndices;  // Store the indices of the words in the original words array\n    int wordCount;     // Number of words ending at this node\n} TrieNode;\n\n// Create a new Trie Node\nTrieNode* createNode() {\n    TrieNode* node = (TrieNode*)malloc(sizeof(TrieNode));\n    node->wordIndices = NULL;\n    node->wordCount = 0;\n    for (int i = 0; i < ALPHABET_SIZE; i++) {\n        node->children[i] = NULL;\n    }\n    return node;\n}\n\n// Insert a word into the Trie\nvoid insert(TrieNode* root, char* word, int index) {\n    TrieNode* current = root;\n    while (*word) {\n        int charIndex = *word - 'a';\n        if (!current->children[charIndex]) {\n            current->children[charIndex] = createNode();\n        }\n        current = current->children[charIndex];\n        word++;\n    }\n    if (current->wordCount == 0) {\n        current->wordIndices = (int*)malloc(sizeof(int));\n    } else {\n        current->wordIndices = (int*)realloc(current->wordIndices, (current->wordCount + 1) * sizeof(int));\n    }\n    current->wordIndices[current->wordCount] = index;\n    current->wordCount++;\n}\n\n// Search for words in the Trie that match the target starting at position `start`\nvoid search(TrieNode* root, char* target, int start, int targetLen, int* dp, int* costs) {\n    TrieNode* current = root;\n    for (int i = start; i < targetLen; i++) {\n        int charIndex = target[i] - 'a';\n        if (!current->children[charIndex]) {\n            break;\n        }\n        current = current->children[charIndex];\n        if (current->wordCount > 0) {\n            for (int j = 0; j < current->wordCount; j++) {\n                int wordIndex = current->wordIndices[j];\n                if (dp[start] != INT_MAX) {\n                    if (dp[i + 1] > dp[start] + costs[wordIndex]) {\n                        dp[i + 1] = dp[start] + costs[wordIndex];\n                    }\n                }\n            }\n        }\n    }\n}\n\nint minimumCost(char* target, char** words, int wordsSize, int* costs, int costsSize) {\n    int targetLen = strlen(target);\n    int* dp = (int*)malloc((targetLen + 1) * sizeof(int));\n    for (int i = 0; i <= targetLen; i++) {\n        dp[i] = INT_MAX;\n    }\n    dp[0] = 0;\n\n    // Create and populate the Trie\n    TrieNode* root = createNode();\n    for (int i = 0; i < wordsSize; i++) {\n        insert(root, words[i], i);\n    }\n\n    // Update dp array using the Trie\n    for (int i = 0; i < targetLen; i++) {\n        if (dp[i] != INT_MAX) {\n            search(root, target, i, targetLen, dp, costs);\n        }\n    }\n\n    int result = dp[targetLen] == INT_MAX ? -1 : dp[targetLen];\n    free(dp);\n\n    // Free the Trie\n    // A function to recursively free Trie nodes would be needed\n    // to avoid memory leaks. For simplicity, we omit that here.\n\n    return result;\n}",
    "submit_ts": "1720321800",
    "subm_id": "1312332620"
}