{
    "username": "Abeed_shaik",
    "submission": "\nusing uint = unsigned int;\ntemplate<uint _mod>\nstruct modular_fixed_base{\n    static constexpr uint mod(){\n        return _mod;\n    }\n    template<class T>\n    static vector<modular_fixed_base> precalc_power(T base, int SZ){\n        vector<modular_fixed_base> res(SZ + 1, 1);\n        for(auto i = 1; i <= SZ; ++ i) res[i] = res[i - 1] * base;\n        return res;\n    }\n    static vector<modular_fixed_base> _INV;\n    static void precalc_inverse(int SZ){\n        if(_INV.empty()) _INV.assign(2, 1);\n        for(auto x = _INV.size(); x <= SZ; ++ x) _INV.push_back(_mod / x * -_INV[_mod % x]);\n    }\n    // _mod must be a prime\n    static modular_fixed_base _primitive_root;\n    static modular_fixed_base primitive_root(){\n        if(_primitive_root) return _primitive_root;\n        if(_mod == 2) return _primitive_root = 1;\n        if(_mod == 998244353) return _primitive_root = 3;\n        uint divs[20] = {};\n        divs[0] = 2;\n        int cnt = 1;\n        uint x = (_mod - 1) / 2;\n        while(x % 2 == 0) x /= 2;\n        for(auto i = 3; 1LL * i * i <= x; i += 2){\n            if(x % i == 0){\n                divs[cnt ++] = i;\n                while(x % i == 0) x /= i;\n            }\n        }\n        if(x > 1) divs[cnt ++] = x;\n        for(auto g = 2; ; ++ g){\n            bool ok = true;\n            for(auto i = 0; i < cnt; ++ i){\n                if((modular_fixed_base(g).power((_mod - 1) / divs[i])) == 1){\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) return _primitive_root = g;\n        }\n    }\n    constexpr modular_fixed_base(): data(){ }\n    modular_fixed_base(const double &x){ data = normalize(llround(x)); }\n    modular_fixed_base(const long double &x){ data = normalize(llround(x)); }\n    template<class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base(const T &x){ data = normalize(x); }\n    template<class T, typename enable_if<is_integral<T>::value>::type* = nullptr> static uint normalize(const T &x){\n        int sign = x >= 0 ? 1 : -1;\n        uint v =  _mod <= sign * x ? sign * x % _mod : sign * x;\n        if(sign == -1 && v) v = _mod - v;\n        return v;\n    }\n    const uint &operator()() const{ return data; }\n    template<class T> operator T() const{ return data; }\n    modular_fixed_base &operator+=(const modular_fixed_base &otr){ if((data += otr.data) >= _mod) data -= _mod; return *this; }\n    modular_fixed_base &operator-=(const modular_fixed_base &otr){ if((data += _mod - otr.data) >= _mod) data -= _mod; return *this; }\n    template<class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base &operator+=(const T &otr){ return *this += modular_fixed_base(otr); }\n    template<class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base &operator-=(const T &otr){ return *this -= modular_fixed_base(otr); }\n    modular_fixed_base &operator++(){ return *this += 1; }\n    modular_fixed_base &operator--(){ return *this += _mod - 1; }\n    modular_fixed_base operator++(int){ modular_fixed_base result(*this); *this += 1; return result; }\n    modular_fixed_base operator--(int){ modular_fixed_base result(*this); *this += _mod - 1; return result; }\n    modular_fixed_base operator-() const{ return modular_fixed_base(_mod - data); }\n    modular_fixed_base &operator*=(const modular_fixed_base &rhs){\n        data = (unsigned long long)data * rhs.data % _mod;\n        return *this;\n    }\n    template<class T, typename enable_if<is_integral<T>::value>::type* = nullptr>\n    modular_fixed_base &inplace_power(T e){\n        if(!data) return *this = {};\n        if(data == 1) return *this;\n        if(data == mod() - 1) return e % 2 ? *this : *this = -*this;\n        if(e < 0) *this = 1 / *this, e = -e;\n        modular_fixed_base res = 1;\n        for(; e; *this *= *this, e >>= 1) if(e & 1) res *= *this;\n        return *this = res;\n    }\n    template<class T, typename enable_if<is_integral<T>::value>::type* = nullptr>\n    modular_fixed_base power(T e) const{\n        return modular_fixed_base(*this).inplace_power(e);\n    }\n    modular_fixed_base &operator/=(const modular_fixed_base &otr){\n        int a = otr.data, m = _mod, u = 0, v = 1;\n        if(a < _INV.size()) return *this *= _INV[a];\n        while(a){\n            int t = m / a;\n            m -= t * a; swap(a, m);\n            u -= t * v; swap(u, v);\n        }\n        assert(m == 1);\n        return *this *= u;\n    }\n    uint data;\n};\ntemplate<uint _mod> vector<modular_fixed_base<_mod>> modular_fixed_base<_mod>::_INV;\ntemplate<uint _mod> modular_fixed_base<_mod> modular_fixed_base<_mod>::_primitive_root;\ntemplate<uint _mod> bool operator==(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return lhs.data == rhs.data; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> bool operator==(const modular_fixed_base<_mod> &lhs, T rhs){ return lhs == modular_fixed_base<_mod>(rhs); }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> bool operator==(T lhs, const modular_fixed_base<_mod> &rhs){ return modular_fixed_base<_mod>(lhs) == rhs; }\ntemplate<uint _mod> bool operator!=(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return !(lhs == rhs); }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> bool operator!=(const modular_fixed_base<_mod> &lhs, T rhs){ return !(lhs == rhs); }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> bool operator!=(T lhs, const modular_fixed_base<_mod> &rhs){ return !(lhs == rhs); }\ntemplate<uint _mod> bool operator<(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return lhs.data < rhs.data; }\ntemplate<uint _mod> bool operator>(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return lhs.data > rhs.data; }\ntemplate<uint _mod> bool operator<=(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return lhs.data <= rhs.data; }\ntemplate<uint _mod> bool operator>=(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return lhs.data >= rhs.data; }\ntemplate<uint _mod> modular_fixed_base<_mod> operator+(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return modular_fixed_base<_mod>(lhs) += rhs; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base<_mod> operator+(const modular_fixed_base<_mod> &lhs, T rhs){ return modular_fixed_base<_mod>(lhs) += rhs; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base<_mod> operator+(T lhs, const modular_fixed_base<_mod> &rhs){ return modular_fixed_base<_mod>(lhs) += rhs; }\ntemplate<uint _mod> modular_fixed_base<_mod> operator-(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return modular_fixed_base<_mod>(lhs) -= rhs; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base<_mod> operator-(const modular_fixed_base<_mod> &lhs, T rhs){ return modular_fixed_base<_mod>(lhs) -= rhs; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base<_mod> operator-(T lhs, const modular_fixed_base<_mod> &rhs){ return modular_fixed_base<_mod>(lhs) -= rhs; }\ntemplate<uint _mod> modular_fixed_base<_mod> operator*(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs){ return modular_fixed_base<_mod>(lhs) *= rhs; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base<_mod> operator*(const modular_fixed_base<_mod> &lhs, T rhs){ return modular_fixed_base<_mod>(lhs) *= rhs; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base<_mod> operator*(T lhs, const modular_fixed_base<_mod> &rhs){ return modular_fixed_base<_mod>(lhs) *= rhs; }\ntemplate<uint _mod> modular_fixed_base<_mod> operator/(const modular_fixed_base<_mod> &lhs, const modular_fixed_base<_mod> &rhs) { return modular_fixed_base<_mod>(lhs) /= rhs; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base<_mod> operator/(const modular_fixed_base<_mod> &lhs, T rhs) { return modular_fixed_base<_mod>(lhs) /= rhs; }\ntemplate<uint _mod, class T, typename enable_if<is_integral<T>::value>::type* = nullptr> modular_fixed_base<_mod> operator/(T lhs, const modular_fixed_base<_mod> &rhs) { return modular_fixed_base<_mod>(lhs) /= rhs; }\ntemplate<uint _mod> istream &operator>>(istream &in, modular_fixed_base<_mod> &number){\n    long long x;\n    in >> x;\n    number.data = modular_fixed_base<_mod>::normalize(x);\n    return in;\n}\n// #define _SHOW_FRACTION\ntemplate<uint _mod> ostream &operator<<(ostream &out, const modular_fixed_base<_mod> &number){\n#if defined(LOCAL) && defined(_SHOW_FRACTION)\n    out << number();\n\tcerr << \"(\";\n\tfor(auto d = 1; ; ++ d){\n\t\tif((number * d).data <= 1000000){\n\t\t\tcerr << (number * d).data << \"/\" << d;\n\t\t\tbreak;\n\t\t}\n\t\telse if((-number * d).data <= 1000000){\n\t\t\tcerr << \"-\" << (-number * d).data << \"/\" << d;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcerr << \")\";\n\treturn out;\n#else\n    return out << number();\n#endif\n}\n#undef _SHOW_FRACTION\n\n const uint mod = 1e9 + 7; // 1000000007\n//const uint mod = (119 << 23) + 1; // 998244353\n// const uint mod = 1e9 + 9; // 1000000009\n\nusing modular = modular_fixed_base<mod>;\n\nusing u64 = unsigned long long;\n#define ll long long\n#define pll pair<ll, ll>\n#define pii pair<int,int>\n#define vt vector\n#define pb push_back\n#define ar array\n#define str string\n\n#define F_OR(i, a, b, s) for (int i = (a); (s) > 0 ? i < (b) : i > (b); i += (s))\n#define F_OR1(e) F_OR(i, 0, e, 1)\n#define F_OR2(i, e) F_OR(i, 0, e, 1)\n#define F_OR3(i, b, e) F_OR(i, b, e, 1)\n#define F_OR4(i, b, e, s) F_OR(i, b, e, s)\n#define GET5(a, b, c, d, e, ...) e\n#define F_ORC(...) GET5(__VA_ARGS__, F_OR4, F_OR3, F_OR2, F_OR1)\n#define rep(...) F_ORC(__VA_ARGS__)(__VA_ARGS__)\n\n#define each(x, a) for (auto &x : a)\n#define all(a) a.begin(), a.end()\n#define r_each(x, a) for (auto &x : a | views::reverse)\n#define len(a) (int)a.size()\n\nclass Solution {\npublic:\n    int numberOfPermutations(int n, vector<vector<int>>& requirements) {\n        int m = requirements.size();\n        map<int, int> mp;\n    rep(m){\n        int idx = requirements[i][0], val = requirements[i][1];\n        mp[idx] = val;\n    }\n\n    vt<vt<modular>> dp(n + 1, vt<modular>(401, 0));\n    dp[0][0] = 1;\n\n    rep(i, n){\n        rep(j, i + 1){\n            rep(k, j, 401){\n                dp[i + 1][k] += dp[i][k - j]; \n            }\n        }\n        if(mp.find(i) != mp.end()){\n            rep(k, 401) if(k != mp[i]) dp[i + 1][k] = 0;\n        }\n    }\n    \n    return dp[n][mp[n - 1]];\n    }\n};",
    "submit_ts": 1719069014.0
}