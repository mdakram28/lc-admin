{
    "username": "b_venkatanath",
    "submission": "#include <vector>\n#include <map>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        map<pair<int, int>, vector<pair<int, int>>> mp;\n\n        // Create graph edges between circles\n        for (int i = 0; i < circles.size(); ++i) {\n            for (int j = i + 1; j < circles.size(); ++j) {\n                long long radDist = static_cast<long long>(circles[i][2] + circles[j][2]) * (circles[i][2] + circles[j][2]);\n                long long normDist = static_cast<long long>(circles[i][0] - circles[j][0]) * (circles[i][0] - circles[j][0]) +\n                                     static_cast<long long>(circles[i][1] - circles[j][1]) * (circles[i][1] - circles[j][1]);\n                if (radDist >= normDist) {\n                    mp[{circles[i][0], circles[i][1]}].push_back({circles[j][0], circles[j][1]});\n                    mp[{circles[j][0], circles[j][1]}].push_back({circles[i][0], circles[i][1]});\n                }\n            }\n        }\n\n        // Add edges from virtual nodes to circles touching boundaries\n        pair<int, int> p1 = {-1, -1};\n        pair<int, int> p2 = {-1, 0};\n        for (const auto& circle : circles) {\n            int nx = circle[0];\n            int ny = circle[1];\n            int nr = circle[2];\n            if (abs(ny - Y) <= nr || nx <= nr) {\n                mp[{p1}].push_back({nx, ny});\n                mp[{nx, ny}].push_back(p1);\n            }\n            if (abs(nx - X) <= nr || ny <= nr) {\n                mp[{p2}].push_back({nx, ny});\n                mp[{nx, ny}].push_back(p2);\n            }\n        }\n\n        // BFS to check if we can reach from p1 to p2\n        queue<pair<int, int>> q;\n        map<pair<int, int>, int> visited;\n        visited[p1] = 1;\n        q.push(p1);\n\n        while (!q.empty()) {\n            auto node = q.front();\n            q.pop();\n            for (const auto& neighbor : mp[node]) {\n                if (neighbor == p2) {\n                    return false;\n                }\n                if (!visited[neighbor]) {\n                    visited[neighbor] = 1;\n                    q.push(neighbor);\n                }\n            }\n        }\n\n        return true;\n    }\n};\n",
    "submit_ts": "1722138014",
    "subm_id": "1335779821"
}