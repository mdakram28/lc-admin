{
    "username": "gamer37",
    "submission": "vector<int> tree1(600010),lazy(600010);\n\nvoid rangeupdate(int node,int s,int e,int l,int r,int val)\n{\n    if(lazy[node]!=0)\n    {\n        tree1[node]+=lazy[node];\n        if(s!=e)\n        {\n            lazy[2*node]+=lazy[node];\n            lazy[2*node+1]+=lazy[node];\n        }\n        lazy[node]=0;\n    }\n\n    if(s>e || s>r || e<l)\n        return;\n\n    if(l<=s && e<=r)\n    {\n        tree1[node]+=val;\n        if(s!=e)\n        {\n            lazy[2*node]+=val;\n            lazy[2*node+1]+=val;\n        }\n        return;\n    }\n\n    int mid=(s+e)/2;\n    rangeupdate(2*node,s,mid,l,r,val);\n    rangeupdate(2*node+1,mid+1,e,l,r,val);\n\n    tree1[node]=max(tree1[2*node],tree1[2*node+1]);\n}\nint rangequery(int node,int s,int e,int l,int r)\n{\n    if(s>e || s>r || e<l)\n        return 0;\n\n    if(lazy[node]!=0)\n    {\n        tree1[node]+=lazy[node];\n        if(s!=e)\n        {\n            lazy[2*node]+=lazy[node];\n            lazy[2*node+1]+=lazy[node];\n        }\n        lazy[node]=0;\n    }\n\n    if(l<=s && e<=r)\n        return tree1[node];\n\n    int mid=(s+e)/2;\n    int p1=rangequery(2*node,s,mid,l,r);\n    int p2=rangequery(2*node+1,mid+1,e,l,r);\n    return max(p1,p2);\n}\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& q) {\n        int m=q.size(),i,mx=0;\n        vector<bool> ans;\n        rangeupdate(1,0,150001,0,150001,150001);\n        set<int> s;\n        s.insert(0);\n        s.insert(150001);\n        for(i=0;i<m;i++)\n        {\n            if(q[i][0]==1)\n            {\n                auto it=s.lower_bound(q[i][1]);\n                int y=*it;\n                auto it1=it;\n                it1--;\n                int x=*it1;\n                rangeupdate(1,0,150001,q[i][1],y,y-q[i][1]-(y-x));\n                rangeupdate(1,0,150001,x,q[i][1],q[i][1]-x-(y-x));\n                mx=max(mx,q[i][1]);\n                s.insert(q[i][1]);\n            }\n            else\n            {\n                auto it=s.lower_bound(q[i][1]);\n                int y=*it;\n                auto it1=it;\n                it1--;\n                int x=*it1;\n                \n                rangeupdate(1,0,150001,q[i][1],y,y-q[i][1]-(y-x));\n                rangeupdate(1,0,150001,x,q[i][1],q[i][1]-x-(y-x));\n                \n                \n                int si = rangequery(1,0,150001,0,q[i][1]);\n                //cout<<si<<endl;\n                \n                if(si>=q[i][2])\n                ans.push_back(1);\n                else\n                ans.push_back(0);\n                \n                rangeupdate(1,0,150001,q[i][1],y,(y-x)-(y-q[i][1]));\n                rangeupdate(1,0,150001,x,q[i][1],(y-x)-(q[i][1]-x));\n            }\n        }\n        for(i=0;i<=4*150001;i++)\n            tree1[i]=lazy[i]=0;\n        s.clear();\n        return ans;\n    }\n};",
    "submit_ts": 1716652037.0
}