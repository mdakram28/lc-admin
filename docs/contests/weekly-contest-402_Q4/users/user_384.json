{
    "username": "sachinbarupal",
    "submission": "class SegmentTree{\n    public: \n    vector<int> seg;\n    int n;\n    SegmentTree(vector<int> &v){\n        n = v.size();\n        seg = vector<int> (n*4, 0);\n//         Constructore Called Here \n        makeTree(1, 0, n-1, v);\n    }\n\n    void mergeNodes(int node){\n//         Working \n        seg[node] = seg[node*2] + seg[node*2+1];\n    }\n\n    void makeTree(int node, int l, int r, vector<int>& v){\n        // if(l > r) return ;\n        if(l == r){\n            seg[node] = v[l];\n            return ;\n        }\n        int mid = (l + r) >> 1;\n//         Go l and r from mid\n        makeTree(node*2, l, mid, v);\n        makeTree(node*2 + 1, mid+1, r, v);\n\n        mergeNodes(node);\n    }\n\n    int getValue(int l, int r){\n        return _getVal(l, r, 0, n-1, 1);\n    }\n\n    int _getVal(int l, int r, int segLeft, int segRight, int node){\n        // if(segLeft > segRight) return 0;  \n        if(segLeft >= l && segRight <= r) return seg[node];\n        if(segLeft > r || segRight < l) return 0;\n        // if(segLeft == segRight) return seg[node];\n\n        int mid = (segLeft + segRight) >> 1;\n\n        return _getVal(l, r, segLeft, mid, node*2) + _getVal(l, r, mid+1, segRight, node*2+1);\n    }\n    \n    void update(int idx, int val){\n        _update(idx, val, 0, n-1, 1);\n    }\n\n    void _update(int idx, int val, int segLeft, int segRight, int node){\n        if(segLeft > idx || segRight < idx) return ;\n        if(segLeft == segRight){\n            seg[node] = val;\n            return;\n        }\n\n        int mid = (segLeft + segRight) >> 1;\n        _update(idx, val, segLeft, mid, node*2);\n        _update(idx, val, mid+1, segRight, node*2+1);\n\n        mergeNodes(node);\n    }\n\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> pref(n);\n        for(int i=1; i<n-1; ++i){\n            if(nums[i] > nums[i-1] && nums[i] > nums[i+1]) pref[i]++;\n        }\n        \n        SegmentTree* seg = new SegmentTree(pref);\n        \n        // for(auto &it : pref) cout<<it<<\" \";\n        // cout<<endl;\n        vector<int> ans;\n        for(auto &q : queries){\n            int t = q[0], a = q[1], b = q[2];\n            \n            if(t == 1){\n                if(b - a + 1 < 3){\n                    ans.push_back(0);\n                }else{\n                    int l = a+1, r = b-1;\n                \n                \n              ans.push_back(seg->getValue(l, r));\n                }\n                \n            }else{\n                int idx = a, val = b;\n                if(nums[idx] == val) continue;\n                nums[idx] = val;\n                // cout<<\"here\"<<endl;\n                if(idx == 0){\n                    if(nums[1] > nums[0] && nums[1] > nums[2]) seg->update(1, 1);\n                    else seg->update(1, 0);\n                }else if(idx == n-1){\n                    // cout<<\"yaha\"<<endl;\n                    if(nums[n-2] > nums[n-3] && nums[n-2] > nums[n-1]) seg->update(n-2, 1);\n                    else {\n                        seg->update(n-2, 0);\n                        // cout<<\"here\"<<endl;\n                    }\n                }else{\n                    if(nums[idx] > nums[idx-1] && nums[idx] > nums[idx+1]) seg->update(idx, 1);\n                    else seg->update(idx, 0);\n                    if(idx+2 < n && nums[idx+1] > nums[idx+2] && nums[idx+1] > nums[idx]) seg->update(idx+1, 1);\n                    else seg->update(idx+1, 0);\n                    if(idx-2 >= 0  && nums[idx-1] > nums[idx-2] && nums[idx-1] > nums[idx]) seg->update(idx-1, 1);\n                    else seg->update(idx-1, 0);\n                }\n            }\n            \n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718507396.0
}