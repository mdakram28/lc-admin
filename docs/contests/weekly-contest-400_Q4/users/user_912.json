{
    "username": "Shiva51",
    "submission": "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#ifndef DEBUG_TEMPLATE_CPP\n#define DEBUG_TEMPLATE_CPP\n// #include <bits/stdc++.h>\n#define cerr cout\nnamespace __DEBUG_UTIL__\n{\n    using namespace std;\n    /* Primitive Datatypes Print */\n    void print(const char *x) { cerr << x; }\n    void print(bool x) { cerr << (x ? \"T\" : \"F\"); }\n    void print(char x) { cerr << '\\'' << x << '\\''; }\n    void print(signed short int x) { cerr << x; }\n    void print(unsigned short int x) { cerr << x; }\n    void print(signed int x) { cerr << x; }\n    void print(unsigned int x) { cerr << x; }\n    void print(signed long int x) { cerr << x; }\n    void print(unsigned long int x) { cerr << x; }\n    void print(signed long long int x) { cerr << x; }\n    void print(unsigned long long int x) { cerr << x; }\n    void print(float x) { cerr << x; }\n    void print(double x) { cerr << x; }\n    void print(long double x) { cerr << x; }\n    void print(string x) { cerr << '\\\"' << x << '\\\"'; }\n    template <size_t N>\n    void print(bitset<N> x) { cerr << x; }\n    void print(vector<bool> v)\n    { /* Overloaded this because stl optimizes vector<bool> by using\n          _Bit_reference instead of bool to conserve space. */\n        int f = 0;\n        cerr << '{';\n        for (auto &&i : v)\n            cerr << (f++ ? \",\" : \"\") << (i ? \"T\" : \"F\");\n        cerr << \"}\";\n    }\n    /* Templates Declarations to support nested datatypes */\n    template <typename T>\n    void print(T &&x);\n    template <typename T>\n    void print(vector<vector<T>> mat);\n    template <typename T, size_t N, size_t M>\n    void print(T (&mat)[N][M]);\n    template <typename F, typename S>\n    void print(pair<F, S> x);\n    template <typename T, size_t N>\n    struct Tuple;\n    template <typename T>\n    struct Tuple<T, 1>;\n    template <typename... Args>\n    void print(tuple<Args...> t);\n    template <typename... T>\n    void print(priority_queue<T...> pq);\n    template <typename T>\n    void print(stack<T> st);\n    template <typename T>\n    void print(queue<T> q);\n    /* Template Datatypes Definitions */\n    template <typename T>\n    void print(T &&x)\n    {\n        /*  This works for every container that supports range-based loop\n            i.e. vector, set, map, oset, omap, dequeue */\n        int f = 0;\n        cerr << '{';\n        for (auto &&i : x)\n            cerr << (f++ ? \",\" : \"\"), print(i);\n        cerr << \"}\";\n    }\n    template <typename T>\n    void print(vector<vector<T>> mat)\n    {\n        int f = 0;\n        cerr << \"\\n~~~~~\\n\";\n        for (auto &&i : mat)\n        {\n            cerr << setw(2) << left << f++, print(i), cerr << \"\\n\";\n        }\n        cerr << \"~~~~~\\n\";\n    }\n    template <typename T, size_t N, size_t M>\n    void print(T (&mat)[N][M])\n    {\n        int f = 0;\n        cerr << \"\\n~~~~~\\n\";\n        for (auto &&i : mat)\n        {\n            cerr << setw(2) << left << f++, print(i), cerr << \"\\n\";\n        }\n        cerr << \"~~~~~\\n\";\n    }\n    template <typename F, typename S>\n    void print(pair<F, S> x)\n    {\n        cerr << '(';\n        print(x.first);\n        cerr << ':';\n        print(x.second);\n        cerr << ')';\n    }\n    template <typename T, size_t N>\n    struct Tuple\n    {\n        static void printTuple(T t)\n        {\n            Tuple<T, N - 1>::printTuple(t);\n            cerr << \",\", print(get<N - 1>(t));\n        }\n    };\n    template <typename T>\n    struct Tuple<T, 1>\n    {\n        static void printTuple(T t) { print(get<0>(t)); }\n    };\n    template <typename... Args>\n    void print(tuple<Args...> t)\n    {\n        cerr << \"(\";\n        Tuple<decltype(t), sizeof...(Args)>::printTuple(t);\n        cerr << \")\";\n    }\n    template <typename... T>\n    void print(priority_queue<T...> pq)\n    {\n        int f = 0;\n        cerr << '{';\n        while (!pq.empty())\n            cerr << (f++ ? \",\" : \"\"), print(pq.top()), pq.pop();\n        cerr << \"}\";\n    }\n    template <typename T>\n    void print(stack<T> st)\n    {\n        int f = 0;\n        cerr << '{';\n        while (!st.empty())\n            cerr << (f++ ? \",\" : \"\"), print(st.top()), st.pop();\n        cerr << \"}\";\n    }\n    template <typename T>\n    void print(queue<T> q)\n    {\n        int f = 0;\n        cerr << '{';\n        while (!q.empty())\n            cerr << (f++ ? \",\" : \"\"), print(q.front()), q.pop();\n        cerr << \"}\";\n    }\n    /* Printer functions */\n    void printer(const char *) {} /* Base Recursive */\n    template <typename T, typename... V>\n    void printer(const char *names, T &&head, V &&...tail)\n    {\n        /* Using && to capture both lvalues and rvalues */\n        int i = 0;\n        for (size_t bracket = 0; names[i] != '\\0' and (names[i] != ',' or bracket != 0); i++)\n            if (names[i] == '(' or names[i] == '<' or names[i] == '{')\n                bracket++;\n            else if (names[i] == ')' or names[i] == '>' or names[i] == '}')\n                bracket--;\n        cerr.write(names, i) << \" = \";\n        print(head);\n        if (sizeof...(tail))\n            cerr << \", \", printer(names + i + 1, tail...);\n        else\n            cerr << \"]\\n\";\n    }\n    /* PrinterArr */\n    void printerArr(const char *) {} /* Base Recursive */\n    template <typename T, typename... V>\n    void printerArr(const char *names, T arr[], size_t N, V... tail)\n    {\n        size_t ind = 0;\n        for (; names[ind] and names[ind] != ','; ind++)\n            cerr << names[ind];\n        for (ind++; names[ind] and names[ind] != ','; ind++)\n            ;\n        cerr << \" = {\";\n        for (size_t i = 0; i < N; i++)\n            cerr << (i ? \",\" : \"\"), print(arr[i]);\n        cerr << \"}\";\n        if (sizeof...(tail))\n            cerr << \", \", printerArr(names + ind + 1, tail...);\n        else\n            cerr << \"]\\n\";\n    }\n}\n#ifndef ONLINE_JUDGE\n#define debug(...) std::cerr << __LINE__ << \": [\", __DEBUG_UTIL__::printer(#__VA_ARGS__, __VA_ARGS__);\n#define debugArr(...) std::cerr << __LINE__ << \": [\", __DEBUG_UTIL__::printerArr(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define debug(...)\n#define debugArr(...)\n#endif\n#endif\nvector<int>SegTree;\n \nvoid build(vector<int> &arr, int start, int end, int index) {\n    \n    if(start == end) {\n        SegTree[index]=arr[start];\n        return;\n    }\n    int mid = (start + end) / 2;\n    int left = 2 * index, right = 2 * index + 1;\n    build(arr, start, mid, left); // going down left\n    build(arr, mid+1, end, right); // going down right\n    SegTree[index] = (SegTree[left] & SegTree[right]); //give val to parent\n \n}\n \nvoid update(vector<int> &arr, int start, int end, int index, int pos, int value) {\n \n    if(start == end) {\n        arr[pos] = value;\n        SegTree[index] = arr[pos];\n        return;\n    }\n    int mid = (start + end) / 2;\n    if(mid >= pos) {\n        update(arr, start, mid, 2 * index, pos, value);\n    }\n    else {\n        update(arr, mid+1, end, 2 * index + 1, pos, value);\n    }\n    SegTree[index] = (SegTree[2 * index] & SegTree[2 * index + 1]);\n \n}\n \nint query(int start, int end, int index, int l, int r) {\n \n    if(start >= l and end <= r) {\n        return SegTree[index];\n    }\n    if(l > end or r < start) {\n        return INT_MAX;\n    }\n    int mid = (start + end) / 2;\n    int leftAns = query(start, mid, 2 * index, l, r);\n    int rightAns = query(mid + 1, end, 2 * index + 1, l, r);\n    return (leftAns & rightAns);\n \n}\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        \n        int n=nums.size();\n        SegTree.resize(4*n);\n        build(nums,0,n-1,1);\n        int ans=INT_MAX;\n        for(int i=0;i<n;i++) {\n            int low=i-1,high=n-1;\n            while(high-low>1) {\n                int mid=(low+high)/2;\n                if(query(0,n-1,1,i,mid)>=k) {\n                    low=mid;\n                }\n                else {\n                    high=mid;\n                }\n            }\n            if (low!=i-1)\n                ans = min(ans,abs(query(0,n-1,1,i,low)-k));\n            ans=min(ans,abs(k-query(0,n-1,1,i,high)));\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1717299681.0
}