{
    "username": "Coding4practice",
    "submission": "struct Node{\n    int left, right;\n    Node* left_child;\n    Node* right_child;\n    int val;\n    \n    Node(vector<int>& nums, int l, int r): left(l), right(r){\n        int mid = (l+r)/2;\n        val = 0;\n        if(l<r)\n        {\n            left_child = new Node(nums,l,mid);\n            right_child = new Node(nums,mid+1,r);\n            int peaks = left_child->val + right_child->val;\n            // if(mid>=1 && mid+1<nums.size() && nums[mid]>nums[mid-1]  && nums[mid]>nums[mid+1])\n            //     peaks++;\n            // if(mid>=0 && mid+2<nums.size() && nums[mid+1]>nums[mid]  && nums[mid+1]>nums[mid+2])\n            //     peaks++;\n            \n            val=peaks;\n        }\n        else\n        {\n            val=0;\n            if(l>=1 && l+1 < nums.size() && nums[l]>nums[l-1] && nums[l]>nums[l+1])\n                val=1;\n        }\n    }\n    \n    void update(int i, vector<int>& nums)\n    {\n        if(i<left || i>right || i<0 || i>=nums.size())\n            return;\n        if(left==right){\n            val=0;\n            int l = i;\n            if(l>=1 && l+1 < nums.size() && nums[l]>nums[l-1] && nums[l]>nums[l+1])\n                val=1;\n            return;\n        }\n        left_child->update(i,nums);\n        right_child->update(i,nums);\n        int peaks = left_child->val + right_child->val;\n        val=peaks;\n    }\n    \n    int find(int lo, int hi)\n    {\n        if(left>hi || right <lo)\n            return 0;\n        if(left>= lo && right <=hi)\n            return val;\n        return left_child->find(lo,hi) + right_child->find(lo,hi) ;\n        \n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> ans;\n        Node* root = new Node(nums,0,nums.size()-1);\n        for(auto& q:queries)\n        {\n            if(q[0]==1)\n            {\n                \n                int a = root->find(q[1],q[2]);\n                int l=q[1],r=q[2];\n                if(l>=1 && l+1 < nums.size() && nums[l]>nums[l-1] && nums[l]>nums[l+1])\n                    a--;\n                if(l!=r && r>=1 && r+1 < nums.size() && nums[r]>nums[r-1] && nums[r]>nums[r+1])\n                    a--;\n                ans.push_back(a);\n            }\n            else\n            {\n                nums[q[1]]=q[2];\n                int i=q[1];\n                root->update(i,nums);\n                root->update(i-1,nums);\n                root->update(i+1,nums);\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": 1718508237.0
}