{
    "username": "Rahul",
    "submission": "\n// class Solution {\n// public:\n//     char dp[100001][7];\n//     char dp_non_zero[100001][7];\n//     int nxt_mod[100001][7];\n//     int non_zero_nxt_mod[100001][7];\n\n//     string largestPalindrome(int n, int k) {\n//         if (k == 1  || k == 3 || k == 9) {\n//             return string(n, '9');\n//         }\n\n//         if (k == 2) {\n//             if (n == 1) {\n//                 return \"8\";  \n//             }\n//             string result(n, '9');\n//             result.front() = '8';\n//             result.back() = '8';\n//             return result;\n//         }\n\n//         if (k == 5) {\n//             if (n == 1) {\n//                 return \"5\"; \n//             }\n//             string result(n, '9');\n//             result.front() = '5';\n//             result.back() = '5';\n//             return result;\n//         }\n\n//         if (k == 4) {\n//             if (n <= 3) {\n//                 return string(n, '8');\n//             }\n//             string result(n, '9');\n//             result[0] = '8';\n//             result[1] = '8';\n//             result[n-2] = '8';\n//             result.back() = '8';\n//             return result;\n//         }\n\n//         if (k == 8) {\n//             if (n <= 5) {\n//                 return string(n, '8');\n//             }\n//             string result(n, '9');\n//             result[0] = '8';\n//             result[1] = '8';\n//             result[2] = '8';\n//             result[n-3] = '8';\n//             result.back() = '8';\n//             return result;\n//         }\n\n//         if (k == 6) {\n//             if (n == 1) {\n//                 return \"6\";\n//             }\n//             if (n == 2) {\n//                 return \"66\";\n//             }\n//             if (n == 3) {\n//                 return \"888\";\n//             }\n//             string result(n, '9');\n//             result.front() = '8';\n//             result.back() = '8';\n//             if (n % 2 == 1) {\n//                 result[n / 2] = '8';\n//             } else {\n//                 result[n / 2] = '7';\n//                 result[(n / 2) - 1] = '7';\n//             }\n//             return result;\n//         }\n\n        \n\n//         return \"\";\n//     }\n// };\n\n\n#include <string>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nclass Solution {\npublic:\n\t\tchar dp[100001][7];\n    char dp_non_zero[100001][7];\n    int nxt_mod[100001][7];\n    int non_zero_nxt_mod[100001][7];\n     string lP(int n, int k) {\n        if (n == 1) {\n            // Handle the single-digit case separately\n            for (int i = 9; i >= 1; --i) {\n                if (i % k == 0) {\n                    return to_string(i);\n                }\n            }\n            return \"-1\";\n        }\n\n        // Generate the largest n-digit number's first half\n        long long upper = pow(10, (n + 1) / 2) - 1;\n        long long lower = pow(10, (n - 1) / 2);\n\n        for (long long i = upper; i >= lower; --i) {\n            // Create the palindrome by mirroring the first half\n            string s = to_string(i);\n            string rev_s = s;\n            reverse(rev_s.begin(), rev_s.end());\n            string palindrome = (n % 2 == 0) ? s + rev_s : s + rev_s.substr(1);\n\n            long long num = stoll(palindrome);\n            if (num % k == 0) {\n                return palindrome;\n            }\n        }\n\n        return \"-1\";  // If no palindrome is found\n    }\n    \n    string largestPalindrome(int n, int k) {\n        string s(n, '9');  // Initialize the string with '9'\n\n        if (k == 1) {\n            return s;\n        }\n        if (k == 2) {\n            s[0] = '8';\n            s[n-1] = '8';\n            return s;\n        }\n        if (k == 3) {\n            return s;\n        }\n        if (k == 4) {\n            if (n == 1) return \"8\";\n            if (n == 2) return \"88\";\n            if (n == 3) return \"888\";\n            if (n > 3) {\n                s[0] = '8';\n                s[1] = '8';\n                s[n-1] = '8';\n                s[n-2] = '8';\n                return s;\n            }\n        }\n        if (k == 5) {\n            if (n == 1) return \"5\";\n            if (n > 1) {\n                s[0] = '5';\n                s[n-1] = '5';\n                return s;\n            }\n        }\n        if (k == 6) {\n            if (n == 1) return \"6\";\n            if (n == 2) return \"66\";\n            if (n > 2) {\n                s[0] = '8';\n                s[n-1] = '8';\n                if (n % 2 == 1) {  // n is odd\n                    s[n/2] = '8';  // Middle character for odd length\n                } else {  // n is even\n                    if(n == 4){\n                        return \"8778\";\n                    }\n                   if(n > 4){\n                        s[n/2 - 1] = '7';  // Middle-left for even-length strings\n    s[n/2] = '7';      // Middle-right for even-length strings\n    s[n/2 - 2] = '9';  // Just left of the middle-left\n    s[n/2 + 1] = '9';  // Just right of the middle-right\n\n                   }\n                }\n                return s;\n            }\n        }\n        if (k == 7) {\n            if (n == 1) {\n                return \"7\";\n            }\n\n            fill(&dp[0][0], &dp[0][0] + sizeof(dp), 0);\n            fill(&dp_non_zero[0][0], &dp_non_zero[0][0] + sizeof(dp_non_zero), 0);\n\n            for (int i = 1; i < 10; ++i) {\n                dp[1][i % 7] = '0' + i;\n                if (i != 0) {\n                    dp_non_zero[1][i % 7] = '0' + i;\n                }\n            }\n\n            int base_mod = 10 % 7;\n            for (int i = 0; i <= 100000 - 2; ++i) {\n                for (int j = 0; j < 7; ++j) {\n                    if ((i == 0 && j != 0) || (i > 0 && dp[i][j] == 0)) {\n                        continue;\n                    }\n                    for (int k = 9; k >= 0; --k) {\n                        int new_mod = (base_mod * k + k + j * 10) % 7;\n                        if (dp[i + 2][new_mod] == 0 || dp[i + 2][new_mod] < '0' + k) {\n                            dp[i + 2][new_mod] = '0' + k;\n                            nxt_mod[i + 2][new_mod] = j;\n                        }\n                        if (k == 0) continue;\n                        if (dp_non_zero[i + 2][new_mod] == 0 || dp_non_zero[i + 2][new_mod] < '0' + k) {\n                            dp_non_zero[i + 2][new_mod] = '0' + k;\n                            non_zero_nxt_mod[i + 2][new_mod] = j;\n                        }\n                    }\n                }\n                base_mod = (base_mod * 10) % 7;\n            }\n\n            int q = n;\n            string front(1, dp_non_zero[q][0]);\n            string back(1, dp_non_zero[q][0]);\n            int mod = non_zero_nxt_mod[q][0];\n            q -= 2;\n            while (q > 0) {\n                front += dp[q][mod];\n                if (q > 1) {\n                    back += dp[q][mod];\n                } else {\n                    break;\n                }\n                mod = nxt_mod[q][mod];\n                q -= 2;\n            }\n            reverse(back.begin(), back.end());\n            return front + back;\n        }\n        if (k == 8) {\n            if (n == 1) return \"8\";\n            if (n == 2) return \"88\";\n            if (n == 3) return \"888\";\n            if(n == 4) return \"8888\";\n            if(n == 5)return \"88888\";\n            if(n >= 6){\n                s[0] = '8';\n                s[1] = '8';\n                s[2] = '8';\n                s[n-1] = '8';\n                s[n-2] = '8';\n                s[n-3] = '8';\n            }\n            return s;\n        }\n        if (k == 9) {\n            return string(n, '9');\n        }\n        \n        return \"\"; // Default return if no case is matched\n    }\n};",
    "submit_ts": "1723953592",
    "subm_id": "1359825795"
}