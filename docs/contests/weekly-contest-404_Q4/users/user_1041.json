{
    "username": "Ashansh1",
    "submission": "class Solution {\npublic:\n    pair<int,int> radius_find(vector<int> degree,vector<int> adj[],int &n)\n    {\n        queue<int> q;\n        vector<int> level(n+1,0);\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 1) {\n                q.push(i);\n            }\n        }\n        int maxlevel=0;\n\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n\n            for(auto it:adj[v])\n            {\n                degree[it]--;\n                if (degree[it] == 1) {\n                        q.push(it);\n                        level[it] = level[v] + 1;\n                        maxlevel = max(maxlevel, level[it]);\n                    }\n            }\n        }\n        set<int> c;\n        for (int i = 0; i < n; i++) {\n            if (level[i] == maxlevel) {\n                c.insert(i);\n            }\n        }\n        int dia=2*maxlevel+c.size()-1;\n        return {dia,(dia+1)/2};\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int n=edges1.size()+1;\n        int m=edges2.size()+1;\n        vector<int> adj1[n];\n        vector<int> adj2[m];\n        vector<int> indegree1(n,0),indegree2(m,0);\n        for(auto it:edges1){\n            indegree1[it[0]]++;\n            indegree1[it[1]]++;\n            adj1[it[0]].push_back(it[1]);\n            adj1[it[1]].push_back(it[0]);\n        }\n        for(auto it:edges2){\n            indegree2[it[0]]++;\n            indegree2[it[1]]++;\n            adj2[it[0]].push_back(it[1]);\n            adj2[it[1]].push_back(it[0]);\n        }\n        pair<int,int> rad1=radius_find(indegree1,adj1,n);\n        pair<int,int> rad2=radius_find(indegree2,adj2,m);\n        return max(rad1.first,max(rad2.first,rad1.second+rad2.second+1));\n    }\n};",
    "submit_ts": 1719718895.0
}