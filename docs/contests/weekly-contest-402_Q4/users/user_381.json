{
    "username": "man-ray",
    "submission": "class Solution {\n    static void init(int n) {\n        int len = 4 * n;\n        l = new int[len];\n        r = new int[len];\n        lazy = new int[len];\n        sum = new long[len];\n        max = new long[len];\n        min = new long[len];\n        build(1, 0, n - 1);//\u9ed8\u8ba4\u6839\u8282\u70b9\u7f16\u53f7\u4e3a 1\uff0c\u533a\u95f4\u5de6\u7aef\u70b9\u4e3a 0 \uff0c\u53f3\u7aef\u70b9\u4e3a n - 1\n    }\n\n    static void build(int u, int le, int ri) {\n        l[u] = le;\n        r[u] = ri;\n        if (le == ri) return;\n        int mid = le + ri >> 1;\n        build(u << 1, le, mid);\n        build(u << 1 | 1, mid + 1, ri);\n        pushUp(u);\n    }\n\n    static void init(int n, int[] a) {\n        int len = 4 * n;\n        l = new int[len];\n        r = new int[len];\n        lazy = new int[len];\n        sum = new long[len];\n        max = new long[len];\n        min = new long[len];\n        build(1, 0, n - 1, a);//\u9ed8\u8ba4\u6839\u8282\u70b9\u7f16\u53f7\u4e3a 1\uff0c\u533a\u95f4\u5de6\u7aef\u70b9\u4e3a 0 \uff0c\u53f3\u7aef\u70b9\u4e3a n - 1\n    }\n\n    static void build(int u, int le, int ri, int[] a) {\n        l[u] = le;\n        r[u] = ri;\n        if (le == ri) {\n            sum[u] = max[u] = min[u] = a[le];\n            return;\n        }\n        int mid = le + ri >> 1;\n        build(u << 1, le, mid, a);\n        build(u << 1 | 1, mid + 1, ri, a);\n        pushUp(u);\n    }\n\n    //\u5b50\u8282\u70b9\u4fe1\u606f\u66f4\u65b0\u7236\u8282\u70b9\u4fe1\u606f\n    static void pushUp(int u) {\n        max[u] = Math.max(max[u << 1], max[u << 1 | 1]);\n        min[u] = Math.min(min[u << 1], min[u << 1 | 1]);\n        sum[u] = sum[u << 1] + sum[u << 1 | 1];\n    }\n\n    //\u4e0b\u4f20\u61d2\u6807\u8bb0\n    static void pushDown(int u) {\n        if (lazy[u] == 0) return;\n        pd(u << 1, lazy[u]);\n        pd(u << 1 | 1, lazy[u]);\n        lazy[u] = 0;\n    }\n\n    static void pd(int u, int lz) {\n        sum[u] += lz * (r[u] - l[u] + 1);\n        lazy[u] += lz;\n        max[u] += lz;\n        min[u] += lz;\n    }\n\n    //\u533a\u95f4\u4fee\u6539 \u533a\u95f4 + v\n    static void updateRange(int u, int le, int ri, int v) {\n        if (le <= l[u] && r[u] <= ri) {//\u5b8c\u5168\u8986\u76d6\n            pd(u, v);\n            return;\n        }\n        pushDown(u);\n        int mid = l[u] + r[u] >> 1;\n        if (mid >= le) updateRange(u << 1, le, ri, v);\n        if (mid < ri) updateRange(u << 1 | 1, le, ri, v);\n        pushUp(u);\n    }\n\n    //\u5355\u70b9\u4fee\u6539,\u5c06\u4e0b\u6807 idx \u5904\u7684\u503c\u52a0\u4e0a v\n    static void update(int u, int idx, int v) {\n        if (l[u] == idx && r[u] == idx) {\n            pd(u, v);\n            return;\n        }\n        pushDown(u);\n        int mid = l[u] + r[u] >> 1;\n        if (mid >= idx) update(u << 1, idx, v);\n        else update(u << 1 | 1, idx, v);\n        pushUp(u);\n    }\n\n    //\u5355\u70b9\u67e5\u8be2\n    static long querySingle(int u, int x) {\n        if (l[u] == x && r[u] == x) return sum[u];\n        pushDown(u);\n        int mid = l[u] + r[u] >> 1;\n        if (mid >= x) return querySingle(u << 1, x);\n        else return querySingle(u << 1 | 1, x);\n    }\n\n    //\u533a\u95f4\u548c\u67e5\u8be2\n    static long queryRangeSum(int u, int le, int ri) {\n        if (le <= l[u] && r[u] <= ri) {//\u5b8c\u5168\u8986\u76d6\n            return sum[u];\n        }\n        pushDown(u);\n        int mid = l[u] + r[u] >> 1;\n        long ret = 0;\n        if (mid >= le) ret += queryRangeSum(u << 1, le, ri);\n        if (mid < ri) ret += queryRangeSum(u << 1 | 1, le, ri);\n        return ret;\n    }\n\n    //\u533a\u95f4\u6700\u5927\u503c\u67e5\u8be2\n    static long queryRangeMax(int u, int le, int ri) {\n        if (le <= l[u] && r[u] <= ri) {//\u5b8c\u5168\u8986\u76d6\n            return max[u];\n        }\n        pushDown(u);\n        int mid = l[u] + r[u] >> 1;\n        long ret = Long.MIN_VALUE;\n        if (mid >= le) ret = Math.max(ret, queryRangeMax(u << 1, le, ri));\n        if (mid < ri) ret = Math.max(ret, queryRangeMax(u << 1 | 1, le, ri));\n        return ret;\n    }\n\n    //\u533a\u95f4\u6700\u5c0f\u503c\u67e5\u8be2\n    static long queryRangeMin(int u, int le, int ri) {\n        if (le <= l[u] && r[u] <= ri) {//\u5b8c\u5168\u8986\u76d6\n            return min[u];\n        }\n        pushDown(u);\n        int mid = l[u] + r[u] >> 1;\n        long ret = Long.MAX_VALUE;\n        if (mid >= le) ret = Math.min(ret, queryRangeMin(u << 1, le, ri));\n        if (mid < ri) ret = Math.min(ret, queryRangeMin(u << 1 | 1, le, ri));\n        return ret;\n    }\n\n    static int[] l, r, lazy;\n    static long[] sum, max, min;\n\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        List<Integer> ans = new ArrayList<>();\n        int n = nums.length;\n        int cnt = 0;\n        init(n);\n        //  boolean[] f = new boolean[n];\n        for (int i = 1; i < n - 1; i++) {\n            if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {\n                //     f[i] = true;\n                update(1, i, 1);\n                cnt++;\n            }\n        }\n        for (int[] q : queries) {\n            if (q[0] == 1) {\n                if (q[1] + 2 > q[2]) {\n                    ans.add(0);\n                    continue;\n                }\n                ans.add((int) queryRangeSum(1, q[1] + 1, q[2] - 1));\n            } else {\n                if (q[1] > 0 && q[1] < n - 1) {\n                    if (nums[q[1]] > nums[q[1] - 1] && nums[q[1]] > nums[q[1] + 1]) update(1, q[1], -1);\n                    nums[q[1]] = q[2];\n                    if (nums[q[1]] > nums[q[1] - 1] && nums[q[1]] > nums[q[1] + 1]) update(1, q[1], 1);\n                }else  nums[q[1]] = q[2];\n                if (q[1] - 1 > 0) {\n                    if (querySingle(1, q[1] - 1) == 0) {\n                        if (nums[q[1] - 1] > nums[q[1] - 2] && nums[q[1] - 1] > nums[q[1]])\n                            update(1, q[1] - 1, 1);\n                    } else {\n                        if (nums[q[1] - 1] <= nums[q[1] - 2] || nums[q[1] - 1] <= nums[q[1]])\n                            update(1, q[1] - 1, -1);\n                    }\n                }\n                if (q[1] + 1 < n - 1) {\n                    if (querySingle(1, q[1] + 1) == 0) {\n                        if (nums[q[1] + 1] > nums[q[1]] && nums[q[1] + 1] > nums[q[1] + 2])\n                            update(1, q[1] + 1, 1);\n                    } else {\n                        if (nums[q[1] + 1] <= nums[q[1]] || nums[q[1] + 1] <= nums[q[1] + 2])\n                            update(1, q[1] + 1, -1);\n                    }\n                }\n            }\n        }\n        return ans;\n\n\n    }\n}",
    "submit_ts": 1718506172.0
}