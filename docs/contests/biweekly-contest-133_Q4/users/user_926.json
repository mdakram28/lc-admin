{
    "username": "ysh101",
    "submission": "#define ll long long\n#define pb push_back\n#define ff first\n#define ss second\n#define mp make_pair\n#define vvi vector<vector<int>>\n#define vi vector<int>\n#define pii pair<int,int>\n#define read(a,n) for(int i=0;i<n;i++) cin>>a[i];\n#define rep(i,a,b) for (int i = a; i < b; i++)\n// cpp template\nclass Solution {\npublic:\n    int numberOfPermutations(int n, vector<vector<int>>& reqs) {\n        const int MOD = 1e9 + 7;\n        const int limit = 400;\n        // requirements[i] = [endi, cnti] represents the end index and the inversion count of each requirement.\n        // A pair of indices (i, j) from an integer array nums is called an inversion if: i < j and nums[i] > nums[j]\n        // perm of [0, 1, 2, ..., n - 1] such that for all requirements[i], perm[0..endi] has exactly cnti inversions.\n        int ans = 0;\n        vvi permutation_cnt(n + 1, vi(limit+1, 0));\n        permutation_cnt[0][0] = 1;\n        unordered_map<int, int> tracker;\n        for (auto& a : reqs) {\n            tracker[a[0] + 1] = a[1];\n        }\n        rep(p_length, 1, n + 1) {\n            rep(p_inv, 0, limit + 1) {\n                rep(p_pos, 0, p_length) {\n                    int ok = p_inv - p_pos;\n                    if (ok >= 0) permutation_cnt[p_length][p_inv] = (permutation_cnt[p_length][p_inv] + permutation_cnt[p_length - 1][ok]) % MOD;  \n                }\n            }\n            if (tracker.count(p_length)) {\n                int targetInv = tracker[p_length];\n                rep(p_inv, 0, limit + 1) {\n                    if (p_inv != targetInv) permutation_cnt[p_length][p_inv] = 0;\n                }\n            }\n        }\n        int size = permutation_cnt[n].size();\n        rep(i, 0, size) ans = (ans + permutation_cnt[n][i]) % MOD;\n        return ans;\n    }\n};\n",
    "submit_ts": 1719071563.0
}