{
    "username": "CuteTN",
    "submission": "//\n//\n//#region Numbers Compressor\nclass NumbersCompressor {\n  constructor() {\n    /**\n     * @type {Set<number>}\n     * @private\n     */\n    this._set = new Set();\n\n    /**\n     * @type {number[]}\n     * @private\n     */\n    this._arr = [];\n\n    /**\n     * @type {Set<number>}\n     * @private\n     */\n    this._compressed = false;\n  }\n\n  clear() {\n    this._set.clear();\n    this._compressed = false;\n  }\n\n  push(...items) {\n    for (let i = items.length - 1; i >= 0; i--) {\n      const item = items[i];\n      if (!this._set.has(item)) {\n        if (this._set.size < this._arr.length) this._arr[this._set.size] = item;\n        else this._arr.push(item);\n        this._set.add(item);\n        this._compressed = false;\n      }\n    }\n  }\n\n  /** @private */\n  _compress() {\n    if (this._compressed) return;\n    while (this._arr.length > this._set.size) this._arr.pop();\n    this._arr.sort((a, b) => a - b);\n    this._compressed = true;\n  }\n\n  get size() {\n    return this._set.size;\n  }\n\n  getNum(ord) {\n    if (!this._compressed) this._compress();\n    return this._arr[ord];\n  }\n\n  getOrd(num) {\n    if (!this._compressed) this._compress();\n\n    let l = 0;\n    let r = this._arr.length;\n    let m;\n    while (l <= r) {\n      m = (l + r) >> 1;\n      if (this._arr[m] === num) return m;\n      if (this._arr[m] > num) r = m - 1;\n      else l = m + 1;\n    }\n\n    return -1;\n  }\n}\n//#endregion\n\nlet numCom = new NumbersCompressor();\nlet dp = Array.from({ length: 52 }, () => new Uint16Array(5005));\nlet maxes1 = new Int16Array(52);\nlet maxes2 = new Int16Array(52);\n\nfunction updateMax(k, x) {\n  if (x == maxes1[k] || x == maxes2[k]) {\n    if (maxes2[k] >= 0 && dp[k][maxes2[k]] > dp[k][maxes1[k]]) {\n      let t = maxes1[k];\n      maxes1[k] = maxes2[k];\n      maxes2[k] = t;\n    }\n  } else {\n    if (maxes1[k] < 0 || dp[k][x] >= dp[k][maxes1[k]]) {\n      maxes2[k] = maxes1[k];\n      maxes1[k] = x;\n    } else if (maxes2[k] < 0 || dp[k][x] > dp[k][maxes2[k]]) {\n      maxes2[k] = x;\n    }\n  }\n}\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function (nums, k) {\n  let n = nums.length;\n  numCom.clear();\n  numCom.push(...nums);\n\n  for (let i = 0; i <= k; ++i) {\n    dp[i].fill(0, 0, n);\n    maxes1[i] = -1;\n    maxes2[i] = -1;\n  }\n  for (let i = 0; i < n; ++i) {\n    nums[i] = numCom.getOrd(nums[i]);\n  }\n\n  let res = 1;\n\n  for (let i = 0; i < n; ++i) {\n    let x = nums[i];\n\n    for (let j = k; j; --j) {\n      let max = maxes1[j - 1];\n      if (max == x) max = maxes2[j - 1];\n      dp[j][x] = Math.max(dp[j][x], dp[j - 1][max]) + 1;\n      updateMax(j, x);\n\n      res = Math.max(dp[j][x], res);\n    }\n\n    res = Math.max(++dp[0][x], res);\n    updateMax(0, x);\n  }\n\n  return res;\n};",
    "submit_ts": 1717860699.0
}