{
    "username": "horiseun",
    "submission": "class Solution {\npublic:\n  struct Peak {\n    int l, la, r, ra, cnt;\n    Peak(): l(0), la(0), r(0), ra(0), cnt(0) {}\n    Peak(int tl, int tla, int tr, int tra, int tcnt): l(tl), la(tla), r(tr), ra(tra), cnt(tcnt) {}\n  };\n  \n  static Peak merge(Peak left, Peak right) {\n    if (left.l == -1 && left.la == -1 && left.r == -1 && left.ra == -1 && left.cnt == -1) {\n      return right;\n    }\n    if (right.l == -1 && right.la == -1 && right.r == -1 && right.ra == -1 && right.cnt == -1) {\n      return left;\n    }\n    Peak ret;\n    ret.cnt = left.cnt + right.cnt;\n    ret.l = left.l;\n    if (left.la == -1) {\n      ret.la = right.l;\n    } else {\n      ret.la = left.la;\n    }\n    ret.r = right.r;\n    if (right.ra == -1) {\n      ret.ra = left.r;\n    } else {\n      ret.ra = right.ra;\n    }\n\n    if ((left.ra != -1 && (left.ra < left.r && left.r > right.l)) || (right.ra != -1 && (left.r < right.l && right.l > right.la))) {\n      ret.cnt++;\n    }\n    return ret;\n  }\n  \n  struct Node {\n    int l, r;\n    Peak p;\n    Node *lft, *rht;\n    Node(int tl, int tr, vector<int> &v): l(tl), r(tr), p() {\n      if (l + 1 != r) {\n        lft = new Node(l, (l + r) / 2, v);\n        rht = new Node((l + r) / 2, r, v);\n        Peak lftp = lft->p;\n        if (!lft) {\n          lftp = {-1, -1, -1, -1, -1};\n        }\n        Peak rhtp = rht->p;\n        if (!rht) {\n          rhtp = {-1, -1, -1, -1, -1};\n        }\n        p = merge(lftp, rhtp);\n      } else {\n        lft = rht = NULL;\n        p = Peak(v[l], -1, v[l], -1, 0);\n      }\n    }\n  };\n  \n  void update(Node *x, int pos, int val) {\n    if (pos < x->l || x->r <= pos) {\n      return;\n    }\n    if (x->l + 1 == x->r) {\n      x->p = Peak(val, -1, val, -1, 0);\n      Peak ret = x->p;\n      return;\n    }\n    update(x->lft, pos, val);\n    update(x->rht, pos, val);\n    x->p = merge(x->lft->p, x->rht->p);\n  }\n  \n  Peak query(Node *x, int l, int r) {\n    if (r <= x->l || x->r <= l) {\n      return {-1, -1, -1, -1, -1};\n    }\n    if (l <= x->l && x->r <= r) {\n      return x->p;\n    }\n    return merge(query(x->lft, l, r), query(x->rht, l, r));\n  }\n  \n  Node *root;\n  \n  vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n    root = new Node(0, nums.size(), nums);\n    vector<int> ans;\n    for (auto v : queries) {\n      if (v[0] == 1) {\n        ans.push_back(query(root, v[1], v[2] + 1).cnt);\n      } else {\n        update(root, v[1], v[2]);\n      }\n    }\n    return ans;\n  }\n};",
    "submit_ts": 1718508244.0
}