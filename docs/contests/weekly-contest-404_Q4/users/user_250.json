{
    "username": "btcmoon",
    "submission": "class Solution {\n    private class GG {\n        List<Integer> nodes;\n        int height;\n        \n        GG(List<Integer> nodes, int height) {\n            this.nodes = nodes;\n            this.height = height;\n        }\n    }\n    \n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        GG info1 = minimumHeight(edges1);\n        GG info2 = minimumHeight(edges2);\n        \n        int h1 = (info1.nodes.size() == 2) ? info1.height + 1 : info1.height;\n        int h2 = (info2.nodes.size() == 2) ? info2.height + 1 : info2.height;\n        int dia1 = (info1.nodes.size() == 2) ? info1.height * 2 + 1 : info1.height * 2;\n        int dia2 = (info2.nodes.size() == 2) ? info2.height * 2 + 1 : info2.height * 2;\n        \n        return Math.max(h1 + h2 + 1, Math.max(dia1, dia2));\n    }\n\n    private GG minimumHeight(int[][] edges) {\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        Map<Integer, Integer> inDegree = new HashMap<>();\n        Set<Integer> vertices = new HashSet<>();\n        \n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            \n            vertices.add(u);\n            vertices.add(v);\n            \n            graph.computeIfAbsent(u, k -> new ArrayList<>()).add(v);\n            graph.computeIfAbsent(v, k -> new ArrayList<>()).add(u);\n            \n            inDegree.put(u, inDegree.getOrDefault(u, 0) + 1);\n            inDegree.put(v, inDegree.getOrDefault(v, 0) + 1);\n        }\n        \n        Deque<Integer> queue = new ArrayDeque<>();\n        Set<Integer> remaining = new HashSet<>(vertices);\n        int height = 0;\n        \n        for (int vertex : vertices) {\n            if (inDegree.get(vertex) == 1) {\n                queue.add(vertex);\n            }\n        }\n        \n        while (remaining.size() > 2) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int u = queue.poll();\n                remaining.remove(u);\n                for (int v : graph.get(u)) {\n                    inDegree.put(v, inDegree.get(v) - 1);\n                    if (inDegree.get(v) == 1) {\n                        queue.add(v);\n                    }\n                }\n            }\n            height++;\n        }\n        \n        return new GG(new ArrayList<>(remaining), height);\n    }\n}\n",
    "submit_ts": "1719717797",
    "subm_id": "1304401008"
}