{
    "username": "vmadhu99",
    "submission": "using ll = long long;\n\n#define f first\n#define s second\n\ntemplate <class T>\nstruct segtree {\n    vector<T> elems;\n    vector<T> mn, sum, lzy;\n    vector<pair<int, int>> seg;\n    void init(vector<T>& elems){\n        this -> elems = elems;\n        int n = elems.size();\n        mn.resize(n * 4);\n        sum.resize(n * 4);\n        lzy.resize(n * 4);\n        seg.resize(n * 4);\n        build(1, 0, n - 1);\n    }\n    void refresh(int i){\n        mn[i] = min(mn[i << 1], mn[(i << 1) + 1]);\n        sum[i] = sum[i << 1] + sum[(i << 1) + 1];\n    }\n    void build(int i, int l, int r){\n        lzy[i] = 0;\n        seg[i] = {l, r};\n        if(l == r){\n            mn[i] = sum[i] = elems[l];\n        } else {\n            build((i << 1), l, (l + r) >> 1);\n            build((i << 1) + 1, ((l + r) >> 1) + 1, r);\n            refresh(i);\n        }\n    }\n    void chk_lzy(int i){\n        if(lzy[i] != 0){\n            mn[i] += lzy[i];\n            sum[i] += (lzy[i] * (seg[i].s - seg[i].f + 1));\n        if((i << 1) < lzy.size()){\n            lzy[(i << 1)] += lzy[i];\n        }\n        if((i << 1) + 1 < lzy.size()){\n            lzy[(i << 1) + 1] += lzy[i];\n        }\n            lzy[i] = 0;\n        }\n    }\n    void upd_rng(int l, int r, T inc, int i = 1){\n        if(i >= seg.size()){\n        return;\n        }\n        chk_lzy(i);\n        if(l <= seg[i].f && r >= seg[i].s){\n            lzy[i] = inc;\n            chk_lzy(i);\n        } else if (r < seg[i].f || l > seg[i].s){\n            return;\n        } else {\n            upd_rng(l, r, inc, (i << 1));\n            upd_rng(l, r, inc, (i << 1) + 1);\n            refresh(i);\n        }\n    }\n    T rsq(int l, int r, int i = 1){\n        if(i >= seg.size()){\n            return 0;\n        }\n        chk_lzy(i);\n        if(l <= seg[i].f && r >= seg[i].s){\n            return sum[i];\n        } else if (r < seg[i].f || l > seg[i].s){\n            return 0;\n        } else {\n            return rsq(l, r, (i << 1)) + rsq(l, r, (i << 1) + 1);\n        }\n    }\n};\n\n\nclass Solution {\npublic:\n    vector<ll> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n        int n = s.size();\n        int m = queries.size();\n        vector<vector<pair<int, int>>> q(n);\n        vector<ll> ans(m);\n        for(int i = 0; i < m; i++){\n            q[queries[i][0]].push_back({queries[i][1], i});\n        }\n        vector<vector<int>> segs(n);\n        vector<int> o(n);\n        int curr = 0;\n        for(int i = 0; i < n; i++){\n            curr += (s[i] == '1');\n            o[i] = curr;\n        }\n        vector<ll> idx_end(n + 5), idx_start(n + 5), cnt_end(n + 5), cnt_start(n + 5), len(n + 5);\n        for(int i = 0; i < n; i++){\n            int l = i, r = n - 1;\n            int to = -1;\n            while(l <= r){\n                int mid = (l + r) / 2;\n                int oc = o[mid] - (i == 0 ? 0 : o[i - 1]);\n                int zc = mid - i + 1 - oc;\n                if(oc <= k || zc <= k){\n                    to = mid;\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n            segs[i].push_back(to);\n            idx_start[i] += i;\n            idx_end[to] += i;\n            len[to] += (to - i + 1);\n            cnt_end[to]++;\n            cnt_start[i]++;\n        }\n        // cout << (len[4] + len[3] + len[2] + len[1] + len[0]) << endl;\n        segtree<ll> idx_startst, idx_endst, cnt_endst, cnt_startst, lenst;\n        idx_startst.init(idx_start);\n        idx_endst.init(idx_end);\n        cnt_startst.init(cnt_start);\n        cnt_endst.init(cnt_end);\n        lenst.init(len);\n        // cout << lenst.rsq(1, 4) << endl;\n        for(int i = 0; i < n; i++){\n            for(auto x : q[i]){\n                ll n_overlap = cnt_endst.rsq(x.f + 1, n - 1) - cnt_startst.rsq(x.f + 1, n - 1);\n                // cout << \"at \" << i << \" n_overlap: \" << n_overlap << endl;\n                ans[x.s] += lenst.rsq(i, x.f);\n                // cout << \"at \" << i << \", \" << lenst.rsq(i, x.f) << endl;\n                ans[x.s] += (n_overlap * (x.f + 1)) - (idx_endst.rsq(x.f + 1, n - 1) - idx_startst.rsq(x.f + 1, n - 1));\n                // cout << \"at \" << i << \" overlap tot: \" << (idx_endst.rsq(x.f + 1, n - 1)) << \" \" << (idx_startst.rsq(x.f + 1, n - 1)) << endl;\n            }\n            for(int x : segs[i]){\n                // cout << \"seg \" << i << \", \" << x << endl;\n                idx_startst.upd_rng(i, i, -i);\n                idx_endst.upd_rng(x, x, -i);\n                cnt_startst.upd_rng(i, i, -1);\n                cnt_endst.upd_rng(x, x, -1);\n                lenst.upd_rng(x, x, -(x - i + 1));\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1723953515",
    "subm_id": "1359823371"
}