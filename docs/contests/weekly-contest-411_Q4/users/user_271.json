{
    "username": "RWBY27",
    "submission": "// #include <bits/stdc++.h>\n// //#include <ext/pb_ds/assoc_container.hpp>\n// //#include <ext/pb_ds/tree_policy.hpp>\n// #define fastio()                  \\\n//     ios_base::sync_with_stdio(0); \\\n//     cin.tie(0);                   \\\n//     cout.tie(0)\n#define pb push_back\n#define show(x) cout << (#x) << \" : \" << x << endl;\n//typedef __int128 bigll;\ntypedef long long ll;\n#define ull unsigned long long\n#define ld long double\n#define pow power\n#define mp make_pair\n#define ff first\n#define ss second\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define sq(x) ((x) * (x))\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define siz(a) int((a).size())\n#define For(i,a,b) for(int (i)=(a);(i) < (b); ++(i))\n#define Forl(i,a,b) for(ll (i)=(a);(i) < (b); ++(i))\n#define Forn(i,a,b) for(int (i)=(a);(i) >= (b); --(i))\n#define Fornl(i,a,b) for(ll (i)=(a);(i) >= (b); --(i))\n#define endl \"\\n\"\n#define pi 3.14159265\n#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst ll mod1 = 998244353;\nconst ll INF  = 1ll*1000*1000*1000*1000*1000*1000 + 7; \n\nstruct segtree {\n\n    ll size;\n    vector <ll> sums;\n\n    void init (ll n) {\n        size = 1;\n        while (size < n)\n            size *= 2;\n\n        sums.assign(2 * size, 0LL);\n    }\n\n    void set (ll i, ll v, ll x, ll lx, ll rx) {\n        if (rx - lx == 1) {\n            sums[x] = v;\n            return;\n        }\n        ll m = (lx + rx)/2;\n        if (i < m) {\n            set(i, v, 2 * x + 1, lx, m);\n        } else {\n            set(i, v, 2 * x + 2, m, rx);\n        }\n        sums[x] = sums[2 * x + 1] + sums[2 * x + 2];\n\n    }\n\n    void set (ll i, ll v) {\n        set(i, v, 0, 0, size);\n    }\n\n    ll sum (ll l, ll r, ll x, ll lx, ll rx) {\n        if (lx >= r || l >= rx) return 0;\n        if (lx >=l and rx <= r) return sums[x];\n        ll m = (lx + rx)/2;\n        ll s1 = sum(l, r, 2 * x + 1, lx, m);\n        ll s2 = sum(l, r, 2 * x + 2, m, rx);\n        return s1 + s2;\n    }\n\n    ll sum (ll l, ll r) {\n        return sum(l, r, 0, 0, size);\n    }\n\n};\n\nstruct segtree2 {\n\n    ll size;\n    vector <ll> sums;\n\n    void init (ll n) {\n        size = 1;\n        while (size < n)\n            size *= 2;\n\n        sums.assign(2 * size, 0LL);\n    }\n\n    void set (ll i, ll v, ll x, ll lx, ll rx) {\n        if (rx - lx == 1) {\n            sums[x] += v;\n            return;\n        }\n        ll m = (lx + rx)/2;\n        if (i < m) {\n            set(i, v, 2 * x + 1, lx, m);\n        } else {\n            set(i, v, 2 * x + 2, m, rx);\n        }\n        sums[x] = sums[2 * x + 1] + sums[2 * x + 2];\n\n    }\n\n    void set (ll i, ll v) {\n        set(i, v, 0, 0, size);\n    }\n\n    ll sum (ll l, ll r, ll x, ll lx, ll rx) {\n        if (lx >= r || l >= rx) return 0;\n        if (lx >=l and rx <= r) return sums[x];\n        ll m = (lx + rx)/2;\n        ll s1 = sum(l, r, 2 * x + 1, lx, m);\n        ll s2 = sum(l, r, 2 * x + 2, m, rx);\n        return s1 + s2;\n    }\n\n    ll sum (ll l, ll r) {\n        return sum(l, r, 0, 0, size);\n    }\n\n};\n\n\nclass Solution {\npublic:\n    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n      ll n = siz(s);\n      vector <ll> upto(n + 1);\n      vector <vector <ll>> pre(n + 1, vector <ll> (2));\n      vector <vector <ll>> segments(n + 2);\n      vector <vector <pll>> qrys(n + 2);\n      For(i,0,siz(queries)) {\n        qrys[queries[i][1] + 1].pb({i, queries[i][0] + 1});\n      }\n\n      vector <ll> ans(siz(queries));\n\n      For(i,0,n) {\n        pre[i + 1][0] = pre[i][0];\n        pre[i + 1][1] = pre[i][1];\n        if (s[i] == '0') {\n          pre[i + 1][0] += 1;\n        } else {\n          pre[i + 1][1] += 1;\n        }\n      }\n\n      For(i,0,n) {\n        ll l = i, r = n - 1;\n        while (l < r) {\n          ll mid = (l + r + 1) / 2;\n          ll s1 = pre[mid + 1][0] - pre[i][0];\n          ll s2 = pre[mid + 1][1] - pre[i][1];\n          if (s1 <= k || s2 <= k) {\n            l = mid;\n          } else {\n            r = mid - 1;\n          }\n        }\n        upto[i + 1] = l + 1;\n        segments[l + 1].pb(i + 1);\n        //print(i, upto[i]);\n      }\n\n      segtree addr;\n      addr.init(n + 3);\n      For(i,1,n + 1) {\n        addr.set(i, upto[i] - i + 1);\n        //print(i, upto[i] - i + 1);\n      }\n\n      segtree2 cntr;\n      segtree2 remvr;\n      cntr.init(n + 3);\n      remvr.init(n + 3);\n\n      for(ll i = n + 1; i >= 1; i--) {\n        for(auto & mem : segments[i]) {\n          cntr.set(mem, 1);\n          remvr.set(mem, i);\n        }\n        for(ll j = 0; j < siz(qrys[i - 1]); j++) {\n          ll idx = qrys[i - 1][j].first;\n          ll lef = qrys[i - 1][j].second;\n          // rig = i - 1\n          ans[idx] = -1 * (remvr.sum(lef, i) - (i - 1) * cntr.sum(lef, i));\n          ans[idx] += addr.sum(lef, i);\n\n          // print(idx, lef, i - 1);\n          // print(addr.sum(lef, i));\n          // print();\n        }\n      }\n\n      //print(ans);\n      return ans;\n    }\n};",
    "submit_ts": "1723952343",
    "subm_id": "1359793976"
}