{
    "username": "RyanPionee2",
    "submission": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <numeric>\n#include <tuple>\n#include <stack>\n#include <bitset>\n#include <functional>\n#include <list>\n\n\nusing namespace std;\n#define SZ(X) ((int)(X).size())\n#define ll long long\n#define MK(X, Y) make_pair(X, Y)\ntypedef pair<int, int> PII;\ntypedef pair<char, char> PCC;\nll mod = 1e9+7;\nconst int MX = 1e5+1;\n\nclass SegmentTreeNode {\npublic:\n    SegmentTreeNode *left;\n    SegmentTreeNode *right;\n    int begin;\n    int end;\n    int mid;\n    int val;\n\n    SegmentTreeNode(int b, int e, int v) {\n        begin = b;\n        end = e;\n        mid = (b + e) / 2;\n        val = v;\n        left = nullptr;\n        right = nullptr;\n    }\n\n    SegmentTreeNode(int b, int e, int v, SegmentTreeNode *l, SegmentTreeNode *r) {\n        begin = b;\n        end = e;\n        mid = (b + e) / 2;\n        val = v;\n        left = l;\n        right = r;\n    }\n};\n\n\nclass SegmentTree {\npublic:\n    SegmentTreeNode *root;\n    SegmentTree() {\n        root = new SegmentTreeNode(0, MX, 0);\n    }\n    void update_delta(SegmentTreeNode * node, int pos, int delta) {\n        if (node == nullptr)\n            return;\n        if (pos < node->begin || pos > node->end)\n            return;\n        if (pos == node->begin && pos == node->end) {\n            node->val = delta;\n            return;\n        }\n        if (pos <= node->mid) {\n            if (node->left == nullptr) {\n                SegmentTreeNode *n = new SegmentTreeNode(node->begin, node->mid, 0) ;\n                node->left = n;\n            }\n            update_delta(node->left, pos, delta);\n        } else {\n            if (node->right == nullptr) {\n                SegmentTreeNode *n = new SegmentTreeNode(node->mid + 1, node->end, 0) ;\n                node->right = n;\n            }\n            update_delta(node->right, pos, delta);\n        }\n        node->val = 0;\n        if (node->left != nullptr)\n            node->val = max(node->val, node->left->val);\n        if (node->right != nullptr)\n            node->val = max(node->val, node->right->val);\n    }\n\n    int query_range_max(SegmentTreeNode * node, int l, int r) {\n        if (node->begin > r || node->end < l)\n            return 0;\n        if (node->begin >= l && node->end <= r)\n            return node->val;\n        int num1 = INT32_MIN, num2 = INT32_MIN;\n        if (node->left != nullptr) {\n            num1 = query_range_max(node->left, l, r);\n        }\n        if (node->right != nullptr) {\n            num2 = query_range_max(node->right, l, r);\n        }\n        return max(num1, num2);\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        SegmentTree *tree = new SegmentTree();\n        tree->update_delta(tree->root, MX-1, MX-1);\n        set<int> nums;\n        nums.insert(MX-1);\n        vector<bool> res;\n        for (auto &q: queries) {\n            int i = tree->query_range_max(tree->root, 0, 11);\n                // cout << i << endl;\n            if (q[0] == 1) {\n                nums.insert(q[1]);\n                auto it = nums.lower_bound(q[1]);\n                int nx = *next(it);\n                if (it == begin(nums)) {\n                    tree->update_delta(tree->root, nx, nx - q[1]);\n                    tree->update_delta(tree->root, q[1], q[1]);\n                } else {\n                    int pv = *prev(it);\n                    int space = nx - pv;\n                    tree->update_delta(tree->root, nx, nx - q[1]);\n                    tree->update_delta(tree->root, q[1], q[1]-pv);\n                }\n            } else {\n                if (nums.empty() || *begin(nums) > q[1]) {\n                    res.push_back(q[2] <= q[1]);\n                    continue;\n                }\n                auto it = nums.lower_bound(q[1]);\n                if (min(*it, q[1]) - *prev(it) >= q[2]) {\n                    res.push_back(true);\n                    continue;\n                }\n                int i = tree->query_range_max(tree->root, 0, q[1]);\n                if (i >= q[2]) res.push_back(true);\n                else res.push_back(false);\n            }\n        }\n        return res;\n    }\n};",
    "submit_ts": 1716651409.0
}