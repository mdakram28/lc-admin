{
    "username": "2hQXFH1gD5",
    "submission": "#define ll long long\n\n\nclass Solution {\npublic:\n    ll dp[2002][1002];\n    const ll mod = 1e9+7;\n    ll helper(vector<int> &nums){\n        int n = nums.size();\n    int max_val = 1001;  // maximum value of nums[i] + 1\n    ll dp[n+1][max_val], prefix[max_val];\n\n    memset(dp, 0, sizeof(dp));\n\n    // Base case: when i == n, there's only one way to form a valid sequence.\n    for(int ls = 0; ls <= nums[n-1]; ls++) {\n        dp[n][ls] = 1;\n    }\n\n    // Fill the dp table iteratively from the end towards the beginning\n    for(int i = n-1; i >= 0; i--) {\n        // Compute prefix sums for the dp array\n        prefix[0] = dp[i+1][0];\n        for(int j = 1; j <= nums[i]; j++) {\n            prefix[j] = (prefix[j-1] + dp[i+1][j]) % mod;\n        }\n\n        for(int ls = 0; ls <= nums[i]; ls++) {\n            if(i == 0) {\n                dp[i][ls] = prefix[nums[i]];  // When `i == 0`, we sum all `j <= nums[i]`\n            } else {\n                int min_j = max(ls, nums[i] - nums[i-1] + ls);\n                if(min_j <= nums[i]) {\n                    dp[i][ls] = (prefix[nums[i]] - (min_j > 0 ? prefix[min_j - 1] : 0) + mod) % mod;\n                } else {\n                    dp[i][ls] = 0;\n                }\n            }\n        }\n    }\n\n    // The result will be in dp[0][0] which is the starting point of our sequence.\n    return dp[0][0]%mod;\n\n\n    }\n    int countOfPairs(vector<int>& nums) {\n        // memset(dp,-1,sizeof(dp));\n        return helper(nums);\n    }\n};",
    "submit_ts": "1723345235",
    "subm_id": "1351551464"
}