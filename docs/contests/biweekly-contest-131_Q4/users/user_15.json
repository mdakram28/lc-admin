{
    "username": "some_idiot",
    "submission": "/*\nlib:        https://github.com/old-yan/CP-template\nauthor:     oldyan\n*/\n#include <algorithm>\n#include <bit>\n#include <cassert>\n#include <cstdint>\n#include <cstring>\n#include <functional>\n#include <numeric>\n#include <type_traits>\n#include <vector>\n#ifndef __OY_ZKWTREE__\n#define __OY_ZKWTREE__\nnamespace OY {\n    namespace ZKW {\n        using size_type = uint32_t;\n        struct Ignore {};\n        template <typename ValueType>\n        struct BaseNode {\n            using value_type = ValueType;\n            using node_type = BaseNode<ValueType>;\n            static value_type op(const value_type &x, const value_type &y) { return x + y; }\n            static void map(const value_type &modify, node_type *x) { x->m_val += modify; }\n            value_type m_val;\n            const value_type &get() const { return m_val; }\n            void set(const value_type &val) { m_val = val; }\n        };\n        template <typename ValueType, typename ModifyType>\n        struct LazyNode {\n            using value_type = ValueType;\n            using modify_type = ModifyType;\n            using node_type = LazyNode<ValueType, ModifyType>;\n            static value_type op(const value_type &x, const value_type &y) { return x + y; }\n            static void map(const modify_type &modify, node_type *x, size_type len) { x->m_val += modify * len; }\n            static void com(const modify_type &modify, node_type *x) { x->m_modify += modify; }\n            value_type m_val;\n            modify_type m_modify;\n            const value_type &get() const { return m_val; }\n            void set(const value_type &val) { m_val = val; }\n            bool has_lazy() const { return bool(m_modify); }\n            const modify_type &get_lazy() const { return m_modify; }\n            void clear_lazy() { m_modify = 0; }\n        };\n        template <typename ValueType, typename Operation>\n        struct CustomNode {\n            using value_type = ValueType;\n            using node_type = CustomNode<ValueType, Operation>;\n            static Operation s_op;\n            static value_type op(const value_type &x, const value_type &y) { return s_op(x, y); }\n            value_type m_val;\n            const value_type &get() const { return m_val; }\n            void set(const value_type &val) { m_val = val; }\n        };\n        template <typename ValueType, typename Operation>\n        Operation CustomNode<ValueType, Operation>::s_op;\n        template <typename ValueType, typename ModifyType, typename Operation, typename Mapping, typename Composition, bool InitClearLazy>\n        struct CustomLazyNode {\n            using value_type = ValueType;\n            using modify_type = ModifyType;\n            using node_type = CustomLazyNode<ValueType, ModifyType, Operation, Mapping, Composition, InitClearLazy>;\n            static Operation s_op;\n            static Mapping s_map;\n            static Composition s_com;\n            static modify_type s_default_modify;\n            static value_type op(const value_type &x, const value_type &y) { return s_op(x, y); }\n            static void map(const modify_type &modify, node_type *x, size_type len) { x->m_val = s_map(modify, x->m_val, len); }\n            static void com(const modify_type &modify, node_type *x) { x->m_modify = s_com(modify, x->m_modify); }\n            static constexpr bool init_clear_lazy = InitClearLazy;\n            value_type m_val;\n            modify_type m_modify;\n            const value_type &get() const { return m_val; }\n            void set(const value_type &val) { m_val = val; }\n            const modify_type &get_lazy() const { return m_modify; }\n            void clear_lazy() { m_modify = s_default_modify; }\n        };\n        template <typename ValueType, typename ModifyType, typename Operation, typename Mapping, typename Composition, bool InitClearLazy>\n        Operation CustomLazyNode<ValueType, ModifyType, Operation, Mapping, Composition, InitClearLazy>::s_op;\n        template <typename ValueType, typename ModifyType, typename Operation, typename Mapping, typename Composition, bool InitClearLazy>\n        Mapping CustomLazyNode<ValueType, ModifyType, Operation, Mapping, Composition, InitClearLazy>::s_map;\n        template <typename ValueType, typename ModifyType, typename Operation, typename Mapping, typename Composition, bool InitClearLazy>\n        Composition CustomLazyNode<ValueType, ModifyType, Operation, Mapping, Composition, InitClearLazy>::s_com;\n        template <typename ValueType, typename ModifyType, typename Operation, typename Mapping, typename Composition, bool InitClearLazy>\n        ModifyType CustomLazyNode<ValueType, ModifyType, Operation, Mapping, Composition, InitClearLazy>::s_default_modify;\n#ifdef __cpp_lib_void_t\n        template <typename... Tp>\n        using void_t = std::void_t<Tp...>;\n#else\n        template <typename... Tp>\n        struct make_void {\n            using type = void;\n        };\n        template <typename... Tp>\n        using void_t = typename make_void<Tp...>::type;\n#endif\n        template <typename Tp, typename ValueType, typename = void>\n        struct Has_modify_type : std::false_type {\n            using type = ValueType;\n        };\n        template <typename Tp, typename ValueType>\n        struct Has_modify_type<Tp, ValueType, void_t<typename Tp::modify_type>> : std::true_type {\n            using type = typename Tp::modify_type;\n        };\n        template <typename Tp, typename = void>\n        struct Has_has_lazy : std::false_type {};\n        template <typename Tp>\n        struct Has_has_lazy<Tp, void_t<decltype(std::declval<Tp>().has_lazy())>> : std::true_type {};\n        template <typename Tp, typename = void>\n        struct Has_get_lazy : std::false_type {};\n        template <typename Tp>\n        struct Has_get_lazy<Tp, void_t<decltype(std::declval<Tp>().get_lazy())>> : std::true_type {};\n        template <typename Tp, typename NodePtr, typename SizeType, typename = void>\n        struct Has_pushup : std::false_type {};\n        template <typename Tp, typename NodePtr>\n        struct Has_pushup<Tp, NodePtr, void, void_t<decltype(std::declval<Tp>().pushup(std::declval<NodePtr>(), std::declval<NodePtr>()))>> : std::true_type {};\n        template <typename Tp, typename NodePtr>\n        struct Has_pushup<Tp, NodePtr, size_type, void_t<decltype(std::declval<Tp>().pushup(std::declval<NodePtr>(), std::declval<NodePtr>(), std::declval<size_type>()))>> : std::true_type {};\n        template <typename Tp, typename = void>\n        struct Has_init_set : std::false_type {};\n        template <typename Tp>\n        struct Has_init_set<Tp, void_t<decltype(std::declval<Tp>().init_set({}))>> : std::true_type {};\n        template <typename Tp, typename NodePtr, typename SizeType, typename = void>\n        struct Has_init_pushup : std::false_type {};\n        template <typename Tp, typename NodePtr>\n        struct Has_init_pushup<Tp, NodePtr, void, void_t<decltype(std::declval<Tp>().init_pushup(std::declval<NodePtr>(), std::declval<NodePtr>()))>> : std::true_type {};\n        template <typename Tp, typename NodePtr>\n        struct Has_init_pushup<Tp, NodePtr, size_type, void_t<decltype(std::declval<Tp>().init_pushup(std::declval<NodePtr>(), std::declval<NodePtr>(), std::declval<size_type>()))>> : std::true_type {};\n        template <typename Tp, typename NodePtr, typename ModifyType, typename SizeType, typename = void>\n        struct Has_map : std::false_type {};\n        template <typename Tp, typename NodePtr, typename ModifyType>\n        struct Has_map<Tp, NodePtr, ModifyType, void, void_t<decltype(Tp::map(std::declval<ModifyType>(), std::declval<NodePtr>()))>> : std::true_type {};\n        template <typename Tp, typename NodePtr, typename ModifyType>\n        struct Has_map<Tp, NodePtr, ModifyType, size_type, void_t<decltype(Tp::map(std::declval<ModifyType>(), std::declval<NodePtr>(), std::declval<size_type>()))>> : std::true_type {};\n        template <typename Tp, typename = void>\n        struct Has_init_clear_lazy : std::false_type {};\n        template <typename Tp>\n        struct Has_init_clear_lazy<Tp, void_t<decltype(Tp::init_clear_lazy)>> : std::true_type {};\n        template <typename Node>\n        struct Tree {\n            using node = Node;\n            using value_type = typename node::value_type;\n            using modify_type = typename Has_modify_type<node, value_type>::type;\n            struct DefaultGetter {\n                using value_type = typename node::value_type;\n                value_type operator()(const node *p) const { return p->get(); }\n                void operator()(value_type &x, const node *p) const { x = node::op(x, p->get()); }\n                void operator()(const node *p, value_type &x) const { x = node::op(p->get(), x); }\n                void operator()(value_type &x, const value_type &y) const { x = node::op(x, y); }\n            };\n            struct iterator {\n                size_type m_index;\n                node *m_ptr;\n            };\n            mutable std::vector<node> m_sub;\n            size_type m_size, m_capacity, m_depth;\n            static void _apply(node *sub, size_type i, const modify_type &modify, size_type len) { node::map(modify, sub + i, len), node::com(modify, sub + i); }\n            static void _apply(node *p, const modify_type &modify) {\n                if constexpr (Has_map<node, node *, modify_type, void>::value)\n                    node::map(modify, p);\n                else if constexpr (Has_map<node, node *, modify_type, size_type>::value)\n                    node::map(modify, p, 1);\n                else\n                    p->set(node::op(modify, p->get()));\n            }\n            static void _pushdown(node *sub, size_type i, size_type len) {\n                if constexpr (Has_get_lazy<node>::value) {\n                    if constexpr (Has_has_lazy<node>::value)\n                        if (!sub[i].has_lazy()) return;\n                    _apply(sub, i * 2, sub[i].get_lazy(), len >> 1);\n                    _apply(sub, i * 2 + 1, sub[i].get_lazy(), len >> 1);\n                    sub[i].clear_lazy();\n                }\n            }\n            static void _init_pushup(node *sub, size_type i, size_type len) {\n                if constexpr (Has_init_pushup<node, node *, size_type>::value)\n                    sub[i].init_pushup(sub + (i * 2), sub + (i * 2 + 1), len);\n                else if constexpr (Has_init_pushup<node, node *, void>::value)\n                    sub[i].init_pushup(sub + (i * 2), sub + (i * 2 + 1));\n                _pushup(sub, i, len);\n            }\n            static void _pushup(node *sub, size_type i, size_type len) {\n                if constexpr (Has_pushup<node, node *, size_type>::value)\n                    sub[i].pushup(sub + (i * 2), sub + (i * 2 + 1), len);\n                else if constexpr (Has_pushup<node, node *, void>::value)\n                    sub[i].pushup(sub + (i * 2), sub + (i * 2 + 1));\n                else\n                    sub[i].set(node::op(sub[i * 2].get(), sub[i * 2 + 1].get()));\n            }\n            static void _fetch(node *sub, size_type l, size_type r, size_type len) {\n                if (l == 1) return;\n                _fetch(sub, l >> 1, r >> 1, len << 1);\n                for (size_type i = l >> 1; i <= r >> 1; i++) _pushdown(sub, i, len);\n            }\n            template <typename InitMapping = Ignore>\n            Tree(size_type length = 0, InitMapping mapping = InitMapping()) { resize(length, mapping); }\n            template <typename Iterator>\n            Tree(Iterator first, Iterator last) { reset(first, last); }\n            template <typename InitMapping = Ignore>\n            void resize(size_type length, InitMapping mapping = InitMapping()) {\n                if (!(m_size = length)) return;\n                m_depth = std::max<size_type>(1, std::bit_width(m_size - 1)), m_capacity = 1 << m_depth;\n                m_sub.assign(m_capacity * 2, {});\n                node *sub = m_sub.data();\n                if constexpr (Has_init_clear_lazy<node>::value)\n                    if constexpr (node::init_clear_lazy)\n                        for (size_type i = 1; i < m_capacity; i++) sub[i].clear_lazy();\n                if constexpr (!std::is_same<InitMapping, Ignore>::value) {\n                    if constexpr (Has_init_set<node>::value)\n                        for (size_type i = 0; i < m_size; i++) sub[m_capacity + i].init_set(mapping(i));\n                    else\n                        for (size_type i = 0; i < m_size; i++) sub[m_capacity + i].set(mapping(i));\n                    for (size_type len = m_capacity / 2, cnt = (m_size + 1) / 2, k = 2; len; len >>= 1, cnt = (cnt + 1) / 2, k <<= 1)\n                        for (size_type i = len; i != len + cnt; i++) _init_pushup(sub, i, k);\n                }\n            }\n            template <typename Iterator>\n            void reset(Iterator first, Iterator last) {\n                resize(last - first, [&](size_type i) { return *(first + i); });\n            }\n            void modify(size_type i, const value_type &val) {\n                do_for_node<false>(i, [&](node *p) { p->set(val); });\n            }\n            void add(size_type i, const modify_type &modify) {\n                do_for_node<false>(i, [&](node *p) { _apply(p, modify); });\n            }\n            void add(size_type left, size_type right, const modify_type &modify) {\n                if (left == right) return add(left, modify);\n                left += m_capacity, right += m_capacity;\n                node *sub = m_sub.data();\n                size_type j = std::bit_width(left ^ right) - 1, len = m_capacity;\n                for (size_type d = m_depth; d > j; d--, len >>= 1) _pushdown(sub, left >> d, len);\n                for (size_type d = j; d; d--, len >>= 1) _pushdown(sub, left >> d, len), _pushdown(sub, right >> d, len);\n                _apply(sub + left, modify), _apply(sub + right, modify), len = 1;\n                while (left >> 1 < right >> 1) {\n                    if (!(left & 1)) _apply(sub, left + 1, modify, len);\n                    _pushup(sub, left >>= 1, len << 1);\n                    if (right & 1) _apply(sub, right - 1, modify, len);\n                    _pushup(sub, right >>= 1, len <<= 1);\n                }\n                while (len <<= 1, left >>= 1) _pushup(sub, left, len);\n            }\n            template <typename Getter = DefaultGetter>\n            typename Getter::value_type query(size_type i) const {\n                return ((Tree *)(this))->do_for_node<true>(i, [&](const node *p) { return Getter()(p); });\n            }\n            template <typename Getter = DefaultGetter>\n            typename Getter::value_type query(size_type left, size_type right) const {\n                if (left == right) return query<Getter>(left);\n                left += m_capacity, right += m_capacity;\n                node *sub = m_sub.data();\n                size_type j = std::bit_width(left ^ right) - 1, len = m_capacity;\n                for (size_type d = m_depth; d > j; d--, len >>= 1) _pushdown(sub, left >> d, len);\n                for (size_type d = j; d; d--, len >>= 1) _pushdown(sub, left >> d, len), _pushdown(sub, right >> d, len);\n                typename Getter::value_type resl = Getter()(sub + left), resr = Getter()(sub + right);\n                for (; left >> 1 != right >> 1; left >>= 1, right >>= 1) {\n                    if (!(left & 1)) Getter()(resl, sub + (left ^ 1));\n                    if (right & 1) Getter()(sub + (right ^ 1), resr);\n                }\n                Getter()(resl, resr);\n                return resl;\n            }\n            template <typename Getter = DefaultGetter>\n            typename Getter::value_type query_all() const { return Getter()(m_sub.data() + 1); }\n            template <typename Getter = DefaultGetter, typename Judger>\n            size_type max_right(size_type left, Judger &&judge) const {\n                left += m_capacity;\n                node *sub = m_sub.data();\n                for (size_type d = m_depth, len = m_capacity; d; d--, len >>= 1) _pushdown(sub, left >> d, len);\n                using get_type = typename Getter::value_type;\n                get_type val = Getter()(sub + left);\n                if (!judge(val)) return left - m_capacity - 1;\n                left++;\n                for (size_type len = 1; std::popcount(left) > 1;) {\n                    size_type ctz = std::countr_zero(left);\n                    get_type a(val);\n                    Getter()(a, sub + (left >>= ctz));\n                    len <<= ctz;\n                    if (judge(a))\n                        val = a, left++;\n                    else {\n                        for (; left < m_capacity; len >>= 1) {\n                            _pushdown(sub, left, len);\n                            get_type a(val);\n                            Getter()(a, sub + (left <<= 1));\n                            if (judge(a)) val = a, left++;\n                        }\n                        return std::min(left - m_capacity, m_size) - 1;\n                    }\n                }\n                return m_size - 1;\n            }\n            template <typename Getter = DefaultGetter, typename Judger>\n            size_type min_left(size_type right, Judger &&judge) const {\n                right += m_capacity;\n                node *sub = m_sub.data();\n                for (size_type d = m_depth, len = m_capacity; d; d--, len >>= 1) _pushdown(sub, right >> d, len);\n                using get_type = typename Getter::value_type;\n                get_type val = Getter()(sub + right);\n                if (!judge(val)) return right - m_capacity + 1;\n                for (size_type len = 1; std::popcount(right) > 1;) {\n                    size_type ctz = std::countr_zero(right - m_capacity);\n                    get_type a(val);\n                    Getter()(sub + ((right >>= ctz) - 1), a);\n                    len >>= ctz;\n                    if (judge(a))\n                        val = a, right--;\n                    else {\n                        for (; right <= m_capacity; len >>= 1) {\n                            _pushdown(sub, right - 1, len);\n                            get_type a(val);\n                            Getter()(sub + ((right <<= 1) - 1), a);\n                            if (judge(a)) val = a, right--;\n                        }\n                        return right - m_capacity;\n                    }\n                }\n                return 0;\n            }\n            template <typename Getter = DefaultGetter>\n            iterator kth(typename Getter::value_type k) const {\n                node *sub = m_sub.data();\n                size_type i = 1, len = m_capacity;\n                for (; i < 1 << m_depth; len >>= 1) {\n                    _pushdown(sub, i, len);\n                    if (Getter()(sub + (i <<= 1)) <= k) k -= Getter()(sub + (i++));\n                }\n                return {i - (1 << m_depth), sub + i};\n            }\n            template <bool ReadOnly, typename Callback>\n            auto do_for_node(size_type i, Callback &&call) const -> decltype(call(m_sub.data())) {\n                i += m_capacity;\n                node *sub = m_sub.data();\n                for (size_type d = m_depth, len = m_capacity; d; d--, len >>= 1) _pushdown(sub, i >> d, len);\n                if constexpr (ReadOnly)\n                    return call(sub + i);\n                else {\n                    call(sub + i);\n                    for (size_type len = 1; len <<= 1, i >>= 1;) _pushup(sub, i, len);\n                }\n            }\n            template <typename Callback>\n            void do_for_each(Callback &&call) const {\n                node *sub = m_sub.data();\n                _fetch(sub, m_capacity, m_capacity + m_size - 1, 2);\n                for (size_type i = m_capacity, j = 0; j != m_size; i++, j++) call(sub + i);\n            }\n        };\n        template <typename Ostream, typename Node>\n        Ostream &operator<<(Ostream &out, const Tree<Node> &x) {\n            out << \"[\";\n            for (size_type i = 0; i < x.m_size; i++) {\n                if (i) out << \", \";\n                out << x.query(i);\n            }\n            return out << \"]\";\n        }\n    }\n    template <typename Tp, typename Operation, typename InitMapping = ZKW::Ignore, typename TreeType = ZKW::Tree<ZKW::CustomNode<Tp, Operation>>>\n    auto make_ZkwTree(ZKW::size_type length, Operation op, InitMapping mapping = InitMapping()) -> TreeType { return TreeType(length, mapping); }\n    template <typename Tp, typename InitMapping = ZKW::Ignore, typename TreeType = ZKW::Tree<ZKW::CustomNode<Tp, const Tp &(*)(const Tp &, const Tp &)>>>\n    auto make_ZkwTree(ZKW::size_type length, const Tp &(*op)(const Tp &, const Tp &), InitMapping mapping = InitMapping()) -> TreeType { return TreeType::node::s_op = op, TreeType(length, mapping); }\n    template <typename Tp, typename InitMapping = ZKW::Ignore, typename TreeType = ZKW::Tree<ZKW::CustomNode<Tp, Tp (*)(Tp, Tp)>>>\n    auto make_ZkwTree(ZKW::size_type length, Tp (*op)(Tp, Tp), InitMapping mapping = InitMapping()) -> TreeType { return TreeType::node::s_op = op, TreeType(length, mapping); }\n    template <typename Iterator, typename Operation, typename Tp = typename std::iterator_traits<Iterator>::value_type, typename TreeType = ZKW::Tree<ZKW::CustomNode<Tp, Operation>>>\n    auto make_ZkwTree(Iterator first, Iterator last, Operation op) -> TreeType { return TreeType(first, last); }\n    template <typename Iterator, typename Tp = typename std::iterator_traits<Iterator>::value_type, typename TreeType = ZKW::Tree<ZKW::CustomNode<Tp, const Tp &(*)(const Tp &, const Tp &)>>>\n    auto make_ZkwTree(Iterator first, Iterator last, const Tp &(*op)(const Tp &, const Tp &)) -> TreeType { return TreeType::node::s_op = op, TreeType(first, last); }\n    template <typename Iterator, typename Tp = typename std::iterator_traits<Iterator>::value_type, typename TreeType = ZKW::Tree<ZKW::CustomNode<Tp, Tp (*)(Tp, Tp)>>>\n    auto make_ZkwTree(Iterator first, Iterator last, Tp (*op)(Tp, Tp)) -> TreeType { return TreeType::node::s_op = op, TreeType(first, last); }\n    template <typename ValueType, typename ModifyType, bool InitClearLazy, typename InitMapping, typename Operation, typename Mapping, typename Composition, typename TreeType = ZKW::Tree<ZKW::CustomLazyNode<ValueType, ModifyType, Operation, Mapping, Composition, InitClearLazy>>>\n    auto make_lazy_ZkwTree(ZKW::size_type length, InitMapping mapping, Operation op, Mapping map, Composition com, const ModifyType &default_modify = ModifyType()) -> TreeType { return TreeType::node::s_default_modify = default_modify, TreeType(length, mapping); }\n    template <typename ValueType, typename ModifyType, bool InitClearLazy, typename Iterator, typename Operation, typename Mapping, typename Composition, typename TreeType = ZKW::Tree<ZKW::CustomLazyNode<ValueType, ModifyType, Operation, Mapping, Composition, InitClearLazy>>>\n    auto make_lazy_ZkwTree(Iterator first, Iterator last, Operation op, Mapping map, Composition com, const ModifyType &default_modify = ModifyType()) -> TreeType { return TreeType::node::s_default_modify = default_modify, TreeType(first, last); }\n    template <typename Tp>\n    using ZkwSumTree = ZKW::Tree<ZKW::BaseNode<Tp>>;\n    template <typename Tp, typename Fp = Tp>\n    using ZkwLazySumTree = ZKW::Tree<ZKW::LazyNode<Tp, Fp>>;\n}\n#endif\n/*\nlib code is above\ntemp code is below\n*/\n#ifdef OY_LOCAL\nusing namespace std;\n#endif\n#define FUNCNAME getResults\nstruct seg {\n    uint32_t m_l0, m_l1, m_r0, m_r1, m_max0, m_max1, m_sum, m_len;\n    void set_zero() {\n        m_l0 = m_r0 = m_max0 = m_len;\n        m_l1 = m_r1 = m_max1 = m_sum = 0;\n    }\n    void set_one() {\n        m_l1 = m_r1 = m_max1 = m_sum = m_len;\n        m_l0 = m_r0 = m_max0 = 0;\n    }\n    void flip() {\n        std::swap(m_l0, m_l1);\n        std::swap(m_r0, m_r1);\n        std::swap(m_max0, m_max1);\n        m_sum = m_len - m_sum;\n    }\n    seg operator+(const seg &rhs) const {\n        seg res;\n        res.m_l0 = m_l0;\n        if (m_l0 == m_len) res.m_l0 = m_l0 + rhs.m_l0;\n        res.m_l1 = m_l1;\n        if (m_l1 == m_len) res.m_l1 = m_l1 + rhs.m_l1;\n        res.m_r0 = rhs.m_r0;\n        if (rhs.m_r0 == rhs.m_len) res.m_r0 = m_r0 + rhs.m_r0;\n        res.m_r1 = rhs.m_r1;\n        if (rhs.m_r1 == rhs.m_len) res.m_r1 = m_r1 + rhs.m_r1;\n        res.m_max0 = std::max({m_max0, rhs.m_max0, m_r0 + rhs.m_l0});\n        res.m_max1 = std::max({m_max1, rhs.m_max1, m_r1 + rhs.m_l1});\n        res.m_sum = m_sum + rhs.m_sum;\n        res.m_len = m_len + rhs.m_len;\n        return res;\n    }\n};\nstruct Node {\n    using value_type = seg;\n    using modify_type = uint32_t;\n    using size_type = uint32_t;\n    using node_type = Node;\n    static constexpr bool init_clear_lazy = true;\n    static value_type op(const value_type &x, const value_type &y) { return x + y; }\n    static void map(const modify_type &modify, node_type *x, size_type len) {\n        if (modify == 3)\n            x->m_val.set_one();\n        else if (modify == 0)\n            x->m_val.set_zero();\n        else if (modify == 2)\n            x->m_val.flip();\n    }\n    static void com(const modify_type &modify, node_type *x) {\n        if (modify == 0 || modify == 3)\n            x->m_modify = modify;\n        else if (modify == 2)\n            x->m_modify = 3 - x->m_modify;\n    }\n    value_type m_val;\n    modify_type m_modify;\n    const value_type &get() const { return m_val; }\n    void set(char c) {\n        m_val.m_len = 1;\n        if (c == '1')\n            m_val.set_one();\n        else\n            m_val.set_zero();\n    }\n    void set(const value_type &val) { m_val = val; }\n    bool has_lazy() const { return m_modify != 1; }\n    const modify_type &get_lazy() const { return m_modify; }\n    void clear_lazy() { m_modify = 1; }\n};\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>> &queries) {\n        using Tree = OY::ZKW::Tree<Node>;\n        Tree S(queries.size() * 3 + 10, [](int i) { return '1'; });\n        S.add(0, 0);\n        vector<bool> ans;\n        for (auto &q : queries) {\n            if (q[0] == 1) {\n                S.add(q[1], 0);\n            } else {\n                bool flag=S.query(q[1]).m_sum;\n                if(flag)S.add(q[1],0);\n                auto res = S.query(0, q[1]);\n                ans.push_back(q[1]>=q[2] and res.m_max1 + 1 >= q[2]);\n                if(flag)S.add(q[1],3);\n            }\n        }\n        return ans;\n    }\n};\n#ifdef OY_LOCAL\nint main() {\n    REGISTER_CONSTRUCTOR_SOLUTION;\n    REGISTER_MEMBERFUNCTION_SOLUTION(FUNCNAME);\n    while (true) {\n        executor.constructSolution();\n        executor.executeSolution();\n    }\n}\n#endif\n",
    "submit_ts": 1716648172.0
}