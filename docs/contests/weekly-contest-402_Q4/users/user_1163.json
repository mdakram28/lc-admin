{
    "username": "sourashisHmm",
    "submission": "class Solution {\n\n    class SegmentTree {\n    private:\n        //arry of size 4n to store the tree\n        //leftChild(i) = 2i + 1\n        //rightChild(i) = 2i + 2\n        vector<long long> t;\n        //size of the actual array(range)\n        int n;\n\n    public:\n        SegmentTree(const vector<long long> &arr) {\n            n = arr.size();\n            t = vector<long long> (4 * n);\n            build(0, 0, n - 1, arr);\n        }\n\n        long long query(int qlow, int qhigh) {\n            return query(0, 0, n - 1, qlow, qhigh);\n        }\n\n        void update(int targetArrInd, long long newVal) {\n            update(0, 0, n - 1, targetArrInd, newVal);\n        }\n\n        //TODO: change according to your need\n        //here combine function is: sum\n        long long combine(long long x, long long y) {\n            return x + y;\n        }\n\n    private:\n        int leftChild(int rootId) { return 2 * rootId + 1;}\n        int rightChild (int rootId) { return 2 * rootId + 2;}\n\n        /*\n        [tl, th] = [low, high] range of current subtree\n        [ql, qh] = [low, high] range of query\n        tm = mid of the range of current tree\n\n        REMEMBER: To acess t[], always use node id as index (ex: t[rootId], t[leftId], t[rightId], ...)\n                    never to use range (ex: tl, tm, th, ql, qh, ....) as index of t[]\n        -----------------\n        */\n\n        void build(int rootId, int tl, int th, const vector<long long> &arr) {\n            //leaf\n            if (tl == th) {\n                t[rootId] = arr[tl];\n                return;\n            }\n\n            int tm = tl + (th - tl) / 2;\n            int leftId = leftChild(rootId), rightId = rightChild(rootId);\n            build(leftId, tl, tm, arr);\n            build(rightId, tm + 1, th, arr);\n            t[rootId] = combine(t[leftId], t[rightId]); \n        }\n\n        long long query(int rootId, int tl, int th, int ql, int qh) {\n            if (tl >= ql && th <= qh) return t[rootId];\n\n            int leftId = leftChild(rootId), rightId = rightChild(rootId);\n            int tm = tl + (th - tl) / 2;\n            if (qh <= tm) return query(leftId, tl, tm, ql, qh);\n            else if (ql >= tm + 1) return query(rightId, tm + 1, th, ql, qh);\n            else return combine(query(leftId, tl, tm, ql, qh), query(rightId, tm + 1, th, ql, qh));\n        }\n\n        void update(int rootId, int tl, int th, int targetArrInd, int newVal) {\n            //leaf\n            if (tl == th) {\n                t[rootId] = newVal;\n                return;\n            } \n            int leftId = leftChild(rootId), rightId = rightChild(rootId);\n            int tm = tl + (th - tl) / 2;\n\n            //update the child subtree\n            if (targetArrInd <= tm) update(leftId, tl, tm, targetArrInd, newVal);\n            else update(rightId, tm + 1, th, targetArrInd, newVal);\n\n            //update the val of current range\n            t[rootId] = combine(t[leftId], t[rightId]);        \n        }\n    };\n    \npublic:\n    \n    vector<int> a;\n    int n;\n    \n    bool isPeak(int i) {\n        return i != 0 && i != (n-1) && a[i] > a[i-1] && a[i] > a[i+1];\n    }\n    \n    vector<int> countOfPeaks(vector<int>& _a, vector<vector<int>>& queries) {\n        a = _a;\n        n = a.size();\n        \n        \n        vector<long long> aux(n, 0);\n        SegmentTree st(aux);\n        \n        for (int i = 1; i < n - 1; ++i) {\n            if (a[i] > a[i-1] && a[i] > a[i + 1]) st.update(i, 1);\n        }\n        \n        vector<int> res;\n        for (const auto &q: queries) {\n            int type = q[0];\n            if (type == 1) {\n                int low = q[1];\n                int high = q[2];\n                int count = st.query(low, high);\n                \n                //if a[low] was a peak, decrease 1\n                if (low > 0 && isPeak(low)) --count;\n                //same for a[high]\n                if (low != high && high < n - 1 && isPeak(high)) --count;\n                \n                res.push_back(count);\n            } else {\n                int ind = q[1];\n                int val = q[2];\n                \n                a[ind] = val;\n                if (isPeak(ind))\n                    st.update(ind, 1);\n                else \n                    st.update(ind, 0);\n                    \n                if (ind - 1 >= 0) {\n                    if (ind - 1 >= 0 && isPeak(ind - 1))\n                        st.update(ind - 1, 1);\n                    else \n                        st.update(ind - 1, 0);\n                }\n                \n                if (ind + 1 < n) {\n                    if (isPeak(ind + 1))\n                        st.update(ind + 1, 1);\n                    else \n                        st.update(ind + 1, 0);\n                }\n            }\n        }\n        return res;\n    }\n    \n    \n    \n    \n};",
    "submit_ts": 1718508499.0
}