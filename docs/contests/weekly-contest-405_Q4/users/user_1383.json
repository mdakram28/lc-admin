{
    "username": "gunjan192002",
    "submission": "class TrieNode {\npublic:\nstd::vector<std::pair<int, int>> EW;\n  // Map to store child nodes for each character\n  std::unordered_map<char, TrieNode*> son;\n  // Vector to store word endings (index in word list and cost)\n  \n};\n\nclass CRY{\npublic:\n  TrieNode* head;\n\n  CRY() {\n    head = new TrieNode();\n  }\n\n  void put(const std::string& word, int index, int cost) {\n    TrieNode* node = head;\n    for (char c : word) {\n      if (!node->son.count(c)) {\n        node->son[c] = new TrieNode();\n      }\n      node = node->son[c];\n    }\n    node->EW.push_back({index, cost});\n  }\n};\n\nclass Solution {\npublic:\n  int minimumCost(const std::string& goal, const std::vector<std::string>& words, const std::vector<int>& costs) {\n    int n = goal.size();\n    std::vector<int> dp(n + 1, INT_MAX);\n    dp[0] = 0;  // Empty string has zero cost\n\n    CRY trie;\n    int z=0;\n    while(z!=words.size())\n    {\n        trie.put(words[z], z, costs[z]);\n        z++;\n        }\n\n    for (int i = 0; i < n; ++i) {\n      if (dp[i] == INT_MAX) {\n        continue;\n      }\n\n      TrieNode* node = trie.head;\n      for (int j = i; j < n; ++j) {\n        if (!node->son.count(goal[j])) {\n          break;\n        }\n        node = node->son[goal[j]];\n        for (const auto& p : node->EW) {\n          int wordLen = words[p.first].size();\n          if (i + wordLen <= n) {\n            dp[i + wordLen] = std::min(dp[i + wordLen], dp[i] + p.second);\n          }\n        }\n      }\n    }\n    if(dp[n]==INT_MAX)\n    {\n        return -1;\n    }\n    return dp[n];\n    // return dp[n] == INT_MAX ? -1 : dp[n];\n  }\n};\n",
    "submit_ts": "1720323795",
    "subm_id": "1312384237"
}