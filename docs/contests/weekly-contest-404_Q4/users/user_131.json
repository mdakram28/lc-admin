{
    "username": "runtime-terror_63",
    "submission": "#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int nodeCount1 = edges1.size() + 1;\n        int nodeCount2 = edges2.size() + 1;\n\n        vector<vector<int>> adjList1 = buildAdjacencyList(edges1, nodeCount1);\n        vector<vector<int>> adjList2 = buildAdjacencyList(edges2, nodeCount2);\n\n        int diameter1 = findTreeDiameter(adjList1);\n        int diameter2 = findTreeDiameter(adjList2);\n\n        int minDiameter = max(diameter1, diameter2);\n        int halfDiameter1 = (diameter1 + 1) / 2;\n        int halfDiameter2 = (diameter2 + 1) / 2;\n        minDiameter = max(minDiameter, halfDiameter1 + halfDiameter2 + 1);\n\n        return minDiameter;\n    }\n\nprivate:\n    vector<vector<int>> buildAdjacencyList(const vector<vector<int>>& edges, int nodeCount) {\n        vector<vector<int>> adjacencyList(nodeCount);\n        for (const auto& edge : edges) {\n            adjacencyList[edge[0]].push_back(edge[1]);\n            adjacencyList[edge[1]].push_back(edge[0]);\n        }\n        return adjacencyList;\n    }\n\n    int findTreeDiameter(const vector<vector<int>>& adjacencyList) {\n        int farthestNode = bfs(adjacencyList, 0).first;\n        int diameter = bfs(adjacencyList, farthestNode).second;\n        return diameter;\n    }\n\n    pair<int, int> bfs(const vector<vector<int>>& adjacencyList, int startNode) {\n        int nodeCount = adjacencyList.size();\n        vector<int> distances(nodeCount, -1);\n        queue<int> q;\n\n        distances[startNode] = 0;\n        q.push(startNode);\n\n        int farthestNode = startNode;\n        while (!q.empty()) {\n            int currentNode = q.front();\n            q.pop();\n\n            for (int neighbor : adjacencyList[currentNode]) {\n                if (distances[neighbor] == -1) {\n                    distances[neighbor] = distances[currentNode] + 1;\n                    q.push(neighbor);\n                    if (distances[neighbor] > distances[farthestNode]) {\n                        farthestNode = neighbor;\n                    }\n                }\n            }\n        }\n\n        return {farthestNode, distances[farthestNode]};\n    }\n\n    vector<vector<int>> mergeAdjacencyLists(const vector<vector<int>>& adjList1, const vector<vector<int>>& adjList2) {\n        int nodeCount1 = adjList1.size();\n        int nodeCount2 = adjList2.size();\n        vector<vector<int>> mergedAdjList(nodeCount1 + nodeCount2);\n\n        // Copy the first adjacency list\n        for (int i = 0; i < nodeCount1; ++i) {\n            mergedAdjList[i] = adjList1[i];\n        }\n\n        // Copy the second adjacency list and offset the indices\n        for (int i = 0; i < nodeCount2; ++i) {\n            for (int neighbor : adjList2[i]) {\n                mergedAdjList[nodeCount1 + i].push_back(nodeCount1 + neighbor);\n            }\n        }\n\n        return mergedAdjList;\n    }\n};\n\n",
    "submit_ts": "1719715862",
    "subm_id": "1304348407"
}