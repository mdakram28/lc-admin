{
    "username": "Mdkaif2938",
    "submission": "class Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& querryies) {\n        int n = nums.size();\n        vector<int> results;\n        vector<int> segTree(4 * nums.size(), 0);\n\n        auto isPeak = [&](int i) -> bool {\n            if (i <= 0 || i >= n - 1)\n            {\n                 return false;\n            }\n            int temp = nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n            return temp;\n        };\n\n        function<void(int, int, int)> bTree = [&](int node, int left, int right) {\n            if (left != right){\n                int mid = left + (right - left) / 2;\n                bTree(node * 2 + 1, left, mid);\n                bTree(node * 2 + 2, mid + 1, right);\n                segTree[node] = segTree[node * 2 + 1] + segTree[node * 2 + 2];\n            }\n            else\n            {\n                segTree[node] = isPeak(left) ? 1 : 0;\n            }\n        };\n        function<void(int, int, int, int)> updTree = [&](int node, int left, int right, int idx) {\n            if(left != right){\n                int mid = left + (right - left) / 2;\n                if (left <= idx && idx <= mid) {\n                    updTree(node * 2 + 1, left, mid, idx);\n                } else {\n                    updTree(node * 2 + 2, mid + 1, right, idx);\n                }\n                segTree[node] = segTree[node * 2 + 1] + segTree[node * 2 + 2];\n            }\n            else{\n                segTree[node] = isPeak(idx) ? 1 : 0;\n            }\n        };\n\n        function<int(int, int, int, int, int)> queryTree = [&](int node, int start, int end, int l, int r) -> int {\n            if (r < start || end < l) {\n                return 0;\n            }\n            if (l <= start && end <= r) {\n                return segTree[node];\n            }\n            int mid = start + (end - start) / 2;\n            int leftSum = queryTree(node * 2 + 1, start, mid, l, r);\n            int rightSum = queryTree(node * 2 + 2, mid + 1, end, l, r);\n            return leftSum + rightSum;\n        };\n\n        bTree(0, 0, n - 1);\n\n        for (const auto& query : querryies) {\n            if (query[0] == 2) {\n                int updateIndex = query[1], newValue = query[2];\n                nums[updateIndex] = newValue;\n                if (updateIndex > 0) updTree(0, 0, n - 1, updateIndex - 1);\n                updTree(0, 0, n - 1, updateIndex);\n                if (updateIndex < n - 1) updTree(0, 0, n - 1, updateIndex + 1);\n            }\n            else if (query[0] == 1) {\n                int leftBound = query[1], rightBound = query[2];\n                if (leftBound == rightBound) {\n                    results.push_back(0);\n                } else {\n                    int totalPeaks = queryTree(0, 0, n - 1, leftBound, rightBound);\n                    if (isPeak(rightBound)) --totalPeaks;\n                    if (isPeak(leftBound)) --totalPeaks;\n                    results.push_back(totalPeaks);\n                }\n            } \n        }\n\n        return results;\n    }\n};",
    "submit_ts": 1718509126.0
}