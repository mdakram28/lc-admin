{
    "username": "alanmiller",
    "submission": "class Solution:\n    \n\n    \n    def minimumDistance(self, points: List[List[int]]) -> int:\n        \n            \n        def max_manhattan_distance(points):\n            # Transform points\n            plus_plus = [x + y for x, y in points]\n            plus_minus = [x - y for x, y in points]\n            minus_plus = [-x + y for x, y in points]\n            minus_minus = [-x - y for x, y in points]\n\n            # Find extrema\n            max_distance = max(\n                max(plus_plus) - min(plus_plus),\n                max(plus_minus) - min(plus_minus),\n                max(minus_plus) - min(minus_plus),\n                max(minus_minus) - min(minus_minus)\n            )\n\n            return max_distance\n\n        def max_manhattan_distance_with_indices(points):\n            # Initialize variables to track the extrema and their indices for each transformation\n            extrema = [(float('-inf'), None), (float('inf'), None)] * 4  # Format: (value, index)\n\n            # Transform points and track extrema\n            for i, (x, y) in enumerate(points):\n                for j, value in enumerate([x + y, x - y, -x + y, -x - y]):\n                    # Update maximum if applicable\n                    if value > extrema[j * 2][0]:\n                        extrema[j * 2] = (value, i)\n                    # Update minimum if applicable\n                    if value < extrema[j * 2 + 1][0]:\n                        extrema[j * 2 + 1] = (value, i)\n\n            # Compute maximum distance and track corresponding indices\n            max_distance = 0\n            indices = (-1, -1)\n            for k in range(0, len(extrema), 2):\n                distance = extrema[k][0] - extrema[k + 1][0]\n                if distance > max_distance:\n                    max_distance = distance\n                    indices = (extrema[k][1], extrema[k + 1][1])\n\n            return max_distance, indices\n        ans1, (index1, index2) = max_manhattan_distance_with_indices(points)\n        \n        pp1 = points[:index1] + points[index1 + 1:]\n        pp2 = points[:index2] + points[index2+1:]\n        ans2 = max_manhattan_distance(pp1)\n        ans3 = max_manhattan_distance(pp2)\n        \n        return min(ans1, ans2, ans3)\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
}