{
    "username": "vineetvermaa30",
    "submission": "\n\nclass Solution {\n    struct TrieNode {\n        unordered_map<char, TrieNode*> children;\n        vector<int> indices;\n    };\n\n    void addWord(TrieNode* root, const string& word, int idx) {\n        TrieNode* currentNode = root;\n        for (auto ch : word) {\n            if (!currentNode->children.count(ch)) {\n                currentNode->children[ch] = new TrieNode();\n            }\n            currentNode = currentNode->children[ch];\n        }\n        currentNode->indices.push_back(idx);\n    }\n\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n        int targetLength = target.size();\n        TrieNode* root = new TrieNode();\n        int index = 0;\n\n        while (index < words.size()) {\n            addWord(root, words[index], index);\n            ++index;\n        }\n\n        vector<int> dp(targetLength + 1, INT_MAX);\n        dp[0] = 0;\n\n        int i = 0;\n        while (i < targetLength) {\n            if (dp[i] != INT_MAX) {\n                TrieNode* node = root;\n                int j = i;\n                while (j < targetLength) {\n                    if (!node->children.count(target[j])) break;\n                    node = node->children[target[j]];\n                    for (auto idx : node->indices) {\n                        int wordLength = words[idx].size();\n                        if (i + wordLength <= targetLength) {\n                            dp[i + wordLength] = min(dp[i + wordLength], dp[i] + costs[idx]);\n                        }\n                    }\n                    ++j;\n                }\n            }\n            ++i;\n        }\n\n        return dp[targetLength] == INT_MAX ? -1 : dp[targetLength];\n    }\n};\n",
    "submit_ts": "1720321352",
    "subm_id": "1312320584"
}