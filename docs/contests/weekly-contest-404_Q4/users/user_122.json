{
    "username": "wenboz",
    "submission": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        var g1 = new HashMap<Integer, List<Integer>>();\n        var g2 = new HashMap<Integer, List<Integer>>();\n        for(int[] e : edges1){\n            g1.computeIfAbsent(e[0], l -> new ArrayList<>()).add(e[1]);\n            g1.computeIfAbsent(e[1], l -> new ArrayList<>()).add(e[0]);\n        }\n        for(int[] e : edges2){\n            g2.computeIfAbsent(e[0], l -> new ArrayList<>()).add(e[1]);\n            g2.computeIfAbsent(e[1], l -> new ArrayList<>()).add(e[0]);\n        }\n        int d1 = diameter(g1);\n        int d2 = diameter(g2);\n        return Math.max(d1 - 1, Math.max(d1/2 + d2/2 + 1, d2 - 1));\n    }\n    \n    int diameter(HashMap<Integer, List<Integer>> g){\n        int[] ret = dfs(g, 0, -1);\n        ret = dfs(g, ret[1], -1);\n        return ret[0];\n    }\n    \n    int[] dfs(HashMap<Integer, List<Integer>> g, int i, int p){\n        int farthest = i;\n        int depth = 0;\n        for(int to : g.getOrDefault(i, new ArrayList<>())){\n            if(to != p){\n                int[] ret = dfs(g, to, i);\n                if(ret[0] > depth){\n                    depth = ret[0];\n                    farthest = ret[1];\n                }\n            }\n        }\n        return new int[]{1 + depth, farthest};\n    }\n}",
    "submit_ts": "1719716961",
    "subm_id": "1304378733"
}