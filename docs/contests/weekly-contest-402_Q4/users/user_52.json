{
    "username": "SR3mix",
    "submission": "// SEG ITERATIVE\ntemplate <typename T> class SegmentTreeIterative {\npublic:\n    T seg[800080],segBase;\n    int n,sz,lsz;\n    function<T(T, T)> compare_operation;\n    SegmentTreeIterative(function<T(T, T)> given_compare_op, T newSegBase) {\n        compare_operation = given_compare_op;\n        segBase = newSegBase;\n    }\n    void reset(int newN) {\n        n = newN;\n        assert(n * 4 <= sizeof(seg)/sizeof(seg[0]));\n        sz = 1; while (sz < n) sz *= 2;\n        lsz = __builtin_ctzll(sz);\n        for (int i= 0; i<(sz*2); i++) {seg[i] = segBase;}\n    }\n    void update(int pos, T x) {doUpdate(pos-1, x);}\n    void doUpdate(int pos0index, T x) {\n        assert(pos0index >= 0 && pos0index < n);\n        int p = pos0index + sz; seg[p] = x;\n        for (int i = 1; i <= lsz; i++) modify(p >> i);\n    }\n    T query(int l, int r) {return doQuery(l-1, r);}\n    T doQuery(int l0index, int r0index) {\n        assert(l0index >= 0 && l0index <= r0index && r0index <= n);\n        int l = l0index + sz, r = r0index + sz;\n        T lans = segBase, rans = segBase;\n        while (l < r) {\n            if (l & 1) lans = compare_operation(lans, seg[l++]);\n            if (r & 1) rans = compare_operation(seg[--r], rans);\n            l = (l >> 1); r = (r >> 1);\n        }\n        return compare_operation(lans, rans);\n    }\n    void modify(int k) {seg[k] = compare_operation(seg[2*k], seg[2*k + 1]);}\n    T trueValue(int index) {assert(index >= 1 && index <= n); return seg[index-1+sz];}\n    T true0indexValue(int index0) {assert(index0 >= 0 && index0 < n); return seg[index0 + sz];}\n};\n// CREDIT TO numb3r5 FOR THIS TEMPLATE -> https://leetcode.com/numb3r5/\ntypedef long long ll;\nll comp(ll a, ll b) {return a + b;}\nSegmentTreeIterative<ll> seg = SegmentTreeIterative<ll>(comp, 0);\nclass Solution {\npublic:\n    void check_pos(int x, vector<int>&v) {\n        if (x > 0 && x < v.size()-1) {\n            if (v[x] > v[x-1] && v[x] > v[x+1]) {\n                seg.update(x+1,1);\n            }\n            else seg.update(x+1,0);\n        }\n    }\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int>v = nums;\n        seg.reset(n);\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && i < n-1 && v[i] > v[i+1] && v[i] > v[i-1]) {\n                seg.update(i+1,1);\n            }\n        }\n        //cout << \"init: \" << seg.query(1,n) << endl;\n        vector<int>ans;\n        for (auto &i : queries) {\n            if (i[0] == 1) {\n                int l = i[1], r = i[2];\n                if (r - l <= 1) {\n                    ans.push_back(0);\n                    continue;\n                }\n                int res = seg.query(l + 2, r);\n                ans.push_back(res);\n            }\n            else {\n                int x = i[1], a = i[2];\n                v[x] = a;\n                //for (auto i : v) {cout << i << \",\";} cout << endl;\n                check_pos(x,v);\n                check_pos(x-1,v);\n                check_pos(x+1,v);\n                // if (x > 0 && x < n-1) {\n                //     if (v[x] > v[x - 1] && v[x] > v[x+1]) {\n                //         seg.update(x + 1, 1);\n                //     }\n                //     else {seg.update(x + 1, 0);}\n                // }\n                // if (x - 1 > 0 )\n                // for (int i = 1; i <= n; i++) {cout << seg.query(i,i) << \",\";} cout << endl;\n            }\n        }\n        return ans;\n    }\n};",
    "submit_ts": "1718505789",
    "subm_id": "1289594981"
}