{
    "username": "cavetr",
    "submission": "class SegmentTree {\n  private value: number[];\n  private baseLen: number;\n  private deep: number;\n  constructor(arr: number[]) {\n    this.deep = Math.ceil(Math.log2(arr.length));\n    this.baseLen = (2 ** this.deep) - 1;\n    this.value = new Array(this.baseLen).fill(0).concat(arr);\n    this.buildAfter(0);\n  }\n  private buildAfter(idx: number): number {\n    if (idx < Math.floor(this.value.length / 2)) {\n      this.value[idx] = this.buildAfter(idx * 2 + 1) + this.buildAfter(idx * 2 + 2);\n    }\n    return this.value[idx] ?? 0;\n  }\n  private buildBefore(idx: number) {\n    if (idx < Math.floor(this.value.length / 2)) {\n      this.value[idx] = (this.value[idx * 2 + 1] ?? 0) + (this.value[idx * 2 + 2] ?? 0);\n    }\n    if (idx !== 0) {\n      this.buildBefore(Math.floor((idx - 1) / 2));\n    }\n  }\n  get valueArr() {\n    return this.value;\n  }\n  get valueStr() {\n    return this.value.join(',');\n  }\n  update(idx: number, val: number) {\n    const realIdx = idx + this.baseLen;\n    if (realIdx < this.baseLen || realIdx > this.value.length) {\n      throw new Error('Out of range');\n    }\n    this.value[realIdx] = val;\n    this.buildBefore(realIdx);\n  }\n  getRange(l: number, r: number) {\n    l = l + this.baseLen, r = r + this.baseLen;\n    if (l < this.baseLen || r > this.value.length || l > r) {\n      throw new Error('Out of range');\n    }\n    let lastLIsR = false, lastRIsL = false;\n    let sum = 0;\n    let calL = l, calR = r;\n    if (calL === calR) {\n      return this.value[calL];\n    }\n    while (l < r) {\n      sum += lastLIsR ? 0 : this.value[calL] ?? 0;\n      sum += lastRIsL ? 0 : this.value[calR] ?? 0;\n      lastLIsR = l % 2 === 0, lastRIsL = r % 2 === 1;\n      l = Math.floor((l - 1) / 2);\n      r = Math.floor((r - 1) / 2);\n      calL = l * 2 + 2;\n      calR = r * 2 + 1;\n    }\n    return sum;\n  }\n}\nfunction countOfPeaks(nums: number[], queries: number[][]): number[] {\n  const arr = [];\n  const ans = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > (nums[i - 1] ?? Infinity) && nums[i] > (nums[i + 1] ?? Infinity)) {\n      arr.push(1);\n    } else {\n      arr.push(0);\n    }\n  }\n  const tree = new SegmentTree(arr);\n  for(const [opt, pram1, pram2] of queries) {\n    if(opt === 1) {\n      let t = tree.getRange(pram1, pram2);\n      if(arr[pram1]) {\n        t--;\n      }\n      if (arr[pram2] && pram1 !== pram2) {\n        t--;\n      }\n      ans.push(t);\n    } else {\n      nums[pram1] = pram2 \n      for(let j = -1; j <= 1; j++) {\n        let i = pram1 + j;\n        if (!nums[i]) {\n          continue;\n        }\n        if (nums[i] > (nums[i - 1] ?? Infinity) && nums[i] > (nums[i + 1] ?? Infinity)) {\n          arr[i] = 1;\n          tree.update(i, 1);\n        } else {\n          arr[i] = 0;\n          tree.update(i, 0);\n        }\n      }\n    }\n  }\n  return ans;\n};",
    "submit_ts": 1718507918.0
}