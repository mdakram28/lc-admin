{
    "username": "Ricky-Daxia",
    "submission": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <unordered_set>\n#include <set>\n#include <functional>\n#include <cassert>\n#include <random>\n#include <chrono>\nusing namespace std;\n \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> PIII;\ntypedef pair<LL, int> PLI;\ntypedef pair<int, LL> PIL;\n#define x first\n#define y second\n#define endl '\\n'\nint dx[8] = {0,0,1,-1,1,1,-1,-1}, dy[8] = {1,-1,0,0,1,-1,1,-1};\n#define lowbit(x) (x & (-x))\nconst int inf = 0x3f3f3f3f;\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst int mod = 998244353;\n\nLL qmi(LL a, LL k, LL p)\n{\n    LL res = 1;\n    while (k)\n    {\n        if (k & 1) res = res * a % p;\n        a = a * a % p;\n        k >>= 1;\n    }\n    return res;\n}\n\nLL gcd(LL a, LL b) \n{\n    return b ? gcd(b, a % b) : a;\n}\n\n\nLL lcm(LL a, LL b)\n{\n    return a / gcd(a, b) * b;\n}\n\nvector<int> z_function(string s) {\n  int n = (int)s.length();\n  vector<int> z(n);\n  for (int i = 1, l = 0, r = 0; i < n; ++i) {\n    if (i <= r && z[i - l] < r - i + 1) {\n      z[i] = z[i - l];\n    } else {\n      z[i] = max(0, r - i + 1);\n      while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];\n    }\n    if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;\n  }\n  z[0] = n;\n  return z;\n}\n\nvector<int> primes;\nvector<bool> is_prime;\nvoid get_primes(int n)  // \u7ebf\u6027\u7b5b\u8d28\u6570\n{\n    is_prime.resize(n + 1);\n    for (int i = 2; i <= n; i ++ )\n    {\n        if (!is_prime[i]) primes.push_back(i);\n        for (int j = 0; primes[j] <= n / i; j ++ )\n        {\n            is_prime[primes[j] * i] = true;\n            if (i % primes[j] == 0) break;\n        }\n    }\n}\n\nconst int N = 1000010;\n\n// int p[N], sz[N];\n// int find(int x)  // \u5e76\u67e5\u96c6\n// {\n//     if (p[x] != x) p[x] = find(p[x]);\n//     return p[x];\n// }\n// void init(int n) {\n//     for (int i = 0; i <= n; i++) p[i] = i, sz[i] = 1;\n// }\n\nLL fac[N], inv[N];\n\nvoid getInv() {\n    fac[0] = 1;\n    for (int i = 1; i < N; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n    }\n    inv[N - 1] = qmi(fac[N - 1], MOD - 2, MOD);\n    for (int i = N - 1; i; i--) {\n        inv[i - 1] = inv[i] * i % MOD;\n    }\n}\n\nLL comb(LL n, int k) {\n    if (n < k) {\n        return 0;\n    }\n    n %= MOD;\n    LL p = 1;\n    for (int i = 1; i <= k; i++) {\n        p = p * (n - i + 1) % MOD;\n    }\n    return p * inv[k] % MOD;\n}\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        map<int, LL> res; // \u7edf\u8ba1\u5b50\u6570\u7ec4\u6570\u91cf\n        vector<array<int, 3>> a; // \u5de6\u7aef\u70b9\u95ed\u533a\u95f4 [a[0], a[1]] \u503c\u4e3a a[2]\n        for (int i = 0; i < nums.size(); i++) {\n            int cur = nums[i];\n            for (auto &v: a) {\n                v[2] &= cur; // \u7ed9\u5b9a\u8fd0\u7b97\n            }\n            a.push_back({i, i, cur});\n            int p = 0; // \u539f\u5730\u53bb\u91cd\n            for (int i = 1; i < a.size(); i++) {\n                if (a[p][2] != a[i][2]) {\n                    p ++;\n                    a[p] = a[i];\n                } else {\n                    a[p][1] = a[i][1];\n                }\n            }\n            a.resize(p + 1);\n            // \u7d2f\u52a0\u5b50\u6570\u7ec4\n            for (auto &t: a) {\n                res[t[2]] += t[1] - t[0] + 1;\n            }\n        }\n        return res[k];\n    }\n};",
    "submit_ts": "1720279955",
    "subm_id": "1311771630"
}