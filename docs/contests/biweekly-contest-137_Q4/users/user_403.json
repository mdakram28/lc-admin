{
    "username": "Wibo",
    "submission": "const int maxn = 503, logn = 9;\ntemplate<typename T> class SparseTable_2D {\nprivate:\n    const int R, C;\n    vector<short> LogTable;\n    T Table[maxn][maxn][logn][logn];\npublic:\n    SparseTable_2D(const vector<vector<T> >& v) : R((int)v.size()), C((int)v[0].size()), LogTable(max(R, C) + 1){\n        for(int i = 2; i <= max(R, C); ++i){\n            LogTable[i] = LogTable[i >> 1] + 1;\n        }\n        for(int i = 0; i < R; ++i){\n            for(int j = 0; j < C; ++j){\n                Table[i][j][0][0] = v[i][j];\n            }\n        }\n        for(int k = 1; (1 << k) <= R; ++k){\n            for(int i = 0; i + (1 << k) <= R; ++i){\n                for(int j = 0; j < C; ++j){\n                    Table[i][j][k][0] = max(Table[i][j][k-1][0], Table[i + (1 << (k - 1))][j][k-1][0]);\n                }\n            }\n        }\n        for(int k = 0; (1 << k) <= R; ++k){\n            for(int l = 1; (1 << l) <= C; ++l){\n                for(int i = 0; i + (1 << k) <= R; ++i){\n                    for(int j = 0; j + (1 << l) <= C; ++j){\n                        Table[i][j][k][l] = max(Table[i][j][k][l-1], Table[i][j + (1 << (l - 1))][k][l-1]);\n                    }\n                }\n            }\n        }\n    }\n    T query(const int lx, const int ly, const int rx, const int ry){\n        const int kx = LogTable[rx - lx];\n        const int ky = LogTable[ry - ly];\n        return max({\n            Table[lx][ly][kx][ky], \n            Table[rx - (1 << kx)][ly][kx][ky], \n            Table[lx][ry - (1 << ky)][kx][ky], \n            Table[rx - (1 << kx)][ry - (1 << ky)][kx][ky]\n        });\n    }\n};\n\nclass Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& board) {\n        short n = board.size(), m = board[0].size();\n        const int magic = 2 * max(n, m) + 1;\n        \n        vector<pair<short, short>> cells(n*m);\n        for (int i=0; i<n; i++) {\n            for (int j=0; j<m; j++) {\n                cells[m*i+j] = {i, j};\n            }\n        }\n        sort(cells.begin(), cells.end(), [&](pair<short, short> &pa, pair<short, short> &pb) {\n            return board[pa.first][pa.second] > board[pb.first][pb.second];\n        });\n        if (cells.size() > magic) cells.resize(magic);\n\n        SparseTable_2D sp(board);\n\n        long long ans = -1e18-3;\n        for (short i=0; i<(int)cells.size(); i++) {\n            for (short j=i+1; j<(int)cells.size(); j++) {\n                auto [ri, ci] = cells[i];\n                auto [rj, cj] = cells[j];\n                if (ri != rj && ci != cj) {\n                    vector<short> rs = {-1, min(ri, rj), max(ri, rj), n}, cs = {-1, min(ci, cj), max(ci, cj), m};\n                    int lst = -1e9-3;\n                    for (short ii=0; ii<3; ii++) {\n                        for (short jj=0; jj<3; jj++) {\n                            if (rs[ii]+1 < rs[ii+1] && cs[jj]+1 < cs[jj+1]) {\n                                lst = max(lst, sp.query(rs[ii]+1, cs[jj]+1, rs[ii+1], cs[jj+1]));\n                            }\n                        }\n                    }\n                    ans = max(ans, 1LL * board[ri][ci] + board[rj][cj] + lst);\n                }\n            }\n        }\n\n        return ans;\n    }\n};",
    "submit_ts": "1723909175",
    "subm_id": "1359182449"
}