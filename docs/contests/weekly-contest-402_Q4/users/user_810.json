{
    "username": "jian-shen-_",
    "submission": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n\nclass Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        List<Integer>res=new ArrayList<>();\n        SingleSegmentTree rt=new SingleSegmentTree(nums);\n        for(int[]q:queries){\n            int t=q[0];\n            int l=q[1];\n            int r=q[2];\n\n            if(t==1){\n                res.add(rt.range(l,r));\n            }else{\n                rt.update(l ,r);\n            }\n        }\n        return res;\n    }\n\n    class SingleSegmentTree {\n        class Node{\n            int lv, rv;\n\n            boolean lg, rg;\n            boolean one;\n            int count;\n\n            public Node(int lv, int rv, int count) {\n                this.lv = lv;\n                this.rv = rv;\n                this.count = count;\n\n                lg=false;\n                rg=false;\n                one=true;\n            }\n\n            @Override\n            public String toString() {\n                return \"Node{\" +\n                        \"lv=\" + lv +\n                        \", rv=\" + rv +\n                        \", lg=\" + lg +\n                        \", rg=\" + rg +\n                        \", one=\" + one +\n                        \", count=\" + count +\n                        '}';\n            }\n        }\n        private Node[] tree; // \u5b58\u50a8\u7ebf\u6bb5\u6811\n        private int[]vals;\n        private int n; // \u6570\u7ec4\u5927\u5c0f\n\n        // \u6784\u9020\u51fd\u6570\uff0c\u521d\u59cb\u5316\u7ebf\u6bb5\u6811\n        public SingleSegmentTree(int[] nums) {\n            if (nums.length > 0) {\n                n = nums.length;\n                vals=nums;\n                tree = new Node[n * 4]; // \u6700\u591a\u9700\u89814n\u7684\u7a7a\u95f4\n                buildTree(nums, 0, 0, n - 1);\n            }\n        }\n\n        void up(int p, int l, int r){\n            tree[p].lv=tree[l].lv;\n            tree[p].rv=tree[r].rv;\n\n            tree[p].count=tree[l].count+tree[r].count;\n            tree[p].one=false;\n\n            tree[p].lg=tree[l].lg;\n            tree[p].rg=tree[r].rg;\n\n            if(!tree[l].one){\n                if(tree[l].rg && tree[l].rv>tree[r].lv){\n                    tree[p].count++;\n                }\n            }else{\n                tree[p].lg = tree[l].lv > tree[r].lv;\n            }\n\n            if(!tree[r].one){\n                if(tree[r].lg && tree[l].rv < tree[r].lv){\n                    tree[p].count++;\n                }\n            }else{\n                tree[p].rg = tree[r].rv > tree[l].rv;\n            }\n\n        }\n\n        // \u5728treeIndex\u7684\u4f4d\u7f6e\u521b\u5efa\u8868\u793a\u533a\u95f4[l...r]\u7684\u7ebf\u6bb5\u6811\n        private void buildTree(int[] nums, int treeIndex, int l, int r) {\n            if (l == r) {\n                // \u53f6\u5b50\u8282\u70b9\uff0c\u8868\u793a\u4e00\u4e2a\u5143\u7d20\n                tree[treeIndex] = new Node(nums[l],nums[l],0);\n                return;\n            }\n            int mid = l + (r - l) / 2; // \u9632\u6b62\u6ea2\u51fa\n            int leftTreeIndex = 2 * treeIndex + 1;\n            int rightTreeIndex = 2 * treeIndex + 2;\n            buildTree(nums, leftTreeIndex, l, mid); // \u6784\u5efa\u5de6\u5b50\u6811\n            buildTree(nums, rightTreeIndex, mid + 1, r); // \u6784\u5efa\u53f3\u5b50\u6811\n\n            tree[treeIndex]=new Node(0,0,0);\n            up(treeIndex, leftTreeIndex, rightTreeIndex); // \u5185\u90e8\u8282\u70b9\u7684\u503c\u4e3a\u5de6\u53f3\u5b50\u6811\u7684\u503c\u4e4b\u548c\n\n            //System.out.println(tree[treeIndex]);\n            //System.out.println(Arrays.toString(new int[]{treeIndex, l, r}));\n\n        }\n\n        // \u66f4\u65b0\u64cd\u4f5c\uff0c\u5c06nums[index]\u7684\u503c\u66f4\u65b0\u4e3aval\n        public void update(int index, int val) {\n            updateTree(0, 0, n - 1, index, val);\n        }\n\n        // \u5728\u4ee5treeIndex\u4e3a\u6839\u7684\u7ebf\u6bb5\u6811\u4e2d\u66f4\u65b0index\u7684\u503c\u4e3aval\n        private void updateTree(int treeIndex, int l, int r, int index, int val) {\n            if (l == r) {\n                tree[treeIndex].lv = val;\n                tree[treeIndex].rv = val;\n                \n                vals[l]=val;\n                return;\n            }\n            int mid = l + (r - l) / 2;\n            int leftTreeIndex = 2 * treeIndex + 1;\n            int rightTreeIndex = 2 * treeIndex + 2;\n            if (index <= mid) {\n                updateTree(leftTreeIndex, l, mid, index, val);\n            } else {\n                updateTree(rightTreeIndex, mid + 1, r, index, val);\n            }\n\n            up(treeIndex, leftTreeIndex, rightTreeIndex); // \u5185\u90e8\u8282\u70b9\u7684\u503c\u4e3a\u5de6\u53f3\u5b50\u6811\u7684\u503c\u4e4b\u548c\n\n        }\n\n        // \u67e5\u8be2\u64cd\u4f5c\uff0c\u6c42\u533a\u95f4[queryL, queryR]\u7684\u503c\n        public int range(int queryL, int queryR) {\n            return query(0, 0, n - 1, queryL, queryR);\n        }\n\n        // \u5728\u4ee5treeIndex\u4e3a\u6839\u7684\u7ebf\u6bb5\u6811\u4e2d\u67e5\u8be2\u533a\u95f4[queryL, queryR]\u7684\u503c\n        private int query(int treeIndex, int l, int r, int queryL, int queryR) {\n            //System.out.println(Arrays.toString(new int[]{treeIndex, l, r, queryL, queryR}));\n            if (queryL <= l && queryR >= r) {\n                // \u5f53\u524d\u533a\u95f4\u88ab\u67e5\u8be2\u533a\u95f4\u5b8c\u5168\u8986\u76d6\n                Node tmp = tree[treeIndex];\n                int res=tmp.count;\n\n                if(!tmp.one ){\n                    if(queryL < l && tmp.lg && tmp.lv > vals[l - 1])++res;\n\n                    if(r < queryR && tmp.rg && tmp.rv > vals[r + 1])++res;\n                }else{\n                    if(queryL<l && r<queryR && tmp.lv > vals[l - 1] && tmp.rv > vals[r + 1])++res;\n                }\n\n                return res;\n            }\n            int mid = l + (r - l) / 2;\n            int leftTreeIndex = 2 * treeIndex + 1;\n            int rightTreeIndex = 2 * treeIndex + 2;\n            int sum = 0;\n            if (queryL <= mid) {\n                sum += query(leftTreeIndex, l, mid, queryL, queryR);\n            }\n            if (queryR > mid) {\n                sum += query(rightTreeIndex, mid + 1, r, queryL, queryR);\n            }\n            return sum;\n        }\n\n    }\n}",
    "submit_ts": 1718508527.0
}