{
    "username": "HenryJuice",
    "submission": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def bfs(tree, start_node, n):\n            dist = [-1] * n\n            dist[start_node] = 0\n            q = deque([start_node])\n\n            farthest_node = start_node\n            max_dist = 0\n\n            while q:\n                node = q.popleft()\n                for neighbor in tree[node]:\n                    if dist[neighbor] == -1:\n                        dist[neighbor] = dist[node] + 1\n                        q.append(neighbor)\n                        if dist[neighbor] > max_dist:\n                            max_dist = dist[neighbor]\n                            farthest_node = neighbor\n\n            return farthest_node, max_dist\n        \n        def find_tree_diameter(tree, n):\n            # First BFS/DFS to find the farthest node from any node (let's start with node 0)\n            farthest_node_from_start, _ = bfs(tree, 0, n)\n\n            # Second BFS/DFS to find the farthest node from the farthest node found in the first BFS/DFS\n            farthest_node, diameter = bfs(tree, farthest_node_from_start, n)\n\n            return diameter\n\n        tree1 = [[] for _ in range(len(edges1) + 1)]\n        tree2 = [[] for _ in range(len(edges2) + 1)]\n\n        for u, v in edges1:\n            tree1[u].append(v)\n            tree1[v].append(u)\n\n        for u, v in edges2:\n            tree2[u].append(v)\n            tree2[v].append(u)\n\n        d1, d2 = find_tree_diameter(tree1, len(edges1) + 1), find_tree_diameter(tree2, len(edges2) + 1)\n        return max(max(d1, d2), (d1 + 1) // 2 + (d2 + 1) // 2 + 1)",
    "submit_ts": "1719718844",
    "subm_id": "1304427478"
}