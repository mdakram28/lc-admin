{
    "username": "ijasonchao",
    "submission": "class Solution:\n    def maximumValueSum_TLE(self, board: List[List[int]]) -> int:        \n        m, n = len(board), len(board[0])\n        col = set(list(range(n)))        \n        def dfs(r, k, col):\n            if k == 0: return 0\n            if r == m or m - r < k: return -inf\n            if len(col) == 0: return -inf\n            else:\n                cur = dfs(r+1, k, col)\n                for j in col:                    \n                    v = board[r][j]                    \n                    cur = max(cur, v + dfs(r + 1, k - 1, col ^ set([j])))\n                return cur\n        return dfs(0, 3, col)\n    \n    def maximumValueSum(self, board: List[List[int]]) -> int:  \n        \"\"\"\n        there are only 3 rooks, if I pin two of them, and loop the other one\n[[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]\n[[1,2,3],[4,5,6],[7,8,9]]\n[[1,1,1],[1,1,1],[1,1,1]]\n[[-23,12,-7],[12,18,-52],[98,16,70]]\n        \"\"\"\n        m = len(board)\n        n = len(board[0])\n\n        max_rooks = 3\n        dp = [-float('inf')] * (1 << n)\n        dp[0] = 0  # Base case: no columns are occupied, sum is 0\n\n        for r in range(m):\n            new_dp = dp[:]  # Copy current dp array to update it\n            for mask in range(1 << n):\n                if bin(mask).count('1') < max_rooks:\n                    for col in range(n):\n                        if not (mask & (1 << col)):  # If the column `col` is not occupied in `mask`\n                            new_mask = mask | (1 << col)\n                            new_dp[new_mask] = max(new_dp[new_mask], dp[mask] + board[r][col])\n            dp = new_dp  # Move to the next row\n\n        # We are interested in the configuration with exactly 3 columns occupied\n        return max(dp[mask] for mask in range(1 << n) if bin(mask).count('1') == max_rooks)\n    \n    def maximumValueSum(self, board: List[List[int]]) -> int:  \n        m = len(board)\n        n = len(board[0])        \n        top_k = 3  \n        best_per_row = []\n\n        for i in range(m):\n            row_values = [(board[i][j], j) for j in range(n)]\n            row_values.sort(reverse=True, key=lambda x: x[0])\n            best_per_row.append(row_values[:top_k])\n\n        best_pairs = []\n        for i in range(m):\n            cur_i = best_per_row[i]\n            for j in range(i+1, m):                \n                cur_j = best_per_row[j]\n                for v1, c1 in cur_i:\n                    for v2, c2 in cur_j:\n                        if c1 != c2: \n                            best_pairs.append((v1+v2, i, j, c1, c2))\n\n        best_pairs.sort(reverse=True)\n        res = -inf\n        for v, i, j, c1, c2 in best_pairs[:10]:\n            for k in range(m):            \n                if k != i and k != j:\n                    cur_k = best_per_row[k]\n                    for v3, c in cur_k:\n                        if c != c1 and c!= c2:\n                            res = max(res, v + v3)\n        return res\n        ",
    "submit_ts": "1723910308",
    "subm_id": "1359225289"
}