{
    "username": "muntasir_120",
    "submission": "import operator\n\nclass RMQTree:\n \n  def __init__(self, length, op, default_value = 0, identity = 0):\n    self._len = length\n    self._op = op\n    self._identity = identity\n    self._default_value = default_value\n    self._buildTree()\n  \n  def _buildTree(self):\n    self._tree = []\n    cur = [self._default_value for _ in range(self._len)]\n    self._tree.append(cur)\n    \n    while len(self._tree[-1]) > 1:\n      cur_level = []\n      last_level = self._tree[-1]\n      if len(last_level) % 2:\n        last_level.append(self._identity)\n      \n      for i in range(0, len(last_level), 2):\n        cur_level.append(self._op(last_level[i], last_level[i + 1]))\n      self._tree.append(cur_level)\n      \n \n  def set(self, index, value):\n    #print('setting ', index, ' to ', value)\n    self._tree[0][index] = value\n    level = 1\n    index//=2\n    while level < len(self._tree):\n      last = self._tree[level - 1]\n      self._tree[level][index] = self._op(last[2*index], last[2*index + 1])\n      level += 1\n      index //= 2\n \n  def __setitem__(self, index, value):\n    self.set(index, value)\n  \n  def get(self, start, end):\n    level = 0\n    ret = self._identity  \n    while start < end:\n      if start % 2:\n        ret = self._op(ret, self._tree[level][start])\n        start += 1\n      if end % 2 == 0:\n        ret = self._op(ret, self._tree[level][end])\n        end -= 1\n      level += 1\n      start //= 2\n      end //= 2\n    if start ==  end:\n      return self._op(ret, self._tree[level][start])\n    else:\n      return ret\n    \n  def __getitem__(self, index):\n    if type(index) == slice:\n      start = index.start if index.start is not None else 0\n      stop = index.stop if index.stop is not None else self._len\n      return self.get(start, stop - 1)\n    else:\n      return self.get(index, index)\n \n  def __len__(self):\n    return self._len\n\n  def __str__(self):\n      return str(self._tree[0])\n\n\n\ndef isPeak(nums, index):\n  if index <= 0 or (index + 1) >= len(nums):\n    return False\n  else:\n    return nums[index-1] < nums[index] > nums[index + 1]\n  \nclass Solution:\n  def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    N = len(nums)\n    tree = RMQTree(N, operator.add)\n    for idx, value in enumerate(nums):\n      if isPeak(nums, idx):\n        tree[idx] = 1\n        \n    ans = []    \n    for t,a,b in queries:\n      #print(t,a,b)\n      if t == 1:\n        l,r = a+1,b\n        #print('appending')\n        ans.append(tree[l:r])\n      else:\n        idx,val = a,b\n        nums[idx] = val\n        \n        if idx > 0:\n          tree[idx-1] = 1 if isPeak(nums, idx-1) else 0\n        tree[idx] = 1 if isPeak(nums, idx) else 0\n        if idx + 1 < N:\n          tree[idx+1] = 1 if isPeak(nums, idx+1) else 0\n      #print(nums) \n    return ans    \n\n    \n        ",
    "submit_ts": "1718508065",
    "subm_id": "1289670667"
}