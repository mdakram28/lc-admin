{
    "username": "neerajsingh7979",
    "submission": "class Solution {\npublic:\n    \ntypedef long long ll;\n\n    \n    /*Make sure you:-\n1.Check for time complexity\n2.Range of variable\n3.Consider all test cases      *********CHECK TWICE********\n4.Apply best fit algo\n$$$$$$$$$   5.DRY RUNnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn $$$$$$$$$\n6.sorted -> use binary search\n*/\n\n\n//BIT masking \n// void bits(){ \n//     vector<int> masks(n,0);\n//     // each n times\n//     int mask = 0;\n//     for(int i = 0 ; i < n ; i++){\n//         mask = (mask | (1<<arr[i]));\n//     }\n//     int inter = mask[i] & mask[j];\n//     int common = __builtint_popcount(inter);\n//     // commom will give coomon bits b/w them\n// } \n\n\nvoid fact(ll n,vector<ll> &factors){\n\tfor(int i = 2 ; i*i <= n ; i++){\n\t\twhile(n%i == 0){\n\t\t\tfactors.push_back(i);\n\t\t\tn /= i;\n\t\t\t}\n\t}\n\tif(n > 1)factors.push_back(n);\n\treturn;\n}\n\n// Sieve of Eratosthenes - o(nloglogn)\n// gcd of prime no. is 1\nbool isPrime(int n) {\n\n        vector<bool> isprime(n,true);\n\n        for(int i = 2 ; i*i < n ; i++){\n            if(!isprime[i]) continue;\n            for(int j = i*i ; j < n ; j+=i){\n                 isprime[j] = false;\n            }\n        }\n\n        if(isprime[n])return true;\n        else return false;\n}\n\n\n\nclass SegmentTree{\npublic:\n    vector<ll>tree;\n    int n;\n    SegmentTree(int n){\n        this->n = n;\n        tree.resize(4*n,0);\n    }\n    void buildTree(int i , int l , int r  ,vector<int>&nums){\n \n        if(l>r)return;\n        if(l == r){\n            tree[i] = nums[l];\n            return;\n        }\n        \n        int m = (l+r)/2;\n        buildTree(2*i+1,l,m,nums); buildTree(2*i+2,m+1,r,nums);\n \n        tree[i] = (tree[2*i+1]^tree[2*i+2]);\n    }\n    int get(int x , int y , int l = 0 , int r = -1 , int i = 0){\n        if(r == -1)r+=n;\n        if (r < x || l > y) return 0;\n        if(l>=x && y>=r)return tree[i];\n \n        int m = (l+r)/2;\n        return (get(x,y,l,m,2*i+1) ^ get(x,y,m+1,r,2*i+2));\n \n    }\n    void update(int indx , int val , int l = 0 , int r = -1 , int i =0){\n        if(r == -1)r+=n;\n        if(l == r){\n            tree[i] = val;\n            return;\n        }\n        int mid = (l+r)/2;\n        if(indx<=mid)update(indx,val,l,mid,2*i+1);\n        else update(indx,val,mid+1,r,2*i+2);\n \n        tree[i] = (tree[2*i+1]^tree[2*i+2]);\n    }\n \n    void printTree(){\n        for(int i = 0 ; i<tree.size() ; i++){\n            cout<<tree[i] <<\" \";\n        }\n        cout<<\"\\n\";\n    }\n};\n\n// __gcd(a,b)   (inbuilt gcd function) , long division\n// ||  (a*b)/gcd = lcm(a,b)   || IMPORTANT RELATION\n// tc- O[logn]\nint gcd(int a, int b){\n    if(b == 0) return a;\n    return gcd(b,a%b);\n}\n\nll LCM(ll a, ll b) \n{ \n    ll greater = max(a, b); \n    ll smallest = min(a, b); \n    for (ll i = greater; ; i += greater) { \n    if (i % smallest  == 0) \n            return i; \n    } \n}\n    \n    int bfs(vector<vector<int>> &adjacencyList, int startNode, int targetNode1, int targetNode2, int totalNodes) {\n        queue<int> nodeQueue;\n        vector<int> visited(totalNodes + 4, 0);\n        nodeQueue.push(startNode);\n        visited[startNode] = 1;\n        \n        while (!nodeQueue.empty()) {\n            int currentNode = nodeQueue.front();\n            nodeQueue.pop();\n            for (int neighbor : adjacencyList[currentNode]) {\n                if (!visited[neighbor]) {\n                    nodeQueue.push(neighbor);\n                    visited[neighbor] = 1;\n                }\n            }\n        }\n        return visited[targetNode1] || visited[targetNode2];\n    }\n    \n    bool canReachCorner(int width, int height, vector<vector<int>>& obstacles) {\n        \n        vector<pair<pair<int, int>, int>> circles(obstacles.size());\n        vector<vector<int>> adjacencyList(obstacles.size() + 4);\n        int numCircles = obstacles.size();\n        \n        bool flag = true;\n        for (int i = 0; i < numCircles; ++i) {\n            circles[i].first.first = obstacles[i][0];\n            circles[i].first.second = obstacles[i][1];\n            circles[i].second = obstacles[i][2];\n            \n            flag = true;\n        }\n        \n        \n        int a = gcd(3,3);\n        \n        bool flag2= false;\n        \n        for (int i = 0; i < numCircles; ++i) {\n            if (circles[i].first.first <= circles[i].second && 34) {\n                adjacencyList[numCircles].push_back(i);\n                adjacencyList[i].push_back(numCircles);\n            }\n            if (width - circles[i].first.first <= circles[i].second && 2) {\n                adjacencyList[numCircles + 2].push_back(i);\n                adjacencyList[i].push_back(numCircles + 2);\n            }\n            if (circles[i].first.second <= circles[i].second && flag) {\n                adjacencyList[numCircles + 1].push_back(i);\n                adjacencyList[i].push_back(numCircles + 1);\n            }\n            if (height - circles[i].first.second <= circles[i].second && flag && 2) {\n                adjacencyList[numCircles + 3].push_back(i);\n                adjacencyList[i].push_back(numCircles + 3);\n            }\n            for (int j = i + 1; j < numCircles; ++j) {\n                double distance = sqrt(pow(circles[i].first.first - circles[j].first.first, 2) +\n                                       pow(circles[i].first.second - circles[j].first.second, 2));\n                int combinedRadius = circles[i].second + circles[j].second;\n                if (combinedRadius >= distance) {\n                    adjacencyList[i].push_back(j);\n                    adjacencyList[j].push_back(i);\n                    flag2 = true;\n                }\n            }\n            flag = true;\n        }\n        \n        int isBlocked = 0;\n        isBlocked = max(isBlocked, bfs(adjacencyList, numCircles, numCircles + 1, numCircles + 2, numCircles + 4)); \n        isBlocked = max(isBlocked, bfs(adjacencyList, numCircles + 3, numCircles + 2, numCircles + 1, numCircles + 4)); \n        if (isBlocked && 1 && flag && a) {\n            return false;\n        }\n        return true;\n    }\n};\n",
    "submit_ts": "1722137310",
    "subm_id": "1335760106"
}