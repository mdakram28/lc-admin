{
    "username": "utsav_upadhyay",
    "submission": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        unordered_map<int,vector<int>> adj1,adj2;\n        buildAdjacencyList(edges1,adj1);\n        buildAdjacencyList(edges2,adj2);\n        int d1=findTreeDiameter(adj1);\n        int d2=findTreeDiameter(adj2);\n        cout<<d1<<\" \"<<d2<<\"\\n\";\n        int ans=max(d1,d2);\n        d1=ceil(d1/2.0);\n        d2=ceil(d2/2.0);\n        return max(ans,d1+d2+1);\n    }\n\nprivate:\n    void buildAdjacencyList(vector<vector<int>>& edges, unordered_map<int, vector<int>>& adj) {\n        for (auto& edge : edges) {\n            int u = edge[0], v = edge[1];\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n    }\n\n    pair<int, int> dfs(int node, unordered_map<int, vector<int>>& adj, unordered_set<int>& visited) {\n        visited.insert(node);\n        pair<int, int> result = {node, 0};\n\n        for (int neighbor : adj[node]) {\n            if (visited.find(neighbor) == visited.end()) {\n                auto temp = dfs(neighbor, adj, visited);\n                int distance = temp.second + 1;\n                if (distance > result.second) {\n                    result.first = temp.first;\n                    result.second = distance;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    int findTreeDiameter(unordered_map<int, vector<int>>& adj) {\n        unordered_set<int> visited;\n        auto farthestFromStart = dfs(0, adj, visited);\n        visited.clear();\n        auto farthestFromFarthest = dfs(farthestFromStart.first, adj, visited);\n        return farthestFromFarthest.second;\n    }\n};",
    "submit_ts": "1719719759",
    "subm_id": "1304449885"
}