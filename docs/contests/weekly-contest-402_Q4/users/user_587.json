{
    "username": "hywo",
    "submission": "/*\n    index - \u8282\u70b9\u7f16\u53f7\uff0c\u4ece1\u5f00\u59cb\n    l, r - \u5f85\u67e5\u8be2\u7684\u533a\u95f4\n    i, j - \u5f53\u524d\u8282\u70b9\u6240\u8868\u793a\u7684\u533a\u95f4\n    index = 1, i = 0, j = n - 1\n */\n\nclass SegmentTree {\n    int[] peek;\n\n    boolean[] isPeek;\n\n    int[] nums;\n\n    int n;\n\n    public SegmentTree(int size) {\n        n = size;\n        peek = new int[size << 2];\n        isPeek = new boolean[size];\n    }\n\n    public SegmentTree(int[] a) {\n        this(a.length);\n        nums = a;\n        build(1, 0, n - 1, a);\n    }\n\n    public void set(int pos, int num) {\n        if (nums[pos] == num) return;\n        nums[pos] = num;\n        if (checkChange(pos - 1)) update(pos - 1);\n        if (checkChange(pos)) update(pos);\n        if (checkChange(pos + 1)) update(pos + 1);\n    }\n\n    private boolean checkChange(int pos) {\n        if (pos <= 0 || pos >= n - 1) return false;\n        if (isPeek[pos] && (nums[pos] <= nums[pos - 1] || nums[pos] <= nums[pos + 1])) {\n            isPeek[pos] = false;\n            return true;\n        }\n        if (!isPeek[pos] && nums[pos] > nums[pos - 1] && nums[pos] > nums[pos + 1]) {\n            isPeek[pos] = true;\n            return true;\n        }\n        return false;\n    }\n\n    private void update(int pos) {\n        update(pos, 0, n - 1, 1);\n    }\n\n    private void update(int pos, int i, int j, int index) {\n        if (i > pos || j < pos) return;\n        if (i == j) {\n            peek[index] = 1 - peek[index];\n            return;\n        }\n        int mid = i + (j - i) / 2;\n        update(pos, i, mid, index << 1);\n        update(pos, mid + 1, j, index << 1 | 1);\n        peek[index] = peek[index << 1] + peek[index << 1 | 1];\n    }\n\n    private void build(int index, int l, int r, int[] a) {\n        if (l == r) {\n            if (l == 0 || l == n - 1) return;\n            if (a[l] > a[l - 1] && a[l] > a[l + 1]) {\n                isPeek[l] = true;\n                peek[index] = 1;\n            } else {\n                isPeek[l] = false;\n            }\n            return;\n        }\n        int mid = l + (r - l) / 2;\n        build(index << 1, l, mid, a);\n        build(index << 1 | 1, mid + 1, r, a);\n        // write your code here\n        peek[index] = peek[index << 1] + peek[index << 1 | 1];\n    }\n\n    private int query(int l, int r, int i, int j, int index) {\n        if (i > r || j < l) return 0;\n        if (l <= i && j <= r) return peek[index];\n        int mid = i + (j - i) / 2;\n        if (r <= mid) return query(l, r, i, mid, index * 2);\n        if (i > mid) return query(l, r, mid + 1, j, index * 2 + 1);\n        // write your code here\n        return query(l, r, i, mid, index * 2) + query(l, r, mid + 1, j, index * 2 + 1);\n    }\n\n    public int query(int l, int r) {\n        return query(l, r, 0, n - 1, 1);\n    }\n}\n\nclass Solution {\n    private static final int MOD = 1000000007;\n\n    private static int[][] dirs = new int[][] {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        SegmentTree tree = new SegmentTree(nums);\n        List<Integer> ans = new ArrayList<>();\n        for (int[] q : queries) {\n            if (q[0] == 1) {\n                ans.add(tree.query(q[1] + 1, q[2] - 1));\n            } else {\n                tree.set(q[1], q[2]);\n            }\n        }\n        return ans;\n    }\n}",
    "submit_ts": "1718507681",
    "subm_id": "539782824"
}