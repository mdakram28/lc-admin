{
    "username": "devvrat_07",
    "submission": "#include <bits/stdc++.h>\nusing namespace std;\n \n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<class T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define ff first\n#define ss second\n#define ld long double\n#define ll long long\n#define pb push_back\n#define INF 1e18\n#define ppb pop_back\n#define fl(i,n,m) for(int i=n;i<m;i++)\n#define pii pair<int,int>\n#define vi vector<int>\n#define vll vector<ll>\n#define print(a) for(auto &it:a) cout<<it<<\" \"; cout<<endl\n#define mii map<int,int>\n#define setbits(x) __builtin_popcountll(x)\n#define sz(x) ((int)(x).size())\n#define all(a) a.begin(),a.end()\n#define yes cout<<\"YES\"<<endl\n#define no cout<<\"NO\"<<endl\n \nll gcd(ll a, ll b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}\nll expo(ll a, ll b, ll mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}\nvoid extendgcd(ll a, ll b, ll*v) {if (b == 0) {v[0] = 1; v[1] = 0; v[2] = a; return ;} extendgcd(b, a % b, v); ll x = v[1]; v[1] = v[0] - v[1] * (a / b); v[0] = x; return;} //pass an arry of size1 3\nll mminv(ll a, ll b) {ll arr[3]; extendgcd(a, b, arr); return arr[0];} //for non prime b\nll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}\nbool revsort(ll a, ll b) {return a > b;}\n \nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\nll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;} //only for prime m\n \nint pw(ll int a, ll int b, ll int m) {\n    if(b==0) {\n        return 1;\n    }\n \n    if(b%2 == 0) {\n        ll int t = pw(a, (b/2), m);\n        return (1ll*t*t)%m;\n    }\n    else {\n        ll int t = pw(a, (b-1)/2, m);\n        t = (1ll*t*t)%m;\n        return (1ll*a*t)%m;\n    }\n}\n \nconst int N=500000;\nconst ll int mod = 1e9 + 7;\n \nll int fact[N], invfact[N];\nvoid init() {\n    ll int p = mod;\n    fact[0]=1;\n    int i;\n    for(i=1; i<N; i++) {\n        fact[i] = (i*fact[i-1])%p;\n    }\n    i--;\n    invfact[i] = pw(fact[i], p-2, p);\n    for(i--; i>=0; i--) {\n        invfact[i] = (invfact[i+1]*(i+1))%p;\n    }\n}\n \nint ncr(int n, int r) {\n    return (((fact[n]*invfact[r])%mod)*invfact[n-r])%mod;\n}\n \nvector<int> sieve_of_eratosthenes(int n) {\n    vector<int> prm;\n    bool is_prime[n + 1];\n    memset(is_prime, true, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = false;\n    for(int p = 2; p * p <= n; p++) {\n        if(is_prime[p]) {\n            for(int i = p * p; i <= n; i += p) {\n                is_prime[i] = false;\n            }\n        }\n    }\n    for(int i = 2; i <= n; i++) {\n        if(is_prime[i]) {\n            prm.pb(i);\n        }\n    }\n    return prm;\n}\n\nclass Solution {\npublic:\n    const ll mod = 1e9+7;\n    ll helper(vector<int> &nums){\n        int n = nums.size();\n        vector<vector<ll>> dp(n+2, vector<ll>(52, 0));\n        int max_val = 52;  // maximum value of nums[i] + 1\n        ll pre_val_cal[max_val];\n        for(int ls = 0; ls <= nums[n-1]; ls++) {\n            dp[n][ls] = 1;\n        }\n        for(int i = n-1; i >= 0; i--) {\n            pre_val_cal[0] = dp[i+1][0];\n            for(int j = 1; j <= nums[i]; j++) {\n                pre_val_cal[j] = (pre_val_cal[j-1] + dp[i+1][j]) % mod;\n            }\n            for(int ls = 0; ls <= nums[i]; ls++) {\n                if(i == 0) {\n                    dp[i][ls] = pre_val_cal[nums[i]];\n                } else {\n                    int minim = max(ls, nums[i] - nums[i-1] + ls);\n                    if(minim > nums[i]) {\n                        dp[i][ls] = 0;\n                    } else {\n                        dp[i][ls] = (pre_val_cal[nums[i]] - (minim > 0 ? pre_val_cal[minim - 1] : 0) + mod) % mod;\n                    }\n                }\n            }\n        }\n        ll ans = dp[0][0]%mod;\n        return ans;\n    }\n    int countOfPairs(vector<int>& nums) {\n        return helper(nums);\n    }\n};",
    "submit_ts": "1723345452",
    "subm_id": "1351556061"
}