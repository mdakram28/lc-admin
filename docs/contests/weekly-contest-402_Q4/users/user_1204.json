{
    "username": "DCXiaoBing",
    "submission": "class Solution {\n  // segtree, update the tree for each op2\n  // mark val to 1 when it is peek\n  \n  private static final int MAX = (int)1e5 + 10;\n  public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n    int n = nums.length;\n    BIT bit = new BIT(MAX);\n    \n    for (int i = 1; i < n - 1; i++) if (isPeak(nums, i)) bit.update(i + 1, 1); // make idx 1-based\n    \n    List<Integer> res = new ArrayList<>();\n    for (int[] q : queries) {\n      if (q[0] == 2) {\n        bit.update(q[1] + 1, computeUpdateDiff(nums, q[1], q[2], q[1]));\n        if (q[1] > 0) bit.update(q[1] - 1 + 1, computeUpdateDiff(nums, q[1] - 1, q[2], q[1]));\n        if (q[1] + 1 < n) bit.update(q[1] + 1 + 1, computeUpdateDiff(nums, q[1] + 1, q[2], q[1]));\n        \n        nums[q[1]] = q[2];\n      } else {\n        if (q[1] == q[2]) {\n          res.add(0);\n          continue;\n        }\n        int cnt = bit.query(q[2] + 1 - 1);\n        // System.out.println(cnt);\n        cnt -= bit.query(q[1] + 1);\n        // System.out.println(\"-\" + bit.query(q[1]));\n        \n        // for (int i = 0; i < bit.arr.length; i++) if (bit.arr[i] < 0) {\n        //   System.out.println(i + \" \" + bit.arr[i]);\n        // }\n        res.add(cnt);\n      }\n    }\n    return res;\n  }\n  \n  private int computeUpdateDiff(int[] nums, int idx, int val, int valIdx) {\n    int old = nums[valIdx];\n    boolean isOldPeak = isPeak(nums, idx);\n\n    nums[valIdx] = val;\n    boolean isNewPeak = isPeak(nums, idx);\n    \n    int res = 0;\n    if (isOldPeak && !isNewPeak) res = -1;\n    if (!isOldPeak && isNewPeak) res = 1;\n    \n    nums[valIdx] = old;\n    return res;\n  }\n  \n  private boolean isPeak(int[] nums, int idx) {\n    int n = nums.length;\n    if (idx == 0 || idx == n - 1) return false;\n    \n    return nums[idx] > nums[idx - 1] && nums[idx] > nums[idx + 1];\n  }\n}\n\nclass BIT {\n  // index 0 represents nothing!\n  // So all element should be 1-indexed\n  int[] arr;\n\n  public BIT(int len) {\n    arr = new int[len];\n  }\n\n  // need to pop up\n  public void update(int idx, int val) {\n    while(idx < arr.length) {\n      arr[idx] = compute(arr[idx], val);\n      idx += idx & -idx; // add a lowest bit\n    }\n    // System.out.println(Arrays.toString(arr) + \" \" + idx + \" \" + val);\n  }\n\n  public int query(int idx) {\n    int res = 0; // like Segment tree, need combine results\n    while(idx > 0) {\n      res = compute(res, arr[idx]);\n      idx -= idx & -idx; // remove a lowest bit\n    }\n    return res;\n  }\n\n  // function that combine results\n  // l is the index to store results\n  private int compute(int old, int val) {\n    // return Math.max(old, val); max num\n    return old + val; // prefixsum\n  }\n}",
    "submit_ts": 1718508889.0
}