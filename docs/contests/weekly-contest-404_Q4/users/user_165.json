{
    "username": "Marmaduke",
    "submission": "class Solution {\npublic:\n    void dfs(int node, vector<vector<int>>& E, vector<int>& dp_down, vector<int>& L)\n    {\n        priority_queue<int, vector<int>, std::greater<int>> pq;\n        dp_down[node] = L[node] = 1;\n        for(auto &x : E[node])\n        {\n            if(dp_down[x] == -1)\n            {\n                dfs(x, E, dp_down, L);\n                pq.push(dp_down[x]);\n                if(pq.size() > 2)\n                {\n                    pq.pop();\n                }\n            }\n        }\n        vector<int> v;\n        while(!pq.empty())\n        {\n            v.push_back(pq.top());\n            pq.pop();\n        }\n        if(!v.empty())\n        {\n            dp_down[node] = L[node] = 1 + v.back();\n            if(v.size() == 2)\n            {\n                L[node] = 1 + v[0] + v[1];\n            }\n        }\n    }\n    int helper(vector<vector<int>>& edges)\n    {\n        int n = edges.size() + 1;\n        vector<vector<int>> E(n);\n        for(auto &u : edges)\n        {\n            int a = u[0];\n            int b = u[1];\n            E[a].push_back(b);\n            E[b].push_back(a);\n        }\n        \n        vector<int> dp_down(n,-1);\n        vector<int> L(n,-1);\n        dfs(0, E, dp_down, L);\n        int ans = 0;\n        for(int i = 0; i < n; i++)\n        {\n            ans = max(L[i], ans);\n        }\n        return ans;\n        \n\n    }\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int A = helper(edges1);\n        int B = helper(edges2);\n        int ans = max(A,B);\n        int a = (A/2)+1;\n        int b = (B/2)+1;\n        ans = max(ans, a+b);\n        return ans-1;\n    }\n};",
    "submit_ts": 1719717886.0
}