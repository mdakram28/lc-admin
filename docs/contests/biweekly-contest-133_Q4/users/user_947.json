{
    "username": "Vedant_Rathore",
    "submission": "\nclass Solution {\n\n\npublic:\n    int numberOfPermutations(int n, vector<vector<int>>& reqs) {\n        int modulo = 1e9+7 ;\n        int topIvn = 400 ;\n        unordered_map<int, int> CountInv;\n        for (auto& req : reqs) {\n            CountInv[req[0] + 1] = req[1]; \n        }\n        unordered_map<int,int>countPrevInv ;\n        int K = 0 ; \n        countPrevInv[K] += 1 ;\n        countPrevInv[K/2] += 1 ;\n        int checkAhead = 1 ; \n        vector<vector<long long>> dp(n + 1, vector<long long>(topIvn + 1, 0));\n        dp[0][0] = 1;\n         int checkPrev = 0 ; \n        int times = 1;\n        while (times <= n) {\n            countPrevInv[K] += 1 ;\n            int curr = 0;\n            if( checkPrev == false ){\n                countPrevInv[K] -=1 ;\n            }\n            if( checkAhead == true ){\n                countPrevInv[K/2] += n ;\n            }\n            while (curr <= topIvn) {\n                int born = 0;\n                while (born < times) {\n                    int pastInv = curr - born;\n                    if (pastInv >= 0) {\n                        dp[times][curr] = (dp[times][curr] + dp[times - 1][pastInv]) % modulo;\n                        checkPrev = pastInv ;\n                        checkAhead = checkPrev ;\n                        checkPrev = 1 ;\n                    }\n                    ++born;\n                }\n                ++curr;\n            }\n\n            unordered_map<int,int>final ;\n            if (CountInv.count(times) > 0) {\n                bool Ahead= false ;\n                int requiredInversions = CountInv[times];\n                int curr = 0;\n                while (curr <= topIvn) {\n                    if( Ahead == true ){\n                        final[K] = curr ;\n                    }\n                    if (curr != requiredInversions) {\n                        dp[times][curr] = 0;\n                        Ahead = true ;\n                    }\n                    ++curr;\n                }\n            }\n            checkAhead = 1 ;\n            checkPrev = 1 ;\n            ++times;\n        }\n\n        long long finalAns = 0;\n        int curr = 0;\n        int prevIdx = -1 ; \n        while (curr <= topIvn) {\n            finalAns = (finalAns + dp[n][curr]) % modulo;\n            if( prevIdx == -1 ){\n                countPrevInv[K] = finalAns ;\n                prevIdx = curr ;\n            }\n            prevIdx ++ ; \n            ++curr;\n        }\n        int finalAns2 = finalAns ;\n        prevIdx = -1 ;\n        finalAns = countPrevInv[K] ;\n        return finalAns2;\n    }\n};",
    "submit_ts": "1719071623",
    "subm_id": "1296850709"
}