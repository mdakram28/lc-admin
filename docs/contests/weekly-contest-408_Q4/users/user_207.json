{
    "username": "shreyd26",
    "submission": "/**\n * @param {number} X\n * @param {number} Y\n * @param {number[][]} circles\n * @return {boolean}\n */\n\nclass UnionFind {\n    constructor(n) {\n        this.parent = Array.from({length: n}, (_, i) => i);\n        this.rank = new Array(n).fill(0);\n    }\n\n    find(x) {\n        if (this.parent[x] !== x) {\n            this.parent[x] = this.find(this.parent[x]);  // Path compression\n        }\n        return this.parent[x];\n    }\n\n    union(x, y) {\n        let rootX = this.find(x);\n        let rootY = this.find(y);\n        \n        if (rootX === rootY) return;\n        \n        // Union by rank\n        if (this.rank[rootX] < this.rank[rootY]) {\n            this.parent[rootX] = rootY;\n        } else if (this.rank[rootX] > this.rank[rootY]) {\n            this.parent[rootY] = rootX;\n        } else {\n            this.parent[rootY] = rootX;\n            this.rank[rootX]++;\n        }\n    }\n\n    connected(x, y) {\n        return this.find(x) === this.find(y);\n    }\n}\n\nconst checkCirclesMeet = ([x1,y1,r1],[x2,y2,r2]) => {\n    const dist = (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\n    return dist <= (r1+r2)*(r1+r2);\n}\n\nconst isTopLeft = (X,Y,[x1,y1,r1]) => (x1-r1 <= 0 || y1+r1 >=Y);\nconst isBottomRight = (X,Y,[x1,y1,r1]) => (x1+r1 >=X || y1-r1<=0);\n\nconst isBlockingCircle = (X,Y,[x1,y1,r1]) => {\n    return (x1-r1 <= 0 || y1+r1 >=Y) && (x1+r1 >=X || y1-r1<=0)\n}\n\nvar canReachCorner = function(X, Y, circles) {\n    const n = circles.length;\n    const uf = new UnionFind(n+2);\n\n    for(let i=0;i<n;i++){\n        if(isBlockingCircle(X,Y,circles[i])) return false;\n        if(isTopLeft(X,Y,circles[i])) uf.union(0,i+1);\n        if(isBottomRight(X,Y,circles[i])) uf.union(n+1,i+1);\n        for(let j=i+1;j<n;j++){\n            if(checkCirclesMeet(circles[i],circles[j])) uf.union(i+1,j+1);\n        }\n    }\n\n    return !uf.connected(0,n+1);\n};",
    "submit_ts": "1722136364",
    "subm_id": "1335732118"
}