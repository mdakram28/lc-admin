{
    "username": "66glory-CUNY",
    "submission": "/*\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n\nusing namespace std;\nconst int N = 105;\n\nusing ll = long long;\nvoid dead() {\n    vector<int> a;\n    for(int i = 0; i < 1000000; i++) a.push_back(i);\n}\n\nint dp[N][N];\nint dfs(vector<int>& a, int l, int r, int k) {     \n    if(l > r) { //success match all\n        return 1;\n    }\n    if(dp[l][r][k] != -1) {\n        return dp[l][r][k];\n    }\n    \n    int ans = 0;   \n    if(l >= a[l] && (l - a[l]) % 2 == 0 && l - a[l] <= k) {\n        for(int i = l + 1; i <= r; i += 2) {\n            int t = dfs(a, l + 1, i - 1, k) & dfs(a, i + 1, r, k + (i - l + 1));\n            if(t) {\n                ans = 1;\n            }\n        }      \n    }\n    cout << l << \" \" << r << \" \"  << k << \"   | \" << ans << endl;\n    return dp[l][r][k] = ans;\n} \n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n + 1);\n    for(int i = 1; i <= n; i++) cin >> a[i];\n\n    for(int i = 0; i <= n; i++) {\n        for(int j = 0; j <= n; j++) {\n            for(int k = 0; k <= n; k++) {\n                dp[i][j][k] = -1;\n            }\n        }\n    }\n    \n    dfs(a, 1, 6, 0);\n\n    for(int l = 1; l <= n; l++) {\n        for(int r = l + 1; r <= n; r += 2) {\n            for(int k = 0; k <= l - 1; k += 2) {\n                //dfs(a, l, r, k);\n                //if(dp[l][r][k]) {\n                  //cout << l << \" \" << r << \" \" << k << endl;\n                //}\n            }\n        }\n    }\n\n    vector<vector<bool>> dp1(n + 1, vector<bool>(n + 1, false));\n    dp1[0][0] = true;\n    int ans = 0;\n    for(int r = 1; r <= n; r++) {\n        for(int l = r - 1; l >= 1; l -= 2) {\n            for(int k = 0; k <= l - 1; k += 2) {\n                if(dp1[l - 1][k] && dp[l][r][k]) {\n                    dp1[r][k + (r - l + 1)] = true;\n                }\n            }\n        }\n        for(int k = 0; k <= r; k++) {\n            dp1[r][k] = dp1[r][k] | dp1[r - 1][k];\n        }\n    }\n\n    for(int k = 0; k <= n; k++) {\n        if(dp1[n][k]) ans = max(ans, k);\n    }\n    printf(\"%d\\n\", ans / 2);\n}   \n\nint main() {\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n    return 0;\n}\n\n/*\n1\n6\n1 3 3 2 4 5 \n*/\n\n\nconst int N = 10010, S = 55, M = 1000010;\nint q[N * S], ne[N * S];\nint c[N * S], len[N * S];\nint tr[N * S][26];\nint n, idx;\n\nvoid insert(string& str, int x) {\n    int p = 0;\n    for (int i = 0; i < str.size(); i ++ )\n    {\n        int t = str[i] - 'a';\n        if (!tr[p][t]) tr[p][t] = ++ idx;\n        p = tr[p][t];\n    }\n    \n    if(c[p] == 0)\n        c[p] = x;\n    else c[p] = min(c[p], x);\n    len[p] = str.size();\n}\n\nvoid build() {\n    int hh = 0, tt = -1;\n    for (int i = 0; i < 26; i ++ )\n        if (tr[0][i])\n            q[ ++ tt] = tr[0][i];\n    while (hh <= tt)\n    {\n        int t = q[hh ++ ];\n        for (int i = 0; i < 26; i ++ )\n        {\n            int p = tr[t][i];\n            if (!p) tr[t][i] = tr[ne[t]][i];\n            else\n            {\n                ne[p] = tr[ne[t]][i];\n                q[ ++ tt] = p;\n            }\n        }\n    }\n}\n\nbool yes = false;\nvoid init() {\n    if(yes) return;\n    yes = true;\n    memset(tr, 0, sizeof tr);\n    memset(c, 0, sizeof c);\n    memset(ne, 0, sizeof ne);\n    idx = 0;\n}\n\nvoid reset() {\n    for(int i = 0; i <= idx + 1; i++) {\n        c[i] = 0;\n        ne[i] = 0;\n        len[i] = 0;\n        for(int j = 0; j < 26; j++) {\n            tr[i][j] = 0;\n        }\n    }\n    idx = 0;\n}\n\n\nclass Solution {\npublic:\n    int minimumCost(string s, vector<string>& words, vector<int>& costs) {\n        int n = s.size();\n        init();\n        for(int i = 0; i < words.size(); i++) insert(words[i], costs[i]);\n        build();\n        int INF = 1e9;\n        vector<int> dp(n + 1, INF);\n        dp[0] = 0;\n        for(int i = 1, j = 0; i <= s.size(); i++) {\n            int t = s[i - 1] - 'a';\n            while(j && !tr[j][t]) j = ne[j];\n            if(tr[j][t]) j = tr[j][t];\n            int p = j;\n            while (p)\n            {\n                \n                if(c[p] > 0 && dp[i - len[p]] != INF) {\n                    int sz = len[p];\n                    dp[i] = min(dp[i], dp[i - sz] + c[p]);\n                }\n                p = ne[p];\n            }\n        }\n        \n        reset();\n        return dp[n] == INF ? -1 : dp[n];\n        \n    }\n};",
    "submit_ts": "1720321563",
    "subm_id": "1312326224"
}