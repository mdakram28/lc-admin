{
    "username": "202101008",
    "submission": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minFlips(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n\n        // Initialize a visited matrix\n        vector<vector<int>> visited(n, vector<int>(m, 0));\n\n        // Dictionary to hold counts of 0s and 1s based on group size\n        unordered_map<int, vector<pair<int, int>>> groupCounts;\n\n        // Process each cell\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (visited[i][j] == 0) {\n                    // Define the four symmetric positions\n                    pair<int, int> pos1 = {n - 1 - i, j};\n                    pair<int, int> pos2 = {i, m - 1 - j};\n                    pair<int, int> pos3 = {n - i - 1, m - j - 1};\n                    pair<int, int> pos4 = {i, j};\n\n                    // Mark all symmetric positions as visited\n                    visited[pos1.first][pos1.second] = 1;\n                    visited[pos2.first][pos2.second] = 1;\n                    visited[pos3.first][pos3.second] = 1;\n                    visited[pos4.first][pos4.second] = 1;\n\n                    // Collect all symmetric positions into a set\n                    set<pair<int, int>> positions = {pos1, pos2, pos3, pos4};\n\n                    // Count number of 0s and 1s in these positions\n                    int count0 = 0;\n                    int count1 = 0;\n                    for (const auto& pos : positions) {\n                        if (grid[pos.first][pos.second] == 1) {\n                            count1++;\n                        } else {\n                            count0++;\n                        }\n                    }\n\n                    // Store counts based on the number of unique positions\n                    groupCounts[positions.size()].emplace_back(count0, count1);\n                }\n            }\n        }\n\n        int totalFlips = 0;\n\n        // Process groups of size 4\n        if (groupCounts.find(4) != groupCounts.end()) {\n            for (const auto& [count0, count1] : groupCounts[4]) {\n                totalFlips += min(count0, count1);\n            }\n        }\n\n        // Process groups of size 1\n        if (groupCounts.find(1) != groupCounts.end()) {\n            int totalCount0 = 0;\n            int totalCount1 = 0;\n\n            for (const auto& [count0, count1] : groupCounts[1]) {\n                totalCount0 += count0;\n                totalCount1 += count1;\n            }\n\n            int remainder = totalCount1 % 4;\n            int minFlipsToDivisible = INT_MAX;\n\n            if (totalCount0 >= 4 - remainder) {\n                minFlipsToDivisible = 4 - remainder;\n            }\n\n            int extraFlips = remainder;\n            totalFlips += min(extraFlips, minFlipsToDivisible);\n        }\n\n        // Process groups of size 2\n        if (groupCounts.find(2) != groupCounts.end()) {\n            int matchingPairs = 0;\n            int specialCaseCount = 0;\n\n            for (const auto& [count0, count1] : groupCounts[2]) {\n                if (count0 == count1) {\n                    matchingPairs++;\n                }\n                if (count1 == 2) {\n                    specialCaseCount++;\n                }\n            }\n\n            if (specialCaseCount % 2 != 0) {\n                if (matchingPairs == 0) {\n                    totalFlips += 2;\n                }\n            }\n\n            totalFlips += matchingPairs;\n        }\n\n        return totalFlips;\n    }\n};\n",
    "submit_ts": "1722698715",
    "subm_id": "1343189452"
}