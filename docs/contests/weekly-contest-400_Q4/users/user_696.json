{
    "username": "Rajdeep_Nagar",
    "submission": "/*\n absolute diff will be minimum if \n\n\n(nums[i] & nums[i+1] & nums[i+2] & ...) is close to k == k\n\n\n\n*/\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        \n    int n = nums.size();\n        \n        \n    if (n==0) \n        return abs(k);\n        \n         unordered_map<int, int> mp;\n        \n    for (int bit : countBits(nums[0])) {\n        mp[bit]++;\n    }\n\n    int temp = nums[0];\n        \n    int ans = abs(temp-k);\n\n  \n    int l=0, r=0;\n        \n        \n    while (r<n){\n        if (temp>k || l>r) {\n            r++;\n            if (r>=n) \n                break;\n            \n            for (int bit : countBits(nums[r])) {\n                mp[bit]++;\n            }\n        } else {\n            for (int bit : countBits(nums[l])) {\n                mp[bit]--;\n                if (mp[bit] == 0) {\n                    mp.erase(bit);\n                }\n            }\n            l++;\n        }\n        \n        int w= r-l+1;\n        \n        int res = 0;\n        \n    for (auto it : mp) {\n        \n        int key=it.first;\n        \n        int count=it.second;\n        \n        if (count==w) {\n            res|=(1 << key);\n        }\n    }\n        \n        temp=res;\n\n        if (l<=r) {\n            ans = min(ans, abs(temp-k));\n        }\n    }\n\n    return ans;\n        \n    }\n    \n    \n    vector<int> countBits(int x) {\n\n    vector<int> v;\n    \n    for (int i = 0; x > 0; ++i) {\n        if (x & 1) {\n            v.push_back(i);\n        }\n        x >>= 1;\n    }\n    return v;\n}\n\n    \n    \n};",
    "submit_ts": 1717299671.0
}